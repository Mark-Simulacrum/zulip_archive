[
    {
        "content": "<p>i was looking at this sample program and became a bit confused as to why miri and/or stacked borrows behaves the way it does: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=b185c339f139013a74929bc2b39b9aa2\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=b185c339f139013a74929bc2b39b9aa2</a></p>\n<p>specifically, moving a box (or reference) itself seems to invalidate pointers derived from it. somehow despite having read the Stacked Borrows docs, which specifically mentions retagging on assignments, i had only expected that to happen on actual reads or writes through the pointer, or on passing the pointer as a function argument.</p>\n<p>so my question is, given that stacked borrows has worked this way pretty much the whole time, what role does this retagging play? is it required for soundness or just for some optimizations?</p>\n<p>(also, this feels like a big shift in my understanding of stacked borrows- i wonder how common this misunderstanding is or how i might have avoided it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>)</p>",
        "id": 270935565,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644212735
    },
    {
        "content": "<p>a further question: i ran into this trying to fix some miri errors in some custom memory allocation code, where the original problem was that i was forming a raw pointer into a Box, pushing the Box into a Vec (retagging it), and then using the raw pointer.</p>\n<p>miri stops complaining if i push the Box first, then form the raw pointer from it where it lives in the Vec. and, miri even continues to accept my program when i <em>grow</em> the Vec before using the raw pointer, presumably because this is an untyped move.</p>\n<p>are untyped moves okay to rely on like this? (and, is that maybe a useful loophole around the typed assignment retagging above?) or is this something uncertain/to be avoided?</p>",
        "id": 270936438,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644213769
    },
    {
        "content": "<blockquote>\n<p>specifically, moving a box (or reference) itself seems to invalidate pointers derived from it.</p>\n</blockquote>\n<p>I recall reading about this recently with the OwningRef bug. Moving a box does invalidate pointers to the contents, while moving a reference invalidates pointers derived from that reference, but not pointers derived from the parent. This matches the behavior you get in safe code, but it is for sure an issue for code that uses <code>Box</code> as a <code>StableDeref</code> container.</p>",
        "id": 270942167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644219782
    },
    {
        "content": "<p>Regarding the example with a <code>Vec&lt;Box&lt;T&gt;&gt;</code>, I think it might be related to the fact that miri does not give any errors on this code, which differs from yours only in using a <code>Box&lt;Box&lt;T&gt;&gt;</code> instead of <code>Box&lt;T&gt;</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"k\">i32</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270942701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644220223
    },
    {
        "content": "<p>That is, Miri does not invalidate pointers behind two layers of indirection, just one</p>",
        "id": 270942827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644220326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Stacked.20borrows.20retagging.20on.20assignments/near/270935565\">said</a>:</p>\n<blockquote>\n<p>i had only expected that to happen on actual reads or writes through the pointer, <strong>or on passing the pointer as a function argument</strong></p>\n</blockquote>\n<p>The latter is a paramount point for optimizations, of course, and from there, I'd find it more error-prone / surprising if moving to a function parameter or moving to a new local exhibited different behavior.</p>\n<p>For instance, consider, the following being fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">slot</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">slot</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and then compare it against:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">- let slot: &amp;mut  (Box&lt;_&gt;) = ...;</span><span class=\"w\"></span>\n<span class=\"gi\">+ let slot: &amp;Cell &lt;Box&lt;_&gt;&gt; = ...;</span><span class=\"w\"></span>\n<span class=\"w\"> </span> â€¦<span class=\"w\"></span>\n<span class=\"gd\">- *slot = b;</span><span class=\"w\"></span>\n<span class=\"gi\">+ slot.set(b);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It would suddenly become UB!</p>\n<p>Or also:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">SOME_THREAD_LOCAL</span><span class=\"p\">.</span><span class=\"n\">with</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">it</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would be OK, but then:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span>     dbg!(unsafe { *p });<span class=\"w\"></span>\n<span class=\"gi\">+     drop(b); // Safety: this is fine because `p` is not used anymore</span><span class=\"w\"></span>\n<span class=\"w\"> </span> });<span class=\"w\"></span>\n</code></pre></div>\n<p>wouldn't (because <code>b</code> gets <em>moved</em> into the closure, which is then fed as a function parameter to <code>LocalKey::with()</code>).</p>\n<hr>\n<p>So, with no technical argument whatsoever, just the practical and subjective point of a view of considering something to be footgunny, I'd find it worse (since too footgunny) if passing some unaliased thing by value as a function parameter invalidated derived pointers, but if moving it around locally didn't.</p>",
        "id": 270968332,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644235727
    },
    {
        "content": "<blockquote>\n<p>so my question is, given that stacked borrows has worked this way pretty much the whole time, what role does this retagging play? is it required for soundness or just for some optimizations?</p>\n</blockquote>\n<p>all of stacked borrows is just for some optimizations. :) Rust would be totally sound without if -- if we removed all the <code>noalias</code>.</p>",
        "id": 271009856,
        "sender_full_name": "RalfJ",
        "timestamp": 1644253729
    },
    {
        "content": "<blockquote>\n<p>So, with no technical argument whatsoever, just the practical and subjective point of a view of considering something to be footgunny, I'd find it worse (since too footgunny) if passing some unaliased thing by value as a function parameter invalidated derived pointers, but if moving it around locally didn't.</p>\n</blockquote>\n<p>that's basically the reason why retagging happens on assignment -- argument passing is seen as a kind of (parallel) assignment, and we want to cover all cases consistently</p>",
        "id": 271009940,
        "sender_full_name": "RalfJ",
        "timestamp": 1644253772
    },
    {
        "content": "<p>ah, that's a very good point, thank you. so since this is primarily about consistency between assignment and argument passing, it's probably reasonable to (continue to) rely on the untyped move in Vec resizing not doing a retag, i think</p>",
        "id": 271020217,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644257878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Stacked.20borrows.20retagging.20on.20assignments/near/270942827\">said</a>:</p>\n<blockquote>\n<p>That is, Miri does not invalidate pointers behind two layers of indirection, just one</p>\n</blockquote>\n<p>i think this is slightly different, and it would be equivalent to moving the Vec. the Vec resize directly moves the Box itself, just not via a typed copy</p>",
        "id": 271020358,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644257937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Stacked.20borrows.20retagging.20on.20assignments/near/271020217\">said</a>:</p>\n<blockquote>\n<p>ah, that's a very good point, thank you. so since this is primarily about consistency between assignment and argument passing, it's probably reasonable to (continue to) rely on the untyped move in Vec resizing not doing a retag, i think</p>\n</blockquote>\n<p>yeah... it might not be fully untyped (it probably uses <code>copy_nonoverlapping</code> which has type information available and hence might require the data to satisfy the validity invariant -- I dont think we have decided this yet), but I dont see a good reason to try and do retagging here</p>",
        "id": 271101590,
        "sender_full_name": "RalfJ",
        "timestamp": 1644312773
    },
    {
        "content": "<p>I thought we had an issue somewhere discussing whether copy_nonoverlapping requires the validity invariant... but I cant find it right now :/</p>",
        "id": 271101826,
        "sender_full_name": "RalfJ",
        "timestamp": 1644312902
    },
    {
        "content": "<p>ah here we go: <a href=\"https://github.com/rust-lang/rust/issues/63159\">https://github.com/rust-lang/rust/issues/63159</a><br>\nlooks like making it a typed copy would probably be a breaking change so is unlikely to happen.<br>\nof course, a separate question is whether <code>Vec</code> guarantees that it will keep using copy_nonoverlapping.</p>",
        "id": 271102257,
        "sender_full_name": "RalfJ",
        "timestamp": 1644313120
    },
    {
        "content": "<p>i guess in the worst case, if Vec were to start retagging its elements on realloc, i would just need some alternative way to represent the Boxes such that moving them doesn't do any invalidation? a raw pointer (wrapped in a newtype that impls Drop) should do that since raw pointers don't do retagging?</p>",
        "id": 271171172,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644345085
    },
    {
        "content": "<p>yeah, only Box and references do retagging.<br>\nbut it is an open question whether retagging recurses into fields, and into <em>private</em> fields specifically... there's no clear answer for any of these questions since it boils down to \"more retagging = more optimizations, but also more UB for unsafe code to run into\".<br>\nNonNull and types like it are definitely safe though. and I think a NonOwningBox (a smart ptr with auto-deallocation but no aliasing guarantees) is something that comes up every now and then, seems generally useful.</p>",
        "id": 271259583,
        "sender_full_name": "RalfJ",
        "timestamp": 1644404297
    },
    {
        "content": "<p>of course we could also decide that Box should not make any aliasing guarantees, but we <em>do</em> emit <code>noalias</code> for it so there is at least an intent of uniqueness here (it also used a ptr type called <code>Unique</code> internally, which seems like a pretty clear intent)</p>",
        "id": 271259644,
        "sender_full_name": "RalfJ",
        "timestamp": 1644404340
    },
    {
        "content": "<blockquote>\n<p>and I think a NonOwningBox (a smart ptr with auto-deallocation but no aliasing guarantees) is something that comes up every now and then, seems generally useful.</p>\n</blockquote>\n<p>I think that's exactly what this crate tries to provide <a href=\"https://crates.io/crates/aliasable\">https://crates.io/crates/aliasable</a><br>\nI haven't used it, but I saw it mentioned in this comment <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133#issuecomment-1025058878\">https://github.com/rust-lang/unsafe-code-guidelines/issues/133#issuecomment-1025058878</a></p>",
        "id": 271344750,
        "sender_full_name": "Nick12",
        "timestamp": 1644439535
    },
    {
        "content": "<p>yeah this can be done as a user crate</p>",
        "id": 271405033,
        "sender_full_name": "RalfJ",
        "timestamp": 1644484963
    },
    {
        "content": "<p>(also the <code>Unique</code> in <code>Vec</code> is not \"weaponized\" by Miri -- yet)</p>",
        "id": 271405047,
        "sender_full_name": "RalfJ",
        "timestamp": 1644484976
    },
    {
        "content": "<p>FYI, Miri currently reports UB in ~10% of crates on <a href=\"http://crates.io\">crates.io</a>. I don't know if this is generally known. But I think that figure is high enough to warrant a lot of caution.</p>",
        "id": 271711248,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644702398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> interesting, how did you get that number? is there any classification of which kind of UB? are these truly all UB errors and not \"operation not supported\"?</p>",
        "id": 271711331,
        "sender_full_name": "RalfJ",
        "timestamp": 1644702547
    },
    {
        "content": "<p>That's the figure for the number of crates where I see \"Undefined Behavior\" in the output. I've read every one of the error messages so I'm sure there are no false positives, in the sense you're bringing up.</p>\n<p>~60% of crates have some kind of error.</p>",
        "id": 271713837,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644706031
    },
    {
        "content": "<p>No numbers, but my instinct is that the majority of errors are pointer invalidation</p>",
        "id": 271713900,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644706104
    },
    {
        "content": "<p>The sample this is based on is currently the top ~5,500 top crates according to the \"recent downloads\" metric</p>",
        "id": 271713971,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644706228
    },
    {
        "content": "<p>And that's probably just counting in their test suites... (The vast majority of the cases that drive numbers like \"60% of C++ security bugs are memory safety related\" are too complex to be covered by their test suites...)</p>",
        "id": 271722877,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644720227
    },
    {
        "content": "<p>I don't think that logic applies. Most (all? it could be all.) of the cases where I've seen code that doesn't follow SB is unconditional. There's no clever input, no edge condition. Just any call to what is often a very core function uses a pointer outside of its provenance, or uses an invalidated pointer which is never valid.</p>\n<p>(what I share in the dark-arts community Discord channel is definitely not a representative sample)</p>",
        "id": 271729110,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644730882
    },
    {
        "content": "<p>Sure, but the remaining 90% may only pass because the invalid use doesn't happen in their test suites.</p>",
        "id": 271781845,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644809956
    },
    {
        "content": "<p>I agree this is possible, but common library crates are hit from a lot of angles, and every time I've detected UB in a crate through a dependent the originator of the UB either detects the same UB in its test suite, detects different UB in its test suite, or attempts an unsupported operation before hitting the code path that is UB.</p>\n<p>Just speaking based on what I have evidence of.</p>\n<p>If my rustc PR ever gets merged, we'll have slightly better UB checking in <code>core</code> which could augment fuzzers. That might be something of a test of your hypothesis.</p>",
        "id": 272059798,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644972159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> so specifically this is in the output of <code>cargo miri test</code>? that might be nice data to do some statistics over -- in particular, I assume those aren't all SB failures</p>",
        "id": 272335537,
        "sender_full_name": "RalfJ",
        "timestamp": 1645138055
    },
    {
        "content": "<p>Yes, <code>cargo miri test</code>.<br>\nMost are.</p>",
        "id": 272337809,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645139508
    },
    {
        "content": "<p>I've been making notes when I check the outputs. Failures in dependencies are easy to recognize, as are non-SB failures.<br>\nI count 185 distinct root crates with SB failures. Most crates (unsurprisingly) fail because there's an SB failure in a dependency. <code>bytes</code> is the biggest contributor, but even it only contributes 71 failures.</p>\n<p>I'm not particularly enthused about manually diagnosing 185 distinct failures by poking through the source, thus my interest in improving Miri's diagnostics.</p>",
        "id": 272340309,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645141268
    },
    {
        "content": "<p>The run of top 10,000 crates finished yesterday or something like that. I'm going to try writing this up as a blog post, but in the meantime if someone wants the logs from failed crates they're here. <a href=\"/user_uploads/4715/8I_kf8y7feaaDiIfynn3T5xz/miri-failed-crates.tar.gz\">miri-failed-crates.tar.gz</a></p>",
        "id": 272553722,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645317772
    },
    {
        "content": "<p>would be interesting to see the results of a <code>-Zmiri-disable-stacked-borrows</code> run :)</p>",
        "id": 272602133,
        "sender_full_name": "RalfJ",
        "timestamp": 1645374638
    },
    {
        "content": "<p>You can scroll the Cause column here and pick out by eye the things that would have failed without SB. Anything without a cause is SB. <a href=\"https://github.com/saethlin/miri-tools/blob/main/README.md\">https://github.com/saethlin/miri-tools/blob/main/README.md</a></p>\n<p><code>bindgen</code> and <code>mem::uninitialized</code> dominate non-SB problems.</p>",
        "id": 272624157,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645399660
    },
    {
        "content": "<p>Also I was surprised by the number of people who seem to have replaced <code>mem::uninitialized()</code> with <code>MaybeUninit::uninit().assume_init()</code>. About half of the \"incorrect <code>assume_init</code>\" crates do that.</p>",
        "id": 272624351,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645399878
    },
    {
        "content": "<p>that's sad :( we have lints and docs explicitly pointing this out as bad, honestly not sure what else we could have done here...</p>",
        "id": 272724852,
        "sender_full_name": "RalfJ",
        "timestamp": 1645470202
    },
    {
        "content": "<p>we could strengthen the lint to also recognize when there is a <code>let x = MaybeUninit::uninit(); x.assume_init()</code>... not sure how many more cases that would catch though</p>",
        "id": 272725231,
        "sender_full_name": "RalfJ",
        "timestamp": 1645470402
    },
    {
        "content": "<p>(Unimportant comment, feel free to skip)</p>\n<p>I'm saddened yet amused by \"Cause: Please don't use this many macros to write unsafe code\".</p>",
        "id": 272725809,
        "sender_full_name": "scottmcm",
        "timestamp": 1645470749
    },
    {
        "content": "<blockquote>\n<p>honestly not sure what else we could have done here...</p>\n</blockquote>\n<p>Honestly I think best way out is to get more people to run Miri. So far I've patched 14 crates (not including <code>core</code>/<code>alloc</code>/<code>rustc</code>) that used to fail Miri, and I've been surprised how often a maintainer either asks me to add Miri to CI or turn on -Ztag-raw-pointers in CI, or does so immediately after merging my PR. Overall, I think we should get more people to use Miri. But I'm really not sure how to do this, the only common interfaces we push people through are <a href=\"http://crates.io\">crates.io</a> and the <code>cargo</code>/<code>rustc</code>. I'm not sure it makes sense to advertise Miri through those.</p>\n<p>The other is that Miri really needs to be a lot better. The current output for anything related to SB is very hard for people to understand; I know of one case where someone stopped running Miri entirely on their unsafe code because they found SB too confusing. And Miri emits a lot of <code>unsupported operation</code> errors. We should probably add a lot more shims so that Miri can work on more code. Here are the top 15 unsupported operations from the run I did, collectively they are 1545 of 1999 such errors:</p>\n<div class=\"codehilite\"><pre><span></span><code>     27 non-default mode 0o600 is not supported\n     28 can&#39;t call foreign function: socketpair\n     31 unsupported Linux dlsym: epoll_create1\n     35 can&#39;t call foreign function: realpath\n     44 can&#39;t call foreign function: localtime_r\n     45 can&#39;t call foreign function: openat\n     49 can&#39;t call foreign function: gnu_get_libc_version\n     50 can&#39;t execute syscall with ID 291\n     87 can&#39;t call foreign function: socket\n     97 io error ReadOnlyFilesystem cannot be translated into a raw os error\n    103 can&#39;t call foreign function: readdir64\n    153 can&#39;t call foreign function: __xpg_strerror_r\n    167 inline assembly is not supported\n    244 can&#39;t call foreign function: pipe2\n    385 can&#39;t call foreign function: epoll_create1\n</code></pre></div>",
        "id": 272755568,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645499232
    },
    {
        "content": "<p>...Okay, we probably can teach Miri about <code>localtime_r</code>, at least. :P</p>",
        "id": 272768130,
        "sender_full_name": "Jubilee",
        "timestamp": 1645514821
    },
    {
        "content": "<p>True or not, the <em>reputation</em> of miri is that it gives false positives, false negatives, and doesn't interact with foreign code. This makes it very unattractive to bother with for a lot of projects.</p>\n<p>One way to make miri be used more is if it was a flag on cargo test. just <code>cargo test --miri</code> and then you get a miri run. It should be just that easy to make a basic miri run happen. that would go a long way.</p>",
        "id": 272769291,
        "sender_full_name": "Lokathor",
        "timestamp": 1645516142
    },
    {
        "content": "<p>I think we could teach Miri about almost everything in that list. Shims for networking might be a bit dicey and inline assembly might never work, but most of what Miri can't do is common \"pure\" functions, basic filesystem stuff or launching subprocesses (<code>pipe2</code> + <code>gnu_get_libc_version</code>).</p>\n<p>Emphasis on the <em>we</em> though. I have other priorities for the moment.</p>\n<p>But additionally, I did this whole run without passing <code>-Zmiri-panic-on-unsupported</code> so it may be biased in subtle ways, though as far as I'm aware it's still the best survey of unsupported but needed shims that we have.</p>",
        "id": 272824398,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645545911
    },
    {
        "content": "<p><code>readdir64()</code> is probably my fault (<a href=\"https://github.com/rust-lang/rust/pull/92778\">https://github.com/rust-lang/rust/pull/92778</a>), I'll try to write a Miri stub</p>",
        "id": 272857532,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1645559550
    },
    {
        "content": "<p>FYI: <a href=\"https://github.com/rust-lang/miri/issues/1966\">https://github.com/rust-lang/miri/issues/1966</a></p>",
        "id": 272860735,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645561040
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/miri/pull/1981\">https://github.com/rust-lang/miri/pull/1981</a></p>",
        "id": 272876697,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1645569466
    },
    {
        "content": "<p>I suppose this is not quite on topic, but in the same PR <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> you note that</p>\n<blockquote>\n<blockquote>\n<p>addr_of!((*ptr).field) requires ptr to point to a properly sized/aligned region</p>\n</blockquote>\n<p>Indeed, <code>*ptr</code> asserts that <code>ptr</code> is dereferencable (for the size and alignment determined by its type).</p>\n</blockquote>\n<p>Is there a reason this <em>should</em> be this way? I can't imagine a possible codegen impact for only requiring (the align and) the size up to the point thats read, which would allow the more naively written version of this work.</p>",
        "id": 272903956,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645590768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> well, those assume_init things would show up even if people disable stacked borrows. maybe it was a mistake to enable stacked borrows by default (the other errors miri raises are much easier to understand and basically never \"false positives\" -- stacked borrows OTOH will definitely need tweaking and some of those errors will be resolved by a better model)</p>",
        "id": 272968372,
        "sender_full_name": "RalfJ",
        "timestamp": 1645631934
    },
    {
        "content": "<p>for an ecosystem-wide initiative (that does not have the goal of evaluating stacked borrows itself) I would currently definitely recommend disabling stacked borrows, and possibly <em>enabling</em> the uninit integer check -- I do wonder what the impact of that one is, and it seems increasingly likely that the status quo (with the reference saying uninit integers are UB) is here to stay</p>",
        "id": 272968894,
        "sender_full_name": "RalfJ",
        "timestamp": 1645632064
    },
    {
        "content": "<p>The run that I did had the uninit integer check on. I had <code>MIRIFLAGS</code> set to <code>-Zmiri-disable-isolation -Zmiri-ignore-leaks -Zmiri-check-number-validity -Zmiri-tag-raw-pointers</code>. Unfortunately, <code>-Zmiri-ignore-leaks</code> is kinda required as well for a good user experience, because in a lot of situations threads are leaked.</p>\n<p>I'd definitely be in favor of altering the Miri defaults to check for uninit integers and not do any SB. The only thing that gives me pause is that it seems like elements of SB have crept into the documentation and/or are so-called Library UB. For example, <code>slice::as_ptr</code> is documented to not be valid to mutate through, and you're not allowed to index past the end of a slice with <code>slice::get_unchecked</code>. Breaking those rules is only detected with SB checking enabled. But I'm almost always willing to let some stuff by in order to improve the signal-to-noise ratio. Such is the role of dynamic checkers.</p>",
        "id": 272970054,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645632484
    },
    {
        "content": "<p>another concern is that this will make it impossible to play with SB on the playground</p>",
        "id": 272970478,
        "sender_full_name": "RalfJ",
        "timestamp": 1645632681
    },
    {
        "content": "<p>plus, by now many people expect SB to be on by default...</p>",
        "id": 272970490,
        "sender_full_name": "RalfJ",
        "timestamp": 1645632691
    },
    {
        "content": "<p>Maybe this is an aside, but why is the default to not tag raw pointers? This has always struck me as a confusing middle ground.</p>\n<p>WRT playground: <a href=\"https://github.com/integer32llc/rust-playground/pull/781\">https://github.com/integer32llc/rust-playground/pull/781</a></p>",
        "id": 272973680,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645634055
    },
    {
        "content": "<p>when designing stacked borrows I wanted to be sure I can handle ptr-int-ptr roundtrips where provenance is lost, so to be sure that case works I made all raw ptrs lose provenance (so this becomes a pretty common case).<br>\nalso that gives us a quite clear marker for when to \"lose\" the provenance, in a place where we have reliable type information (since the input operand is a reference) -- attempting to do the same only when a raw ptr is actually cast to an integer is a lot harder, since at that point we do not have reliable type information any more</p>",
        "id": 272990949,
        "sender_full_name": "RalfJ",
        "timestamp": 1645640553
    },
    {
        "content": "<p>also pragmatically speaking, theres a lot of code that fails with raw ptr tagging due to the use of int-to-ptr casts, so it would make miri even harder to apply to real code</p>",
        "id": 272991162,
        "sender_full_name": "RalfJ",
        "timestamp": 1645640646
    },
    {
        "content": "<blockquote>\n<p>theres a lot of code that fails with raw ptr tagging due to the use of int-to-ptr casts</p>\n</blockquote>\n<p>This is an interesting statement. I don't know why I never though to do this little experiment, but here we are:</p>\n<div class=\"codehilite\"><pre><span></span><code>$ rg &quot;but parent tag &lt;\\d+&gt;&quot; --files-with-matches | wc -l\n204\n$ rg &quot;but parent tag &lt;untagged&gt;&quot; --files-with-matches | wc -l\n125\n</code></pre></div>\n<p>I'm not disagreeing with you that this is a lot of code, but I think this indicates that pointer invalidation is currently a more broadly-impacting issue than int-to-ptr casts. Just a curiosity more than anything else at this stage.</p>",
        "id": 273006329,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645647755
    },
    {
        "content": "<blockquote>\n<p>The only thing that gives me pause is that it seems like elements of SB have crept into the documentation and/or are so-called Library UB</p>\n</blockquote>\n<p>Aren't <code>addr_of</code> and <code>addr_of_mut</code> needed only because of SB?</p>",
        "id": 273029522,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1645660829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Stacked.20borrows.20retagging.20on.20assignments/near/273029522\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The only thing that gives me pause is that it seems like elements of SB have crept into the documentation and/or are so-called Library UB</p>\n</blockquote>\n<p>Aren't <code>addr_of</code> and <code>addr_of_mut</code> needed only because of SB?</p>\n</blockquote>\n<p>Also because of partial initialization, and unaligned fields (inside <code>repr(packed)</code>)</p>",
        "id": 273033370,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645663740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Stacked.20borrows.20retagging.20on.20assignments/near/273029522\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The only thing that gives me pause is that it seems like elements of SB have crept into the documentation and/or are so-called Library UB</p>\n</blockquote>\n<p>Aren't <code>addr_of</code> and <code>addr_of_mut</code> needed only because of SB?</p>\n</blockquote>\n<p>I find it hard to imagine an aliasing model that would not need them. SB has its flaws, but I dont think this is one of them.</p>",
        "id": 273034504,
        "sender_full_name": "RalfJ",
        "timestamp": 1645664507
    },
    {
        "content": "<blockquote>\n<p>SB has its flaws, but I dont think this is one of them.</p>\n</blockquote>\n<p>Would love to pick your brain sometime about which flaws you have in mind. From an end-user perspective it has been a breeze working with SB imho :) Maybe a nice topic for your next blog post? <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 273055854,
        "sender_full_name": "Pointerbender",
        "timestamp": 1645688043
    },
    {
        "content": "<blockquote>\n<p>I find it hard to imagine an aliasing model that would not need them. SB has its flaws, but I dont think this is one of them.</p>\n</blockquote>\n<p>This was definitely not a criticism :) I love SB, even though it makes writing big chunks of correct unsafe code pretty hard</p>",
        "id": 273139637,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1645731837
    },
    {
        "content": "<p>I didnt take it as unfair criticism, no worries :)</p>",
        "id": 273158236,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741596
    },
    {
        "content": "<p>but I do think SB has quirks we need to fix and it'd be bad if addr_of was just motivated by those quirks, so I wanted to be sure we all agree that is not the case</p>",
        "id": 273158269,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741619
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> there's an entire list of flaws at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aopen+is%3Aissue+label%3AT-stacked-borrows\">https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aopen+is%3Aissue+label%3AT-stacked-borrows</a> ;)</p>",
        "id": 273158308,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741645
    },
    {
        "content": "<p>but the biggest one by far is <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133\">https://github.com/rust-lang/unsafe-code-guidelines/issues/133</a>, I think, and <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a></p>",
        "id": 273158423,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741704
    },
    {
        "content": "<p>I think those are the main reasons for why 'it makes writing big chunks of correct unsafe code pretty hard'. and I think we can do better.<br>\nmaking writing unsafe code hard is bad, so we should do what we can to avoid it, IMO. :)</p>",
        "id": 273158490,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741771
    },
    {
        "content": "<p>I started a new run and I'm automatically re-running Miri with pointer tagging when I get an SB error that mentions a tag. I think this means I could with little effort pick out cases of pointer invalidation, as opposed to use with wrong permission and use outside provenance.</p>\n<p>What would be super cool to pair with this is a hacked Miri with the invalidation on write as suggested in 133.</p>",
        "id": 273163868,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645744863
    },
    {
        "content": "<p>My informal instinct is that 134 is not as prevalent. But maybe I'll have data to back that up in a week or two</p>",
        "id": 273164052,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645744990
    },
    {
        "content": "<p>134 is kind of required for memory allocators, kernels, and a bunch of other low level use cases where rust wants to target</p>",
        "id": 273164115,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645745036
    },
    {
        "content": "<p>container_of-style stuff is super important</p>",
        "id": 273164159,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645745043
    },
    {
        "content": "<p>and it's <em>soooo</em> hard to do right currently in rust</p>",
        "id": 273164169,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645745051
    },
    {
        "content": "<p>Oh are we including 256 (&amp;Header) in 134? I think the Header pattern is rather ingrained in a few places. Perhaps they could be patched (I patched one out of thinvec) but most that I've seen in the wild are very spread across a codebase. I wonder if the Header pattern should be permitted on the grounds that it seems to make code so much simpler.</p>",
        "id": 273164356,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645745179
    },
    {
        "content": "<p>No, header is same as 133, not 134</p>",
        "id": 273165771,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645746120
    },
    {
        "content": "<p>wait no its not</p>",
        "id": 273165938,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645746234
    },
    {
        "content": "<p>Yeah, you're right, my bad</p>",
        "id": 273165991,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645746252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> you're just too quick.^^ I hope in the fall/winter we will have something that makes progress on these issues, and then we will need to evaluate if our new model is indeed \"better\" at accepting existing code than the old one. but we're not there yet. :)</p>",
        "id": 273261052,
        "sender_full_name": "RalfJ",
        "timestamp": 1645811238
    },
    {
        "content": "<p>I hope you wont have fixed all miri warnings in the ecosystem by then, because that would make our evaluation look quite bad :P</p>",
        "id": 273261165,
        "sender_full_name": "RalfJ",
        "timestamp": 1645811284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Stacked.20borrows.20retagging.20on.20assignments/near/273164356\">said</a>:</p>\n<blockquote>\n<p>Oh are we including 256 (&amp;Header) in 134? I think the Header pattern is rather ingrained in a few places. Perhaps they could be patched (I patched one out of thinvec) but most that I've seen in the wild are very spread across a codebase. I wonder if the Header pattern should be permitted on the grounds that it seems to make code so much simpler.</p>\n</blockquote>\n<p>I am including &amp;Header in what I think we could do better, so maybe I should have included it in that list of most important problems</p>",
        "id": 273261282,
        "sender_full_name": "RalfJ",
        "timestamp": 1645811347
    }
]