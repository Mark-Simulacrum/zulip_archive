[
    {
        "content": "<p>Is it fine to read a mutex's data via a shared reference while somewhere else in the code a <code>*mut ...</code> raw pointer (1) points to the same data and (2) is not dereferenced? Here is a <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9c425dc325a66020627e94e0b629e696\">concrete example</a>; the <code>println!</code> statements are where the shared reference is used. I think it's not UB, because the mutex's data is in an unsafe cell, but I would like a confirmation. MIRI with <code>-Zmiri-track-raw-pointers</code> gives no warnings.</p>",
        "id": 219054826,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607331808
    },
    {
        "content": "<p>As a comparison, I expect <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=ab9dc81acd6c80659e95d369e1d36015\">this program</a> to have UB because it uses a <code>Box</code> instead of a <code>Mutex</code>. However, MIRI doesn't give warnings on that either. I'm not sure if it's a false negative of MIRI or a misunderstanding on my side.</p>",
        "id": 219056162,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607332691
    },
    {
        "content": "<p>I <em>think</em> it's a false negative: aliasing (or rather, lack thereof) ought to be a transitive property. I guess it's just not transitively checked yet.</p>\n<p>Note that your initial example is UB if you do:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">- let data_guard =   data_mutex.lock().unwrap();</span>\n<span class=\"gi\">+ let data_guard = &amp;*data_mutex.lock().unwrap();</span>\n</code></pre></div>\n<p>That is, if you do have a Rust reference that lives past the <code>lib</code> call <em>and which gets used / dereferenced</em> after the call then that write-dereference in <code>lib</code> breaks SB (and Miri does then complain).</p>\n<p>In the case where all you have is a guard it's less clear cut: implementation-wise, a <code>Guard</code> is a <code>&amp;UnsafeCell&lt;_&gt;</code>, <em>i.e.</em>, a shared read-write in SB parlance. It's only when you use its <code>Deref{,Mut}</code> that some aliasing properties get applied, and for the duration of the dereference.  But I wonder if the implementation could change to upgrade on lock rather than on deref, in which case your code would be UB even without an initial <code>&amp;*</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 219078341,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607347291
    },
    {
        "content": "<p>In practice, you may want to use/write your own <code>(Mutex&lt;()&gt;, UnsafeCell&lt;u32&gt;)</code> wrapper pair, or actually \"simply\" use a <code>RwLock&lt;Cell&lt;u32&gt;&gt;</code>. In the latter case, while performing a <code>.read()</code> lock on the <code>Cell</code>, it won't be possible to assert any lack of aliasing on the <code>u32</code> thanks to the <code>Cell</code>.</p>",
        "id": 219079291,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607347852
    },
    {
        "content": "<p>Thank you, everything you wrote makes much sense. I'm aware that the code snippets are far from being Good Rust, but I'm trying to understand what's the (formal) limit of the API of some types.</p>",
        "id": 219454460,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607596000
    },
    {
        "content": "<p>A surprising consequence of the first example that I posted seems to be that it's not UB to change the data of a <code>RwLock</code> while <em>another</em> thread is holding a <code>RwLockReadGuard</code> (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0c329d1ad68f0422d4b11083b5d9bbed\">playground</a>).</p>",
        "id": 219454552,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607596054
    },
    {
        "content": "<p>So, if I were to implement a library that takes an <code>Arc&lt;RwLock&lt;_&gt;&gt;</code> argument, technically I cannot rely on the fact that it's UB to change the content of a lock while I'm holding a read guard, because a client of the library <em>might</em> find a side channel to do the synchronization (the <code>logic_mutex</code> in the last example that I linked).</p>",
        "id": 219454650,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607596105
    },
    {
        "content": "<p>Note that if you <code>deref()</code> the guard and keep the reference alive, the example becomes UB (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1573655f7f29b0779611b3dc2ffdbb7c\">modified playground</a>). Since <code>first_thread()</code> is all safe code, the UB must come from <code>second_thread()</code>.</p>",
        "id": 219456631,
        "sender_full_name": "Gwaihir Thorondorsen",
        "timestamp": 1607597388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"369545\">Gwaihir Thorondorsen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Raw.20pointer.20to.20a.20mutex's.20data/near/219456631\">said</a>:</p>\n<blockquote>\n<p>Note that if you <code>deref()</code> the guard and keep the reference alive, the example becomes UB (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1573655f7f29b0779611b3dc2ffdbb7c\">modified playground</a>). Since <code>first_thread()</code> is all safe code, the UB must come from <code>second_thread()</code>.</p>\n</blockquote>\n<p>Yes, or from the <code>unsafe impl</code> that I had to use to send the raw pointer.</p>",
        "id": 219457302,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607597843
    },
    {
        "content": "<p>Actually the <code>unsafe impl</code> can be avoided: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b60e69a7fdbf9b3fa9f6ab1eb67efb4b\">playground</a>.</p>",
        "id": 219457750,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607598128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116427\">Federico Poli</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Raw.20pointer.20to.20a.20mutex's.20data/near/219454650\">said</a>:</p>\n<blockquote>\n<p>So, if I were to implement a library that takes an <code>Arc&lt;RwLock&lt;_&gt;&gt;</code> argument, technically I cannot rely on the fact that it's UB to change the content of a lock while I'm holding a read guard, because a client of the library <em>might</em> find a side channel to do the synchronization (the <code>logic_mutex</code> in the last example that I linked).</p>\n</blockquote>\n<p>I don't think this is correct. The invariant of <code>RwLock</code> says that you can only write to it while you hold the write lock. So <code>second_thread</code> is violating that invariant and is unsound (which is to say, it allows <code>first_thread</code> to cause UB without any unsafe code)</p>",
        "id": 219458915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607598908
    },
    {
        "content": "<p>If you want to locally violate this invariant and enforce a different one of your own design (something involving the <code>Mutex&lt;()&gt;</code> in this case), you can do so without causing UB because the invariant is at the library level, but the code snippet here demonstrates an unsound API: <code>ReadGuard</code> is built to support RwLock's invariant, and it violates your invariant. The <code>deref</code> impl needs to be unsafe with your invariant.</p>",
        "id": 219459289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607599145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Raw.20pointer.20to.20a.20mutex's.20data/near/219458915\">said</a>:</p>\n<blockquote>\n<p>The invariant of <code>RwLock</code> says that you can only write to it while you hold the write lock.</p>\n</blockquote>\n<p>Do you have a reference? Intuitively this is the invariant that I expect too, but what's unspecified is what \"you hold\" means. For example, it could be \"the thread that does the modification has a local variable of type <code>RwLockWriteGuard</code> on the stack\", or \"the function that does the modification has a local variable of type <code>RwLockWriteGuard</code>\", or \"the function that does the modification has a local variable from which the write guard is reachable\" (\"reachable\" would need a definition too...).</p>",
        "id": 219466536,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607604274
    },
    {
        "content": "<p>Among those three, I think that the correct interpretation should be the last one, such that programs like <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9c425dc325a66020627e94e0b629e696\">the first example of this thread</a> violate the invariant of <code>RwLock</code> and the reasoning is modular. However, I don't have an argument to claim that the first interpretation is incorrect.</p>",
        "id": 219466624,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607604353
    },
    {
        "content": "<p>The modification must be done from a pointer or reference derived from a WriteGuard that has not yet been dropped</p>",
        "id": 219470043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607606347
    },
    {
        "content": "<p>In the first example,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">data_ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">data_mutex_ref</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">deref_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>creates a pointer that is immediately dangling. It cannot be used.</p>",
        "id": 219470395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607606542
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116427\">@Federico Poli</span></p>",
        "id": 219470451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607606578
    },
    {
        "content": "<p>The location of the write guard is not important. What matters, in order to be consistent with the stacked borrows model (or other similar models, for that matter), is whether the lifetime of the guard has ended. In SB this is represented by whether reference that is being used to perform the write still has an entry on the borrow stack that was put there by the guard (and will remain there until the guard is dropped). All Rust APIs have this form because this is what the lifetime and ownership model gives you, so it makes sense to build APIs that play well with it.</p>",
        "id": 219471041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607606915
    },
    {
        "content": "<p>So far, all of the examples have had (library) UB. Miri won't catch this because it only finds language UB, and unfortunately most type invariants are not spelled out in formal detail so I don't have a reference to give, but for RwLock the API makes the invariant pretty obvious: you get a guard and you can only modify the data through that guard. Using unsafe code doesn't change this.</p>",
        "id": 219472591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607607744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Using the guard's lifetime is a really clear way of expressing the invariant, nice! I guess that your definition of \"dangling pointer\" is not \"points to deallocated memory\", right? Because in the example the raw pointer references data that will be deallocated by dropping the <code>Mutex</code>, not the <code>MutexGuard</code>.</p>",
        "id": 219483942,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607612730
    },
    {
        "content": "<p>I find intriguing the \"library UB\" and \"language UB\" terms that you use. Could you expand a bit on the difference between them? For example, imagine that I copy-paste the definition of <code>Mutex</code> from the standard library and use it in <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9c425dc325a66020627e94e0b629e696\">the first example</a>. Would you still call it UB, even if as a developer I can rely on the intricate details of my copy-pasted implementation of <code>Mutex</code>?</p>",
        "id": 219483986,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607612752
    },
    {
        "content": "<p>The definition of language UB is determined by the language spec, i.e. the thing that UCG is trying to determine. By contrast, library UB is defined by the author of the library, in the form of a set of invariants that must hold at the crate boundary. GIven such a definition, the question of whether a given function must be <code>unsafe</code> or not is well defined, as well as the preconditions for <code>unsafe</code> functions that suffice to make the calls safe.</p>\n<p>If you copy paste the definition of <code>Mutex</code>, you may or may not copy paste the invariant as well. If you keep <code>Mutex</code>'s invariant, then the code is still UB, but you can change the invariants, and then it may not be, although you may need to change the signatures of some functions or make them inaccessible to avoid presenting an unsound interface for downstream clients.</p>",
        "id": 219484706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607613032
    },
    {
        "content": "<p>Personally, I wish that programs put more emphasis on defining the invariants of their code. But Rust code at least has \"explicit safety\", and you can usually work backwards from the public safe API of a library to reverse engineer what the invariants are (under the assumption that the library API is sound). I think most programmers are used to doing this, and that's how I'm determining what the invariant of <code>RwLock</code> is.</p>",
        "id": 219485665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607613410
    },
    {
        "content": "<p>Now I see your point, thanks! I would like too invariants to be more explicit :) Given that the invariants are (currently) not visible to the compiler, however, don't you think that the compiler is forced to be conservative and act as if there were no invariant at all? I'm not sure that we want a UB definition that depends on non-visible invariants.</p>",
        "id": 219486909,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607613897
    },
    {
        "content": "<p>Oh, I now see that what you call library UB is probably what I call library (in)correctness.</p>",
        "id": 219487153,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607613986
    },
    {
        "content": "<p>The compiler operates with respect to the invariants of the language itself, that's language UB</p>",
        "id": 219487207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607614016
    },
    {
        "content": "<p>so even if you violate library invariants the compiler doesn't know or care</p>",
        "id": 219487310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607614056
    },
    {
        "content": "<p>Yes, I see your point. It's like the distinction \"logic bug\" vs \"soundness bug\" of <a href=\"#narrow/stream/146229-wg-secure-code/topic/How.20do.20programmers.20use.20unsafe.20Rust.3F\">this other discussion</a>. In my terminology \"UB\" is your \"language UB\".</p>",
        "id": 219487652,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607614179
    },
    {
        "content": "<p>You can still argue that such code is correct, but now the argument involves the internal details of that library, so you lose stability</p>",
        "id": 219487674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607614186
    },
    {
        "content": "<p>Yes</p>",
        "id": 219487711,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607614199
    },
    {
        "content": "<p>which is why it is best to actually copy paste the code if you want to rely on that behavior</p>",
        "id": 219487774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607614209
    },
    {
        "content": "<p>well, there is still a bit of difference between a logic bug and library UB: the latter changes the assignment of <code>unsafe</code> labels to functions</p>",
        "id": 219488374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607614391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Raw.20pointer.20to.20a.20mutex's.20data/near/219488374\">said</a>:</p>\n<blockquote>\n<p>well, there is still a bit of difference between a logic bug and library UB: the latter changes the assignment of <code>unsafe</code> labels to functions</p>\n</blockquote>\n<p>Could you post an example of that?</p>",
        "id": 219624607,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607703080
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// The library UB version:</span>\n\n<span class=\"sd\">/// Module invariant: this is always even.</span>\n<span class=\"sd\">/// The field must not be public</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">EvenInt</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">EvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// There is no promise that the user gave us an even number, so</span>\n<span class=\"w\">    </span><span class=\"sd\">/// this function makes the crate interface unsound.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// (Assume it is not present for the rest)</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">unsound</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">EvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">EvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// This is okay, because the language invariant says that x is aligned</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">from_aligned_pointer</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">u16</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">EvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">EvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// This is okay, because it is private.</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">internal_function</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">EvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">EvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// This is okay, because it is unsafe, signaling that the usual</span>\n<span class=\"w\">    </span><span class=\"sd\">/// preconditions may not be sufficient.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// It should come with an explicit description of the precondition:</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// # Safety</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// This function must not be called with an odd input.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">explicit_precondition</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">EvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">EvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// This is okay, because of the module invariant</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">relies_on_precondition</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// Safety: our module invariant ensures that this property holds</span>\n<span class=\"w\">            </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">hint</span>::<span class=\"n\">unreachable_unchecked</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n\n\n<span class=\"c1\">// The logic bug version:</span>\n\n<span class=\"sd\">/// This *should* be an even int, but we don't rely on it as such.</span>\n<span class=\"sd\">/// Formally, the module invariant is trivial (it is not necessarily even).</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ProbablyEvenInt</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// this can be public, but it doesn't have to be</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ProbablyEvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// This uses assert for checking, it is okay</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">runtime_checked</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ProbablyEvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"this should be even\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">ProbablyEvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// This is only checked in debug mode, but it's still okay because</span>\n<span class=\"w\">    </span><span class=\"sd\">/// there isn't actually an invariant at the memory safety level</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">debug_checked</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ProbablyEvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">debug_assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"this should be even\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">ProbablyEvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// smelly but still legal. You must have a lot of trust in your users</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">unchecked</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ProbablyEvenInt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">ProbablyEvenInt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Now this function is the unsound one, because we don't have the invariant</span>\n<span class=\"w\">    </span><span class=\"sd\">/// we need except at the logic bug level</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">unsound</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">hint</span>::<span class=\"n\">unreachable_unchecked</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Here's how you signal logic bugs that have not been promoted to library UB level:</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">better</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">unreachable</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219627931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607704561
    },
    {
        "content": "<p>I really like this example</p>",
        "id": 219632672,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607706579
    },
    {
        "content": "<p>and it helps me articulate why I don't like cranelift's API, because it <em>always</em> has <code>better</code> but not always <code>runtime_checked</code></p>",
        "id": 219632774,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607706624
    },
    {
        "content": "<p>so it's hard to track down where things went wrong</p>",
        "id": 219632790,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607706635
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> very nice example indeed. :)</p>\n<p>FWIW, as a matter of code style, I'd usually make <code>internal_function</code> <code>unsafe</code> as well (and would ask people to do that during review). But this is not fundamentally needed for a sound interface.<br>\nAlso, and now I am really nitpicking, I think safety comments should be positive, not negative -- so \"This function assumes that the argument is even\", not \"This function must not be called with an odd input\".</p>",
        "id": 219772428,
        "sender_full_name": "RalfJ",
        "timestamp": 1607882895
    },
    {
        "content": "<p>Indeed. Really the whole discussion about \"undefined behavior\" seems backward since it talks about when an invariant is violated rather than the positive concept which is the idea of nontrivial invariants (and inferred preconditions)</p>",
        "id": 219772520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607883006
    },
    {
        "content": "<blockquote>\n<p>In the case where all you have is a guard it's less clear cut: implementation-wise, a Guard is a &amp;UnsafeCell&lt;_&gt;, i.e., a shared read-write in SB parlance. It's only when you use its Deref{,Mut} that some aliasing properties get applied, and for the duration of the dereference. But I wonder if the implementation could change to upgrade on lock rather than on deref, in which case your code would be UB even without an initial &amp;* <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n</blockquote>\n<p>I think the implementation probably could be changed like that, so relying on this internal implementation detail is likely not correct</p>",
        "id": 219772546,
        "sender_full_name": "RalfJ",
        "timestamp": 1607883072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Raw.20pointer.20to.20a.20mutex's.20data/near/219772520\">said</a>:</p>\n<blockquote>\n<p>Indeed. Really the whole discussion about \"undefined behavior\" seems backward since it talks about when an invariant is violated rather than the positive concept which is the idea of nontrivial invariants (and inferred preconditions)</p>\n</blockquote>\n<p>many stdlib docs get around that by saying \"behavior is undefined unless all of the following conditions are met: [...]\"</p>",
        "id": 219772556,
        "sender_full_name": "RalfJ",
        "timestamp": 1607883109
    },
    {
        "content": "<p>but yeah, with all the baggage that comes with the term \"UB\", the fact that it focuses on the negative case is really my biggest complaint.</p>",
        "id": 219772615,
        "sender_full_name": "RalfJ",
        "timestamp": 1607883153
    },
    {
        "content": "<p>Thank you for the example! Now I see what you mean with adding unsafe.</p>",
        "id": 219831057,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607947209
    },
    {
        "content": "<p>I find this thread very useful. So, let me condense some ideas.</p>\n<p>Rust code can be annotated with documentation that states properties (invariants, pre/post conditions etc) of the code. The author of the code should always explicitly split these properties in two: <em>correctness</em> and <em>safety</em> properties. When done correctly, violating the former from a client should lead in the worst case to logic errors (panics, computing the wrong result etc) while violating the latter should lead in the worst case to UB. The safety proof of unsafe blocks can only rely on safety properties, not correctness properties.</p>\n<p>When a safety property is violated, two things can happen:</p>\n<ul>\n<li>The code's behavior is undefined. For example, because the compiler infers that a shared and a mutable reference point to the same memory location while they are both active.</li>\n<li>The code's behavior is actually defined, but just because of implementation details. This is fragile because a future version of a library might change the implementation. I think this is a case of @Mario Carneiro's \"library UB\", but I would call this \"fragile behavior\" to make it clear that it's not undefined.</li>\n</ul>\n<p>To complete the analogy, when a correctness property is violated, two things can happen:</p>\n<ul>\n<li>The code has a logic error (panics, computes the wrong result etc).</li>\n<li>The code actually runs fine and computes the correct result, because the implementation is more robust than what stated in the declared correctness properties. Of course, this is fragile because the implementation could change in future versions.</li>\n</ul>",
        "id": 219832612,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607948151
    },
    {
        "content": "<p>In the end, my understanding is that all the examples that I linked are cases of <em>fragile behaviour</em>: the code that arrives to the compiler has no UB, but the safety proof is <em>wrong</em> because it relies on an implementation detail of a library and not on its safety properies, which are guaranteed to be preserved in minor updates of the library.</p>",
        "id": 219832710,
        "sender_full_name": "Federico Poli",
        "timestamp": 1607948184
    },
    {
        "content": "<p>yes, that's a good way to put it</p>",
        "id": 219833894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607948824
    },
    {
        "content": "<p>I had assumed panics were a UB property rather than a logic property</p>",
        "id": 219896490,
        "sender_full_name": "oliver",
        "timestamp": 1607977158
    },
    {
        "content": "<p>panics are never UB</p>",
        "id": 219933937,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608002960
    },
    {
        "content": "<p>they can crash the program, but they can't write to arbitrary memory or run arbitrary code</p>",
        "id": 219933985,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608002984
    },
    {
        "content": "<p>heh yeah I think this is because of checks in the MIR, like in,<br>\nC an out-of-bounds read is UB, but in Rust that is prevented</p>",
        "id": 219948790,
        "sender_full_name": "oliver",
        "timestamp": 1608020967
    },
    {
        "content": "<p>or at least eventually MIR will have safety proofs?</p>",
        "id": 219948889,
        "sender_full_name": "oliver",
        "timestamp": 1608021028
    },
    {
        "content": "<p>either way I appreciated the outline since I had some bad assumptions :)</p>",
        "id": 219948928,
        "sender_full_name": "oliver",
        "timestamp": 1608021068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Raw.20pointer.20to.20a.20mutex's.20data/near/219948790\">said</a>:</p>\n<blockquote>\n<p>heh yeah I think this is because of checks in the MIR, like in,<br>\nC an out-of-bounds read is UB, but in Rust that is prevented</p>\n</blockquote>\n<p>well yes, but it's nothing to do with MIR, there's a <code>panic</code> in <code>Index</code> if you try to read out of bounds: <a href=\"https://doc.rust-lang.org/src/core/slice/index.rs.html#395\">https://doc.rust-lang.org/src/core/slice/index.rs.html#395</a></p>",
        "id": 219976951,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608038306
    },
    {
        "content": "<p>you can still call <code>get_unchecked</code> and it will be UB on an out-of-bounds index</p>",
        "id": 219976995,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608038329
    },
    {
        "content": "<p>ooh interesting</p>",
        "id": 220031286,
        "sender_full_name": "oliver",
        "timestamp": 1608061275
    }
]