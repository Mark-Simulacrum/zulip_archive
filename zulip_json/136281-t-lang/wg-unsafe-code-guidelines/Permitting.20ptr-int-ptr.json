[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> If you want to permit ptr-int-ptr you need to have some kind of solution to this problem <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/291\">https://github.com/rust-lang/unsafe-code-guidelines/issues/291</a></p>\n<p>My very short summary of this is that ptr-int-ptr conflicts with <code>restrict</code>/<code>noalias</code> with GVN. It's not entirely clear to me if one can point to GVN as a root cause here. That is, if we eliminated integer GVN, would a different integer optimization produce the same problem? I suspect so, but <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> probably knows better.</p>\n<p>So, pending Ralf's response, I think Rust really does have to make a choice between sprinkling <code>noalias</code> on its LLVM IR and having ptr-int-ptr casts.</p>",
        "id": 277479624,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648848301
    },
    {
        "content": "<p>or getting LLVM to fix their optimizations in the way ralf suggests right there (you can't delete ptrtoint if you aren't keeping alias/escape info any other way), which they need to do for C anyways even without restrict-specific examples</p>",
        "id": 277479940,
        "sender_full_name": "Talchas",
        "timestamp": 1648848489
    },
    {
        "content": "<p>there's \"we don't want to wait for LLVM and don't have people willing to try to fix it ourselves\", but this example is a general problem LLVM has, not rust-specific</p>",
        "id": 277479991,
        "sender_full_name": "Talchas",
        "timestamp": 1648848532
    },
    {
        "content": "<p>Don't ascribe intentionality to my omission lol, I just forgot about that option</p>",
        "id": 277480019,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648848553
    },
    {
        "content": "<p>ah, ok :P</p>",
        "id": 277480199,
        "sender_full_name": "Talchas",
        "timestamp": 1648848652
    },
    {
        "content": "<p>I think my solution is that I agree that ptr2int casts should be side-effecting. Is that a valid solution? I have it like that in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my summary post</a>. </p>\n<blockquote>\n<p>We introduce a performance lint against <code>usize as ptr</code> and <code>ptr as usize</code> and their synonyms â€” because they are slow+insecure on some platforms and merely slower on most others.</p>\n</blockquote>",
        "id": 277480958,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648849055
    },
    {
        "content": "<p>The details of the lowering to LLVM, what exactly LLVM is supposed to do, need to be figured out of course</p>",
        "id": 277481107,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648849111
    },
    {
        "content": "<p>I'm very wary of overeager lints like that, because the actual problem is ptr-int-ptr, which can be spread across code and across time</p>",
        "id": 277481180,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648849147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> I'm going to try to move the conversation here from the other thread to be able to address this head on: You seem to be under the impression that Rust can both allow non-strict provenance and have a sound memory model. I'm not so sure how you came to that conclusion; I am not at that point, and would like to see evidence of that fact</p>",
        "id": 277482493,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849874
    },
    {
        "content": "<p>I agree that it is likely that Rust can have a sound memory model and <em>avoid</em> miscompiling programs that do not comply with strict provenance, but that is not at all the same thing</p>",
        "id": 277482544,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849910
    },
    {
        "content": "<p>I believe SB with the PNVI-ae-udi-like \"ptrtoint adds to the escaped log, inttoptr gives the pointer the provenance of a set including all provenance values at that address, if the actual execution path is not valid at all points for some provenance in that set, it is UB\" is generally assumed to be sound? (and assumed to still permit <code>noalias</code> with ptrtoint considered a side-effect)</p>",
        "id": 277483076,
        "sender_full_name": "Talchas",
        "timestamp": 1648850196
    },
    {
        "content": "<p>but is glhf for miri</p>",
        "id": 277483085,
        "sender_full_name": "Talchas",
        "timestamp": 1648850202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277482493\">said</a>:</p>\n<blockquote>\n<p>You seem to be under the impression that Rust can both allow non-strict provenance and have a sound memory model. I'm not so sure how you came to that conclusion; I am not at that point, and would like to see evidence of that fact</p>\n</blockquote>\n<p>Correct. Stacked Borrows has a notion of \"exposing\" pointers, like pnvi-ae, although the details are different. This is how I understand the paper and how I understand <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304\">Ralf's message</a></p>",
        "id": 277483335,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850398
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277483335\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277482493\">said</a>:</p>\n<blockquote>\n<p>You seem to be under the impression that Rust can both allow non-strict provenance and have a sound memory model. I'm not so sure how you came to that conclusion; I am not at that point, and would like to see evidence of that fact</p>\n</blockquote>\n<p>Correct. Stacked Borrows has a notion of \"exposing\" pointers, like pnvi-ae, although the details are different. This is how I understand the paper and how I understand <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304\">Ralf's message</a></p>\n</blockquote>\n<p>Under SB with tagged raw pointers (which is strongly favored over the alternative by a number of people right now), there is no notion of exposed raw pointers</p>",
        "id": 277483500,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850459
    },
    {
        "content": "<p>AIUI the original SB non-udi like expose setup has had issues. The only complaints I've heard about -udi models is that the formalization would be ugly and miri probably dies</p>",
        "id": 277483507,
        "sender_full_name": "Talchas",
        "timestamp": 1648850464
    },
    {
        "content": "<p>And IIUC Stacked Borrows is sound. We just don't know how to integrate it yet with the rest of the world. One problem being transmute (which I now think we should banish)</p>",
        "id": 277483511,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277483507\">said</a>:</p>\n<blockquote>\n<p>AIUI the original SB non-udi like expose setup has had issues. The only complaints I've heard about -udi models is that the formalization would be ugly and miri probably dies</p>\n</blockquote>\n<p>I'm also not convinced that it doesn't cause optimization problems. The paper is pretty light on the optimizations it proves correct</p>",
        "id": 277483574,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277483500\">said</a>:</p>\n<blockquote>\n<p>which is strongly favored over the alternative by a number of people right now</p>\n</blockquote>\n<p>I have yet to understand why normal Stacked Borrows wouldn't be a fine model / what, specifically, is making work on the compiler more complicated</p>",
        "id": 277483639,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850536
    },
    {
        "content": "<p><a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging</a></p>",
        "id": 277483703,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850586
    },
    {
        "content": "<p>It might have issues, but my understanding is that it is similar to what compilers already do when they aren't running into inttoptr bugs - they already have to assume that unknown provenance could be any provenance</p>",
        "id": 277483719,
        "sender_full_name": "Talchas",
        "timestamp": 1648850601
    },
    {
        "content": "<p>It's not that the compiler is more complicated, it's that the model is</p>",
        "id": 277483721,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850601
    },
    {
        "content": "<p>Ralf claims that raw pointer tagging does not enable many more optimizations, although to be honest I think that claim is undersupported</p>",
        "id": 277483758,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850628
    },
    {
        "content": "<p>But even more importantly, Saethlin reports that this is a nightmare to write sound programs against</p>",
        "id": 277483819,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850649
    },
    {
        "content": "<p>And that's like... an actual problem</p>",
        "id": 277483963,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850739
    },
    {
        "content": "<p>Miri checkability and the ability of people to reason about the memory model is <em>really</em> important. SB is complicated, we need to help people get their code right</p>",
        "id": 277484001,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277483500\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277483335\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277482493\">said</a>:</p>\n<blockquote>\n<p>You seem to be under the impression that Rust can both allow non-strict provenance and have a sound memory model. I'm not so sure how you came to that conclusion; I am not at that point, and would like to see evidence of that fact</p>\n</blockquote>\n<p>Correct. Stacked Borrows has a notion of \"exposing\" pointers, like pnvi-ae, although the details are different. This is how I understand the paper and how I understand <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304\">Ralf's message</a></p>\n</blockquote>\n<p>Under SB with tagged raw pointers (which is strongly favored over the alternative by a number of people right now), there is no notion of exposed raw pointers</p>\n</blockquote>\n<p>What does SB with tagged raw pointers think of pointers that escape into extern code?</p>\n<p>Or is there no plan to ever support this, and we'll have to continue to write models of every C API we use if we want to use miri?</p>",
        "id": 277484714,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648851235
    },
    {
        "content": "<p>What do you mean? It doesn't really <em>think</em> anything</p>",
        "id": 277485001,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851449
    },
    {
        "content": "<p>FFI functions are not permitted to influence the Rust AM in a way that sound Rust code could not</p>",
        "id": 277485072,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851488
    },
    {
        "content": "<p>FFI functions can absolutely do things like cast ptrs to integers and back, and this is indistinguishable to the rust AM from them storing them in globals</p>",
        "id": 277485139,
        "sender_full_name": "Talchas",
        "timestamp": 1648851549
    },
    {
        "content": "<p>(except that the only valid ways to do this are those extern fns instead of the builtin intrinsics)</p>",
        "id": 277485190,
        "sender_full_name": "Talchas",
        "timestamp": 1648851587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485139\">said</a>:</p>\n<blockquote>\n<p>FFI functions can absolutely do things like cast ptrs to integers and back, and this is indistinguishable to the rust AM from them storing them in globals</p>\n</blockquote>\n<p>Yes. To be clear, I do not consider this incompatible with what I said above</p>",
        "id": 277485272,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851642
    },
    {
        "content": "<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>",
        "id": 277485295,
        "sender_full_name": "RalfJ",
        "timestamp": 1648851667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>Well, we still do need to say at least a few words about how FFI is allowed to touch things that the Rust AM knows about</p>",
        "id": 277485397,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851726
    },
    {
        "content": "<p>because they have the same implications on anything taking advantage of provenance as a very permissive ptrtoint/inttoptr does</p>",
        "id": 277485478,
        "sender_full_name": "Talchas",
        "timestamp": 1648851784
    },
    {
        "content": "<p>That's probably somewhat my fault, but I bring it up less in a formal model sense and more in this code should continue to work sense.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">ptrtoint</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">ptrtoint</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277485481,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851786
    },
    {
        "content": "<p>issue <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/291\">https://github.com/rust-lang/unsafe-code-guidelines/issues/291</a> that was linked above is concerned about ptr2int casts having 'expose' like side effects. I have since come to the conclusion that this is entirely unavoidable. it's also what C does with PNVI-ae-\\*. So I basically concluded I will no longer try to cater for LLVM's desire to make ptr2int casts pure and side-effect-free, and instead hold the position that LLVM needs to accept that these casts have side-effects, and be changed accordingly.</p>",
        "id": 277485508,
        "sender_full_name": "RalfJ",
        "timestamp": 1648851802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277484714\">said</a>:</p>\n<blockquote>\n<p>What does SB with tagged raw pointers think of pointers that escape into extern code?</p>\n<p>Or is there no plan to ever support this, and we'll have to continue to write models of every C API we use if we want to use miri?</p>\n</blockquote>\n<p>As far as I understand, this is too complicated for formal models. Maybe sometime in the future this can be formalized but now there's just no hope of formalizing that.</p>",
        "id": 277485515,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648851804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485397\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>Well, we still do need to say at least a few words about how FFI is allowed to touch things that the Rust AM knows about</p>\n</blockquote>\n<p>basically: the FFI function can have any effect that an actual inside-AM function could also have</p>",
        "id": 277485564,
        "sender_full_name": "RalfJ",
        "timestamp": 1648851840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>I bring it up because \"treating old Rust code as thought it were called across an FFI boundary from the perspective of the model\" is a possible solution, though not a great one.</p>",
        "id": 277485595,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851842
    },
    {
        "content": "<p>Ralf, what would we do without you!</p>",
        "id": 277485605,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648851843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485595\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>I bring it up because \"treating old Rust code as thought it were called across an FFI boundary from the perspective of the model\" is a possible solution, though not a great one.</p>\n</blockquote>\n<p>it's a really tricky one because of things like generics and stuff -- you'd have to actually put old Rust code reliably into its own TU to use this approach</p>",
        "id": 277485657,
        "sender_full_name": "RalfJ",
        "timestamp": 1648851879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485508\">said</a>:</p>\n<blockquote>\n<p>issue <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/291\">https://github.com/rust-lang/unsafe-code-guidelines/issues/291</a> that was linked above is concerned about ptr2int casts having 'expose' like side effects. I have since come to the conclusion that this is entirely unavoidable. it's also what C does with PNVI-ae-\\*. So I basically concluded I will no longer try to cater for LLVM's desire to make ptr2int casts pure and side-effect-free, and instead hold the position that LLVM needs to accept that these casts have side-effects, and be changed accordingly.</p>\n</blockquote>\n<p>TBH I've felt for a while now that this may be unavoidable as well.</p>",
        "id": 277485661,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485515\">said</a>:</p>\n<blockquote>\n<p>As far as I understand, this is too complicated for formal models.</p>\n</blockquote>\n<p>No shade on you, Ralf, just trying to be realistic and integrating some intuitions from my own PhD</p>",
        "id": 277485693,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648851898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485515\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277484714\">said</a>:</p>\n<blockquote>\n<p>What does SB with tagged raw pointers think of pointers that escape into extern code?</p>\n<p>Or is there no plan to ever support this, and we'll have to continue to write models of every C API we use if we want to use miri?</p>\n</blockquote>\n<p>As far as I understand, this is too complicated for formal models. Maybe sometime in the future this can be formalized but now there's just no hope of formalizing that.</p>\n</blockquote>\n<p>I dont think this is any different than FFI in general</p>",
        "id": 277485752,
        "sender_full_name": "RalfJ",
        "timestamp": 1648851951
    },
    {
        "content": "<p>which is tricky but something people work on</p>",
        "id": 277485756,
        "sender_full_name": "RalfJ",
        "timestamp": 1648851958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485657\">said</a>:</p>\n<blockquote>\n<p>it's a really tricky one because of things like generics and stuff -- you'd have to actually put old Rust code reliably into its own TU to use this approach</p>\n</blockquote>\n<p>Well, in practice only the optimization passes that are doing things that assume SB (or whatever) would have to worry about this.</p>",
        "id": 277485794,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485508\">said</a>:</p>\n<blockquote>\n<p>I [instead] hold the position that LLVM needs to accept that these casts have side-effects, and be changed accordingly.</p>\n</blockquote>\n<p>I also added it to <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my position</a>, although I phrase it as \"ptr2int and int2ptr are lint-worthy because they're slowish\"</p>",
        "id": 277485820,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648851994
    },
    {
        "content": "<p>Does anyone have all of Ralf's examples stored somewhere? I had it on my Linux install before it died miserably. I'm looking for the redundant store elimination one.</p>",
        "id": 277485829,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648852002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485820\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485508\">said</a>:</p>\n<blockquote>\n<p>I [instead] hold the position that LLVM needs to accept that these casts have side-effects, and be changed accordingly.</p>\n</blockquote>\n<p>I also added it to <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my position</a>, although I phrase it as \"ptr2int and int2ptr are lint-worthy because they're slowish\"</p>\n</blockquote>\n<p>that's a very different statement IMO^^</p>",
        "id": 277485838,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485829\">said</a>:</p>\n<blockquote>\n<p>Does anyone have all of Ralf's examples stored somewhere? I had it on my Linux install before it died miserably. I'm looking for the redundant store elimination one.</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806</a></p>",
        "id": 277485868,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852040
    },
    {
        "content": "<p>Is it a different statement? I think it expresses the same sentiment, but one is from an optimization perspective, the other is written for a developer</p>",
        "id": 277485886,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648852055
    },
    {
        "content": "<p>well you're adding some value judgment to it, and we don't have data supporting its slowness <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277485971,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>Besides the formalization work, what about miri? If miri implemented \"address escapes\" semantics for any pointers that are exposed to FFI, that could potentially open us up to check the correctness of unsafe Rust that calls foreign code (albeit not the correctness of the foreign code itself).<br>\nMaybe I'm being naive though.</p>",
        "id": 277486005,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648852140
    },
    {
        "content": "<p>It would (in some circumstances, in some hypothesized improved future version of LLVM) have worse alias analysis than strict-only provenance :D</p>",
        "id": 277486024,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648852159
    },
    {
        "content": "<p>FWIW I think it'd be good if you could put that summary on something like <a href=\"https://hackmd.io/\">https://hackmd.io/</a> . right now it's burried in a huge stream. also hackmd supports comments better.</p>",
        "id": 277486044,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852174
    },
    {
        "content": "<p>worse alias analysis --&gt; slower (at least not faster)</p>",
        "id": 277486051,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648852179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277486005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>Besides the formalization work, what about miri? If miri implemented \"address escapes\" semantics for any pointers that are exposed to FFI, that could potentially open us up to check the correctness of unsafe Rust that calls foreign code (albeit not the correctness of the foreign code itself).<br>\nMaybe I'm being naive though.</p>\n</blockquote>\n<p>not sure how that'd help, we still need to implement <em>all the other</em> effects of an FFI call</p>",
        "id": 277486137,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852229
    },
    {
        "content": "<p>when you call into FFI, <em>some</em> transformation happens to the AM state. that transformation can do things like expose an allocation, but also just change a value stored somewhere. all of these effects need to be implemented explicitly in miri.</p>",
        "id": 277486185,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277486137\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277486005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277485295\">said</a>:</p>\n<blockquote>\n<p>FFI functions act outside the Rust Abstract machine, their interaction happens on the level of the target hardware. FFI is basically irrelevant for provenance, except if we consider cross-lang LTO. Not sure why people keep bringing it up.^^</p>\n</blockquote>\n<p>Besides the formalization work, what about miri? If miri implemented \"address escapes\" semantics for any pointers that are exposed to FFI, that could potentially open us up to check the correctness of unsafe Rust that calls foreign code (albeit not the correctness of the foreign code itself).<br>\nMaybe I'm being naive though.</p>\n</blockquote>\n<p>not sure how that'd help, we still need to implement <em>all the other</em> effects of an FFI call</p>\n</blockquote>\n<p>Only those pertaining to the AM, right?<br>\nWhich could still be a bunch I realize</p>",
        "id": 277486194,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648852278
    },
    {
        "content": "<p>it doesn't make sense to indiscrimnantly expose <em>all</em> pointers passed to FFI in miri; miri should reflect whether the particular FFI function being called exposes or not (just like it reflects all the other effects of the particular FFI function in question)</p>",
        "id": 277486226,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852311
    },
    {
        "content": "<p>Also, FFI calls can still do arbitrary things to the AM as-if it was calling a Rust function, which could change program behavior/conditionals taken/that stuff.</p>",
        "id": 277486277,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648852326
    },
    {
        "content": "<p>I may be coming at this from a weird angle because of my background in symbolic execution, where it's not unheard of to spin up an ISA emulator (Or to lift foreign code into IR dynamically) for extern calls <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But the performance story of that is even worse than what people expect from miri today</p>",
        "id": 277486313,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648852370
    },
    {
        "content": "<p>the compiler, OTOH, doesn't know what the FFI function does, so it has to assume it might be <em>anything</em> that a regular AM function can do. including exposing all pointers it can reach.</p>",
        "id": 277486328,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852384
    },
    {
        "content": "<p>but, crucially, <em>not</em> including just faking or exposing arbitrary unique provenance that is local to the function and that the FFI function has no way of knowing about</p>",
        "id": 277486361,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277486044\">said</a>:</p>\n<blockquote>\n<p>FWIW I think it'd be good if you could put that summary on something like <a href=\"https://hackmd.io/\">https://hackmd.io/</a> . right now it's burried in a huge stream. also hackmd supports comments better.</p>\n</blockquote>\n<p>Thanks for the suggestion!</p>\n<p>I migrated it to <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA\">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA</a></p>",
        "id": 277486418,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648852445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277486313\">said</a>:</p>\n<blockquote>\n<p>I may be coming at this from a weird angle because of my background in symbolic execution, where it's not unheard of to spin up an ISA emulator (Or to lift foreign code into IR dynamically) for extern calls <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But the performance story of that is even worse than what people expect from miri today</p>\n</blockquote>\n<p>oh sure one could have a fun experiment with some kind of universal FFI emulation, and then we'd have to decide what happens wrt provenance as that information is not encoded in the assembly. it's also not typically given in the specs of FFI functions. so either way we'd have to make some choice...</p>",
        "id": 277486454,
        "sender_full_name": "RalfJ",
        "timestamp": 1648852486
    },
    {
        "content": "<p>Yes, you invariably lose some precision (if you're careful, only in one direction, i.e. you only make your analysis less complete or less correct, not both)</p>",
        "id": 277486571,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648852571
    },
    {
        "content": "<p>We should have universal FFI in Miri at some point, but making it work is going to be pretty invasive because you have to make it possible to dereference a pointer which you got from FFI and that does not point to memory allocated by Rust.</p>",
        "id": 277487072,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648852961
    },
    {
        "content": "<p>I'm sure there are other problems too, but from a very practical standpoint I gave it a shot then ran straight into that and decided to do other things with my time</p>",
        "id": 277487100,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648852990
    },
    {
        "content": "<p>I suspect a \"sanitizer\" approach might be easier, which allocates shadow memory with metadata</p>",
        "id": 277487191,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648853071
    },
    {
        "content": "<p>I suggest you take a look at how pointers work in Miri/CTFE before suggesting solutions. It's pretty easy to grep the rust-lang/rust codebase for the type <code>Pointer</code>.</p>",
        "id": 277487236,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648853115
    },
    {
        "content": "<p>That sounds a bit unwelcoming, sorry</p>",
        "id": 277487413,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648853282
    },
    {
        "content": "<p>Reading a compiler isn't a 10-minute task</p>",
        "id": 277487468,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648853300
    },
    {
        "content": "<p>That's why I said to grep for <code>Pointer</code>, because it's what I did to figure out how pointers work.</p>",
        "id": 277487700,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648853480
    },
    {
        "content": "<p>I understand how SB works, but I'm not interested in navigating large codebases right now. Anyway, it was just a hunch nothing important</p>",
        "id": 277488256,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648853856
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> </p>\n<blockquote>\n<p>transmute (which I now think we should banish)<br>\n<code>trasmute(ptr, int)</code>, yes, this is clearly problematic, along with any other <code>transmute_copy(&amp;ptr, int)</code> written with type punning. I just want clarification you're only taking about ptr-int transmute here? <em>Fully</em> banning transmute is typed memory and I don't think anyone's in favor of that. (i.e. <code>transmute(Vec&lt;u8&gt;, String)</code> is \"fine\" (modulo relying on unstable layout details))</p>\n</blockquote>",
        "id": 277507183,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648876123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277487191\">said</a>:</p>\n<blockquote>\n<p>I suspect a \"sanitizer\" approach might be easier, which allocates shadow memory with metadata</p>\n</blockquote>\n<p>Miri is already a sanitizer...</p>",
        "id": 277507277,
        "sender_full_name": "Jubilee",
        "timestamp": 1648876239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277486571\">said</a>:</p>\n<blockquote>\n<p>Yes, you invariably lose some precision (if you're careful, only in one direction, i.e. you only make your analysis less complete or less correct, not both)</p>\n</blockquote>\n<p>I think this interacts oddly with pointer exposing. Because if you expose a pointer you have <em>less</em> UB, so if you \"conservatively\" assume that all pointers passed to FFI are exposed / cast through integers, then you might miss UB because the code \"actually\" keeps the pointers un-exposed and then uses the result in an invalid way even though there is no evidence of this in the generated code. You can't even \"conservatively\" assume that pointers are not exposed because you can't tell if the provenances got permuted about in some way</p>",
        "id": 277507650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648876899
    },
    {
        "content": "<p>so I think this is a case where we have no choice but to miss some UB</p>",
        "id": 277507655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648876915
    },
    {
        "content": "<p>You can conservatively say \"sorry, you called foreign code, miri can't do this\" and your analysis will still be correct (but not as helpful).</p>",
        "id": 277520519,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648894569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Permitting.20ptr-int-ptr/near/277507277\">said</a>:</p>\n<blockquote>\n<p>Miri is already a sanitizer...</p>\n</blockquote>\n<p>I mean something that compiles to machine code like rustc and thus integrates seamlessly with FFI, but still tracks stuff for Rust-allocated memory like asan.</p>\n<p>Is that how Miri works?</p>",
        "id": 277525157,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648900527
    },
    {
        "content": "<p>no, Miri is an interpreter. I have dreams of a stacked borrows module for valgrind. one day...</p>",
        "id": 277529588,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905925
    },
    {
        "content": "<p>this discussion is... interesting. I've been looking into playing around with some approximations of miri's memory models applied to machine code (where all of the provenance distinctions would be <em>injected</em> into the initial architectural emulator state and also generated by high-level emulation of system interfaces e.g. the <code>mmap</code> syscalls - in fact, I think <code>mmap</code> can be a primitive for the former, like the binary image and the stack)</p>",
        "id": 277568573,
        "sender_full_name": "eddyb",
        "timestamp": 1648958248
    },
    {
        "content": "<p>for anything other than machine code level emulation, a LLVM sanitizer might be handy, but I doubt you can get far without e.g. Linux syscall interface emulation</p>",
        "id": 277568636,
        "sender_full_name": "eddyb",
        "timestamp": 1648958311
    }
]