[
    {
        "content": "<p>Ok, what I have is up, but tags not being contiguous because of  <code>UnsafeCell</code> made my life difficult, I've only implemented SRW from SRW reborrowing of wildcard tags one layer deep, and the diagnostics are kind of a mess.</p>\n<p>My current model is what I discussed above, where int-to-ptr casts produce a Wildcard tag with permission SRW, any reborrows to SRW also have a Wildcard tag, but any other reborrows use the item at the top of the borrow stack. I've tested this on real world code and it works, but that's just getting past my implementation, and nothing more :P.</p>",
        "id": 278397644,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649493882
    },
    {
        "content": "<p>Here's my attempt at \"porting\" <a href=\"https://github.com/rust-lang/rust/issues/273\">#273</a> to ptr-to-int shenanigans, and what exactly this implementation allows and disallows. <a href=\"https://gist.github.com/carbotaniuman/223b4a797ef852257d12a6210935fa99\">https://gist.github.com/carbotaniuman/223b4a797ef852257d12a6210935fa99</a></p>",
        "id": 278397660,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649493922
    },
    {
        "content": "<p>nice :D</p>",
        "id": 278408302,
        "sender_full_name": "RalfJ",
        "timestamp": 1649508090
    },
    {
        "content": "<p>in terms of reviewing I wonder if it would make sense to first land something for just the AllocId part (no SB support)? smaller PRs are significantly easier to review than big ones.</p>",
        "id": 278408331,
        "sender_full_name": "RalfJ",
        "timestamp": 1649508153
    },
    {
        "content": "<p>Yeah that can be done, although the SB part is quite well isolated from the rest of the code. I'd like some more examples to run it on (especially on the SB side).</p>",
        "id": 278431733,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649539536
    },
    {
        "content": "<p>This angelic non-determinism helps us fix some other stuff like <a href=\"https://github.com/rust-lang/miri/issues/1866\">https://github.com/rust-lang/miri/issues/1866</a> as I could keep extending our notion of reifying pointers. (Although I think 1866 could just be replaced by changing casts to ZSTs to have <code>invalid_addr</code> semantics).</p>",
        "id": 278431879,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649539696
    },
    {
        "content": "<p>And the fact that <code>UnsafeCell</code> exists is painful, I don't know how to do diagnostics at all when say the first 4 bytes are tagged normally and the last 4 are wildcard.</p>",
        "id": 278431974,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649539859
    },
    {
        "content": "<p>yeah indeed fixing 1866 will be nice :D</p>",
        "id": 278472032,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278431974\">said</a>:</p>\n<blockquote>\n<p>And the fact that <code>UnsafeCell</code> exists is painful, I don't know how to do diagnostics at all when say the first 4 bytes are tagged normally and the last 4 are wildcard.</p>\n</blockquote>\n<p>not sure what UnsafeCell changes here? everything is bytewise, so even a <code>&amp;mut u64</code> might encounter different borrow stacks for the first 4 and the last 4 bytes</p>",
        "id": 278472049,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602057
    },
    {
        "content": "<p>If pointers have the same permissions the full range, I can make being wildcard a property of  the pointer, and not have to make it a property of every stack.</p>",
        "id": 278490490,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649625740
    },
    {
        "content": "<p>That's tricky with partial invalidation</p>",
        "id": 278490610,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649625927
    },
    {
        "content": "<p>Can you explain a bit more? Not sure what that is sorry.</p>",
        "id": 278490678,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649625981
    },
    {
        "content": "<p>As in casting say a u64 to a u32 and then invalidating the first 4 bytes?</p>",
        "id": 278490704,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649626033
    },
    {
        "content": "<p>No I mean you can create a pointer to a u64 then remove its tag from any one of the bytes in that u64's borrow stacks, so that the pointer can only be used for 7 of the 8 bytes.</p>",
        "id": 278490955,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649626405
    },
    {
        "content": "<p>Hm actually I can only do this with aggregates. I wonder if I'm just uncreative.</p>",
        "id": 278491342,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649627028
    },
    {
        "content": "<p>Is your example something like this? (With raw pointers tagged)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"k\">u64</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">d</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491397,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627085
    },
    {
        "content": "<p>Even without raw pointer tagging, this program is rejected.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491418,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649627146
    },
    {
        "content": "<p>Right yeah that makes sense.</p>",
        "id": 278491468,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627202
    },
    {
        "content": "<p>I guess wildcard provenance should be a property of the stack then. That makes stuff easier-ish, but I'll need to change the diagnostics to mention that.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"n\">attempting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"mi\">2075</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc995</span><span class=\"p\">[</span><span class=\"mh\">0x7</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">exist</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">borrow</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">location</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">occurs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc995</span><span class=\"p\">[</span><span class=\"mh\">0x0</span><span class=\"o\">..</span><span class=\"mh\">0x8</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491547,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278490490\">said</a>:</p>\n<blockquote>\n<p>If pointers have the same permissions the full range, I can make being wildcard a property of  the pointer, and not have to make it a property of every stack.</p>\n</blockquote>\n<p>wait, I am confused. of course this is a property of the pointer.<br>\non the stack side we have this \"unknown stack\" thing we discussed recently. I though?</p>",
        "id": 278491550,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627388
    },
    {
        "content": "<p>Poor wording, it's a property of the pointer, but it has to be stored in the stacks. Aka, I can't just make an <code>SbTag::Wildcard</code>.</p>",
        "id": 278491606,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627438
    },
    {
        "content": "<p>right, I thought we had reached consensus that stacks look like now but you add a <code>bool</code> flag indicating \"there is more unknown stuff below the things in that <code>Vec&lt;Item&gt;</code>\"</p>",
        "id": 278491626,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627497
    },
    {
        "content": "<p>Ah, I'm derping. Got any implementation tips for that?</p>",
        "id": 278491698,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627587
    },
    {
        "content": "<p>Right now I have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Clone, Debug, PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Stack</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Used *mostly* as a stack; never empty.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Invariants:</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * Except for `Untagged`, no tag occurs in the stack more than once.</span>\n<span class=\"w\">    </span><span class=\"n\">borrows</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Tags that should be treated as wildcards.</span>\n<span class=\"w\">    </span><span class=\"n\">treated_as_wildcard</span>: <span class=\"nc\">FxHashSet</span><span class=\"o\">&lt;</span><span class=\"n\">SbTag</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491704,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627596
    },
    {
        "content": "<p>oh I see</p>",
        "id": 278491712,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627630
    },
    {
        "content": "<p><code>treated_as_wildcard</code> should be in <code>GlobalState</code></p>",
        "id": 278491716,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627638
    },
    {
        "content": "<p>also <code>exposed</code> might be a better name</p>",
        "id": 278491763,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627662
    },
    {
        "content": "<p>it's not like those tags are treated like wildcards, it's the other way around -- wildcard pointers are treated as if they are any of those tags</p>",
        "id": 278491770,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627678
    },
    {
        "content": "<p>Those are two seperate things, I have this here:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">GlobalStateInner</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Hashset of all pointers that have been exposed</span>\n<span class=\"w\">    </span><span class=\"n\">exposed_tags</span>: <span class=\"nc\">FxHashSet</span><span class=\"o\">&lt;</span><span class=\"n\">SbTag</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491787,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627702
    },
    {
        "content": "<p>Basically from a <code>*mut (u32, UnsafeCell&lt;u32&gt;)</code> to a <code>&amp;mut (u32, UnsafeCell&lt;u32&gt;)</code>, the last 4 bytes should still have wildcard provenance if we want no false positives.</p>",
        "id": 278491796,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627737
    },
    {
        "content": "<p>if you have that global thing you shouldnt need anything in the <code>Stack</code> besides a <code>bool</code></p>",
        "id": 278491854,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627795
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Stack</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Used *mostly* as a stack; never empty.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Invariants:</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * Except for `Untagged`, no tag occurs in the stack more than once.</span>\n<span class=\"w\">    </span><span class=\"n\">borrows</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Indicates that below the items listed above, an unknown set of further items exists.</span>\n<span class=\"w\">    </span><span class=\"n\">unknown_bottom</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491866,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627839
    },
    {
        "content": "<p>and then the trick will be figuring out what that does in the existing checks. that will need some refactoring.</p>",
        "id": 278491874,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627866
    },
    {
        "content": "<p>basically, if <code>find_granting</code> doesnt find anything in <code>borrows</code> but <code>unknown_bottom</code> is <code>true</code>, it has to say \"yeah I think there might be a granting item but I dont know what it looks like\"</p>",
        "id": 278491916,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627898
    },
    {
        "content": "<p>Ah. Here's my <code>find_granting</code> right now for reference:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">is_wildcard</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SbTag</span>::<span class=\"n\">Wildcard</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">treated_as_wildcard</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tag</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">borrows</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">enumerate</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// we also need to know *where* in the stack</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">rev</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// search top-to-bottom</span>\n<span class=\"w\">    </span><span class=\"c1\">// Return permission of first item that grants access.</span>\n<span class=\"w\">    </span><span class=\"c1\">// We require a permission with the right tag, ensuring U3 and F3.</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">find_map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// a wildcard tag allows access to all exposed tags</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wildcard_match</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">is_wildcard</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"p\">.</span><span class=\"n\">exposed_tags</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">tag</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wildcard_match</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">tag</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">perm</span><span class=\"p\">.</span><span class=\"n\">grants</span><span class=\"p\">(</span><span class=\"n\">access</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278491932,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649627940
    },
    {
        "content": "<p>I dont even conceptually understand what you mean by treating an item in the borrow stack as a wildcard</p>",
        "id": 278491943,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627982
    },
    {
        "content": "<p>Why is it <code>unknown_bottom</code> instead of an <code>Unknown</code> stack element that acts like an unknown list of borrow stack elements in the middle?</p>",
        "id": 278492014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649628016
    },
    {
        "content": "<p>like shouldn't <code>[SRW a, unknown, SRW c]</code> be a possibility</p>",
        "id": 278492052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649628039
    },
    {
        "content": "<p>if a wildcard pointer is used on a stack with <code>unknown_bottom == false</code> (i.e. the first time it is used), you search <code>borrows</code> and if any item there is in <code>global.exposed</code>, this matches... and you basically replace the entire stack by \"unknown\". (not sure if there is any information we can usefully preserve here.)</p>",
        "id": 278492057,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628056
    },
    {
        "content": "<p>Yeah I may be way off-base here.</p>",
        "id": 278492070,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649628066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> good question! I thought so, too, at first. but I dont think there is any point in preserving the part of the stack below <code>unknown</code>. it will never be relevant again.</p>",
        "id": 278492076,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628086
    },
    {
        "content": "<p>But I'm not treating an items as a wildcard, I'm treating the <code>SbTag::Tagged(PtrId)</code> as a wildcard.</p>",
        "id": 278492082,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649628096
    },
    {
        "content": "<p><code>find_granting</code> always returns true when it hits the first <code>unknown</code>, so it'll never even look at the stuff below</p>",
        "id": 278492085,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628108
    },
    {
        "content": "<p>If you have <code>[Unique a, unknown]</code> and derive a pointer from <code>a</code>, I think it will pop the <code>unknown</code></p>",
        "id": 278492125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649628133
    },
    {
        "content": "<p>hm...</p>",
        "id": 278492162,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628229
    },
    {
        "content": "<p>that would require an even more clever <code>find_granting</code></p>",
        "id": 278492204,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628260
    },
    {
        "content": "<p>basically it has to exploit that tags in borrow stacks are unique, and so <code>a</code> can <em>not</em> be in 'unknown', and so it can be skipped</p>",
        "id": 278492209,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628283
    },
    {
        "content": "<p>because naively, even when searching for <code>a</code>, it'd just say \"hit\" when finding the <code>unknown</code></p>",
        "id": 278492218,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628309
    },
    {
        "content": "<p>I think you would search for <code>a</code>, and as you walk the stack you take note when you pass <code>unknown</code> but only use that to grant the access if you don't find the <code>a</code> tag further along</p>",
        "id": 278492243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649628346
    },
    {
        "content": "<p>yeah...</p>",
        "id": 278492283,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628373
    },
    {
        "content": "<p>but you are right we could be more precise here. good catch!</p>",
        "id": 278492291,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628395
    },
    {
        "content": "<p>Mmm yeah <code>Unknown</code> would make some of this easier.</p>",
        "id": 278492324,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649628479
    },
    {
        "content": "<p>I still think we need <code>treated_as_wildcard</code> (I'm realizing this is a terrible name) for the <code>*mut (u32, UnsafeCell&lt;u32&gt;)</code> to a <code>&amp;mut (u32, UnsafeCell&lt;u32&gt;)</code> case though.</p>",
        "id": 278492375,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649628545
    },
    {
        "content": "<p>Because if you just return true when hitting an <code>unknown</code>, then something like this would be allowed:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_num</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">expose_addr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">b_num</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// I think this should be UB</span>\n</code></pre></div>",
        "id": 278492549,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649628819
    },
    {
        "content": "<p>that does doesnt involve an <code>UnsafeCell</code> though?</p>",
        "id": 278495652,
        "sender_full_name": "RalfJ",
        "timestamp": 1649633859
    },
    {
        "content": "<p>I agree that code should be UB, I dont agree we have to catch that code. don't make the perfect the enemy of the good. if you call <code>expose_addr</code>, <em>expect</em> some missed UB.</p>",
        "id": 278495706,
        "sender_full_name": "RalfJ",
        "timestamp": 1649633926
    },
    {
        "content": "<p>If you have a global list of exposed tags (not sure if this is <code>treated_as_wildcard</code> or <code>exposed_tags</code> in your implementation), then you should be able to catch this one, since <code>a</code> is not exposed</p>",
        "id": 278498755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649638413
    },
    {
        "content": "<p>Yeah, that's <code>exposed_tags</code>. I have my <code>find_granting</code> as this right now.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tag_is_wildcard</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">wildcard_tags</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tag</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">borrows</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">enumerate</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// we also need to know *where* in the stack</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">rev</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// search top-to-bottom</span>\n<span class=\"w\">    </span><span class=\"c1\">// Return permission of first item that grants access.</span>\n<span class=\"w\">    </span><span class=\"c1\">// We require a permission with the right tag, ensuring U3 and F3.</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">find_map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// A wildcard tag allows access to all exposed tags</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wildcard_match</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tag_is_wildcard</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"p\">.</span><span class=\"n\">exposed_tags</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">tag</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wildcard_match</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">tag</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">perm</span><span class=\"p\">.</span><span class=\"n\">grants</span><span class=\"p\">(</span><span class=\"n\">access</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278499100,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649638919
    },
    {
        "content": "<p>I could refactor it so that exposing the address of a pointer pushes an <code>Unknown</code> with the same permission directly on top, and change the logic inside of the <code>find_map</code> closure.</p>",
        "id": 278499229,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649639048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278498755\">said</a>:</p>\n<blockquote>\n<p>If you have a global list of exposed tags (not sure if this is <code>treated_as_wildcard</code> or <code>exposed_tags</code> in your implementation), then you should be able to catch this one, since <code>a</code> is not exposed</p>\n</blockquote>\n<p>but there'll be <code>Unknown</code> in the borrow stack of <code>x[1]</code> and <code>a</code> might match that so it should be accepted. unless we go even further and refine <code>unknown</code> by tracking which tags might be in there. but I would not do that for a first prototype.^^</p>",
        "id": 278503119,
        "sender_full_name": "RalfJ",
        "timestamp": 1649644733
    },
    {
        "content": "<p>Is there a reason why this code doesn't put the new <code>SharedReadWrite</code> directly on top?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">            </span><span class=\"c1\">// SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write</span>\n<span class=\"w\">            </span><span class=\"c1\">// access. Instead of popping the stack, we insert the item at the place the stack would</span>\n<span class=\"w\">            </span><span class=\"c1\">// be popped to (i.e., we insert it above all the write-compatible items).</span>\n<span class=\"w\">            </span><span class=\"c1\">// This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">find_first_write_incompatible</span><span class=\"p\">(</span><span class=\"n\">granting_idx</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278503774,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649645651
    },
    {
        "content": "<p>Actually somewhat of a dumb question now that I think about it, because I can just push the <code>Unknown</code> using this same logic and have it still work.</p>",
        "id": 278503836,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649645771
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/miri/pull/727\">https://github.com/rust-lang/miri/pull/727</a> looks like it changed this behavior from the obvious.</p>",
        "id": 278504128,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649646106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278503119\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278498755\">said</a>:</p>\n<blockquote>\n<p>If you have a global list of exposed tags (not sure if this is <code>treated_as_wildcard</code> or <code>exposed_tags</code> in your implementation), then you should be able to catch this one, since <code>a</code> is not exposed</p>\n</blockquote>\n<p>but there'll be <code>Unknown</code> in the borrow stack of <code>x[1]</code> and <code>a</code> might match that so it should be accepted. unless we go even further and refine <code>unknown</code> by tracking which tags might be in there. but I would not do that for a first prototype.^^</p>\n</blockquote>\n<p>The argument I had in mind was that <code>a</code> can never appear in the <code>Unknown</code> part of a borrow stack because it is not derived from a wildcard pointer and neither it nor any of its ancestors are exposed. This is a property of the tag <code>a</code> and does not need to be tracked in the borrow stack</p>",
        "id": 278540028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649676846
    },
    {
        "content": "<p>It's true that this is a bit sophisticated for v1, but it doesn't seem like something fundamentally unreachable without a total redesign like some of the other things we've talked about, so it might fit in v2</p>",
        "id": 278540453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649677088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278540028\">said</a>:</p>\n<blockquote>\n<p>neither it nor any of its ancestors are exposed</p>\n</blockquote>\n<p>Actually, I don't think it's even necessary to care about ancestors here, since even if you got a hold of <code>a</code>'s parent you can't use it to make another pointer with tag <code>a</code>, any reborrow would result in a fresh tag. The only way to get <code>a</code> itself is if it is exposed and then picked up by a wildcard pointer</p>",
        "id": 278540667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649677238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278504128\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-lang/miri/pull/727\">https://github.com/rust-lang/miri/pull/727</a> looks like it changed this behavior from the obvious.</p>\n</blockquote>\n<p>I dont see the relation between that PR and your question</p>",
        "id": 278578603,
        "sender_full_name": "RalfJ",
        "timestamp": 1649694007
    },
    {
        "content": "<p>regarding the question, that would disallow some safe code you can write with RefCell</p>",
        "id": 278578638,
        "sender_full_name": "RalfJ",
        "timestamp": 1649694023
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/miri/blob/master/tests/run-pass/stacked-borrows/refcell.rs\">https://github.com/rust-lang/miri/blob/master/tests/run-pass/stacked-borrows/refcell.rs</a> has some nasty examples</p>",
        "id": 278578680,
        "sender_full_name": "RalfJ",
        "timestamp": 1649694051
    },
    {
        "content": "<p>with RefCell you can have an <code>&amp;RefCell</code> and a <code>&amp;mut T</code> <em>that overlap</em> and both are active at the same time</p>",
        "id": 278578725,
        "sender_full_name": "RalfJ",
        "timestamp": 1649694078
    },
    {
        "content": "<p>then if someone reborrows the <code>&amp;RefCell</code> we have to not destroy that <code>&amp;mut T</code></p>",
        "id": 278578751,
        "sender_full_name": "RalfJ",
        "timestamp": 1649694089
    },
    {
        "content": "<p>so we have to be very careful when reborrowing for SRW</p>",
        "id": 278578764,
        "sender_full_name": "RalfJ",
        "timestamp": 1649694097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278578603\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278504128\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-lang/miri/pull/727\">https://github.com/rust-lang/miri/pull/727</a> looks like it changed this behavior from the obvious.</p>\n</blockquote>\n<p>I dont see the relation between that PR and your question</p>\n</blockquote>\n<p>When reborrowing a SRW from a SRW, why is the resulting SRW placed on top of the block of SRWs, and not on top of the  original SRW? The PR changes the behavior from the latter to the former.</p>",
        "id": 278611509,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649708608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278384176\">said</a>:</p>\n<blockquote>\n<p>Right now, <code>addr</code> is implemented via transmute in my experiments. Similarly, <code>invalid</code> is a transmute in the other direction.</p>\n</blockquote>\n<p>I mean, eventually you need to make it a lang item in order to implement an intrinsic right. Why not just jump there now.</p>",
        "id": 278617289,
        "sender_full_name": "riking",
        "timestamp": 1649711424
    },
    {
        "content": "<p>doesnt need to be a lang item, but yeah it should probably be an intrinsic</p>",
        "id": 278624415,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715434
    },
    {
        "content": "<blockquote>\n<p>When reborrowing a SRW from a SRW, why is the resulting SRW placed on top of the block of SRWs, and not on top of the SRW that we derived_from? The PR changes the behavior from the latter to the former.</p>\n</blockquote>\n<p>the order of a bunch of SRWs in a block doesn't matter at all, so where in that block we but it is irrelevant</p>",
        "id": 278624476,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715464
    },
    {
        "content": "<p>so, this was probably a side-effect of a refactor, where now the other way is more natural to implement</p>",
        "id": 278624595,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715514
    },
    {
        "content": "<p>(or I am misunderstanding the question)</p>",
        "id": 278624609,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715525
    },
    {
        "content": "<p>Ah ok, just checking that it was indeed irrelevant.</p>",
        "id": 278624646,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649715552
    },
    {
        "content": "<p>if it's all just within a block of SRW then yes it is irrelevant</p>",
        "id": 278624832,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715678
    },
    {
        "content": "<p>Is there any way to force the int2ptr casts here to not give <code>q1</code> and <code>q2</code> the same provenance? (i.e. so that <code>q1=p1</code>, <code>q2=p2</code> and <code>q1=p2</code>,<code>q2=p1</code> are sound but <code>q1=q2=p1</code> and <code>q1=q2=p2</code> is not)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">r1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278679802,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649763411
    },
    {
        "content": "<p>I mean, with angelic non-determinism, you can just choose. Pretend they have the provenance you like and go about your day like normal. I must not be understanding your goal here</p>",
        "id": 278681613,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649764555
    },
    {
        "content": "<p>My goal is to find a program where angelic non-provenance is _forced_ to make such a choice, as opposed to a program where that choice is allowed.</p>",
        "id": 278682362,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649764903
    },
    {
        "content": "<p>i.e. angelic non-provenance will always make a choice such that the program has defined behavior if one exists, so the choices I want should be the only ones for which the behavior is defined</p>",
        "id": 278682497,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649764985
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// this should be UB</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// this should not be UB</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and similarly for the two other cases</p>",
        "id": 278682642,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649765066
    },
    {
        "content": "<p>(Context is that I attempted to show that making an implementation of angelic non-determinism is NP-complete, and all of my attempts required something like the above.)</p>",
        "id": 278683363,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649765499
    },
    {
        "content": "<p>Unless I'm missing something, that's just (assuming tagged-raw-pointers):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">*</span><span class=\"n\">q2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">q1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278684000,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649765910
    },
    {
        "content": "<p>This one also should not be UB, and unless I'm missing something, your example is UB here. (because you invalidated <code>r2</code> with the first write)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278684248,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649766068
    },
    {
        "content": "<p>Oh, I see</p>",
        "id": 278684434,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649766190
    },
    {
        "content": "<p>You might be able to do this with <code>UnsafeCell</code> shenanigans</p>",
        "id": 278684455,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649766208
    },
    {
        "content": "<p>Unless you're adding some runtime branching based on opaque values, I don't think that's possible. You can't dereference p2 and then p1, but you can dereference p1 and then p2. (So no single execution can be valid for both permutations)</p>",
        "id": 278685335,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649766694
    },
    {
        "content": "<p>I also could not find any way to do it.</p>",
        "id": 278685635,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649766857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278682362\">said</a>:</p>\n<blockquote>\n<p>My goal is to find a program where angelic non-provenance is _forced_ to make such a choice, as opposed to a program where that choice is allowed.</p>\n</blockquote>\n<p>see the <a href=\"https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html#appendix\">appendix</a> of my blog post? :)</p>",
        "id": 278701246,
        "sender_full_name": "RalfJ",
        "timestamp": 1649774005
    },
    {
        "content": "<p>Hmm, it doesn't quite do it..</p>",
        "id": 278707344,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649776366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> then I dont understand what you are asking for. that code is an example where, given the same integer, two different casts <em>have</em> to produce different provenance.</p>",
        "id": 278715413,
        "sender_full_name": "RalfJ",
        "timestamp": 1649779921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278682362\">said</a>:</p>\n<blockquote>\n<p>My goal is to find a program where angelic non-provenance is _forced_ to make such a choice, as opposed to a program where that choice is allowed.</p>\n</blockquote>\n<p>isn't that what you mean here? ^</p>",
        "id": 278715473,
        "sender_full_name": "RalfJ",
        "timestamp": 1649779935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278715473\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance/near/278682362\">said</a>:</p>\n<blockquote>\n<p>My goal is to find a program where angelic non-provenance is _forced_ to make such a choice, as opposed to a program where that choice is allowed.</p>\n</blockquote>\n<p>isn't that what you mean here? ^</p>\n</blockquote>\n<p>I think the goal is this: Consider two int to pointer casts yielding <code>p</code> and <code>q</code>, where the allowed provenances for each pointer are exactly <code>a, b</code>. Find a program in which <code>prov(p) = a, prov(q) = b</code> and <code>prov(p) = b, prov(q) = a</code> would both lead to defined behavior, but neither of the other two choices would</p>",
        "id": 278716173,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649780298
    },
    {
        "content": "<p>uh. okay that's a fun puzzle but I dont quite understand why it's interesting.</p>",
        "id": 278716402,
        "sender_full_name": "RalfJ",
        "timestamp": 1649780405
    },
    {
        "content": "<p>Alice said that she was attempting to prove that checking weak provenance is NP-Complete</p>",
        "id": 278716689,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649780538
    },
    {
        "content": "<p><span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 278717491,
        "sender_full_name": "RalfJ",
        "timestamp": 1649780927
    }
]