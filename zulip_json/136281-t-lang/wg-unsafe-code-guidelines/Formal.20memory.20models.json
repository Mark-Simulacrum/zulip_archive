[
    {
        "content": "<p>In <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA\">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA</a> , I wrote down my understanding of the formal memory models under consideration, with two specific programs that are(n‚Äôt) UB. Is my understanding about (non)-UB correct?</p>",
        "id": 277532517,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648909657
    },
    {
        "content": "<p>For those programs specifically</p>",
        "id": 277532706,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648909895
    },
    {
        "content": "<p>the 2nd example <em>is</em> UB under permissive provenance</p>",
        "id": 277629308,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992827
    },
    {
        "content": "<p>under the version I have been promoting the last week, anyway</p>",
        "id": 277629322,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992838
    },
    {
        "content": "<p>the following is not UB:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">storage</span><span class=\"w\"> </span>: <span class=\"kt\">i8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x_int</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">storage</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">storage</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">//! ------------------------------------</span>\n<span class=\"w\">    </span><span class=\"sd\">//!</span>\n<span class=\"w\">    </span><span class=\"sd\">//!   - x_int : usize</span>\n<span class=\"w\">    </span><span class=\"sd\">//!   - y :     &amp;mut i8</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\">  </span><span class=\"n\">y_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The raw pointer receives provenance from y_ptr! ü§Ø</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x_int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">y_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">34</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">storage</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277629421,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992882
    },
    {
        "content": "<p><code>x_int as *mut i8</code> needs to be able to pick some <em>previously exposed</em> provenance, and in your version of the code no suitable provenance has been exposed. in my version, the <code>y_ptr as usize</code> does the exposing.</p>",
        "id": 277629493,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992930
    },
    {
        "content": "<p>Cool, that‚Äôs also a version that I could imagine a formalization for</p>",
        "id": 277647609,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649002695
    },
    {
        "content": "<p>These alternative memory models are mostly not written up mathematically, only in code (or only informally), right?</p>",
        "id": 277647628,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649002738
    },
    {
        "content": "<p>yeah</p>",
        "id": 277647705,
        "sender_full_name": "RalfJ",
        "timestamp": 1649002834
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>üèª Thanks</p>",
        "id": 277647709,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649002849
    },
    {
        "content": "<p>I will adjust the document when I have time</p>",
        "id": 277647717,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649002860
    },
    {
        "content": "<p>I read the twinsem paper, and I think it's pretty ingenuous. It seems a minimal change required to LLVM to make \"all\" sensible C/C++ programs compile, and compile almost everything well. </p>\n<p>Twinsem is a very different approach than SB/pnvi-ae ‚Äî I'd call it extrinsic instead of intrinsic. In both cases there is a cost to ptr2int2ptr (what you call a \"side-effect\"), but Twinsem ascribes the cost to specific runtime behavior while SB/pnvi-ae ascribes it to language constructs. I think that's why LLVM refuse to call ptr2int side-effecting ‚Äî because a clever compiler _doesn't_ incur a cost if you throw away the int immediately after. They can't call any construct side-effecting because the cost is in \"\"emergent behavior of the instructions\"\". </p>\n<p>Intrinsic has the advantage that you can give guidance: \"try to avoid ptr2int\". And it seems compiling SB to Twinsem should be fine ‚Äî then SB's formulation of the cost is just a bit pessimistic, it gives an overestimate of the costs you're incurring. If you follow the guidance \"avoid ptr2int\" then you also avoid all the costs on the LLVM side.</p>",
        "id": 277663658,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649023521
    },
    {
        "content": "<p>yeah I am quite fond of twinsem. sadly the twinsem approach stops working once you have <code>restrict</code>/<code>noalias</code>/Stacked Borrows, as demonstrated by <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html\">this example</a>. I hope to finish a blog post on that soon-ish.</p>",
        "id": 277665383,
        "sender_full_name": "RalfJ",
        "timestamp": 1649025794
    },
    {
        "content": "<p>Interesting. I'm curious for the blog post.</p>\n<p>I would think that <code>foo(ptr, (uintptr_t)ptr);</code> is not legal, because under a twinsem semantics, <code>x=ptr</code> is guessable from <code>y=(uintptr_t)ptr</code>.</p>",
        "id": 277666562,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649027402
    },
    {
        "content": "<p>but why would that make the call not legal?</p>",
        "id": 277667482,
        "sender_full_name": "RalfJ",
        "timestamp": 1649028826
    },
    {
        "content": "<p>Well, we need a formal definition of <code>noalias</code>.</p>\n<p><code>noalias</code> is currently informally defined as</p>\n<blockquote>\n<p>[noalias] indicates that memory locations accessed via pointer values based on the argument or return value are not also accessed, during the execution of the function, via pointer values not based on the argument or return value. (..) The caller shares the responsibility with the callee for ensuring that these requirements are met. (..)</p>\n</blockquote>\n<p>I posit the following \"twinsem\" definition of <code>noalias</code>.</p>\n<hr>\n<p>Suppose that we have</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">noalias</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">noalias</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>noalias</code> puts an obligation on every execution of the whole program.</p>\n<p>So let an execution of the whole program be given. In Twinsem, this execution of a program is really a set of traces.</p>\n<p>Let <code>check1</code>, <code>check2</code> range over syntactic procedures that are always successful, with the following signatures</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">check1</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">check2</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Suppose that as part of the execution, <code>bar</code> is called.</p>\n<p>When instead of <code>bar(val_x, val_y, val_z)</code> we substitute <code>{check1(val_x, val_z); check2(val_x, val_y); bar(val1, val_y, val_z)}</code> for every call in the program, then</p>\n<ul>\n<li>\n<p>the call to <code>check1(val_x, val_z)</code> may not reliably (in every trace of the execution) compute an address into the allocation for <code>val_y</code>,</p>\n</li>\n<li>\n<p>the call to <code>check2(val_x, val_y)</code> may not reliably (in every trace of the execution) compute an address into the allocation for <code>val_z</code>.</p>\n</li>\n</ul>\n<p>Otherwise, this call to <code>bar</code> generates UB.</p>\n<hr>\n<p>(Is this <em>the</em> formal definition? Is there a simpler one?)</p>\n<p>For your <code>foo</code>, if it runs, then I think the call site fails the requirement.</p>\n<p>What a mess, though.</p>",
        "id": 277670614,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649033091
    },
    {
        "content": "<p>This does not match with the actual definition of <code>noalias</code> unfortunately. <code>noalias</code> is about <em>accesses</em>, not about values of pointers. It is defined behavior to pass two aliasing pointers into <code>void bar(void * noalias x, void * noalias y)</code> as long as at least one of the pointers is never dereferenced</p>",
        "id": 277672156,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649035383
    },
    {
        "content": "<p>Ah, yes. Then I have no idea what <code>noalias</code> could mean formally. </p>\n<p>Is <code>while (++x != y) ; *x</code> an access via x, via y, or both?</p>",
        "id": 277674664,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649038896
    },
    {
        "content": "<p>Because it essentially sets x to the value of y</p>",
        "id": 277674704,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649038924
    },
    {
        "content": "<p>What about <code>while (x != y) x = random()</code></p>",
        "id": 277674723,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649038966
    },
    {
        "content": "<p>If x and y are the same, what about <code>(x+y) / 2</code> (disregarding overflow)</p>",
        "id": 277674913,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649039193
    },
    {
        "content": "<p>LLVM doesn't support most of those operations on pointers</p>",
        "id": 277675075,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649039457
    },
    {
        "content": "<p>The closest thing it has is GEP, and that only accepts one pointer argument, so things are unambiguous</p>",
        "id": 277675083,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649039477
    },
    {
        "content": "<p>We can insert pointer-integer-pointer casts as needed to make the examples work</p>",
        "id": 277675358,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649039904
    },
    {
        "content": "<p>Yes, but at that point you're just once more observing that LLVM's semantics around ptr2int and int2ptr casts are broken...</p>",
        "id": 277675675,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649040286
    },
    {
        "content": "<p>And as far as I know, there's no published model for how PNVI-ae-udi can work with restrict/noalias</p>",
        "id": 277675697,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649040336
    },
    {
        "content": "<p>I mean, you can have two entirely disjoint restrictions, like C does today; the question is whether that allows the optimizations <code>restrict</code> is intended to allow</p>",
        "id": 277676653,
        "sender_full_name": "Talchas",
        "timestamp": 1649041327
    },
    {
        "content": "<p>(though first you'd also need to do something about how the spec definition of <code>restrict</code> is probably more generous to programmers than anything a compiler will implement)</p>",
        "id": 277676669,
        "sender_full_name": "Talchas",
        "timestamp": 1649041364
    },
    {
        "content": "<p>Maybe the point of <code>noalias</code> is merely to give examples of execution patterns that are Obviously Bad, and LLVM promises to be conservative for anything that‚Äôs not Obviously Bad.</p>",
        "id": 277707536,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649066034
    },
    {
        "content": "<p>The problem that Ralf is pointing out, being that optimization turns not-Obviously-Bad code into Obviously Bad</p>",
        "id": 277707794,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649066158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Formal.20memory.20models/near/277674664\">said</a>:</p>\n<blockquote>\n<p>Ah, yes. Then I have no idea what <code>noalias</code> could mean formally. </p>\n</blockquote>\n<p>it's loosely something like Stacked Borrows, I think. well, without the stacks and the borrows. ;)<br>\nyou generate a fresh provenance for each <code>restrict</code> parameter (like SB retagging). you track which provenances are used to access each location in memory. if two 'conflicting' provenances (whatever that mean) access the same location, that is UB.</p>",
        "id": 277922562,
        "sender_full_name": "RalfJ",
        "timestamp": 1649182983
    },
    {
        "content": "<p>Hm, that could be the start to an answer</p>",
        "id": 277926279,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649184263
    },
    {
        "content": "<p>What happens here? In the first statement, we \"access a memory location via a pointer value based on\"... perhaps both <code>hi</code> and <code>lo1</code> arguments I guess? Is the second statement allowed? (When pointer values are based on multiple arguments, what's the boolean formula here?)</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">ptri</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">ptri</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">~</span><span class=\"mh\">0xff</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">ptri</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mh\">0xff</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">ptri</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mh\">0xff</span><span class=\"p\">))</span><span class=\"w\"></span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"kr\">restrict</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"kr\">restrict</span><span class=\"w\"> </span><span class=\"n\">lo1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">lo2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">hi</span><span class=\"o\">|</span><span class=\"n\">lo1</span><span class=\"p\">));</span><span class=\"w\"> </span><span class=\"c1\">// allowed?</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">hi</span><span class=\"o\">|</span><span class=\"n\">lo2</span><span class=\"p\">));</span><span class=\"w\"> </span><span class=\"c1\">// allowed?</span>\n\n<span class=\"w\">    </span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">lo1</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">new</span><span class=\"o\">++</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// What is the provenance of new?</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">// Perhaps it has empty or fresh provenance.</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">// Then presumably it cannot be optimized to</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">//     uintptr_t new = hi | lo1</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">// because that would change provenance.</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277926325,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649184282
    },
    {
        "content": "<p>restrict is invalid except on pointer types</p>",
        "id": 277926829,
        "sender_full_name": "Talchas",
        "timestamp": 1649184523
    },
    {
        "content": "<p>if they were pointers instead, I believe /currently/ accessing through <code>hi|lo2</code> is invalid if you ever access through <code>hi|lo1</code> as well</p>",
        "id": 277926967,
        "sender_full_name": "Talchas",
        "timestamp": 1649184600
    },
    {
        "content": "<p>the question is ill-formed since there is no <code>|</code> on pointer types ;)</p>",
        "id": 277927167,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184674
    },
    {
        "content": "<p>this goes into union provenance again which as I keep saying is a very non-trivial extension for complicated aliasing models</p>",
        "id": 277927227,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184709
    },
    {
        "content": "<p>which is why I dont think we should have it ;)</p>",
        "id": 277927249,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184720
    },
    {
        "content": "<p>and the C proposal's stance in other places is that control flow dependencies like <code>switch (*ptr) { case 0: return 0; ... }</code> should not be expected to preserve provenance (while they'd like <code>*char_x = *char_y</code> to do so that transforming manual char copies to just memcpy is valid).</p>",
        "id": 277927330,
        "sender_full_name": "Talchas",
        "timestamp": 1649184737
    },
    {
        "content": "<p>and for pointers <code>==</code> is not actual full equality in general anyways, so once you change hi/lo1 to pointer types that's less surprising</p>",
        "id": 277927461,
        "sender_full_name": "Talchas",
        "timestamp": 1649184821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Formal.20memory.20models/near/277926829\">said</a>:</p>\n<blockquote>\n<p>restrict is invalid except on pointer types</p>\n</blockquote>\n<p>I should have written <code>noalias</code>, the question was about <code>noalias</code>. I don't see anywhere that <code>noalias</code> applies only to pointer arguments.</p>",
        "id": 277931638,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649186721
    },
    {
        "content": "<p>llc on</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">void</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">noalias</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">void</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>gives \"Attribute 'noalias' applied to incompatible type!\" Though I agree that LangRef doesn't state that.</p>",
        "id": 277933604,
        "sender_full_name": "Talchas",
        "timestamp": 1649187821
    },
    {
        "content": "<p>so I guess LLVM also gets to dodge that by forcing them to be pointers and then not having <code>pointer = pointer op pointer</code></p>",
        "id": 277934308,
        "sender_full_name": "Talchas",
        "timestamp": 1649188200
    },
    {
        "content": "<p>Ah! This helps a lot. This kinda implies that they mean ‚Äúbased on‚Äù specifically as GEP</p>",
        "id": 277936201,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649189083
    },
    {
        "content": "<p>Hm, I still don‚Äôt know that that‚Äôs formal. But it‚Äôs closer: I can now carve out a space of ‚Äúdefinitely UB‚Äù and ‚Äúdefinitely fine‚Äù</p>",
        "id": 277936424,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649189172
    },
    {
        "content": "<p>yeah, they list exactly the operations for their \"based on\" in <a href=\"https://llvm.org/docs/LangRef.html#pointeraliasing\">https://llvm.org/docs/LangRef.html#pointeraliasing</a> complete with pure handwave for \"what about inttoptr\"</p>",
        "id": 277936551,
        "sender_full_name": "Talchas",
        "timestamp": 1649189241
    },
    {
        "content": "<p>Oh, nice, thanks!</p>",
        "id": 277938053,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649189986
    }
]