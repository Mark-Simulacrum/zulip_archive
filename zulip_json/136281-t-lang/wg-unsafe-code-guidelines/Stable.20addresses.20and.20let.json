[
    {
        "content": "<p>I was recently pointed to this open issue: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/15\">https://github.com/rust-lang/unsafe-code-guidelines/issues/15</a></p>\n<p>Do we really not guarantee that variables have stable addresses when you create references to them? If this also applies to the reference passed to destructors, then macros like <code>futures::pin_mut!</code> are incorrect since they assume that the <code>Pin&lt;&amp;mut T&gt;</code> reference that the macro creates has the same address as the reference passed to the destructor.</p>",
        "id": 276221489,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1647968586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> on the MIR level we guarantee that a local has a stable address from its <code>StorageLive</code> until its next <code>StorageDead</code></p>",
        "id": 276731717,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309355
    },
    {
        "content": "<p>but e.g. a <code>let</code> in a loop can have a new address in each loop iteration</p>",
        "id": 276731728,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309367
    },
    {
        "content": "<p>we have not really specified how surface Rust maps to MIR storage annotations, but I would generally expect that the address remains stable from the first write until move or drop. however I am less sure about re-initialized locals.</p>",
        "id": 276731753,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> according to the issue, it's an open question whether that's guaranteed even without a redefinition? If we do guarantee that, then we should probably close the issue or write that somewhere, or something.</p>",
        "id": 276742928,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648324685
    },
    {
        "content": "<p>I think basically nothing is guaranteed on the surface level mostly since so far this is just not talked about explicitly anywhere</p>",
        "id": 276746261,
        "sender_full_name": "RalfJ",
        "timestamp": 1648329371
    },
    {
        "content": "<p>but it seems impossible for us to break this</p>",
        "id": 276746268,
        "sender_full_name": "RalfJ",
        "timestamp": 1648329392
    },
    {
        "content": "<p>I'm all for turning this into a proper guarantee, it just takes someone to push for it. This is a tricky subject to talk about precisely because it affects not only MIR semantics but Rust â†’ MIR lowering.</p>",
        "id": 276746282,
        "sender_full_name": "RalfJ",
        "timestamp": 1648329427
    },
    {
        "content": "<p>Given how many functions use temporary references, it feels like there might be a potential optimization loss if taking a reference to a value <em>ever</em> forces it to always live at that address for the rest of time.</p>",
        "id": 276749249,
        "sender_full_name": "Lokathor",
        "timestamp": 1648333598
    },
    {
        "content": "<p>I'd expect stable addresses to be bounded by the SB borrow stack. i.e. maximally stable would be until the binding is next <code>&amp;mut</code>ed or assigned to. It seems \"morally\" correct that while a valid tag is on the stack, it can be used to access the value.<br>\nBut yeah, that does seem to prevent some optimization of on-the-fly stack reorganization, so I'm not sure.</p>",
        "id": 276750349,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648335150
    },
    {
        "content": "<p>SB can only help with actual memory accesses though</p>",
        "id": 276750454,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335333
    },
    {
        "content": "<p>if you use ptr comparison to check of a variable has a stable address, SB cannot affect that</p>",
        "id": 276750456,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335348
    },
    {
        "content": "<p>IOW, \"address stability\" and SB are wholly unrelated</p>",
        "id": 276750457,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335357
    },
    {
        "content": "<p>Ah fair</p>",
        "id": 276750513,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648335409
    },
    {
        "content": "<p>(for a blessed instant I lived in a world where a) you can't compare pointers to different \"objects\", of which an empty borrow stack makes a new \"object\" and b) ptrtoint doesn't exist)<br>\n(basically I forgot that addresses are observable beyond being used for accesses)</p>",
        "id": 276750634,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648335586
    },
    {
        "content": "<p>yes such a world would make life a lot easier indeed :(</p>",
        "id": 276751056,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336044
    },
    {
        "content": "<p>but Rust made comparing <em>arbitrary, even dangling pointers</em> a <strong>safe operation</strong> so that's <em>very far</em> from the world we live in</p>",
        "id": 276751065,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336067
    },
    {
        "content": "<p>(Even hashing them, for extra \"fun\")</p>",
        "id": 276751239,
        "sender_full_name": "scottmcm",
        "timestamp": 1648336308
    },
    {
        "content": "<p>i think banning inttoptr kills most of the \"crimes\" arbitrary pointer comparisons can introduce and mostly just leaves you with \"code that gets stupid answers for asking stupid questions\"</p>",
        "id": 276751865,
        "sender_full_name": "Gankra",
        "timestamp": 1648337182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I dont see any connection between issues caused by ptr comparisons and inttoptr</p>",
        "id": 276789416,
        "sender_full_name": "RalfJ",
        "timestamp": 1648389089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> basically pointer-comparisons between two different allocations (by defining it as address-comparison) is only conceptually terrifying if you're allowed to actually take action on that comparison directly with things like inttoptr IMO</p>",
        "id": 276790046,
        "sender_full_name": "Gankra",
        "timestamp": 1648389886
    },
    {
        "content": "<p>i.e. this person was just asking me about it on twitter and really nervous about it (mostly just because C says these kinds of \"blind\" comparisons are UB) but they were in fact doing the responsible thing of going over to the canonical allocation and doing the reslices from there, just like cheri/strict-provenance wants you to: <a href=\"https://twitter.com/bitshiftmask/status/1507856233897893888\">https://twitter.com/bitshiftmask/status/1507856233897893888</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/bitshiftmask/status/1507856233897893888\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b05fb1cdd1e43d0201532bd762bc1414c2888c99/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313436373235303534303831363038393039312f5849575a302d4c685f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> Every time I read about pointer provenance, I get more an more nervous about my library where I use pointers as integers to figure out if one slice \"originates\" from within another.\n\nWhich, works, but no one can figure out what kind of vibes it has.</p><span>- james.poll_on()?; (@bitshiftmask)</span></div></div>",
        "id": 276790260,
        "sender_full_name": "Gankra",
        "timestamp": 1648390120
    },
    {
        "content": "<p>(similarly i have a hacky toy compiler which represents spans as addresses into the original program text, but they are \"resolved\" not by intoptr but by doing a pointer comparison and using the result as an index into the original program text)</p>",
        "id": 276790358,
        "sender_full_name": "Gankra",
        "timestamp": 1648390284
    },
    {
        "content": "<p>hm, that seems orthogonal so the question here though which is whether the address that a <code>let</code>-bound variable is stored at can just silently change. the fact that pointer comparison gives a well-defined result at all already means a change in address can be observed and no amount of aliasing or provenance shenanigans can change this.</p>",
        "id": 276790575,
        "sender_full_name": "RalfJ",
        "timestamp": 1648390563
    },
    {
        "content": "<p>if we didnt have ptr comparison OTOH, then getting \"unique\" access to an allocation would mean nobody else could even notice if we moved it somewhere else</p>",
        "id": 276790596,
        "sender_full_name": "RalfJ",
        "timestamp": 1648390623
    },
    {
        "content": "<p>as in</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// stuff happens</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// more stuff happens</span>\n</code></pre></div>\n<p>no pointer to <code>x</code> that was created in the first 'stuff' can still be used in the 2nd 'stuff' since we are claiming uniqueness by directly accessing the place. so can we move <code>x</code> to a different location at the reassignment? if pointers with 'invalid' provenance would be UB to compare (and ignoring ptr2int), then we could definitely move <code>x</code> to a different location since it would be impossible to even notice that this happened.</p>\n<p>however, as things stand a pointer to <code>x</code> created in the first 'stuff' can still be <em>compared with</em> a pointer to <code>x</code> created in the second stuff, so whether or not <code>x</code> was moved to a different location is observable by the program and thus has to be prescribed by the spec.</p>",
        "id": 276790692,
        "sender_full_name": "RalfJ",
        "timestamp": 1648390780
    },
    {
        "content": "<p>everything you're saying here is correct, i was just replying slightly tangentially, because I know a lot of people have Lingering Terror from pointer comparisons being able to be UB in C and also because e.g. the example in your article hinges on \"accidental\" address equality resulting in messed up conclusions.</p>",
        "id": 276794643,
        "sender_full_name": "Gankra",
        "timestamp": 1648396560
    },
    {
        "content": "<p>oh I see. if we never allow int2ptr to obtain an existing provenance then comparing pointers does <em>not</em> 'leak'/'expose' the pointer in the sense of the corresponding analysis done by the compiler -- even if we give away the result of a ptr comparison, that does not give away the (unique) provenance of our private allocation, and as long as we keep <em>that</em> to ourselves we can still optimize assuming nothing else reads from or writes to our location. That is a very neat consequence of killing general int2ptr that I had not even realized.</p>",
        "id": 276794787,
        "sender_full_name": "RalfJ",
        "timestamp": 1648396797
    },
    {
        "content": "<p>yeah it's just another example of \"you don't <em>actually</em> get to be 'lucky' with evil\"</p>",
        "id": 276794921,
        "sender_full_name": "Gankra",
        "timestamp": 1648396908
    },
    {
        "content": "<p>well my examples aren't lucky, they are just evil ;)</p>",
        "id": 276794966,
        "sender_full_name": "RalfJ",
        "timestamp": 1648396935
    },
    {
        "content": "<p>we already can handle \"you dont get to be lucky\" with things like <a href=\"https://www.ralfj.de/research/twinsem/twinsem.pdf\">https://www.ralfj.de/research/twinsem/twinsem.pdf</a></p>",
        "id": 276794974,
        "sender_full_name": "RalfJ",
        "timestamp": 1648396951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> they \"get lucky\" in the sense of \"we don't actually guarantee these stack vars are adjacent, but you congrats you noticed it\"</p>",
        "id": 276795135,
        "sender_full_name": "Gankra",
        "timestamp": 1648397271
    },
    {
        "content": "<p>in much the same way you \"get lucky\" with a UAF into a reallocation</p>",
        "id": 276795186,
        "sender_full_name": "Gankra",
        "timestamp": 1648397299
    },
    {
        "content": "<p>To this effect I am adding this bullet to \"Things it <em>is</em> still sound to do:\"</p>\n<blockquote>\n<p>Compare arbitrary pointers by address. Addresses <em>are</em> just integers and so there is<br>\n  always a coherent answer, even if the pointers are invalid or from different<br>\n  address-spaces/provenances. Of course, comparing addresses from different address-spaces<br>\n  is generally going to be <em>meaningless</em>, but so is comparing Kilograms to Meters, and Rust<br>\n  doesn't prevent that either. Similarly, if you get \"lucky\" and notice that a pointer<br>\n  one-past-the-end is the \"same\" address as the start of an unrelated allocation, anything<br>\n  you do with that fact is <em>probably</em> going to be gibberish. The scope of that gibberish<br>\n  is kept under control by the fact that the two pointers <em>still</em> aren't allowed to access<br>\n  the other's allocation (bytes), because they still have different provenance.</p>\n</blockquote>",
        "id": 276802621,
        "sender_full_name": "Gankra",
        "timestamp": 1648407846
    }
]