[
    {
        "content": "<p>i think making union provenance be based on each byte of a pointer having separate provenance isn't the best idea---we should just have provenance of the whole pointer be the union and say the byte's provenance is just that of the whole pointer</p>",
        "id": 276119879,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647900139
    },
    {
        "content": "<p>you can extend xorlists to a multiple dimensional grid, where each grid cell has just one pointer-sized field that is the xor of all pointers to adjacent grid cells...you'd need <code>2*N</code> pointers unioned where <code>N</code> is the number of dimensions</p>",
        "id": 276120159,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647900315
    },
    {
        "content": "<p>New topic time!</p>",
        "id": 276120161,
        "sender_full_name": "Jubilee",
        "timestamp": 1647900316
    },
    {
        "content": "<p>for when xorlist isn't cursed enough :)</p>",
        "id": 276120199,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647900350
    },
    {
        "content": "<p>I mean, if you want to be absurd you could do some sort of crazy mixing scheme and do it bytewise</p>",
        "id": 276120214,
        "sender_full_name": "Talchas",
        "timestamp": 1647900356
    },
    {
        "content": "<p>well...if you want to go extra crazy, you could use <code>GF(2^64)</code> multiplication/division instead of xor, that would allow the combined pointer to be <code>NonZeroU64</code> :P</p>",
        "id": 276120642,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647900612
    },
    {
        "content": "<p>Galois Fields to the rescue for all your evil pointer shenanigans!</p>",
        "id": 276120714,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647900688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276120159\">said</a>:</p>\n<blockquote>\n<p>you can extend xorlists to a multiple dimensional grid, where each grid cell has just one pointer-sized field that is the xor of all pointers to adjacent grid cells...you'd need <code>2*N</code> pointers unioned where <code>N</code> is the number of dimensions</p>\n</blockquote>\n<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>",
        "id": 276122366,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647901944
    },
    {
        "content": "<p>It'd be possible in a tree, but not a graph.</p>",
        "id": 276122443,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647902030
    },
    {
        "content": "<p><a href=\"https://twitter.com/brooksdavis/status/1506036121020510209\">https://twitter.com/brooksdavis/status/1506036121020510209</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/brooksdavis/status/1506036121020510209\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/4db634e8b70331ac638709072b343cbf84e230fb/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3533353039363230313637303937393538342f41563657577574765f6e6f726d616c2e6a706567\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> <a href=\"https://twitter.com/arichardson___\">@arichardson___</a> <a href=\"https://twitter.com/MSpondee\">@MSpondee</a> We know they exist, but I don’t think we’ve seen one in software we’ve cared about. I did find some use of xor to hide pointers from a leak checker in some Open Solaris code as well as xor for constant time conditionals in OpenSSL.</p><span>- brooksdavis (@brooksdavis)</span></div></div>",
        "id": 276122512,
        "sender_full_name": "Gankra",
        "timestamp": 1647902064
    },
    {
        "content": "<p>Hypothetically, would union-provenance that requires an explicit declaration (e.g. \"we don't do union provenance except when you explicitly declare a pointer as subject to it\") be sufficient to make XOR lists work? Is this in the category of \"we don't know how to do this\", or is it in the category of \"we know how but it'd suck to do it for every pointer by default\"?</p>",
        "id": 276123062,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647902498
    },
    {
        "content": "<blockquote>\n<p>We know they exist, but I don’t think we’ve seen one in software we’ve cared about. I did find some use of xor to hide pointers from a leak checker in some Open Solaris code</p>\n</blockquote>\n<p>lmao.</p>",
        "id": 276123163,
        "sender_full_name": "Jubilee",
        "timestamp": 1647902579
    },
    {
        "content": "<p>I mean leak checkers are annoying af when they get it wrong so... &lt;_&lt;</p>",
        "id": 276123167,
        "sender_full_name": "Jubilee",
        "timestamp": 1647902586
    },
    {
        "content": "<p>that seems like it would be better done as \"we have bitops on pointers that work via non-escaping ptrtoint or new compiler builtin ops on pointers\"</p>",
        "id": 276123215,
        "sender_full_name": "Talchas",
        "timestamp": 1647902625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276123215\">said</a>:</p>\n<blockquote>\n<p>that seems like it would be better done as \"we have bitops on pointers that work via non-escaping ptrtoint or new compiler builtin ops on pointers\"</p>\n</blockquote>\n<p>So, less <code>p1.addr() ^ p2.addr()</code>, more <code>p1.combine_pointers_funkily(p2)</code>?</p>",
        "id": 276123288,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647902685
    },
    {
        "content": "<p>no I mean \"<code>as</code> is still some PNVI+union escape, but you don't need to use <code>as</code> for most of the sane stuff\"</p>",
        "id": 276123341,
        "sender_full_name": "Talchas",
        "timestamp": 1647902730
    },
    {
        "content": "<p>because *const T and AtomicPtr have the relevant ops built in, and maybe even good helpers for them</p>",
        "id": 276123438,
        "sender_full_name": "Talchas",
        "timestamp": 1647902782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276123062\">said</a>:</p>\n<blockquote>\n<p>Hypothetically, would union-provenance that requires an explicit declaration (e.g. \"we don't do union provenance except when you explicitly declare a pointer as subject to it\") be sufficient to make XOR lists work? Is this in the category of \"we don't know how to do this\", or is it in the category of \"we know how but it'd suck to do it for every pointer by default\"?</p>\n</blockquote>\n<p>Well, there is always the fallback option of doing the full union provenance PNVI-like thing (ie int-&gt;ptr casts get the provenance of some tag, and as long as there is at least one choice that leads to DB the program behavior is defined). But that's annoying to check in MIRI at the very least, and <em>might</em> have other problems.</p>\n<p>As far as know there is no completely specified alternative to this (maybe I just didn't read that conversation though). I see a number of ways to try and work towards specifying such a thing, but I definitely can't claim to understand the consequences of each</p>",
        "id": 276123775,
        "sender_full_name": "Jake",
        "timestamp": 1647903074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276123288\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276123215\">said</a>:</p>\n<blockquote>\n<p>that seems like it would be better done as \"we have bitops on pointers that work via non-escaping ptrtoint or new compiler builtin ops on pointers\"</p>\n</blockquote>\n<p>So, less <code>p1.addr() ^ p2.addr()</code>, more <code>p1.combine_pointers_funkily(p2)</code>?</p>\n</blockquote>\n<p>i think CHERI fundamentally cannot support this because it fucks with way too high bits</p>",
        "id": 276124294,
        "sender_full_name": "Gankra",
        "timestamp": 1647903469
    },
    {
        "content": "<p>oh actually they have sections dedicated to this in 3.9: <a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf\">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf</a></p>",
        "id": 276124669,
        "sender_full_name": "Gankra",
        "timestamp": 1647903677
    },
    {
        "content": "<blockquote>\n<p>In an architecture that uses integer pointers, it is possible to implement a doubly-linked<br>\nlist using only one pointer by using an exclusive-OR between the previous list element<br>\npointer and the next pointer [212]. This optimization is not compatible with CHERI<br>\ncapabilities, as the XOR operation would make the pointer be out-of-bounds and therefore<br>\nnon-dereferenceable. However, if one were to use capabilities with very large bounds, i.e.<br>\nones that span all list elements, this optimization would still be possible. Alternatively, the<br>\nlist could be implemented using virtual addresses and prior to dereferencing, a capability<br>\ncould be derived from a large ambient one. However, we do not believe it is a good idea<br>\nas it prevents enforcing spatial safety and is therefore not possible by default.</p>\n</blockquote>",
        "id": 276124685,
        "sender_full_name": "Gankra",
        "timestamp": 1647903697
    },
    {
        "content": "<p>this basically amounts to \"use an arena\" but also with the extremely cursed version of \"what if your whole program was an arena <em>wink</em>\"</p>",
        "id": 276124788,
        "sender_full_name": "Gankra",
        "timestamp": 1647903763
    },
    {
        "content": "<p>yeah it can work with a DDC but a DDC (\"default data capability\", i.e. \"regular pointers that are actually addresses in a big internally-unprotected region\") is a cop-out on CHERI anyway</p>",
        "id": 276124851,
        "sender_full_name": "eddyb",
        "timestamp": 1647903837
    },
    {
        "content": "<p>tho it does match wasm linear memory, so it could be a hardware optimization over manually addressing a wasm linear memory as a large array :P</p>",
        "id": 276124996,
        "sender_full_name": "eddyb",
        "timestamp": 1647903960
    },
    {
        "content": "<p>(but I think in practice, DDC is only used to run software that isn't portable wrt large pointers, or even as a compat mode for existing binaries - not really sure about that though)</p>",
        "id": 276125088,
        "sender_full_name": "eddyb",
        "timestamp": 1647904013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276124851\">said</a>:</p>\n<blockquote>\n<p>yeah it can work with a DDC but a DDC (\"default data capability\", i.e. \"regular pointers that are actually addresses in a big internally-unprotected region\") is a cop-out on CHERI anyway</p>\n</blockquote>\n<p>It is, but at the same time, the fact that that <em>exists</em> provides a good bridge for existing software.</p>",
        "id": 276126529,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647904940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276122366\">said</a>:</p>\n<blockquote>\n<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>\n</blockquote>\n<p>ok, yeah...i was thinking you could move from one grid cell to another, but i forgot that you'd need the pointers to all adjacent grid cells around the new cell in the directions your moving away from.</p>",
        "id": 276126547,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647904949
    },
    {
        "content": "<p>And in particular, the fact that they <em>can</em> operate in that mode means we could support both modes, and treat this as a portability issue.</p>",
        "id": 276126571,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647904974
    },
    {
        "content": "<p>now I <em>really</em> wish I had a Morello board so I can see exactly what it takes in practice. presumably such a mode would just work already, and not be very interesting to Rust</p>",
        "id": 276126689,
        "sender_full_name": "eddyb",
        "timestamp": 1647905061
    },
    {
        "content": "<p>So, for instance, if we have <em>some</em> mechanism that allows XOR lists, we can compile programs that use that mechanism to use DDC, and programs that don't (the common case) to not.</p>",
        "id": 276126701,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647905068
    },
    {
        "content": "<p>\"this should be possible\", not \"this should be possible without tradeoffs\". :)</p>",
        "id": 276126723,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647905091
    },
    {
        "content": "<p>you can also emulate it, to be clear. it's almost like compiling to wasm64 then AOT-ing that, heh. hardware support is only needed as an optimization</p>",
        "id": 276126774,
        "sender_full_name": "eddyb",
        "timestamp": 1647905143
    },
    {
        "content": "<p>Is this a program-wide choice, or is it possible to have a whole-address-space capability as well as more constrained capabilities?</p>",
        "id": 276126859,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647905206
    },
    {
        "content": "<p>If the latter, that seems like exactly what we'd want to use, and then there could be some mechanism to opt out of (or opt into) supporting that, via whatever the portability lint ends up being spelled like.</p>",
        "id": 276126894,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647905241
    },
    {
        "content": "<p>If an architecture supports both \"capability-aware\" and \"capability-unaware\" load and store instructions, then the Default Data Capability is in effect the actual capability used by the latter set.</p>",
        "id": 276127048,
        "sender_full_name": "Jubilee",
        "timestamp": 1647905389
    },
    {
        "content": "<p>hmm, so that's a more subtle question than just the basic \"do OSes ported to this have a per-process/thread flag for this\"...</p>\n<p>CHERI is flexible enough that even the kernel-userspace distinction is kind of vestigial, heh<br>\n(that is, you could implement an OS where none of the execution state can reach kernel memory except when you call vDSO functions they atomically transition to an execution state that is running kernel code and can see kernel memory)</p>\n<p>I think some of the things they've been able to demonstrate include several protection domains <em>in one process</em></p>",
        "id": 276127136,
        "sender_full_name": "eddyb",
        "timestamp": 1647905444
    },
    {
        "content": "<blockquote>\n<p>Hybrid-capability code implements pointer types using integers by default, interpreted with<br>\nrespect to a global default data capability (DDC) able to address code, globals, heap, and<br>\nstack(s). When special language-level annotations are added to program source, specific<br>\npointers or pointer types are instead implemented using capabilities, offering additional<br>\nprotection. Hybrid-capability code is primarily for use in specialized environments: the<br>\nboot loader, early kernel startup, and in code bridging communications between legacy<br>\ncode and pure-capability code (such as ABI compatibility layers).</p>\n</blockquote>",
        "id": 276127147,
        "sender_full_name": "Jubilee",
        "timestamp": 1647905454
    },
    {
        "content": "<p>it's again a bit like wasm64: you can have as many VMs as you want in a process, and AOT them</p>",
        "id": 276127169,
        "sender_full_name": "eddyb",
        "timestamp": 1647905485
    },
    {
        "content": "<p>I think their demonstration was taking specific C libraries and wrapping them so that they existed almost as an isolated subprocess/wasm-like-VM within the actual process</p>",
        "id": 276127200,
        "sender_full_name": "eddyb",
        "timestamp": 1647905517
    },
    {
        "content": "<p>but yeah I guess most of the concerns are around ABI</p>",
        "id": 276127251,
        "sender_full_name": "eddyb",
        "timestamp": 1647905534
    },
    {
        "content": "<p>and yes, essentially for Rust this means that e.g. a Morello target might look less like <code>morello-unknown-freebsd</code> and more like <code>aarch64-unknown-freebsd-morello</code></p>",
        "id": 276127416,
        "sender_full_name": "Jubilee",
        "timestamp": 1647905713
    },
    {
        "content": "<blockquote>\n<h3>CheriBSD kernel</h3>\n<p>An extended version of the FreeBSD operating system whose kernel can be<br>\ncompiled either as hybrid-capability or pure-capability code, offering different degrees<br>\nof kernel memory protection. The CheriBSD kernel is also able to host legacy, hybrid-<br>\ncapability, and pure-capability userspace environments. The pure-capability process en-<br>\nvironment is known as CheriABI, and is a new OS ABI based on ubiquitous userspace use<br>\nof architectural capabilities. CheriBSD is also able to offer optional temporal memory<br>\nsafety for (non-stack) allocations in pure-capability userspace applications. In addition,<br>\nCheriBSD provides a libcheri intra-process compartmentalization framework, which<br>\nallows library-like components to operate in compartments within a larger application<br>\nprocess.</p>\n<h3>CheriBSD hybrid userspace</h3>\n<p>An extended version of the FreeBSD userspace that is mini-<br>\nmally modified to support hybrid-capability code execution, including modest additions<br>\nto the C runtime (CRT) and system libraries (including libc).</p>\n<h3>CheriBSD CheriABI userspace</h3>\n<p>An extended version of the FreeBSD userspace that supports<br>\npure-capability execution, with modest further extensions.</p>\n<h3>CheriBSD applications</h3>\n<p>A set of extended applications able to operate in the CheriABI pro-<br>\ncess environment, including integrated FreeBSD programs such as OpenSSH, and also<br>\nthird-party applications such as Apple’s WebKit and the PostgreSQL database. These all<br>\noperate with full spatial, referential, and temporal memory safety.</p>\n</blockquote>",
        "id": 276127805,
        "sender_full_name": "Jubilee",
        "timestamp": 1647906011
    },
    {
        "content": "<blockquote>\n<p>In addition, CheriBSD provides a libcheri intra-process compartmentalization framework, which allows library-like components to operate in compartments within a larger application process.</p>\n</blockquote>\n<p>oh that's the thing I was referencing, nice</p>",
        "id": 276127953,
        "sender_full_name": "eddyb",
        "timestamp": 1647906155
    },
    {
        "content": "<blockquote>\n<p>CheriBSD is also able to offer optional temporal memory safety for (non-stack) allocations in pure-capability userspace applications.</p>\n</blockquote>\n<p>huh, how does that work, \"scan all userspace memory before allocation reuse\"?</p>",
        "id": 276127995,
        "sender_full_name": "eddyb",
        "timestamp": 1647906208
    },
    {
        "content": "<p>idk.</p>",
        "id": 276128074,
        "sender_full_name": "Jubilee",
        "timestamp": 1647906267
    },
    {
        "content": "<p>I mean, I suspect DDC is like \"you can run 32-bit code with a 64-bit kernel... if you have an entire 32-bit copy of the userspace libraries\"</p>",
        "id": 276128237,
        "sender_full_name": "Talchas",
        "timestamp": 1647906416
    },
    {
        "content": "<p>Soooorta.</p>",
        "id": 276128264,
        "sender_full_name": "Jubilee",
        "timestamp": 1647906448
    },
    {
        "content": "<p>code can actually run using the full hybrid of both.</p>",
        "id": 276128356,
        "sender_full_name": "Jubilee",
        "timestamp": 1647906500
    },
    {
        "content": "<p>I mean, if you _want_ to go to the land of __near and __far for the sake of not building a library twice, or more likely a lot of glue bits to convert a codebase more slowly</p>",
        "id": 276128651,
        "sender_full_name": "Talchas",
        "timestamp": 1647906769
    },
    {
        "content": "<p>Oh I meant on CheriBSD.</p>",
        "id": 276128673,
        "sender_full_name": "Jubilee",
        "timestamp": 1647906802
    },
    {
        "content": "<p><a href=\"https://twitter.com/arichardson___/status/1506041671670284295\">https://twitter.com/arichardson___/status/1506041671670284295</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/arichardson___/status/1506041671670284295\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> <a href=\"https://twitter.com/brooksdavis\">@brooksdavis</a> <a href=\"https://twitter.com/workingjubilee\">@workingjubilee</a> <a href=\"https://twitter.com/MSpondee\">@MSpondee</a> <a href=\"https://twitter.com/clarfonthey\">@clarfonthey</a> I believe the last time we gathered those statistics was running the full FreeBSD testsuite using QEMU to log the out-of-bounds pointers: 155214 were out-of-bounds by more than one byte. 1205 pointed past the end and 81% were at most sizeof(void*) beyond\nthe bounds.</p><span>- Alex Richardson (@arichardson___)</span></div></div>",
        "id": 276131332,
        "sender_full_name": "Gankra",
        "timestamp": 1647909280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276126547\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276122366\">said</a>:</p>\n<blockquote>\n<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>\n</blockquote>\n<p>ok, yeah...i was thinking you could move from one grid cell to another, but i forgot that you'd need the pointers to all adjacent grid cells around the new cell in the directions your moving away from.</p>\n</blockquote>\n<p>The principle of XOR lists works on grids too, but the entropy accounting says you need 2^d-1 xor-pointer-things per node, so <code>3 * size_of::&lt;*mut Node&gt;</code> space per node for a square grid. For example if you need to store pointers <code>a,b,c,d</code> you would keep the values <code>a^b, a^c, a^d</code> and if you have <code>a</code> you can xor it to get any of the others and if you have <code>b</code> then you can xor it with <code>a^b</code> to get <code>a</code> and then <code>a^c</code> or <code>a^d</code> to get the others</p>",
        "id": 276385607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648062690
    },
    {
        "content": "<p>Another variation would store only two pointer values per node in a square grid, say top^bottom and left^right. You could use this to do a horizontal or vertical sweep of the grid given the value across a whole frontier, in addition to diagonal sweeps</p>",
        "id": 276386175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648062966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276385607\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276126547\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276122366\">said</a>:</p>\n<blockquote>\n<p>I don't see how that would work; the XOR trick only works if you have all the other pointers apart from the one you want. So that would only work if you have all the adjacent cell pointers except one.</p>\n</blockquote>\n<p>ok, yeah...i was thinking you could move from one grid cell to another, but i forgot that you'd need the pointers to all adjacent grid cells around the new cell in the directions your moving away from.</p>\n</blockquote>\n<p>The principle of XOR lists works on grids too, but the entropy accounting says you need 2^d-1 xor-pointer-things per node, so <code>3 * size_of::&lt;*mut Node&gt;</code> space per node for a square grid. For example if you need to store pointers <code>a,b,c,d</code> you would keep the values <code>a^b, a^c, a^d</code> and if you have <code>a</code> you can xor it to get any of the others and if you have <code>b</code> then you can xor it with <code>a^b</code> to get <code>a</code> and then <code>a^c</code> or <code>a^d</code> to get the others</p>\n</blockquote>\n<p>Yeah, I've seen that done for trees, for parent and child pointers.</p>",
        "id": 276387329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648063518
    },
    {
        "content": "<p>Given the parent pointer that you got by descending, you can get any of the children.</p>",
        "id": 276387362,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648063537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276127995\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>CheriBSD is also able to offer optional temporal memory safety for (non-stack) allocations in pure-capability userspace applications.</p>\n</blockquote>\n<p>huh, how does that work, \"scan all userspace memory before allocation reuse\"?</p>\n</blockquote>\n<p>effectively yes, but with a bit of help from the MMU to avoid scanning everything. I.e. only pages that have had valid capabilities stored to since the last scan</p>",
        "id": 276507471,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648141285
    },
    {
        "content": "<p><a href=\"https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2020oakland-cornucopia.pdf\">https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2020oakland-cornucopia.pdf</a> for the details on that approach, although there is ongoing work to reduce those overheads further with more HW support.</p>",
        "id": 276507762,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648141377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276126689\">said</a>:</p>\n<blockquote>\n<p>now I <em>really</em> wish I had a Morello board so I can see exactly what it takes in practice. presumably such a mode would just work already, and not be very interesting to Rust</p>\n</blockquote>\n<p>It might be possible that some of the boards at Cambridge will be made accessible to interested users for testing, but I believe it will still be a while until they are all delievered. In the mean time, it <em>should</em> be quite easy (maybe even easier) to get started on QEMU. Only downside is that it will be a bit slower than a real 2GHz+ CPU.</p>\n<p>If you clone <a href=\"https://github.com/CTSRD-CHERI/cheribuild\">https://github.com/CTSRD-CHERI/cheribuild</a>, running <code>./cheribuild.py run-morello-purecap -d</code> should build all the dependencies and give you a shell in a CheriBSD environment where all software is compiled as pure-capability CHERI. Alternatively <code>./cheribuild.py run-riscv64-purecap -d</code> will do the same just for CHERI-RISC-V</p>",
        "id": 276508773,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648141781
    },
    {
        "content": "<p>regarding DDC, that mostly exists to constrain the region accessible by integer loads and stores. Additionally, you can use it to relocate data since it not only bounds checks, but also gets added to the integer load address. When running in pure-capability mode, it is set to NULL so that any integer load faults, but you can always install a valid capability there if you want. This is safe since that capability must be derived from a capability you already have access to so it can't grant any additional rights.</p>\n<p>Some integer loads and stores are still available in pure capability mode, but to avoid using up too much encoding space most loads/stores are mode-dependent (Morello encodes the mode in the LSB of the PC like Thumb, RISC-V uses a bit in PCC), so you either capability registers or integer registers depending on that mode bit.</p>",
        "id": 276509731,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648142157
    },
    {
        "content": "<p>Interesting!</p>",
        "id": 276518769,
        "sender_full_name": "Jubilee",
        "timestamp": 1648145664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276115586\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> Hypothetically, if we <em>don't</em> have any backwards compatibility constraints at all, and we only have the requirement to make something <em>possible</em> without making it use the <em>same code</em> as it did before, and we're fine with requiring unsafe operations but we need to provide a well-defined non-UB way to do something, what APIs <em>would</em> we want people to use for something like an XOR linked list that stores only one pointer-sized value in each node (plus the data)?</p>\n</blockquote>\n<p>I'm not her but I'll give you my take on it anyway. ;) Also I'll ignore CHERI and focus on \"Abstract Machine provenance\".<br>\nI think it would totally possible to add a few hacky things to Rust to make this work (so I disagree with everyone above who says this has to be UB everywhere except asm). Basically I would exploit that in my model of Rust, every <em>byte</em> in memory carries provenance. The ptr-sized field in the XOR list is multiple bytes in size so it can hold multiple provenances. We \"just\" need a more explicit way to work with that per-byte provenance. It's all super clunky with our current way of writing these APIs since provenance is awfully implicit, but it would be internally consistent.</p>",
        "id": 276732958,
        "sender_full_name": "RalfJ",
        "timestamp": 1648310933
    },
    {
        "content": "<p>Sadly the proposal of thinking of <code>type Pointer = (Address, Provenance)</code> where <code>Provenance</code> is a ZST doesn't work, or I don't know how to work, because a ZST doesn't even have a single byte that could hold the provenance</p>",
        "id": 276732987,
        "sender_full_name": "RalfJ",
        "timestamp": 1648310990
    },
    {
        "content": "<p><span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span> that's a beautiful hack Ralf, you've really been corrupted by Make It Work after all these years</p>",
        "id": 276733036,
        "sender_full_name": "Gankra",
        "timestamp": 1648311017
    },
    {
        "content": "<p>it is many things but surely not \"beautiful\"^^</p>",
        "id": 276733056,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311064
    },
    {
        "content": "<p>so concretely we could have a type like <code>Byte</code> that is <em>not</em> <code>u8</code>, it is more like <code>MaybeUninit&lt;u8&gt;</code> but lets just say it has to be initialized (but unlike <code>u8</code> may carry provenance). it works like a pair of a <code>u8</code> and provenance. and then you could have a weird function like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Returns a byte with the value of `self` but the provenance of `other`</span>\n<span class=\"k\">fn</span> <span class=\"nf\">with_provenance_of</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Byte</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">Byte</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Byte</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and we could say that <code>*mut u8</code> round-trips losslessly through <code>[Byte; 8]</code> <em>where all bytes have the same provenance</em>.<br>\nso given the two ptrs we want to XOR we turn them both into Byte arrays and XOR them lanewise but crucially we keep ptr1 provenance on the first 4 bytes and ptr2 provenance for the last 4 bytes. then we can later reconstruct either pointer (including its provnenace) if we are given the right things to XOR with.</p>\n<p>and now I need to shower, I feel dirty...</p>",
        "id": 276733244,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311345
    }
]