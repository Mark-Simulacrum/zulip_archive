[
    {
        "content": "<p>So, I don't know what is currently implemented (am about to go check), but wanted to ask about people's intuition anyway. Imagine that we write a bunch of pointer bytes to memory, and the provenance of those bytes is different (ie they have different SB tags). What are people's intuition for what should happen when the pointer is loaded? It gets the provenance of the lowest byte? The highest byte? UB if the bytes don't all agree? <code>invalid_ptr()</code> if they don't all agree?</p>\n<p>Relatedly, are there any issues in terms of optimizations or the memory model with any of these choices? I can't think of any</p>",
        "id": 277929107,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649185532
    },
    {
        "content": "<p>My intuition is that if the bytes don't all have the same provenance, that makes the provenance invalid, similar to how a whole <code>usize</code> is considered uninitialized if any of the bytes are uninitialized.</p>",
        "id": 277929684,
        "sender_full_name": "scottmcm",
        "timestamp": 1649185774
    },
    {
        "content": "<p>That is also mine</p>",
        "id": 277929725,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649185801
    },
    {
        "content": "<p>In the XOR list discussion, Ralf mentioned that we could have a function that maps the provenance onto all 8 bytes individually. I suppose we could also specify that this is already the case - all 8 bytes of a pointer carry the full provenance of that pointer. That would in particular imply that this is defined:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">42_</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bytes</span>: <span class=\"p\">[</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"n\">bytes</span><span class=\"p\">.</span><span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// or   bytes = [bytes[0]; 8];</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mangled_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">).</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">mangled_ptr</span><span class=\"p\">.</span><span class=\"n\">with_addr</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">()));</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277930882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649186342
    },
    {
        "content": "<p>Indeed</p>",
        "id": 277931665,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649186737
    },
    {
        "content": "<p>The implementation of this in CTFE right now is... weird</p>",
        "id": 277931676,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649186745
    },
    {
        "content": "<p>it certainly seems easier to specify provenance this way than to have to talk about bytes being \"4th from the left of a pointer value\" like in <a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</a></p>",
        "id": 277932103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649186957
    },
    {
        "content": "<p>CTFE has a variety of restrictions around pointers right now.  One that jumps to mind (<a href=\"https://github.com/rust-lang/rust/issues/94371#issue-1150822966\">https://github.com/rust-lang/rust/issues/94371#issue-1150822966</a>) is that chunked copying of unaligned-because-packed pointers doesn't work even in cases where it tends to for aligned pointers.  But that's tends not to be an issue in practice because <code>repr(packed)</code> pointers are so rare.</p>",
        "id": 277932106,
        "sender_full_name": "scottmcm",
        "timestamp": 1649186958
    },
    {
        "content": "<p>Yeah, I'm seeing that right now. I have some ideas for how to approach some of these, but definitely off topic here and I also don't have the time to work on this probably</p>",
        "id": 277932756,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649187335
    },
    {
        "content": "<p>For the purpose of this conversation, the tldr is that CTFE will probably have to change around this anyway, and so we can ignore it for now (as long as whatever we choose remains implementable)</p>",
        "id": 277932865,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649187391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20bytes.20with.20different.20provenance/near/277930882\">said</a>:</p>\n<blockquote>\n<p>In the XOR list discussion, Ralf mentioned that we could have a function that maps the provenance onto all 8 bytes individually. I suppose we could also specify that this is already the case - all 8 bytes of a pointer carry the full provenance of that pointer. That would in particular imply that this is defined:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">42_</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bytes</span>: <span class=\"p\">[</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"n\">bytes</span><span class=\"p\">.</span><span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// or   bytes = [bytes[0]; 8];</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mangled_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">).</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">mangled_ptr</span><span class=\"p\">.</span><span class=\"n\">with_addr</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">()));</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>note that I did <em>not</em> say that you can have such a multi-provenance value <em>at pointer type</em></p>",
        "id": 277959672,
        "sender_full_name": "RalfJ",
        "timestamp": 1649202973
    },
    {
        "content": "<p>I could totally imagine saying that the validity invariant of pointer values says they must be initialized (that much is hopefully uncontroversial if integers have to be initialized) <em>and furthermore all their bytes must have the same provenance</em></p>",
        "id": 277959722,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203020
    },
    {
        "content": "<p>that would make your code UB at the <code>assume_init</code></p>",
        "id": 277959854,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203100
    },
    {
        "content": "<p>I don't think that would mean this is UB. All the bytes still have the right provenance, they just got shuffled around a little</p>",
        "id": 277959936,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649203198
    },
    {
        "content": "<p>oh, right. so yeah that's fine then.</p>",
        "id": 277960048,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203230
    },
    {
        "content": "<p>but what I said should answer your original question :)</p>",
        "id": 277960062,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203246
    },
    {
        "content": "<p>using this validity invariant would surely help CTFE/Miri to accurately implement the semantics. :D like, <a href=\"https://github.com/rust-lang/rust/issues/87184\">https://github.com/rust-lang/rust/issues/87184</a> still needs to be resolved, but at least I have in my head a very clear idea for how to do that.<br>\nsupporting multi-provenance values at pointer type, OTOH, would require a whole different set of extra changes, and I dont even have a good idea for how to do that in the current architecture...</p>",
        "id": 277960083,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203272
    },
    {
        "content": "<p>so, this should be UB I think</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">42_</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bytes</span>: <span class=\"p\">[</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"n\">bytes</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mangled_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">).</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because one of the bytes has a different provenance (in this case, no provenance).</p>",
        "id": 277960172,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20bytes.20with.20different.20provenance/near/277932103\">said</a>:</p>\n<blockquote>\n<p>it certainly seems easier to specify provenance this way than to have to talk about bytes being \"4th from the left of a pointer value\" like in <a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</a></p>\n</blockquote>\n<p>yeah... I wanted to make <code>Pointer</code> as opaque at possible, but it might be better to just make <code>Provenance</code> opaque and keep <code>Pointer</code> as <code>(Address, Provenance)</code>.</p>",
        "id": 277960202,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203382
    },
    {
        "content": "<p>the amusing thing about that specific example is that that is pretty much exactly one of the reference examples that the C WG wants to allow for some reason, because I guess some old code did their bit packing specifically on individual bytes?</p>",
        "id": 277960359,
        "sender_full_name": "Talchas",
        "timestamp": 1649203528
    },
    {
        "content": "<p>What is the motivation for making this UB instead of just yielding a pointer with null provenance?</p>",
        "id": 277960459,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649203633
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> am I ever glad I don't have their job</p>",
        "id": 277960555,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649203757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20bytes.20with.20different.20provenance/near/277960459\">said</a>:</p>\n<blockquote>\n<p>What is the motivation for making this UB instead of just yielding a pointer with null provenance?</p>\n</blockquote>\n<p>funny I would have expected it should yield a pointer with the provenance of the other bytes ;)</p>",
        "id": 277960785,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203981
    },
    {
        "content": "<p>like, \"if some subset of bytes have a given provenance and the rest has none, use that provenance\"</p>",
        "id": 277960804,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203996
    },
    {
        "content": "<p>that would be... still implementable fairly easily with the current general Miri/CTFE architecture but (like other proposals you made before that I disliked for similar reasons) violates the property that byte-value-byte roundtrips are a 'widening', i.e., can always return the original value (a \"Galois connection\" if you want to use fancy terms ;)</p>",
        "id": 277960896,
        "sender_full_name": "RalfJ",
        "timestamp": 1649204049
    },
    {
        "content": "<p>so, again one has to be very careful when justifying a removal of <code>x=x;</code></p>",
        "id": 277960924,
        "sender_full_name": "RalfJ",
        "timestamp": 1649204094
    },
    {
        "content": "<p>Yeah, I see that</p>",
        "id": 277961131,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649204322
    },
    {
        "content": "<p>\"In PNVI*, when constructing a pointer value, if the third components of the bytes all carry the appropriate index,<br>\nand all have the same provenance (which will be guaranteed if pointer types all have the same size), the provenance<br>\nof the result is that provenance. Otherwise, [it does basically the same as an integer-to-pointer cast]\".  p35 of <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf\">N2577</a></p>",
        "id": 277980871,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649227179
    },
    {
        "content": "<p>FWIW on CHERI these are totally busted. Any time you write to any of a pointerâ€™s bytes, any time you store it in unaligned memory, it becomes invalid / useless for provenance</p>",
        "id": 277984585,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649230077
    },
    {
        "content": "<p>oh hi <span class=\"user-mention\" data-user-id=\"490957\">@Peter Sewell</span> :)</p>",
        "id": 278020186,
        "sender_full_name": "RalfJ",
        "timestamp": 1649250354
    },
    {
        "content": "<p>integer-to-pointer casts are impure in general (they generate a freshly guessed provenance) so I dont think we want that to ever happen \"implicitly\" as part of e.g. a pointer-typed load</p>",
        "id": 278020292,
        "sender_full_name": "RalfJ",
        "timestamp": 1649250398
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  :)   I was just clarifying what PNVI-* does there, which we chose to get bytewise user memcpy and some horrible futzing-with-unused-bytes C idioms to work; you might very well want something much tighter.</p>",
        "id": 278027285,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649253555
    },
    {
        "content": "<p>(I'm just dipping into these infinite conversations)</p>",
        "id": 278027668,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649253696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"490957\">Peter Sewell</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20bytes.20with.20different.20provenance/near/278027668\">said</a>:</p>\n<blockquote>\n<p>(I'm just dipping into these infinite conversations)</p>\n</blockquote>\n<p>let me know if you want a summary of my take on it ;) might be easier in a synchronous call though</p>",
        "id": 278031208,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255174
    },
    {
        "content": "<p>probably it'd be good to have a translator :-)   maybe best let this settle first, though - I've no spare cycles for the next few days</p>",
        "id": 278033789,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649256236
    }
]