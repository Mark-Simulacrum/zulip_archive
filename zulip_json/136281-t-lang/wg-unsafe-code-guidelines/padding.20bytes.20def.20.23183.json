[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I am not sure how your typed copy proposal can be reconciled with how memcpy works today:</p>",
        "id": 172119226,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564573119
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">from</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">to</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uninitialized</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"p\">..</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size_of</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">());</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Here <code>memcpy</code> only works on a <code>[u8]</code> so IIUC per your typed copy proposal, all bytes of T including padding bytes should be copied. Yet right now this is not the case.</p>",
        "id": 172119352,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564573274
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 172119362,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564573300
    },
    {
        "content": "<p>To make <code>memcpy</code> work in your proposal, it would need to operate on <code>*T</code> and not on <code>*u8</code></p>",
        "id": 172119533,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564573462
    },
    {
        "content": "<p>The implementation of our <code>memcpy</code> is here: <a href=\"https://github.com/rust-lang-nursery/compiler-builtins/blob/6178e2c61105a9ff7fa1c4fc974b142b0c07ae3d/src/mem.rs#L9\" target=\"_blank\" title=\"https://github.com/rust-lang-nursery/compiler-builtins/blob/6178e2c61105a9ff7fa1c4fc974b142b0c07ae3d/src/mem.rs#L9\">https://github.com/rust-lang-nursery/compiler-builtins/blob/6178e2c61105a9ff7fa1c4fc974b142b0c07ae3d/src/mem.rs#L9</a></p>\n<p>And as you see the code there is written to copy all bytes, so it must copy padding bytes, but it can be optimized not to do that, and it is currently optimized as such.</p>",
        "id": 172119609,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564573544
    },
    {
        "content": "<p>I don't <em>not</em> believe it, but could you please demonstrate a concrete program using <code>memcpy</code> which is optimized to not copy padding?</p>",
        "id": 172120274,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564574263
    },
    {
        "content": "<p>uh</p>",
        "id": 172120670,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564574660
    },
    {
        "content": "<p><a href=\"https://rust.godbolt.org/z/_Oha1o\" target=\"_blank\" title=\"https://rust.godbolt.org/z/_Oha1o\">https://rust.godbolt.org/z/_Oha1o</a></p>",
        "id": 172120681,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564574680
    },
    {
        "content": "<p>we don't, but then, it is a compiler bug</p>",
        "id": 172120688,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564574689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> <a href=\"https://rust.godbolt.org/z/SDb-pj\" target=\"_blank\" title=\"https://rust.godbolt.org/z/SDb-pj\">https://rust.godbolt.org/z/SDb-pj</a> those two operations should only copy one byte, and not 128 bytes</p>",
        "id": 172120808,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564574775
    },
    {
        "content": "<p>Is that a compiler bug? Really? It seems to respect the quite reasonable semantics Ralf proposed, that's a good thing in my book.</p>",
        "id": 172121096,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575033
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/63159\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63159\">https://github.com/rust-lang/rust/issues/63159</a></p>",
        "id": 172121142,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575098
    },
    {
        "content": "<p>I consider it a missed optimization</p>",
        "id": 172121146,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575104
    },
    {
        "content": "<p>The memcpy one I mean. ptr::copy_nonoverlapping could be considered a typed copy, so it should be optimizable. But plain <code>memcpy</code> being just that and not magically knowing about padding is a good thing IMO</p>",
        "id": 172121158,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575121
    },
    {
        "content": "<p>The semantics ralf proposed do say that when doing a typed copy the padding bytes do not need to be copied</p>",
        "id": 172121203,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> <code>ptr::copy_nonoverlapping</code> is the API of <code>memcpy</code> in Rust: <a href=\"https://rust.godbolt.org/z/rEG68z\" target=\"_blank\" title=\"https://rust.godbolt.org/z/rEG68z\">https://rust.godbolt.org/z/rEG68z</a></p>",
        "id": 172121243,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575192
    },
    {
        "content": "<p>(or at least is the only way I know to call the definition given in compiler-builtins)</p>",
        "id": 172121255,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575211
    },
    {
        "content": "<p>I know what it lowers to, but it's a typed API and an intrinsic, so we can give it \"typed copy\" semantics while clearly making raw <code>memcpy</code> know about padding would require some ugly magic.</p>",
        "id": 172121333,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575250
    },
    {
        "content": "<p>btw, LLVM will recognize calls to <code>extern \"C\" { fn memcpy(...); }</code> as The Memcpy Function and convert calls to it to <code>llvm.memcpy</code> intrinsics</p>",
        "id": 172121366,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575293
    },
    {
        "content": "<p>Both of your examples are (in the first case) or could be (in the second case) typed copies so I don't really see the contradiction to Ralf's semantics. That's all I'm saying.</p>",
        "id": 172121538,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575438
    },
    {
        "content": "<p>In C: <a href=\"https://rust.godbolt.org/z/Ka2VLG\" target=\"_blank\" title=\"https://rust.godbolt.org/z/Ka2VLG\">https://rust.godbolt.org/z/Ka2VLG</a></p>",
        "id": 172121542,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575443
    },
    {
        "content": "<p>lol</p>",
        "id": 172121614,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575484
    },
    {
        "content": "<p>in Rust, using <code>extern \"C\" { fn memcpy(...); }</code> does not recognize the intrinsic as a <code>memcpy</code> function, so I'd guess that's another bug</p>",
        "id": 172121616,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575485
    },
    {
        "content": "<p>huh</p>",
        "id": 172121627,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575500
    },
    {
        "content": "<p>(note that in C both Clang and GCC do the optimization)</p>",
        "id": 172121628,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575501
    },
    {
        "content": "<p>In Rust with <code>extern \"C\"</code> another missed optimization: <a href=\"https://rust.godbolt.org/z/O9Lrqw\" target=\"_blank\" title=\"https://rust.godbolt.org/z/O9Lrqw\">https://rust.godbolt.org/z/O9Lrqw</a></p>",
        "id": 172121655,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575535
    },
    {
        "content": "<p>Actually, I'm not sure if the <code>extern \"C\"</code> call in Rust is a missed optimization, it is definetely an optimization that C and C++ do, but since we have <code>ptr::copy_nonoverlapping</code> and C and C++ do not have it, I do not really care that much about <code>extern \"C\"</code></p>",
        "id": 172121751,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575611
    },
    {
        "content": "<p>although it would at least be nice to have an attribute that the <code>libc</code> crate could use on the <code>memcpy</code> and <code>memmove</code> intrinsics that it exposes</p>",
        "id": 172121768,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575630
    },
    {
        "content": "<p>but that's a problem that the libc crate has, and can be solved using unstable attributes</p>",
        "id": 172121784,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564575654
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I am not sure how your typed copy proposal can be reconciled with how memcpy works today:</p>\n</blockquote>\n<p>Anyway, do you agree that this issue <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> is not an issue after all?</p>",
        "id": 172121896,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1564575784
    },
    {
        "content": "<p>yes, thanks, talking with you helped</p>",
        "id": 172123774,
        "sender_full_name": "gnzlbg",
        "timestamp": 1564577476
    },
    {
        "content": "<p>great, issue resolved before I even arrived in this thread :)</p>",
        "id": 172146401,
        "sender_full_name": "RalfJ",
        "timestamp": 1564593877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> a different way to define padding could be</p>",
        "id": 173017760,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565611802
    },
    {
        "content": "<p>to just say that they have a particular type, like <code>MaybeUninit&lt;u8&gt;</code> ?</p>",
        "id": 173017932,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565611992
    },
    {
        "content": "<p>e.g. <code>(u8, u16)</code> would just be <code>(u8, MaybeUninit&lt;u8&gt;, u16)</code></p>",
        "id": 173017951,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612017
    },
    {
        "content": "<p>and that the rules are the same ?</p>",
        "id": 173017958,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612031
    },
    {
        "content": "<p>for initialization, we probably want to say that they are initialized to <code>MaybeUninit::uninit</code></p>",
        "id": 173018007,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612064
    },
    {
        "content": "<p>The rules can't be the same. A <code>MaybeUninit&lt;u8&gt;</code> field always has to be copied, but by other (more conventional) definitions they don't have to be copied.</p>",
        "id": 173018022,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1565612081
    },
    {
        "content": "<p>yep</p>",
        "id": 173018027,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612086
    },
    {
        "content": "<p>so what we need is <code>Uninit&lt;u8&gt;</code> instead, which is always uninitialized</p>",
        "id": 173018036,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612099
    },
    {
        "content": "<p>and therefore never needs to be copied</p>",
        "id": 173018051,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612109
    },
    {
        "content": "<p>(or some other type like that)</p>",
        "id": 173018055,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612117
    },
    {
        "content": "<p>\"always uninitialized\" is still a very weird notion as discussion elsewhere previously</p>",
        "id": 173018069,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1565612132
    },
    {
        "content": "<p>these are always initialized, but they only have one valid representation, and that's 0xUU</p>",
        "id": 173018116,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612162
    },
    {
        "content": "<p>That can't work out, it's allowed to write to padding, it just doesn't get preserved on typed copies. If 0xUU was the only valid bit string then e.g. <code>memset</code> followed by a typed copy would be UB.</p>",
        "id": 173018149,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1565612197
    },
    {
        "content": "<p>indeed</p>",
        "id": 173018158,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612215
    },
    {
        "content": "<p>bad idea - if we make it a normal type, then typed copies would need to copy it</p>",
        "id": 173018247,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612287
    },
    {
        "content": "<p>I also don't see the motivation for trying to explicitly define padding this way (or in any other explicit way) when it can fall out nicely as a side effect of other definitions (repr relation)</p>",
        "id": 173018248,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1565612299
    },
    {
        "content": "<p>i'm not sure how to differentiate padding from niche in the repr relation</p>",
        "id": 173018272,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612355
    },
    {
        "content": "<p>for padding everything is valid, while niches are a sub-set of invalid relations</p>",
        "id": 173018353,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565612437
    },
    {
        "content": "<p>Niches aren't ignored by the repr relation, padding is. e.g. is a byte can only be 0x00 or 0x01 for the byte list to represent a value of T, then there's a (potential) niche there. If the value of the byte is completely irrelevant for the value being represented, then it's padding.</p>",
        "id": 173018369,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1565612466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> so a <code>u16</code> that can only be 0 or 1, has a niche</p>",
        "id": 173030525,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565621806
    },
    {
        "content": "<p>and has no padding (the upper bytes must always be zero)</p>",
        "id": 173030536,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565621816
    },
    {
        "content": "<p>if one wanted to say that the upper byte doesn't matter for the value representation, one could do <code>#[repr(align(2))] struct S(bool);</code> instead</p>",
        "id": 173030667,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565621892
    },
    {
        "content": "<p>but then one can't put that type at an alignment of 1</p>",
        "id": 173031068,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622143
    },
    {
        "content": "<p>AFAICT one can't easily construct such a value with an alignment of 1</p>",
        "id": 173031168,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622241
    },
    {
        "content": "<p>so I was wondering if there was a way to have a <code>Padding</code> type that one could use to explicitly add padding, and enable that</p>",
        "id": 173031434,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622399
    },
    {
        "content": "<p>Such a type would be useful for <code>repr(C)</code></p>",
        "id": 173031449,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622411
    },
    {
        "content": "<p>The problem I see is that for typed copies of the type to not copy anything it would need to have size 0, but then it cannot increase the size of the type</p>",
        "id": 173031614,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622545
    },
    {
        "content": "<p>We currently use, e.g., <code>[...; 0]</code> types to insert padding to raise the alignment of the next field</p>",
        "id": 173031656,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622587
    },
    {
        "content": "<p>but that's more implicit and hard to discover than just inserting a Padding field</p>",
        "id": 173031755,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622642
    },
    {
        "content": "<p>such a Padding type would have non-zero size, but none of its bytes would be part of the value it represents</p>",
        "id": 173031940,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622743
    },
    {
        "content": "<p>it represents no value</p>",
        "id": 173031991,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565622777
    },
    {
        "content": "<p>(more like it would only represent a single value, like <code>()</code>)</p>",
        "id": 173040302,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565629202
    },
    {
        "content": "<blockquote>\n<p>i'm not sure how to differentiate padding from niche in the repr relation</p>\n</blockquote>\n<p>what is the problem?<br>\nniche: byte lists that are not valid for any value<br>\npadding: bytes that you can change arbitrarily without affecting the value for which the overall byte list is valid</p>",
        "id": 173044945,
        "sender_full_name": "RalfJ",
        "timestamp": 1565632590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> is padding the fundamental primitive ?</p>",
        "id": 173047347,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565634384
    },
    {
        "content": "<p>i mean, we have bytes, and then we have padding bytes, which are not like normal bytes</p>",
        "id": 173047501,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565634526
    },
    {
        "content": "<p>no, they are not fundamental in any way</p>",
        "id": 173047555,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634579
    },
    {
        "content": "<p>whats fundamental is the value relation</p>",
        "id": 173047627,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565634607
    },
    {
        "content": "<p>this is all following what I laid down in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md</a></p>",
        "id": 173047636,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634615
    },
    {
        "content": "<p>and bytes that do not affect it follow from it</p>",
        "id": 173047656,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565634621
    },
    {
        "content": "<p>the notion of typed copy I describe there handles padding correctly, I think</p>",
        "id": 173047661,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634626
    },
    {
        "content": "<p>and we just call them padding bytes</p>",
        "id": 173047667,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565634628
    },
    {
        "content": "<p>specifically, for a type like <code>(u8, u16)</code>, with abstract value say <code>Tuple([42, 1337])</code></p>",
        "id": 173047695,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634660
    },
    {
        "content": "<p>it will, when writing, pick (non-deterministically) any value for the padding byte</p>",
        "id": 173047711,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634673
    },
    {
        "content": "<p>so it's not actually saying they become <code>0xUU</code>, it says they could become anything</p>",
        "id": 173047718,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634687
    },
    {
        "content": "<p>but that is indistinguishable in the program from saying they become <code>0xUU</code></p>",
        "id": 173047740,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634709
    },
    {
        "content": "<p>that is, it is not that only 0xUU is validfor padding</p>",
        "id": 173047834,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565634754
    },
    {
        "content": "<blockquote>\n<p>it will, when writing, pick (non-deterministically) any value for the padding byte</p>\n</blockquote>\n<p>the reason for this is that no matter what the padding byte says, the resulting byte list is related to the abstract value we are writing</p>",
        "id": 173047844,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634765
    },
    {
        "content": "<p><code>Tuple([0, 0])</code> is easier</p>",
        "id": 173047862,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634786
    },
    {
        "content": "<p>the set of 4-byte lists related to that is the set consisting of all <code>[Raw(0), X, Raw(0), Raw(0)]</code> for any <code>X</code></p>",
        "id": 173047897,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634823
    },
    {
        "content": "<p>well technically the way I wrote it, it could also pick pointer bytes that, when cast to an int, produce 0... hm, interesting.^^ that is an orthogonal issue though.</p>",
        "id": 173047988,
        "sender_full_name": "RalfJ",
        "timestamp": 1565634879
    },
    {
        "content": "<p>Is it important to be able to talk about <code>X</code> as if they are a special value that a byte can take ?</p>",
        "id": 173050726,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565636805
    },
    {
        "content": "<p>we say today that a byte can be <code>{0..256, UU}</code>, but could we extend that to also say <code>{0..256, UU, X}</code> ?</p>",
        "id": 173050774,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565636844
    },
    {
        "content": "<p>where X is \"doesn't matter\"</p>",
        "id": 173050869,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565636904
    },
    {
        "content": "<blockquote>\n<p>Is it important to be able to talk about <code>X</code> as if they are a special value that a byte can take ?</p>\n</blockquote>\n<p><code>X</code> is a mathematical variable here, quantifying over all values of my <code>Byte</code> type</p>",
        "id": 173051470,
        "sender_full_name": "RalfJ",
        "timestamp": 1565637389
    },
    {
        "content": "<blockquote>\n<p>where X is \"doesn't matter\"</p>\n</blockquote>\n<p>that seems like an unnecessary complication to me. I dont even see how it would behave differently from <code>UU</code></p>",
        "id": 173051502,
        "sender_full_name": "RalfJ",
        "timestamp": 1565637422
    },
    {
        "content": "<blockquote>\n<p>we say today that a byte can be <code>{0..256, UU}</code></p>\n</blockquote>\n<p>that's incomplete, it can also be a pointer fragment (carrying provenance)</p>",
        "id": 173051523,
        "sender_full_name": "RalfJ",
        "timestamp": 1565637440
    },
    {
        "content": "<blockquote>\n<p>that seems like an unnecessary complication to me. I dont even see how it would behave differently from UU</p>\n</blockquote>\n<p>I don't either</p>",
        "id": 173115154,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565704708
    },
    {
        "content": "<p>yet we don't have a way to use <code>UU</code> in Rust like that</p>",
        "id": 173115174,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565704724
    },
    {
        "content": "<p>right?</p>",
        "id": 173115180,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565704727
    },
    {
        "content": "<p>e.g. <code>MaybeUninit&lt;u8&gt;</code> wouldn't be it, because it requires the byte to be copied</p>",
        "id": 173115220,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565704750
    },
    {
        "content": "<blockquote>\n<p>yet we don't have a way to use <code>UU</code> in Rust like that</p>\n</blockquote>\n<p>I don't follow. As I said above I believe I have fully described padding in my existing frame, the way I defined <code>Byte</code> and <code>Value</code> in my WIP documents. What do you think is missing from that?</p>",
        "id": 173148795,
        "sender_full_name": "RalfJ",
        "timestamp": 1565728317
    },
    {
        "content": "<p>The ability for a user to say \"at offset y there are N bytes of padding\"</p>",
        "id": 173198592,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565786527
    },
    {
        "content": "<p>Or at least, in your model, I wouldn't know how to do that</p>",
        "id": 173198622,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565786569
    },
    {
        "content": "<p>E.g. If I have a <code>#[repr(C)] struct S(u16, u16)</code> and I want to insert 3 bytes of padding between both u16s, how would I do that ?</p>",
        "id": 173198660,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565786600
    },
    {
        "content": "<blockquote>\n<p>The ability for a user to say \"at offset y there are N bytes of padding\"</p>\n</blockquote>\n<p>I think that is a meaningless statement</p>",
        "id": 173215922,
        "sender_full_name": "RalfJ",
        "timestamp": 1565798164
    },
    {
        "content": "<p>padding isnt a thing that exists in memory</p>",
        "id": 173215954,
        "sender_full_name": "RalfJ",
        "timestamp": 1565798169
    },
    {
        "content": "<p>just like you cant say \"there's a bool here\" (in memory)</p>",
        "id": 173216044,
        "sender_full_name": "RalfJ",
        "timestamp": 1565798176
    },
    {
        "content": "<p>or do you mean \"at offset y in type T, ...\" -- so, stating a property of the type, not some piece of data? in that case I proposed a definition that makes that work in some UCG issue</p>",
        "id": 173216108,
        "sender_full_name": "RalfJ",
        "timestamp": 1565798206
    },
    {
        "content": "<blockquote>\n<p>or do you mean \"at offset y in type T, ...\"  </p>\n</blockquote>\n<p>that's what I meant</p>",
        "id": 173235138,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811663
    },
    {
        "content": "<p>ideally, to state that property I'd write <code>#[repr(C)] struct S(u16, Pad, Pad, Pad, u16)</code> but that would mean that I need a <code>Pad</code> type that only contains padding</p>",
        "id": 173235301,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811804
    },
    {
        "content": "<p>that would be a type that has only one value, but has, e.g.,  size 1</p>",
        "id": 173235409,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811881
    },
    {
        "content": "<p>\"contains only padding\" is an ill-defined concept</p>",
        "id": 173235445,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811906
    },
    {
        "content": "<p><code>Pad</code> is the same as <code>MaybeUninit&lt;u8&gt;</code></p>",
        "id": 173235453,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811913
    },
    {
        "content": "<p>it is a byte that can have any value</p>",
        "id": 173235461,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811918
    },
    {
        "content": "<p>not really</p>",
        "id": 173235462,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811919
    },
    {
        "content": "<p>one must copy all bytes of a MaybeUninit&lt;u8&gt; on a typed copy</p>",
        "id": 173235474,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811932
    },
    {
        "content": "<p>there is no reason to reify the concept of padding into the abstract machine</p>",
        "id": 173235479,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811937
    },
    {
        "content": "<p>the whole point of pad would be not doing that</p>",
        "id": 173235488,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811943
    },
    {
        "content": "<blockquote>\n<p>one must copy all bytes of a MaybeUninit&lt;u8&gt; on a typed copy</p>\n</blockquote>\n<p>ah I see. but that is different from \"contains only padding\".</p>",
        "id": 173235499,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811958
    },
    {
        "content": "<p>for that you want a type which has a trivial value representation but accepts any byte list</p>",
        "id": 173235550,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811976
    },
    {
        "content": "<p>the libc crate is literally full of <code>_padding: u8</code></p>",
        "id": 173235552,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811977
    },
    {
        "content": "<p>like, <code>()</code> of size &gt; 0</p>",
        "id": 173235555,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811980
    },
    {
        "content": "<p>yeah</p>",
        "id": 173235564,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811984
    },
    {
        "content": "<p>yes that is also easy to define in my framework</p>",
        "id": 173235577,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811992
    },
    {
        "content": "<p>the type <code>Pad</code> is defined as:<br>\nValue <code>Tuple([])</code> (the empty tuple) is related to any byte-list of length 1.<br>\nend of definition.</p>",
        "id": 173235610,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812021
    },
    {
        "content": "<p>this is a type that accepts any value (validity invariant is trivial) and where a typed copy transports no information (because it goes through <code>Tuple([])</code>, a singleton)</p>",
        "id": 173235658,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812064
    },
    {
        "content": "<p>I finally understood what you mean by \"contains only padding\". it's not about the values it accepts / the validity invariant. it is about the behavior on a typed copy.</p>",
        "id": 173235742,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812112
    },
    {
        "content": "<p>we currently doesn't really have a way to specify that in the language</p>",
        "id": 173235760,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812126
    },
    {
        "content": "<p><code>Pad</code> and <code>MaybeUninit&lt;u8&gt;</code> have the same validity invariant</p>",
        "id": 173235761,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812128
    },
    {
        "content": "<blockquote>\n<p>we currently doesn't really have a way to specify that in the language</p>\n</blockquote>\n<p>well we do in the meta-language that we are speaking right now</p>",
        "id": 173235770,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812139
    },
    {
        "content": "<p>but we dont in Rust, right</p>",
        "id": 173235772,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812142
    },
    {
        "content": "<p>i guess that's what i meant with \"a <code>MaybeUninit&lt;u8&gt;</code> that's always uninitialzied\"</p>",
        "id": 173235775,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812143
    },
    {
        "content": "<p>yeah. that wording tripped me because \"is always X\" sounds a lot like you want to change the validity invariant.</p>",
        "id": 173235795,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812166
    },
    {
        "content": "<p>\"a bool is always true or false\"</p>",
        "id": 173235802,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812181
    },
    {
        "content": "<p>so with such a Pad type, maybe we could improve some of the examples</p>",
        "id": 173235811,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812189
    },
    {
        "content": "<p>but here this is not at all what you want so that wording was misleading</p>",
        "id": 173235812,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812189
    },
    {
        "content": "<p>but now that we cleared this, we should write this down somewhere :D</p>",
        "id": 173235820,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812203
    },
    {
        "content": "<p>e.g. if such a <code>Pad</code> type were present in libcore, we can write some examples as ... is equivalent to ... struct using Pad</p>",
        "id": 173235869,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812221
    },
    {
        "content": "<p>yes</p>",
        "id": 173235877,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812228
    },
    {
        "content": "<p>and then we don't talk about \"padding\" anymore</p>",
        "id": 173235885,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812243
    },
    {
        "content": "<p>but about <code>Pad</code></p>",
        "id": 173235888,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812246
    },
    {
        "content": "<p>we could add a section \"padding\" to the glossary, which does nothing but define that type?</p>",
        "id": 173235892,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812252
    },
    {
        "content": "<p>that sounds like a good idea</p>",
        "id": 173235908,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812268
    },
    {
        "content": "<p>and then we can basically use padding as synonym for <code>[Pad; N]</code></p>",
        "id": 173235931,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812295
    },
    {
        "content": "<p>a union then always has a variant of type <code>[Pad; N]</code></p>",
        "id": 173235941,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812306
    },
    {
        "content": "<p>why that?</p>",
        "id": 173235995,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812325
    },
    {
        "content": "<p>seems like this doesnt change anything</p>",
        "id": 173235996,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812330
    },
    {
        "content": "<p>ah no, it is not necessary</p>",
        "id": 173236003,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812338
    },
    {
        "content": "<p>its more like, a union uses two <code>[Pad; N]</code> (one before, one after the field) to fill each variant to the full size</p>",
        "id": 173236009,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812343
    },
    {
        "content": "<p>we can just say that typed copies of union do not copy bytes at offsets where all variants have a Pad</p>",
        "id": 173236027,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812364
    },
    {
        "content": "<p>i.e., what I had in my \"picture\"^^</p>",
        "id": 173236031,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812370
    },
    {
        "content": "<p>yep</p>",
        "id": 173236038,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812380
    },
    {
        "content": "<p>rules are the same</p>",
        "id": 173236047,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812385
    },
    {
        "content": "<blockquote>\n<p>we can just say that typed copies of union do not copy bytes at offsets where all variants have a Pad</p>\n</blockquote>\n<p>well here I'd slow down a bit, as that's a syntactic def.n</p>",
        "id": 173236052,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812390
    },
    {
        "content": "<p>\"where in this type is padding\" would become a part of the ABI</p>",
        "id": 173236084,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812419
    },
    {
        "content": "<p>isn't it equivalent to the one we have ?</p>",
        "id": 173236085,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812419
    },
    {
        "content": "<p>and this is \"interesting\" for enums</p>",
        "id": 173236089,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812424
    },
    {
        "content": "<p>like, <code>Result&lt;(u8, u16), (u16, u8)&gt;</code> has different padding depending on the active variant...</p>",
        "id": 173236168,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812450
    },
    {
        "content": "<p>at least if you follow my typed copy rules</p>",
        "id": 173236180,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812462
    },
    {
        "content": "<p>indeed</p>",
        "id": 173236192,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812475
    },
    {
        "content": "<p>\"where in this type is padding\" is kind of already part of the type ABI</p>",
        "id": 173236234,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812511
    },
    {
        "content": "<p>even if nothing there mentions padding</p>",
        "id": 173236245,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812516
    },
    {
        "content": "<p>well... no I dont agree. it's pat of the value representation relation. but so far we didnt want to make that part of the ABI.</p>",
        "id": 173236278,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812547
    },
    {
        "content": "<p>so i think the value relation is part of the ABI of the type</p>",
        "id": 173236432,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812681
    },
    {
        "content": "<p>you can observe it</p>",
        "id": 173236491,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812700
    },
    {
        "content": "<p>I dont think so. the representation relation is extremely language-specific. we don't want to have to sync that between Rust and C.</p>",
        "id": 173236503,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812714
    },
    {
        "content": "<p>e.g. get a value of a type, inspect its bytes, move it around, and see which bytes don't change</p>",
        "id": 173236505,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812717
    },
    {
        "content": "<p>so you can at least infer that some bytes are not part of the value relation of a type</p>",
        "id": 173236535,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812743
    },
    {
        "content": "<p>but ultimately this is a rather arbitrary choice of terminology</p>",
        "id": 173236541,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812746
    },
    {
        "content": "<p>due to how typed copies work on the type</p>",
        "id": 173236557,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812757
    },
    {
        "content": "<p>what worries me more is how to define unions appropriately. it'll be really ugly and really sad :(</p>",
        "id": 173236565,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812768
    },
    {
        "content": "<p>time to sleep :P</p>",
        "id": 173236635,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812805
    },
    {
        "content": "<p>;)</p>",
        "id": 173236652,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812813
    }
]