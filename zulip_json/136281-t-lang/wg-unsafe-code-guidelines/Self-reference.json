[
    {
        "content": "<p>I haven't kept up with all of the discussion, but I see that there is a lot of provenance and stuff for raw pointers recently, and some proposed solutions in that gankra blog post. I was wondering â€” does any of this do anything about the self-referential struct troubles?</p>",
        "id": 276220912,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1647968393
    },
    {
        "content": "<p>Which self-referential struct troubles? The ability to understand that a mutable reference to a self-referential struct is not noalias?</p>",
        "id": 276224721,
        "sender_full_name": "bstrie",
        "timestamp": 1647969863
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/63818\">https://github.com/rust-lang/rust/issues/63818</a></p>",
        "id": 276225256,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1647970095
    },
    {
        "content": "<p>Don't think so, this is to do with what happens when you convert a pointer to an integer and back again - the uniqueness of references isn't really involved.</p>\n<p>The impact I'd imagine it having on async is whether it's sound to smuggle pointers through <code>io-uring</code>'s user data field (&lt;<a href=\"https://docs.rs/io-uring/0.5/io_uring/squeue/struct.Entry.html#method.user_data\">https://docs.rs/io-uring/0.5/io_uring/squeue/struct.Entry.html#method.user_data</a>&gt;)</p>",
        "id": 276293665,
        "sender_full_name": "Kestrer",
        "timestamp": 1648017562
    },
    {
        "content": "<p>but if adopting and enforcing these restrictions on pointers allows rust to have a working aliasing model, would that solve this problem?</p>",
        "id": 276323027,
        "sender_full_name": "bstrie",
        "timestamp": 1648037070
    },
    {
        "content": "<p>I suppose, and that would be a nice outcome, but I don't think that will necessarily happen as a result of this. The central question right now is \"should int2ptr be allowed?\" and that can be answered without answering whether <code>&amp;mut</code> universally enforces uniqueness or not.</p>\n<p>Maybe if PNVI-ae were to be chosen then it would have a small impact because you could make each node in an intrusive linked list have an exposed address, thus allowing you to magic up provenance to any of them at any time. But it doesn't look like that model will be used, and it doesn't solve the \"async fn is unsound\" issue anyway since that's about references not raw pointers.</p>",
        "id": 276325170,
        "sender_full_name": "Kestrer",
        "timestamp": 1648038375
    }
]