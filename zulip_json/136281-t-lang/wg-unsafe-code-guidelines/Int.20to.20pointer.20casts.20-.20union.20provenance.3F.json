[
    {
        "content": "<p>This was being discussed breifly on the rust community discord, and I was wondering how this applies to rust, specifically, pointer to integer casts.<br>\nThe idea is \"union provenance\" IE. pointers that have exactly one provenance of some set, but the compiler doesn't (yet) know which one. The example was</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It's easy to see that (ignoring other sources of leaked addresses) <code>p</code> has the union provenance <code>a[1]|a[..2]|a[1..]</code>, but is this \"it has all of these provenances simulatenously\" or is it that \"it has exactly one of these provenances, it's just not yet know which one\".<br>\nFor example, if <code>p.offset(-1)</code> was used, could the implementation reason that <code>p.offset(2)</code> has undefined behaviour (again, assuming no other possible pointers for <code>p</code>, or that all others are ruled out), and if <code>p.offset(2)</code> is used that <code>p.offset(-1)</code> has undefined behaviour? Or would both of those operations be allowed because it ends up with provenance to the entire allocation of <code>p</code>? </p>\n<p>My ideal answer is \"yes\" because I would like to, in lccc, be able to do this kind of \"on-both-sides\" reasoning, to narrow down what pointers could possibly come from any source of an unknown pointer in general.</p>",
        "id": 268192203,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642348413
    },
    {
        "content": "<blockquote>\n<p>pointers that have exactly one provenance of some set, but the compiler doesn't (yet) know which one</p>\n</blockquote>\n<p>I am very confused by this framing already -- provenance is part of the <em>operational semantics</em> of Rust, and has nothing to do with what the <em>compiler</em> does or does not know. It is common to confuse this provenance that is present in the op.sem with compiler analyses that attempt to determine the 'provenance' of a pointer, but those are totally different (albeit related) concepts that should not be confused. (in fancy words one might call them 'synthetic' and 'emergent' provenance but I am not sure if anyone besides me finds those terms helpful.^^)</p>",
        "id": 268204390,
        "sender_full_name": "RalfJ",
        "timestamp": 1642364001
    },
    {
        "content": "<p>judging from your example though it seems you meant something like \"the operational semantics cannot uniquely determine the provenance\", and this has nothing to do with compiler knowledge or analyses</p>",
        "id": 268204466,
        "sender_full_name": "RalfJ",
        "timestamp": 1642364087
    },
    {
        "content": "<p><code>p</code> is an integer so I dont think asking about its provenance is meaningful... and <code>&amp;a[1] as *const i32</code> has a pretty clear provenance since it comes directly from <code>a</code>.<br>\nbut indeed if we later in this program do <code>p as *const i32</code> then we have three ptrs that were cast to the same integer that this could be referring to. I have not seen a nice proposal for resolving this (other than banning usize-to-ptr casts which more and more looks like the only reasonable solution...). the best one I know is basically \"we try executing the program with all possible choices and as long as one of them works we are happy\", which is a form of 'angelic non-determinism' and probably has far-reaching consequences for all consumers of a Rust spec. the C provenance proposal does basically this, though they implement it explicitly with a form of 'symbolic provenance'.</p>",
        "id": 268204662,
        "sender_full_name": "RalfJ",
        "timestamp": 1642364337
    },
    {
        "content": "<blockquote>\n<p>\"we try executing the program with all possible choices and as long as one of them works we are happy\"</p>\n</blockquote>\n<p>Is this the union provenance I'm talking about, just reworded? IE. the resulting pointer has <em>some</em> unique provenance (it's either <code>&amp;a[1]</code>, <code>&amp;a[1..]</code>, or <code>&amp;a[..2]</code>, which are all different, though overlapping subranges of <code>a</code> IIRC), but it cannot be immediately determined which one, and then if you perform an operation valid for one, but not valid on another, that other provenance or provenances can be ruled out in analysis/runtime tracking?</p>",
        "id": 268204799,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642364531
    },
    {
        "content": "<p>its not quite the same thing -- consider the case where the resulting pointer is copied so you have many ptrs with the same provenance.  the 'angelic' option says that a single consistent choice has to work for all these pointers, whereas your approach would allow one of them to 'refine' its provenance to A and another copy to 'refine' its provenance to a (conflicting) B</p>",
        "id": 268568473,
        "sender_full_name": "RalfJ",
        "timestamp": 1642610944
    },
    {
        "content": "<blockquote>\n<p>whereas your approach would allow one of them to 'refine' its provenance to A and another copy to 'refine' its provenance to a (conflicting) B</p>\n</blockquote>\n<p>I'd assume that refining one would force the other copies to the same. IE. <code>q=&gt;p</code> (q derived from p), <code>p-&gt;A</code> (p points to A), means <code>q-&gt;A</code>.</p>",
        "id": 268569099,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642611174
    },
    {
        "content": "<blockquote>\n<p>other than banning usize-to-ptr casts which more and more looks like the only reasonable solution...</p>\n</blockquote>\n<p>Would this ban bit-packing into pointers? If it would, that seems strange to pay a runtime cost for a provenance model.</p>",
        "id": 268590211,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1642619981
    },
    {
        "content": "<p>It should still be possible if an intrinsic for it is introduced. This intrinsic would just preserve the provenance of the input pointer in the output pointer.</p>",
        "id": 268596560,
        "sender_full_name": "bjorn3",
        "timestamp": 1642623028
    },
    {
        "content": "<p>Ah that makes sense. It will be a bit annoying to fix all the code that does this, but I suppose this is pretty minor in comparison to all the other extant code that provenance outlaws. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 268613548,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1642631666
    },
    {
        "content": "<p>\"a bit annoying\" is an understatement, and I expect people will keep writing such code because it works in C.</p>",
        "id": 268745043,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642707012
    },
    {
        "content": "<p>It's worth noting most of the the proposed PNVI provenance models for C do manage to allow ptr-&gt;int-&gt;ptr casting, so it's not like this can't be solved.</p>\n<p>I also can easily come up with scenarios where a \"int_to_ptr_with_provenance\" operation is not a solution. For example, it means that i need to carry both the integer and the provenance source to the output, but i may have to do a CAS at some point, and the maximum width of a cas that is commonly available is only a single pointer in size.</p>",
        "id": 268745857,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1642707385
    },
    {
        "content": "<p>Can't you use an AtomicPtr in that case?</p>",
        "id": 268769152,
        "sender_full_name": "bjorn3",
        "timestamp": 1642718798
    },
    {
        "content": "<p>FWIW, I think the whole \"pass in a pointer with the provenance you want\" pattern is of greatly limited utility. If you're doing bit-packing to shrink the size of a data structure, you might as well just not do the packing and keep separate a u8 or a bool you were going to pack (I'm aware of code that does this in <code>bytes</code> and I think I  <code>semver</code>). And in the case of <code>rayon</code> which wants to merge slices, there's no use in passing a pointer alongside. The better fix is to store a pointer and length instead of a slice.</p>",
        "id": 268772189,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1642720677
    },
    {
        "content": "<p>When bit packing you can store   pointer but use a ptr2int cast and bitmanipulation followed by a int+provenance to ptr cast with the original pointer as provenance. When unpacking you can do the exact same. Just make sure you store a pointer instead of an integer.</p>",
        "id": 268773239,
        "sender_full_name": "bjorn3",
        "timestamp": 1642721382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/268590211\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>other than banning usize-to-ptr casts which more and more looks like the only reasonable solution...</p>\n</blockquote>\n<p>Would this ban bit-packing into pointers? If it would, that seems strange to pay a runtime cost for a provenance model.</p>\n</blockquote>\n<p>no it wouldnt. bit packing can be implemented without int-to-ptr casts, see e.g. <a href=\"https://github.com/bitvecto-rs/bitvec/issues/135#issuecomment-986357842\">https://github.com/bitvecto-rs/bitvec/issues/135#issuecomment-986357842</a>. (this is exactly what <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> suggested.)</p>",
        "id": 269466493,
        "sender_full_name": "RalfJ",
        "timestamp": 1643224773
    },
    {
        "content": "<blockquote>\n<p>It's worth noting most of the the proposed PNVI provenance models for C do manage to allow ptr-&gt;int-&gt;ptr casting, so it's not like this can't be solved.</p>\n</blockquote>\n<p>yeah but they are solving an easier problem. I am eagerly awaiting the extension of PNVI that supports <code>restrict</code>; <em>that</em> would be a fair comparison with a Rust provenance model. (I am not sure if anyone is actually working on that though.)<br>\nsome day I might have the time to write the blog post that shows with examples why this is a strictly harder problem...</p>",
        "id": 269466624,
        "sender_full_name": "RalfJ",
        "timestamp": 1643224817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/268745857\">said</a>:</p>\n<blockquote>\n<p>I also can easily come up with scenarios where a \"int_to_ptr_with_provenance\" operation is not a solution. For example, it means that i need to carry both the integer and the provenance source to the output, but i may have to do a CAS at some point, and the maximum width of a cas that is commonly available is only a single pointer in size.</p>\n</blockquote>\n<p>Honestly I find it hard to believe that an atomic CAS is enjoying enormous optimizations anyways around it from pointer provenance such that accepting a degraded provenance will be a significant negative impact, or enjoying such optimizations from bit-packing that the provenance-related optimizations would not be a fair trade. However maybe the \"<code>restrict</code>-like pointers\" rule changes that somehow in some way I am not aware of, as Ralf noted.</p>",
        "id": 273158595,
        "sender_full_name": "Jubilee",
        "timestamp": 1645741816
    },
    {
        "content": "<p>a CAS at pointer type should usually solve this, I think (but I can imagine there are nasty corner cases)</p>",
        "id": 273158726,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741911
    },
    {
        "content": "<p>sadly, even our AtomicPtr uses CASes at integer type under the hood, which confuses the heck out of miri. I think there is no good reason for this, just an LLVM limitation (LLVM doesnt supports atomic at ptr type). I hope some day someone will move the ptr/int casting into the LLVM backend so that on the MIR level everything is sane and pointer-typed, and then this will work a lot better in Miri, too. :D</p>",
        "id": 273158827,
        "sender_full_name": "RalfJ",
        "timestamp": 1645741957
    },
    {
        "content": "<p>I see. So the other option is that CAS via pointers isn't being well-optimized anyways to begin with, I suppose.</p>",
        "id": 273158911,
        "sender_full_name": "Jubilee",
        "timestamp": 1645742026
    },
    {
        "content": "<p>I dont see any optimization advantage for CASing at int vs ptr type</p>",
        "id": 273158983,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742052
    },
    {
        "content": "<p>if anything, preserving the ptr type should help optimizations as it gives the compiler more insight into what happens^^</p>",
        "id": 273158999,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742068
    },
    {
        "content": "<p>Right, I mean that LLVM doesn't have that much support for the hypothetical optimizations that would be lost.</p>",
        "id": 273159067,
        "sender_full_name": "Jubilee",
        "timestamp": 1645742117
    },
    {
        "content": "<p>many parts of LLVM still treat integers (<code>iN</code>) as a kind of \"universal\" type that all data can be losslessly stored in. under that view, having atomics at int type is sufficient. I think that is why they dont allow ptr types.</p>",
        "id": 273159104,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742154
    },
    {
        "content": "<p>Mmm.</p>",
        "id": 273159148,
        "sender_full_name": "Jubilee",
        "timestamp": 1645742165
    },
    {
        "content": "<p>also see that entire discussion about adding a \"byte\" type to LLVM</p>",
        "id": 273159182,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742194
    },
    {
        "content": "<p>a type that would <em>actually</em> support holding all data losslessly</p>",
        "id": 273159195,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742203
    },
    {
        "content": "<p>sadly it didnt get very far yet</p>",
        "id": 273159219,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273159067\">said</a>:</p>\n<blockquote>\n<p>Right, I mean that LLVM doesn't have that much support for the hypothetical optimizations that would be lost.</p>\n</blockquote>\n<p>I dont know which optimizations you mean or why they'd be lost if atomics supported ptr types...</p>",
        "id": 273159264,
        "sender_full_name": "RalfJ",
        "timestamp": 1645742253
    },
    {
        "content": "<p>Well we're talking about trying to combine that with bitpacking via ptr-&gt;int-&gt;ptr</p>",
        "id": 273159366,
        "sender_full_name": "Jubilee",
        "timestamp": 1645742296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/269466624\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It's worth noting most of the the proposed PNVI provenance models for C do manage to allow ptr-&gt;int-&gt;ptr casting, so it's not like this can't be solved.</p>\n</blockquote>\n<p>yeah but they are solving an easier problem. I am eagerly awaiting the extension of PNVI that supports <code>restrict</code>; <em>that</em> would be a fair comparison with a Rust provenance model. (I am not sure if anyone is actually working on that though.)<br>\nsome day I might have the time to write the blog post that shows with examples why this is a strictly harder problem...</p>\n</blockquote>\n<p>How exactly <strong>is</strong> the restrict keyword different?</p>",
        "id": 273159417,
        "sender_full_name": "Jubilee",
        "timestamp": 1645742332
    },
    {
        "content": "<p>I wonder if the new opaque pointer type would make it more reasonable to add support for atomics on pointer types, rather than just integers.</p>",
        "id": 273160531,
        "sender_full_name": "scottmcm",
        "timestamp": 1645742986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273158595\">said</a>:</p>\n<blockquote>\n<p>Honestly I find it hard to believe that an atomic CAS is enjoying enormous optimizations anyways around it from pointer provenance such that accepting a degraded provenance will be a significant negative impact</p>\n</blockquote>\n<p>Yes, I agree. Note that I don't care about the optimizations really, so long as losing the provenance (or whatever) doesn't make it unsound to use the pointer when i cast it back on the other side.</p>\n<p>An conceptually simple (although the implementation is a little complex) example of the case I'm concerned about is <a href=\"https://github.com/Amanieu/parking_lot/blob/78f09f45d6b8b34ec23afdf7a696cbe54d0a469b/core/src/word_lock.rs\">https://github.com/Amanieu/parking_lot/blob/78f09f45d6b8b34ec23afdf7a696cbe54d0a469b/core/src/word_lock.rs</a>, which uses bottom bits of a integer to indicate lock state, and the top bits to store a pointer to a linked list of waiting threads. It's not clear how this could be done in a <code>ptr::with_provenance</code> situation, although having atomic bitor and such directly on an atomic pointer type would solve it, I suppose.</p>",
        "id": 273162847,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645744255
    },
    {
        "content": "<p>I think the issue with casting inttoptr isn't necessarily that it <strong>has</strong> to be <em>unsound</em>, just that it will destroy some or a lot of possible optimizations... which, well.</p>\n<p>...multiplying zero by zero is still zero, yanno?</p>",
        "id": 273166405,
        "sender_full_name": "Jubilee",
        "timestamp": 1645746512
    },
    {
        "content": "<p>Because as I understand it you can always say \"The provenance is from the null pointer. <span aria-label=\"angel\" class=\"emoji emoji-1f47c\" role=\"img\" title=\"angel\">:angel:</span>\"</p>",
        "id": 273166435,
        "sender_full_name": "Jubilee",
        "timestamp": 1645746540
    },
    {
        "content": "<p>hm, i thought it might prevent optimizations on other things, which is why it would be disallowed.</p>",
        "id": 273172352,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645751240
    },
    {
        "content": "<blockquote>\n<p>How exactly is the restrict keyword different?</p>\n</blockquote>\n<p>at a high level: with restrict (and with Rust's aliasing rules), there are many different valid provenances (as in, valid for a memory access to be performed) for a pointer to the same address.<br>\nin C without restrict, there is always at most one.</p>",
        "id": 273262039,
        "sender_full_name": "RalfJ",
        "timestamp": 1645811684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273159366\">said</a>:</p>\n<blockquote>\n<p>Well we're talking about trying to combine that with bitpacking via ptr-&gt;int-&gt;ptr</p>\n</blockquote>\n<p>bitpacking is expressible without ever doing a int2ptr cast, so I think that is the way to go here. (and using ptr-typed atomics.)</p>",
        "id": 273262128,
        "sender_full_name": "RalfJ",
        "timestamp": 1645811725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273166405\">said</a>:</p>\n<blockquote>\n<p>I think the issue with casting inttoptr isn't necessarily that it <strong>has</strong> to be <em>unsound</em>, just that it will destroy some or a lot of possible optimizations... which, well.</p>\n<p>...multiplying zero by zero is still zero, yanno?</p>\n</blockquote>\n<p>the problem isnt even optimizations around the cast operation. even if we say we dont touch functions that contain such casts, we still have a problem, since <em>other</em> functions are optimized in a way that needs provenance to be justified. the problem is the <em>ability to even define what the program will do when executed</em>, in particular whether it has UB. we can't even answer with certainty the question of which optimizations are valid.</p>",
        "id": 273262296,
        "sender_full_name": "RalfJ",
        "timestamp": 1645811817
    },
    {
        "content": "<p>casts would be easy if we would never rely on provenance for optimizations. (or if we would only rely on \"inferred provenance\", where the compiler can <em>prove</em> that certain values are related in a certain way. this is different from the provenance in C/Rust which exists by fiat. ) basically, if you could write a Miri-like tool that detects <em>all</em> UB, and that tool would not need any kind of provenance, then things would be easy.<br>\nbut the moment you add provenance to the language <em>spec</em> (and tools like Miri) itself, then int2ptr becomes hard. that is probably best seen when taking the Miri perspective: in the interpreter, when we execute an int2ptr cast -- how do we compute the provenance of the newly generated pointer? we have full knowledge of the program state, but that is still a question that might not even have a well-defined answer.<br>\nand that's why I am so keen on exploring ways to just avoid int2ptr casts altogether :)</p>",
        "id": 273263313,
        "sender_full_name": "RalfJ",
        "timestamp": 1645812226
    },
    {
        "content": "<p>\"inferred provenance\" sounds interesting. What would be the implications of only relying on things the compiler can prove? That sounds like it might reduce the burden on the code author.</p>",
        "id": 273266748,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645813828
    },
    {
        "content": "<p>yeah, its what compilers do, like, everywhere else</p>",
        "id": 273267228,
        "sender_full_name": "RalfJ",
        "timestamp": 1645814058
    },
    {
        "content": "<p>and some people think it <em>might</em> be possible for C sans restrict. I am not convinced of that.<br>\nit is certainly impossible for restrict or Rust's aliasing rules to be of any use.</p>",
        "id": 273267326,
        "sender_full_name": "RalfJ",
        "timestamp": 1645814109
    },
    {
        "content": "<p>Sigh.</p>",
        "id": 273267457,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645814163
    },
    {
        "content": "<p>in those cases we observably have ptrs with the same address that are distinct, i.e., it matters which one you use</p>",
        "id": 273267521,
        "sender_full_name": "RalfJ",
        "timestamp": 1645814198
    },
    {
        "content": "<p>that can only be exaplained via \"synthetic\" provenance -- the kind that needs to be explicitly added in Miri, and explicitly considered by programmers</p>",
        "id": 273267578,
        "sender_full_name": "RalfJ",
        "timestamp": 1645814231
    },
    {
        "content": "<p>so, yeah, \"inferred provenance\" (I also like \"emergent provenance\" as a term for this) would reduce the burden on the code author -- they could stop thinking about it entirely (unless they care about which optimizations are applied). but the loss on optimization potential is probably too big for this to be viable.</p>",
        "id": 273267760,
        "sender_full_name": "RalfJ",
        "timestamp": 1645814328
    },
    {
        "content": "<p>How much of this is \"loss on optimization potential\", and how much of this is \"this is what LLVM does so it's not like we have a choice\"?</p>",
        "id": 273268348,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645814626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273268348\">said</a>:</p>\n<blockquote>\n<p>How much of this is \"loss on optimization potential\", and how much of this is \"this is what LLVM does so it's not like we have a choice\"?</p>\n</blockquote>\n<p>The problem is that LLVM has optimizations based on provenance that accept int-&gt;ptr casts, but which are actually flatly unsound.</p>",
        "id": 273276786,
        "sender_full_name": "Jubilee",
        "timestamp": 1645818784
    },
    {
        "content": "<p>and LLVM has very little of the kind of optimizations that use the restrict keyword that Ralf is talking about, which as noted inject additional headaches.</p>",
        "id": 273276866,
        "sender_full_name": "Jubilee",
        "timestamp": 1645818834
    },
    {
        "content": "<p>A compiler <strong>can</strong> recover an inferred provenance, but like all type inference, this is not 100% infallible. And as Ralf noted, it makes later optimizations which are based on other provenances hard to justify.</p>",
        "id": 273277024,
        "sender_full_name": "Jubilee",
        "timestamp": 1645818918
    },
    {
        "content": "<p>LLVM is having to restructure their compilation and optimization model around this fact <strong>somehow</strong>. We have a choice of either going along with whatever LLVM does... even if it is in fact wildly bad for Rust... or starting to design our own model.</p>\n<p>Fighting against the fact that int-&gt;ptr is not great for Rust's model because \"C does it!\" is not actually a winning strategy, nor is it the one that somehow resists whatever LLVM decides for us. It is in fact the one that fully concedes the field to whatever LLVM decides is their new model, over time, no matter how good or bad, coherent or incoherent, sound or unsound, it is.</p>",
        "id": 273277533,
        "sender_full_name": "Jubilee",
        "timestamp": 1645819198
    },
    {
        "content": "<p>The time we actually know how much this will be inherent to LLVM's decisions and how much it is down to optimization losses will be the moment at which it is too late to actually make a new decision and advocate for it upstream because everything will have been decided.</p>",
        "id": 273278616,
        "sender_full_name": "Jubilee",
        "timestamp": 1645819763
    },
    {
        "content": "<p>if there is a model which makes optimizations easy for C code but is flatly worse for Rust in every way, I have no confidence that LLVM will not take that choice, unless we are already presenting our alternative and its benefits.</p>",
        "id": 273278952,
        "sender_full_name": "Jubilee",
        "timestamp": 1645819956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273277533\">said</a>:</p>\n<blockquote>\n<p>Fighting against the fact that int-&gt;ptr is not great for Rust's model</p>\n</blockquote>\n<p>I feel like that's an inversion of the issue. I tend to treat it as the reverse: is the compiler backend and/or the availability of <em>incredible optimization potential</em> making it <em>absolutely necessary</em> that we push back on int-&gt;ptr casts, such that it's worth the pain of making people do something else in their code?</p>",
        "id": 273279657,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645820366
    },
    {
        "content": "<p>(I'm going to try to avoid re-treading old territory here. I mostly was asking after \"inferred provenance\" because I'd never heard of that approach.)</p>",
        "id": 273279873,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645820512
    },
    {
        "content": "<p>Also, this isn't only deisrable because C allows it. Genuinely, I think it's a lot harder to think of ways to avoid int-&gt;ptr and ptr-&gt;int casts in certain code. <a href=\"https://github.com/rust-lang/rust/pull/87869\">https://github.com/rust-lang/rust/pull/87869</a> was very hard to think of a way to avoid it. I'm not sure that in all cases its avoidable (in particular, the atomics case requires some undesirable library extensions, like allowing bitops on AtomicPtr...)</p>\n<p>Even when it is possible, in many cases it's still undesirable and leads to a larger degree of platform specific code. With integers, I can cast a <code>usize</code> to a <code>u64</code> on both 32 bit and 64 bit, and have all the code handle it there. But if I have to use <code>*const ()</code> or w/e that stores \"ptr or bits\", then I basically need to have separate codepaths for 64/32 bit in most cases (and you'll notice this happens in io::Error).</p>",
        "id": 273282185,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645821561
    },
    {
        "content": "<p>Say int-&gt;ptr could produce any provenance, including those not previously leaked using ptr-&gt;int, then most memory optimizations become invalid AFAIU. Now we probably won't be as radical as that, but doing anything other than this and disallowing int-&gt;ptr entirely is more complicated. We would have to make some tradeoff between more complex rules and worse optimizations.</p>",
        "id": 273282523,
        "sender_full_name": "bjorn3",
        "timestamp": 1645821721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273279657\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273277533\">said</a>:</p>\n<blockquote>\n<p>Fighting against the fact that int-&gt;ptr is not great for Rust's model</p>\n</blockquote>\n<p>I feel like that's an inversion of the issue. I tend to treat it as the reverse: is the compiler backend and/or the availability of <em>incredible optimization potential</em> making it <em>absolutely necessary</em> that we push back on int-&gt;ptr casts, such that it's worth the pain of making people do something else in their code?</p>\n</blockquote>\n<p>Have we ever tried to gather any data to this effect? Like, has anyone ever tried to implement a <code>-Z stacked-borrows-alias-analysis</code> that does some optimizations? This would possibly give us an opportunity to measure the effect of missing optimizations in the real world. Maybe other people have better intuition than me on this, but I at the very least have trouble reasoning about which optimizations we \"need\" and which ones we don't</p>",
        "id": 273289564,
        "sender_full_name": "Jake",
        "timestamp": 1645826047
    },
    {
        "content": "<p>I've been working on MIR opts recently, and although I probably lack some of the background (and there are a couple other things I want to do first), if the answer to this is \"no,\" I would not be opposed to putting in the work to give this a try</p>",
        "id": 273289981,
        "sender_full_name": "Jake",
        "timestamp": 1645826306
    },
    {
        "content": "<p>My experience is that alias optimizations are actually pretty minor and situational. The most effective of them are in loops when stuff like stores to (something derived from a) <code>&amp;mut [T]</code> are known not to invalidate loads from (something derived from a) <code>&amp;[T]</code>, but most of the time it just allows some preferential reordering that can avoid some spilling and such. That said, I've been told that there are more important cases.</p>\n<p>I'd be somewhat concerned about implementing our own optimizations here, to avoid canonicalizing the status quo, though.</p>",
        "id": 273291806,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645827268
    },
    {
        "content": "<p>To be clear though, I think this is broader than just the common alias optimizations, or at least the ones enabled by noalias.</p>",
        "id": 273292030,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645827427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273291806\">said</a>:</p>\n<blockquote>\n<p>My experience is that alias optimizations are actually pretty minor and situational. The most effective of them are in loops when stuff like stores to (something derived from a) <code>&amp;mut [T]</code> are known not to invalidate loads from (something derived from a) <code>&amp;[T]</code>, but most of the time it just allows some preferential reordering that can avoid some spilling and such. That said, I've been told that there are more important cases.</p>\n<p>I'd be somewhat concerned about implementing our own optimizations here, to avoid canonicalizing the status quo, though.</p>\n</blockquote>\n<p>Can you explain this last part a bit more? Are you worried that implementing an opt would cause us to become unwilling to \"fix\" SB (in fear of breaking the opts)?</p>",
        "id": 273294248,
        "sender_full_name": "Jake",
        "timestamp": 1645828610
    },
    {
        "content": "<p>Yes, basically. Perhaps it's unfounded.</p>",
        "id": 273297592,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645830702
    },
    {
        "content": "<p>And that it will justify logic like \"that code is just broken and needs to be fixed\" (rather than that perhaps the model does). Anyway it might be unfounded, but I already see that logic around SB (but perhaps I'm overly worried)</p>",
        "id": 273297712,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645830773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273297712\">said</a>:</p>\n<blockquote>\n<p>And that it will justify logic like \"that code is just broken and needs to be fixed\" (rather than that perhaps the model does). Anyway it might be unfounded, but I already see that logic around SB</p>\n</blockquote>\n<p>Yeah, I do think that this is a risk in general, but we should be able to work around. Like, if we do such a thing, both the procedural practices surrounding it and the implementation itself should be set up very concretely with the goal of using it as a tool for experimentation</p>",
        "id": 273298048,
        "sender_full_name": "Jake",
        "timestamp": 1645830979
    },
    {
        "content": "<p>Yeah, thats plausible. I do think there's a way we could do it.</p>",
        "id": 273298154,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645831061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273279657\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273277533\">said</a>:</p>\n<blockquote>\n<p>Fighting against the fact that int-&gt;ptr is not great for Rust's model</p>\n</blockquote>\n<p>I feel like that's an inversion of the issue. I tend to treat it as the reverse: is the compiler backend and/or the availability of <em>incredible optimization potential</em> making it <em>absolutely necessary</em> that we push back on int-&gt;ptr casts, such that it's worth the pain of making people do something else in their code?</p>\n</blockquote>\n<p>I am stating precisely that you must invert it and instead approach from what you want, instead, because the future is not written and LLVM is allowed to choose a design which instead makes it <code>(Lose, Lose)</code>: They may choose an implementation that makes int-&gt;ptr casts in Rust code functionally unsound from the Rust perspective <strong>and</strong> deoptimizes Rust code. You are asking about an unconstrained variable.</p>",
        "id": 273302870,
        "sender_full_name": "Jubilee",
        "timestamp": 1645834385
    },
    {
        "content": "<p>You cannot treat the ground as stable and you cannot wait and see.</p>",
        "id": 273302981,
        "sender_full_name": "Jubilee",
        "timestamp": 1645834484
    },
    {
        "content": "<p>The question is <strong>not</strong> \"what does LLVM require?\" because they don't have an answer yet. Not a certain one.<br>\nIt is not \"how many optimizations are we losing?\" because LLVM hasn't audited all their opts either.<br>\nThe question is \"how much type-based and flow-based alias analysis do you want, and what are you willing to pay to get it?\"</p>",
        "id": 273303849,
        "sender_full_name": "Jubilee",
        "timestamp": 1645835361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273289564\">said</a>:</p>\n<blockquote>\n<p>Have we ever tried to gather any data to this effect? Like, has anyone ever tried to implement a <code>-Z stacked-borrows-alias-analysis</code> that does some optimizations? This would possibly give us an opportunity to measure the effect of missing optimizations in the real world. Maybe other people have better intuition than me on this, but I at the very least have trouble reasoning about which optimizations we \"need\" and which ones we don't</p>\n</blockquote>\n<p>As far as I am aware, not yet.</p>",
        "id": 273304405,
        "sender_full_name": "Jubilee",
        "timestamp": 1645835770
    },
    {
        "content": "<p>And I agree that experimenting with a model is a good idea.</p>",
        "id": 273304422,
        "sender_full_name": "Jubilee",
        "timestamp": 1645835803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273303849\">said</a>:</p>\n<blockquote>\n<p>The question is <strong>not</strong> \"what does LLVM require?\" because they don't have an answer yet. Not a certain one.<br>\nIt is not \"how many optimizations are we losing?\" because LLVM hasn't audited all their opts either.<br>\nThe question is \"how much type-based and flow-based alias analysis do you want, and what are you willing to pay to get it?\"</p>\n</blockquote>\n<p>I understand the point you're making, and I do want to address the practical considerations there; I agree that \"wait and see\" is not a good plan. In the course of answering that last question, it feels like it would help to understand the tradeoffs a bit more, because that would allow for a more informed answer. If the tradeoffs really are currently \"we don't know\", that's valid, but that makes it harder to answer.</p>\n<p>In the absence of additional information, my own personal answer would be: as much optimization and analysis as we can get while not preventing people from arbitrarily treating pointer bits as numbers, storing them in integers, and doing arbitrary operations on them, as long as any pointer that actually gets dereferenced contains an address in valid memory that's compatible with the type of the pointer being dereferenced.</p>",
        "id": 273305140,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645836563
    },
    {
        "content": "<p>In the presence of some additional information, like \"here's how much additional analysis/optimization we could get if we added XYZ limitation to what you can do with pointer&lt;-&gt;integer operations\", it might be worth considering such limitations. In the <em>absence</em> of that information, I'd be inclined not to add such limitations.</p>",
        "id": 273305257,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645836657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273305140\">said</a>:</p>\n<blockquote>\n<p>In the absence of additional information, my own personal answer would be: as much optimization and analysis as we can get while not preventing people from arbitrarily treating pointer bits as numbers, storing them in integers, and doing arbitrary operations on them, as long as any pointer that actually gets dereferenced contains an address in valid memory that's compatible with the type of the pointer being dereferenced.</p>\n</blockquote>\n<p>I'm going to second this with both my \"primary maintainer of lccc\" (who happens to like pointer optimizations a lot) and \"user of rust who does pointer shenanigans\" hats on, conditioned on maintaining the limitations of pointer alias analysis provided currently by Stacked Borrows with or without pointer-&gt;int conversions (e.g. if a mutable reference is taken to some memory for which some unrelated provenance has escaped, maintaing the ability to remove that provenance from the escaped set entirely, or when some memory is deallocated it can no longer be accessed period).</p>\n<p>While I do have a desire to exploit rust's reference rules and aliasing analysis to some <em>extreme</em> extents, int-&gt;ptr casts are one of the few places that I would personally grant some dereference to users. Not to the extent that it undermines the ability to do analysis in unrelated code, though.</p>",
        "id": 273308451,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645839882
    },
    {
        "content": "<p>That's fair. To elaborate a little, my current understanding is that for the set of rules in LLVM:</p>\n<ul>\n<li>Some of these rules are optimizations that greatly benefit C code, and at most benefit Rust code a little: opt(C).</li>\n<li>Some of these rules are optimizations that greatly benefit Rust code, and at most benefit C code a little: opt(Rust).</li>\n<li>Some of these rules are optimizations that greatly benefit both C and Rust code: opt(Rust | C).</li>\n<li>Some of these rules are inherently unsound from the perspective of C: unsound(C).</li>\n<li>Some of these rules are inherently unsound from the perspective of Rust: unsound(Rust).</li>\n<li>Some of these rules are inherently unsound from the perspective of both C and Rust: unsound(C | Rust).</li>\n<li>There are also rules that are not any of the above. They may simply be opt() or unsound() or neither.</li>\n<li>If one attempted to arrange them in a logical structure, they would have a directed-graph-like shape.</li>\n<li>...not necessarily an acyclic one, though, which can itself be a source of problems.</li>\n<li>Some of the edges express an optimization dependent on another rule also being in play: opt(rule).</li>\n<li>Some of the edges express an unsoundness dependent on another rule also being in play: unsound(rule).</li>\n</ul>\n<p>I am eliding the difference between C and C++ at the moment because, well, clang is written in C++.<br>\nBut a rule can can be unsound(C) or unsound(rule) and opt(Rust).<br>\nA rule can also be unsound(Rust) or unsound(rule) and opt(C).<br>\nAnd most of the unsound(C) cases probably look more like unsound(C &amp; rule).<br>\nWe are thus not perfectly aligned with LLVM: there are things we may want to keep that may be just cost to their perspective.</p>\n<p>I am also handwaving at least some differences on an important matter: possible code versus actual code. And unfortunately, a lot of things that are <em>technically</em> sound to reason on for optimization purposes in C or C++ are functionally in the category of opt(Rust), because people do not write C code that would exploit that optimization, and may also be \"de facto, but not de jure\" unsound(C).</p>",
        "id": 273309056,
        "sender_full_name": "Jubilee",
        "timestamp": 1645840618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273308451\">said</a>:</p>\n<blockquote>\n<p>int-&gt;ptr casts are one of the few places that I would personally grant some dereference to users</p>\n</blockquote>\n<p>While I think you meant \"deference\" here, \"grant some dereference\" in the context of pointers is a hilariously punny description. :)</p>",
        "id": 273312658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645844325
    },
    {
        "content": "<p>I did not catch that typo, but that is definately funny, so I will leave it as is. I did mean deference, though, yes.</p>",
        "id": 273312963,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645844469
    },
    {
        "content": "<p>In an ideal world no optimization rule would be conditionally unsound on another optimization rule... Alas that is not the world we live in. One thing I hope we can do is to figure out whether or not proposed C provenance specs work or not for us, so we at least have something to work off of.</p>",
        "id": 273328530,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1645866013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273268348\">said</a>:</p>\n<blockquote>\n<p>How much of this is \"loss on optimization potential\", and how much of this is \"this is what LLVM does so it's not like we have a choice\"?</p>\n</blockquote>\n<p>Almost entirely the former. All these nice noalias-based optimizations we want to do with Rust's reference types crucially rely on \"synthetic provenance\" for correctness -- I don't think there is any way to make them work with \"inferred provenance\", even if we were to recreate LLVM from scratch.</p>",
        "id": 273379227,
        "sender_full_name": "RalfJ",
        "timestamp": 1645932764
    },
    {
        "content": "<blockquote>\n<p>In the absence of additional information, my own personal answer would be: as much optimization and analysis as we can get while not preventing people from arbitrarily treating pointer bits as numbers, storing them in integers, and doing arbitrary operations on them, as long as any pointer that actually gets dereferenced contains an address in valid memory that's compatible with the type of the pointer being dereferenced.</p>\n</blockquote>\n<p>Not a single compiler for C/C++ that works anything like that is in major use today, as far as I know.<br>\nSo, I would be interested in the outcome of this experiment, but I'd rather not bet the future of Rust on it. Pointers stopped being just plain numbers quite a while ago in C/C++, and the fact that many people did not realize it is what leads to fun miscompilations and self-contradicting compiler specs today. I strongly doubt Rust can turn back the wheel of time here, and I'd rather spend my effort on doing the best we can to teach people about the world these programs are actually written in, adjust docs and APIs accordingly, etc</p>",
        "id": 273379435,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933100
    },
    {
        "content": "<blockquote>\n<p>int-&gt;ptr casts are one of the few places that I would personally grant some dereference to users</p>\n</blockquote>\n<p>the thing is, that's like saying you want to have your cake and eat it, too. if you allow int-&gt;ptr casts in the strongest possible sense, then there basically is no point in having an aliasing model to begin with since the hypothetical existence of such a cast in the part of the program that you dont see (like, a different TU) kills your optimizations.</p>\n<p>when it comes to optimizations, there is no such thing as \"few places\". an optimization has to be correct <em>no matter what happens in the other TUs</em>, and so if you allow <em>just a single place anywhere in the program</em> to side-step the rules, you just have to stop optimizing entirely.</p>\n<p>for example, the mere fact that relaxed accesses exist in a language like C means that there are some optimizations on release/acquire accesses that we cannot do. those optimizations would be correct if we knew that the entire program did not use <code>Relaxed</code> anywhere at all, but when we dont see the other TUs we can't know that, and thus we have to scratch this optimization even in code that does not use <code>Relaxed</code>.</p>",
        "id": 273379569,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933325
    },
    {
        "content": "<p>I wish we had Consume/Release ordering as a real thing. Then that could be the weakest ordering.</p>",
        "id": 273379679,
        "sender_full_name": "Jubilee",
        "timestamp": 1645933512
    },
    {
        "content": "<p>this is a typical phenomenon in \"contextual reasoning\", meaning reasoning about a part of a program that is surrounded by an arbitrary unknown context -- of which optimizations are an example. if you make the context more powerful (by letting it do wild things with int-&gt;ptr casts, or by letting it do Relaxed accesses), that affects reasoning about <em>that does not even use those new features</em>, simply because the context might use them.</p>",
        "id": 273379692,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273379679\">said</a>:</p>\n<blockquote>\n<p>I wish we had Consume/Release ordering as a real thing. Then that could be the weakest ordering.</p>\n</blockquote>\n<p>consume is an ill-defined mess, so I am quite happy it didnt really catch up^^</p>",
        "id": 273379732,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933566
    },
    {
        "content": "<p>Well I wish a <strong>slightly</strong> better defined Consume/Release was a real thing.</p>",
        "id": 273379744,
        "sender_full_name": "Jubilee",
        "timestamp": 1645933596
    },
    {
        "content": "<p>there are slightly strengthened versions of Relaxed that would fix this. but the ARM model is bonkers and some relaxed accesses would need a fence on ARM to protect against the hardware's brokenness, and that's just not going to happen. :(</p>",
        "id": 273379776,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933670
    },
    {
        "content": "<p>Ehhh are you talking about the revised model?</p>",
        "id": 273379832,
        "sender_full_name": "Jubilee",
        "timestamp": 1645933732
    },
    {
        "content": "<p>hm, i thought ppc was the one with messy semantics here, not that it particuarly matters. (armv8.2 also cleaned up the semantics a great deal, which applies back to arm v8.0 since all implementations already followed the cleaned-up rules)</p>",
        "id": 273379842,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645933750
    },
    {
        "content": "<p>but anyway I wasnt going to make this a weak memory horror show, I just wanted to name this as another example for the problem with \"adding a niche feature with weird rules that only some code will use\"</p>",
        "id": 273379845,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933753
    },
    {
        "content": "<p>even if the use of that feature is localized, the effect of adding that feature to the language is not</p>",
        "id": 273379859,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933800
    },
    {
        "content": "<p>int2ptr casts are another example of that. (specifically, int2ptr casts that support roundtrips of arbitrary pointers. casting a constant 0x12300 to a pointer, if that memory is disjoint from the stack or other known-to-Rust memory, is totally fine.)</p>",
        "id": 273379936,
        "sender_full_name": "RalfJ",
        "timestamp": 1645933898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273282185\">said</a>:</p>\n<blockquote>\n<p>Also, this isn't only deisrable because C allows it. Genuinely, I think it's a lot harder to think of ways to avoid int-&gt;ptr and ptr-&gt;int casts in certain code. <a href=\"https://github.com/rust-lang/rust/pull/87869\">https://github.com/rust-lang/rust/pull/87869</a> was very hard to think of a way to avoid it. I'm not sure that in all cases its avoidable (in particular, the atomics case requires some undesirable library extensions, like allowing bitops on AtomicPtr...)</p>\n<p>Even when it is possible, in many cases it's still undesirable and leads to a larger degree of platform specific code. With integers, I can cast a <code>usize</code> to a <code>u64</code> on both 32 bit and 64 bit, and have all the code handle it there. But if I have to use <code>*const ()</code> or w/e that stores \"ptr or bits\", then I basically need to have separate codepaths for 64/32 bit in most cases (and you'll notice this happens in io::Error).</p>\n</blockquote>\n<p>I think this is mainly because the kind of operations C or Rust provide are still all based on the assumption that round-tripping a ptr value through an integer is fine. there's no reason we couldn't have a \"64bit type that can hold a pointer provenance\" and associated APIs. that type would just not be an integer type, it would act more like a <code>union</code> of a ptr type and a <code>u64</code>.</p>",
        "id": 273380112,
        "sender_full_name": "RalfJ",
        "timestamp": 1645934181
    },
    {
        "content": "<p>the same goes for atomics</p>",
        "id": 273380129,
        "sender_full_name": "RalfJ",
        "timestamp": 1645934230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273379936\">said</a>:</p>\n<blockquote>\n<p>int2ptr casts are another example of that. (specifically, int2ptr casts that support roundtrips of arbitrary pointers. casting a constant 0x12300 to a pointer, if that memory is disjoint from the stack or other known-to-Rust memory, is totally fine.)</p>\n</blockquote>\n<p>So, it's good to know that you can synthesize an arbitrary pointer to (say) hardware memory. And, for what it's worth, I think it'd be perfectly fine to say you can't out-of-thin-air a pointer to known-to-Rust memory.</p>",
        "id": 273380768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645934911
    },
    {
        "content": "<p>As long as you can, say, cast a pointer to an integer, twiddle some of its bits (e.g. xor it with something), shove it into a data structure, and later pull it out, untwiddle it, and dereference it.</p>",
        "id": 273380816,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645934954
    },
    {
        "content": "<p>Would it help to say \"you can't manufacture a pointer you didn't originally have, unless it points to entirely non-Rust memory not pointed to by other things\"?</p>",
        "id": 273380856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645935002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273380816\">said</a>:</p>\n<blockquote>\n<p>As long as you can, say, cast a pointer to an integer, twiddle some of its bits (e.g. xor it with something), shove it into a data structure, and later pull it out, untwiddle it, and dereference it.</p>\n</blockquote>\n<p>yeah thats the roundtrip I am so worried about :)</p>",
        "id": 273380874,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273379435\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>In the absence of additional information, my own personal answer would be: as much optimization and analysis as we can get while not preventing people from arbitrarily treating pointer bits as numbers, storing them in integers, and doing arbitrary operations on them, as long as any pointer that actually gets dereferenced contains an address in valid memory that's compatible with the type of the pointer being dereferenced.</p>\n</blockquote>\n<p>Not a single compiler for C/C++ that works anything like that is in major use today, as far as I know.<br>\nSo, I would be interested in the outcome of this experiment, but I'd rather not bet the future of Rust on it. Pointers stopped being just plain numbers quite a while ago in C/C++, and the fact that many people did not realize it is what leads to fun miscompilations and self-contradicting compiler specs today.</p>\n</blockquote>\n<p>To the best of my knowledge, kernel and firmware people still rely on ptr-&gt;int-&gt;ptr round trips today, and if the compiler ever miscompiles that, they apply <code>-f</code> options until it stops that. (e.g. <code>-fno-strict-aliasing</code>)</p>",
        "id": 273380881,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645935087
    },
    {
        "content": "<p>It's <em>possible</em> that what they're relying on is a subset of possible operations of that type.</p>",
        "id": 273380883,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645935113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273380856\">said</a>:</p>\n<blockquote>\n<p>Would it help to say \"you can't manufacture a pointer you didn't originally have, unless it points to entirely non-Rust memory not pointed to by other things\"?</p>\n</blockquote>\n<p>no, not really what helps is \"you can't manufacture a pointer from an int, unless it points to entirely non-Rust memory not pointed to by other things\". but if the fact that you \"had\" it makes a difference then we lost, we have to somehow reconstruct the lost information when the int is cast back to a ptr</p>",
        "id": 273380921,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935139
    },
    {
        "content": "<blockquote>\n<p>To the best of my knowledge, kernel and firmware people still rely on ptr-&gt;int-&gt;ptr round trips today, and if the compiler ever miscompiles that, they apply -f options until it stops that.</p>\n</blockquote>\n<p>I'm sure tons of code relies on them. :) and the miscompilations are probably very hard to actually hit in practice. (I was told a dev version of windows once stopped booting because of the MSVC version of this miscompilation. no idea if that's true though.)</p>",
        "id": 273380943,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935238
    },
    {
        "content": "<p>but as far as I am concerned, if an optimization is <em>known to be definitely wrong</em> in some cases, then a compiler must not do that optimization, even if this issue rarely ever occurs in practice. the only acceptable optimizations are those that are <em>always</em> correct. (of course there can be bugs in the implementation of the optimization, but that is not what we are talking about here.)<br>\nand, well, under those requirements, all major compilers are broken by int2ptr roundtrip casts in hard-to-fix ways</p>",
        "id": 273381055,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935390
    },
    {
        "content": "<p>I get that. And I don't want to retread that same line of discussion that we've poked at before.</p>",
        "id": 273381109,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645935492
    },
    {
        "content": "<p>IIRC one of the more common <code>-f</code> options is to disable the subset of pointer aliasing rules that in C enable a kind of TBAA that Rust actually does not rely on and thus allows doing anyways because of a stricter adherence to a \"memory is untyped, accesses are typed\" model.</p>",
        "id": 273381110,
        "sender_full_name": "Jubilee",
        "timestamp": 1645935494
    },
    {
        "content": "<p>maybe there's a way to fix them, but I expect it will make the memory models (in the Rust case, the aliasing requirements) a lot more complicated, and we'll still have to sacrifice some optimizations (like, we cant remove a ptr2int cast whose result is unused. we might not even be able to remove a <em>load</em> whose result is unused.)</p>",
        "id": 273381118,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273381110\">said</a>:</p>\n<blockquote>\n<p>IIRC one of the more common <code>-f</code> options is to disable the subset of pointer aliasing rules that in C enable a kind of TBAA that Rust actually does not rely on and thus allows doing anyways because of a stricter adherence to a \"memory is untyped, accesses are typed\" model.</p>\n</blockquote>\n<p>C's TBAA does not rely on ptr provenance though so I think that is unrelated.<br>\nthe better comparison with C is <code>restrict</code>. I doubt that is sued much in firmware/kernels though?</p>",
        "id": 273381130,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273381118\">said</a>:</p>\n<blockquote>\n<p>maybe there's a way to fix them, but I expect it will make the memory models (in the Rust case, the aliasing requirements) a lot more complicated, and we'll still have to sacrifice some optimizations (like, we cant remove a ptr2int cast whose result is unused. we might not even be able to remove a <em>load</em> whose result is unused.)</p>\n</blockquote>\n<p>I'll take your word for it, though it's not obvious to me why those particular optimizations couldn't be done with caution. (If you don't use the result of a cast, you can't be storing it anywhere, so you can't be planning to get it back later.)</p>",
        "id": 273381175,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645935604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273381175\">said</a>:</p>\n<blockquote>\n<p>I'll take your word for it, though it's not obvious to me why those particular optimizations couldn't be done with caution. (If you don't use the result of a cast, you can't be storing it anywhere, so you can't be planning to get it back later.)</p>\n</blockquote>\n<p>yeah I need to write the blogpost with the examples for that</p>",
        "id": 273381188,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935639
    },
    {
        "content": "<p>Yeah, I think I am thinking of <code>-fnostrict-aliasing</code>, which we just kind of shrug at by allowing pointer casts all over the place.</p>",
        "id": 273381193,
        "sender_full_name": "Jubilee",
        "timestamp": 1645935668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  for the dead cast elimination, I explain the example at <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html\">https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html</a>.<br>\nbasically, in that case you already know the outcome of the cast, so you dont need to look at it to rely on it having happened. then you chain this with some other optimizations (similar to what I did in <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a>), and <span aria-label=\"boom\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"boom\">:boom:</span></p>",
        "id": 273381194,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935668
    },
    {
        "content": "<p>( which, in spite of the name, has fairly little to do with <strong>this</strong> part of pointer aliasing discussion. )</p>",
        "id": 273381205,
        "sender_full_name": "Jubilee",
        "timestamp": 1645935706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273381205\">said</a>:</p>\n<blockquote>\n<p>( which, in spite of the name, has fairly little to do with <strong>this</strong> part of pointer aliasing discussion. )</p>\n</blockquote>\n<p>(yes exactly, that's why I said it seems mostly unrelated)</p>",
        "id": 273381249,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935748
    },
    {
        "content": "<p>it's funny because in (C|++) if you use a pointer to produce a value of a different type than the pointer you started with you might explode the world but in Rust it's just \"lol sure, fine.\"</p>",
        "id": 273381314,
        "sender_full_name": "Jubilee",
        "timestamp": 1645935894
    },
    {
        "content": "<p>yeah Rust is a lot more permissive there. which I hope means people wont have to use <code>-f</code> flags to make their code work with the Rust rules. :D<br>\nbut the aliasing rules could still be an issue here...</p>",
        "id": 273381336,
        "sender_full_name": "RalfJ",
        "timestamp": 1645935948
    },
    {
        "content": "<p>Without necessarily saying that we <em>should</em> do this: do the various problems all go away if we say \"you can store a pointer anywhere you like, and swizzle its bits, but its type has to be something equivalent to <code>void *</code>, not <code>usize</code>\"?</p>",
        "id": 273381384,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645935997
    },
    {
        "content": "<p>I think Ralf already said yes.</p>",
        "id": 273381395,
        "sender_full_name": "Jubilee",
        "timestamp": 1645936031
    },
    {
        "content": "<p>I'm trying to make sure I understand the nature of the restriction, and if it's <em>just</em> that you have to use a pointer type but you can otherwise do anything you want with the bits, or if there's something more to it.</p>",
        "id": 273381449,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645936107
    },
    {
        "content": "<p>For an old C hand, it's useful to keep in mind that when someone like Ralf (or me, tbh) talks about optimizations, we're talking about optimizations that are valid <strong>before</strong> lowering to e.g. the x86 Machine: it's possible to examine pure x86 machine code and dynamically recompile and optimize that based <strong>purely on the semantics of the x86 Machine</strong>. However, by then you've discarded a lot of higher-level data that legalizes <strong>much</strong> more aggressive optimizations.</p>",
        "id": 273381651,
        "sender_full_name": "Jubilee",
        "timestamp": 1645936279
    },
    {
        "content": "<p>Sure, I understand that. And on balance, I think I'm OK with either not doing certain types of especially aggressive optimizations, or requiring some additional options that might require whole-program analysis or similar efforts before doing them.</p>",
        "id": 273381705,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645936345
    },
    {
        "content": "<p>But if it turns out the main restriction is just \"use a pointer type\", that would be more livable than further restrictions.</p>",
        "id": 273381725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645936411
    },
    {
        "content": "<p>For instance, if using that pointer type you could still do things like serialize a pointer to bytes, send it over a connection to another thread, deserialize it, and dereference it...</p>",
        "id": 273381733,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645936438
    },
    {
        "content": "<p>Yeah, as long as you set it into a valid state before dereferencing it.</p>\n<p>Remember that the options are, per <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a>:</p>\n<blockquote>\n<p>We could say both pointers and integers have provenance, which invalidates the first optimization.<br>\n   We could say pointers have provenance but integers do not, which invalidates the second optimization.<br>\n   We could say nothing has provenance, which invalidates the third optimization.</p>\n</blockquote>\n<p>Importantly, for the 2nd option, I can imagine some possible link-time optimizations (which <strong>are</strong> basically \"whole program analysis, go!\") that <strong>might</strong> hypothetically recover the lost optimization sometimes, but it's much harder to get back, uh, something as important as \"all arithmetic optimizations whatsoever\" in LTO.</p>",
        "id": 273382045,
        "sender_full_name": "Jubilee",
        "timestamp": 1645936917
    },
    {
        "content": "<blockquote>\n<p>I'm trying to make sure I understand the nature of the restriction, and if it's just that you have to use a pointer type but you can otherwise do anything you want with the bits, or if there's something more to it.</p>\n</blockquote>\n<p>There's another way this whole situation makes sense to me, maybe Ralf can make sure this is accurate. The naive ptr-int-ptr strips provenance with the first cast, so what you get back out has none and is thus not valid for any access. It might as well be an integer. At least, that is current SB.</p>\n<p>The pattern that makes this valid as you're alluding to is casting to an integer, working out the offset you need to apply to the pointer to get the bits you want, then using <code>wrapping_offset</code> to get the pointer bit pattern you need. Then you do the reverse later on. The key is that you can cast to an int and do whatever arithmetic you want on the int, but to transform the pointer you need to use <code>wrapping_offset</code> and friends.</p>\n<p>This pattern dodges the whole issue by not needing to do a cast.</p>\n<p>As far as I can tell, most uses of int-to-ptr casts in the wild can be replaced by this pattern. The one notable exception is <code>crossbeam-epoch</code>, which embeds int-to-ptr casts in its API.</p>",
        "id": 273387756,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645945817
    },
    {
        "content": "<p>the reasoning at the time around a lack of Atomic&lt;T&gt; was partially because you can just implement it in terms of transmutes to integers of the precise sizes as well</p>",
        "id": 273390027,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645949415
    },
    {
        "content": "<p>which is already untrue if you consider padding, but stuff like AtomicU128 is... not very useful if it can't be used for pointers. Similarly, vendor intrinsics like core::arch::x86_64::cmpxchg16b</p>",
        "id": 273390046,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645949470
    },
    {
        "content": "<p>I think this is my main concern about forbidding pointer-&gt;int and replacing with just pointer ops. Often you need to do ptr-&gt;int-&gt;wider int.</p>",
        "id": 273390108,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645949539
    },
    {
        "content": "<p>In principal, this is solvable by having wider pointers (or rather wider datatypes that can contain pointers), but i'm... unsure we have the stomach for doing this.</p>",
        "id": 273390164,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645949645
    },
    {
        "content": "<p>I dunno, what do you think Ralf? Would some kind of weird AtomicPtr&lt;u128&gt; work for your purposes without exploding everything?</p>",
        "id": 273390639,
        "sender_full_name": "Jubilee",
        "timestamp": 1645950542
    },
    {
        "content": "<p>hmm, just to clarify: AtomicPtr&lt;u128&gt; would be a different thing, it's almost more <code>Atomic128&lt;T&gt;</code>  where T is somehow constrained to be 128 bits, but could hold pointers and integers and such (e.g. you could store both a ABA counter with the pointer and cas them both)</p>",
        "id": 273390895,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645950794
    },
    {
        "content": "<p>but atomics aren't the only reason to do this.</p>",
        "id": 273390898,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645950804
    },
    {
        "content": "<p>As mentioned, it can avoid a lot of code divergence between e.g. 32 and 64 bit. e.g. with integers, on 32 bit and 64 bit rather than working with <code>usize</code> you can just work with <code>u64</code> (since every 32 bit and 64 bit pointer fits in a u64).</p>",
        "id": 273390957,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645950854
    },
    {
        "content": "<p>This is useful when you always need 64 bits of data, and disambiguate pointerness in some other manner. The std::io::Error rewrite is a good example of this. It's 64 bits even on 32 bit systems, but <em>must</em> use a different implementation on them, because NonNull&lt;()&gt; isn't always enough to fit 64 bits of data.</p>",
        "id": 273391077,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645951038
    },
    {
        "content": "<p>Regarding ptr-&gt;int-&gt;ptr casts to actual rust memory, what if the ptr-&gt;int cast required (either explicitly or implicitly) a \"broadcast\" operation which marks the memory as safe to later access with a wild pointer? That seems like it would sidestep the context issues that Ralf mentions: as long as code does not use the broadcast operation, you can optimize around unknown functions which might use wild pointers because all of your local data is not broadcast.</p>",
        "id": 273391396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645951490
    },
    {
        "content": "<p>You would be blocked from optimizing away a broadcast operation even if the result is unused, but that seems like a fair price if it is a rare operation</p>",
        "id": 273391406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645951542
    },
    {
        "content": "<p>especially if it is combined with the other mechanisms mentioned here for doing operations directly on pointer types, which would mitigate the need except for the most extreme cases of swizzling or XOR'ing pointers or serializing and deserializing them</p>",
        "id": 273391472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645951650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273379569\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>int-&gt;ptr casts are one of the few places that I would personally grant some dereference to users</p>\n</blockquote>\n<p>the thing is, that's like saying you want to have your cake and eat it, too. if you allow int-&gt;ptr casts in the strongest possible sense, then there basically is no point in having an aliasing model to begin with since the hypothetical existence of such a cast in the part of the program that you dont see (like, a different TU) kills your optimizations.</p>\n</blockquote>\n<p>Only for pointers that escape to those other TUs, and only until it can be proven the pointer isn't aliased again (use of a <code>&amp;mut T</code>/<code>&amp;T</code> to access that memory or reborrowing of such, some hypothetical <code>does_not_alias</code> operation). </p>\n<blockquote>\n<p>for example, the mere fact that relaxed accesses exist in a language like C means that there are some optimizations on release/acquire accesses that we cannot do. those optimizations would be correct if we knew that the entire program did not use <code>Relaxed</code> anywhere at all, but when we dont see the other TUs we can't know that, and thus we have to scratch this optimization even in code that does not use <code>Relaxed</code>.</p>\n</blockquote>\n<p>There are also optimizations on Release/Acquire accesses that we <em>can</em> do. It's perfectly valid to merge two directly adjacent atomic operations to one memory location of <em>any</em> ordering, as long as the union of the orderings is preserved (with SeqCst locally out of the picture, there are even more ways to merge atomic accesses). This is why C++ explicitly has volatile atomic operations (and why Rust needs them as well).<br>\nHowever, even still, more aggressive forms of this may be manifestly unreasonable, as atomics are also a place that the user is owed deference.</p>",
        "id": 273401416,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645965413
    },
    {
        "content": "<blockquote>\n<p>Only for pointers that escape to those other TUs, and only until it can be proven the pointer isn't aliased again (use of a &amp;mut T/&amp;T to access that memory or reborrowing of such, some hypothetical does_not_alias operation). </p>\n</blockquote>\n<p>Int-&gt;ptr casts in the strongest possible sense allows those casts to results into pointers to anything. Whether stored on the heap, or on the stack.  Even to return addresses or spilled values on the stack. The way to avoid this is to only allow addresses of allocations previously leaked using a ptr-&gt;int cast to be turned back into a pointer.</p>",
        "id": 273401718,
        "sender_full_name": "bjorn3",
        "timestamp": 1645965892
    },
    {
        "content": "<p>I think that it is useful (and potentially necessary to avoid a big performance loss) to separate one-way ptr-&gt;int casts from \"broadcast\" casts such as I mentioned before. There are reasons you might want to convert a pointer to an integer without wanting it to be round-trippable, for example if you are hashing pointer values you don't want to mark all the pointers as accessible. There is some design work on whether broadcasting should be the default or not; my guess is that you don't want broadcasting most of the time but this might cause too much UB in real world applications.</p>",
        "id": 273404448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645969521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273401718\">said</a>:</p>\n<blockquote>\n<p>The way to avoid this is to only allow addresses of allocations previously leaked using a ptr-&gt;int cast to be turned back into a pointer.</p>\n</blockquote>\n<p>Yes, once this cast happens, the pointer is escaped, until that pointer is invalidated, that's fine. I'm not saying \"unrestricted int-&gt;ptr\". My argument is against barring int-&gt;ptr in general.</p>",
        "id": 273405527,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645970843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273381384\">said</a>:</p>\n<blockquote>\n<p>Without necessarily saying that we <em>should</em> do this: do the various problems all go away if we say \"you can store a pointer anywhere you like, and swizzle its bits, but its type has to be something equivalent to <code>void *</code>, not <code>usize</code>\"?</p>\n</blockquote>\n<p>well, yes -- with a subscript saying \"that depends on which operations are provided on that ptr type\". the reason the types make a difference is that for <em>all</em> operations on <code>void*</code> (which arent many), it is quite easy to define how the provenance of the output is computed. as long as we carefully pick the operations offered on <code>void*</code> to uphold that, then yes that works.<br>\n(the other reason the type makes a difference is that seeing <code>if x == y { ... }</code>, if these are <code>usize</code>, the compiler will happily replace <code>x</code> by <code>y</code>. it <a href=\"https://bugs.llvm.org/show_bug.cgi?id=35229\">must not</a> do that if these are pointers. so that is also something we still have to ensure for this <code>void*</code> type.)</p>",
        "id": 273415426,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273390046\">said</a>:</p>\n<blockquote>\n<p>which is already untrue if you consider padding, but stuff like AtomicU128 is... not very useful if it can't be used for pointers. Similarly, vendor intrinsics like core::arch::x86_64::cmpxchg16b</p>\n</blockquote>\n<p>I think what you are saying is that we want a type that can hold <em>arbitrary</em> data of a given size, and I fully agree. (that's also what is behind that LLVM \"byte type\" proposal.) in Rust, currently that type is <code>MaybeUninit&lt;_&gt;</code>. we \"just\" need atomics on that type. at leads for loads and stores, that works out fine.<br>\nnow, atomic comparison is a whole different thing, but that's not even about pointers... if you treat a <code>(u16, u8)</code> as a <code>AtomicU32</code> and to <code>compare_and_swap</code>, you are comparing uninit bytes. <span aria-label=\"boom\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"boom\">:boom:</span></p>",
        "id": 273415577,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273391396\">said</a>:</p>\n<blockquote>\n<p>Regarding ptr-&gt;int-&gt;ptr casts to actual rust memory, what if the ptr-&gt;int cast required (either explicitly or implicitly) a \"broadcast\" operation which marks the memory as safe to later access with a wild pointer? That seems like it would sidestep the context issues that Ralf mentions: as long as code does not use the broadcast operation, you can optimize around unknown functions which might use wild pointers because all of your local data is not broadcast.</p>\n</blockquote>\n<p>the thing is, that broadcast needs to be much more fine-grained than per-memory-location. when we are compiling a <code>fn foo(&amp;mut i32)</code>, we cannot know if that memory location was already broadcast, so we have to assume that it was. in order to get any optimization mileage out of the unique reference here, we thus <em>have to</em> make it such that even on a broadcast location, if you have a mutable reference, other code is not allowed to use a int2ptr cast to violate the aliasing rules. in other words, the memory still cannot be accessed by arbitrary wild pointers.<br>\nthat's what I meant when I said above that we need a lot of extra complication in the memory model to allow these roundtrip casts.</p>",
        "id": 273415670,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983489
    },
    {
        "content": "<blockquote>\n<p>Only for pointers that escape to those other TUs, and only until it can be proven the pointer isn't aliased again (use of a &amp;mut T/&amp;T to access that memory or reborrowing of such, some hypothetical does_not_alias operation). </p>\n</blockquote>\n<p>Yes, that is the only interesting case. <em>of course</em> there are always special cases where the compiler has extra knowledge. everything I say is about the general case, not the special case.</p>",
        "id": 273415691,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273415670\">said</a>:</p>\n<blockquote>\n<p>the thing is, that broadcast needs to be much more fine-grained than per-memory-location. when we are compiling a <code>fn foo(&amp;mut i32)</code>, we cannot know if that memory location was already broadcast, so we have to assume that it was. in order to get any optimization mileage out of the unique reference here, we thus <em>have to</em> make it such that even on a broadcast location, if you have a mutable reference, other code is not allowed to use a int2ptr cast to violate the aliasing rules. in other words, the memory still cannot be accessed by arbitrary wild pointers.</p>\n</blockquote>\n<p>Yes, I agree with that. <code>&amp;mut</code> memory should not be broadcast (unless you broadcast a pointer derived from this <code>&amp;mut</code> and not from a parent of it). Given that this is how pointer invalidation works today, I assume it is not too hard to continue enforcing this even for wild pointers</p>",
        "id": 273415783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645983644
    },
    {
        "content": "<p>well, stacked borrows basically does exactly this, right? it does it on the ref-to-raw cast but that could be adjusted: the memory is marked as being accessible by \"untagged\" pointers; that is your 'broadcast\"</p>",
        "id": 273415858,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983731
    },
    {
        "content": "<p>and that \"untagged\" broadcast is part of the borrow stack so there still are some restrictions</p>",
        "id": 273415866,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983756
    },
    {
        "content": "<p>but the thing is, that mechanism is actually broken; see the details at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a></p>",
        "id": 273415881,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983794
    },
    {
        "content": "<p>Right, this works on top of the existing SB model. I think the current implementation effectively does a broadcast on any &amp;mut-&gt;*mut</p>",
        "id": 273415884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645983801
    },
    {
        "content": "<p>and the only way I know that <em>might</em> fix this is <em>crazy</em> complicated</p>",
        "id": 273415896,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983828
    },
    {
        "content": "<p>basically there are examples where adding an extra \"broadcast\" (pointer untagging) <em>introduces UB</em></p>",
        "id": 273415964,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983883
    },
    {
        "content": "<p>and that surely should not be the case</p>",
        "id": 273415972,
        "sender_full_name": "RalfJ",
        "timestamp": 1645983897
    },
    {
        "content": "<p>I think the \"broadcast\" approach will mitigate the issues, if it is rare enough that it does not appear twice in the borrow stack</p>",
        "id": 273416067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645984003
    },
    {
        "content": "<p>I can think of 2 ways to fix that:</p>\n<ul>\n<li>do not allow ptr2intp2tr roundtrips</li>\n<li>(the \"crazy complicated\" option) essentially make the entire model speculative where on a int2ptr, when there are multiple different \"broadcast\" that this could 'match up with', we speculatively match up with <em>all of them</em> and run all those potential different states of the entire aliasing model at the same time to see if <em>any</em> of these choices could actually work</li>\n</ul>",
        "id": 273416068,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273416067\">said</a>:</p>\n<blockquote>\n<p>I think the \"broadcast\" approach will mitigate the issues, if it is rare enough that it does not appear twice in the borrow stack</p>\n</blockquote>\n<p>\"rare\" helps not at all. the fact that the unknown code in another TU <em>might</em> have done a broadcast is enough to cause this problem.</p>",
        "id": 273416083,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984041
    },
    {
        "content": "<p>also note that SB <em>is</em> using your broadcast approach, so that demonstrably is insufficient to mitigate the issue</p>",
        "id": 273416101,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984063
    },
    {
        "content": "<p>No, the problem still exists, but it might be rare enough to not cause miri performance problems and/or unintuitive UB</p>",
        "id": 273416159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645984095
    },
    {
        "content": "<p>it would help if we could say broadcasting the same location twice is UB, but... I doubt you want that :D</p>",
        "id": 273416161,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273416159\">said</a>:</p>\n<blockquote>\n<p>No, the problem still exists, but it might be rare enough to not cause miri performance problems and/or unintuitive UB</p>\n</blockquote>\n<p>it's not jut miri. the entire model is affected by this. literally every unsafe code author who wants to learn the aliasing model is affected, since we need a much more complicated model.</p>",
        "id": 273416184,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984147
    },
    {
        "content": "<p>You could also just double down on the current behavior and say that you might get UB if this situation happens so don't write code like that</p>",
        "id": 273416197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645984179
    },
    {
        "content": "<p>sure</p>",
        "id": 273416249,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984211
    },
    {
        "content": "<p>experience shows \"dont write code like that\" is not a sustainable strategy...</p>",
        "id": 273416254,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984227
    },
    {
        "content": "<p>well, if miri catches it it helps, and also if it is made rare because broadcast is a conscious operation then it also helps</p>",
        "id": 273416270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645984262
    },
    {
        "content": "<p>maybe I am overestimating the importance of this, but -- we already have a problem with people's intuition going the wrong way for issues like this. if we have a model that doesnt even satisfy some of the intuitive properties that IMO it absolutely should, then that surely wont help improve people's intuition.</p>",
        "id": 273416327,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984334
    },
    {
        "content": "<p>plus I think quirks like this will make it a lot harder to build tools that can <em>formally prove</em> that unsafe code is following the aliasing rules correctly</p>",
        "id": 273416335,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984365
    },
    {
        "content": "<p>but, I am actually quite surprised by this response (that you think having this issue could be acceptable). I thought having such a quirky model would be out of the question. could you leave a comment in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a> ?</p>",
        "id": 273416385,
        "sender_full_name": "RalfJ",
        "timestamp": 1645984443
    },
    {
        "content": "<p>The way I would teach it is, if you have a int-&gt;ptr cast to existing rust memory, then this pointer must \"pair\" with a previous broadcast(ptr-&gt;int) operation, and if there are multiple such pointers then it is unpredictable (defined but unhelpfully so) which you will get, so you should ensure that there is a unique such pointer when writing this kind of code. Similarly, when proving properties about wild pointers, I would ensure that the pointer to pair with is unique.</p>",
        "id": 273416425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645984539
    },
    {
        "content": "<p>I think we have pretty deep problems with people not understanding the rules in unsafe Rust. Sufficiently deep that I am not confident in characterizing \"don't write that pattern\" as an approach. We've been unable to teach people about uninit memory, alignment problems, and repr(Rust). Who's to say that whatever improves that also makes a complicated aliasing model workable?</p>",
        "id": 273416431,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645984555
    },
    {
        "content": "<p>I agree with Saethlin.</p>",
        "id": 273417994,
        "sender_full_name": "Jubilee",
        "timestamp": 1645986556
    },
    {
        "content": "<p>Any ptr-&gt;int-&gt;ptr models that rely on complex broadcasting logic are ultimately a foundation of sand.</p>",
        "id": 273418208,
        "sender_full_name": "Jubilee",
        "timestamp": 1645986702
    },
    {
        "content": "<p>Normally when we have <code>unsafe</code> code it relies on some property the compiler can't adequately verify, but the programmer can. The problem with this complex broadcasting logic is that it requires complex logic that requires you to bust open Agda just to get started.</p>",
        "id": 273418527,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987077
    },
    {
        "content": "<p>\"under homotopy type theory, the path from A to B is\" no.</p>",
        "id": 273418572,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987102
    },
    {
        "content": "<p>No Lament Configuration models.</p>",
        "id": 273418601,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987169
    },
    {
        "content": "<p>What this conversation has made clear to me is that what people want, functionally, is for their pointers to be treated as a <strong>union</strong> with integers, exposing the integer-like operations they need and allowing them to store pointer data where it needs to go, while still having <strong>normal integers</strong>. And we can do THAT very easily.</p>",
        "id": 273418724,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987326
    },
    {
        "content": "<p>To be clear, I'm not endorsing use of ptr-&gt;int-&gt;ptr at all. I think we should do everything we can to let people avoid using it at all. But for the cases where there is no other option, after you have entered the danger zone, it should be <em>possible</em> to write literal provenance-erasing pointer roundtrips, even if you need to break out Agda to make sure you did it right.</p>",
        "id": 273418754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645987422
    },
    {
        "content": "<p>That is, I am not sure that the union of all proposed alternatives actually covers all the use cases of ptr-&gt;int-&gt;ptr in the wild</p>",
        "id": 273418807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645987485
    },
    {
        "content": "<p>Neither does C.</p>",
        "id": 273418820,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987513
    },
    {
        "content": "<p>And that's the problem:<br>\nThe language under which all those things are valid in is neither Rust, nor C, but some boutique special cocktail whipped up by using gcc with all its compiler extensions (and also miscompilations) and gratuitous use of compiler flags to customize its behavior further. There is no standard and no proof it is viable. The only language it might make sense in is in the language of x86 Assembly.</p>",
        "id": 273418894,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987627
    },
    {
        "content": "<p>And to that my response is, thus:<br>\nWe do offer inline assembly.</p>",
        "id": 273418899,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987646
    },
    {
        "content": "<p>I don't believe that we should necessarily even use \"the kernel needs it\" as an excuse, because the Linux kernel is also in an adversarial relationship with gcc: it regularly rewrites its code to avoid miscompilations, using patterns it might never adopt otherwise.</p>",
        "id": 273418961,
        "sender_full_name": "Jubilee",
        "timestamp": 1645987735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273418899\">said</a>:</p>\n<blockquote>\n<p>And to that my response is, thus:<br>\nWe do offer inline assembly.</p>\n</blockquote>\n<p>This seems to just shift the issues around, though. Specifying inline assembly is just as hard if not harder than all this wild pointer stuff</p>",
        "id": 273419208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645988118
    },
    {
        "content": "<p>I disagree.<br>\nThe x86 Machine is actually much better behaved than Standard C, and much MUCH better behaved than the GNU Extended Compiler Flag Language.</p>",
        "id": 273419266,
        "sender_full_name": "Jubilee",
        "timestamp": 1645988188
    },
    {
        "content": "<p>I mean <em>inline</em> assembly, i.e. Rust and x86 coexisting, passing values back and forth</p>",
        "id": 273419278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645988226
    },
    {
        "content": "<p>for sure, if it was just x86 I would agree with you, but this is x86 + pointer provenance, and I don't know what that is</p>",
        "id": 273419282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645988258
    },
    {
        "content": "<p>The way our abstraction works happens to work pretty well in insulating Rust code from the madness of the machine by making most behaviors of the interface have to be programmatically specified by the Rust programmer.</p>",
        "id": 273419325,
        "sender_full_name": "Jubilee",
        "timestamp": 1645988298
    },
    {
        "content": "<p>can you use inline assembly to do a ptr-&gt;int-&gt;ptr cast?</p>",
        "id": 273419330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645988325
    },
    {
        "content": "<p>I believe the answer is no, because the concept of a pointer is in fact meaningless to the x86 Machine.</p>",
        "id": 273419343,
        "sender_full_name": "Jubilee",
        "timestamp": 1645988351
    },
    {
        "content": "<p>But neither is the inline assembler allowed to optimize out arithmetic operations.</p>",
        "id": 273419353,
        "sender_full_name": "Jubilee",
        "timestamp": 1645988371
    },
    {
        "content": "<p>can <code>in(reg)</code> args be of <code>*const T</code> type?</p>",
        "id": 273419355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645988372
    },
    {
        "content": "<p>I believe the answer is yes, but only if <code>*const T</code> is thin.</p>",
        "id": 273419622,
        "sender_full_name": "Jubilee",
        "timestamp": 1645988512
    },
    {
        "content": "<p>So this is defined behavior? Because if so I don't see how we've gained anything</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"mov {}, {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"mov {}, {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273419869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645988813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273418724\">said</a>:</p>\n<blockquote>\n<p>What this conversation has made clear to me is that what people want, functionally, is for their pointers to be treated as a <strong>union</strong> with integers, exposing the integer-like operations they need and allowing them to store pointer data where it needs to go, while still having <strong>normal integers</strong>. And we can do THAT very easily.</p>\n</blockquote>\n<p>Yeah, hard agree with this. The lesson that I'm learning form this conversation is that int-&gt;ptr needs to be a compile time error when possible (and produce an illegal to dereference pointer when not, with a special intrinsic for hardware memory). We can then solve most of the use cases of ptr-&gt;int-&gt;ptr by just giving pointer types all the arithmetic operations people want</p>",
        "id": 273419959,
        "sender_full_name": "Jake",
        "timestamp": 1645988950
    },
    {
        "content": "<p>Such pointers are already illegal to dereference under SB, but per Ralf the raw pointer tagging that detects this is disabled by default in Miri to permit such code, because too many things break.</p>\n<p>I agree on that last point, but I want to point out that this is not because int-ptr casts are particularly widespread, it's because a handful of extremely core ecosystem crates do them.</p>\n<p>Overall, I think this becomes an unfortunately political situation where we need to convince people to use the <code>wrapping_offset</code> pattern, and I'm not entirely sure how successful we would be.</p>",
        "id": 273420273,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645989416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273419869\">said</a>:</p>\n<blockquote>\n<p>So this is defined behavior? Because if so I don't see how we've gained anything</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"mov {}, {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"mov {}, {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>When you compile this code, it generates an annotation denoting every inline assembly block, which is preserved all the way to the emitted assembly. Functionally, this is identical to giving the values touched thereby an additional bit that only the compiler can see, because it does what that might imply... it prevents dead operation eliminations. Here is the same with dead store elimination (written using \"pure Rust\", though likely the kind that would make Miri at least somewhat concerned):</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"w\">    </span><span class=\"nf\">subq</span><span class=\"w\">    </span><span class=\"no\">$72</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">%rsp</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">movl</span><span class=\"w\">    </span><span class=\"no\">$1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">(</span><span class=\"nv\">%rsp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">leaq</span><span class=\"w\">    </span><span class=\"mi\">4</span><span class=\"p\">(</span><span class=\"nv\">%rsp</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nv\">%rax</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">movq</span><span class=\"w\">    </span><span class=\"nv\">%rax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">(</span><span class=\"nv\">%rsp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">movq</span><span class=\"w\">    </span><span class=\"no\">core</span><span class=\"p\">::</span><span class=\"no\">fmt</span><span class=\"p\">::</span><span class=\"no\">num</span><span class=\"p\">::</span><span class=\"no\">imp</span><span class=\"p\">::</span><span class=\"err\">&lt;</span><span class=\"no\">impl</span><span class=\"w\"> </span><span class=\"no\">core</span><span class=\"p\">::</span><span class=\"no\">fmt</span><span class=\"p\">::</span><span class=\"no\">Display</span><span class=\"w\"> </span><span class=\"no\">for</span><span class=\"w\"> </span><span class=\"no\">i32</span><span class=\"err\">&gt;</span><span class=\"p\">::</span><span class=\"no\">fmt@GOTPCREL</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nv\">%rax</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So the inline-assembly-using block generates this instead:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"w\">    </span><span class=\"nf\">subq</span><span class=\"w\">    </span><span class=\"no\">$72</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">%rsp</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">movl</span><span class=\"w\">    </span><span class=\"no\">$0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">(</span><span class=\"nv\">%rsp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">leaq</span><span class=\"w\">    </span><span class=\"mi\">4</span><span class=\"p\">(</span><span class=\"nv\">%rsp</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nv\">%rax</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">#APP</span>\n<span class=\"w\">    </span><span class=\"nf\">movq</span><span class=\"w\">    </span><span class=\"nv\">%rax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">%rcx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">#NO_APP</span>\n<span class=\"w\">    </span><span class=\"c1\">#APP</span>\n<span class=\"w\">    </span><span class=\"nf\">movq</span><span class=\"w\">    </span><span class=\"nv\">%rcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">%rdx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">#NO_APP</span>\n<span class=\"w\">    </span><span class=\"nf\">movl</span><span class=\"w\">    </span><span class=\"no\">$1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">%rdx</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">movq</span><span class=\"w\">    </span><span class=\"nv\">%rax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">(</span><span class=\"nv\">%rsp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">movq</span><span class=\"w\">    </span><span class=\"no\">core</span><span class=\"p\">::</span><span class=\"no\">fmt</span><span class=\"p\">::</span><span class=\"no\">num</span><span class=\"p\">::</span><span class=\"no\">imp</span><span class=\"p\">::</span><span class=\"err\">&lt;</span><span class=\"no\">impl</span><span class=\"w\"> </span><span class=\"no\">core</span><span class=\"p\">::</span><span class=\"no\">fmt</span><span class=\"p\">::</span><span class=\"no\">Display</span><span class=\"w\"> </span><span class=\"no\">for</span><span class=\"w\"> </span><span class=\"no\">i32</span><span class=\"err\">&gt;</span><span class=\"p\">::</span><span class=\"no\">fmt@GOTPCREL</span><span class=\"p\">(</span><span class=\"nv\">%rip</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nv\">%rax</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which is to say, we have gained the value that when you tell the machine to do <strong>exactly what you are saying</strong> that it <strong>does exactly what you are saying</strong>.</p>",
        "id": 273420998,
        "sender_full_name": "Jubilee",
        "timestamp": 1645990319
    },
    {
        "content": "<p>But I do not know if that is or should be defined behavior.</p>",
        "id": 273421076,
        "sender_full_name": "Jubilee",
        "timestamp": 1645990400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273420273\">said</a>:</p>\n<blockquote>\n<p>Such pointers are already illegal to dereference under SB, but per Ralf the raw pointer tagging that detects this is disabled by default in Miri to permit such code, because too many things break.</p>\n<p>I agree on that last point, but I want to point out that this is not because int-ptr casts are particularly widespread, it's because a handful of extremely core ecosystem crates do them.</p>\n<p>Overall, I think this becomes an unfortunately political situation where we need to convince people to use the <code>wrapping_offset</code> pattern, and I'm not entirely sure how successful we would be.</p>\n</blockquote>\n<p>I don't think the <code>wrapping_offset</code> pattern in particular is what we need, I think we just need to give pointer types the necessary operations natively. We can then convince people to do the right thing by just pointing out that their code will keep compiling (and be DB!) if they literally just remove the <code>as usize</code> and <code>as *const _</code> casts. This probably means implementations of <code>Add</code>, <code>Mod</code>, etc. for pointer types, which might be slightly footgunny, but if that is the price we need to pay to get a somewhat manageable memory model, I'm all for it</p>",
        "id": 273421596,
        "sender_full_name": "Jake",
        "timestamp": 1645991177
    },
    {
        "content": "<p>Eg, for pointer tagging, right now people are doing</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_bits</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">^</span><span class=\"w\"> </span><span class=\"mh\">0x7</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// zero last three bits</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">new_bits</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I am suggesting that we make <code>let ptr = ptr &amp; (-1 ^ 0x7);</code> compile</p>",
        "id": 273421685,
        "sender_full_name": "Jake",
        "timestamp": 1645991303
    },
    {
        "content": "<p>I have always thought it was a bit silly that when you want to add to a pointer</p>\n<ol>\n<li><code>ptr + 1</code> does not work</li>\n<li>you find <code>.add</code> it has a bunch of random safety invariants :(</li>\n</ol>\n<p>I don't find it particularly surprising that people jump to <code>as usize + 1 as *mut T</code> or w/e lol</p>",
        "id": 273421707,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1645991398
    },
    {
        "content": "<p>shouldn't that be 0x7 if it's 0b111</p>",
        "id": 273421768,
        "sender_full_name": "Jubilee",
        "timestamp": 1645991439
    },
    {
        "content": "<p>hello I have been doing way too much bitwhacking</p>",
        "id": 273421792,
        "sender_full_name": "Jubilee",
        "timestamp": 1645991489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273421768\">said</a>:</p>\n<blockquote>\n<p>shouldn't that be 0x7 if it's 0b111</p>\n</blockquote>\n<p>shh, never happened <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 273421803,
        "sender_full_name": "Jake",
        "timestamp": 1645991508
    },
    {
        "content": "<p>And we can make this all work out nicely because we make sure that binary operations either yield an integer, or take one (not two) pointer arguments, so the provenance of the output pointer is unambiguous</p>",
        "id": 273421856,
        "sender_full_name": "Jake",
        "timestamp": 1645991562
    },
    {
        "content": "<p>if <code>ptr + 1</code> returns an integer you've not really accomplished your goal have you?</p>",
        "id": 273421877,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1645991622
    },
    {
        "content": "<p>it's <code>unsafe fn add</code> because it's \"GEP inbounds\"</p>",
        "id": 273421920,
        "sender_full_name": "Jubilee",
        "timestamp": 1645991659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273421877\">said</a>:</p>\n<blockquote>\n<p>if <code>ptr + 1</code> returns an integer you've not really accomplished your goal have you?</p>\n</blockquote>\n<p><code>ptr + 1</code> would return a pointer, because its <code>ptr + usize</code>. <code>ptr + ptr</code> would yield an integer (although probably we don't want that impl at all)</p>",
        "id": 273421922,
        "sender_full_name": "Jake",
        "timestamp": 1645991666
    },
    {
        "content": "<p>Ah, sorry, forgot to mention again how this will <em>not</em> work for <code>crossbeam-epoch</code>. At some point I need to figure out why they're even doing what they're doing.</p>",
        "id": 273421926,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1645991683
    },
    {
        "content": "<p>Would <code>+</code> and <code>-</code> on pointers do pointer or integer arithmetic? Pointer arithmetic can't represent everything while integer arithmetic would be confusing to C users.</p>",
        "id": 273421929,
        "sender_full_name": "bjorn3",
        "timestamp": 1645991685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273421929\">said</a>:</p>\n<blockquote>\n<p>Would <code>+</code> and <code>-</code> on pointers do pointer or integer arithmetic? Pointer arithmetic can't represent everything while integer arithmetic would be confusing to C users.</p>\n</blockquote>\n<p><code>+</code> or <code>-</code> does \"integer arithmetic\" in that it modifies the bits as if they were integers, while retaining the provenance from the input pointer if the output value is a pointer</p>",
        "id": 273422018,
        "sender_full_name": "Jake",
        "timestamp": 1645991857
    },
    {
        "content": "<p>That would make a naive port from C to rust misbehave as in C they use pointer arithmetic. (pointer arithmetic multiplies the offset by the element size, so adding 2 to an *const i32 will offset by 8 bytes as 2 * 4 = 8)</p>",
        "id": 273422084,
        "sender_full_name": "bjorn3",
        "timestamp": 1645991966
    },
    {
        "content": "<p>I think</p>",
        "id": 273422089,
        "sender_full_name": "Jubilee",
        "timestamp": 1645991986
    },
    {
        "content": "<p>we need a new type.</p>",
        "id": 273422091,
        "sender_full_name": "Jubilee",
        "timestamp": 1645991991
    },
    {
        "content": "<p>We designed our pointer types to work a certain way, and we designed our integer types to work a certain way, and if we want to cover the \"pointer that behaves like an integer\" usecase, that means a new interface that becomes \"what you write instead of <code>as usize</code>\".</p>",
        "id": 273422428,
        "sender_full_name": "Jubilee",
        "timestamp": 1645992239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273422091\">said</a>:</p>\n<blockquote>\n<p>we need a new type.</p>\n</blockquote>\n<p>There was some discussion of needing a new integer type to account for platforms such as CHERI, where pointer size and size_t differ.<br>\nSo maybe this could be a new \"uptr\". It would still count as a pointer type for provenance, but supply more arithmetic operations.</p>",
        "id": 273425689,
        "sender_full_name": "Herr Jemine",
        "timestamp": 1645996734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273416068\">said</a>:</p>\n<blockquote>\n<p>I can think of 2 ways to fix that:</p>\n<ul>\n<li>do not allow ptr2intp2tr roundtrips</li>\n<li>(the \"crazy complicated\" option) essentially make the entire model speculative where on a int2ptr, when there are multiple different \"broadcast\" that this could 'match up with', we speculatively match up with <em>all of them</em> and run all those potential different states of the entire aliasing model at the same time to see if <em>any</em> of these choices could actually work</li>\n</ul>\n</blockquote>\n<p>Way 1 is a non-starter, for reasons discussed in this thread.<br>\nWay 2 is like what I want to do, in that it attaches the \"union provenance\" that was the origin of this thread to the pointer, until one true provenance can be refined.  This union provenance would trivially include the null provenance (which is not a null pointer, but what I've taken to calling the provenance of <code>1 as *const u8</code>) until the allocation size is required to be at least 1 (which null provenance doesn't satisfy), which would fix 273.</p>",
        "id": 273425955,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645997071
    },
    {
        "content": "<p>Way 2 could actually be implemented in miri using a stronger form of  the analysis reduction - because miri can see every operation.</p>",
        "id": 273426120,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645997284
    },
    {
        "content": "<p>What reasons, Connor?</p>",
        "id": 273426767,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998112
    },
    {
        "content": "<p>The \"reasons discussed in this thread\" make it abundantly clear to me that it is in fact Way 2 that is the non-starter, because it is just an attempt to backdoor in another unsound framework that eventually will, under sufficient pressure, collapse by doing exactly what is not allowed: validating both integer and pointer optimizations at the same time.</p>",
        "id": 273426831,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273379435\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>In the absence of additional information, my own personal answer would be: as much optimization and analysis as we can get while not preventing people from arbitrarily treating pointer bits as numbers, storing them in integers, and doing arbitrary operations on them, as long as any pointer that actually gets dereferenced contains an address in valid memory that's compatible with the type of the pointer being dereferenced.</p>\n</blockquote>\n<p>Not a single compiler for C/C++ that works anything like that is in major use today, as far as I know.<br>\nSo, I would be interested in the outcome of this experiment, but I'd rather not bet the future of Rust on it. Pointers stopped being just plain numbers quite a while ago in C/C++, and the fact that many people did not realize it is what leads to fun miscompilations and self-contradicting compiler specs today. I strongly doubt Rust can turn back the wheel of time here, and I'd rather spend my effort on doing the best we can to teach people about the world these programs are actually written in, adjust docs and APIs accordingly, etc</p>\n</blockquote>\n<p>to point back to those reasons.</p>",
        "id": 273427064,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273426767\">said</a>:</p>\n<blockquote>\n<p>What reasons, Connor?</p>\n</blockquote>\n<p>ptr-&gt;int-&gt;ptr is a highly common operation in some code, especially in dynamic language interpreter using bit layouts of pointers, adding a tag, to store different kinds of values.</p>",
        "id": 273427070,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645998549
    },
    {
        "content": "<p>That doesn't actually matter.</p>",
        "id": 273427080,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273422084\">said</a>:</p>\n<blockquote>\n<p>That would make a naive port from C to rust misbehave as in C they use pointer arithmetic. (pointer arithmetic multiplies the offset by the element size, so adding 2 to an *const i32 will offset by 8 bytes as 2 * 4 = 8)</p>\n</blockquote>\n<p>So, to be honest, \"naive port from C does the same thing in Rust\" is not really one of the design goals I care about. That being said, this might indeed be excessively footgunny anyway. We could have it do pointer arithmetic if we come up with some reasonable behavior in the case of non-integer results (possibly just truncating in release, panic in debug?).</p>\n<p>Regardless though, the particular interface is not really my point. My point was that we can get people to stop doing ptr -&gt; int casts by giving them a nice to use interface to do the things they want to do on pointers directly. We could discuss this with T-libs as well - if a new type turns out to be the right answer (as it well might), that is a possibility. Generally though, my point is that ptr-&gt;int-&gt;ptr roundtrips aren't a good solution for the problems they're used for right now anyway (I'd love to see exceptions though). We can get people to stop doing pointer to int casts by giving them a better solution for their problem</p>",
        "id": 273427083,
        "sender_full_name": "Jake",
        "timestamp": 1645998579
    },
    {
        "content": "<p>As we have already discussed, it is possible to allow modifying a pointer's bits without allowing casting it to an integer.</p>",
        "id": 273427131,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998615
    },
    {
        "content": "<p>What you are asking for is something that can already be made possible without requiring a Byzantine model to accommodate it.</p>",
        "id": 273427154,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998687
    },
    {
        "content": "<p>Making the model for all future optimizations more complex in order to save a few crates is a bad trade.</p>",
        "id": 273427235,
        "sender_full_name": "Jubilee",
        "timestamp": 1645998804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273427235\">said</a>:</p>\n<blockquote>\n<p>Making the model for all future optimizations more complex in order to save a few crates is a bad trade.</p>\n</blockquote>\n<p>I mean, its not just complexity of optimizations that's a concern, but complexity of all the other crates that have to interact with the memory model</p>",
        "id": 273427296,
        "sender_full_name": "Jake",
        "timestamp": 1645998872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273427131\">said</a>:</p>\n<blockquote>\n<p>As we have already discussed, it is possible to allow modifying a pointer's bits without allowing casting it to an integer and back.</p>\n</blockquote>\n<p>I think it's moot, since a lot of code exists already that depends on doing this. I think it would be a huge non-starter to break that code.</p>",
        "id": 273427873,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645999528
    },
    {
        "content": "<blockquote>\n<p>That would make a naive port from C to rust misbehave as in C they use pointer arithmetic. (pointer arithmetic multiplies the offset by the element size, so adding 2 to an *const i32 will offset by 8 bytes as 2 * 4 = 8)</p>\n</blockquote>\n<p>So, I'm not sure how worried about this we should be -- it's not the sort of thing that will seem to work until optimizations are enabled (or written), it will either work or not, and it seems likely to fail horribly in the case it doesn't work. That said, I agree with the other comments that perhaps on its own this is too error prone.</p>",
        "id": 273427962,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645999629
    },
    {
        "content": "<p>Code that depends on non-elaborated parts of the Rust model is in fact subject to breakage. <strong>Not</strong> breaking it is essentially sticking us with having a model that will take another 50 years to fully work out, just like it has taken C that long to even get here, and thus making sure that such code can be broken at any time without violating the Rust stability promises.</p>",
        "id": 273428323,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000201
    },
    {
        "content": "<p>If this pointer-integer union type is added, I think it should probably not have a <code>T</code> type (i.e. it's just a <code>void*</code>-like type with arithmetic), in which case the arithmetic will not have to worry about multiplying by <code>sizeof(T)</code></p>",
        "id": 273428340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646000256
    },
    {
        "content": "<p>Agreed. It might be generic over <code>*const T</code> or <code>*mut T</code> if absolutely necessary, but it would be an ignored parameter.</p>",
        "id": 273428399,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000318
    },
    {
        "content": "<p>it's \"just\" a very suspicious integer.</p>",
        "id": 273428410,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000344
    },
    {
        "content": "<p>How are the operations actually supposed to work though? Like Ralf said, the reason pointers are different is because they have very restrictive operations that makes tracking pointer provenance feasible. If you start XORing <code>uptr</code>s then what provenance do you get?</p>",
        "id": 273428596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646000645
    },
    {
        "content": "<p>That is a very good question.</p>",
        "id": 273428601,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273428596\">said</a>:</p>\n<blockquote>\n<p>How are the operations actually supposed to work though? Like Ralf said, the reason pointers are different is because they have very restrictive operations that makes tracking pointer provenance feasible. If you start XORing <code>uptr</code>s then what provenance do you get?</p>\n</blockquote>\n<p>The idea is that you can't xor <code>uptr</code>s. You can xor a <code>uptr</code> with a <code>usize</code>, but in that case the provenance is clear. But for stuff like pointer tagging, this is even what we want: <code>ptr &amp; (-1 ^ 0x7)</code> is much more clear and intuitive than <code>ptr &amp; ((-1 ^ 0x7) as uptr)</code></p>",
        "id": 273428686,
        "sender_full_name": "Jake",
        "timestamp": 1646000802
    },
    {
        "content": "<p>I think our (<code>u</code>)<code>intptr</code> type would have to, as Jake said, implement binops only with {<code>u</code>, <code>i</code>}<code>size</code> and possibly {<code>u</code>, <code>i</code>}<code>addr</code> (if that happens also), yeah.</p>",
        "id": 273428689,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000807
    },
    {
        "content": "<p>And if you <em>really</em> need to do a binop on two uptrs, you can choose which provenance you get by casting the other one to a <code>usize</code> first</p>",
        "id": 273428703,
        "sender_full_name": "Jake",
        "timestamp": 1646000844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jake</span> I bring up XOR because that's actually a technique used in the wild: it is a trick for storing doubly linked lists with only one usize of metadata per node</p>",
        "id": 273428711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646000879
    },
    {
        "content": "<p>god that's so bad though.</p>",
        "id": 273428749,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000891
    },
    {
        "content": "<p>like yes people use it but it's like \"ha ha look at my funny thing.\"</p>",
        "id": 273428756,
        "sender_full_name": "Jubilee",
        "timestamp": 1646000908
    },
    {
        "content": "<p>waaaaay more common is intptr - intptr.</p>",
        "id": 273428824,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001005
    },
    {
        "content": "<p>you can use <code>ptr::sub</code> for that, right?</p>",
        "id": 273428940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646001042
    },
    {
        "content": "<p>yeah if you get a usize</p>",
        "id": 273428945,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001063
    },
    {
        "content": "<p>you want <code>intptr - intptr = intptr</code>?</p>",
        "id": 273428951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646001079
    },
    {
        "content": "<p>probably not lol.</p>",
        "id": 273428957,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273428940\">said</a>:</p>\n<blockquote>\n<p>you can use <code>ptr::sub</code> for that, right?</p>\n</blockquote>\n<p>No, <code>ptr::sub</code> is <code>ptr - usize -&gt; usize</code></p>",
        "id": 273428958,
        "sender_full_name": "Jake",
        "timestamp": 1646001088
    },
    {
        "content": "<p>oh, isn't there a <code>ptr - ptr = usize</code> operation? <code>offset</code>?</p>",
        "id": 273428965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646001119
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.offset_from\">https://doc.rust-lang.org/std/primitive.pointer.html#method.offset_from</a></p>",
        "id": 273429006,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001143
    },
    {
        "content": "<p>it generates an isize</p>",
        "id": 273429009,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001151
    },
    {
        "content": "<p>which I think is the correct model: for any \"three-address code\" operation, you have two pointers and one integer.</p>",
        "id": 273429058,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001243
    },
    {
        "content": "<p>binop on two pointers, you store an integer.<br>\nbinop on a pointer and integer, you store a pointer</p>",
        "id": 273429079,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001272
    },
    {
        "content": "<p>two integers? integer.</p>",
        "id": 273429083,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001284
    },
    {
        "content": "<p>are the two pointers required to live in the same allocation, or is it a safe operation</p>",
        "id": 273429089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646001294
    },
    {
        "content": "<p>in your perfect world</p>",
        "id": 273429095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646001304
    },
    {
        "content": "<p>LLVM allows us to make it a safe operation.</p>",
        "id": 273429103,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001318
    },
    {
        "content": "<p>We just didn't.</p>",
        "id": 273429104,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273429089\">said</a>:</p>\n<blockquote>\n<p>are the two pointers required to live in the same allocation, or is it a safe operation</p>\n</blockquote>\n<p>The easy to use version of this (ie the trait impls) should be safe. We may additionally offer unsafe versions, but I'm not so sure it'll even be necessary</p>",
        "id": 273429115,
        "sender_full_name": "Jake",
        "timestamp": 1646001347
    },
    {
        "content": "<p>Because LLVM allows more aggressive optimizations if you don't, so this would be more like<br>\n<a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add\">https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add</a></p>",
        "id": 273429124,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001354
    },
    {
        "content": "<p>it's weird that there is no <code>wrapping_offset_from</code></p>",
        "id": 273429166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646001373
    },
    {
        "content": "<p>I am honestly not sure why.</p>",
        "id": 273429185,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001443
    },
    {
        "content": "<p>nonetheless, afaik any LLVM model under consideration is mostly okay with you doing totally wacky shit with the pointer, as long as you put it back somewhere sensible before dereferencing it, and you don't use the \"this is UB if you do totally wacky shit with it\" ops.</p>",
        "id": 273429228,
        "sender_full_name": "Jubilee",
        "timestamp": 1646001490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I don't think \"A lot of code exists already depends on doing this\" is a good argument. Most of the web ecosystem depends on <code>mem:: uninitialized</code>, and a lot of SIMD code depends on invalid use of <code>assume_init</code>. Plenty of code depends on doing mutation through a pointer derived from a &amp;T where T is not an UnsafeCell.</p>",
        "id": 273434929,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646009248
    },
    {
        "content": "<p>Fair enough. I would call this closer to well-defined, uninit memory is a thing that exists, and it's well-specified that you can't mutate memory aliased by a <code>&amp;T</code> that isn't <code>&amp;UnsafeCell&lt;U&gt;</code>.</p>",
        "id": 273435618,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646010020
    },
    {
        "content": "<p>It could be worse.<br>\nWe could be Pascal and have pointers only to dynamic variables.</p>",
        "id": 273435738,
        "sender_full_name": "Jubilee",
        "timestamp": 1646010189
    },
    {
        "content": "<p>I just think that we have a lot of code which is UB or needs to be patched already. And if we're going to rule out more code that already exists, we need to be able to articulate to maintainers why they need to change their code. That is my biggest concern. I think there's only so far we can get with \"you can't do that, it's UB\".</p>\n<p>Btw you can add assuming repr(Rust) is stable to the list above if you want. We tell people it isn't but it definitely is in practice, especially for some types. I think that is not too different from a miscompilation that's hard to hit.</p>",
        "id": 273439009,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646014677
    },
    {
        "content": "<p>Well, with <code>repr(Rust)</code>, we've got <code>-Z randomize-layout</code>, and in the future, other implementations with their own layout optimizations (or lack thereof, in my case), so I think it's at least possible to easily test as it is (Although, heh).</p>",
        "id": 273442472,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646019085
    },
    {
        "content": "<p>-Zrandomize-layout is kinda useless IME</p>",
        "id": 273445676,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646023409
    },
    {
        "content": "<p>I have not seen it detect a single bug in the wild</p>",
        "id": 273445731,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646023444
    },
    {
        "content": "<p>I agree that it should help in theory. Fixing it is a good topic for another thread or whatever these are called</p>",
        "id": 273445748,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646023483
    },
    {
        "content": "<p>-Zrandomize-layout doesnt cover everything yet. There are a lot of cases where people still can rely on non-guaranteed properties and have it not catch it</p>",
        "id": 273448106,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646026743
    },
    {
        "content": "<p>For example, c-style enum layout is a common thing I see people rely on (<a href=\"https://github.com/alacritty/vte/pull/74\">https://github.com/alacritty/vte/pull/74</a>), and it's not something caught by the layouit randomization.</p>",
        "id": 273448212,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646026906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273429166\">said</a>:</p>\n<blockquote>\n<p>it's weird that there is no <code>wrapping_offset_from</code></p>\n</blockquote>\n<p>it existed, but then people were like \"why not just cast to ints and subtract those\"...^^</p>",
        "id": 273738368,
        "sender_full_name": "RalfJ",
        "timestamp": 1646183808
    },
    {
        "content": "<p>WHY NOT INDEED</p>",
        "id": 273738397,
        "sender_full_name": "Jubilee",
        "timestamp": 1646183842
    },
    {
        "content": "<p>but also see <a href=\"https://github.com/rust-lang/rust/issues/92512\">https://github.com/rust-lang/rust/issues/92512</a>, I dont think our current offset_from is quite what we want (but the fully safe version isnt, either)</p>",
        "id": 273738402,
        "sender_full_name": "RalfJ",
        "timestamp": 1646183847
    },
    {
        "content": "<p>the reason the unsafe version exists is mostly that the \"subtract ints\" alternative doesnt work in CTFE</p>",
        "id": 273738423,
        "sender_full_name": "RalfJ",
        "timestamp": 1646183868
    },
    {
        "content": "<p>so \"LLVM says we could make it safe but we just didnt\" isnt quite true -- to have an operation that can actually be <em>implemented</em> in CTFE, we need the restriction of both ptrs being in the same allocation, which means we need to make it unsafe</p>",
        "id": 273738525,
        "sender_full_name": "RalfJ",
        "timestamp": 1646183947
    },
    {
        "content": "<p>also there are proposals to add a <code>ptrsub</code> operation to LLVM with pretty much those restrictions, preicsely because it avoids leaking any information about allocation base addresses (and that is potentially useful for analyses)</p>",
        "id": 273738580,
        "sender_full_name": "RalfJ",
        "timestamp": 1646183996
    },
    {
        "content": "<p>if we want to use that in the future when/if it is added (which IMO we should), then again unsafe is needed</p>",
        "id": 273738646,
        "sender_full_name": "RalfJ",
        "timestamp": 1646184028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273738525\">said</a>:</p>\n<blockquote>\n<p>so \"LLVM says we could make it safe but we just didnt\" isnt quite true -- to have an operation that can actually be <em>implemented</em> in CTFE, we need the restriction of both ptrs being in the same allocation, which means we need to make it unsafe</p>\n</blockquote>\n<p>Ahhh fair enough then.</p>",
        "id": 273738665,
        "sender_full_name": "Jubilee",
        "timestamp": 1646184049
    },
    {
        "content": "<p>I actually have this operation in lccc's xir: an alternative form of <code>sub</code> for pointers, is defined exactly like pointer subtraction is in C/++, and thus <code>.offset_from</code>.</p>",
        "id": 273738754,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273738754\">said</a>:</p>\n<blockquote>\n<p>I actually have this operation in lccc's xir: an alternative form of <code>sub</code> for pointers, is defined exactly like pointer subtraction is in C/++, and thus <code>.offset_from</code>.</p>\n</blockquote>\n<p>makes sense -- except I think it can be slightly more permissive, as in <a href=\"https://github.com/rust-lang/rust/issues/92512\">https://github.com/rust-lang/rust/issues/92512</a>. (the proposal LLVM ptrsub is like that.)<br>\nthis still allows the same key analyses re: not leaking the allocation base address.<br>\nin C/C++ the distinction between the two doesnt matter since it is UB to even create such OOB pointers.</p>",
        "id": 273739717,
        "sender_full_name": "RalfJ",
        "timestamp": 1646184727
    },
    {
        "content": "<p>Well, I need to detect UB uses in most cases during consteval (because C++ requires that), so I do have limited room.</p>",
        "id": 273739790,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184838
    },
    {
        "content": "<p>if Rust goes for the weaker one you could always have a flag to be able to express both kinds</p>",
        "id": 273739859,
        "sender_full_name": "RalfJ",
        "timestamp": 1646184877
    },
    {
        "content": "<p>but I think even for C++ UB checks you dont need the intrinsic to check for OOB</p>",
        "id": 273739869,
        "sender_full_name": "RalfJ",
        "timestamp": 1646184887
    },
    {
        "content": "<p>since that should already be caught by other checks</p>",
        "id": 273739879,
        "sender_full_name": "RalfJ",
        "timestamp": 1646184892
    },
    {
        "content": "<p>Yeah (probably overloading the overflow behaviour field)</p>",
        "id": 273739909,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184913
    },
    {
        "content": "<p>Also, even if we removed the \"inbounds\" requirement <code>offset_from</code> looks like it still is strict enough to to <code>div exact</code>, so can't be safe because of that.</p>",
        "id": 273741686,
        "sender_full_name": "scottmcm",
        "timestamp": 1646186378
    },
    {
        "content": "<p>ahhh.</p>",
        "id": 273741968,
        "sender_full_name": "Jubilee",
        "timestamp": 1646186474
    },
    {
        "content": "<p>(And that precondition is actually useful, since it's what allows optimizing <code>a.offset_from(b) == 0</code> to <code>a == b</code>; see <a href=\"https://github.com/rust-lang/rust/issues/61885\">#61885</a>.)</p>",
        "id": 273742102,
        "sender_full_name": "scottmcm",
        "timestamp": 1646186603
    },
    {
        "content": "<p>at some point my brain only-semi-jokingly came up with <code>ptr.map(|addr| { .. })</code></p>",
        "id": 273913500,
        "sender_full_name": "Jubilee",
        "timestamp": 1646275349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> suggested <code>ptr.with_addr(ptr.addr() &amp; !TAG_MASK)</code> so yeah makes sense ;)</p>",
        "id": 273916239,
        "sender_full_name": "RalfJ",
        "timestamp": 1646277707
    },
    {
        "content": "<p>Oh, I really like that. It feels a lot less painful and more rusty that way, so it would probably go a good way toward paying down the syntactic penalty of using <code>with_provenance</code> style operations which can help adoption</p>",
        "id": 273966597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646311549
    },
    {
        "content": "<p>Is <code>.addr()</code> the same as <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.to_bits\"><code>.to_bits()</code></a>?</p>",
        "id": 274015603,
        "sender_full_name": "scottmcm",
        "timestamp": 1646331561
    },
    {
        "content": "<p>The doc on <code>to_bits</code> suggests that it is to avoid confusion between <code>p as usize</code> and <code>*p as usize</code> but it doesn't really accomplish that since <code>u32::to_bits</code> sounds just as plausible</p>",
        "id": 274015877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646331686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274015603\">said</a>:</p>\n<blockquote>\n<p>Is <code>.addr()</code> the same as <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.to_bits\"><code>.to_bits()</code></a>?</p>\n</blockquote>\n<p>For a CHERI-style pointer it would not be.</p>",
        "id": 274016874,
        "sender_full_name": "Jubilee",
        "timestamp": 1646332124
    },
    {
        "content": "<p>For everyone else: yeah probably.</p>",
        "id": 274016944,
        "sender_full_name": "Jubilee",
        "timestamp": 1646332155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274016874\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274015603\">said</a>:</p>\n<blockquote>\n<p>Is <code>.addr()</code> the same as <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.to_bits\"><code>.to_bits()</code></a>?</p>\n</blockquote>\n<p>For a CHERI-style pointer it would not be.</p>\n</blockquote>\n<p>hm, is that a concern for stabilizing ptr::to_bits?</p>",
        "id": 274021651,
        "sender_full_name": "RalfJ",
        "timestamp": 1646334100
    },
    {
        "content": "<p>there are already stabilized things that imply that usize = uintptr, one more isn't going to hurt</p>",
        "id": 274022959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646334621
    },
    {
        "content": "<p>AAAA</p>",
        "id": 274023879,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646334987
    },
    {
        "content": "<p>Connor, if you manage to somehow find a way to fix this without breaking the world, I'm sure you can fix this one too</p>",
        "id": 274024321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646335181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274021651\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274016874\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274015603\">said</a>:</p>\n<blockquote>\n<p>Is <code>.addr()</code> the same as <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.to_bits\"><code>.to_bits()</code></a>?</p>\n</blockquote>\n<p>For a CHERI-style pointer it would not be.</p>\n</blockquote>\n<p>hm, is that a concern for stabilizing ptr::to_bits?</p>\n</blockquote>\n<p>should be. :P</p>",
        "id": 274029182,
        "sender_full_name": "Jubilee",
        "timestamp": 1646337067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/273416068\">said</a>:</p>\n<blockquote>\n<p>I can think of 2 ways to fix that:</p>\n<ul>\n<li>do not allow ptr2intp2tr roundtrips</li>\n<li>(the \"crazy complicated\" option) essentially make the entire model speculative where on a int2ptr, when there are multiple different \"broadcast\" that this could 'match up with', we speculatively match up with <em>all of them</em> and run all those potential different states of the entire aliasing model at the same time to see if <em>any</em> of these choices could actually work</li>\n</ul>\n</blockquote>\n<p>How does the compilation of <code>rawptr as usize</code> and <code>int as *const X</code> in option 2 differ (on non-CHERI) from the compilation of <code>external_function(rawptr)</code> and <code>external_function_returning_rawptr()</code>. If this is just a problem for the model and not for optimizers, rules can be fairly abstract and ridiculous from an implementation POV. If it's a problem for actual compilers, I don't see how the other sources of escaping are ok. If it's only a problem for miri (ie \"external functions are not supported\"), consteval <code>ptr as usize</code> is always going to have special restrictions that don't need to apply to other code. </p>\n<p>CHERI of course at minimum already runs into the entire mess of what usize is if rust wants to support CHERI, and \"we need to remove this to support CHERI\" would be a very different starting point regardless.</p>\n<p>All that said, having some selection of the common aligning/bitsetting/etc operations on pointer and particularly AtomicPtr would not be a bad idea regardless of the answers.</p>",
        "id": 274081533,
        "sender_full_name": "Talchas",
        "timestamp": 1646370655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274081533\">said</a>:</p>\n<blockquote>\n<p>CHERI of course at minimum already runs into the entire mess of what usize is if rust wants to support CHERI, and \"we need to remove this to support CHERI\" would be a very different starting point regardless.</p>\n</blockquote>\n<p>Yeah, CHERI is not in itself a determinant of how we should handle pointers, it's more interesting in how it immediately <strong>clarifies</strong> the intense degree that a pointer is not simply an integer, to the point the hardware <strong>itself</strong> may disagree with an attempt to impose that model and do seemingly nonintuitive things, like, say, make both of these true:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"></span>\n<span class=\"n\">UINTPTR_MAX</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">UINT64_MAX</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274087699,
        "sender_full_name": "Jubilee",
        "timestamp": 1646376437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274087699\">said</a>:</p>\n<blockquote>\n<p>Yeah, CHERI is not in itself a determinant of how we should handle pointers, it's more interesting in how it immediately <strong>clarifies</strong> the intense degree that a pointer is not simply an integer, to the point the hardware <strong>itself</strong> may disagree with an attempt to impose that model and do seemingly nonintuitive things, like, say, make both of these true:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"></span>\n<span class=\"n\">UINTPTR_MAX</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">UINT64_MAX</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Or, say, having registers just for the pointers which are not the same as integer registers and are now used in parameter passing, etc. etc.</p>\n</blockquote>\n<p>Well, there's definitely two positions there, one that it's just a more obvious way as you say, and the other is that it's just completely different and should not be considered like other targets. And having <code>1 &lt;&lt; (sizeof(a supposed integer type) * CHAR_BITS)</code> be nowhere near <code>THAT_INT_MAX</code> puts it firmly in \"even if it's permitted by spec, it is being actively hostile to the point of having these types and definitions\".</p>\n<p>(Also for my general point wrt this topic it _is_ completely different, because it can truly say it doesn't have escaped pointers where there is no known provanence/capability information)</p>",
        "id": 274166942,
        "sender_full_name": "Talchas",
        "timestamp": 1646417258
    },
    {
        "content": "<p>Mmm. <br>\n<span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274166942\">said</a>:</p>\n<blockquote>\n<p>Well, there's definitely two positions there, one that it's just a more obvious way as you say, and the other is that it's just completely different and should not be considered like other targets. And having <code>1 &lt;&lt; (sizeof(a supposed integer type) * CHAR_BITS)</code> be nowhere near <code>THAT_INT_MAX</code> puts it firmly in \"even if it's permitted by spec, it is being actively hostile to the point of having these types and definitions\".</p>\n</blockquote>\n<p>Mmm. Maybe, but CHERI is not actually the first ISA to define its ABI in a way that pointers are not simply numeric addresses even under a \"flat memory model\", and it will not be the last, and the assumption that Rust could ignore the detail that addresses other than simple numeric pointers exist was a wrong one~</p>",
        "id": 274167264,
        "sender_full_name": "Jubilee",
        "timestamp": 1646417400
    },
    {
        "content": "<p>Anyways, as far as \"can't escaped pointers from extern functions block alias analysis\":<br>\nThey may harm it, yes.<br>\nBut if int to pointer exists inside Rust, then <strong>every</strong> function that returns a pointer <strong>or</strong> an integer impacts alias analysis.</p>",
        "id": 274167484,
        "sender_full_name": "Jubilee",
        "timestamp": 1646417495
    },
    {
        "content": "<p>Per <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> either pointers have provenance and integers don't, everything has provenance (and we lose common integer opts), or nothing has provenance. If a pointer intrudes into Rust from a source we decide we must reason about as \"mysterious fait accompli\", then that's a lot different from then not being able to reason about our own operations using that pointer.</p>",
        "id": 274168185,
        "sender_full_name": "Jubilee",
        "timestamp": 1646417824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274167484\">said</a>:</p>\n<blockquote>\n<p>Anyways, as far as \"can't escaped pointers from extern functions block alias analysis\":<br>\nThey may harm it, yes.<br>\nBut if int to pointer exists inside Rust, then <strong>every</strong> function that returns a pointer <strong>or</strong> an integer impacts alias analysis.</p>\n</blockquote>\n<p>I'm not convinced by this actually, and I think this is also what Talchas is saying. For example, consider making the rule: \"int to ptr casts return a pointer with the provenance of a pointer on the borrow stack that has had its address leaked of the user's choosing, and null provenance otherwise\" (\"of the users choosing\" means \"we execute the AM for each possible choice and as long as one is legal the behavior is defined\"). This may be what Ralf was suggesting, I'm unclear on that.</p>\n<p>We could still optimize out the dead store in:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">returnsint</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because <code>p</code> aliasing <code>r</code> would lead to UB on the last use of <code>r</code></p>",
        "id": 274175155,
        "sender_full_name": "Jake",
        "timestamp": 1646420941
    },
    {
        "content": "<p>The thing I am worried about is whether this rule is so footgunny that it might not be that useful to have. Especially compared to C, where (at least under PNVI-ae), int to ptr casts always yield a valid pointer as long as the allocation has been leaked</p>",
        "id": 274175510,
        "sender_full_name": "Jake",
        "timestamp": 1646421103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274167484\">said</a>:</p>\n<blockquote>\n<p>Anyways, as far as \"can't escaped pointers from extern functions block alias analysis\":<br>\nThey may harm it, yes.<br>\nBut if int to pointer exists inside Rust, then <strong>every</strong> function that returns a pointer <strong>or</strong> an integer impacts alias analysis.</p>\n</blockquote>\n<p>No, the inttoptr (and the earlier ptrtoint) impacts the alias analysis (unless we're going with \"integers have provenance\", for which my impression is that compilers consider lost integer optimizations more important than the more conservative alias info, and no one seems to think it's worth putting in the model to let compilers try to keep it for short periods or something). Functions returning a pointer don't impact alias analysis any more (or any less) than just an uninlined function in general (which could mutate any escaped pointer that is still considered valid by SB).</p>\n<p>Now, maybe too many parts of the stdlib have ptrtoint so too many things are escaped too often, but that's an entirely different argument.</p>",
        "id": 274183096,
        "sender_full_name": "Talchas",
        "timestamp": 1646424917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> </p>\n<blockquote>\n<p>How does the compilation of rawptr as usize and int as *const X in option 2 differ (on non-CHERI) from the compilation of external_function(rawptr) and external_function_returning_rawptr(). If this is just a problem for the model and not for optimizers, rules can be fairly abstract and ridiculous from an implementation POV. If it's a problem for actual compilers, I don't see how the other sources of escaping are ok. If it's only a problem for miri (ie \"external functions are not supported\"), consteval ptr as usize is always going to have special restrictions that don't need to apply to other code. </p>\n</blockquote>\n<p>Compilation (as in lowering to machine code) is the same in all of them. <em>optimization</em> is different though, in particular in option 2, doing a ptr2int cast has a side-effect (the \"broadcast\") and can <em>not</em> be dead-code eliminated when its result is unused on the MIR / LLVM IR level, i.e. any IRs that still exploit provenance.</p>\n<p>I think rules being complicated is still a problem, since I think we have to convince unsafe Rust authors to think in terms of the rules of the abstract machine and <em>not</em> in terms of optimizations and machine code. It is that kind of thinking that <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">lead us to this situation</a>, so we should stop doing it.</p>",
        "id": 274254752,
        "sender_full_name": "RalfJ",
        "timestamp": 1646500820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274254752\">said</a>:</p>\n<blockquote>\n<p>doing a ptr2int cast has a side-effect (the \"broadcast\") and can <em>not</em> be dead-code eliminated when its result is unused on the MIR / LLVM IR level, i.e. any IRs that still exploit provenance.</p>\n</blockquote>\n<p>Yes (exactly like <code>external_function(ptr)</code> and how you mentioned in the past); has this been decided to cause too many optimization losses? (There's always \"PVI and let compilers decide how much they want to track provenance vs do integer optimizations\", though that of course makes the model an absolute mess)</p>\n<blockquote>\n<p>I think rules being complicated is still a problem, since I think we have to convince unsafe Rust authors to think in terms of the rules of the abstract machine and <em>not</em> in terms of optimizations and machine code. </p>\n</blockquote>\n<p>The thing is no one writing unsafe code <em>wants</em> to exploit the edge cases that cause all the ugly parts of a formal definition of a PNVI-ae-udi-like model. What is the part that a user actually cares about?</p>\n<p>Is the worry about \"cast usize-&gt;ptr, use it as one-past-the-end of X, then realize the original usize is equal to the start of Y and try to use the pointer for Y\"? That really does not seem plausible - the sorts of things where you'd be doing those usize comparisons at <em>all</em> you'd probably have a bug in this case because you're colliding things you don't intend to be equal.</p>\n<p>Is the worry about playing games with tons of ZSTs on the same address and doing deallocation that optimizations care about? I don't think there's anything there that isn't explained (as much as it's possible to explain) by \"you can't use after free even if it's a ZST\"; pointers are comparable so you already have the confusingness of <code>p == q</code> with both pointers the same type, and yet them not being equivalent.</p>",
        "id": 274261709,
        "sender_full_name": "Talchas",
        "timestamp": 1646509950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274254752\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> </p>\n<blockquote>\n<p>How does the compilation of rawptr as usize and int as *const X in option 2 differ (on non-CHERI) from the compilation of external_function(rawptr) and external_function_returning_rawptr(). If this is just a problem for the model and not for optimizers, rules can be fairly abstract and ridiculous from an implementation POV. If it's a problem for actual compilers, I don't see how the other sources of escaping are ok. If it's only a problem for miri (ie \"external functions are not supported\"), consteval ptr as usize is always going to have special restrictions that don't need to apply to other code. </p>\n</blockquote>\n<p>Compilation (as in lowering to machine code) is the same in all of them. <em>optimization</em> is different though, in particular in option 2, doing a ptr2int cast has a side-effect (the \"broadcast\") and can <em>not</em> be dead-code eliminated when its result is unused on the MIR / LLVM IR level, i.e. any IRs that still exploit provenance.</p>\n<p>I think rules being complicated is still a problem, since I think we have to convince unsafe Rust authors to think in terms of the rules of the abstract machine and <em>not</em> in terms of optimizations and machine code. It is that kind of thinking that <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">lead us to this situation</a>, so we should stop doing it.</p>\n</blockquote>\n<p>Actually, how much optimizations do we lose if we get rid of this? ie if the rule was \"int to ptr casts yield a raw pointer with the provenance of some raw pointer currently on the borrow stack\" (no previous leaking required). We still have all of the rest of SB to let us do alias analysis</p>",
        "id": 274261923,
        "sender_full_name": "Jake",
        "timestamp": 1646510273
    },
    {
        "content": "<p>Heh.</p>",
        "id": 274262246,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646510626
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">magic_extern_function</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span>  <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">magic_extern_function</span><span class=\"p\">()}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// magic pure function involving y</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274262371,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646510764
    },
    {
        "content": "<p>You'd have a hard time convincing me to not just delete everything involving <code>y</code> other than the last line setting it to <code>0</code>.</p>",
        "id": 274262400,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646510840
    },
    {
        "content": "<p>And I'd think you'd have a similarily <em>fun</em> time convincing llvm or gcc either.</p>",
        "id": 274262414,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646510878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274262414\">said</a>:</p>\n<blockquote>\n<p>And I'd think you'd have a similarily <em>fun</em> time convincing llvm or gcc either.</p>\n</blockquote>\n<p>oh LLVM is a good point, but I would actually be interested to know how much this affects Rust code</p>",
        "id": 274262637,
        "sender_full_name": "Jake",
        "timestamp": 1646511151
    },
    {
        "content": "<p>My instinct tells me not too much, because the pattern above is actually not that common I think. References passed as function parameters tend to stay as references, and pointers passed in have to basically do this type of thing anyway</p>",
        "id": 274262673,
        "sender_full_name": "Jake",
        "timestamp": 1646511214
    },
    {
        "content": "<p>Still, I don't want to lose opts on raw pointers, because, functionally, references are raw pointers with extra attributes. I think thats true of xlang (lccc), llvm, and gcc.</p>",
        "id": 274263223,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646511964
    },
    {
        "content": "<p>Yeah, that's fair. Probably not a great idea, I'm going to keep it in mind in any case though</p>",
        "id": 274263336,
        "sender_full_name": "Jake",
        "timestamp": 1646512093
    },
    {
        "content": "<p>From a practical perspective, it would be a shame to have going to pointers have even-hypothetical performance losses over staying as references.  Because the library will often implement things on references by using pointers internally, and if that lost information we'd need to duplicate basically everything.  Not to mention that I have no idea what it'd do to the <code>Allocator</code> API, since it always returns pointers today.</p>",
        "id": 274263589,
        "sender_full_name": "scottmcm",
        "timestamp": 1646512388
    },
    {
        "content": "<blockquote>\n<p>Actually, how much optimizations do we lose if we get rid of this? ie if the rule was \"int to ptr casts yield a raw pointer with the provenance of some raw pointer currently on the borrow stack\" (no previous leaking required). We still have all of the rest of SB to let us do alias analysis</p>\n</blockquote>\n<p>We lose all the SB optimizations then. So we might just as well not bother with SB in the first place.</p>",
        "id": 274267154,
        "sender_full_name": "RalfJ",
        "timestamp": 1646517605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274263589\">said</a>:</p>\n<blockquote>\n<p>From a practical perspective, it would be a shame to have going to pointers have even-hypothetical performance losses over staying as references.  Because the library will often implement things on references by using pointers internally, and if that lost information we'd need to duplicate basically everything.  Not to mention that I have no idea what it'd do to the <code>Allocator</code> API, since it always returns pointers today.</p>\n</blockquote>\n<p>I am a bit confused by this... the <em>entire point</em> of SB is that a <code>fn rainbow(x: &amp;mut i32)</code> can do a bunch of (alias-based) optimizations that <code>fn rainbow(x: *mut i32)</code> cannot do.</p>",
        "id": 274267271,
        "sender_full_name": "RalfJ",
        "timestamp": 1646517682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274267154\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Actually, how much optimizations do we lose if we get rid of this? ie if the rule was \"int to ptr casts yield a raw pointer with the provenance of some raw pointer currently on the borrow stack\" (no previous leaking required). We still have all of the rest of SB to let us do alias analysis</p>\n</blockquote>\n<p>We lose all the SB optimizations then. So we might just as well not bother with SB in the first place.</p>\n</blockquote>\n<p>Why is that? I specifically mean raw pointer - ie SRW or SRO - and not Unique</p>",
        "id": 274267345,
        "sender_full_name": "Jake",
        "timestamp": 1646517746
    },
    {
        "content": "<p>We should for example still be able to do the DSE from this example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">returnsint</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274267354,
        "sender_full_name": "Jake",
        "timestamp": 1646517784
    },
    {
        "content": "<p>Since whatever provenance <code>p</code> has must be below <code>r</code> on the borrow stack</p>",
        "id": 274267360,
        "sender_full_name": "Jake",
        "timestamp": 1646517810
    },
    {
        "content": "<blockquote>\n<p>Yes (exactly like external_function(ptr) and how you mentioned in the past); has this been decided to cause too many optimization losses? (There's always \"PVI and let compilers decide how much they want to track provenance vs do integer optimizations\", though that of course makes the model an absolute mess)</p>\n</blockquote>\n<p>I don't think much has been decided, though I think broadly speaking there is consensus <em>against</em> PVI (since that breaks \"replacing <code>x</code> by <code>y</code> inside an <code>if x == y</code>\" even for integer variables).<br>\nMaking ptr2int a side-effecting broadcast seems like the \"most fair\" option, since it will only affect code that actually does ptr2int.</p>",
        "id": 274267363,
        "sender_full_name": "RalfJ",
        "timestamp": 1646517814
    },
    {
        "content": "<blockquote>\n<p>Is the worry about \"cast usize-&gt;ptr, use it as one-past-the-end of X, then realize the original usize is equal to the start of Y and try to use the pointer for Y\"?</p>\n</blockquote>\n<p>The worry is that you just cast ptr -&gt; usize and back, <em>without even knowing</em> excactly what kind of pointer this is (ZST or one-past-the-end or much-past-the-end or pointing to things where there's also a bunch of shared references or whatever) -- and yet people will just assume that the pointer they get back is \"equivalent\" to the one they started with.</p>",
        "id": 274267431,
        "sender_full_name": "RalfJ",
        "timestamp": 1646517910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274267345\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274267154\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Actually, how much optimizations do we lose if we get rid of this? ie if the rule was \"int to ptr casts yield a raw pointer with the provenance of some raw pointer currently on the borrow stack\" (no previous leaking required). We still have all of the rest of SB to let us do alias analysis</p>\n</blockquote>\n<p>We lose all the SB optimizations then. So we might just as well not bother with SB in the first place.</p>\n</blockquote>\n<p>Why is that? I specifically mean raw pointer - ie SRW or SRO - and not Unique</p>\n</blockquote>\n<p>oh, sorry, I misunderstood.<br>\nthen we still lose all optimizations related to shared references.</p>",
        "id": 274267492,
        "sender_full_name": "RalfJ",
        "timestamp": 1646517975
    },
    {
        "content": "<p>I still don't follow, can you give an example?</p>",
        "id": 274267511,
        "sender_full_name": "Jake",
        "timestamp": 1646518041
    },
    {
        "content": "<p>aren't those just the optimizations in <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> again</p>",
        "id": 274270148,
        "sender_full_name": "Jubilee",
        "timestamp": 1646520948
    },
    {
        "content": "<p>Well, the second optimization there would be invalid, yes</p>",
        "id": 274270555,
        "sender_full_name": "Jake",
        "timestamp": 1646521324
    },
    {
        "content": "<p>Semi-related: What do people think about making <code>usize as *const T</code> produce a read-only pointer, in the same way as <code>&amp;T as *const T</code>? That is, <code>usize as *mut T</code> can be written to (assuming that it pairs with something meaningful) but <code>usize as *const T as *mut T</code> can't. Depending on how things are set up, <code>usize as *const T</code> may pair with a mutable pointer, meaning that subsequent writing to it is not UB, but if we can make this always UB I think it will be easier to reason about on the receiver side.</p>",
        "id": 274270932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646521852
    },
    {
        "content": "<p>I would prefer we not add complications like that to the model, even if they cause some more code to be accepted. As it is, people mutate through <code>slice::as_ptr</code> which documents that you can't do that, but I feel like I have some shot at explaining that to people by justifying it as deriving from a <code>&amp;T</code>. But we've depressingly done a good job teaching people that <code>const</code> vs <code>mut</code> doesn't mean anything, so I don't think overturning that will go well.</p>",
        "id": 274278791,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646533107
    },
    {
        "content": "<p>The problem is that with the \"pairing to another pointer\" semantics, a <code>usize as *const T</code> operation could pair with a read-only pointer or a mutable pointer, and it is hard to determine which you will get (it is a nonlocal property), so it is UB <em>sometimes</em> to write to the pointer (after casting to <code>*mut T</code>), depending on runtime conditions.</p>",
        "id": 274279084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646533572
    },
    {
        "content": "<p>The idea here is that we instead consider an int2ptr operation as having exactly the mutability ascribed to it, just like with casts from references. Any subsequent <code>*const T as *mut T</code> or vice versa have no effect on the mutability status of the pointer (which matches current behavior).</p>",
        "id": 274279215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646533759
    },
    {
        "content": "<p>I do not think that your proposal is less confusing than \"You can't mutate through that *mut T because you didn't leak a mutable provenance for the pointer\"</p>",
        "id": 274279430,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646533925
    },
    {
        "content": "<p>What if you <em>did</em> leak a mutable provenance for the pointer, but you instead get paired with another pointer that is read-only?</p>",
        "id": 274279441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646533974
    },
    {
        "content": "<p>I think that it would be a deep mistake to adopt an aliasing model with a chaotic abstract machine</p>",
        "id": 274279462,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646534021
    },
    {
        "content": "<p>I don't know if there's a way arround it.</p>",
        "id": 274279489,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534042
    },
    {
        "content": "<p>the problem with wild pointers is exactly that they are not uniquely specifying a pointer</p>",
        "id": 274279510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646534059
    },
    {
        "content": "<p>Balancing code that is expected to <em>just work</em> against optimizations that implementations perform or want to perform.</p>",
        "id": 274279515,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534071
    },
    {
        "content": "<p>If we don't want to be overly restrictive on either side, we will need a complicated model.</p>",
        "id": 274279535,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534124
    },
    {
        "content": "<p>I'm fine with a complicated model but I can't imagine how to check that</p>",
        "id": 274279599,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646534191
    },
    {
        "content": "<p>Does Miri pick a provenance randomly? Through some complicated algorithm people will depend on? Or does it pick the minimum, in which case we should just say that's the semantics.</p>",
        "id": 274279625,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646534242
    },
    {
        "content": "<p>Miri picks a provenance.<br>\nAnd if there's ever been an provenance leaked at that address, it picks it, rather than null provenance, which is incorrect.</p>",
        "id": 274279684,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534298
    },
    {
        "content": "<p>I do not want a Miri where code passes or doesn't by chance</p>",
        "id": 274279699,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646534342
    },
    {
        "content": "<p>We could use union provenance.</p>",
        "id": 274279711,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534367
    },
    {
        "content": "<p>When you perform an operation on union provenace, it checks each provenance, discards ones it's invalid for, and if anything is left that grants the access, it has DB.</p>",
        "id": 274279769,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534414
    },
    {
        "content": "<p>Miri doesn't pick a provenance randomly, there is a rule, but it's not a rule that I would attempt to teach people other than to say it is something deterministic but you should assume the worst case</p>",
        "id": 274279844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646534555
    },
    {
        "content": "<p>Whatever the rule is, it's invalid.</p>",
        "id": 274279858,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279769\">said</a>:</p>\n<blockquote>\n<p>When you perform an operation on union provenace, it checks each provenance, discards ones it's invalid for, and if anything is left that grants the access, it has DB.</p>\n</blockquote>\n<p>How does this interact with the borrow stack? If you have two valid provenances in the borrow stack and it picks the top one, is it still allowed to use the lower one? That would once more allow <code>*pointer = 1; *unique_ref = 2; *pointer = 3;</code> to alias</p>",
        "id": 274279868,
        "sender_full_name": "Jake",
        "timestamp": 1646534602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279625\">said</a>:</p>\n<blockquote>\n<p>Does Miri pick a provenance randomly? Through some complicated algorithm people will depend on? Or does it pick the minimum, in which case we should just say that's the semantics.</p>\n</blockquote>\n<p>The Miri bug is exactly the observation that \"minimum\" isn't well defined, provenances aren't all comparable</p>",
        "id": 274280006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646534777
    },
    {
        "content": "<p>My understanding is that it is picking something that is minimum-ish, but there are counterexamples</p>",
        "id": 274280021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646534814
    },
    {
        "content": "<p>SInce if you allocate something, cast to usize, then cast the address of that allocation as a constant (by chance, including by miri-chance), you get a pointer to the previous allocation. If you don't use anything with the new pointer, and deallocate the allocation, then the new pointer is invalid even though according to <code>core::ptr</code> it's valid for accesses of size 0.</p>",
        "id": 274280026,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534818
    },
    {
        "content": "<p>(That bullet point in <code>core::ptr</code> actually seems to either require union provenance or PVI)</p>",
        "id": 274280106,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279868\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279769\">said</a>:</p>\n<blockquote>\n<p>When you perform an operation on union provenace, it checks each provenance, discards ones it's invalid for, and if anything is left that grants the access, it has DB.</p>\n</blockquote>\n<p>How does this interact with the borrow stack? If you have two valid provenances in the borrow stack and it picks the top one, is it still allowed to use the lower one? That would once more allow <code>*pointer = 1; *unique_ref = 2; *pointer = 3;</code> to alias</p>\n</blockquote>\n<p>I'd assume you can only have one provenance to a particular memory location at a time.</p>",
        "id": 274280114,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646534962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279844\">said</a>:</p>\n<blockquote>\n<p>Miri doesn't pick a provenance randomly, there is a rule, but it's not a rule that I would attempt to teach people other than to say it is something deterministic but you should assume the worst case</p>\n</blockquote>\n<p>I've already patched code that is unconditional UB but passes Miri by default. I don't want to see more of that.</p>",
        "id": 274280116,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646534963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280021\">said</a>:</p>\n<blockquote>\n<p>My understanding is that it is picking something that is minimum-ish, but there are counterexamples</p>\n</blockquote>\n<p>You're using present tense here, but Miri doesn't do any of this so I'm confused</p>",
        "id": 274280166,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646535004
    },
    {
        "content": "<p>The miri bug I'm referring to is <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a></p>",
        "id": 274280195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535094
    },
    {
        "content": "<p>It's described as a bug in stacked borrows but I thought that Miri had an implementation of it, possibly behind a <code>-Z miri-track-raw-pointers</code> flag</p>",
        "id": 274280243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280116\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279844\">said</a>:</p>\n<blockquote>\n<p>Miri doesn't pick a provenance randomly, there is a rule, but it's not a rule that I would attempt to teach people other than to say it is something deterministic but you should assume the worst case</p>\n</blockquote>\n<p>I've already patched code that is unconditional UB but passes Miri by default. I don't want to see more of that.</p>\n</blockquote>\n<p>We're talking about the rules for the abstract machine, which can also be implemented by Miri. So I don't think this is an issue?</p>",
        "id": 274280265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535199
    },
    {
        "content": "<p>It is exactly the desire to have an executable AM which leads to the rule being \"something deterministic and hard to reason about\" rather than \"something wildly nondeterministic and maximally permissive\" like the C++ roundtrip rule</p>",
        "id": 274280326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535268
    },
    {
        "content": "<p>I'm just gonna be honest here, I wouldn't be surprised if some people leave Rust if a decision like that is made. \"Our abstract machine cannot be understood\" does not sound like a platform you can actually write code against.</p>",
        "id": 274280357,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646535353
    },
    {
        "content": "<p>I'm basically advocating for programmers to treat the abstract machine as if it chooses some provenance nondeterministically, even though it uses a particular rule and they can program to it if they really want to</p>",
        "id": 274280431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535451
    },
    {
        "content": "<p>It would be nice if there was an optimal choice so that the AM could make that choice, but there isn't, at least in the current model of provenance</p>",
        "id": 274280527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535571
    },
    {
        "content": "<p>So it's implementing the next best thing, which is a rule which is simple and reasonable from the point of view of the abstract machine itself but involves notions that are not immediately obvious in the code like the current state of the borrow stack</p>",
        "id": 274280685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535652
    },
    {
        "content": "<p>I think that's too complicated for people to program against, and instead, people will write code to whatever passes Miri.</p>",
        "id": 274280725,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646535716
    },
    {
        "content": "<p>The alternative is a rule like C++ which forks the machine into a huge number of nondeterministic executions which makes it impractical to run on nontrivial examples. I don't think this is doing a service to unsafe code authors</p>",
        "id": 274280773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280725\">said</a>:</p>\n<blockquote>\n<p>I think that's too complicated for people to program against, and instead, people will write code to whatever passes Miri.</p>\n</blockquote>\n<p><em>That's exactly what an executable AM gives you.</em> We're not disagreeing?</p>",
        "id": 274280787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535764
    },
    {
        "content": "<p>Miri implements this rule, so if Miri says okay then it's not UB</p>",
        "id": 274280795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646535787
    },
    {
        "content": "<p>The problem, of course, is when miri disagrees with what the spec allows.</p>",
        "id": 274280796,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646535798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280114\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279868\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279769\">said</a>:</p>\n<blockquote>\n<p>When you perform an operation on union provenace, it checks each provenance, discards ones it's invalid for, and if anything is left that grants the access, it has DB.</p>\n</blockquote>\n<p>How does this interact with the borrow stack? If you have two valid provenances in the borrow stack and it picks the top one, is it still allowed to use the lower one? That would once more allow <code>*pointer = 1; *unique_ref = 2; *pointer = 3;</code> to alias</p>\n</blockquote>\n<p>I'd assume you can only have one provenance to a particular memory location at a time.</p>\n</blockquote>\n<p>Well in that case, which one?</p>",
        "id": 274280799,
        "sender_full_name": "Jake",
        "timestamp": 1646535820
    },
    {
        "content": "<p>(Keeping in mind that miri mostly follows the choices for implementation-defined/unspecified behaviour of rustc)</p>",
        "id": 274280800,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646535820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280243\">said</a>:</p>\n<blockquote>\n<p>It's described as a bug in stacked borrows but I thought that Miri had an implementation of it, possibly behind a <code>-Z miri-track-raw-pointers</code> flag</p>\n</blockquote>\n<p>No, under <code>-Zmiri-tag-raw-pointers</code>, the pointer from an int-to-ptr cast is not usable for anything.</p>",
        "id": 274281000,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646536083
    },
    {
        "content": "<p>oh, in the issue it says that miri has the analogous problem for ref &lt;-&gt; ptr because pointers are untagged</p>",
        "id": 274281034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646536162
    },
    {
        "content": "<p>Yes, the issue is about the problems with the default behavior of Miri, which as far as I understand is an incomplete implementation of SB, because the full implementation which is <code>-Zmiri-tag-raw-pointers</code> rejects too much code.</p>",
        "id": 274281081,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646536213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274267431\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is the worry about \"cast usize-&gt;ptr, use it as one-past-the-end of X, then realize the original usize is equal to the start of Y and try to use the pointer for Y\"?</p>\n</blockquote>\n<p>The worry is that you just cast ptr -&gt; usize and back, <em>without even knowing</em> excactly what kind of pointer this is (ZST or one-past-the-end or much-past-the-end or pointing to things where there's also a bunch of shared references or whatever) -- and yet people will just assume that the pointer they get back is \"equivalent\" to the one they started with.</p>\n</blockquote>\n<p>Yes, and by this rule it will be usable in <em>at least</em> as many places as their original pointer. As far as a programmer is concerned that <em>is</em> equivalent. Teaching \"<code>as usize</code> may lose some optimizations, avoid it if you can\" does not seem difficult or unreasonable.</p>",
        "id": 274281082,
        "sender_full_name": "Talchas",
        "timestamp": 1646536215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274281081\">said</a>:</p>\n<blockquote>\n<p>Yes, the issue is about the problems with the default behavior of Miri, which as far as I understand is an incomplete implementation of SB, because the full implementation which is <code>-Zmiri-tag-raw-pointers</code> rejects too much code.</p>\n</blockquote>\n<p>Sure, but rejecting all wild pointers is probably not tenable, and that exact issue will come back if wild pointers are paired with a specific item on the borrow stack.</p>",
        "id": 274281371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646536618
    },
    {
        "content": "<p>Union provenance does seem like a possible solution; I'm not sure what impact it has on the implementation.</p>",
        "id": 274281532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646536855
    },
    {
        "content": "<p>It would be dicey to implement in Miri if that's what you're asking. But everything that it needs we should probably have anyway for generating better diagnostics. So if Ralf &amp; co. don't pave the way I will eventually.</p>",
        "id": 274282407,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646538151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274267511\">said</a>:</p>\n<blockquote>\n<p>I still don't follow, can you give an example?</p>\n</blockquote>\n<p>well you are basically treating SRO and SRW as \"broadcasted\". when &amp;mut T is turned to &amp;T, we do generate SRO/SRW (depending on whether there are UnsafeCell), so that would be the moment we \"broadcast\" a location.<br>\nI dont think we should do that -- entirely reference-based code should never \"broadcast\" (and pay the associated optimization cost).</p>",
        "id": 274314685,
        "sender_full_name": "RalfJ",
        "timestamp": 1646584412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279769\">said</a>:</p>\n<blockquote>\n<p>When you perform an operation on union provenace, it checks each provenance, discards ones it's invalid for, and if anything is left that grants the access, it has DB.</p>\n</blockquote>\n<p>that's not enough. you need to basically track \"all possible choices\" for provenance at the same time, since depending on which provenance the new ptr got, that will have different effects on borrow stacks of accessed locations.<br>\nso, this is exactly the \"crazy complicated\" model I mentioned before in this thread, where you track a whole set of speculative executions (one for each choice of provenance).</p>",
        "id": 274314819,
        "sender_full_name": "RalfJ",
        "timestamp": 1646584604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274279684\">said</a>:</p>\n<blockquote>\n<p>Miri picks a provenance.<br>\nAnd if there's ever been an provenance leaked at that address, it picks it, rather than null provenance, which is incorrect.</p>\n</blockquote>\n<p>\"incorrect\" wrt which model of correctness?<br>\nare you saying always using \"null provenance\" (I assume that means \"empty provenance\", i.e., a provenance not usable for any access) would be more correct?<br>\nEDIT: ah you probably mean <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280026\">this</a>. Honestly I think that annoying situation around size 0 things is almost entirely LLVM's fault, if the GEPi rules made slightly more sense this would be so much easier...<br>\nI am in favor of simply allowing 0-sized accesses for <em>all</em> pointers (maybe with the sole exception of NULL) and either convincing LLVM to adjust their GEPi rules or changing rustc to omit <code>inbounds</code> for 0 offsets.</p>",
        "id": 274314845,
        "sender_full_name": "RalfJ",
        "timestamp": 1646584654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274280357\">said</a>:</p>\n<blockquote>\n<p>I'm just gonna be honest here, I wouldn't be surprised if some people leave Rust if a decision like that is made. \"Our abstract machine cannot be understood\" does not sound like a platform you can actually write code against.</p>\n</blockquote>\n<p>the funny thing is, people are willing to build on C/C++ which doesnt come close to Stacked Borrows in terms of how well its abstract machine is understood.</p>",
        "id": 274314993,
        "sender_full_name": "RalfJ",
        "timestamp": 1646584886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274281081\">said</a>:</p>\n<blockquote>\n<p>Yes, the issue is about the problems with the default behavior of Miri, which as far as I understand is an incomplete implementation of SB, because the full implementation which is <code>-Zmiri-tag-raw-pointers</code> rejects too much code.</p>\n</blockquote>\n<p>I'd say they are just 2 variants of SB. neither of them is more or less complete than the other. the paper describes the one Miri implements by default though, so it is certainly \"complete enough\" in the sense of giving us the optimizations we want.</p>",
        "id": 274315061,
        "sender_full_name": "RalfJ",
        "timestamp": 1646584982
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> </p>\n<blockquote>\n<p>Yes, and by this rule it will be usable in at least as many places as their original pointer. As far as a programmer is concerned that is equivalent. Teaching \"as usize may lose some optimizations, avoid it if you can\" does not seem difficult or unreasonable.</p>\n</blockquote>\n<p>oh gosh we are having like 10 parallel conversations in the same zulip thread. I lost track of this one so I have no idea what \"this rule\" is. we are discussing a multitude of different rules here...<br>\nbut, basically, the gist of it is that it is <em>really hard</em> to ensure that the new pointer is \"usable in at least as many places\". in SB I thought I had achieved that but I <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">was wrong</a>. basically the only way we know to do that is what I called the \"crazy complicated\" model and Connor calls \"union provenance\" (which I think undersells its complexity since just making provenance more fancy is not enough, you need to literally keep duplicating all the borrow stacks)</p>",
        "id": 274315124,
        "sender_full_name": "RalfJ",
        "timestamp": 1646585047
    },
    {
        "content": "<p>Let's end this thread and resume conversations in new threads per topic.</p>",
        "id": 274317528,
        "sender_full_name": "Jubilee",
        "timestamp": 1646587049
    },
    {
        "content": "<blockquote>\n<p>are you saying always using \"null provenance\" (I assume that means \"empty provenance\", i.e., a provenance not usable for any access) would be more correct?</p>\n</blockquote>\n<p>A null provenance is not always more correct, but is minimally required for constants cast to pointers. It's not the same as \"empty provenance\" because it's valid for accesses of size 0. This is mandated by <a href=\"https://doc.rust-lang.org/core/ptr/index.html#safety\">https://doc.rust-lang.org/core/ptr/index.html#safety</a>, bullet 3.</p>\n<blockquote>\n<p>However, casting any non-zero integer literal to a pointer is valid for zero-sized accesses, even if some memory happens to exist at that address and gets deallocated.</p>\n</blockquote>",
        "id": 274317700,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646587285
    },
    {
        "content": "<p>That is <code>addr as *mut u8</code> is valid for accesses of size 0 (assuming <code>addr</code>!=0) even if there happens to have been an allocation there that previously or subsequently gets deallocated.</p>",
        "id": 274317766,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646587336
    },
    {
        "content": "<p>I rather like that deallocated memory can't be used for zero sized accesses, since it means I can give the xir <code>indirect</code> instruction conistent semantics, as that get's generated for both zero-sized and non-zero-sized accesses.</p>",
        "id": 274317902,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646587524
    }
]