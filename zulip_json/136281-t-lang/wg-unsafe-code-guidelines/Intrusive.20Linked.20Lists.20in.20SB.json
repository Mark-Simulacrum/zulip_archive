[
    {
        "content": "<p>So I've seen a number of times the claim that intrusive linked lists are not possible in SB. This is not true: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a4a0782783f1130be1e59fe15872e0b9\">playground</a></p>\n<p>That passes MIRI with tagged raw pointers (and other hard mode flags) without issues. This is not restricted to linked lists either. You can put the edges of the graph into much more complicated shapes too, it all doesn't matter.</p>\n<p>The fundamental reason this works (and the biggest restriction for it) is that all the pointers stored in the linked list that point to the same node are the same, ie they have the same provenance. This is possible (and easy) to do in SB because pointers are not retagged on move. If you have a pointer, you can just write it into two places and the provenance of the pointers in those places is the same. In this sense, there is a \"master pointer\" to each node, which must not be invalidated as long as the node is in the linked list. A good choice for such a master pointer if the node is allocated on the heap is the pointer returned by the allocator - that cannot be invalidated without freeing the allocation. If the node is in the stack, we need to create the pointer from the local once and then not use the local directly again (except through the pointer).</p>\n<p>The playground includes lots of examples of things that work. The one thing that won't work is any pattern that does this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">curr</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">curr_ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">other_node</span><span class=\"p\">.</span><span class=\"n\">prev</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">curr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The reason is that now, the <code>other_node.prev</code> pointer is <em>not</em> the master pointer that we stored before, but rather another pointer that is derived from <code>curr</code>. That's no good, and will cause us SB errors as soon as <code>curr</code> gets invalidated.</p>",
        "id": 276533479,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648152857
    },
    {
        "content": "<p>The particular way you have written this example does not really show an intrusive list, just a regular single-item-per-node linked list. This /is/ adaptable into a proper intrusive list (ie, ability to be on multiple lists while having the list operations encapsulated), but the encapsulation causes hassle with the currently available syntax (brb, writing it up)</p>",
        "id": 276534900,
        "sender_full_name": "Talchas",
        "timestamp": 1648153625
    },
    {
        "content": "<p>I agree with the syntax issue, but would like to keep that out of this thread if at all possible. <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span>  has brought up some suggestions for how to address this, and it's in general no secret that <code>addr_of</code> and friends are not user friendly. The point here isn't to show that it's easy to write - even my example may be unintuitive. The point is to show that it's <em>possible</em></p>",
        "id": 276535106,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648153748
    },
    {
        "content": "<p>\"How (if at all) can we change syntax/ergonomics problems to make SB less of a pain to work with?\" does sound like a good topic for another thread though</p>",
        "id": 276535265,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648153824
    },
    {
        "content": "<p>yes, my bigger point is that your intrusive list example should still be an actual intrusive list</p>",
        "id": 276535362,
        "sender_full_name": "Talchas",
        "timestamp": 1648153900
    },
    {
        "content": "<p>huh? I thought this was an intrusive list, and that a non-intrusive one uses an abstraction like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Node</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">prev</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">data</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Data</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276535800,
        "sender_full_name": "Jubilee",
        "timestamp": 1648154072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276535800\">said</a>:</p>\n<blockquote>\n<p>huh? I thought this was an intrusive list, and that a non-intrusive one uses an abstraction like</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Node</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">prev</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">data</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Data</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Well, you can make it \"more\" intrusive by having</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Node</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">prev</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">list_1</span>: <span class=\"nc\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">list_2</span>: <span class=\"nc\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">data</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or something like that</p>",
        "id": 276535928,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648154130
    },
    {
        "content": "<p>But I'm going to call this covered under the points \"this pattern isn't restricted to a linked list, you can have the edges in more complicated shapes\" and \"nothing cares if you put some data in a struct or code in a function\"</p>",
        "id": 276536098,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648154203
    },
    {
        "content": "<p>If you do add stuff to a function though, keep in mind that you cannot implement this interface for reasons discussed above:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">add_to_list</span><span class=\"p\">(</span><span class=\"n\">new_node</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">prev</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276536339,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648154311
    },
    {
        "content": "<p>(yes, this does pose ergonomics issues - discuss elsewhere)</p>",
        "id": 276536378,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648154329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276535800\">said</a>:</p>\n<blockquote>\n<p>huh? I thought this was an intrusive list, and that a non-intrusive one uses an abstraction like</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Node</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">prev</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">data</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Data</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>that's like a non-intrusive list in java where everything is a pointer. The relevant part is that a direct translation to a generic version of this would be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">prev</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">data</span>: <span class=\"nc\">T</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>ie the data is owned by the Node, not the other way around</p>",
        "id": 276536557,
        "sender_full_name": "Talchas",
        "timestamp": 1648154415
    },
    {
        "content": "<p>Yeah, wanting to avoid forcing the <code>Node</code> type to own <code>data</code> is completely fair</p>",
        "id": 276536652,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648154471
    },
    {
        "content": "<p>Actually, interestingly, this type of pattern is one that is liable to be broken by not tagging raw pointers. None of the code I wrote runs into this, but \"accidentally reborrowed too high up the stack\" is a super easy problem to run into here</p>",
        "id": 276537162,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648154744
    },
    {
        "content": "<p>I think the \"reborrowed too high up in the stack\" is just one aspect of the deeper problem with SB without raw pointer tagging</p>",
        "id": 276537415,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648154882
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e44fd33f6d63fc1109c7bb3966ccc3e2\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e44fd33f6d63fc1109c7bb3966ccc3e2</a> is what I'd use as an example without CRTP+traits, to clarify that reasonable encapsulation and actual intrusiveness is possible</p>",
        "id": 276539974,
        "sender_full_name": "Talchas",
        "timestamp": 1648156239
    },
    {
        "content": "<p>I wrote <a href=\"https://gist.github.com/Darksonn/1567538f56af1a8038ecc3c664a42462\">this page</a> on intrusive lists last year, and for the use cases discussed there it really is not possible to do it correctly under SB. The primary difference is that we cannot prevent the user from taking a new mutable reference to the stack location, invalidating the old raw pointers.</p>",
        "id": 276543164,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648158143
    },
    {
        "content": "<p>and <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=ee8e6d59bd7941f93284c05a926938f6\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=ee8e6d59bd7941f93284c05a926938f6</a> is the nice looking CRTPish one</p>",
        "id": 276543265,
        "sender_full_name": "Talchas",
        "timestamp": 1648158227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276543164\">said</a>:</p>\n<blockquote>\n<p>I wrote <a href=\"https://gist.github.com/Darksonn/1567538f56af1a8038ecc3c664a42462\">this page</a> on intrusive lists last year, and for the use cases discussed there it really is not possible to do it correctly under SB. The primary difference is that we cannot prevent the user from taking a new mutable reference to the stack location, invalidating the old raw pointers.</p>\n</blockquote>\n<p>Why can't you prevent this? Can't you shadow the local the same way <code>pin_mut!</code> does and I do in the example?</p>",
        "id": 276543725,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648158492
    },
    {
        "content": "<p>Well, in the most common situation, the intrusive list is inside a Future. The only pointers you have access to are those the user passes to <code>poll</code>, but since that's a reference, they are invalidated on the next poll (or on drop)</p>",
        "id": 276544384,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648158916
    },
    {
        "content": "<p>and Pin::map_unchecked_mut/etc probably are narrowing provenance as well</p>",
        "id": 276544446,
        "sender_full_name": "Talchas",
        "timestamp": 1648158959
    },
    {
        "content": "<p>(though whether or not narrowing spatially is a problem depends)</p>",
        "id": 276544518,
        "sender_full_name": "Talchas",
        "timestamp": 1648158982
    },
    {
        "content": "<p>I mean, the mutable reference itself would be invalidated on the next call, so it doesn't matter how you derive your raw pointers from it</p>",
        "id": 276544595,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648159034
    },
    {
        "content": "<p>So it's not exactly that rust is completely unable to represent them, but that future/poll APIs use references which make it impossible?<br>\nCould that be more of a problem with those specific APIs than with the language semantics? Like the Read trait not letting you read into an uninit buffer<br>\nWould it help at all if there was a raw pointer poll version that didn't assert uniqueness and/or narrow provenance?</p>",
        "id": 276545671,
        "sender_full_name": "Nick12",
        "timestamp": 1648159574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276544384\">said</a>:</p>\n<blockquote>\n<p>Well, in the most common situation, the intrusive list is inside a Future. The only pointers you have access to are those the user passes to <code>poll</code>, but since that's a reference, they are invalidated on the next poll (or on drop)</p>\n</blockquote>\n<p>Ah. To be honest, that sounds like it might be more of a problem with the generator stuff in general than anything else</p>",
        "id": 276546013,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648159788
    },
    {
        "content": "<p>Whenever we do decide on a fix, I think supporting use cases like this is a good thing to keep in mind</p>",
        "id": 276546166,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648159884
    },
    {
        "content": "<p>What if you replace <em>all</em> occurrences of <code>&amp;mut _</code> with <code>&amp;Cell&lt;_&gt;</code>? Don't go through any mutable references, go straight from <code>*mut</code> to <code>&amp;Cell</code>.   This isn't possible in all interfaces—in particular not for Futures—but it does sound possible if one were to invent a new linked-list from scratch. And iirc then a reference-to-cell alone will not invalidate the SharedRW provenance of any of the other pointers, nor get invalidated if you copy any of the other sharedRW provenance (or use them for <code>write</code> or <code>read</code> operations). Just never create a unique references.</p>",
        "id": 276547272,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1648160590
    },
    {
        "content": "<p>I've been lamenting the lack of standard library goodies for <code>&amp;Cell</code> elsewhere. It should feel more native. For example, <code>&amp;mut [_]</code> gets <code>copy_from_slice</code>, <code>copy_within</code> and other utilities. There should be similar methods offered on <code>&amp;Cell</code>, imho. Many only make use of the writeability, not uniqueness. There's an explainable lack of prior-art of course but using <code>Cell</code> is better than unsound code—sadly this isn't incentivized due to the lack of (safe) utilities for <code>Cell</code>/<code>UnsafeCell</code>.</p>",
        "id": 276547652,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1648160933
    },
    {
        "content": "<p>you can't split <code>&amp;Cell&lt;(A, B)&gt;</code> into <code>(&amp;Cell&lt;A&gt;, &amp;Cell&lt;B&gt;)</code> (such a function should be safe though I think?) Though yes, a lot of intrusive list uses would probably be using &amp; for any top-level access and then various Cell types for any mutation</p>",
        "id": 276548616,
        "sender_full_name": "Talchas",
        "timestamp": 1648161709
    },
    {
        "content": "<p>Yes, that split should be sound as far as I'm aware of SB. Count it towards the missing utilities, only this one can't even be emulated by <code>as_slice_of_cells</code> and reverse.</p>",
        "id": 276549958,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1648162675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219940\">Nick12</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276545671\">said</a>:</p>\n<blockquote>\n<p>So it's not exactly that rust is completely unable to represent them, but that future/poll APIs use references which make it impossible?<br>\nCould that be more of a problem with those specific APIs than with the language semantics? Like the Read trait not letting you read into an uninit buffer<br>\nWould it help at all if there was a raw pointer poll version that didn't assert uniqueness and/or narrow provenance?</p>\n</blockquote>\n<p>I don't think that would help because all Future implementors are (AIUI) in a shared ecosystem and must all interoperate. It's not... clear how you could define a \"new\" \"lower level\" API under that</p>",
        "id": 276551215,
        "sender_full_name": "Gankra",
        "timestamp": 1648163456
    },
    {
        "content": "<p>To be clear, the interface of the Future trait is not the only reason it is not really possible for futures. Another issue comes up when you require all stack-allocated nodes to be defined using your own fancy macro so your macro can create a \"root\" reference and prevent the user from creating new references in the future. The issue there is that you can no longer \"compose\" these kinds of types together, similar to how there are various combinators for futures and streams, since now the macro would be used on the full struct and not the field.</p>\n<p>Maybe you can get around it by requiring that all such combinators access the field only with the <code>addr_of!</code> macro and other such hackery, but it gets a lot more complicated than pin-projection is today.</p>\n<p>Another potential issue is that when the destructor runs, it will create a new reference to the variable, invalidating the old one. Though you can probably get around that by putting the destructor on a wrapper struct around the reference rather than on the struct itself.</p>",
        "id": 276680686,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648243553
    },
    {
        "content": "<p>Hmm, I'm sort of tempted to go and write a library for semi-safe intrusive linked lists. It might make this conversation easier to have in a concrete way</p>",
        "id": 276681579,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648244173
    },
    {
        "content": "<p>The real problem with it though isn't the safe interface for stack allocated stuff, but for heap allocated stuff. You somehow have to know when to free it... Brinstorming time ig</p>",
        "id": 276681986,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648244294
    },
    {
        "content": "<p>If you can heap allocate all the nodes, then it's \"easy\" to do intrusive lists. Just make sure that all pointers you store long-term are derived from the original pointer you got from malloc without going through any references.</p>",
        "id": 276682494,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648244638
    },
    {
        "content": "<p><a href=\"https://docs.rs/intrusive-collections/0.9.3/intrusive_collections/\">This</a> exists, but it's sort of very unsound under <code>-Zmiri-tag-raw-pointers</code>. This is also not fixable for that crate as far as I can tell, because the \"scoped collections\" example on that page just cannot be made to work</p>",
        "id": 276685063,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648246010
    },
    {
        "content": "<p>I made <a href=\"https://docs.rs/pinned-aliasable\">the pinned-aliasable</a> crate a while back which was intended to help with this situation. Your code would be unsound but wouldn't miscompile as long as Miri passes.</p>",
        "id": 276686485,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1648246786
    },
    {
        "content": "<blockquote>\n<p>There is one final snag: Miri. Miri is a tool for running your Rust code and dynamically checking whether it is sound or not. If we used the main implementation of this crate under Miri, it would report all kinds of errors, because what we are doing is fundamentally unsound after all. So instead, when this crate detects that Miri is enabled it switches to a different backend that boxes the value in a way that is totally sound, but isn’t used normally for efficiency reasons.</p>\n</blockquote>\n<p>lol<br>\naside: I thought <a href=\"https://github.com/rust-lang/miri/pull/1952\">https://github.com/rust-lang/miri/pull/1952</a> \"fixed\" that?</p>",
        "id": 276687310,
        "sender_full_name": "Nick12",
        "timestamp": 1648247327
    },
    {
        "content": "<p>How is this</p>\n<blockquote>\n<p>Your code would be unsound but wouldn't miscompile as long as Miri passes.</p>\n</blockquote>\n<p>possibly correct then? If you're doing a lot of cfg(miri) stuff, Miri passing doesn't mean anything.</p>",
        "id": 276687720,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648247677
    },
    {
        "content": "<p>\"it's not actually unsound by the patched rustc spec\"</p>",
        "id": 276687853,
        "sender_full_name": "Talchas",
        "timestamp": 1648247771
    },
    {
        "content": "<p>(but that would be before that miri pull was done)</p>",
        "id": 276687880,
        "sender_full_name": "Talchas",
        "timestamp": 1648247803
    },
    {
        "content": "<p>Also I think it's possible the assumption of \"&amp;mut Aliasable&lt;T&gt; can alias &amp;mut T\" might be wrong</p>\n<p>To quote RalfJ from that PR:</p>\n<blockquote>\n<blockquote>\n<p>But can an &amp;Aliasable or &amp;mut Aliasable coexist with an &amp;mut T (or to a field of T)?</p>\n</blockquote>\n<p>&amp;mut T (with this patch: for T: Unpin) cannot coexist with anything (assuming both pointers are being used). Weakening that guarantee would make it entirely useless for optimizations.</p>\n<p>But &amp;mut T can be reborrowed from &amp;mut Aliasable&lt;T&gt;, as long as for the time that the &amp;mut T is active, no other reference/pointer to that memory is used.</p>\n</blockquote>",
        "id": 276687912,
        "sender_full_name": "Nick12",
        "timestamp": 1648247835
    },
    {
        "content": "<p>on a related note I was recently surprised to learn that miri has somehow found a way to semantically use ptr::Unique? Does anyone have a good resource for what it's interpretation is? I added it to std as a vague idea, and my coworker was asking what it did over NonNull and all I could do was shrug.</p>",
        "id": 276688331,
        "sender_full_name": "Gankra",
        "timestamp": 1648248145
    },
    {
        "content": "<p>(seemingly if you take a ref to the pointee it would have the same semantics as if it was a raw pointer)</p>",
        "id": 276688420,
        "sender_full_name": "Gankra",
        "timestamp": 1648248226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I meant to ask this at the time you posted it, but never got around to it. Are you able to elaborate on what exactly you mean in the text that <span class=\"user-mention\" data-user-id=\"219940\">@Nick12</span> quoted?</p>",
        "id": 276688866,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648248572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> Skimming code I could only find this FIXME: <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_middle/src/ty/layout.rs#L2569-L2576\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_middle/src/ty/layout.rs#L2569-L2576</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">                </span><span class=\"c1\">// FIXME(eddyb) This should be for `ptr::Unique&lt;T&gt;`, not `Box&lt;T&gt;`.</span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pointee</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span>::<span class=\"n\">Adt</span><span class=\"p\">(</span><span class=\"n\">def</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"p\">.</span><span class=\"n\">ty</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">def</span><span class=\"p\">.</span><span class=\"n\">is_box</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">.</span><span class=\"n\">bytes</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"n\">pointee</span><span class=\"p\">.</span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">PointerKind</span>::<span class=\"n\">UniqueOwned</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But I can give you this RalfJ quote from 2020 <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/258\">https://github.com/rust-lang/unsafe-code-guidelines/issues/258</a></p>\n<blockquote>\n<blockquote>\n<p>I don't believe Stacked Borrows special cases Unique</p>\n</blockquote>\n<p>Indeed it does not. That is an extension I hope I will be able to support eventually, and at that point I think Box will not be special-cased any more, but Unique will. Though as you said Unique does not imply dereferencable so Box probably still needs to be special-cased a bit.</p>\n</blockquote>",
        "id": 276692005,
        "sender_full_name": "Nick12",
        "timestamp": 1648251461
    },
    {
        "content": "<p>Is it just Dereferenceable?</p>",
        "id": 276692317,
        "sender_full_name": "Gankra",
        "timestamp": 1648251773
    },
    {
        "content": "<p>I think it's supposed to be noalias</p>",
        "id": 276693055,
        "sender_full_name": "Nick12",
        "timestamp": 1648252513
    },
    {
        "content": "<p>I'm pretty sure Box gets noalias but if someone could point out the code where that happens, would be very cool</p>",
        "id": 276693557,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648252955
    },
    {
        "content": "<p>But also, I have no idea why</p>",
        "id": 276693563,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648252967
    },
    {
        "content": "<p>the <code>PointerKind::UniqueOwned</code> above is what make it <code>noalias</code></p>",
        "id": 276693820,
        "sender_full_name": "cuviper",
        "timestamp": 1648253325
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/d53246fedde4c193eae8a003546a8f0f9f85d223/compiler/rustc_middle/src/ty/layout.rs#L3120-L3124\">https://github.com/rust-lang/rust/blob/d53246fedde4c193eae8a003546a8f0f9f85d223/compiler/rustc_middle/src/ty/layout.rs#L3120-L3124</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">                    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">no_alias</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">PointerKind</span>::<span class=\"n\">Shared</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PointerKind</span>::<span class=\"n\">UniqueBorrowed</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">PointerKind</span>::<span class=\"n\">UniqueOwned</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">PointerKind</span>::<span class=\"n\">Frozen</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">is_return</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276693860,
        "sender_full_name": "cuviper",
        "timestamp": 1648253379
    },
    {
        "content": "<p>is the implication basically \"if you want to hold onto raw pointers to this you  must Box::into_raw first?\". because having a noalias pointer has no practical consequences if you're taking shared/mutable refs to the pointee, right? because they essentially introduce that same claim?</p>",
        "id": 276694885,
        "sender_full_name": "Gankra",
        "timestamp": 1648254427
    },
    {
        "content": "<p>it <em>feels</em> like that's just already true because Deref is the only API to access the pointee of a Box (DerefMove magic aside), and that's defined in terms of references, so there's no way to go through the Box pointer without accidentally claiming noalias and invalidating everything pointing into it?</p>",
        "id": 276695064,
        "sender_full_name": "Gankra",
        "timestamp": 1648254652
    },
    {
        "content": "<p>So tbh this kinda just feels like Dereferencable is the only practical implication, idk</p>",
        "id": 276695082,
        "sender_full_name": "Gankra",
        "timestamp": 1648254687
    },
    {
        "content": "<p>The implication is that if you move a Box, you invalidate all pointers into it</p>",
        "id": 276695296,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648254967
    },
    {
        "content": "<p>&amp;mut technically has the same behavior, but people want to treat Box as a stable pointer to an allocation, but that's at least a dangerously misleading characterization under SB</p>",
        "id": 276695362,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255078
    },
    {
        "content": "<p>HUH</p>",
        "id": 276695422,
        "sender_full_name": "Gankra",
        "timestamp": 1648255114
    },
    {
        "content": "<p>Well, under SB with this bizarre addition</p>",
        "id": 276695431,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255124
    },
    {
        "content": "<p>I guess that technically has to be true for move semantics to be coherent since it can result in a Drop you can't see</p>",
        "id": 276695446,
        "sender_full_name": "Gankra",
        "timestamp": 1648255145
    },
    {
        "content": "<p>no it doesn't</p>",
        "id": 276695462,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255167
    },
    {
        "content": "<p>You can write an owning pointer that does not have this property</p>",
        "id": 276695476,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255187
    },
    {
        "content": "<p>If you try to implement your own Box, that's what you get</p>",
        "id": 276695483,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255200
    },
    {
        "content": "<p>The standard library just chooses to provide a more dangerous tool</p>",
        "id": 276695577,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276695064\">said</a>:</p>\n<blockquote>\n<p>it <em>feels</em> like that's just already true because Deref is the only API to access the pointee of a Box (DerefMove magic aside), and that's defined in terms of references, so there's no way to go through the Box pointer without accidentally claiming noalias and invalidating everything pointing into it?</p>\n</blockquote>\n<p>This certainly calls into question whether or not that decision was worthwhile, tbh, since this makes sense to me.</p>",
        "id": 276695854,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648255563
    },
    {
        "content": "<p>I really do not think that Box aliasing optimizations are valuable. Wouldn't mind being proven wrong. But I would grumble mightily if someone checked in code that used Box on an interface boundary instead of &amp; or &amp;mut.</p>",
        "id": 276696002,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255805
    },
    {
        "content": "<p>If it is, I want examples of it being impactful added to my wishlist of motivating examples for SB.</p>",
        "id": 276696052,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648255905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276695064\">said</a>:</p>\n<blockquote>\n<p>it <em>feels</em> like that's just already true because Deref is the only API to access the pointee of a Box (DerefMove magic aside), and that's defined in terms of references, so there's no way to go through the Box pointer without accidentally claiming noalias and invalidating everything pointing into it?</p>\n</blockquote>\n<p>But does LLVM know all that, if we don't mark the box pointer <code>noalias</code>?</p>",
        "id": 276696873,
        "sender_full_name": "cuviper",
        "timestamp": 1648256980
    },
    {
        "content": "<p>The docs on <code>PointerKind::UniqueOwned</code> specifically mention returns, and LLVM says this:</p>\n<blockquote>\n<p>For function return values, C99’s restrict is not meaningful, while LLVM’s noalias is. Furthermore, the semantics of the noalias attribute on return values are stronger than the semantics of the attribute when used on function arguments. On function return values, the noalias attribute indicates that the function acts like a system memory allocation function, returning a pointer to allocated storage disjoint from the storage for any other object accessible to the caller.</p>\n</blockquote>",
        "id": 276696949,
        "sender_full_name": "cuviper",
        "timestamp": 1648257037
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">addr_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>appears to not invoke Deref, so in that sense you can dodge &amp;T. (Though this is sorta a variant of DerefMove magic)</p>",
        "id": 276696950,
        "sender_full_name": "Talchas",
        "timestamp": 1648257037
    },
    {
        "content": "<p>i am thinking in terms of Stacked Borrows here and not llvm</p>",
        "id": 276696952,
        "sender_full_name": "Gankra",
        "timestamp": 1648257044
    },
    {
        "content": "<p>ok -- if you answer that in SB, does that produce the same actionable knowledge for LLVM?</p>",
        "id": 276697021,
        "sender_full_name": "cuviper",
        "timestamp": 1648257136
    },
    {
        "content": "<p>barring llvm bugs, all references should be noalias, right?</p>",
        "id": 276697116,
        "sender_full_name": "Gankra",
        "timestamp": 1648257277
    },
    {
        "content": "<p>except for interior mutability, i.e. references to <code>!Freeze</code> types</p>",
        "id": 276697139,
        "sender_full_name": "cuviper",
        "timestamp": 1648257326
    },
    {
        "content": "<p>but <code>Box</code> is not a reference, so I don't really understand you</p>",
        "id": 276697212,
        "sender_full_name": "cuviper",
        "timestamp": 1648257403
    },
    {
        "content": "<p>IIUC <code>noalias</code> mostly pertains to accesses, and to access the data in the box, you have to go through &amp;T or &amp;mut T, which are references, no?</p>",
        "id": 276697304,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648257519
    },
    {
        "content": "<p>Sort of like we're applying noalias at the last minute</p>",
        "id": 276697321,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648257547
    },
    {
        "content": "<p>But perhaps thats not how it happens.</p>",
        "id": 276697324,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648257555
    },
    {
        "content": "<p>I am saying that if you have &amp;mut MyBox&lt;T&gt; and do my_box.val = 0, then you went through DerefMut, which made an &amp;mut T and therefore did a mega aliasing/derefencability assert for llvm</p>",
        "id": 276697415,
        "sender_full_name": "Gankra",
        "timestamp": 1648257676
    },
    {
        "content": "<p>If we ignore DerefMove magic then this is also definitely true for by-val box</p>",
        "id": 276697474,
        "sender_full_name": "Gankra",
        "timestamp": 1648257731
    },
    {
        "content": "<p>I copied the aliasable box from <a href=\"https://crates.io/crates/aliasable\">https://crates.io/crates/aliasable</a> and wrote a dumb test function in godbolt: <a href=\"https://godbolt.org/z/jfEYTa8rc\">https://godbolt.org/z/jfEYTa8rc</a><br>\nIt looks like the std box gets optimizations the other one doesn't, but I don't really know if this is because of some <em>other</em> attribute than noalias that is lost or if it's just that llvm can't figure it out despite the optimization being technically allowed</p>",
        "id": 276697916,
        "sender_full_name": "Nick12",
        "timestamp": 1648258344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> that's not quite right; <code>noalias</code> is something that goes on function arguments. As far as I know we don't emit any aliasing metadata for references created inside the function body</p>",
        "id": 276698342,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648258988
    },
    {
        "content": "<p>Also, under SB without the Unique rule</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is allowed to alias</p>",
        "id": 276698511,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648259266
    },
    {
        "content": "<p>Those are both good academic examples, but I would reject Nick's in code review and the replacement has only one <code>Box</code> on the interface, and thus all the aliasing is stipulated by <code>&amp;mut</code>.</p>",
        "id": 276698673,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648259511
    },
    {
        "content": "<blockquote>\n<p>allowed to alias</p>\n</blockquote>\n<p>Because even if the deref created a &amp;mut, the tag for the Box ptr and the <code>b</code> ptr are the same? And obviously creating a &amp;mut from the box ptr doesn't invalidate it's tag/provenance</p>",
        "id": 276698728,
        "sender_full_name": "Nick12",
        "timestamp": 1648259574
    },
    {
        "content": "<p>Nick - yes</p>",
        "id": 276698794,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648259676
    },
    {
        "content": "<p>Saethlin - I agree, this doesn't on its own justify a need for this rule. I was just making the point that deref doesn't make this redundant</p>",
        "id": 276698857,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648259771
    },
    {
        "content": "<p>great example, thanks!</p>",
        "id": 276701051,
        "sender_full_name": "Gankra",
        "timestamp": 1648262864
    },
    {
        "content": "<p>hmm actually wait</p>",
        "id": 276701053,
        "sender_full_name": "Gankra",
        "timestamp": 1648262872
    },
    {
        "content": "<p>kinda unclear how it's possible to get a *mut into a Box without having introduced an intermediary ref</p>",
        "id": 276701099,
        "sender_full_name": "Gankra",
        "timestamp": 1648262902
    },
    {
        "content": "<p>I guess with some into_raw shenanigans?</p>",
        "id": 276701104,
        "sender_full_name": "Gankra",
        "timestamp": 1648262916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276701099\">said</a>:</p>\n<blockquote>\n<p>kinda unclear how it's possible to get a *mut into a Box without having introduced an intermediary ref</p>\n</blockquote>\n<p><code>Box::from_raw</code></p>",
        "id": 276701105,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648262928
    },
    {
        "content": "<p>yeah</p>",
        "id": 276701117,
        "sender_full_name": "Gankra",
        "timestamp": 1648262967
    },
    {
        "content": "<p><em>mildly</em> contrived but doable</p>",
        "id": 276701119,
        "sender_full_name": "Gankra",
        "timestamp": 1648262978
    },
    {
        "content": "<p>Well, yes, but optimizations can't distinguish between contrived and non-contrived code</p>",
        "id": 276701171,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648263021
    },
    {
        "content": "<p>The options are only \"UB\" or \"not UB\"</p>",
        "id": 276701176,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648263034
    },
    {
        "content": "<p>totally, and we should be airtight, but also I'm willing to recognize a difference between \"this can technically happen but is unlikely in practice\" and \"this happens all the time\"</p>",
        "id": 276701572,
        "sender_full_name": "Gankra",
        "timestamp": 1648263675
    },
    {
        "content": "<p>(a lot of std safety is sadly the former...)</p>",
        "id": 276701576,
        "sender_full_name": "Gankra",
        "timestamp": 1648263698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Intrusive.20Linked.20Lists.20in.20SB/near/276688866\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I meant to ask this at the time you posted it, but never got around to it. Are you able to elaborate on what exactly you mean in the text that <span class=\"user-mention silent\" data-user-id=\"219940\">Nick12</span> quoted?</p>\n</blockquote>\n<p>basically in code like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">uwu</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>we have UB if <code>x</code> and <code>y</code> alias. this is <em>despite</em> the fact that \"raw pointer are allowed to alias\". yes they are, but mutable references are not, and when two pointers are used to access overlapping regions of memory <em>both</em> have to consent for that to be legal.<br>\nthe situation is similar with <code>fn owo(x: &amp;mut u8, y: &amp;mut Aliasable&lt;u8&gt;)</code>.</p>",
        "id": 276733857,
        "sender_full_name": "RalfJ",
        "timestamp": 1648312134
    },
    {
        "content": "<p>but it is totally fine to do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">uwu</span><span class=\"p\">(</span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>since yes they alias but \"while <code>x</code> lives, no other pointer to this memory is used\". that is what I meant with the last part of my statement, \"as long as for the time that the &amp;mut T is active, no other reference/pointer to that memory is used\".</p>",
        "id": 276734019,
        "sender_full_name": "RalfJ",
        "timestamp": 1648312339
    }
]