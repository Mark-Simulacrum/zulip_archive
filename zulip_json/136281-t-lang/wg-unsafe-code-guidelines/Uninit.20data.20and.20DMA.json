[
    {
        "content": "<p>Is there a way to create a safe abstractions over DMA transactions without UB ? Let's say I have a [MaybeUninit&lt;u8&gt;; 1024 ] and tell the DMA to fill it, and I would wish to transform it in a &amp;[u8] after it's done, would it be UB to use slice::from_raw_parts ?</p>",
        "id": 189349415,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582922907
    },
    {
        "content": "<p>How would I tell the compiler that the thing is in fact initialized, since it has no idea of a DMA peripheral ?<br>\nSorry if this isn't the right place for this</p>",
        "id": 189349446,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582922936
    },
    {
        "content": "<p>So first of all you would need a fence or memory barrier to ensure the DMA is properly completed as seen by the CPU and compiler. After that sure, slice::from_raw_parts is fine. <code>MaybeUninit&lt;u8&gt;</code>is guaranteed to have the same layout as <code>u8</code>.</p>",
        "id": 189357819,
        "sender_full_name": "Amanieu",
        "timestamp": 1582929219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> You need to use <code>ptr::read_volatile</code> and <code>ptr::write_volatile</code> to access the DMA buffer. I would avoid creating a <code>&amp;[u8]</code>, since it's too easy to do a non-volatile read by mistake. Instead, you should define your own slice equivalent that uses volatile reads/writes for all operations.</p>",
        "id": 189359744,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582930848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> Why would I need volatile operations after the transaction has been completed ?</p>",
        "id": 189359928,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582931018
    },
    {
        "content": "<p>Because optimizing compilers are free to omit and/or reorder reads and writes if the changes cannot be detected on the abstract machine.</p>",
        "id": 189360183,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582931217
    },
    {
        "content": "<p>And the abstract machine has no idea that a DMA transaction is occurring behind the scenes.</p>",
        "id": 189360205,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582931247
    },
    {
        "content": "<p>You don't need volatile once the action is complete. However, you also must not make the &amp;[T] before the action occurs of course.</p>",
        "id": 189360298,
        "sender_full_name": "Lokathor",
        "timestamp": 1582931306
    },
    {
        "content": "<p>Yes, the compiler fence thing, I know</p>",
        "id": 189360327,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582931329
    },
    {
        "content": "<p>I would suggest skipping the MaybeUninit part, if you can</p>",
        "id": 189360386,
        "sender_full_name": "Lokathor",
        "timestamp": 1582931400
    },
    {
        "content": "<p>Just have a zeroed buffer</p>",
        "id": 189360436,
        "sender_full_name": "Lokathor",
        "timestamp": 1582931414
    },
    {
        "content": "<p>That wouldn't make much sense, if I have to zeroed it I might just as well copy the thing myself</p>",
        "id": 189360498,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582931473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> is this UB ?<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9139b07bc1015bfeb286e881602e98ea\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9139b07bc1015bfeb286e881602e98ea\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9139b07bc1015bfeb286e881602e98ea</a><br>\nIf it is, how is that different from the DMA case ?</p>",
        "id": 189360517,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582931515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> the write volatile makes sense, in the sense of only working with raw pointers</p>",
        "id": 189361137,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  the OP still needs volatile operations. If they were to check the DMA flag in a loop, then emit an <code>mfence</code> or whatever, and only then create a slice pointing to memory that is uninitialized or zeroed or whatever, the compiler is still free to const-propagate across the memory barrier.</p>",
        "id": 189361317,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582932243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> well if miri says it's fine i guess it's fine. But it sure looks to me like that code makes a reference into uninit memory</p>",
        "id": 189361505,
        "sender_full_name": "Lokathor",
        "timestamp": 1582932370
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> miri is not normative. miri has false negatives ATM.</p>",
        "id": 189361637,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582932447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  It sure does, but it will be the same thing with DMA, i.e. the physical memory would actually be initialized, but the compiler would have no idea about that</p>",
        "id": 189361647,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932455
    },
    {
        "content": "<p>and that code is UB</p>",
        "id": 189361745,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582932506
    },
    {
        "content": "<p>although I don't think we've committed to whether <code>mem::uninitialized::&lt;u8&gt;()</code> will always be UB</p>",
        "id": 189361817,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582932576
    },
    {
        "content": "<p>Yes, I thought so, I will wrap the the buffer and only allow access through volatile operations and raw pointers</p>",
        "id": 189361833,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932593
    },
    {
        "content": "<p>Then it would be okay, right ?</p>",
        "id": 189361897,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> Yes. I might ask the embedded rust discord if there are preexisting libraries for wrapping  a DMA buffer.</p>",
        "id": 189362037,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582932728
    },
    {
        "content": "<p>Hmm, this form of DMA is nothing like the operation I was expecting, honestly.</p>",
        "id": 189362049,
        "sender_full_name": "Lokathor",
        "timestamp": 1582932736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> heh, I came from there, there isn't any as far as a know dealing with uninitialized</p>",
        "id": 189362090,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932789
    },
    {
        "content": "<p>There is actually one PR that does the &amp;[u8] thing, that's why I was questioning myself about this</p>",
        "id": 189362116,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932823
    },
    {
        "content": "<p>I will comment on the thread about this</p>",
        "id": 189362122,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932835
    },
    {
        "content": "<p>How are you calling the DMA anyway?</p>",
        "id": 189362196,
        "sender_full_name": "Lokathor",
        "timestamp": 1582932878
    },
    {
        "content": "<p>Memory Mapped IO</p>",
        "id": 189362207,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932891
    },
    {
        "content": "<p>Just write to a bit on a specific memory location</p>",
        "id": 189362221,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932904
    },
    {
        "content": "<p>And you can check another bit to see if it's done, or activate an interrupt</p>",
        "id": 189362249,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582932935
    },
    {
        "content": "<p>none of the existing DMA code I've seen in the wild uses volatile</p>",
        "id": 189362486,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933110
    },
    {
        "content": "<p>Isn't there a freeze type method to say to the compiler that I don't care that it's just random bits, just read it and don't throw it away ?</p>",
        "id": 189362509,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933134
    },
    {
        "content": "<p>I believe LLVM has something like that, but Rust doesn't expose it atm</p>",
        "id": 189362546,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> this is true, I wonder if we are swinging in UB<br>\nEdit: regarding the volatile</p>",
        "id": 189362565,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933178
    },
    {
        "content": "<p>LLVM just barely added it</p>",
        "id": 189362566,
        "sender_full_name": "Lokathor",
        "timestamp": 1582933178
    },
    {
        "content": "<p>our version of LLVM doesn't have it i think</p>",
        "id": 189362639,
        "sender_full_name": "Lokathor",
        "timestamp": 1582933221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> what do they use? Maybe my reading of <code>compiler_fence</code> is too conservative? Does it forbid omitting reads as well as reordering like <code>asm volatile(\"\" ::: \"memory\");</code> would in C?</p>",
        "id": 189362703,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582933298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> so you write a pointer to X register, write a value to Y register to copy N bytes, and then read Z until it's done?</p>",
        "id": 189362709,
        "sender_full_name": "Lokathor",
        "timestamp": 1582933306
    },
    {
        "content": "<p>Yep</p>",
        "id": 189362767,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933364
    },
    {
        "content": "<p>Pretty much</p>",
        "id": 189362775,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933375
    },
    {
        "content": "<p>All volatile operations on MMIO, of course</p>",
        "id": 189362802,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> DMA code usually just uses a compiler fence and maybe an <code>UnsafeCell</code> around the buffer or its elements</p>",
        "id": 189362868,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933464
    },
    {
        "content": "<p>Yeah okay that's basically what I expected now that you put it that way</p>",
        "id": 189362892,
        "sender_full_name": "Lokathor",
        "timestamp": 1582933497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> which implementation uses <code>UnsafeCell</code> ?</p>",
        "id": 189362916,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> The one in stm32-usbd uses <code>VolatileCell</code> <a href=\"https://github.com/stm32-rs/stm32-usbd/blob/master/src/endpoint_memory.rs\" target=\"_blank\" title=\"https://github.com/stm32-rs/stm32-usbd/blob/master/src/endpoint_memory.rs\">https://github.com/stm32-rs/stm32-usbd/blob/master/src/endpoint_memory.rs</a></p>",
        "id": 189362934,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933539
    },
    {
        "content": "<p>Then accessing the buffer shouldn't need volatile</p>",
        "id": 189362938,
        "sender_full_name": "Lokathor",
        "timestamp": 1582933543
    },
    {
        "content": "<p>just the fence after the DMA completes, and then it's all normal memory after that</p>",
        "id": 189363015,
        "sender_full_name": "Lokathor",
        "timestamp": 1582933595
    },
    {
        "content": "<p>That specific one should be fine I guess</p>",
        "id": 189363021,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933607
    },
    {
        "content": "<p>The <code>&amp;'static mut</code> worries me a little, does that still allow an <code>UnsafeCell</code> to change behind the compiler's back?</p>",
        "id": 189363044,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> how if the compiler decides to not read the thing after the compiler fence since it thinks it's all zeros ?</p>",
        "id": 189363051,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933647
    },
    {
        "content": "<p>Does compiler fence prevent that ?</p>",
        "id": 189363063,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933670
    },
    {
        "content": "<p>I'd <em>really</em> expect a function that's documented to \"restrict the kinds of memory re-ordering the compiler is allowed to do\" to also affect const prop though</p>",
        "id": 189363144,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933750
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> Oh, yes the USB one, it's not really using the DMA peripheral but it's the same principle</p>",
        "id": 189363155,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933774
    },
    {
        "content": "<p>Doesn't the USB peripheral have built-in DMA or something?</p>",
        "id": 189363172,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933797
    },
    {
        "content": "<p>(Currently bringing up USB on the nRF52840, so all of this is pretty relevant)</p>",
        "id": 189363236,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933844
    },
    {
        "content": "<p>In the stm case it has an arbiter which moderates the accesses of the USB peripheral and the core</p>",
        "id": 189363237,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933848
    },
    {
        "content": "<p>The USB memory is in another place, reserved to it</p>",
        "id": 189363255,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933870
    },
    {
        "content": "<p>Right, but mapped to the CPU bus. So effectively this is just DMA with a slightly weirder memory setup.</p>",
        "id": 189363269,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582933905
    },
    {
        "content": "<p>Effectively, yes, the USB peripheral does the writing to the memory</p>",
        "id": 189363334,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582933949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> all of this is because I'm trying to do USB with uninit buffers, but the end_point trait expects a <code>&amp;mut [u8]</code> to write to it</p>",
        "id": 189363446,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934080
    },
    {
        "content": "<p>And I was worrying about creating a slice to a uninit thing, quite a show stopper</p>",
        "id": 189363497,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934159
    },
    {
        "content": "<p>Just wished uninitialized <code>u8</code> was fine</p>",
        "id": 189363561,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> Since you've already been to the discord channel, you've probably already read <a href=\"https://docs.rust-embedded.org/embedonomicon/dma.html#compiler-misoptimizations\" target=\"_blank\" title=\"https://docs.rust-embedded.org/embedonomicon/dma.html#compiler-misoptimizations\">the book</a>. They seem to be very careful to do only volatile writes in addition to the memory barriers.</p>",
        "id": 189363581,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582934232
    },
    {
        "content": "<p>I read it some time ago, but don't they just hand the &amp;[u8] back to the user afterwards ?</p>",
        "id": 189363665,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934349
    },
    {
        "content": "<p>Then the user is free do read/write to it the way they want</p>",
        "id": 189363675,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> you escaped a pointer to a buffer to the wild world and then did a memory fence, it can't assume the buffer is still anything</p>",
        "id": 189363733,
        "sender_full_name": "Lokathor",
        "timestamp": 1582934403
    },
    {
        "content": "<p>Ah, I thought they were copying it out.</p>",
        "id": 189363754,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582934414
    },
    {
        "content": "<p>Copy is no good, heh, that's why they are using DMA in the first place</p>",
        "id": 189363810,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934468
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> that seems plausible, apart from the outside world part, to rust it's just another address on memory</p>",
        "id": 189363890,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934527
    },
    {
        "content": "<p>Well if <code>compiler_fence</code> also declares \"arbitrary-side effects may have occurred\" then it's fine to just create a <code>&amp;[u8]</code>. I've not read anything that explicitly states this, but it seems like it's maybe implicit/obvious?</p>",
        "id": 189363906,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582934548
    },
    {
        "content": "<p>Not to me obviously.</p>",
        "id": 189363920,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582934563
    },
    {
        "content": "<p>There has to be some way we can give a <code>&amp;[u8]</code> back to the user though, otherwise DMA would become a total nuisance in all APIs</p>",
        "id": 189363922,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582934565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> I really don't like \"implicit\" things</p>",
        "id": 189363976,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934627
    },
    {
        "content": "<p>Nor do I.</p>",
        "id": 189363987,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582934636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> volatile means \"special spooky actions happen here, you must do it exactly as often as i say\"</p>",
        "id": 189364052,
        "sender_full_name": "Lokathor",
        "timestamp": 1582934675
    },
    {
        "content": "<p>That's the thing, if we give &amp;[u8] back to the user they sure won't be using volatile_read</p>",
        "id": 189364098,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934729
    },
    {
        "content": "<p>Volatile is still greatly restricted in what those special things can do, it isn't total chaos, but it's allowed to do side effects the compiler doesn't see</p>",
        "id": 189364177,
        "sender_full_name": "Lokathor",
        "timestamp": 1582934769
    },
    {
        "content": "<p>that's the whole point of the attribute</p>",
        "id": 189364188,
        "sender_full_name": "Lokathor",
        "timestamp": 1582934787
    },
    {
        "content": "<p>You can't have a <code>&amp;[u8]</code> because the compiler assumes no aliasing. This is false since DMA has a reference to the buffer.</p>",
        "id": 189364202,
        "sender_full_name": "Amanieu",
        "timestamp": 1582934804
    },
    {
        "content": "<p>Basically you need to construct the slice after the DMA has complete and you have issued your fence.</p>",
        "id": 189364229,
        "sender_full_name": "Amanieu",
        "timestamp": 1582934833
    },
    {
        "content": "<p>The <code>&amp;[u8]</code> would of course only exist when DMA is not running</p>",
        "id": 189364231,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582934834
    },
    {
        "content": "<p>Then no problem.</p>",
        "id": 189364240,
        "sender_full_name": "Amanieu",
        "timestamp": 1582934843
    },
    {
        "content": "<p>Yeah, that's what I'm thinking</p>",
        "id": 189364243,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582934845
    },
    {
        "content": "<p>But it's not constructed, it's given back</p>",
        "id": 189364259,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934875
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> FWIW the docs of <code>compiler_fence</code> pretty clearly say \"with Acquire, subsequent reads and writes cannot be moved ahead of preceding reads\" and that's essentially the fundamental guarantee we need</p>",
        "id": 189364265,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582934881
    },
    {
        "content": "<p>But it doesn't say it can't be omitted</p>",
        "id": 189364336,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582934917
    },
    {
        "content": "<p>Ugh, is that really going to be an issue?</p>",
        "id": 189364378,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582934965
    },
    {
        "content": "<p>Let's say we have a zeroed buffer, the compiler knows it's zeroed, then we DMA into the buffer, and after the whole thing is complete we ask it for buffer[0]</p>",
        "id": 189364467,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582935011
    },
    {
        "content": "<p>The compiler is sure that this would return zero, what would it do the read?</p>",
        "id": 189364501,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582935043
    },
    {
        "content": "<p>Yeah...</p>",
        "id": 189364510,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582935055
    },
    {
        "content": "<p>I meant to be joking when I said \"another week another soundness issue\" last week, but it looks like this is really going to continue indefinitely</p>",
        "id": 189364513,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582935060
    },
    {
        "content": "<p>We should create a <code>DmaSlice</code> type and spread it over the ecosystem</p>",
        "id": 189364643,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582935184
    },
    {
        "content": "<p>Is there a <code>volatile_copy_nonoverlapping</code> operation ? Heh</p>",
        "id": 189364678,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582935236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> <a href=\"https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\" target=\"_blank\" title=\"https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\">This is the relevant section of the LLVM refererence</a>, which defines the semantics of happens-before.</p>",
        "id": 189364733,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582935259
    },
    {
        "content": "<p>This will probably poison all APIs that transitively call DMA functions, and greatly affect performance too</p>",
        "id": 189364745,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582935283
    },
    {
        "content": "<p>Well, unless it's read-only DMA</p>",
        "id": 189364758,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582935300
    },
    {
        "content": "<blockquote>\n<p>Given that definition, Rbyte is defined as follows:</p>\n<p>If R is volatile, the result is target-dependent. (Volatile is supposed to give guarantees which can support sig_atomic_t in C/C++, and may be used for accesses to addresses that do not behave like normal memory. It does not generally provide cross-thread synchronization.)</p>\n<p>Otherwise, if there is no write to the same byte that happens before Rbyte, Rbyte returns undef for that byte.</p>\n</blockquote>",
        "id": 189364766,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582935306
    },
    {
        "content": "<p>where <code>R</code> is defined as :</p>\n<blockquote>\n<p>Every (defined) read operation (load instructions, memcpy, atomic loads/read-modify-writes, etc.) R reads a series of bytes written by (defined) write operations (store instructions, atomic stores/read-modify-writes, memcpy, etc.). For the purposes of this section, initialized globals are considered to have a write of the initializer which is atomic and happens before any other read or write of the memory in question. For each byte of a read R, Rbyte may see any write to the same byte, except:</p>\n</blockquote>",
        "id": 189364835,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582935383
    },
    {
        "content": "<p>Just have old and crappy DMA that doesn't run as a co-processing unit, like me ;3</p>",
        "id": 189364855,
        "sender_full_name": "Lokathor",
        "timestamp": 1582935427
    },
    {
        "content": "<p>Sure, you need a volatile write to initiate DMA and to read the DMA-complete flag. But apart from that you just need to insert a fence to establish that the write by the DMA engine happens before you reading the result of the DMA.</p>",
        "id": 189365063,
        "sender_full_name": "Amanieu",
        "timestamp": 1582935643
    },
    {
        "content": "<p>You can think of the DMA engine as a separate thread. It uses a store-release on the DMA-complete flag and you use a load-acquire to read it. Then you are free to read the DMA results normally</p>",
        "id": 189365104,
        "sender_full_name": "Amanieu",
        "timestamp": 1582935714
    },
    {
        "content": "<p>Okay, sounds like I'll punt on rewriting half the ecosystem until the UCG WG agrees on this :)</p>",
        "id": 189365154,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582935731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Won't the compiler be allowed to omit a read to the dma Buffer if it thinks it didn't change ?</p>",
        "id": 189365178,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582935781
    },
    {
        "content": "<p>Well Amanieu and I have made basically the same case here</p>",
        "id": 189365187,
        "sender_full_name": "Lokathor",
        "timestamp": 1582935785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> but where's the \"write\" to memory backing the DMA buffer? Won't any non-volatile read be<code>undef</code> since there's no observable write within that thread?</p>",
        "id": 189365188,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582935786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> The write is done by the DMA engine. You have to stretch the definition of a parallel thread of execution to include the DMA engine.</p>",
        "id": 189365271,
        "sender_full_name": "Amanieu",
        "timestamp": 1582935879
    },
    {
        "content": "<p>I'll put that under \"there are platform-specific ways to create them, and we define LLVM IR’s behavior in their presence\"</p>",
        "id": 189365285,
        "sender_full_name": "Amanieu",
        "timestamp": 1582935900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> , there's no write anywhere in any part of the rust abstraction machine</p>",
        "id": 189365287,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582935902
    },
    {
        "content": "<p>It does sound like the compiler would have to <em>prove absence</em> of such writes before it can const prop though, which is not really possible once the buffer address has been written to a register with a volatile_write, right?</p>",
        "id": 189365382,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582936006
    },
    {
        "content": "<p>Does it even know what a DMA is ?</p>",
        "id": 189365402,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936039
    },
    {
        "content": "<p>It doesn't need to, it is just treated as FFI.</p>",
        "id": 189365425,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936065
    },
    {
        "content": "<p>Does it really ?</p>",
        "id": 189365523,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936154
    },
    {
        "content": "<p>Yes.</p>",
        "id": 189365529,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936160
    },
    {
        "content": "<p>FWIW we also model interrupt handlers as threads, and that model seems to fit them perfectly</p>",
        "id": 189365534,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582936163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> So if a write the address of a &amp;[MaybeUninit&lt;u8&gt;] to a random location with volatile_write can I take a &amp;[u8] to it afterwards without UB ?</p>",
        "id": 189365656,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936256
    },
    {
        "content": "<p>If it treats it like a FFI it won't assume that isn't uninit and throw it away, right ?</p>",
        "id": 189365732,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936332
    },
    {
        "content": "<p>You need a fence. Otherwise the compiler will assume the contents haven't changed and are still uninitialized.</p>",
        "id": 189365735,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936339
    },
    {
        "content": "<p>Yeah yeah, with a fence too</p>",
        "id": 189365746,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936352
    },
    {
        "content": "<p>Then, would it be okay (no UB) even without no DMA present ?</p>",
        "id": 189365770,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936385
    },
    {
        "content": "<p>Well technically you still need someone at the other end to actually initialize the memory for it to be valid.</p>",
        "id": 189365846,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936452
    },
    {
        "content": "<p>Everything is valid for an u8 no ?</p>",
        "id": 189365857,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> To clarify, you're saying that after a <code>fence</code> instruction, the compiler must assume that <em>all</em> memory may have been written from another thread of execution and thus is no longer <code>undef</code>?</p>",
        "id": 189365869,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582936485
    },
    {
        "content": "<p>Or just heap memory?</p>",
        "id": 189365885,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582936491
    },
    {
        "content": "<p>Anything whose address may be visible to other threads of execution.</p>",
        "id": 189365913,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936520
    },
    {
        "content": "<p>Or just memory whose address is published?</p>",
        "id": 189365921,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582936525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> I think he is also saying that the address would have to be written somewhere with a volatile to emulate a ffi</p>",
        "id": 189365928,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936532
    },
    {
        "content": "<p>Yes, that.</p>",
        "id": 189365931,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936532
    },
    {
        "content": "<p>Ah, okay. How do I know when an address is published?</p>",
        "id": 189365948,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582936560
    },
    {
        "content": "<p>(I'd love to continue this discussion but it's getting late)</p>",
        "id": 189366022,
        "sender_full_name": "Amanieu",
        "timestamp": 1582936609
    },
    {
        "content": "<p>some sort of escape analysis perhaps?</p>",
        "id": 189366026,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1582936612
    },
    {
        "content": "<p>That would fix my initial problem at least...</p>",
        "id": 189366046,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582936645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> np, I'll check the LLVM docs</p>",
        "id": 189366048,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582936647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> So the term I was looking for is \"pointer capture\". When you take the address of your DMA buffer and write it to the MMIO register used to initiate DMA transfer, that pointer becomes captured and the buffer escapes the current thread of execution. Since you have a single-threaded fence after the you write the address, the compiler cannot reorder any subsequent reads of the buffer before the point at which the pointer was captured, and it can no longer assume that their value (whether <code>0</code> or <code>undef</code>) is known.</p>",
        "id": 189366970,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582937656
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> when you volatile write the address to a location outside of any location LLVM is using, you've published it</p>",
        "id": 189366977,
        "sender_full_name": "Lokathor",
        "timestamp": 1582937677
    },
    {
        "content": "<p>oh zullip didn't update at first, you already got it</p>",
        "id": 189367010,
        "sender_full_name": "Lokathor",
        "timestamp": 1582937711
    },
    {
        "content": "<p>Thanks all! I learned things today.</p>",
        "id": 189367251,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582938007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  what random memory can I write to emulate this ? Would it have to be out of ram ?</p>",
        "id": 189367302,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582938091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> (writing it to) any non-stack address that you didn't get from <code>malloc</code> should cause the pointer to be marked as captured. Capture tracking is itself not precise, so it's not possible to say precisely what locations won't cause a pointer to become captured when they are written to.</p>",
        "id": 189367502,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582938317
    },
    {
        "content": "<p><a href=\"https://llvm.org/doxygen/CaptureTracking_8cpp_source.html\" target=\"_blank\" title=\"https://llvm.org/doxygen/CaptureTracking_8cpp_source.html\">https://llvm.org/doxygen/CaptureTracking_8cpp_source.html</a></p>",
        "id": 189367509,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582938325
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span>   You can't just write to random memory XD that's also not allowed</p>",
        "id": 189367523,
        "sender_full_name": "Lokathor",
        "timestamp": 1582938346
    },
    {
        "content": "<p>(is what I'm reading ATM)</p>",
        "id": 189367556,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1582938363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> well, not random, but precisely chosen to not cause side effects</p>",
        "id": 189367670,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582938507
    },
    {
        "content": "<p>the semantics of volatile are not only specific to a general build target, they're specific to the device. on any device with an OS and a memory management unit, you'll run afoul of the MMU</p>",
        "id": 189367692,
        "sender_full_name": "Lokathor",
        "timestamp": 1582938549
    },
    {
        "content": "<p>Good thing I don't have a MMU heh</p>",
        "id": 189367703,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582938584
    },
    {
        "content": "<p>;3</p>",
        "id": 189367711,
        "sender_full_name": "Lokathor",
        "timestamp": 1582938592
    },
    {
        "content": "<p>\"consult your datasheets\"</p>",
        "id": 189367766,
        "sender_full_name": "Lokathor",
        "timestamp": 1582938627
    },
    {
        "content": "<p>Thanks all</p>",
        "id": 189368268,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582939340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/189361505\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/189361505\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> well if miri says it's fine i guess it's fine. But it sure looks to me like that code makes a reference into uninit memory</p>\n</blockquote>\n<p>Miri doesnt catch <em>all</em> UB, just a lot of it. Also see <a href=\"https://github.com/rust-lang/miri/\" target=\"_blank\" title=\"https://github.com/rust-lang/miri/\">the README</a>. And also to make it possible to run Miri on more code, Miri currently does not complain about uninitialized integers, or references to uninitialized data.</p>",
        "id": 189382705,
        "sender_full_name": "RalfJ",
        "timestamp": 1582966439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/189365857\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/189365857\">said</a>:</p>\n<blockquote>\n<p>Everything is valid for an u8 no ?</p>\n</blockquote>\n<p>uninitialized memory isn't (maybe -- see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\">https://github.com/rust-lang/unsafe-code-guidelines/issues/71</a>)</p>",
        "id": 189382817,
        "sender_full_name": "RalfJ",
        "timestamp": 1582966634
    },
    {
        "content": "<p>also while \"captured/escaped pointers\" etc are important notions in the compiler, they are not part of the spec, so one has to be very careful when using them to reason about absence of UB...</p>",
        "id": 189382862,
        "sender_full_name": "RalfJ",
        "timestamp": 1582966727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> But won't pointer espace \"trick\" the compiler into thinking that this is fact initialized ?</p>",
        "id": 189391499,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582984986
    },
    {
        "content": "<p>If we can't trust that then we will need to change the entire API for DMA in embedded, and that will bring a lot of overhead and hard to use apis</p>",
        "id": 189391541,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582985073
    },
    {
        "content": "<p>The point is that it's precarious to reason about soundness by thinking of specific code transformations that may \"break your code\" and how those transformations may be blocked by throwing wrenches into (your mental model of) the compiler's internal reasoning. That does not necessarily mean that any particular conclusion you get that way is wrong, just that it's easier to get wrong conclusions.</p>",
        "id": 189394630,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1582990968
    },
    {
        "content": "<p>I understand that this is a fragile reasoning, but I don't see any other way to do DMA in a sensible way, especially mem-to-mem DMA</p>",
        "id": 189395261,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582992213
    },
    {
        "content": "<p>It doesn't make sense to do mem-to-mem DMA without uninitialized data that the compiler has no way to know that it was in fact initialized</p>",
        "id": 189395342,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582992339
    },
    {
        "content": "<p>If the CPU has to initialize the data why use DMA then ?</p>",
        "id": 189395392,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582992408
    },
    {
        "content": "<p>Well, just as an example, ASM doesn't care at all, so you can do DMA by having a C FFI call that actually links to an assembly block that does the copy and returns with the buffer filled and LLVM literally can't tell that it was DMA or CPU.</p>",
        "id": 189396177,
        "sender_full_name": "Lokathor",
        "timestamp": 1582993939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> that's why I think pointer escape is sufficient in this case, the mechanism that makes LLVM drop all assumptions about something that got passed to FFI is pointer escape/capture, or am I wrong ?</p>",
        "id": 189396299,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582994194
    },
    {
        "content": "<p>The DMA engine <em>is</em> another thread from LLVM's point of view. So what you are doing is just standard inter-thread communication.</p>",
        "id": 189396315,
        "sender_full_name": "Amanieu",
        "timestamp": 1582994243
    },
    {
        "content": "<p>you are correct Thales</p>",
        "id": 189396326,
        "sender_full_name": "Lokathor",
        "timestamp": 1582994278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> Note the difference between \"makes LLVM drop all assumptions\" (which btw is arguably wrong as stated) and casting the DMA transfer as a kind of multi-threaded communication. Both ways end at \"this code should be fine\", but the latter rests on specifications giving actual guarantee about how <em>any</em> implementation will behave, regardless of how clever or exotic it is. You don't even <em>need</em> the precarious reasoning to get your goal.</p>",
        "id": 189396588,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1582994755
    },
    {
        "content": "<p>I agree that some semantics I used were very brittle, but that doesn't change the fact that there is no need for an actual DMA transfer to happen to make the code UB-free</p>",
        "id": 189396818,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582995189
    },
    {
        "content": "<p>Uhm, yes? I don't think we ever stated that you needed to literally do a DMA to freeze the memory. There's a few ways you can just freeze memory if that's the goal.</p>",
        "id": 189397078,
        "sender_full_name": "Lokathor",
        "timestamp": 1582995650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> yes, the DMA transfer was the initial goal, but freezing memory is also useful in other contexts, are there other ways to do it without FFI ?</p>",
        "id": 189397144,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582995798
    },
    {
        "content": "<p>Not really, the basic idea is always some form of \"let code outside of LLVM's view edit the memory and LLVM won't know what happened, so if nothing actually happened then the memory is just plain frozen.\"</p>\n<p>Some day LLVM will have a full intrinsic for it, but I think that is currently just in development (last I heard).</p>",
        "id": 189397204,
        "sender_full_name": "Lokathor",
        "timestamp": 1582995936
    },
    {
        "content": "<p>Thanks for all the explanations</p>",
        "id": 189397254,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582996061
    },
    {
        "content": "<p>And as I'm sure Ralf would want me to say: any current way to freeze memory is unspecified and just \"happens to work that way\" status.</p>",
        "id": 189397292,
        "sender_full_name": "Lokathor",
        "timestamp": 1582996084
    },
    {
        "content": "<p>Is there a portable way of doing this ? without the need to link in a C or asm routine that just returns ?</p>",
        "id": 189397497,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582996513
    },
    {
        "content": "<p>Note that \"freezing memory without writing it\" is brittle for reasons beyond just compiler behavior / lack of specification. See e.g. <a href=\"https://github.com/rust-lang/rust/pull/58363#issuecomment-512119241\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/58363#issuecomment-512119241\">https://github.com/rust-lang/rust/pull/58363#issuecomment-512119241</a></p>",
        "id": 189397608,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1582996702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@Hanna Kruppe</span> thanks for the link, it's good information to keep in mind, but it doesn't concern me in this case, since I don't have an OS or even a heap</p>",
        "id": 189397740,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582996947
    },
    {
        "content": "<p>And I sure won't depend on any \"freezed\" value to make sense before I write to it, I just need it to not be UB</p>",
        "id": 189398120,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1582997744
    },
    {
        "content": "<p>Remember that there are platforms where uninitialized memory is tracked at the hardware level. You need to <em>actually write</em> to the memory, otherwise it's still uninitialized.</p>",
        "id": 189400043,
        "sender_full_name": "Amanieu",
        "timestamp": 1583001000
    },
    {
        "content": "<p>One surprising example is Linux: if you use <code>madvise(MADV_FREE)</code> (which jemalloc does), then it's telling the OS that if nobody has written to the page since that syscall, it can be reclaimed and replaced with a zero page. This can happen at <em>any time</em> unless you actually write to the memory.</p>",
        "id": 189400111,
        "sender_full_name": "Amanieu",
        "timestamp": 1583001079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/189396818\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/189396818\">said</a>:</p>\n<blockquote>\n<p>I agree that some semantics I used were very brittle, but that doesn't change the fact that there is no need for an actual DMA transfer to happen to make the code UB-free</p>\n</blockquote>\n<p>that's exactly the point -- this is wrong. unless you are doing something for which the spec says that it freezes memory (which so far isnt possible), then the code <em>does</em> have UB unless something actually initialized that memory (that something can be another device via DMA, sure).<br>\nThis is the kind of UB that cannot bite you unless the compiler can somehow prove that no DMA is going to happen, but it's still UB.<br>\nthe fact that \"pointers were escaped\" doesn't change this -- the spec doesnt have any clause that says \"if the pointer escaped it's not UB\".</p>\n<p>I admit that this might sound like academic nitpicking, but I do think it is important which part of the reasoning here is based on the \"source of truth\" (the spec, which is ideally written without even mentioning a compiler) and which part is based on looking at how current compilers <em>happen to</em> implement the spec.  The latter <em>can</em> lead to correct results, but it can also be very misleading.<br>\nIn this case though it looks like things work out the same either way, so that's good :)</p>",
        "id": 189400242,
        "sender_full_name": "RalfJ",
        "timestamp": 1583001320
    },
    {
        "content": "<p>There was a question regarding pointer capture/escape on the rust-embedded chat, I wasn't sure of the answer so I will ask here.</p>\n<p>The setup is a SPI peripheral reading data of a buffer through DMA. There is a setup stage where the pointer to the buffer gets written to the DMA registers (escaped) and after that a compiler fence. </p>\n<p>After that there will be some computations and writing to this buffer in an interrupt handler and using a compiler fence before asserting the DMA transfer, the buffer never gets read anywhere in the code.</p>\n<p>The question is, the pointer only escapes in the beginning of the program, would this be enough to prevent any writes to the buffer of being omitted throughout the rest of the program or there is a need for <code>write_volatile</code> ? </p>\n<p>There is no concern with reordering apart from the very specific places that will have compiler fences</p>",
        "id": 190059360,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583752869
    },
    {
        "content": "<blockquote>\n<p>There is a setup stage where the pointer to the buffer gets written to the DMA registers (escaped) and after that a compiler fence. </p>\n</blockquote>\n<p>is that a <code>write_volatile</code>?</p>",
        "id": 190062094,
        "sender_full_name": "RalfJ",
        "timestamp": 1583755851
    },
    {
        "content": "<p>Yes, all MMIO interactions use write/read volatile by design</p>",
        "id": 190062191,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583755936
    },
    {
        "content": "<p>The important part of the question is that the setup only occurs once in the beginning, but the buffer will be written (but never read) over and over throughout the course of the program</p>",
        "id": 190062268,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583756027
    },
    {
        "content": "<p>There will be compiler fences after every complete interaction with the buffer to prevent it from getting too postponed</p>",
        "id": 190062361,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583756092
    },
    {
        "content": "<p>So, rust writes to the buffer without reading it  and the DMA unit copies the buffer to some other place periodically?</p>",
        "id": 190112340,
        "sender_full_name": "Lokathor",
        "timestamp": 1583784618
    },
    {
        "content": "<p>Yes, and the rust code changes the buffer in-between the DMA readings</p>",
        "id": 190112600,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583784784
    },
    {
        "content": "<p>with compiler fencing that sounds fine</p>",
        "id": 190112654,
        "sender_full_name": "Lokathor",
        "timestamp": 1583784818
    },
    {
        "content": "<p>Honestly the volatile part probably doesn't really hurt anyway</p>",
        "id": 190112898,
        "sender_full_name": "Lokathor",
        "timestamp": 1583784901
    },
    {
        "content": "<p>Yeah, I also think that, wasn't sure that if rust code keeps writing to it somewhere it would disregard the pointer as escaped and start optimizing out the writes</p>",
        "id": 190112906,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583784902
    },
    {
        "content": "<p>I think the volatile could have a bad effect depending of the amount of data and processing that occurs while filling the buffer</p>",
        "id": 190113169,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583784986
    },
    {
        "content": "<p>But that would have to be measured</p>",
        "id": 190113187,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583784997
    },
    {
        "content": "<p>if you only ever write to the buffer, unless you're writing the same spot more than once, every byte gets written once volatile or not</p>",
        "id": 190137508,
        "sender_full_name": "Lokathor",
        "timestamp": 1583807526
    },
    {
        "content": "<p>There will be multiple writes to the same byte on the buffer, it would work like that:</p>\n<ul>\n<li>First write to the buffer.</li>\n<li>setup stage -&gt; Pointer escape &amp; compiler fence.</li>\n</ul>\n<p>1:</p>\n<ul>\n<li>DMA gets finished.</li>\n<li>Write new data to the whole buffer and compile fence and start DMA</li>\n<li>Jump 1</li>\n</ul>",
        "id": 190138662,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583809320
    },
    {
        "content": "<p>What I'm not sure is that if writes on looping 1 won't get optmized out</p>",
        "id": 190138731,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583809440
    },
    {
        "content": "<p>Maybe the best solution would be to escape the pointer once every loop</p>",
        "id": 190138775,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583809468
    },
    {
        "content": "<p>Optimizing compilers are hard</p>",
        "id": 190138779,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583809479
    },
    {
        "content": "<p>Sorry, I'm speaking specifically about the time between DMA uses.</p>\n<p>Each byte of the buffer is written at most once, and then you do a fence/DMA cycle, then each byte is written at most once again on the next loop, then a fence/DMA cycle, etc.</p>\n<p>If that is the case, then using volatile or not makes no difference.</p>",
        "id": 190140207,
        "sender_full_name": "Lokathor",
        "timestamp": 1583811866
    },
    {
        "content": "<p>That is the case, but the DMA cycle doesn't write the pointer to the buffer to a register anymore, since it isn't required for the peripheral, since it already has the address from the first setup</p>",
        "id": 190140475,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583812337
    },
    {
        "content": "<p>Sure, that's not really related though.</p>\n<p>The issue with using volatile vs non-volatile for the actual buffer filling steps is that volatile must do exactly the count of reads and writes written, and normal reads/writes can elide repeated reads or skip early writes if there's no read before the next write. In other words, normal access can turn two writes into one write by skipping the first write. However, if there is already exactly one write per byte into the buffer, the compiler cannot reduce that any further. Thus, both normal access and volatile access would have exactly 1 write per byte into the buffer. So volatile would have no speed difference.</p>",
        "id": 190140556,
        "sender_full_name": "Lokathor",
        "timestamp": 1583812538
    },
    {
        "content": "<p>Oh, ok, now I understand, you were talking about the performance hit not about the problem with omitted writes</p>",
        "id": 190140655,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583812699
    },
    {
        "content": "<p>Yes, right</p>",
        "id": 190140661,
        "sender_full_name": "Lokathor",
        "timestamp": 1583812715
    },
    {
        "content": "<p>Yes, putting that way it looks like it's much better to not really depend on compiler behavior and use volatile writes</p>",
        "id": 190140675,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583812758
    },
    {
        "content": "<p>Yes, since it can't hurt, just be volatile</p>",
        "id": 190140680,
        "sender_full_name": "Lokathor",
        "timestamp": 1583812780
    },
    {
        "content": "<p>The bad thing would be if that was a lib that hides the implementation and just passes the buffer to the user for the filling etc</p>",
        "id": 190140754,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583812912
    },
    {
        "content": "<p>I mean, not necessarily bad, but cumbersome</p>",
        "id": 190140797,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583812929
    },
    {
        "content": "<p>In that case, I'd possibly just eat the cost of a few cycles and just re-assign the pointer to the buffer to the DMA unit</p>",
        "id": 190140864,
        "sender_full_name": "Lokathor",
        "timestamp": 1583813076
    },
    {
        "content": "<p>In fact I think you'd have to because in calling the closure with a <code>&amp;mut [MyType]</code> arg I'm pretty sure you'd invalidate the existing pointer under the stacked borrow rules (?)</p>",
        "id": 190141111,
        "sender_full_name": "Lokathor",
        "timestamp": 1583813584
    },
    {
        "content": "<p>Hmm, I didn't quite follow, what closure ? A user API ?</p>",
        "id": 190141280,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583813889
    },
    {
        "content": "<p>Yeah, I guess it depends on what sort of API you have. I was thinking something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">use_dma_to_move_buffers</span><span class=\"o\">&lt;</span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">dma</span>: <span class=\"nc\">DMAUnit</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">usize</span>: <span class=\"nc\">count</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Or something where you're prepping a buffer in the lib, then user code fills the buffer, then you send off the buffer. In that case, calling the user code would start moving around a unique reference to the buffer, which would (if I remember my stacked borrows properly) invalidate the pointer that you had to the buffer. And once the pointer is invalidated... does it count as escaped any more? I dunno. Like, I really don't. We'd need some real LLVM wizards to tell us that one.</p>\n<p>But you could probably make _some sort_ of good API that's using DMA, depending on your exact needs. I think that it's probably device specific enough that I wouldn't expect the embedded-wg to be able to have a super suitable abstraction in the embedded-hal crate, for example. Probably it'd be simper to write up a page of suggested guidelines and then each specific device's crate can have functions for doing DMA on that device.</p>",
        "id": 190142937,
        "sender_full_name": "Lokathor",
        "timestamp": 1583817247
    },
    {
        "content": "<p>Yes, now I understand, we cast the pointer to an u32 to write to register, but I guess that even that way it still applies</p>",
        "id": 190143260,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583817903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/190112906\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/190112906\">said</a>:</p>\n<blockquote>\n<p>Yeah, I also think that, wasn't sure that if rust code keeps writing to it somewhere it would disregard the pointer as escaped and start optimizing out the writes</p>\n</blockquote>\n<p>so as mentioned elsewhere, \"escaped pointer\" is not a thing in the Rust spec and thus not terribly useful if you are asking \"what does the compiler have to do per spec\".<br>\nbut if you are asking exclusively about how <em>current</em> Rust <em>happens to</em> think about it, then -- a pointer, once escaped, can never \"unescape\" as long as it remains a raw pointer. (creating a mutable reference is a promise to the compiler that the reference is unique and all potentially escaped aliases will not be used again, so you cannot use references.)</p>",
        "id": 190154397,
        "sender_full_name": "RalfJ",
        "timestamp": 1583832407
    },
    {
        "content": "<p>as far as the spec is concerned, I think of the DMA device as something akin to another thread, and once that thread has access to your memory it can just keep accessing it. and since DMA \"pesudo-threads\" through some magic (that I dont understand but well^^) dont need \"real fences\" (just compiler fences), the fences you have should be enough synchronization to enable proper communication.</p>",
        "id": 190154547,
        "sender_full_name": "RalfJ",
        "timestamp": 1583832544
    },
    {
        "content": "<p>It becomes very target specific because DMA on some devices halts the CPU while it works (similar to an interrupt), and with other devices the DMA is running along side the CPU (similar to a multi-core situation). So \"pseudo-threads\" is probably the best general abstraction.</p>",
        "id": 190197544,
        "sender_full_name": "Lokathor",
        "timestamp": 1583859682
    },
    {
        "content": "<blockquote>\n<p>with other devices the DMA is running along side the CPU (similar to a multi-core situation)</p>\n</blockquote>\n<p>but somehow still in a way that compiler fences are enough, no real fences are needed?</p>",
        "id": 190198782,
        "sender_full_name": "RalfJ",
        "timestamp": 1583860257
    },
    {
        "content": "<p>that is the part that makes little sense to me</p>",
        "id": 190198803,
        "sender_full_name": "RalfJ",
        "timestamp": 1583860270
    },
    {
        "content": "<p>I would say that in a lot of cases you need the memory fence, but that isn't the case for most cortex-m processors</p>",
        "id": 190199946,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583860895
    },
    {
        "content": "<blockquote>\n<p>Omitting the DMB or DSB instruction in the examples in Figure 41 on page 47 and Figure 42 would not cause any error because the Cortex-M processors:</p>\n<p>do not re-order memory transfers</p>\n<p>do not permit two write transfers to be overlapped.</p>\n</blockquote>",
        "id": 190199973,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583860921
    },
    {
        "content": "<blockquote>\n<p>The use of DMB is rarely needed in Cortex-M processors because they do not reorder memory transactions. However, it is needed if the software is to be reused on other ARM processors, especially multi-master systems. </p>\n</blockquote>",
        "id": 190200156,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1583860988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/190199946\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Uninit.20data.20and.20DMA/near/190199946\">said</a>:</p>\n<blockquote>\n<p>I would say that in a lot of cases you need the memory fence, but that isn't the case for most cortex-m processors</p>\n</blockquote>\n<p>ah, fair. so these pseudo-threads have some target-specific rules for whether synchronizing with them requires a hardware fence or just a compiler fence. makes sense.</p>",
        "id": 190201005,
        "sender_full_name": "RalfJ",
        "timestamp": 1583861379
    },
    {
        "content": "<p>when dma runs along side cpu there usually is external fencing i think. for example, when using vulkan to move data to the gpu memory there are fences involved.</p>",
        "id": 190201377,
        "sender_full_name": "Lokathor",
        "timestamp": 1583861547
    }
]