[
    {
        "content": "<p>What is <code>unsafe</code> even for? I know this may seem like a totally deranged question, but please bear with me.<br>\nObviously it confers the power to</p>\n<blockquote>\n<p>Dereference a raw pointer<br>\n    Call an unsafe function or method<br>\n    Access or modify a mutable static variable<br>\n    Implement an unsafe trait<br>\n    Access fields of unions</p>\n</blockquote>\n<p>But what, notionally, is the purpose... and limits... of <code>unsafe</code>? Is it just memory safety? Does it cover all possible UB? What are the limits of Rust's considerations? I raise this question because <code>#[target_feature]</code> seems like it might be implying something subtly different from memory safety. Obviously Rust can technically actually violate memory safety, a la <a href=\"https://crates.io/crates/totally-safe-transmute\">https://crates.io/crates/totally-safe-transmute</a>, but we tend to punt on that because it's an OS provided API. So to what extent is Rust actually <em>allowed</em> to consider the machine it is running on? Whence cometh the consideration of the risk of unsoundness for SIMD instructions but not for <code>totally-safe-transmute</code>?</p>",
        "id": 240110258,
        "sender_full_name": "Jubilee",
        "timestamp": 1621889549
    },
    {
        "content": "<p><code>unsafe</code> covers all forms of UB. <code>target_feature</code> is an interesting case though! If trying to run an instruction on a CPU that doesn't supported just triggered a SIGILL, then <code>unsafe</code> wouldn't be required. However, I think it turned out that, at least in some obscure contexts, new CPU instructions sometimes recycled the opcodes of old CPU instructions, and so running code targetting a certain target feature on a very old CPU could actually run semantically different operations than were intended.</p>",
        "id": 240110517,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621889675
    },
    {
        "content": "<p>I can't remember exactly what, but maybe some very early 16 bit real mode x86 opcodes overlap with some of the new AVX extensions?</p>",
        "id": 240110572,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621889703
    },
    {
        "content": "<p>Oh, there's an example of that up above in the other thread!</p>",
        "id": 240110690,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621889760
    },
    {
        "content": "<p>Then what, philosophically, is undefined behavior, anyways? :^)<br>\nI know, I know, \"prescribed to be unpredictable\", but when <strong>must</strong> Rust insist that the result is unpredictable? Because if we emit aarch64 code, and then you run it on an x86 processor, that's not exactly going to produce more deterministic behavior, nonetheless, at the risk of sounding absurd, we do not actually weigh that, afaik, in our design (it's not <code>unsafe fn main()</code> after all) but we do consider it for target features for a given individual processor, even though it's already definitionally UB to execute that code.</p>\n<p>At what point, exactly, did Rust acquire that burden?</p>",
        "id": 240111414,
        "sender_full_name": "Jubilee",
        "timestamp": 1621890106
    },
    {
        "content": "<p>UB as is usually defined for programming language purposes is not a concept that exists after the compiler is done emitting the machine code. Hardware has its own kinds of UB like for instance indeterminate results when logic voltage is too low, but that's not something a programming language needs to concern itself with… right?</p>\n<p>It still isn't clear to me at least as to whether LLVM is allowed to do whatever it wishes during codegen when the features are not available during codegen. At the very least I remember <code>rdrand</code> causing an assertion in LLVM when the <code>rdrnd</code> feature is not enabled.</p>",
        "id": 240112318,
        "sender_full_name": "nagisa",
        "timestamp": 1621890565
    },
    {
        "content": "<p>By calling <code>#[target_feature]</code> unsafe we leave ourselves some wiggle-room to decide either way in the future.</p>",
        "id": 240112443,
        "sender_full_name": "nagisa",
        "timestamp": 1621890626
    },
    {
        "content": "<p>I would consider that the executing code compiled with a target feature when that feature isn't available is undefined behaviour in general. On x86, it's a #UD exception, but it could actually cause hardware UB on a different ISA. It's entirely possibly that you could hit the HCF instruction. I could presume that is sufficient to warrant unsafe at the rust level.</p>",
        "id": 240117925,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621893572
    },
    {
        "content": "<p>An example of opcode reuse in x86 is <code>lzcnt</code> which is I think <code>rep bsr</code> on older cpus. I once had to debug a bug of cg_clif caused by using lzcnt on an older cpu.</p>",
        "id": 240164525,
        "sender_full_name": "bjorn3",
        "timestamp": 1621936482
    },
    {
        "content": "<p>What about running code on emulators/virtual machines/etc that have different ideas as to what instructions do compared to real hardware?</p>",
        "id": 240169418,
        "sender_full_name": "nagisa",
        "timestamp": 1621939664
    },
    {
        "content": "<p>If you run in a broken VM (or on broken hardware), then you're just kind of screwed. The best we can do is generate correct output according to the relevant specifications.</p>",
        "id": 240182436,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621947367
    },
    {
        "content": "<p>A couple of years ago, I heard a story of an issue where some cloud VMs incorrectly reported that they implemented AES-NI while the underlying hardware did not. Somehow things \"worked\" well enough for a while until people noticed that their \"encrypted backups\" were actually just white noise since the AES instructions were just trapping up to the hypervisor!</p>",
        "id": 240182680,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621947469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240112318\">said</a>:</p>\n<blockquote>\n<p>UB as is usually defined for programming language purposes is not a concept that exists after the compiler is done emitting the machine code. Hardware has its own kinds of UB like for instance indeterminate results when logic voltage is too low, but that's not something a programming language needs to concern itself with… right?</p>\n</blockquote>\n<p>Hopefully. ^^;</p>\n<blockquote>\n<p>It still isn't clear to me at least as to whether LLVM is allowed to do whatever it wishes during codegen when the features are not available during codegen. At the very least I remember <code>rdrand</code> causing an assertion in LLVM when the <code>rdrnd</code> feature is not enabled.</p>\n</blockquote>\n<p>Yeaaah, that's part of why I'm kind of wondering about this in connection with the wasm SIMD and target-feature 1.1 thing, because the question about possible codegen UB was raised there but not fully addressed (though it's not entirely clear how addressable it is, thus...). And then I realized part of my question was sufficiently general that I should separate it out, basically trying to figure out the \"reverse\" position: where do Rust's obligations to consider what is arguably \"beyond Rust\" behavior start and stop?</p>",
        "id": 240243265,
        "sender_full_name": "Jubilee",
        "timestamp": 1621973350
    },
    {
        "content": "<blockquote>\n<p>UB as is usually defined for programming language purposes is not a concept that exists after the compiler is done emitting the machine code.</p>\n</blockquote>\n<p>I guess the \"problem\" for me, zeroing back on this statement, is that this is what makes it unclear to me where the <code>target_feature</code> burden starts and stops. As Connor says, you could trigger HCF in the CPU... but actually running the code on a given computer with a given feature-set (or absence thereof) happens in a \"beyond Rust\" scenario, and, well...</p>\n<blockquote>\n<p>If you run in a broken VM (or on broken hardware), then you're just kind of screwed.</p>\n</blockquote>\n<p>I am not sure where to draw the line between \"broken ISA\" vs. \"ISA codegen spec vs. execution spec mismatch\".</p>",
        "id": 240244317,
        "sender_full_name": "Jubilee",
        "timestamp": 1621973832
    },
    {
        "content": "<blockquote>\n<p>I am not sure where to draw the line between \"broken ISA\" vs. \"ISA codegen spec vs. execution spec mismatch\".</p>\n</blockquote>\n<p>The only difference between a bug and a feature is intent</p>",
        "id": 240244831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621974097
    },
    {
        "content": "<p>Correct, and yet. ^^;</p>",
        "id": 240245019,
        "sender_full_name": "Jubilee",
        "timestamp": 1621974174
    },
    {
        "content": "<p>If you are an OS, you often have to just deal with hardware bugs, at which point it just becomes a peculiar architecture. The main problem is when these peculiar architectures can't be detected through the normal mechanisms (CPUID et al)</p>",
        "id": 240245076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621974212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240244317\">said</a>:</p>\n<blockquote>\n<p>I guess the \"problem\" for me, zeroing back on this statement, is that this is what makes it unclear to me where the <code>target_feature</code> burden starts and stops.</p>\n</blockquote>\n<p>My understanding is that today we aren't quite sure if LLVM can do unexpected things when you request it to produce the code for an opration which otherwise requires a certain feature to be enabled. Making wasm32 features not require unsafe seems like we'd be going in the direction of saying \"no, LLVM does not do that\".</p>",
        "id": 240245386,
        "sender_full_name": "nagisa",
        "timestamp": 1621974348
    },
    {
        "content": "<blockquote>\n<p>And then I realized part of my question was sufficiently general that I should separate it out, basically trying to figure out the \"reverse\" position: where do Rust's obligations to consider what is arguably \"beyond Rust\" behavior start and stop?</p>\n</blockquote>\n<p>I think we should make every effort to detect and mitigate \"beyond Rust\" problems when possible. (The <code>really_monotonic_clock</code> hack comes to mind.) We may not be able to do much about some kinds of issues, though.</p>",
        "id": 240245488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621974380
    },
    {
        "content": "<p>For reference: <a href=\"#narrow/stream/213817-t-lang/topic/safe.20target_feature.20functions.20for.20wasm/near/238667618\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/safe.20target_feature.20functions.20for.20wasm/near/238667618</a></p>",
        "id": 240245506,
        "sender_full_name": "nagisa",
        "timestamp": 1621974393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240244317\">said</a>:</p>\n<blockquote>\n<p>I guess the \"problem\" for me, zeroing back on this statement, is that this is what makes it unclear to me where the <code>target_feature</code> burden starts and stops. As Connor says, you could trigger HCF in the CPU... but actually running the code on a given computer with a given feature-set (or absence thereof) happens in a \"beyond Rust\" scenario, and, well...</p>\n</blockquote>\n<p>Well, combining things like <code>target_feature</code> and <code>is_&lt;arch&gt;_feature_detected!</code>, I'd argue that it is within the purview of rust to consider execution environments as having \"particular\" features, even if the consideration extends no further than a simple <em>conditionally-supported</em> statement.</p>",
        "id": 240249021,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621976254
    },
    {
        "content": "<p>(As a semi-related note, I would consider that target features are <em>conditionally-supported</em> already, even if there isn't normative text on the subject, and lacking otherwise defined behaviour, the unsupported case falls back to UB)</p>",
        "id": 240249258,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621976360
    },
    {
        "content": "<blockquote>\n<p>lacking otherwise defined behaviour, the unsupported case falls back to UB</p>\n</blockquote>\n<p>I don't think Rust has UB-of-the-gaps like this. If something is unspecified that doesn't mean it's UB, that means the spec is incomplete</p>",
        "id": 240251506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621977452
    },
    {
        "content": "<p>I mean, what else can a spec gap be? If something doesn't have defined behaviour by the spec, what limits are imposed on the behaviour that can be assigned by the implementation? There is a difference between unspecified and \"is not present in the specification\".</p>",
        "id": 240252001,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621977727
    },
    {
        "content": "<p>(It's also generally the case, at least in C and C++, that when a <em>conditionally supported</em> feature is unsupported, it's use is either ill-formed or undefined behaviour)</p>",
        "id": 240252103,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621977800
    },
    {
        "content": "<p>Yes, this is a deliberate departure from C/C++ specs where spec omissions are UB</p>",
        "id": 240252280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621977897
    },
    {
        "content": "<p>If there is a spec gap, that doesn't mean anything other than that the spec is incomplete/buggy/needs to be fixed. It doesn't imply that the behavior is defined, undefined, conditionally-supported or anything else like that</p>",
        "id": 240252437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621977973
    },
    {
        "content": "<p>UB of the gaps! <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <br>\n<span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240245488\">said</a>:</p>\n<blockquote>\n<p>I think we should make every effort to detect and mitigate \"beyond Rust\" problems when possible. (The <code>really_monotonic_clock</code> hack comes to mind.) We may not be able to do much about some kinds of issues, though.</p>\n</blockquote>\n<p>I think, for Rust at least, the <code>really_monotonic_clock</code> hack happens to be a situation where we are trying to undermine a type violation that is directly \"in Rust\" (that is, we promised monotonicity). So we can either hack monotonicity in or repeal the promise of monotonicity. The latter is a breakage of the kind that Rust's semver policies arguably might <strong>not</strong> permit without incrementing Rust Major, in spite of being a fix.</p>",
        "id": 240252597,
        "sender_full_name": "Jubilee",
        "timestamp": 1621978083
    },
    {
        "content": "<p>I think totally-safe-transmute falls in the same category though; it is an OS feature that directly undermines a promise that rust is trying to make. The only difference is that there is very little we can do about it. It's in the same category as trying to prove that a program doesn't have any panics and then someone pulls the plug on the computer</p>",
        "id": 240252874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621978282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240251506\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>lacking otherwise defined behaviour, the unsupported case falls back to UB</p>\n</blockquote>\n<p>I don't think Rust has UB-of-the-gaps like this. If something is unspecified that doesn't mean it's UB, that means the spec is incomplete</p>\n</blockquote>\n<p>In either case, it could just as easily be a split statement. The text I would write in that case could be:</p>\n<blockquote>\n<ul>\n<li>If a function with a <code>#[target_feature]</code> attribute is called in a context where a feature indicated is not enabled, the program is ill-formed if the call does not occur within an unsafe context. Such a call is <em>conditionally-supported</em>, and the behaviour is undefined if unsupported. [Note: An implementation may make use of features enabled by the <code>#[target_feature]</code> attribute to generate better optimized code than may be possible in the remainder of the crate]</li>\n</ul>\n</blockquote>",
        "id": 240253217,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978540
    },
    {
        "content": "<p>(If UB-by-deliberate omission is permitted, I would simply stop the normative text at \"Such a call is <em>conditionally-supported</em>\")</p>",
        "id": 240253338,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978597
    },
    {
        "content": "<p>Yeah in practice the monotonicity hack is there because it is something that can be controlled within the scope of the Rust program. So I guess we could apply a similar reasoning here and say that <code>unsafe</code> only applies to things which can be governed entirely within Rust control flow.</p>",
        "id": 240253373,
        "sender_full_name": "Jubilee",
        "timestamp": 1621978619
    },
    {
        "content": "<p>Now we just need to provide a definition of Rust control flow which I am sure will be simple and non-controversial. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 240253413,
        "sender_full_name": "Jubilee",
        "timestamp": 1621978665
    },
    {
        "content": "<p>For the cases of buggy processors, I would agree. In general, though ,<code>#[target_feature]</code> is close fairly close to what I described in the Note: a indication that the implementation is allowed to generate more optimized code, using the indicated features. To facilate that optimization, it must therefore be undefined behaviour to enter that code where the feature is unavailable, otherwise such optimizations would arguably violate the <em>as-if</em> rule.</p>",
        "id": 240253636,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978811
    },
    {
        "content": "<p>The architecture and the ISA is, primarily, a detail of the implementation. It's how the implementation chose to emulate the required observable behaviour of the Abstract Machine, whatever that means for rust.</p>",
        "id": 240253716,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978871
    },
    {
        "content": "<p>(Also, making it undefined behaviour to enter code that requires unavailable target features would be useful for abi issues accross such bounderies)</p>",
        "id": 240254012,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621979047
    },
    {
        "content": "<p>I agree that it should be undefined behavior to call a function with an unsupported <code>#[target_feature]</code>. That is more or less forced by the hardware, since it's essentially hardware UB already. Whether that entails <code>unsafe</code> depends on the degree to which we can statically ensure that we only ever call functions when the target features are supported.</p>",
        "id": 240256304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621980383
    },
    {
        "content": "<p>What about the WebAssembly case, where we have what we assume is a static guarantee that entering unsupported features will trap? To what degree do we allow the implementation details of the underlying \"\"\"hardware\"\"\" to leak into Rust when it reduces possible cases of UB?</p>",
        "id": 240256614,
        "sender_full_name": "Jubilee",
        "timestamp": 1621980587
    },
    {
        "content": "<p>A function that is always safe to call (i.e. never causes UB) does not need to be marked <code>unsafe</code>. We already do this kind of thing with \"safe wrappers\", but it can also be implemented directly on the intrinsic. The spec already knows what is UB and what isn't so it can include language to this effect.</p>",
        "id": 240256877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621980747
    },
    {
        "content": "<blockquote>\n<p>I agree that it should be undefined behavior to call a function with an unsupported <code>#[target_feature]</code></p>\n</blockquote>\n<p>Actually this needs to be amended to \"conditionally-supported\" since making all unsupported features UB would exclude the wasm case. Ideally the spec should enumerate the status of all target features - whether they are known to trap, are known to be UB, or have some other status</p>",
        "id": 240257276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621981001
    },
    {
        "content": "<p>I'd argue that, even in the wasm case where the runtime result is known, it's still necessary to make it undefined behaviour, in order to release the implementation from that burden. Otherwise, rust would have to define exactly what all happens in that case, which can be difficult, and \"trapping\" wouldn't be able to consider <code>SIGILL</code>.<br>\nAlso, I'd argue that the list of target features shouldn't be exhaustive in the spec, and should rather be <em>implementation-defined</em> (possibly with a minimum supported list for some common architectures). In particular, I would personally rather avoid constraining the architectures available to rust implementations, and requiring admission into the specification (which may not be granted for some architectures, but various implementations may be capable of supporting them trivially).</p>",
        "id": 240266095,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621988214
    },
    {
        "content": "<blockquote>\n<p>it's still necessary to make it undefined behaviour, in order to release the implementation from that burden</p>\n</blockquote>\n<p>I just realised that the burden I'm referring to may not be obvious. I'm referring to the burden of either issuing the trap as required (even if it doesn't make use of the target_feature), or maintaining correct state of the AM for the purposes of determining observable behaviour (if it does).</p>",
        "id": 240274105,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621997400
    },
    {
        "content": "<blockquote>\n<p>Also, I'd argue that the list of target features shouldn't be exhaustive in the spec, and should rather be implementation-defined (possibly with a minimum supported list for some common architectures). In particular, I would personally rather avoid constraining the architectures available to rust implementations, and requiring admission into the specification (which may not be granted for some architectures, but various implementations may be capable of supporting them trivially).</p>\n</blockquote>\n<p>I've been thinking about what a formal specification of rust would look like these days, and it's really not clear to me how to model divergent architectures unless the possible behaviors are explicitly enumerated. That may well mean that the spec is limited to Tier-1 targets, but generalizing over all possible behaviors while also not being UB somehow seems like a very difficult balance otherwise.</p>",
        "id": 240275625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621999445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240274105\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it's still necessary to make it undefined behaviour, in order to release the implementation from that burden</p>\n</blockquote>\n<p>I just realised that the burden I'm referring to may not be obvious. I'm referring to the burden of either issuing the trap as required (even if it doesn't make use of the target_feature), or maintaining correct state of the AM for the purposes of determining observable behaviour (if it does).</p>\n</blockquote>\n<p>We're supposing for the sake of discussion that WASM <em>does</em> issue the trap as required under all circumstances. If that can't be guaranteed then obviously we can't remove the <code>unsafe</code>.</p>",
        "id": 240275731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621999583
    },
    {
        "content": "<p>Couldn't a formal specification of Rust lean heavily on implementation-defined behavior? A formal spec for Rust should be able to support at least a large subset of targets, or else it risks just being ignored and rustc being the defacto standard.</p>",
        "id": 240276155,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1622000218
    },
    {
        "content": "<p>The thing is, it's not clear to me what it means to \"lean heavily on implementation-defined behavior\". That sounds like the spec is parameterized on a huge number of functions specifying the semantics of individual instructions to the point that the spec itself offers very little and it may not even be clear that a model exists</p>",
        "id": 240276853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001219
    },
    {
        "content": "<p>I would rather just see all supported targets in the spec, since that's what rustc does (possibly with some generic / parameterized behavior for other targets as a template for future expansion)</p>",
        "id": 240276935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001292
    },
    {
        "content": "<p>Well trap doesn't have a defined behavior actually.<br>\nI mean, it does, but it also doesn't: it generates an exception of some unspecified nature, but deterministically, and returns control flow to the environment beyond wasm.</p>",
        "id": 240277022,
        "sender_full_name": "Jubilee",
        "timestamp": 1622001412
    },
    {
        "content": "<p>That sounds like \"as good as a panic\". In particular execution visibly terminates abnormally and instructions following the trap are not executed</p>",
        "id": 240277045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001463
    },
    {
        "content": "<p><code>std::process::abort</code> is a safe function</p>",
        "id": 240277108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001524
    },
    {
        "content": "<p>but you have to spec no_std / bare metal too</p>",
        "id": 240281812,
        "sender_full_name": "Lokathor",
        "timestamp": 1622007872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240275731\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240274105\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it's still necessary to make it undefined behaviour, in order to release the implementation from that burden</p>\n</blockquote>\n<p>I just realised that the burden I'm referring to may not be obvious. I'm referring to the burden of either issuing the trap as required (even if it doesn't make use of the target_feature), or maintaining correct state of the AM for the purposes of determining observable behaviour (if it does).</p>\n</blockquote>\n<p>We're supposing for the sake of discussion that WASM <em>does</em> issue the trap as required under all circumstances. If that can't be guaranteed then obviously we can't remove the <code>unsafe</code>.</p>\n</blockquote>\n<p>Does it guarantee a trap even if the implementation chooses not to exploit the <code>#[target_feature]</code> as permitted? If so, then it could be <em>implementation-defined</em> whether the implementation issues a trap instead. But specifying that trap is either going to be incredibly handwavying (without being exhaustive), or insufficient to handle all cases, when the undefined behaviour case would permit the issuance of a trap (and also permit the implementation making an independant promise of such).</p>",
        "id": 240303614,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622024620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240276853\">said</a>:</p>\n<blockquote>\n<p>The thing is, it's not clear to me what it means to \"lean heavily on implementation-defined behavior\". That sounds like the spec is parameterized on a huge number of functions specifying the semantics of individual instructions to the point that the spec itself offers very little and it may not even be clear that a model exists</p>\n</blockquote>\n<p>imo the rust spec should be agnostic of the finite list of supported targets. It should neither mandate implementations support any particular platform, nor forbid such (either implicitly or explicitly) beyond generic specification requirements that consequentially limit implementation platforms.</p>",
        "id": 240303990,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622024869
    },
    {
        "content": "<blockquote>\n<p>imo the rust spec should be agnostic of the finite list of supported targets.</p>\n</blockquote>\n<p>How then does one define the behavior of <code>#[cfg(target_arch = \"x86_64\")]</code>? Presumably implementations are not allowed to disagree on the abstract machine semantics of a program using such cfg directives. But the only way to establish such semantics is to put x86-specific constraints literally in the spec. It can be done in an open ended way, but I don't think a rust implementation that swaps the meaning of <code>target_arch = \"x86_64\"</code> and <code>target_arch = \"arm\"</code> should be considered conforming, because a perfectly well defined rust program running under rustc could cause almost arbitrary misbehavior if run on an incompatible architecture.</p>",
        "id": 240308447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622027822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240308447\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>imo the rust spec should be agnostic of the finite list of supported targets.</p>\n</blockquote>\n<p>How then does one define the behavior of <code>#[cfg(target_arch = \"x86_64\")]</code>? Presumably implementations are not allowed to disagree on the abstract machine semantics of a program using such cfg directives. But the only way to establish such semantics is to put x86-specific constraints literally in the spec. It can be done in an open ended way, but I don't think a rust implementation that swaps the meaning of <code>target_arch = \"x86_64\"</code> and <code>target_arch = \"arm\"</code> should be considered conforming, because a perfectly well defined rust program running under rustc could cause almost arbitrary misbehavior if run on an incompatible architecture.</p>\n</blockquote>\n<p>The value of each <code>target_*</code> cfg key is implementation defined.</p>",
        "id": 240310014,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622028827
    },
    {
        "content": "<p>And then it's constrained that <code>core::arch::x86_64</code> exists if <code>cfg(target_cpu=\"x86_64\")</code>, which contains various things (and those have particular behaviour within the abstract machine).</p>",
        "id": 240310227,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622028965
    },
    {
        "content": "<p>It can contain particular constraints on existing well-known architectures, but, for example, if I wanted to implement the <code>w65</code> architecture, it is my opinion that rust should not prohibit that implementation choice. Likewise, if I don't want to implement the aarch64 architecture, rust shouldn't require that it's implemented (that would constrain something like gcc-rs, which is a single-target toolchain).</p>",
        "id": 240310552,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622029146
    },
    {
        "content": "<p>I don't think either of those criteria are difficult to achieve, although for the <code>w65</code> example we would have to leave in some room to potentially extend the spec to cover the architecture \"properly\", at which point an early adopter implementation may become nonconforming</p>",
        "id": 240311202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622029582
    },
    {
        "content": "<p>Well, at that point, I would presume that the implementor would be able to offer that experience to avoid that issue.</p>",
        "id": 240311569,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622029858
    },
    {
        "content": "<p>Supported targets are necessarily part of the Rust language and library, because the language and library define target-specific behavior. If nothing else, there needs to be information about what sizes and layouts various types have, as well as what modules are defined for that target.</p>",
        "id": 240428096,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622099788
    },
    {
        "content": "<p>If you'd like to implement w65, the same issues apply as if you want to add any other new language feature; either way it needs some amount of design work.</p>",
        "id": 240428268,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622099960
    },
    {
        "content": "<p>The issue comes when the people in charge of the design has no reason to pursue designing a feature. w65 in particular is close to 40 (may even be more) years old, and sees limited use. I have reasons to support it (related to SNES Homebrew development),  but  I doubt many other people do.  Thus I find it extraordinarily unlikely that w65 would be explicitly supported by the Rust Language.<br>\n I would also prefer <em>not</em> having to do the extra work to gate off targets that rust doesn't permit, when the default state for my design is to permit it (my design just parses the target tuple, then passes it to the frontend, and the frontend can obtain information about the target).  Modules are somewhat fair (though they can easily be introduced with a feature gate, as could inline assembly), but I'd argue that size and layout could easily be made <em>implementation-defined</em> rather than exhaustively enumerating the values. Likewise, <code>target_feature</code>s could be <em>implementation-defined</em>.</p>",
        "id": 240447790,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622112604
    },
    {
        "content": "<p>The fact that size is at least u16 is baked in to the standard library at least.</p>",
        "id": 240451712,
        "sender_full_name": "nagisa",
        "timestamp": 1622115068
    },
    {
        "content": "<p>Yes, that would be a constraint on the <em>implementation-defined</em> size of <code>usize</code>.</p>",
        "id": 240452400,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622115522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> So, two things about that:<br>\n1) If the standards for tier 3 are such that SNES homebrew development can't meet them, we've done something very wrong. ;)  I very much hope that in general, the standards for tier 3 (unlike the higher tiers) are a sufficiently minimal set that they would be more-or-less what any other implementation would want anyway.<br>\n2) If it turns out that there's a second relevant implementation for which (1) is not actually true in practice, I imagine we could expand our processes such that we could collaboratively determine the minimum details needed for uniform handling of the target, such as target triple name, type sizes, and similar. We could even add a concept of \"tier 4 targets\": \"this isn't in the codebase, but there's enough consensus on it to not end up with incompatible implementations in the future\".</p>",
        "id": 240496669,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622133791
    },
    {
        "content": "<p>I agree that if Rust can't compile for the SNES then I'm rioting.</p>",
        "id": 240526728,
        "sender_full_name": "Jubilee",
        "timestamp": 1622147314
    },
    {
        "content": "<p>I mean I don't expect to load up an actual cartridge any time soon.</p>",
        "id": 240526757,
        "sender_full_name": "Jubilee",
        "timestamp": 1622147334
    },
    {
        "content": "<p>I would love to, but sadly my console's video output isn't reliable anymore.</p>",
        "id": 240528187,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622148052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240526728\">said</a>:</p>\n<blockquote>\n<p>I agree that if Rust can't compile for the SNES then I'm rioting.</p>\n</blockquote>\n<p>Well, I doubt rustc specifically would be able to compile it any time soon, I've abandoned my efforts for implementing a w65 backend for llvm. That being said, my primary issue is with <code>usize</code> (pointers are 24-bit zero-extended to 32-bit, but the size type is 16-bit). But it's a lot more of an issue if Rust itself prohibits the implementation, either explicitly, or by exhaustively listing the required ones, then if there are technical details that have to be solved.</p>",
        "id": 240529694,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622148693
    },
    {
        "content": "<p>would rustc-codegen-gcc solve the \"no llvm target\" issue?</p>",
        "id": 240530272,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1622148949
    },
    {
        "content": "<p>There alas also isn't a gcc target, though I'm working on (re)implementing binutils, so it or gcc rs might have some in not-upstream in the future. I'm also working on an implementation (of not just rust) that will come with w65 support (where the\"I'd rather not have to specifically exclude targets\" issue arises).</p>",
        "id": 240530824,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622149194
    },
    {
        "content": "<p>I think the Rust specification could say that, for targets that are not addressed specifically by the specification, the behavior is implementation-defined.</p>",
        "id": 240533146,
        "sender_full_name": "Jubilee",
        "timestamp": 1622150213
    },
    {
        "content": "<p>Probably doesn't even need to say for non-addressed targets. If it's just implementation-defined, it can be constrained down to something close to well defined. Fully constraining known platforms also may burden implementations. For example, if rust says that on x86_64, the pointer width is 64, then an implementation could not then operate on x86_64, but compile to the x32 abi (which has only 32-bit pointers, but generates 64-bit code).</p>",
        "id": 240534071,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622150701
    },
    {
        "content": "<p>The x32 ABI has a different target, for exactly that reason.</p>",
        "id": 240536079,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240529694\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240526728\">said</a>:</p>\n<blockquote>\n<p>I agree that if Rust can't compile for the SNES then I'm rioting.</p>\n</blockquote>\n<p>Well, I doubt rustc specifically would be able to compile it any time soon, I've abandoned my efforts for implementing a w65 backend for llvm. That being said, my primary issue is with <code>usize</code> (pointers are 24-bit zero-extended to 32-bit, but the size type is 16-bit). But it's a lot more of an issue if Rust itself prohibits the implementation, either explicitly, or by exhaustively listing the required ones, then if there are technical details that have to be solved.</p>\n</blockquote>\n<p>I don't think Rust should list <em>required</em> targets, just \"if you implement this target this is how it must work\".</p>",
        "id": 240536160,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151894
    },
    {
        "content": "<p>I do think, because of that, there's value in Rust saying \"a target must be in this list\", but that's only a problem if it's non-trivial to extend that list.</p>",
        "id": 240536244,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151937
    },
    {
        "content": "<p>That's what I was getting at when I suggested \"tier 4\" targets: we can evaluate a target without necessarily including it.</p>",
        "id": 240536286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151957
    },
    {
        "content": "<p>Yeah, I meant permitted targets not required targets there.</p>",
        "id": 240536353,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622151977
    },
    {
        "content": "<p>My primary concern is if some third-party implementation adds a target without any kind of coordination at all, and sets the properties of that target, and then later rustc is expected to preserve some of those properties for compatibility with the third-party implementation.</p>",
        "id": 240536636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152144
    },
    {
        "content": "<p>That's the main reason that I don't think it's unreasonable to say \"hey, please coordinate the addition of targets\". If we refused to participate in that coordination, then I'd certainly understand people deciding they were going to do it anyway.</p>",
        "id": 240536724,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152198
    },
    {
        "content": "<p>This isn't a hypothetical; this happens for existing targets in other compilers, where the first compiler to target a platform may set a less-than-ideal ABI and subsequent compilers are stuck with it.</p>",
        "id": 240536825,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152249
    },
    {
        "content": "<p>I'm <em>happy</em> to spend time reviewing \"hey, can we have a tier 4 target for (insert arbitrary platform here)\" requests if it means that we actually coordinate and design new targets.</p>",
        "id": 240536972,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152332
    },
    {
        "content": "<p>The reason I say I wouldn't like a specific list of permitted targets, is the way I'd expect the lccc rust frontend to behave when it's told what target to compile for is to query the properties of the target from xlang (the core architecture of lccc), and just follow it. If then the list of targets were restricted, I'd have to implement a whitelist in the rustc driver of the main lccc program, which is extra work, both for myself as the implementor, and the actual program itself (potentially requiring a string hashtable lookup or a tree search, if the target names are exact, like rustc seems to think they are).</p>",
        "id": 240537040,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622152372
    },
    {
        "content": "<p>Is a simple \"member of HashSet\" check <em>that</em> bad?</p>",
        "id": 240537215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152462
    },
    {
        "content": "<p>(Also, you wouldn't have to if every xlang target were covered.)</p>",
        "id": 240537239,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152478
    },
    {
        "content": "<p>Another option would be for xlang's target data to include Rust target definition information (e.g. \"what size is the xyz type\"), and then you could do that lookup (which you may need to do anyway) and treat the absence of that information as \"this target isn't supported\".</p>",
        "id": 240537358,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152552
    },
    {
        "content": "<p>I just don't want to end up in a world where rustc faces a choice of either \"break people using a third-party compiler\" or \"precisely match the target design from a third-party compiler\".</p>",
        "id": 240537476,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152606
    },
    {
        "content": "<p>I don't think that's good for either third-party compilers or the Rust compiler.</p>",
        "id": 240537519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240537239\">said</a>:</p>\n<blockquote>\n<p>(Also, you wouldn't have to if every xlang target were covered.)</p>\n</blockquote>\n<p>That issue then becomes I need approval from the rust teams to add a target to the C or the C++ frontend (or to any third party xlang frontend, which, given that I've designed the api to be modular, would make it a non-starter). It's possible I could do the latter (I haven't entirely worked out the design), however, considering I'd already be storing the pointer size, and the lock-free atomic sizes, I can't think of much I would store that wouldn't be just deliberately duplicating information (aside from just storing an explicit <code>bool is_rust_target;</code>, which may not be a bad design)</p>",
        "id": 240538534,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622153277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> </p>\n<blockquote>\n<p>That issue then becomes I need approval from the rust teams to add a target to the C or the C++ frontend</p>\n</blockquote>\n<p>Fair point, and that's <em>not</em> something you should have to do; I didn't want to suggest otherwise. I more meant that since you care about Rust , \"every xlang target is a Rust target\" may actually be close to the case in practice. :)</p>",
        "id": 240539377,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622153936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240538534\">said</a>:</p>\n<blockquote>\n<p>aside from just storing an explicit <code>bool is_rust_target;</code>, which may not be a bad design</p>\n</blockquote>\n<p>Yeah, that does seem reasonable and better than a separate list, since you do that target lookup anyway.</p>",
        "id": 240539431,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622153994
    },
    {
        "content": "<p>(Of course, all of this depends on whether or not rust itself considers equivalent but different targets distinct. If so, then I'd have to implement a separate list, since the lookup is against the canonical form, not against the target name)</p>",
        "id": 240541648,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622155728
    },
    {
        "content": "<p>What do you mean by \"equivalent but different targets\"?</p>",
        "id": 240542082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622156143
    },
    {
        "content": "<p>Targets that are different in name, but canonicalize to the same thing (xlang performs target canonicalization). For example (though rustc does not accept either, which I consider wrong, as config.guess, at least on my machine, produces the latter) x86_64-linux-gnu canonicalizes to x86_64-pc-linux-gnu. Also, both of these targets are semantically equivalent (though distinct) with x86_64-unknown-linux-gnu (which rustc <em>does</em> accept).</p>",
        "id": 240542824,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622156680
    },
    {
        "content": "<p>I can't imagine any circumstance in which rustc accepted x86_64-pc-linux-gnu and treated it as <em>different</em> than x86_64-unknown-linux-gnu.</p>",
        "id": 240544635,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622158149
    },
    {
        "content": "<p>Either rustc won't accept it at all, or will treat it as identical. Likewise <code>x86_64-linux-gnu</code>.</p>",
        "id": 240544667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622158189
    },
    {
        "content": "<p>Accepting target aliases has come up before, and I don't think it'd be unreasonable to ask for target alias support in Rust.</p>",
        "id": 240544814,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622158288
    },
    {
        "content": "<p><a href=\"https://github.com/microsoft/xlang\">https://github.com/microsoft/xlang</a>, eh?<br>\nAs far as targets go, I believe addressing logical targets is preferable to matching exact strings.</p>",
        "id": 240549969,
        "sender_full_name": "Jubilee",
        "timestamp": 1622163068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240549969\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/microsoft/xlang\">https://github.com/microsoft/xlang</a>, eh?<br>\nAs far as targets go, I believe addressing logical targets is preferable to matching exact strings.</p>\n</blockquote>\n<p>Not that, no. I wasn't even aware that existed. The xlang I'm referring to is the middle-architecture of lccc (<a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a>).</p>",
        "id": 240550663,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622163781
    },
    {
        "content": "<p>Yeah, I just found it funny.</p>",
        "id": 240552505,
        "sender_full_name": "Jubilee",
        "timestamp": 1622165771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> </p>\n<blockquote>\n<p>Then what, philosophically, is undefined behavior, anyways? :^)</p>\n</blockquote>\n<p>My 2 cents: <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#undefined-behavior\">https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#undefined-behavior</a></p>",
        "id": 240698388,
        "sender_full_name": "RalfJ",
        "timestamp": 1622289200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240112318\">said</a>:</p>\n<blockquote>\n<p>It still isn't clear to me at least as to whether LLVM is allowed to do whatever it wishes during codegen when the features are not available during codegen. At the very least I remember <code>rdrand</code> causing an assertion in LLVM when the <code>rdrnd</code> feature is not enabled.</p>\n</blockquote>\n<p>well, that makes <a href=\"https://github.com/rust-lang/rust/pull/84988\">https://github.com/rust-lang/rust/pull/84988</a> even more interesting...</p>\n<p>EDIT: ah okay that was already covered. and then discussion derailed a bit...^^</p>",
        "id": 240698448,
        "sender_full_name": "RalfJ",
        "timestamp": 1622289275
    },
    {
        "content": "<p>Regarding: <a href=\"https://github.com/rust-lang/rust/pull/84988\">https://github.com/rust-lang/rust/pull/84988</a> , the example there is an opt that cannot happen.</p>",
        "id": 250337278,
        "sender_full_name": "hannahE2",
        "timestamp": 1629717353
    },
    {
        "content": "<p>But the opt that can happen is transforming:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[target_feature(enable = &quot;sse4&quot;)] unsafe fn foo_sse4() {}\n\nfn main() {\n  unsafe { foo_sse4() }\n // .... other code...\n}\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\"><pre><span></span><code>#[target_feature(enable = &quot;sse4&quot;)] unsafe fn foo_sse4() {}\n\n#[target_feature(enable = &quot;sse4&quot;)]  fn main() {\n  unsafe { foo_sse4() }\n  // ... other code ...\n}```\n</code></pre></div>",
        "id": 250337384,
        "sender_full_name": "hannahE2",
        "timestamp": 1629717425
    },
    {
        "content": "<p>For WASM, using a <code>target_feature</code> function anywhere in a WASM module, enables that feature statically for the whole module anyways, and if the hardware does not support it, that module will never run.</p>",
        "id": 250337491,
        "sender_full_name": "hannahE2",
        "timestamp": 1629717503
    },
    {
        "content": "<p>Looking at that issue, I think the problem is that WASM <code>core::arch</code> intrinsics should not have the <code>#[targt_feature(enable = \"\")]</code> attribute</p>",
        "id": 250337572,
        "sender_full_name": "hannahE2",
        "timestamp": 1629717578
    },
    {
        "content": "<p>Instead, they should only be available if the WASM SIMD feature is enabled at compile-time, by doing a normal <code>#[cfg(...)]</code></p>",
        "id": 250337604,
        "sender_full_name": "hannahE2",
        "timestamp": 1629717604
    },
    {
        "content": "<p>I think the PR correctly identified that there was an issue here, but the issue identified is the wrong one.</p>\n<p>You can only enable / disable WASM simd _for the whole WASM module_. You cannot do this on a function basis. Once you do this, they can be used anywhere, e.g., LLVM can insert them for you, or you can safely call the <code>core::arch::wasm</code> intrinsic.</p>",
        "id": 250337703,
        "sender_full_name": "hannahE2",
        "timestamp": 1629717673
    },
    {
        "content": "<p>The issue, however, is not that <code>#[target_feature]</code> requires <code>unsafe</code>, but rather that these intrinsics should not have the <code>#[target_feature]</code> attribute _at all_: they should, instead, be guarded behind a <code>#[cfg(target_feature)]</code>, because you can only use them if _the whole WASM module_ is compiled with SIMD enabled.</p>",
        "id": 250338300,
        "sender_full_name": "hannahE2",
        "timestamp": 1629718131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ^^ is there a way to fix this?</p>",
        "id": 250338502,
        "sender_full_name": "hannahE2",
        "timestamp": 1629718270
    },
    {
        "content": "<p><code>#[cfg(target_feature)]</code> would prevent them from being used without recompiling libstd.</p>",
        "id": 250347262,
        "sender_full_name": "bjorn3",
        "timestamp": 1629723435
    },
    {
        "content": "<p>As far as I can tell, LLVM is allowed to use <code>simd128</code> on everything if there is a <code>simd128</code> function in the module, like the <code>core::arch::wasm32</code> intrinsics.</p>",
        "id": 250371091,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734015
    },
    {
        "content": "<p>Because for WASM, the only way that module will validate is if it actually runs with <code>simd128</code> enabled, so if that's not available, it will fail to validate anyways.</p>",
        "id": 250371212,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734058
    },
    {
        "content": "<p>This is true for all WASM conditional features, not only <code>simd128</code>.</p>",
        "id": 250371258,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734088
    },
    {
        "content": "<p>You don't want to accidentally link any code into a module that uses a feature, even if that feature is never called anywhere.</p>",
        "id": 250371292,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734109
    },
    {
        "content": "<p><code>#[target_feature]</code> goal is to allow run-time feature detection, but WASM design forbids runtime feature detection of any kind.</p>",
        "id": 250371488,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734189
    },
    {
        "content": "<p>If you want to do runtime feature detection, you need to ship multiple modules, compiled with different features, and decide at runtime which one to use.</p>",
        "id": 250371546,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734230
    },
    {
        "content": "<p>So yes, i think WASM users need to recompile standard for every feature combination they want to use, and we should consider erroring when <code>#[target_feature]</code> is used on the WASM target.</p>",
        "id": 250372084,
        "sender_full_name": "hannahE2",
        "timestamp": 1629734427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"409057\">@hannahE2</span> can you schedule some time at <a href=\"https://calendly.com/nikomatsakis/\">my calendly</a> if you're still blocked and we can talk in depth?</p>",
        "id": 250782353,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629988710
    },
    {
        "content": "<p>I'm not blocked by this.</p>",
        "id": 251731607,
        "sender_full_name": "hannahE2",
        "timestamp": 1630595630
    },
    {
        "content": "<p>Cc <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> ^</p>",
        "id": 252033816,
        "sender_full_name": "RalfJ",
        "timestamp": 1630798078
    },
    {
        "content": "<p>Is the statement here a claim of what LLVM does today, or what LLVM could do? I disagree that we should error on <code>#[target_feature]</code> because it's how libstd implements its SIMD support, which is that it's not required to be used, but if used it works correctly. Put another way <code>#[target_feature]</code> is the only way to ship a wasm library that conditionally supports a feature if consumers use it, but without requiring some sort of compile-time opt-in (which isn't available to libstd)</p>",
        "id": 252470000,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631111469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> how does that work?</p>",
        "id": 252497517,
        "sender_full_name": "hannahE2",
        "timestamp": 1631120961
    },
    {
        "content": "<p>If a WASM module either uses <code>simd128</code> or it doesn't.</p>",
        "id": 252497567,
        "sender_full_name": "hannahE2",
        "timestamp": 1631120984
    },
    {
        "content": "<p>Libstd is compiled once without <code>simd128</code>. The user program is possibly compiled with <code>simd128</code> and linked against the libstd compiled without <code>simd128</code>.</p>",
        "id": 252497704,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121027
    },
    {
        "content": "<p>If you declare a function inside a module that uses <code>simd128</code>, and don't call it, and nothing calls it, the module still does not validate if the user does not support <code>simd128</code>.</p>",
        "id": 252497707,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121027
    },
    {
        "content": "<p>So how can it use the <code>simd128</code> apis ?</p>",
        "id": 252497749,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121049
    },
    {
        "content": "<p>The codegen of the <code>simd128</code> apis happens within the user program because all functions are annotated with <code>#[inline]</code>.</p>",
        "id": 252497822,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121082
    },
    {
        "content": "<p>Right, so what happens if we generate code for <code>#[inline]</code> functions in standard ?</p>",
        "id": 252497875,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121108
    },
    {
        "content": "<p>That would break the users that do not enable <code>simd128</code> at compile-time.</p>",
        "id": 252497892,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121117
    },
    {
        "content": "<p>We only generate code if the functions are actually called.</p>",
        "id": 252497982,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121139
    },
    {
        "content": "<p>But we don't guarantee that as far as I know.</p>",
        "id": 252498009,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121153
    },
    {
        "content": "<p>The standard library is allowed to depend on implementation details.</p>",
        "id": 252498060,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121179
    },
    {
        "content": "<p>That is, using <code>#[target_feature]</code> in this way here, actually requires <code>#[inline]</code> to never generate any code if not used _for correctness_.</p>",
        "id": 252498061,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121179
    },
    {
        "content": "<p><code>#[target_feature]</code> is not an implementation detail, but an API, and we currently do not guarantee that <code>#[target_feature]</code> functions or <code>#[inline]</code> functions never generate code, much less that users can rely on that.</p>",
        "id": 252498148,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121218
    },
    {
        "content": "<p>In the case of WASM, being able to rely on that is required for correctness, and the only feature we expose for this is <code>#[cfg(target_feature)]</code>.</p>",
        "id": 252498237,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121244
    },
    {
        "content": "<p>The goal of <code>#[target_feature]</code> is to support <code>is_wasm32_feature_detected!(\"simd128\")</code>, but that is \"unimplementable\" on WASM32 today.</p>",
        "id": 252498340,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/252498237\">said</a>:</p>\n<blockquote>\n<p>In the case of WASM, being able to rely on that is required for correctness, and the only feature we expose for this is <code>#[cfg(target_feature)]</code>.</p>\n</blockquote>\n<p>Maybe, but only for user code. The standard library is allowed to depend on the fact that <code>#[inline]</code> currently causes codegen to not happen unless it is actually called.</p>",
        "id": 252498386,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121303
    },
    {
        "content": "<p>The user is not allowed to do this though, so a user that does not want to use the <code>simd128</code> feature is not allowed to use the standard library.</p>",
        "id": 252498500,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121355
    },
    {
        "content": "<p>That is, from a user POV, because the standard library has <code>#[target_feature(enable = \"simd128\")]</code> functions, the standard library requires <code>simd128</code>.</p>",
        "id": 252498608,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121385
    },
    {
        "content": "<p>If they don't want to use it, they can't use the standard library because there is no <code>cfg</code> macro to turn those off. The fact that this currently works is \"accidental\", not by \"design\".</p>",
        "id": 252498692,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"409057\">@hannahE2</span> sorry but how does which part work?</p>",
        "id": 252498699,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631121430
    },
    {
        "content": "<p>When one does <code>#[target_feature(simd128)]</code> [sic] on a function, code for that function can be generated (e.g. on debug builds, depending on backend, etc.). If that happens for a WASM module, the whole module requires <code>simd128</code>.</p>",
        "id": 252498911,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/252498692\">said</a>:</p>\n<blockquote>\n<p>If they don't want to use it, they can't use the standard library because there is no <code>cfg</code> macro to turn those off. The fact that this currently works is \"accidental\", not by \"design\".</p>\n</blockquote>\n<p>Maybe the actual implementation method is \"accidental\". The standard library is allowed to depend on this kind of implementation details as it is bound to a specific rustc version. If the implementation method breaks, either the standard library will need to be changed at the same time, or the PR breaking it will never pass CI and thus not be merged.</p>",
        "id": 252499028,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121547
    },
    {
        "content": "<p>A user cannot rely on <code>#[inline] #[target_feature(simd128)]</code> not generating any code because neither feature, which are parts of a function signature, guarantee that no code isn't generated if not used.</p>",
        "id": 252499042,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121553
    },
    {
        "content": "<p>The consequence right now is that a user that doesn't want their WASM32 modules to depend on <code>simd128</code> is that they can't use the Rust standard library, since it exposes these functions, which do not provide this guarantee.</p>",
        "id": 252499227,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121617
    },
    {
        "content": "<blockquote>\n<p>since it exposes these functions, which do not provide this guarantee.</p>\n</blockquote>\n<p>It does provide this guarantee.</p>",
        "id": 252499258,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121633
    },
    {
        "content": "<p>Where?</p>",
        "id": 252499268,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121638
    },
    {
        "content": "<p>Which RFC added this guarantee ?</p>",
        "id": 252499285,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121645
    },
    {
        "content": "<p>Where is the guarantee provided in the API docs of these APIs?</p>",
        "id": 252499308,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121655
    },
    {
        "content": "<p>If this breaks, no wasm tests will pass and thus the change will never be merged in the first place.</p>",
        "id": 252499337,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/252499308\">said</a>:</p>\n<blockquote>\n<p>Where is the guarantee provided in the API docs of these APIs?</p>\n</blockquote>\n<p>By the fact that we support compilation with simd128 disabled.</p>",
        "id": 252499369,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121688
    },
    {
        "content": "<p>I think that's a bug, that should not work as things are implemented right now.</p>",
        "id": 252499411,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121710
    },
    {
        "content": "<p>You could add an <code>#[inline(truly_always_always)]</code> to these APIs to provide these guarantee</p>",
        "id": 252499497,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121733
    },
    {
        "content": "<p>and RFC that new feature that does this</p>",
        "id": 252499522,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/252499411\">said</a>:</p>\n<blockquote>\n<p>I think that's a bug, that should not work as things are implemented right now.</p>\n</blockquote>\n<p>It is not a bug. The standard library is allowed to depend on implementation details. In fact it does at a lot of places.</p>",
        "id": 252499545,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121754
    },
    {
        "content": "<p>Again, a user crate can only depend on the API exposed.</p>",
        "id": 252499579,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121769
    },
    {
        "content": "<p>The APIs exposed do not guarantee anywhere that this works, so users can't depend on this.</p>",
        "id": 252499616,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121787
    },
    {
        "content": "<p>If your claim is that <code>#[target_feature]</code> or <code>#[inline]</code> provide this guarantee, that claim is wrong, they do not.</p>",
        "id": 252499656,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/252499656\">said</a>:</p>\n<blockquote>\n<p>If your claim is that <code>#[target_feature]</code> or <code>#[inline]</code> provide this guarantee, that claim is wrong, they do not.</p>\n</blockquote>\n<p>They don't, but the standard library is allowed to depend on the fact that they currently work this way.</p>",
        "id": 252499716,
        "sender_full_name": "bjorn3",
        "timestamp": 1631121829
    },
    {
        "content": "<p>But a user can't, so they can't use these APIs, cause these APIs <strong>don't guarantee that to users</strong>.</p>",
        "id": 252499821,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121859
    },
    {
        "content": "<p>What you are saying is that standard can rely on, say, <code>#[repr(Rust)]</code> layout being of some form,  that's true, but a user can't rely on that.</p>",
        "id": 252499893,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121886
    },
    {
        "content": "<p>Same here.</p>",
        "id": 252499904,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121890
    },
    {
        "content": "<p>We don't guarantee that <code>#[target_feature]</code> functions are only compiled if used. We don't guarantee that <code>#[inline]</code> is compiled only if used. So a user that looks <strong>at the signature</strong> of these APIs, has to assume that the standard library requires <code>simd128</code>, and that if their code links it it will require <code>simd128</code>.</p>",
        "id": 252500020,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121942
    },
    {
        "content": "<p>The only feature we currently expose to avoid this is <code>cfg(target_feature)</code>, which is the only way in which these APIs could work with the language and features we have today.</p>",
        "id": 252500122,
        "sender_full_name": "hannahE2",
        "timestamp": 1631121973
    },
    {
        "content": "<p><code>#[inline(always)]</code> does not work well with <code>#[target_feature]</code> so we need a different kind of attribute to guarantee \"codegen only if used\" or something like that here.</p>",
        "id": 252500229,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122020
    },
    {
        "content": "<p>If we add the new attribute to the type signature, then users could rely on that.</p>",
        "id": 252500257,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122035
    },
    {
        "content": "<p>On stable you can't avoid using libcore, which is the crate that exposes these apis. The very fact that we allow compilation to wasm without simd128 means that we allow libcore without simd128.</p>",
        "id": 252500259,
        "sender_full_name": "bjorn3",
        "timestamp": 1631122036
    },
    {
        "content": "<p>That's a bug in the current implementation probably.</p>",
        "id": 252500294,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122051
    },
    {
        "content": "<p>No, it isn't.</p>",
        "id": 252500311,
        "sender_full_name": "bjorn3",
        "timestamp": 1631122057
    },
    {
        "content": "<p>I disagree.</p>",
        "id": 252500333,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122068
    },
    {
        "content": "<p>You want to guarantee that <code>#[target_feature]</code> only generates code if the function is used? Go ahead and open an RFC.</p>",
        "id": 252500400,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122085
    },
    {
        "content": "<p>It did be a bug if we only allowed libcore <strong>with</strong> simd128. That would be a breaking change.</p>",
        "id": 252500431,
        "sender_full_name": "bjorn3",
        "timestamp": 1631122096
    },
    {
        "content": "<p>I think that's a bug <strong>too</strong>.</p>",
        "id": 252500468,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122115
    },
    {
        "content": "<p>But these are two different bugs.</p>",
        "id": 252500483,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122126
    },
    {
        "content": "<p>Bug 1: #[target_feature(simd128)] requires the crate to have simd128 enabled for WASM32. <br>\nBug 2: that would require simd128 for core</p>",
        "id": 252500539,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122154
    },
    {
        "content": "<p>Multiple ways to fix both bugs, replace <code>#[target_feature]</code> with <code>cfg(target_feature)</code> (breaking change probably), add <code>#[never_codegens_unless_used]</code> to the API contract, probably others.</p>",
        "id": 252500606,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122193
    },
    {
        "content": "<p>WASM does not have run-time feature support, so the problem <code>#[target_feature]</code> and <code>is_wasm32_feature_detected!</code> solve just does not exist on WASM, and I think therefore these features are the wrong one to solve it.</p>",
        "id": 252500861,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122278
    },
    {
        "content": "<p>There is no need for a code change for std to guarantee this. The docs can just say that you don't need simd128 enabled</p>",
        "id": 252500880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631122286
    },
    {
        "content": "<p>\"But then users must recompile libcore for simd128\" is an issue, but that's just how WASM was designed to work.</p>",
        "id": 252500923,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122304
    },
    {
        "content": "<p>and they can also say that recompilation is not necessary for this</p>",
        "id": 252501012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631122326
    },
    {
        "content": "<p>Faking something different, probably adds more trouble than a fix is worth.</p>",
        "id": 252501019,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122329
    },
    {
        "content": "<p>it's not faking, this is literally what happens</p>",
        "id": 252501059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631122342
    },
    {
        "content": "<p>through an unstable mechanism sure, but that doesn't matter for users</p>",
        "id": 252501104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631122363
    },
    {
        "content": "<p>Implementation wise, we need to make sure that for all backends, if there is no  \"leaf\" in the wasm module that uses these, these are not included.</p>",
        "id": 252501127,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122376
    },
    {
        "content": "<p>That would require dead code elimination at -C opt-level=0</p>",
        "id": 252501152,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122387
    },
    {
        "content": "<p>Are there configurations that hit this issue in practice? If so, then that's the bug</p>",
        "id": 252501223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631122419
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">simd128_api</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>ought to generate a module without <code>simd128</code>, _always_.</p>",
        "id": 252501261,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122435
    },
    {
        "content": "<p>Is that in user code? If so then I wouldn't have such an expectation</p>",
        "id": 252501404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631122485
    },
    {
        "content": "<p>That's what </p>\n<div class=\"codehilite\"><pre><span></span><code>pub fn foo() {\n    if is_wasm32_feature_detected!(&quot;simd128&quot;) {\n        simd128_api();\n    }\n}\n</code></pre></div>\n<p>expands to </p>\n<div class=\"codehilite\"><pre><span></span><code>pub fn foo() {\n   if #[cfg(target_feature = &quot;simd128&quot;)] {\n      simd128_api();\n   }\n}\n</code></pre></div>\n<p>which expands to <code>false</code> if the user did not enable <code>simd128</code> at compile-time for their crate.</p>",
        "id": 252501619,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122567
    },
    {
        "content": "<p>sorry looked away for a bit again, let me catch up...</p>",
        "id": 252501839,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631122670
    },
    {
        "content": "<p>I don't know how this could be reliably made to work, so my conclusion is that making these APIs <code>#[target_feature]</code> is just something that was never going to work because that's just not how WASM is designed to work.</p>",
        "id": 252501859,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122678
    },
    {
        "content": "<p>In WASM, if you want to generate code that uses different sets of features, you need to provide different independently compiled modules.</p>",
        "id": 252501958,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122708
    },
    {
        "content": "<p>That's a job for <code>cfg()</code>.</p>",
        "id": 252501982,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122722
    },
    {
        "content": "<p>What the user wanted above is to write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cp\">#[cfg(target_feature = </span><span class=\"s\">\"simd128\"</span><span class=\"cp\">)]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">simd128_api</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>instead of using <code>is_wasm32_feature_detected!()</code>, and replacing <code>#[target_feature]</code> with <code>#[cfg(target_feature)]</code> for these APIs would avoid these types of mistakes from users.</p>\n<p>Because <code>simd128_api</code> would only exist when the config is set.</p>",
        "id": 252502239,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122830
    },
    {
        "content": "<p>I don't think I have much to add over what's already been said. It is true that if any simd is in the final wasm binary then the whole binary could have used simd. We rely on gc-sections and users reporting bugs for this to not happen by default in libstd. The standard library doesn't use simd, not because it's proven to not do so but because we're vigilant about setting defaults for code generation and such. There's nothing stopping libstd from using <code>std::arch::wasm32</code> which would make everyone require simd all the time, but we're not going to do that.</p>",
        "id": 252502301,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631122862
    },
    {
        "content": "<p>Any production code shipping in crates which conditionally supports simd-on-wasm is doing conditionally compiled code, yes</p>",
        "id": 252502373,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631122897
    },
    {
        "content": "<p>but the \"leaves\" in libstd are all gc-section'd away (or not codegen'd in the first place)</p>",
        "id": 252502410,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631122916
    },
    {
        "content": "<p>So which part of the API of these functions in standard guarantees that to users ?</p>",
        "id": 252502490,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122937
    },
    {
        "content": "<p><code>#[inline]</code> and <code>#[target_feature]</code> do not currently guarantee this.</p>",
        "id": 252502526,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122952
    },
    {
        "content": "<p>If you're looking for an RFC-like guarantee you won't find one. It's not there. It's \"practically\" there and will get fixed if broken. That's the best we have at this time</p>",
        "id": 252502555,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631122969
    },
    {
        "content": "<p>For wasm32 i think it is important to have the guarantee and the contract.</p>",
        "id": 252502562,
        "sender_full_name": "hannahE2",
        "timestamp": 1631122974
    },
    {
        "content": "<p>For other architectures users should not assume that <code>#[target_feature]</code> functions or <code>#[inline]</code> functions are not compiled.</p>",
        "id": 252502612,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123003
    },
    {
        "content": "<p>Whether they are or not is an implementation detail that can change any time, and for other archs, it is not an issue, but these type of change would break the wasm world.</p>",
        "id": 252502664,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123027
    },
    {
        "content": "<p>well, in any case, that's what I have to add to this having been cc'd, I don't think I have much more to add</p>",
        "id": 252502673,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631123032
    },
    {
        "content": "<p>I guess that's fine</p>",
        "id": 252502798,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123077
    },
    {
        "content": "<p>if as a wasm user I don't have the guarantee (in the docs, or APIs, or wherever) that the rust standard library won't require <code>simd128</code>, and the current APIs currently suggests that it would be allowed, I can't build anything for WASM using rust</p>",
        "id": 252503107,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123202
    },
    {
        "content": "<p>From the sounds of things, it's clearly a promise that the core team is trying to meet, so I think this can be solved with some documentation to make it clear that this isn't just a coincidence</p>",
        "id": 252503321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631123285
    },
    {
        "content": "<p>that would be great</p>",
        "id": 252503417,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"409057\">@hannahE2</span> you are guaranteed, for the forseeable future, that the standard library won't use simd-by-default. When provided, if ever, there will be a way to turn it off</p>",
        "id": 252503449,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631123349
    },
    {
        "content": "<p>basically everyone compiling to wasm cares about this, not just you</p>",
        "id": 252503464,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631123360
    },
    {
        "content": "<p>this is a special guarantee that the <code>core::arch::wasm32</code> intrinsic have over all other <code>core::arch::</code> intrinsic, so maybe a big note explaining this at the top of <code>core::arch::wasm32</code> module docs would clarify this (maybe adding the <code>is_wasm32_target_feature!</code> example above showing what not to do and what to do instead).</p>",
        "id": 252503646,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123433
    },
    {
        "content": "<p>indeed that sounds like a good idea!</p>",
        "id": 252503710,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1631123467
    },
    {
        "content": "<p>This guarantee is not provided by <code>#[target_feature]</code> or <code>#[inline]</code>, and is a different one of <code>libstd</code> not using <code>core::arch::wasm32</code> internally (but both could be documented there).</p>",
        "id": 252503717,
        "sender_full_name": "hannahE2",
        "timestamp": 1631123470
    }
]