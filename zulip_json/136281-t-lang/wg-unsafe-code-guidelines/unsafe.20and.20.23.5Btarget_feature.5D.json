[
    {
        "content": "<p>What is <code>unsafe</code> even for? I know this may seem like a totally deranged question, but please bear with me.<br>\nObviously it confers the power to</p>\n<blockquote>\n<p>Dereference a raw pointer<br>\n    Call an unsafe function or method<br>\n    Access or modify a mutable static variable<br>\n    Implement an unsafe trait<br>\n    Access fields of unions</p>\n</blockquote>\n<p>But what, notionally, is the purpose... and limits... of <code>unsafe</code>? Is it just memory safety? Does it cover all possible UB? What are the limits of Rust's considerations? I raise this question because <code>#[target_feature]</code> seems like it might be implying something subtly different from memory safety. Obviously Rust can technically actually violate memory safety, a la <a href=\"https://crates.io/crates/totally-safe-transmute\">https://crates.io/crates/totally-safe-transmute</a>, but we tend to punt on that because it's an OS provided API. So to what extent is Rust actually <em>allowed</em> to consider the machine it is running on? Whence cometh the consideration of the risk of unsoundness for SIMD instructions but not for <code>totally-safe-transmute</code>?</p>",
        "id": 240110258,
        "sender_full_name": "Jubilee",
        "timestamp": 1621889549
    },
    {
        "content": "<p><code>unsafe</code> covers all forms of UB. <code>target_feature</code> is an interesting case though! If trying to run an instruction on a CPU that doesn't supported just triggered a SIGILL, then <code>unsafe</code> wouldn't be required. However, I think it turned out that, at least in some obscure contexts, new CPU instructions sometimes recycled the opcodes of old CPU instructions, and so running code targetting a certain target feature on a very old CPU could actually run semantically different operations than were intended.</p>",
        "id": 240110517,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621889675
    },
    {
        "content": "<p>I can't remember exactly what, but maybe some very early 16 bit real mode x86 opcodes overlap with some of the new AVX extensions?</p>",
        "id": 240110572,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621889703
    },
    {
        "content": "<p>Oh, there's an example of that up above in the other thread!</p>",
        "id": 240110690,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621889760
    },
    {
        "content": "<p>Then what, philosophically, is undefined behavior, anyways? :^)<br>\nI know, I know, \"prescribed to be unpredictable\", but when <strong>must</strong> Rust insist that the result is unpredictable? Because if we emit aarch64 code, and then you run it on an x86 processor, that's not exactly going to produce more deterministic behavior, nonetheless, at the risk of sounding absurd, we do not actually weigh that, afaik, in our design (it's not <code>unsafe fn main()</code> after all) but we do consider it for target features for a given individual processor, even though it's already definitionally UB to execute that code.</p>\n<p>At what point, exactly, did Rust acquire that burden?</p>",
        "id": 240111414,
        "sender_full_name": "Jubilee",
        "timestamp": 1621890106
    },
    {
        "content": "<p>UB as is usually defined for programming language purposes is not a concept that exists after the compiler is done emitting the machine code. Hardware has its own kinds of UB like for instance indeterminate results when logic voltage is too low, but that's not something a programming language needs to concern itself with… right?</p>\n<p>It still isn't clear to me at least as to whether LLVM is allowed to do whatever it wishes during codegen when the features are not available during codegen. At the very least I remember <code>rdrand</code> causing an assertion in LLVM when the <code>rdrnd</code> feature is not enabled.</p>",
        "id": 240112318,
        "sender_full_name": "nagisa",
        "timestamp": 1621890565
    },
    {
        "content": "<p>By calling <code>#[target_feature]</code> unsafe we leave ourselves some wiggle-room to decide either way in the future.</p>",
        "id": 240112443,
        "sender_full_name": "nagisa",
        "timestamp": 1621890626
    },
    {
        "content": "<p>I would consider that the executing code compiled with a target feature when that feature isn't available is undefined behaviour in general. On x86, it's a #UD exception, but it could actually cause hardware UB on a different ISA. It's entirely possibly that you could hit the HCF instruction. I could presume that is sufficient to warrant unsafe at the rust level.</p>",
        "id": 240117925,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621893572
    },
    {
        "content": "<p>An example of opcode reuse in x86 is <code>lzcnt</code> which is I think <code>rep bsr</code> on older cpus. I once had to debug a bug of cg_clif caused by using lzcnt on an older cpu.</p>",
        "id": 240164525,
        "sender_full_name": "bjorn3",
        "timestamp": 1621936482
    },
    {
        "content": "<p>What about running code on emulators/virtual machines/etc that have different ideas as to what instructions do compared to real hardware?</p>",
        "id": 240169418,
        "sender_full_name": "nagisa",
        "timestamp": 1621939664
    },
    {
        "content": "<p>If you run in a broken VM (or on broken hardware), then you're just kind of screwed. The best we can do is generate correct output according to the relevant specifications.</p>",
        "id": 240182436,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621947367
    },
    {
        "content": "<p>A couple of years ago, I heard a story of an issue where some cloud VMs incorrectly reported that they implemented AES-NI while the underlying hardware did not. Somehow things \"worked\" well enough for a while until people noticed that their \"encrypted backups\" were actually just white noise since the AES instructions were just trapping up to the hypervisor!</p>",
        "id": 240182680,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1621947469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240112318\">said</a>:</p>\n<blockquote>\n<p>UB as is usually defined for programming language purposes is not a concept that exists after the compiler is done emitting the machine code. Hardware has its own kinds of UB like for instance indeterminate results when logic voltage is too low, but that's not something a programming language needs to concern itself with… right?</p>\n</blockquote>\n<p>Hopefully. ^^;</p>\n<blockquote>\n<p>It still isn't clear to me at least as to whether LLVM is allowed to do whatever it wishes during codegen when the features are not available during codegen. At the very least I remember <code>rdrand</code> causing an assertion in LLVM when the <code>rdrnd</code> feature is not enabled.</p>\n</blockquote>\n<p>Yeaaah, that's part of why I'm kind of wondering about this in connection with the wasm SIMD and target-feature 1.1 thing, because the question about possible codegen UB was raised there but not fully addressed (though it's not entirely clear how addressable it is, thus...). And then I realized part of my question was sufficiently general that I should separate it out, basically trying to figure out the \"reverse\" position: where do Rust's obligations to consider what is arguably \"beyond Rust\" behavior start and stop?</p>",
        "id": 240243265,
        "sender_full_name": "Jubilee",
        "timestamp": 1621973350
    },
    {
        "content": "<blockquote>\n<p>UB as is usually defined for programming language purposes is not a concept that exists after the compiler is done emitting the machine code.</p>\n</blockquote>\n<p>I guess the \"problem\" for me, zeroing back on this statement, is that this is what makes it unclear to me where the <code>target_feature</code> burden starts and stops. As Connor says, you could trigger HCF in the CPU... but actually running the code on a given computer with a given feature-set (or absence thereof) happens in a \"beyond Rust\" scenario, and, well...</p>\n<blockquote>\n<p>If you run in a broken VM (or on broken hardware), then you're just kind of screwed.</p>\n</blockquote>\n<p>I am not sure where to draw the line between \"broken ISA\" vs. \"ISA codegen spec vs. execution spec mismatch\".</p>",
        "id": 240244317,
        "sender_full_name": "Jubilee",
        "timestamp": 1621973832
    },
    {
        "content": "<blockquote>\n<p>I am not sure where to draw the line between \"broken ISA\" vs. \"ISA codegen spec vs. execution spec mismatch\".</p>\n</blockquote>\n<p>The only difference between a bug and a feature is intent</p>",
        "id": 240244831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621974097
    },
    {
        "content": "<p>Correct, and yet. ^^;</p>",
        "id": 240245019,
        "sender_full_name": "Jubilee",
        "timestamp": 1621974174
    },
    {
        "content": "<p>If you are an OS, you often have to just deal with hardware bugs, at which point it just becomes a peculiar architecture. The main problem is when these peculiar architectures can't be detected through the normal mechanisms (CPUID et al)</p>",
        "id": 240245076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621974212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240244317\">said</a>:</p>\n<blockquote>\n<p>I guess the \"problem\" for me, zeroing back on this statement, is that this is what makes it unclear to me where the <code>target_feature</code> burden starts and stops.</p>\n</blockquote>\n<p>My understanding is that today we aren't quite sure if LLVM can do unexpected things when you request it to produce the code for an opration which otherwise requires a certain feature to be enabled. Making wasm32 features not require unsafe seems like we'd be going in the direction of saying \"no, LLVM does not do that\".</p>",
        "id": 240245386,
        "sender_full_name": "nagisa",
        "timestamp": 1621974348
    },
    {
        "content": "<blockquote>\n<p>And then I realized part of my question was sufficiently general that I should separate it out, basically trying to figure out the \"reverse\" position: where do Rust's obligations to consider what is arguably \"beyond Rust\" behavior start and stop?</p>\n</blockquote>\n<p>I think we should make every effort to detect and mitigate \"beyond Rust\" problems when possible. (The <code>really_monotonic_clock</code> hack comes to mind.) We may not be able to do much about some kinds of issues, though.</p>",
        "id": 240245488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621974380
    },
    {
        "content": "<p>For reference: <a href=\"#narrow/stream/213817-t-lang/topic/safe.20target_feature.20functions.20for.20wasm/near/238667618\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/safe.20target_feature.20functions.20for.20wasm/near/238667618</a></p>",
        "id": 240245506,
        "sender_full_name": "nagisa",
        "timestamp": 1621974393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240244317\">said</a>:</p>\n<blockquote>\n<p>I guess the \"problem\" for me, zeroing back on this statement, is that this is what makes it unclear to me where the <code>target_feature</code> burden starts and stops. As Connor says, you could trigger HCF in the CPU... but actually running the code on a given computer with a given feature-set (or absence thereof) happens in a \"beyond Rust\" scenario, and, well...</p>\n</blockquote>\n<p>Well, combining things like <code>target_feature</code> and <code>is_&lt;arch&gt;_feature_detected!</code>, I'd argue that it is within the purview of rust to consider execution environments as having \"particular\" features, even if the consideration extends no further than a simple <em>conditionally-supported</em> statement.</p>",
        "id": 240249021,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621976254
    },
    {
        "content": "<p>(As a semi-related note, I would consider that target features are <em>conditionally-supported</em> already, even if there isn't normative text on the subject, and lacking otherwise defined behaviour, the unsupported case falls back to UB)</p>",
        "id": 240249258,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621976360
    },
    {
        "content": "<blockquote>\n<p>lacking otherwise defined behaviour, the unsupported case falls back to UB</p>\n</blockquote>\n<p>I don't think Rust has UB-of-the-gaps like this. If something is unspecified that doesn't mean it's UB, that means the spec is incomplete</p>",
        "id": 240251506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621977452
    },
    {
        "content": "<p>I mean, what else can a spec gap be? If something doesn't have defined behaviour by the spec, what limits are imposed on the behaviour that can be assigned by the implementation? There is a difference between unspecified and \"is not present in the specification\".</p>",
        "id": 240252001,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621977727
    },
    {
        "content": "<p>(It's also generally the case, at least in C and C++, that when a <em>conditionally supported</em> feature is unsupported, it's use is either ill-formed or undefined behaviour)</p>",
        "id": 240252103,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621977800
    },
    {
        "content": "<p>Yes, this is a deliberate departure from C/C++ specs where spec omissions are UB</p>",
        "id": 240252280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621977897
    },
    {
        "content": "<p>If there is a spec gap, that doesn't mean anything other than that the spec is incomplete/buggy/needs to be fixed. It doesn't imply that the behavior is defined, undefined, conditionally-supported or anything else like that</p>",
        "id": 240252437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621977973
    },
    {
        "content": "<p>UB of the gaps! <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <br>\n<span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240245488\">said</a>:</p>\n<blockquote>\n<p>I think we should make every effort to detect and mitigate \"beyond Rust\" problems when possible. (The <code>really_monotonic_clock</code> hack comes to mind.) We may not be able to do much about some kinds of issues, though.</p>\n</blockquote>\n<p>I think, for Rust at least, the <code>really_monotonic_clock</code> hack happens to be a situation where we are trying to undermine a type violation that is directly \"in Rust\" (that is, we promised monotonicity). So we can either hack monotonicity in or repeal the promise of monotonicity. The latter is a breakage of the kind that Rust's semver policies arguably might <strong>not</strong> permit without incrementing Rust Major, in spite of being a fix.</p>",
        "id": 240252597,
        "sender_full_name": "Jubilee",
        "timestamp": 1621978083
    },
    {
        "content": "<p>I think totally-safe-transmute falls in the same category though; it is an OS feature that directly undermines a promise that rust is trying to make. The only difference is that there is very little we can do about it. It's in the same category as trying to prove that a program doesn't have any panics and then someone pulls the plug on the computer</p>",
        "id": 240252874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621978282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240251506\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>lacking otherwise defined behaviour, the unsupported case falls back to UB</p>\n</blockquote>\n<p>I don't think Rust has UB-of-the-gaps like this. If something is unspecified that doesn't mean it's UB, that means the spec is incomplete</p>\n</blockquote>\n<p>In either case, it could just as easily be a split statement. The text I would write in that case could be:</p>\n<blockquote>\n<ul>\n<li>If a function with a <code>#[target_feature]</code> attribute is called in a context where a feature indicated is not enabled, the program is ill-formed if the call does not occur within an unsafe context. Such a call is <em>conditionally-supported</em>, and the behaviour is undefined if unsupported. [Note: An implementation may make use of features enabled by the <code>#[target_feature]</code> attribute to generate better optimized code than may be possible in the remainder of the crate]</li>\n</ul>\n</blockquote>",
        "id": 240253217,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978540
    },
    {
        "content": "<p>(If UB-by-deliberate omission is permitted, I would simply stop the normative text at \"Such a call is <em>conditionally-supported</em>\")</p>",
        "id": 240253338,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978597
    },
    {
        "content": "<p>Yeah in practice the monotonicity hack is there because it is something that can be controlled within the scope of the Rust program. So I guess we could apply a similar reasoning here and say that <code>unsafe</code> only applies to things which can be governed entirely within Rust control flow.</p>",
        "id": 240253373,
        "sender_full_name": "Jubilee",
        "timestamp": 1621978619
    },
    {
        "content": "<p>Now we just need to provide a definition of Rust control flow which I am sure will be simple and non-controversial. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 240253413,
        "sender_full_name": "Jubilee",
        "timestamp": 1621978665
    },
    {
        "content": "<p>For the cases of buggy processors, I would agree. In general, though ,<code>#[target_feature]</code> is close fairly close to what I described in the Note: a indication that the implementation is allowed to generate more optimized code, using the indicated features. To facilate that optimization, it must therefore be undefined behaviour to enter that code where the feature is unavailable, otherwise such optimizations would arguably violate the <em>as-if</em> rule.</p>",
        "id": 240253636,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978811
    },
    {
        "content": "<p>The architecture and the ISA is, primarily, a detail of the implementation. It's how the implementation chose to emulate the required observable behaviour of the Abstract Machine, whatever that means for rust.</p>",
        "id": 240253716,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621978871
    },
    {
        "content": "<p>(Also, making it undefined behaviour to enter code that requires unavailable target features would be useful for abi issues accross such bounderies)</p>",
        "id": 240254012,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621979047
    },
    {
        "content": "<p>I agree that it should be undefined behavior to call a function with an unsupported <code>#[target_feature]</code>. That is more or less forced by the hardware, since it's essentially hardware UB already. Whether that entails <code>unsafe</code> depends on the degree to which we can statically ensure that we only ever call functions when the target features are supported.</p>",
        "id": 240256304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621980383
    },
    {
        "content": "<p>What about the WebAssembly case, where we have what we assume is a static guarantee that entering unsupported features will trap? To what degree do we allow the implementation details of the underlying \"\"\"hardware\"\"\" to leak into Rust when it reduces possible cases of UB?</p>",
        "id": 240256614,
        "sender_full_name": "Jubilee",
        "timestamp": 1621980587
    },
    {
        "content": "<p>A function that is always safe to call (i.e. never causes UB) does not need to be marked <code>unsafe</code>. We already do this kind of thing with \"safe wrappers\", but it can also be implemented directly on the intrinsic. The spec already knows what is UB and what isn't so it can include language to this effect.</p>",
        "id": 240256877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621980747
    },
    {
        "content": "<blockquote>\n<p>I agree that it should be undefined behavior to call a function with an unsupported <code>#[target_feature]</code></p>\n</blockquote>\n<p>Actually this needs to be amended to \"conditionally-supported\" since making all unsupported features UB would exclude the wasm case. Ideally the spec should enumerate the status of all target features - whether they are known to trap, are known to be UB, or have some other status</p>",
        "id": 240257276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621981001
    },
    {
        "content": "<p>I'd argue that, even in the wasm case where the runtime result is known, it's still necessary to make it undefined behaviour, in order to release the implementation from that burden. Otherwise, rust would have to define exactly what all happens in that case, which can be difficult, and \"trapping\" wouldn't be able to consider <code>SIGILL</code>.<br>\nAlso, I'd argue that the list of target features shouldn't be exhaustive in the spec, and should rather be <em>implementation-defined</em> (possibly with a minimum supported list for some common architectures). In particular, I would personally rather avoid constraining the architectures available to rust implementations, and requiring admission into the specification (which may not be granted for some architectures, but various implementations may be capable of supporting them trivially).</p>",
        "id": 240266095,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621988214
    },
    {
        "content": "<blockquote>\n<p>it's still necessary to make it undefined behaviour, in order to release the implementation from that burden</p>\n</blockquote>\n<p>I just realised that the burden I'm referring to may not be obvious. I'm referring to the burden of either issuing the trap as required (even if it doesn't make use of the target_feature), or maintaining correct state of the AM for the purposes of determining observable behaviour (if it does).</p>",
        "id": 240274105,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621997400
    },
    {
        "content": "<blockquote>\n<p>Also, I'd argue that the list of target features shouldn't be exhaustive in the spec, and should rather be implementation-defined (possibly with a minimum supported list for some common architectures). In particular, I would personally rather avoid constraining the architectures available to rust implementations, and requiring admission into the specification (which may not be granted for some architectures, but various implementations may be capable of supporting them trivially).</p>\n</blockquote>\n<p>I've been thinking about what a formal specification of rust would look like these days, and it's really not clear to me how to model divergent architectures unless the possible behaviors are explicitly enumerated. That may well mean that the spec is limited to Tier-1 targets, but generalizing over all possible behaviors while also not being UB somehow seems like a very difficult balance otherwise.</p>",
        "id": 240275625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621999445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240274105\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it's still necessary to make it undefined behaviour, in order to release the implementation from that burden</p>\n</blockquote>\n<p>I just realised that the burden I'm referring to may not be obvious. I'm referring to the burden of either issuing the trap as required (even if it doesn't make use of the target_feature), or maintaining correct state of the AM for the purposes of determining observable behaviour (if it does).</p>\n</blockquote>\n<p>We're supposing for the sake of discussion that WASM <em>does</em> issue the trap as required under all circumstances. If that can't be guaranteed then obviously we can't remove the <code>unsafe</code>.</p>",
        "id": 240275731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621999583
    },
    {
        "content": "<p>Couldn't a formal specification of Rust lean heavily on implementation-defined behavior? A formal spec for Rust should be able to support at least a large subset of targets, or else it risks just being ignored and rustc being the defacto standard.</p>",
        "id": 240276155,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1622000218
    },
    {
        "content": "<p>The thing is, it's not clear to me what it means to \"lean heavily on implementation-defined behavior\". That sounds like the spec is parameterized on a huge number of functions specifying the semantics of individual instructions to the point that the spec itself offers very little and it may not even be clear that a model exists</p>",
        "id": 240276853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001219
    },
    {
        "content": "<p>I would rather just see all supported targets in the spec, since that's what rustc does (possibly with some generic / parameterized behavior for other targets as a template for future expansion)</p>",
        "id": 240276935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001292
    },
    {
        "content": "<p>Well trap doesn't have a defined behavior actually.<br>\nI mean, it does, but it also doesn't: it generates an exception of some unspecified nature, but deterministically, and returns control flow to the environment beyond wasm.</p>",
        "id": 240277022,
        "sender_full_name": "Jubilee",
        "timestamp": 1622001412
    },
    {
        "content": "<p>That sounds like \"as good as a panic\". In particular execution visibly terminates abnormally and instructions following the trap are not executed</p>",
        "id": 240277045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001463
    },
    {
        "content": "<p><code>std::process::abort</code> is a safe function</p>",
        "id": 240277108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622001524
    },
    {
        "content": "<p>but you have to spec no_std / bare metal too</p>",
        "id": 240281812,
        "sender_full_name": "Lokathor",
        "timestamp": 1622007872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240275731\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240274105\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it's still necessary to make it undefined behaviour, in order to release the implementation from that burden</p>\n</blockquote>\n<p>I just realised that the burden I'm referring to may not be obvious. I'm referring to the burden of either issuing the trap as required (even if it doesn't make use of the target_feature), or maintaining correct state of the AM for the purposes of determining observable behaviour (if it does).</p>\n</blockquote>\n<p>We're supposing for the sake of discussion that WASM <em>does</em> issue the trap as required under all circumstances. If that can't be guaranteed then obviously we can't remove the <code>unsafe</code>.</p>\n</blockquote>\n<p>Does it guarantee a trap even if the implementation chooses not to exploit the <code>#[target_feature]</code> as permitted? If so, then it could be <em>implementation-defined</em> whether the implementation issues a trap instead. But specifying that trap is either going to be incredibly handwavying (without being exhaustive), or insufficient to handle all cases, when the undefined behaviour case would permit the issuance of a trap (and also permit the implementation making an independant promise of such).</p>",
        "id": 240303614,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622024620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240276853\">said</a>:</p>\n<blockquote>\n<p>The thing is, it's not clear to me what it means to \"lean heavily on implementation-defined behavior\". That sounds like the spec is parameterized on a huge number of functions specifying the semantics of individual instructions to the point that the spec itself offers very little and it may not even be clear that a model exists</p>\n</blockquote>\n<p>imo the rust spec should be agnostic of the finite list of supported targets. It should neither mandate implementations support any particular platform, nor forbid such (either implicitly or explicitly) beyond generic specification requirements that consequentially limit implementation platforms.</p>",
        "id": 240303990,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622024869
    },
    {
        "content": "<blockquote>\n<p>imo the rust spec should be agnostic of the finite list of supported targets.</p>\n</blockquote>\n<p>How then does one define the behavior of <code>#[cfg(target_arch = \"x86_64\")]</code>? Presumably implementations are not allowed to disagree on the abstract machine semantics of a program using such cfg directives. But the only way to establish such semantics is to put x86-specific constraints literally in the spec. It can be done in an open ended way, but I don't think a rust implementation that swaps the meaning of <code>target_arch = \"x86_64\"</code> and <code>target_arch = \"arm\"</code> should be considered conforming, because a perfectly well defined rust program running under rustc could cause almost arbitrary misbehavior if run on an incompatible architecture.</p>",
        "id": 240308447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622027822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240308447\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>imo the rust spec should be agnostic of the finite list of supported targets.</p>\n</blockquote>\n<p>How then does one define the behavior of <code>#[cfg(target_arch = \"x86_64\")]</code>? Presumably implementations are not allowed to disagree on the abstract machine semantics of a program using such cfg directives. But the only way to establish such semantics is to put x86-specific constraints literally in the spec. It can be done in an open ended way, but I don't think a rust implementation that swaps the meaning of <code>target_arch = \"x86_64\"</code> and <code>target_arch = \"arm\"</code> should be considered conforming, because a perfectly well defined rust program running under rustc could cause almost arbitrary misbehavior if run on an incompatible architecture.</p>\n</blockquote>\n<p>The value of each <code>target_*</code> cfg key is implementation defined.</p>",
        "id": 240310014,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622028827
    },
    {
        "content": "<p>And then it's constrained that <code>core::arch::x86_64</code> exists if <code>cfg(target_cpu=\"x86_64\")</code>, which contains various things (and those have particular behaviour within the abstract machine).</p>",
        "id": 240310227,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622028965
    },
    {
        "content": "<p>It can contain particular constraints on existing well-known architectures, but, for example, if I wanted to implement the <code>w65</code> architecture, it is my opinion that rust should not prohibit that implementation choice. Likewise, if I don't want to implement the aarch64 architecture, rust shouldn't require that it's implemented (that would constrain something like gcc-rs, which is a single-target toolchain).</p>",
        "id": 240310552,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622029146
    },
    {
        "content": "<p>I don't think either of those criteria are difficult to achieve, although for the <code>w65</code> example we would have to leave in some room to potentially extend the spec to cover the architecture \"properly\", at which point an early adopter implementation may become nonconforming</p>",
        "id": 240311202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622029582
    },
    {
        "content": "<p>Well, at that point, I would presume that the implementor would be able to offer that experience to avoid that issue.</p>",
        "id": 240311569,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622029858
    },
    {
        "content": "<p>Supported targets are necessarily part of the Rust language and library, because the language and library define target-specific behavior. If nothing else, there needs to be information about what sizes and layouts various types have, as well as what modules are defined for that target.</p>",
        "id": 240428096,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622099788
    },
    {
        "content": "<p>If you'd like to implement w65, the same issues apply as if you want to add any other new language feature; either way it needs some amount of design work.</p>",
        "id": 240428268,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622099960
    },
    {
        "content": "<p>The issue comes when the people in charge of the design has no reason to pursue designing a feature. w65 in particular is close to 40 (may even be more) years old, and sees limited use. I have reasons to support it (related to SNES Homebrew development),  but  I doubt many other people do.  Thus I find it extraordinarily unlikely that w65 would be explicitly supported by the Rust Language.<br>\n I would also prefer <em>not</em> having to do the extra work to gate off targets that rust doesn't permit, when the default state for my design is to permit it (my design just parses the target tuple, then passes it to the frontend, and the frontend can obtain information about the target).  Modules are somewhat fair (though they can easily be introduced with a feature gate, as could inline assembly), but I'd argue that size and layout could easily be made <em>implementation-defined</em> rather than exhaustively enumerating the values. Likewise, <code>target_feature</code>s could be <em>implementation-defined</em>.</p>",
        "id": 240447790,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622112604
    },
    {
        "content": "<p>The fact that size is at least u16 is baked in to the standard library at least.</p>",
        "id": 240451712,
        "sender_full_name": "nagisa",
        "timestamp": 1622115068
    },
    {
        "content": "<p>Yes, that would be a constraint on the <em>implementation-defined</em> size of <code>usize</code>.</p>",
        "id": 240452400,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622115522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> So, two things about that:<br>\n1) If the standards for tier 3 are such that SNES homebrew development can't meet them, we've done something very wrong. ;)  I very much hope that in general, the standards for tier 3 (unlike the higher tiers) are a sufficiently minimal set that they would be more-or-less what any other implementation would want anyway.<br>\n2) If it turns out that there's a second relevant implementation for which (1) is not actually true in practice, I imagine we could expand our processes such that we could collaboratively determine the minimum details needed for uniform handling of the target, such as target triple name, type sizes, and similar. We could even add a concept of \"tier 4 targets\": \"this isn't in the codebase, but there's enough consensus on it to not end up with incompatible implementations in the future\".</p>",
        "id": 240496669,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622133791
    },
    {
        "content": "<p>I agree that if Rust can't compile for the SNES then I'm rioting.</p>",
        "id": 240526728,
        "sender_full_name": "Jubilee",
        "timestamp": 1622147314
    },
    {
        "content": "<p>I mean I don't expect to load up an actual cartridge any time soon.</p>",
        "id": 240526757,
        "sender_full_name": "Jubilee",
        "timestamp": 1622147334
    },
    {
        "content": "<p>I would love to, but sadly my console's video output isn't reliable anymore.</p>",
        "id": 240528187,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622148052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240526728\">said</a>:</p>\n<blockquote>\n<p>I agree that if Rust can't compile for the SNES then I'm rioting.</p>\n</blockquote>\n<p>Well, I doubt rustc specifically would be able to compile it any time soon, I've abandoned my efforts for implementing a w65 backend for llvm. That being said, my primary issue is with <code>usize</code> (pointers are 24-bit zero-extended to 32-bit, but the size type is 16-bit). But it's a lot more of an issue if Rust itself prohibits the implementation, either explicitly, or by exhaustively listing the required ones, then if there are technical details that have to be solved.</p>",
        "id": 240529694,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622148693
    },
    {
        "content": "<p>would rustc-codegen-gcc solve the \"no llvm target\" issue?</p>",
        "id": 240530272,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1622148949
    },
    {
        "content": "<p>There alas also isn't a gcc target, though I'm working on (re)implementing binutils, so it or gcc rs might have some in not-upstream in the future. I'm also working on an implementation (of not just rust) that will come with w65 support (where the\"I'd rather not have to specifically exclude targets\" issue arises).</p>",
        "id": 240530824,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622149194
    },
    {
        "content": "<p>I think the Rust specification could say that, for targets that are not addressed specifically by the specification, the behavior is implementation-defined.</p>",
        "id": 240533146,
        "sender_full_name": "Jubilee",
        "timestamp": 1622150213
    },
    {
        "content": "<p>Probably doesn't even need to say for non-addressed targets. If it's just implementation-defined, it can be constrained down to something close to well defined. Fully constraining known platforms also may burden implementations. For example, if rust says that on x86_64, the pointer width is 64, then an implementation could not then operate on x86_64, but compile to the x32 abi (which has only 32-bit pointers, but generates 64-bit code).</p>",
        "id": 240534071,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622150701
    },
    {
        "content": "<p>The x32 ABI has a different target, for exactly that reason.</p>",
        "id": 240536079,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240529694\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240526728\">said</a>:</p>\n<blockquote>\n<p>I agree that if Rust can't compile for the SNES then I'm rioting.</p>\n</blockquote>\n<p>Well, I doubt rustc specifically would be able to compile it any time soon, I've abandoned my efforts for implementing a w65 backend for llvm. That being said, my primary issue is with <code>usize</code> (pointers are 24-bit zero-extended to 32-bit, but the size type is 16-bit). But it's a lot more of an issue if Rust itself prohibits the implementation, either explicitly, or by exhaustively listing the required ones, then if there are technical details that have to be solved.</p>\n</blockquote>\n<p>I don't think Rust should list <em>required</em> targets, just \"if you implement this target this is how it must work\".</p>",
        "id": 240536160,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151894
    },
    {
        "content": "<p>I do think, because of that, there's value in Rust saying \"a target must be in this list\", but that's only a problem if it's non-trivial to extend that list.</p>",
        "id": 240536244,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151937
    },
    {
        "content": "<p>That's what I was getting at when I suggested \"tier 4\" targets: we can evaluate a target without necessarily including it.</p>",
        "id": 240536286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622151957
    },
    {
        "content": "<p>Yeah, I meant permitted targets not required targets there.</p>",
        "id": 240536353,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622151977
    },
    {
        "content": "<p>My primary concern is if some third-party implementation adds a target without any kind of coordination at all, and sets the properties of that target, and then later rustc is expected to preserve some of those properties for compatibility with the third-party implementation.</p>",
        "id": 240536636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152144
    },
    {
        "content": "<p>That's the main reason that I don't think it's unreasonable to say \"hey, please coordinate the addition of targets\". If we refused to participate in that coordination, then I'd certainly understand people deciding they were going to do it anyway.</p>",
        "id": 240536724,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152198
    },
    {
        "content": "<p>This isn't a hypothetical; this happens for existing targets in other compilers, where the first compiler to target a platform may set a less-than-ideal ABI and subsequent compilers are stuck with it.</p>",
        "id": 240536825,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152249
    },
    {
        "content": "<p>I'm <em>happy</em> to spend time reviewing \"hey, can we have a tier 4 target for (insert arbitrary platform here)\" requests if it means that we actually coordinate and design new targets.</p>",
        "id": 240536972,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152332
    },
    {
        "content": "<p>The reason I say I wouldn't like a specific list of permitted targets, is the way I'd expect the lccc rust frontend to behave when it's told what target to compile for is to query the properties of the target from xlang (the core architecture of lccc), and just follow it. If then the list of targets were restricted, I'd have to implement a whitelist in the rustc driver of the main lccc program, which is extra work, both for myself as the implementor, and the actual program itself (potentially requiring a string hashtable lookup or a tree search, if the target names are exact, like rustc seems to think they are).</p>",
        "id": 240537040,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622152372
    },
    {
        "content": "<p>Is a simple \"member of HashSet\" check <em>that</em> bad?</p>",
        "id": 240537215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152462
    },
    {
        "content": "<p>(Also, you wouldn't have to if every xlang target were covered.)</p>",
        "id": 240537239,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152478
    },
    {
        "content": "<p>Another option would be for xlang's target data to include Rust target definition information (e.g. \"what size is the xyz type\"), and then you could do that lookup (which you may need to do anyway) and treat the absence of that information as \"this target isn't supported\".</p>",
        "id": 240537358,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152552
    },
    {
        "content": "<p>I just don't want to end up in a world where rustc faces a choice of either \"break people using a third-party compiler\" or \"precisely match the target design from a third-party compiler\".</p>",
        "id": 240537476,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152606
    },
    {
        "content": "<p>I don't think that's good for either third-party compilers or the Rust compiler.</p>",
        "id": 240537519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622152637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240537239\">said</a>:</p>\n<blockquote>\n<p>(Also, you wouldn't have to if every xlang target were covered.)</p>\n</blockquote>\n<p>That issue then becomes I need approval from the rust teams to add a target to the C or the C++ frontend (or to any third party xlang frontend, which, given that I've designed the api to be modular, would make it a non-starter). It's possible I could do the latter (I haven't entirely worked out the design), however, considering I'd already be storing the pointer size, and the lock-free atomic sizes, I can't think of much I would store that wouldn't be just deliberately duplicating information (aside from just storing an explicit <code>bool is_rust_target;</code>, which may not be a bad design)</p>",
        "id": 240538534,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622153277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> </p>\n<blockquote>\n<p>That issue then becomes I need approval from the rust teams to add a target to the C or the C++ frontend</p>\n</blockquote>\n<p>Fair point, and that's <em>not</em> something you should have to do; I didn't want to suggest otherwise. I more meant that since you care about Rust , \"every xlang target is a Rust target\" may actually be close to the case in practice. :)</p>",
        "id": 240539377,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622153936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240538534\">said</a>:</p>\n<blockquote>\n<p>aside from just storing an explicit <code>bool is_rust_target;</code>, which may not be a bad design</p>\n</blockquote>\n<p>Yeah, that does seem reasonable and better than a separate list, since you do that target lookup anyway.</p>",
        "id": 240539431,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622153994
    },
    {
        "content": "<p>(Of course, all of this depends on whether or not rust itself considers equivalent but different targets distinct. If so, then I'd have to implement a separate list, since the lookup is against the canonical form, not against the target name)</p>",
        "id": 240541648,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622155728
    },
    {
        "content": "<p>What do you mean by \"equivalent but different targets\"?</p>",
        "id": 240542082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622156143
    },
    {
        "content": "<p>Targets that are different in name, but canonicalize to the same thing (xlang performs target canonicalization). For example (though rustc does not accept either, which I consider wrong, as config.guess, at least on my machine, produces the latter) x86_64-linux-gnu canonicalizes to x86_64-pc-linux-gnu. Also, both of these targets are semantically equivalent (though distinct) with x86_64-unknown-linux-gnu (which rustc <em>does</em> accept).</p>",
        "id": 240542824,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622156680
    },
    {
        "content": "<p>I can't imagine any circumstance in which rustc accepted x86_64-pc-linux-gnu and treated it as <em>different</em> than x86_64-unknown-linux-gnu.</p>",
        "id": 240544635,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622158149
    },
    {
        "content": "<p>Either rustc won't accept it at all, or will treat it as identical. Likewise <code>x86_64-linux-gnu</code>.</p>",
        "id": 240544667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622158189
    },
    {
        "content": "<p>Accepting target aliases has come up before, and I don't think it'd be unreasonable to ask for target alias support in Rust.</p>",
        "id": 240544814,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622158288
    },
    {
        "content": "<p><a href=\"https://github.com/microsoft/xlang\">https://github.com/microsoft/xlang</a>, eh?<br>\nAs far as targets go, I believe addressing logical targets is preferable to matching exact strings.</p>",
        "id": 240549969,
        "sender_full_name": "Jubilee",
        "timestamp": 1622163068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240549969\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/microsoft/xlang\">https://github.com/microsoft/xlang</a>, eh?<br>\nAs far as targets go, I believe addressing logical targets is preferable to matching exact strings.</p>\n</blockquote>\n<p>Not that, no. I wasn't even aware that existed. The xlang I'm referring to is the middle-architecture of lccc (<a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a>).</p>",
        "id": 240550663,
        "sender_full_name": "Connor Horman",
        "timestamp": 1622163781
    },
    {
        "content": "<p>Yeah, I just found it funny.</p>",
        "id": 240552505,
        "sender_full_name": "Jubilee",
        "timestamp": 1622165771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> </p>\n<blockquote>\n<p>Then what, philosophically, is undefined behavior, anyways? :^)</p>\n</blockquote>\n<p>My 2 cents: <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#undefined-behavior\">https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#undefined-behavior</a></p>",
        "id": 240698388,
        "sender_full_name": "RalfJ",
        "timestamp": 1622289200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/unsafe.20and.20.23.5Btarget_feature.5D/near/240112318\">said</a>:</p>\n<blockquote>\n<p>It still isn't clear to me at least as to whether LLVM is allowed to do whatever it wishes during codegen when the features are not available during codegen. At the very least I remember <code>rdrand</code> causing an assertion in LLVM when the <code>rdrnd</code> feature is not enabled.</p>\n</blockquote>\n<p>well, that makes <a href=\"https://github.com/rust-lang/rust/pull/84988\">https://github.com/rust-lang/rust/pull/84988</a> even more interesting...</p>\n<p>EDIT: ah okay that was already covered. and then discussion derailed a bit...^^</p>",
        "id": 240698448,
        "sender_full_name": "RalfJ",
        "timestamp": 1622289275
    }
]