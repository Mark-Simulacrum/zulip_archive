[
    {
        "content": "<p>I was reading <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.60usize.60.20vs.20.60size_t.60\">this Zulip thread</a>, where a <a href=\"https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369\">pre-RFC</a> was spawned related to the question of usize/isize vs size_t/ssize_t. In the documentation for <a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.offset-1\"><code>&lt;*mut T&gt;::offset()</code></a> it mentions:</p>\n<blockquote>\n<p>...<br>\nThe computed offset, in bytes, cannot overflow an <code>isize</code>.<br>\n...<br>\nsome 32-bit and 16-bit platforms may successfully serve a request for more than <code>isize::MAX</code> bytes with things like Physical Address Extension. As such, memory acquired directly from allocators or memory mapped files may be too large to handle with this function.<br>\n...</p>\n</blockquote>\n<p>If the above mentioned (pre-)RFC eventually gets accepted, would the description in the documentation still be accurate? If I read the <a href=\"https://llvm.org/docs/GetElementPtr.html\">LLVM documentation</a> about <code>GEP</code>, it seems that LLVM hints that it expects an <code>ssize_t</code> as the offset parameter:</p>\n<blockquote>\n<p>...<br>\nGEP does use target-dependent parameters for the size and layout of data types, which targets can customize.<br>\n...<br>\nIndexing into an array only depends on the size of the array element, not the number of elements.<br>\n...<br>\nAs such, there are some ramifications of this for inbounds GEPs: scales implied by array/vector/pointer indices are always known to be “nsw” since they are signed values that are scaled by the element size.<br>\n...</p>\n</blockquote>\n<p>This then would seem to conflict with the Rust documentation for <code>offset()</code> if:</p>\n<ul>\n<li><code>isize</code> is not guaranteed to be equal to <code>ssize_t</code> and</li>\n<li><code>isize</code> is the same as <code>intptr_t</code> and</li>\n<li><code>ssize_t != intptr_t</code> on the target platform, because informally stated, this implies that <code>isize::MAX &gt; ssize_t::MAX</code>.</li>\n</ul>\n<p>Is this a correct observation? Should I use <a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset-1\"><code>&lt;*mut T&gt;::wrapping_offset()</code></a> already instead to protect against this possible future incompatibility? Or will <code>&lt;*mut T&gt;::wrapping_offset()</code> have the same problem when eventually dereferencing the resulting pointer?</p>",
        "id": 257815577,
        "sender_full_name": "Pointerbender",
        "timestamp": 1634374583
    },
    {
        "content": "<blockquote>\n<p>Or will &lt;*mut T&gt;::wrapping_offset() have the same problem when eventually dereferencing the resulting pointer?</p>\n</blockquote>\n<p>Assuming my other observations are correct, I think I can already answer this part of my own question. The <a href=\"https://llvm.org/docs/LangRef.html#id233\">LLVM reference says</a>:</p>\n<blockquote>\n<p>If the inbounds keyword is not present, the offsets are added to the base address with silently-wrapping two’s complement arithmetic. If the offsets have a different width from the pointer, they are sign-extended or truncated to the width of the pointer. The result value of the getelementptr may be outside the object pointed to by the base pointer. The result value may not necessarily be used to access memory though, <strong>even if it happens to point into allocated storage</strong>. See the Pointer Aliasing Rules section for more information.</p>\n</blockquote>",
        "id": 257818737,
        "sender_full_name": "Pointerbender",
        "timestamp": 1634377827
    },
    {
        "content": "<p>Oh wait, I think I read that wrong. \"allocated storage\" means something different than \"the same allocated object or one past the end\", I think. So, I believe that answer is still inconclusive :)</p>",
        "id": 257818902,
        "sender_full_name": "Pointerbender",
        "timestamp": 1634378014
    }
]