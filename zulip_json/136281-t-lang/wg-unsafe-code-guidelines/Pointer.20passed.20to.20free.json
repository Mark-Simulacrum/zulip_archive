[
    {
        "content": "<p>When freeing an allocation, does the pointer have to be a copy of the original pointer, or is passing a raw pointer you got from an <code>&amp;</code> to the allocation ok? What about an <code>&amp;mut</code>? I have always followed the rule that you should free the original pointer, but miri doesn't seem to care:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">into_raw</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">));</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">r</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278453599,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649575686
    },
    {
        "content": "<p>Ah, right. The playground doesn't use the stricter flags. Miri does complain when using stricter options.</p>",
        "id": 278453666,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649575808
    },
    {
        "content": "<p>Still, if the pointer is derived from a mutable reference, then that's still fine.</p>",
        "id": 278453890,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649576189
    },
    {
        "content": "<p>Stacked Borrows says any pointer that can mutate the memory, can also deallocate it</p>",
        "id": 278472105,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602099
    },
    {
        "content": "<p>also there can't be any active \"protected\" items anywhere on the stack</p>",
        "id": 278472112,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602120
    },
    {
        "content": "<p>but this is tied up with quite a few other discussions... like <a href=\"https://github.com/rust-lang/miri/issues/1909\">https://github.com/rust-lang/miri/issues/1909</a> and <a href=\"https://github.com/rust-lang/rust/issues/55005\">https://github.com/rust-lang/rust/issues/55005</a></p>",
        "id": 278472237,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602323
    },
    {
        "content": "<p>I <em>think</em> <span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> you're asking about this because of <a href=\"https://github.com/tokio-rs/tokio/pull/4608\">https://github.com/tokio-rs/tokio/pull/4608</a> right? I'm just trying to make sure I'm following everything.</p>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> you said this in the (lengthy) discussion about Arc above. tokio-utils is doing basically the same thing as far as I can tell:</p>\n<blockquote>\n<p>References generally only have to be \"valid when used\" -- though \"used\" is interpreted very coarsely and includes reborrows and (typed) copies, not just dereferences. The only exception are references passed as function arguments.</p>\n</blockquote>\n<p>Alice has now pointed out <em>two</em> cases that I missed in my PR where a <code>&amp;mut</code> is passed to a function which accepts <code>*mut</code> and which may deallocate the pointer. My (I now think incorrect) expectation was that Miri should have generated a protector error on the call which freed it. So from my reading of the issue about <code>Arc</code> it sounds like this code pattern is not invalid according to Stacked Borrows, but it's in some unknown territory where we're not sure if it's UB or not because the reference is dangling, but it's not used. Is that right?</p>",
        "id": 278481924,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649614252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span>  if the function has argument type <code>*mut</code> then it doesn't generate protectors</p>",
        "id": 278488690,
        "sender_full_name": "RalfJ",
        "timestamp": 1649623405
    },
    {
        "content": "<p>the issue with deallocation is with functions that take references, and those references are deallocated (or otherwise invalidated) while the function runs</p>",
        "id": 278488702,
        "sender_full_name": "RalfJ",
        "timestamp": 1649623430
    },
    {
        "content": "<p>But if the function converts a *mut somewhere into a &amp;mut then passes the &amp;mut to a function accepting a *mut which deallocates, is there any problem with the now-dangling reference? That is, the reference dangling but unused after the deallocating function returns.</p>",
        "id": 278488854,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649623616
    },
    {
        "content": "<p>It feels like the reference definitely dangles but if nobody uses it, this feels like it's in some murky area between safety and validity invariants</p>",
        "id": 278488915,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649623688
    },
    {
        "content": "<p>whether a protector is created depends on the declared type of the function</p>",
        "id": 278489206,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624084
    },
    {
        "content": "<p>how you compute the argument is irrelevant</p>",
        "id": 278489214,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624093
    },
    {
        "content": "<blockquote>\n<p>That is, the reference dangling but unused after the deallocating function returns.</p>\n</blockquote>\n<p>Isn't that possible in safe code?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// now xref dangles, but is not used any more. this is fine.</span>\n</code></pre></div>",
        "id": 278489231,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624159
    },
    {
        "content": "<p>Ah, of course. Thanks for the explanation.</p>",
        "id": 278490886,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649626286
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> It was your PR that prompted me to open this thread, yes, but it is a question I have pondered for a long time before that.</p>",
        "id": 278491104,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649626624
    }
]