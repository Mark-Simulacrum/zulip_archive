[
    {
        "content": "<p>(continuing from <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F\">#t-lang/wg-unsafe-code-guidelines &gt; Problems with PVI - What optimizations does it break?</a> )</p>\n<p>Let's say we use an SMT solver. That makes everything easier to model than just SAT. Here's a sketch for a Miri-like checker.</p>\n<p>Our world contains locations, which are each assigned a stack and values. Both stacks and values can mention tags. There is nondeterminism in these stacks and in the values. However, if we erase the tags out of values then they are the same in every nondeterministic world. This means that we can still execute the program deterministically â€” as long as we can figure out the erased value of every location.</p>\n<h3>Defining the SMT model</h3>\n<p>Let's reify the way in which the \"spine\" of values is always the same. We introduce a kind of \"tag variables\" ğ‘¡. Then a value becomes</p>\n<div class=\"codehilite\"><pre><span></span><code>ğ‘†ğ‘ğ‘ğ‘™ğ‘ğ‘Ÿ â‰œ Pointer(ğ‘™, ğ‘¡) | ğ‘§      where ğ‘§ âˆˆ â„¤\n</code></pre></div>\n\n<p>(swapping out ğ‘¡ for t).</p>\n<p>Stacks and items stay the same, and contain ordinary natural-valued tags.</p>\n<p>In our SMT model, we introduce</p>\n<ul>\n<li>for every location a tag variable ğ‘¡_ğ‘–  : â„•</li>\n<li>for every location a stack variable ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘™ : ğ‘†ğ‘¡ğ‘ğ‘ğ‘˜</li>\n</ul>\n<p>The scalar part of memory stays out of SMT-land, they do not get variables.</p>\n<p>We write ğ‘ƒ((ğ‘¡), (ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜)) for a predicate over this model.</p>\n<h3>Execution</h3>\n<p>At runtime, we keep</p>\n<ol>\n<li>The program under evaluation. (expression + call stack, I guess)</li>\n<li>The set of live locations</li>\n<li>For every live location, its current scalar value â€” with tags replaced by tag variables as above </li>\n<li>A satisfiable SMT predicate over the model above.</li>\n</ol>\n<p>To execute the program, execute the following in a loop.</p>\n<p>(5) Use (1) to determine which operation to evaluate next.<br>\n(6) Let ğ‘ƒ be the current predicate (4).<br>\n(7) Every operation takes (1,2,3), and produces new versions of (1,2,3), as well as a predicate relation ğ‘… between the old and the new model. <br>\n(8) The new predicate becomes \"âˆƒ (â€˜ğ‘¡), (â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜): ğ‘ƒ((â€˜ğ‘¡), (â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜)) âˆ§ ğ‘…((â€˜ğ‘¡), (â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜), (ğ‘¡), (ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜))\"<br>\n(9) Ask SMT to simplify the predicate. <br>\n(10) Ask SMT whether if it is satisfiable. If not, then UB has happened in the previous step.</p>\n<p>For int2ptr (the nondeterministic step), </p>\n<h3>Example: semantics of USE-1 w.r.t. the relation in step (7)</h3>\n<p>We are using a pointer value Pointer(ğ‘™, ğ‘¡_ğ‘–) .</p>\n<p>The following stands for an SMT formula that gets conjuncted into the current relation.</p>\n<blockquote>\n<p>(1) âˆƒ (t âˆˆ â„•) : ğ‘¡_ğ‘– = t  âˆ§  â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘™ contains a Unique(t) item</p>\n<p>The \"âˆƒ t\" here is a tautology; we use it to clarify that Unique contains a number not a variable.</p>\n<p>(2) And call the topmost such item \"I\". Pop everything above it. Then ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘™ must equal the resulting value.</p>\n<p>(3) And for all ğ‘˜ (ğ‘˜ â‰  ğ‘™), â€˜ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘˜ = ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜_ğ‘˜.</p>\n</blockquote>\n<h3>Example: semantics of int2ptr</h3>\n<p>Introduce a new tag variable ğ‘¡_ğ‘–, and conjunct into the relation that ğ‘¡_ğ‘– is one of the permissible values. The tag variable can now safely be handled by determinism-land (1,2,3).</p>",
        "id": 277944913,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649193596
    },
    {
        "content": "<p>I don't think there is necessarily any nondeterminism in the values</p>",
        "id": 277947120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649194719
    },
    {
        "content": "<p>Just in the provenance tags. When you do int2ptr, in the permissive-provenance formal model, you get a pointer with any provenance which is maximally in the favor of developer for avoiding UB.</p>",
        "id": 277952994,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649198241
    },
    {
        "content": "<p>Indeed there is no nondeterminism that can affect the execution of the program, or anything thatâ€™s printed to the terminal</p>",
        "id": 277953168,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649198297
    },
    {
        "content": "<p>I wonder if it is possible to have it be a pointer with a fresh tag that is <em>derived</em> from a nondeterministic pointer on the stack. That way the nondeterminism is limited to the stack itself and you can have the same tag regardless of what it binds to</p>",
        "id": 277953205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649198324
    },
    {
        "content": "<p>i.e. if you have <code>[a SRW, b Unique, c SRW]</code> where <code>a</code> and <code>c</code> are exposed and make a int2ptr, you get the value <code>Ptr(d)</code> and the stack becomes one of</p>\n<ul>\n<li><code>[a SRW, d SRW, b Unique, c SRW]</code></li>\n<li><code>[a SRW, b Unique, c SRW, d SRW]</code></li>\n</ul>\n<p>where <code>d</code> is not exposed.</p>",
        "id": 277953471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649198494
    },
    {
        "content": "<p>I don't think that there is any observable difference compared to getting either <code>Ptr(a)</code> or <code>Ptr(c)</code> nondeterministically with no change in the stack, but I'm not 100%. In particular I'm not sure if writes to <code>Ptr(a)</code> would invalidate <code>Ptr(d)</code> in the first case</p>",
        "id": 277953873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649198684
    },
    {
        "content": "<p>Miri doesn't use SAT though so I dont see how SMT would help Miri</p>",
        "id": 277959598,
        "sender_full_name": "RalfJ",
        "timestamp": 1649202912
    },
    {
        "content": "<p>sure you could build some kind of model checker or so but that's a very different game</p>",
        "id": 277959608,
        "sender_full_name": "RalfJ",
        "timestamp": 1649202923
    },
    {
        "content": "<p>Yes, it wouldn't exactly be trivial to integrate in Miri. It seems feasible, and I think it'll work well for small examples, but I have no idea how it would scale to larger programs. People say that SMT solvers are really clever but I believe they're also a bit unpredictable</p>",
        "id": 277959716,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649203016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277959598\">said</a>:</p>\n<blockquote>\n<p>Miri doesn't use SAT though so I dont see how SMT would help Miri</p>\n</blockquote>\n<p>Satisfyability checkers allow you to take n nondeterministic branches with potentially less than O(2^n) work. Additionally, they're just convenient for handling nondeterminism.</p>\n<p>SMT is just SAT with a fancier expression language and more types, e.g. in addition to bools you have lists too.</p>",
        "id": 277960574,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649203788
    },
    {
        "content": "<p>I mean yes but that is a VERY birds-eye view of what they do</p>",
        "id": 277960647,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203854
    },
    {
        "content": "<p>they certainly dont let me use non-determinism <em>in the middle if a big imperative program like Miri</em> and \"take n nondet branches\" there</p>",
        "id": 277960666,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203881
    },
    {
        "content": "<p>it's a <em>very</em> specific kind of problems in which they can do that</p>",
        "id": 277960682,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203903
    },
    {
        "content": "<p>specifically, things you can write in <em>propositional</em> logic (the weakest logic of them all)</p>",
        "id": 277960738,
        "sender_full_name": "RalfJ",
        "timestamp": 1649203926
    },
    {
        "content": "<p>It would have to be baked into Miri. Definitely not magic</p>",
        "id": 277960753,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649203952
    },
    {
        "content": "<p>I think for int2ptr, propositional logic is all you need isn't it?</p>",
        "id": 277960813,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649204002
    },
    {
        "content": "<p>you realize that that state space that has to be exploded here is literally all of Stacked Borrows?</p>",
        "id": 277960946,
        "sender_full_name": "RalfJ",
        "timestamp": 1649204136
    },
    {
        "content": "<p>like, for each \"possible world\" we need to have a completely independent set of borrow stacks for each allocation</p>",
        "id": 277960951,
        "sender_full_name": "RalfJ",
        "timestamp": 1649204152
    },
    {
        "content": "<p>it is <em>probably</em> possible to do this in a per-allocation way (I dont think we can have cross-allocation correlations) but that still means all of the SB stuff needs to be \"folded into\" this nondet automaton</p>",
        "id": 277961015,
        "sender_full_name": "RalfJ",
        "timestamp": 1649204188
    },
    {
        "content": "<p>Yes â€” but that's the point. With SAT you don't make <em>n</em> parallel copies â€” you add a term to your formula</p>",
        "id": 277961016,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649204189
    },
    {
        "content": "<p>yes but SB isnt a SAT formula :)</p>",
        "id": 277961021,
        "sender_full_name": "RalfJ",
        "timestamp": 1649204201
    },
    {
        "content": "<p>I think the nondeterministic part of it can be expressed in SAT, and I think it would handle it more efficiently than making <em>n</em> copies of the world</p>",
        "id": 277961071,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649204276
    },
    {
        "content": "<p>Or do you mean because Miri is a bunch more complicated than the paper?</p>",
        "id": 277961115,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649204291
    },
    {
        "content": "<p>Exactly Mario, that's basically what I tried to formalize. The computation only has to happen once, but at any point multiple stacks may be possible for a location. </p>\n<p>(posting this example because I have it anyway, might as well get it out of my editor)</p>\n<p>Suppose that we have this 1 memory location, and it has a stack</p>\n<blockquote>\n<p>ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW]</code></p>\n</blockquote>\n<p>Now we do int2ptr. It returns <code>Ptr(1, ğ‘¡_7)</code> where ğ‘¡_7 is a fresh tag variable that's either <code>a</code> or <code>c</code>. The predicate becomes</p>\n<blockquote>\n<p>ğ‘¡_7 âˆˆ {<code>a</code>, <code>c</code>}  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW]</code></p>\n</blockquote>\n<p>Next, we do ptr2int on the pointer. If its tag was <code>c</code> then the stack stays the same, otherwise the last two elements are popped. The predicate becomes</p>\n<blockquote>\n<p>(ğ‘¡_7 = a  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW]</code>)</p>\n<p>âˆ¨ (ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW]</code>)</p>\n</blockquote>\n<p>Next, suppose we push a <code>&amp;mut</code> on the stack, which corresponds to pushing a <code>Unique</code>. The predicate becomes</p>\n<blockquote>\n<p>(ğ‘¡_7 = a  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, d Unique]</code>)</p>\n<p>âˆ¨ (ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW, d Unique]</code>)</p>\n</blockquote>\n<p>Now the program uses the <code>&amp;mut</code> pointer for <code>b</code>. This creates the formula</p>\n<blockquote>\n<p>(ğ‘¡_7 = a  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, d Unique]</code>  âˆ§  false)</p>\n<p>âˆ¨ (ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW, d Unique]</code>)</p>\n</blockquote>\n<p>which SAT simplifies to</p>\n<blockquote>\n<p>ğ‘¡_7 = c  âˆ§  ğ‘ ğ‘¡ğ‘ğ‘ğ‘˜â‚ = <code>[a SRW, b Unique, c SRW, d Unique]</code></p>\n</blockquote>\n<p>for us.</p>",
        "id": 277961361,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649204564
    },
    {
        "content": "<p>Hm, looks like SMT solvers aren't really made for simplifying. They can be part of simplifying (they can answer \"is there still a feasible world\" or \"is it still possible that t_7 = a\") but maybe they can't drive the simplifying</p>",
        "id": 277962083,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649205288
    },
    {
        "content": "<p>I am sorry but this discussion is going so far into speculative territory that I can't really invest the time to dig deep enough into it to follow.<br>\nI dont doubt that something <em>can</em> in theory be done, but it would be no less than a complete rewrite of the relevant parts of Miri. if someone wants to experiment with that, by all means do so. :) but I can't currently help much with designing something like that.</p>",
        "id": 277968843,
        "sender_full_name": "RalfJ",
        "timestamp": 1649212734
    },
    {
        "content": "<p>what I am personally more interested in is a way to \"approximate\" SB + permissive provenance in a way that there are no false positives, but also no undue amount of loss of precision and no complete rewrite of everything (like your approach would require us to do). how do we have to handle accesses through pointers with \"magic\" provenance, and what do they have to do on the borrow stack, so that we will definitely not reject any correct program?<br>\nin fact, forget stacked borrows, how do we do that even just for bounds checks and <code>offset</code> checking? what miri currently does here by default is wrong. it will reject the following (outrageous but correct) program:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">expose_addr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span>::<span class=\"n\">from_exposed_addr</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">()).</span><span class=\"n\">with_addr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n<p>this is correct because <code>from_exposed_addr(...)</code> can pick up the provenance that was exposed by <code>x.expose_addr</code>, and then that is combined with the actual address of <code>x</code>, so provenance and address match and everything should work.</p>",
        "id": 277969233,
        "sender_full_name": "RalfJ",
        "timestamp": 1649213170
    },
    {
        "content": "<p>What's the issue with the \"intuitive\" greedy behavior, such that a pointer cast from an int uses the tag that would require it to pop the least amount of items from the borrow stack?</p>",
        "id": 277971659,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649215835
    },
    {
        "content": "<p>Yes, my story is indeed rather speculative</p>",
        "id": 277982782,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649228792
    },
    {
        "content": "<p>I donâ€™t get it Ralf, didnâ€™t we just put in docs that from_exposed_addr on a nonexposed addr is UB?</p>",
        "id": 277983097,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649229064
    },
    {
        "content": "<p>I assumed that from_exposed_addr would pick up any provenance valid <em>for that address</em>, not any provenance in general</p>",
        "id": 277983233,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649229133
    },
    {
        "content": "<p>You seem to imply that the dereferencing is UB instead of the from_exposed_addr</p>",
        "id": 277983363,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649229236
    },
    {
        "content": "<p>Allowing to return any provenance from _any_ addr seems theoretically nice for devs, but it makes us a lot more liberal than C, could be harder for compiler writers and I donâ€™t see why it would actually be nicer in practice</p>",
        "id": 277983785,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649229519
    },
    {
        "content": "<p>Quy, I think there is an example with NLL where you actually donâ€™t want the topmost tag</p>",
        "id": 277983866,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649229592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277971659\">said</a>:</p>\n<blockquote>\n<p>What's the issue with the \"intuitive\" greedy behavior, such that a pointer cast from an int uses the tag that would require it to pop the least amount of items from the borrow stack?</p>\n</blockquote>\n<p>as I said, forget stacked borrows. making my example work with <code>-Zmiri-disable-stacked-borrows</code> will already require some interesting changes to miri</p>",
        "id": 278032139,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277983097\">said</a>:</p>\n<blockquote>\n<p>I donâ€™t get it Ralf, didnâ€™t we just put in docs that from_exposed_addr on a nonexposed addr is UB?</p>\n</blockquote>\n<p>no we didnt, please carefully read the docs :)</p>",
        "id": 278032204,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277983233\">said</a>:</p>\n<blockquote>\n<p>I assumed that from_exposed_addr would pick up any provenance valid <em>for that address</em>, not any provenance in general</p>\n</blockquote>\n<p>oh no, it must be any provenance in general</p>",
        "id": 278032233,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255581
    },
    {
        "content": "<p>people do things like <code>from_exposed_addr(x.expose_addr() + 4)</code></p>",
        "id": 278032278,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255597
    },
    {
        "content": "<p>Ah, yes, thatâ€™s indeed a more precise reading of the docs</p>",
        "id": 278035567,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649256883
    },
    {
        "content": "<p>It also makes a polyfill for CHERI impossible</p>",
        "id": 278035637,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649256909
    },
    {
        "content": "<p>Not just infeasible but impossible. CHERI (like C) doesnâ€™t allow for capabilities to point to outside their valid range</p>",
        "id": 278035804,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649256968
    },
    {
        "content": "<p>CHERI is more liberal than ISO C here: it guarantees some space above and below (something like 1/4 and 1/8 of the region) within which any pointer value is guaranteed to be representable; we see code using some of this flexibility.</p>",
        "id": 278040502,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649258688
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>ğŸ»</p>",
        "id": 278041160,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649258956
    },
    {
        "content": "<p>(To be pedantic, I would like to call this â€œCHERI Câ€ not just CHERI ğŸ˜‡)</p>",
        "id": 278041284,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649258995
    },
    {
        "content": "<p>It's actually non-trivially debatable.  The architectures allow what I say, and in many cases CHERI C will too, but I don't know for sure that the CHERI C implementations don't have analyses/optimisations that assume that more than one-past pointer construction is UB.</p>",
        "id": 278041919,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649259197
    },
    {
        "content": "<p>(Jess Clarke or Alex Richardson may know that already)</p>",
        "id": 278043091,
        "sender_full_name": "Peter Sewell",
        "timestamp": 1649259609
    },
    {
        "content": "<p>As far as the language goes it's as UB as whatever LLVM already does, whatever that is and means</p>",
        "id": 278047787,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649261513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Ok, so I made some jank changes a while back, but I didn't exactly hit anything that changed in testing, so I shelved it.</p>\n<p><a href=\"https://github.com/carbotaniuman/miri/blob/e7aa846ef60404b6e10e98a43cd21e12af434fb4/tests/run-pass/addr-oob.rs\">https://github.com/carbotaniuman/miri/blob/e7aa846ef60404b6e10e98a43cd21e12af434fb4/tests/run-pass/addr-oob.rs</a></p>\n<p>I'm not familiar enough with Miri to know why the first test case passes already, but the second one needs these changes. I also made these changes from a quick glance, so I've probably butchered a lot of the semantics.</p>",
        "id": 278060720,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649267231
    },
    {
        "content": "<p>Despite what I say in the commit, the actual semantics are more like <code>PNVI-ae-universal</code> (<code>PNVI-ae-udi</code> does not work for us because there's no <code>wrapping_offset</code> equivalent in C), wherein any pointer casted from a nonzero integer can alias any exposed allocation (the exposed part is currently not implemented). Most of the jank comes from the fact that rustc doesn't expect AllocIds to be synthesized like this, so instead of saying I can't synthesize a valid one for this access I have to pick a random invalid one.</p>",
        "id": 278066832,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649269831
    },
    {
        "content": "<blockquote>\n<p>any pointer casted from a nonzero integer can alias any exposed allocation</p>\n</blockquote>\n<p>yeah for Miri we probably want that. it's not correct re: what the docs say, but it's a reasonable approximation that avoids all false positives and still is fully precise for code that does not call expose_addr.</p>",
        "id": 278069151,
        "sender_full_name": "RalfJ",
        "timestamp": 1649271005
    },
    {
        "content": "<p>and yeah I think we need something like what you did for <code>AllocId</code>... basically currently a value of pointer type is a <code>Pointer&lt;Option&lt;AllocId&gt;&gt;</code> (ignoring SB) such that a <code>None</code> indicates an invalid pointer. for permissive provenance we will also somehow need a provenance that indicates a \"wildcard\" pointer that can access all exposed memory</p>",
        "id": 278069511,
        "sender_full_name": "RalfJ",
        "timestamp": 1649271174
    },
    {
        "content": "<p>I was thinking about adding a hook <a href=\"https://github.com/rust-lang/rust/blob/5da76eeaad7b57eaee81fc28067952f96abf8377/compiler/rustc_const_eval/src/interpret/memory.rs#L1144\">here</a>, and turning <code>into_pointer_or_addr</code> into a trait method somewhere so we can map the \"maybe pointer\"  (read: permissive provenance pointer) into a proper pointer in Miri. This basically lets us shove all of our \"guess the right allocation\" logic into this method.</p>",
        "id": 278072641,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649272680
    },
    {
        "content": "<p>there's already a hook there, <code>ptr_get_alloc</code></p>",
        "id": 278073352,
        "sender_full_name": "RalfJ",
        "timestamp": 1649272991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278073352\">said</a>:</p>\n<blockquote>\n<p>there's already a hook there, <code>ptr_get_alloc</code></p>\n</blockquote>\n<p>Ah, i saw that, <a href=\"https://github.com/rust-lang/miri/blob/fb01df538e30cf63bdcbadad61828940ca8ec578/src/machine.rs#L597\">https://github.com/rust-lang/miri/blob/fb01df538e30cf63bdcbadad61828940ca8ec578/src/machine.rs#L597</a>, but Im not exactly sure how I'm supposed to return <code>None</code> here. Do I need to reintroduce the Option, or is AllocId a built-in option?</p>",
        "id": 278074332,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649273455
    },
    {
        "content": "<p>hm, that comment might be refering to an earlier version of the API... now the conversion is always possible because the input is a <code>Pointer&lt;Self::PointerTag&gt;</code> that always has provenance. that is, until you add the wildcard provenance, then that does not work any more. ;)</p>",
        "id": 278075436,
        "sender_full_name": "RalfJ",
        "timestamp": 1649273986
    },
    {
        "content": "<p>Yeah that seems like an easy-ish change. The harder one (in that I don't understand it at all) is <code>get_alloc_id</code>, <a href=\"https://github.com/rust-lang/rust/search?q=get_alloc_id&amp;type=\">https://github.com/rust-lang/rust/search?q=get_alloc_id&amp;type=</a>, which obviously doesn't work with this, but I can't tell what it's actually used for.</p>",
        "id": 278075824,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649274190
    },
    {
        "content": "<p>I think that one is easy, just return the absolute address<br>\nEDIT: oh, looked at the wrong thing</p>",
        "id": 278087743,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280078
    },
    {
        "content": "<p>from what I can tell, <code>get_alloc_id</code> is only used for debug output, and for <code>try_to_int</code> <em>if</em> <code>Tag::OFFSET_IS_ADDR == false</code> (so the latter never applies for Miri)</p>",
        "id": 278088324,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280296
    },
    {
        "content": "<p>so, I think we can make it return an <code>Option</code></p>",
        "id": 278088482,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280370
    },
    {
        "content": "<p>Took a couple of compiles and it seems good now as the permissive provenance portion of the changes seem to be working. I'm not sure how I would implement exposure tracking though (iirc the base address was only generated if exposed at one point, but that got changed). </p>\n<p>It also seems like Miri's definition of provenance does not narrow on subobjects, and that part is handled by SB?</p>",
        "id": 278102844,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649289950
    },
    {
        "content": "<p>Yes. Provenance is stored in the Stacks.</p>",
        "id": 278103448,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649290537
    },
    {
        "content": "<p>We think of provenance as being a property of pointers, but in Miri provenance is stored the borrow stacks. It's basically what an Item is.</p>",
        "id": 278103519,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649290580
    },
    {
        "content": "<p>Miri does have a code path for ptr_to_int btw</p>",
        "id": 278103572,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649290648
    },
    {
        "content": "<p>Mind giving me a pointer? It seems like <code>alloc_base_addr</code> would be it, but that seems to always get called when any reference is made.</p>",
        "id": 278104100,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649291153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278032233\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/277983233\">said</a>:</p>\n<blockquote>\n<p>I assumed that from_exposed_addr would pick up any provenance valid <em>for that address</em>, not any provenance in general</p>\n</blockquote>\n<p>oh no, it must be any provenance in general</p>\n</blockquote>\n<p>Oh my goodness, this is terrible. I had a similar misconception as Bram here, or rather I noticed that all the documentation so far was a bit vague on this point. This makes the explosion <em>much</em> worse - we aren't just talking about maybe a two-way split sometimes, it's more like a 10000-way split any time you do any int2ptr, since you will pick up any exposed pointer ever done in the past, even if it is not remotely close in value to the integer you are casting. Can we make this at least be restricted to pointer provenances whose allocation contains the address we are casting? Or maybe 1 past the end if necessary. Otherwise this will really become impossible to check.</p>",
        "id": 278107262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649294489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> (whoops, I was away) This function: <a href=\"https://github.com/rust-lang/miri/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src/intptrcast.rs#L83\">https://github.com/rust-lang/miri/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src/intptrcast.rs#L83</a></p>",
        "id": 278107537,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649294797
    },
    {
        "content": "<p>Yeah, I was looking at that function, and it appears to eagerly be called whenever I make a reference. <a href=\"https://github.com/rust-lang/miri/issues/1988#issuecomment-1056107051\">https://github.com/rust-lang/miri/issues/1988#issuecomment-1056107051</a> says that this is an intentional refactoring, so it looks like I'll have to hook in somewhere else...</p>",
        "id": 278108578,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649296011
    },
    {
        "content": "<p>Alright, work done for this:</p>\n<p><a href=\"https://github.com/carbotaniuman/rust/commit/b32cc2f92cf663cbcd1a394cfb7dc5d593e8ac9a\">https://github.com/carbotaniuman/rust/commit/b32cc2f92cf663cbcd1a394cfb7dc5d593e8ac9a</a><br>\n<a href=\"https://github.com/carbotaniuman/miri/commit/a25b65e8011d99612c3796f5586d244f0dfc92ca\">https://github.com/carbotaniuman/miri/commit/a25b65e8011d99612c3796f5586d244f0dfc92ca</a></p>\n<p>This implements a permissive form of exposed-address provenance, wherein the only way to expose the address is with a cast to <code>usize</code> (ideally <code>expose_addr</code>). This is more restrictive than C in that stuff like reading the representation bytes (via unions, type-punning, transmute) does not expose the address, only <code>expose_addr</code>. This is less restrictive than C in that a pointer casted from an integer has union provenance of all exposed pointers, not any udi stuff. Not sure how helpful this will be for anything important, but I'll use this to try and muck around with SB.</p>",
        "id": 278116149,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649305591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278103519\">said</a>:</p>\n<blockquote>\n<p>We think of provenance as being a property of pointers, but in Miri provenance is stored the borrow stacks. It's basically what an Item is.</p>\n</blockquote>\n<p>Provenance is still a property of pointers. it's the stacked borrows tag.</p>",
        "id": 278354908,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> that sounds pretty nice. :D do you want to submit PRs so that we can do proper code review?</p>",
        "id": 278355010,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447981
    },
    {
        "content": "<p>Ah yes of course, I was thinking from the angle of where the information about what memory a pointer can access is stored.</p>",
        "id": 278355289,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649448108
    },
    {
        "content": "<p>PRs opened, review at your leisure. I've put all of my current working thoughts and ideas in the Miri PR, but the <code>get_alloc_id</code> changes in rustc are also somewhat weird.</p>",
        "id": 278363034,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649452428
    },
    {
        "content": "<p>thanks. :) yeah it might be a bit until I get around to reviewing them.</p>",
        "id": 278363851,
        "sender_full_name": "RalfJ",
        "timestamp": 1649452836
    },
    {
        "content": "<p>I'm experimenting with semantics where ptr-to-casts get the topmost exposed tag (but this does run into <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a>, sigh), and was trying to see if this helps bring raw pointer tagging to more code. Is there a technical/model reason this wasn't done before?</p>",
        "id": 278376331,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649462972
    },
    {
        "content": "<p>yeah -- it is important that you only match <em>exposed</em> tags, otherwise all optimizations are broken</p>",
        "id": 278379939,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467582
    },
    {
        "content": "<p>but I didnt want to even have such a notion (where is that state stored? when exactly does a tag get exposed? etc)</p>",
        "id": 278379952,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467608
    },
    {
        "content": "<p>The idea I had was int-to-ptr casts creating an pointer not only with universal provenance (union of all previously exposed pointers), but also with an universal SB tag (union of all previously exposed SB tags). For this to work, it has to be ok for there to be a pointer with multiple SB tags, which I think is fine as the justifications in the paper use the state of the stacks, and not the tag of the pointer.</p>",
        "id": 278380038,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649467710
    },
    {
        "content": "<p>I dont think you literally want a <code>Vec&lt;Tag&gt;</code> on a pointer though</p>",
        "id": 278380058,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467747
    },
    {
        "content": "<p>but if you mean that <code>Wildcard</code> should act as if it had all the exposed SB tags, I agree</p>",
        "id": 278380068,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467763
    },
    {
        "content": "<p>Yeah, not literally a Vec but as-if.</p>",
        "id": 278380084,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649467786
    },
    {
        "content": "<p>we'll have to make it so that <code>exposed_addr</code> exposes but <code>addr</code> doesn't, so some new intrinsic or so will be required</p>",
        "id": 278380091,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467799
    },
    {
        "content": "<p>So kinda something like, on every int-to-ptr cast, you would get a pointer with the aforementioned SB tag. I think every SRW directly derived from that pointer would also have this universal tag, but  a retag to anything else just use the topmost usable tag.</p>",
        "id": 278380146,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649467828
    },
    {
        "content": "<p>I think this would also \"solve\" <a href=\"https://github.com/rust-lang/rust/issues/273\">#273</a>, but I'm not sure if that works.</p>",
        "id": 278380154,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649467848
    },
    {
        "content": "<p>that's also about as far as I got, but it doesn't satisfy the condition I think we should satisfy -- no false positives</p>",
        "id": 278380258,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467977
    },
    {
        "content": "<p>IMO it is okay to lose even more precision than this, if we can convince ourselves that that fixes all false positives</p>",
        "id": 278380271,
        "sender_full_name": "RalfJ",
        "timestamp": 1649468013
    },
    {
        "content": "<p>What's the false positive that still exists here? (Other than ptr-int transmutes, but I don't think you're talking about those)</p>",
        "id": 278380309,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649468043
    },
    {
        "content": "<p>the best guess I have for that is to not just have a <code>Wildcard</code> tag but also a <code>Wildcard</code> part of the borrow stack -- basically the unknown part of the stack where we cant tell what happened because wildcard pointers got used. so in general the stack has a known bottom, then an unknown part, and then a known top. and maybe that's enough? the optimization correctness arguments we have so far only rely on the top part so if this works it'd even still be good enough for the optimizations...</p>",
        "id": 278380353,
        "sender_full_name": "RalfJ",
        "timestamp": 1649468121
    },
    {
        "content": "<p>the example from <a href=\"https://github.com/rust-lang/rust/issues/273\">#273</a> would yield a false positive, no?</p>",
        "id": 278380408,
        "sender_full_name": "RalfJ",
        "timestamp": 1649468200
    },
    {
        "content": "<p>if a reborrow from <code>Wildcard</code> picks the topmost exposed item as the base to reborrow from, then that might lead to false positives later</p>",
        "id": 278380418,
        "sender_full_name": "RalfJ",
        "timestamp": 1649468231
    },
    {
        "content": "<p>Only for non-SRW, which I think works?</p>",
        "id": 278380430,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649468279
    },
    {
        "content": "<p>Oh, not for Unique and SRW hmm.</p>",
        "id": 278380581,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649468522
    },
    {
        "content": "<p>Wait, so if we have <code>[ESRW(1), U(2), ESRW(3), SRO(4)]</code> for example, where E denotes exposed.</p>\n<p>If you cast an int to a pointer you would have <code>ESRW(1) | ESRW(3)</code>, and any <code>SRW</code> directly derived would have the same tag.<br>\nIf you derived an <code>SRO</code> or a <code>U</code> at <code>ESRW(3)</code>,  then the use of <code>U(2)</code> would invalidate the newly derived pointer.</p>\n<p>If you derive an <code>SRO</code> or a <code>U</code> at <code>ESRW(1)</code>, ...</p>",
        "id": 278380802,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649468850
    },
    {
        "content": "<p>I dont think <code>ESRW</code> works. 'escaped' is a property of the tag, not a property of the item. (I was a bit sloppy above.)</p>",
        "id": 278381207,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469445
    },
    {
        "content": "<p>if you now derive a <code>U</code> from a wildcard ptr, then you can choose to put it after <code>3</code> or after <code>1</code>. but either choice might later turn out to be the wrong that leads to more UB.</p>",
        "id": 278381272,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469516
    },
    {
        "content": "<p>so instead we could just say that the entire stack is now unknown, and a fresh unique is on top: <code>[unk, U(5)]</code>. this allows <em>all</em> accesses with <em>all</em> tags, but if the tag is not <code>5</code> they will pop the <code>U(5)</code> -- so we still enforce uniqueness of <code>5</code></p>",
        "id": 278381300,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469590
    },
    {
        "content": "<p>Isn't deriving a <code>U</code> from a pointer marked <code>SRW</code> treated as a write to said pointer, or am I misreading the paper?</p>",
        "id": 278381420,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649469637
    },
    {
        "content": "<p>basically, <code>Wildcard</code> provenance reflects our ignorance wrt the true provenance value (could literally be anything that was exposed). likewise we have to find a way to reflect our ignorance about the true borrow stack, in a way correctly overapproximates all possibles stacks.</p>",
        "id": 278381425,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469640
    },
    {
        "content": "<p>well yeah but we dont know with SRW</p>",
        "id": 278381428,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469656
    },
    {
        "content": "<p>if we did the correct thing we would not split the world</p>",
        "id": 278381458,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469676
    },
    {
        "content": "<p>one execution treats this as if it matched SRW(1), the other one as if it matches SRW(3)</p>",
        "id": 278381470,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469696
    },
    {
        "content": "<p>but we don't actually want to do that, so instead we find a way to represent the set of all possible worlds in a single data structure -- the stack is \"something, and then U(5) on top\". that is the one thing we know for sure.</p>",
        "id": 278381526,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469730
    },
    {
        "content": "<p>Yeah that makes sense. Let me ask the question again, I think I might be missing something here.</p>\n<p>If we chose SRW(1), then the stack would look like [SRW(1), U(5)]<br>\nIf we chose SRW(3), then the stack would look like [SRW(1), U(2), SRW(3), U(5)]</p>\n<p>So we can either use <code>U(2)</code> and <code>SRW(3)</code>, or <code>U(5)</code>. Is this right?</p>",
        "id": 278381643,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649469888
    },
    {
        "content": "<p>yes those are the two options. I dont understand the question in the last line.</p>",
        "id": 278381963,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470396
    },
    {
        "content": "<p>what does \"use\" mean?</p>",
        "id": 278381966,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470399
    },
    {
        "content": "<p>Perform an access allowed by the tag</p>",
        "id": 278381980,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649470428
    },
    {
        "content": "<p>you can use 1 in all cases so I a confused</p>",
        "id": 278382003,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470442
    },
    {
        "content": "<p>using 1 will pop other tags of course but still, you can use it</p>",
        "id": 278382020,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470451
    },
    {
        "content": "<p>you can always use all the tags listed in the stack</p>",
        "id": 278382026,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470461
    },
    {
        "content": "<p>From what I've read the mere act of creating a mutable reference pops everything above on the stack.</p>",
        "id": 278382060,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649470541
    },
    {
        "content": "<p>yes</p>",
        "id": 278382068,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470559
    },
    {
        "content": "<p>everything above the parent tag from which the mutable ref is being derived, to be precise</p>",
        "id": 278382118,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470592
    },
    {
        "content": "<p>so?</p>\n<p>If we chose SRW(1), then the stack would look like [SRW(1), U(5)]. so now we can use tags 1 and 5.<br>\nIf we chose SRW(3), then the stack would look like [SRW(1), U(2), SRW(3), U(5)]. so now we can use tags 1, 2, 3, 5.</p>",
        "id": 278382123,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470611
    },
    {
        "content": "<p>So when we turn a SRW(Wildcard) into a U or SRW, using the topmost tag that allows for such a retag produces no false-negatives.</p>",
        "id": 278382396,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649471042
    },
    {
        "content": "<p>in the <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">https://github.com/rust-lang/unsafe-code-guidelines/issues/273</a> example it does</p>",
        "id": 278382848,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471646
    },
    {
        "content": "<p>false-positives are my concern</p>",
        "id": 278382852,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471652
    },
    {
        "content": "<p>as in, reporting UB when there isnt UB</p>",
        "id": 278382854,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471658
    },
    {
        "content": "<p>Ah, my idea was when deriving SRW from SRW(Wildcard) to keep it as SRW(Wildcard).</p>",
        "id": 278382881,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649471711
    },
    {
        "content": "<p>hm... I think it'd be good if <code>&amp;mut</code> ptrs get <code>U</code> no matter from where they are derived</p>",
        "id": 278382941,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471784
    },
    {
        "content": "<p>Oh I meant false positives above btw</p>",
        "id": 278382961,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649471825
    },
    {
        "content": "<p>I am not sure, but I think the model that I sketched above -- the one with the 'unknown' part of the stack -- we could actually literally take that as the bottommost floor in Gankra's Tower of Weakenings. This allows all code that is allowed by the <code>from_exposed_addr</code>-angelic-guessing I described, while still allowing all the optimizations we verified for Stacked Borrows. Maybe.</p>",
        "id": 278382973,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471849
    },
    {
        "content": "<p>But what we discussed above should allow SRW(*) =&gt; U with no false positives</p>",
        "id": 278382981,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649471865
    },
    {
        "content": "<p>How difficult implementation wise would that be?</p>",
        "id": 278382983,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649471873
    },
    {
        "content": "<p>which one?</p>",
        "id": 278383022,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471884
    },
    {
        "content": "<p><code>Wildcard</code> part of the borrow stack</p>",
        "id": 278383028,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649471915
    },
    {
        "content": "<p>I dont know</p>",
        "id": 278383374,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472443
    },
    {
        "content": "<p>in terms of representation it's just a <code>bool</code> in the <code>Stack</code> type indicating whether there are additional unknown things below the known things in <code>borrows</code></p>",
        "id": 278383424,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472493
    },
    {
        "content": "<p>but then a bunch of the logic needs to (carefully) be adjusted to take that into account properly</p>",
        "id": 278383428,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472506
    },
    {
        "content": "<p>so, I think two things here will need new intrinsics</p>\n<ul>\n<li><code>addr</code> needs to do a non-exposing ptr2int</li>\n<li><code>ptr::invalid</code> needs to create a ptr without provenance (rather than one with wildcard provenance)</li>\n</ul>\n<p>they both can't behave like the <code>as</code> casts they are currently implemented with<br>\n(or, well, they shouldn't -- that would be totally unnecessary false negatives)</p>",
        "id": 278384091,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473465
    },
    {
        "content": "<p>got any plans for that yet?</p>",
        "id": 278384162,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473572
    },
    {
        "content": "<p>Right now, <code>addr</code> is implemented via transmute in my experiments. Similarly, <code>invalid</code> is a transmute in the other direction.</p>",
        "id": 278384176,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473626
    },
    {
        "content": "<p>It would be cleaner to change <code>as usize</code> to <code>expose_addr</code> and <code>expose_addr</code> to <code>expose</code> intrinsic + <code>addr</code>, but that's a bit far out of my skillset.</p>",
        "id": 278384187,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473665
    },
    {
        "content": "<p>Current implementations are less \"the right way\" and more minimize changes to the compiler.</p>",
        "id": 278384305,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473833
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT/near/278384187\">said</a>:</p>\n<blockquote>\n<p>It would be cleaner to change <code>as usize</code> to <code>expose_addr</code> and <code>expose_addr</code> to <code>expose</code> intrinsic + <code>addr</code>, but that's a bit far out of my skillset.</p>\n</blockquote>\n<p>well <code>as</code> casts are a MIR primitive so that doesn't really work</p>",
        "id": 278384602,
        "sender_full_name": "RalfJ",
        "timestamp": 1649474370
    },
    {
        "content": "<p>so it's easier to implement <code>expose_addr</code> in terms of <code>as</code>, and then add the hooks required for <code>as</code> to do the exposing</p>",
        "id": 278384616,
        "sender_full_name": "RalfJ",
        "timestamp": 1649474395
    },
    {
        "content": "<p>hm yeah <code>invalid</code> could be a transmute I guess, though that will look odd in the code. making <code>addr</code> a transmute will cause UB errors in Miri. ;)</p>",
        "id": 278384664,
        "sender_full_name": "RalfJ",
        "timestamp": 1649474434
    },
    {
        "content": "<p>like, somewhere around<br>\n<a href=\"https://github.com/rust-lang/rust/blob/f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03/compiler/rustc_const_eval/src/interpret/cast.rs#L172\">https://github.com/rust-lang/rust/blob/f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03/compiler/rustc_const_eval/src/interpret/cast.rs#L172</a><br>\nwe want to add the option for the <code>Machine</code> to do extra magic on an <code>as</code> cast (exposing, and generating a wildcard provenance). and we don't want that magic to happen anywhere else.</p>",
        "id": 278384723,
        "sender_full_name": "RalfJ",
        "timestamp": 1649474549
    },
    {
        "content": "<p>That part is already done in my PR :P</p>",
        "id": 278384787,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649474655
    },
    {
        "content": "<p>I'm working on getting SB to cooperate now</p>",
        "id": 278384792,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649474671
    }
]