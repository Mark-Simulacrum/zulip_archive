[
    {
        "content": "<p>Hi, I'm looking at an extension to enable me to do: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C, u32, niches(0))]</span><span class=\"w\"></span>\n<span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">E</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Field0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Field1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"mi\">0_</span><span class=\"k\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">());</span><span class=\"w\">  </span><span class=\"c1\">// guaranteed</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"mi\">0_</span><span class=\"k\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">is_err</span><span class=\"p\">());</span><span class=\"w\"> </span><span class=\"c1\">// guaranteed</span>\n</code></pre></div>\n<p>In this particular case, there is only 1 niche, so that's the only niche that <code>Option</code> and <code>Result</code> can pick. </p>\n<p>I'm not advocating for or right now interested in an extension like: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C, u32, niches(0, 3..=u32::max_value()))]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Field0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Field1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but it is something one could do (not sure which niches <code>Option</code> or <code>Result</code> would pick, and whether we could / would want to guarantee anything there).</p>\n<p>Does anybody see anything wrong from the point of view of soundness for this?</p>",
        "id": 262861143,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638000791
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C, u32, niches(0, 3..=u32::max_value()))]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Field0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Field1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This is the same as not giving a niche, right? enums always assume their discriminant are valid, even with these extra repr clauses.</p>",
        "id": 262897990,
        "sender_full_name": "RalfJ",
        "timestamp": 1638054828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"441719\">Gonzalo Brito (gnzlbg)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niche.20control/near/262861143\">said</a>:</p>\n<blockquote>\n<p>Does anybody see anything wrong from the point of view of soundness for this?</p>\n</blockquote>\n<p>I'm wondering what it means for <code>match</code>ing things.  Can you match on reprs that don't have variants?  If not, how do you observe those values?</p>\n<p>And, in general, <code>#[repr(C, u32, niches(0))]</code> looks to me like <code>#[repr(transparent)] struct E(NonZeroU32);</code> with a bunch of associated <code>const</code>s...</p>",
        "id": 262911250,
        "sender_full_name": "scottmcm",
        "timestamp": 1638077896
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think that’s correct, from the point of view of validity nothing changes. I really don’t understand why using repr(C, u32) disables niche optimizations in my experiments. Maybe it’s a bug?</p>",
        "id": 262929408,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638106732
    },
    {
        "content": "<p>For the other cases being able to pick a single niche, to force the option optimization to use it, feels like a workaround, so maybe one could just have a single repr attribute for the option optimization and that’s it.</p>",
        "id": 262929479,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638106822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> you can’t observe the values, but for some reason when I was playing with this, rustc was not performing niche optimizations on repr(C) enums.</p>",
        "id": 262929506,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638106897
    },
    {
        "content": "<p>Is there a simple way to match on the repr struct with a NonZero field for its associated consts “as if” it was an actual enum with fields ?</p>",
        "id": 262929575,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638106974
    },
    {
        "content": "<p>Layout wise they still different because they have different niches at least in theory (the enum with two fields has more niches that NonZero which only has one), but the biggest difference is ergonomics.</p>",
        "id": 262929626,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638107056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"441719\">Gonzalo Brito (gnzlbg)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niche.20control/near/262929408\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I think that’s correct, from the point of view of validity nothing changes. I really don’t understand why using repr(C, u32) disables niche optimizations in my experiments. Maybe it’s a bug?</p>\n</blockquote>\n<p>That sounds strange, but I am not a layout computation expert... Cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 262933286,
        "sender_full_name": "RalfJ",
        "timestamp": 1638111943
    },
    {
        "content": "<blockquote>\n<p>Maybe it’s a bug?</p>\n</blockquote>\n<p>It <em>may</em> be by design (I'm not an expert in this field, but here is my two cents). The <a href=\"https://doc.rust-lang.org/nomicon/other-reprs.html\">Rustonomicon</a> says: \"<em>repr(c) is the most important repr. It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C or C++</em>\". I'm not sure if niche optimizations exist in C or C++, but if they don't then these couldn't be carried over from Rust's niche optimizations when you opt-in to <code>#[repr(C)]</code>. The only exception seems to be \"<em>If T is an FFI-safe non-nullable pointer type, Option&lt;T&gt; is guaranteed to have the same layout and ABI as T and is therefore also FFI-safe. As of this writing, this covers &amp;, &amp;mut, and function pointers, all of which can never be null</em>\". Although this is only for the aforementioned pointers (which excludes raw pointers <code>*const T</code>/<code>*mut T</code> and <code>NonNull&lt;T&gt;</code> apparently), not for enums or numbers.</p>",
        "id": 262936515,
        "sender_full_name": "Pointerbender",
        "timestamp": 1638116462
    },
    {
        "content": "<p>repr(C) for enums is somewhat weird anyway, since in C (and maybe C++), it is totally fine to have \"invalid\" values in an enum-typed variable</p>",
        "id": 262941239,
        "sender_full_name": "RalfJ",
        "timestamp": 1638123626
    },
    {
        "content": "<p>so repr(C) just means that the (memory and call) ABI is the same, but doesnt mean that the types make \"the same promises\"</p>",
        "id": 262941257,
        "sender_full_name": "RalfJ",
        "timestamp": 1638123658
    },
    {
        "content": "<p>and since C++ doesnt have enums with data, arguably it would be okay for repr(C) types to have niches (and indeed I think <code>bool</code> is considered C-compaible despite having a niche)</p>",
        "id": 262941284,
        "sender_full_name": "RalfJ",
        "timestamp": 1638123702
    },
    {
        "content": "<p>Maybe what I want is repr(u32) without C</p>",
        "id": 262943665,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638126954
    },
    {
        "content": "<p>Plus the guarantee that if the 0 niche is available it will be used for option-like optimizations.</p>",
        "id": 262943725,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127020
    },
    {
        "content": "<p>So, was in the train, and now I’m finally at home.</p>",
        "id": 262943907,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127283
    },
    {
        "content": "<p>I’d internally raise the issue about the constraints that you’ve mentioned</p>",
        "id": 262943918,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127316
    },
    {
        "content": "<p>But they are essentially that lib nvvm is proprietary, and therefore some people might not like it being usable from rust, and also that even if it were allowed, some fallback would need to be required .</p>",
        "id": 262943993,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127413
    },
    {
        "content": "<p>I can’t promise anything about libnvvm, but it has been supported for longer than Rust has existed</p>",
        "id": 262944038,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127451
    },
    {
        "content": "<p>And given that all toolchains that interfere with the CUDA platform use it, there is 15+ years of history</p>",
        "id": 262944061,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127510
    },
    {
        "content": "<p>Having said this, rust has removed tier 1 targets in the past</p>",
        "id": 262944065,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127522
    },
    {
        "content": "<p>So the claim that it is necessary to have a fallback just in case it’s stops being supported is not true either.</p>",
        "id": 262944071,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127545
    },
    {
        "content": "<p>And there is prior art of rust downgrading and even removing targets.</p>",
        "id": 262944112,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127572
    },
    {
        "content": "<p>If llvm removes a target, there is no workaround available either.</p>",
        "id": 262944119,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638127587
    },
    {
        "content": "<p>Did you mean to post this in <a class=\"stream-topic\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler/topic/codegen.20upstreaming.20requirements\">#t-compiler &gt; codegen upstreaming requirements</a>?</p>",
        "id": 262944529,
        "sender_full_name": "bjorn3",
        "timestamp": 1638128253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"441719\">Gonzalo Brito (gnzlbg)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niche.20control/near/262929408\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I think that’s correct, from the point of view of validity nothing changes. I really don’t understand why using repr(C, u32) disables niche optimizations in my experiments. Maybe it’s a bug?</p>\n</blockquote>\n<p>The <code>#repr(C)</code> and <code>#[repr(inttype)]</code> on enums guarantee to encode discriminant in specific way (as per RFC 2195), so they are fundamentally incompatible with niche optimization for the enum. They still expose their niche, which can be used for niche optimization of an outer enum.</p>",
        "id": 262944792,
        "sender_full_name": "tm",
        "timestamp": 1638128646
    },
    {
        "content": "<p>my understanding was that <span class=\"user-mention\" data-user-id=\"441719\">@Gonzalo Brito (gnzlbg)</span> said that it is the <em>outer</em> niche optimizations that get diasbled. I admit I did not actually check this.</p>",
        "id": 262946795,
        "sender_full_name": "RalfJ",
        "timestamp": 1638131611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"441719\">Gonzalo Brito (gnzlbg)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niche.20control/near/262943665\">said</a>:</p>\n<blockquote>\n<p>Maybe what I want is repr(u32) without C</p>\n</blockquote>\n<p>that already exists -- in fact on nightly I get a lint when I do <code>repr(C, u32)</code></p>",
        "id": 262946852,
        "sender_full_name": "RalfJ",
        "timestamp": 1638131685
    },
    {
        "content": "<p>I checked now and the optimizations do happen: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9315c06a76998fa5d9e73a0dce3a131b\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9315c06a76998fa5d9e73a0dce3a131b</a></p>",
        "id": 262946895,
        "sender_full_name": "RalfJ",
        "timestamp": 1638131745
    },
    {
        "content": "<p>so <span class=\"user-mention\" data-user-id=\"441719\">@Gonzalo Brito (gnzlbg)</span> why do you mean when you say \"repr(C, u32) disables niche optimizations\" -- the link above demonstrates they do not get disabled?</p>",
        "id": 262946943,
        "sender_full_name": "RalfJ",
        "timestamp": 1638131782
    },
    {
        "content": "<p>RFC: <a href=\"https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html#guide-level-explanation\">https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html#guide-level-explanation</a></p>\n<p><code>repr(C, Int)</code> being a 2-field struct with a tag enum and a paylod union says to me it would definitely get layout optimizations.  It's less obvious whether just <code>repr(Int)</code> would, as that's phrased as union-of-structs, and unions seem to disable them as we don't have the \"at least one variant must be valid\" rule, IIRC.</p>",
        "id": 262947176,
        "sender_full_name": "scottmcm",
        "timestamp": 1638132184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I tried this a couple of weeks ago and I couldn’t get 0 to get picked as the niche</p>",
        "id": 262947456,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638132658
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8cf5330f3ef615cedb1a03b96517904b\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8cf5330f3ef615cedb1a03b96517904b</a></p>",
        "id": 262947598,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638132895
    },
    {
        "content": "<p>Shows that it get picked here, did this change recently?</p>",
        "id": 262947604,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638132907
    },
    {
        "content": "<p>Enum should prefer discriminant zero for niche: <a href=\"https://github.com/rust-lang/rust/issues/87794\">#87794</a>, probably?</p>",
        "id": 262947672,
        "sender_full_name": "tm",
        "timestamp": 1638133012
    },
    {
        "content": "<p>Might be, cool. Then nothing for me to do then <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 262947757,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638133198
    },
    {
        "content": "<p>I only need this for C-like enums that don’t have a variant with value 0</p>",
        "id": 262947865,
        "sender_full_name": "Gonzalo Brito (gnzlbg)",
        "timestamp": 1638133251
    },
    {
        "content": "<p>note however that I dont think we <em>guarantee</em> that 0 gets picked as a niche, even if it currently does get picked</p>",
        "id": 262949606,
        "sender_full_name": "RalfJ",
        "timestamp": 1638135426
    }
]