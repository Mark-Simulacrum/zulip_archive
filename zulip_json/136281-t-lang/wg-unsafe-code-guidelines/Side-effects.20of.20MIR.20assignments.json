[
    {
        "content": "<p>Sure</p>",
        "id": 276750806,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335717
    },
    {
        "content": "<p><del>for your original question as I said above, provenance changing or not <em>makes no difference</em></del></p>",
        "id": 276750847,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335735
    },
    {
        "content": "<p>since <em>all</em> pointers to that memory are read-only, making the write UB</p>",
        "id": 276750851,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335749
    },
    {
        "content": "<p>ah oh wait I might have misread</p>",
        "id": 276750867,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335786
    },
    {
        "content": "<p>so the MIR code is like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">r</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Retag</span><span class=\"p\">([</span><span class=\"n\">raw</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276750936,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335871
    },
    {
        "content": "<p>and the retag <em>is</em> the key operation here since a retag to a const raw ptr creates a provenance with read-only permission</p>",
        "id": 276750947,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335894
    },
    {
        "content": "<p><code>addr_of!(*r)</code> (in MIR!) returns a ptr that is wholly identical (addr and provenance) to the value stored in <code>r</code></p>",
        "id": 276750977,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335961
    },
    {
        "content": "<p>it is the subsequent <code>Retag</code> that \"adjusts\" the provenance of <code>p</code>, as part of Stacked Borrows</p>",
        "id": 276751036,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336002
    },
    {
        "content": "<p>sorry for the confusion. I hope this makes sense <span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> ?</p>",
        "id": 276751041,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336014
    },
    {
        "content": "<p>So referring back to this Rust code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">r</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">rp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// Line A</span>\n<span class=\"w\">    </span><span class=\"c1\">// `r`s memory now contains a `&amp;mut x`.</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// The `r as *const i32` is lowered to `&amp;raw *r` in MIR</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Line B</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the relevant MIR for the <code>r as *const i32</code> on Line B is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">_12</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">_1</span><span class=\"p\">);</span><span class=\"w\">          </span><span class=\"c1\">// scope 3 at test.rs:9:13: 9:14</span>\n<span class=\"w\">        </span><span class=\"n\">Retag</span><span class=\"p\">([</span><span class=\"n\">raw</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">_12</span><span class=\"p\">);</span><span class=\"w\">                </span><span class=\"c1\">// scope 3 at test.rs:9:13: 9:14</span>\n</code></pre></div>\n<p>Importantly, before that, the memory of <code>_1</code>, ie the memory you would be touching if you did <code>load(_1)</code> contains the bytes that were created on Line A by the write of the value yielded by <code>&amp;mut x</code> to the memory at <code>*rp</code>. This write happens at type <code>&amp;mut i32</code>, and so the resulting pointer in memory should have SRW provenance. Because of the way <code>*rp</code>is constructed, writing to writes to the same memory that <code>load(_1)</code> would load.</p>\n<p>Then, in Line B, we begin by performing a <code>load(_1)</code> at type <code>&amp;i32</code>. Keep in mind that the actual memory that is being loaded currently contains a pointer with a tag having Unique provenance. My confusion is about the semantics of this load. Assuming it does not affect borrow stacks and the provenance of the resulting pointer value is the same as the provenance of the pointer bytes in memory, we should get out a value that looks like a <code>&amp;mut x</code> (since that is what was written to that memory). Then, we dereference that value creating a <code>Place(&amp;mut x)</code>, for which we subsequently do a <code>&amp;raw</code> on. This means that the pointer yielded by <code>&amp;raw *(load(_1))</code> (stored in <code>_12</code>) has SRW provenance. We can then retag it without issue. Afterwards we should be able to use it to perform a <code>*_12 = 5;</code> operation without causing UB</p>",
        "id": 276751295,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336378
    },
    {
        "content": "<p>(I made this a new thread since it's somewhat separate from the old one, sorry <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I couldnt exclude your 2 messages)</p>",
        "id": 276751298,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336383
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> regarding the original example, it doesnt even contain a <code>x=x</code> so I am not sure how it even relates to our previous discussion</p>",
        "id": 276751309,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336411
    },
    {
        "content": "<blockquote>\n<p>This means that the pointer yielded by &amp;raw *(load(_1)) (stored in _12) has SRW provenance.</p>\n</blockquote>\n<p>Yes, everything is correct until here.</p>\n<blockquote>\n<p>We can then retag it without issue. Afterwards we should be able to use it to perform a *_12 = 5; operation without causing UB</p>\n</blockquote>\n<p>This is where things go wrong. The retag adjusts _12 to have SRO provenance.</p>",
        "id": 276751379,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336494
    },
    {
        "content": "<p>But how does it know to do that?</p>",
        "id": 276751389,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336515
    },
    {
        "content": "<p>(thanks for the very detailed explanation with the example!)</p>",
        "id": 276751392,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336520
    },
    {
        "content": "<p>ie based on what information?</p>",
        "id": 276751395,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336524
    },
    {
        "content": "<p>based on whether its raw-retagging a <code>*const</code> or <code>*mut</code></p>",
        "id": 276751400,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336539
    },
    {
        "content": "<p>oh what... that wasn't in my mind as a possibility at all. I thought these were equivalent</p>",
        "id": 276751456,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336587
    },
    {
        "content": "<p>they are almost :/</p>",
        "id": 276751465,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336604
    },
    {
        "content": "<p>but when a value crosses from being a reference to being a raw ptr, at that moment the kind of raw ptr matters</p>",
        "id": 276751469,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336620
    },
    {
        "content": "<p>i.e., at the cast</p>",
        "id": 276751476,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336633
    },
    {
        "content": "<p>that's not just a Miri thing, even the borrow checker makes a distinction there</p>",
        "id": 276751479,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336647
    },
    {
        "content": "<p>Oh hmm. Ok, I had no idea about that. That's surprising</p>",
        "id": 276751481,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336658
    },
    {
        "content": "<p>yes it is</p>",
        "id": 276751482,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336678
    },
    {
        "content": "<p>see <a href=\"https://github.com/rust-lang/rust/issues/56604\">https://github.com/rust-lang/rust/issues/56604</a> for a looong discussion</p>",
        "id": 276751507,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336682
    },
    {
        "content": "<p>Alright, I agree that there's no issues around <code>x = x;</code> then</p>",
        "id": 276751549,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336778
    },
    {
        "content": "<p>but basically (a) with current SB, it's hard to implement anything else (Cc <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/227\">https://github.com/rust-lang/unsafe-code-guidelines/issues/227</a>), and (b) given that the borrow checker distinguishes them, maybe this makes some sense?</p>",
        "id": 276751550,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336778
    },
    {
        "content": "<p>How does the borrow checker distinguish?</p>",
        "id": 276751596,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336811
    },
    {
        "content": "<p>specifically, for <code>x: &amp;mut T</code> with outstanding shared loans the borrow checker will allow <code>x as *const _</code> but not <code>x as *mut _</code></p>",
        "id": 276751598,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336814
    },
    {
        "content": "<p>Ah, interesting</p>",
        "id": 276751603,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336827
    },
    {
        "content": "<p>essentially, <code>x as *const _</code> is equivalent to <code>(&amp;*x) as *const _</code></p>",
        "id": 276751611,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336839
    },
    {
        "content": "<p>and <code>&amp;*x</code> is ofc allowed when there are outstanding shared loans</p>",
        "id": 276751614,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336852
    },
    {
        "content": "<p>Yeah, I'm not super happy about that, but I don't mind too much either</p>",
        "id": 276751625,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648336881
    },
    {
        "content": "<p>but that is a very good question, since indeed if raw ptr types truly did not matter then that code would not be UB</p>",
        "id": 276751628,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336891
    },
    {
        "content": "<p>now I need to get dinner :D see y'all!</p>",
        "id": 276751686,
        "sender_full_name": "RalfJ",
        "timestamp": 1648336940
    }
]