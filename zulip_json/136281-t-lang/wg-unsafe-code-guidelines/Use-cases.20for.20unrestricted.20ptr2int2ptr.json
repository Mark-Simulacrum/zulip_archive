[
    {
        "content": "<p>The other threads are very long, so I'm just going to start this one to discuss any potential uses of these roundtrips that aren't transmutes (which are a big pain) or simple tagging. Some of these are addressable with changes to APIs such as <code>with_addr</code>, <code>map_addr</code>, or something like an arena allocator supporting ptr2int2ptr casts.</p>",
        "id": 276282515,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648003441
    },
    {
        "content": "<p>Compressed pointers: These are used in V8, the JVM, and the purpose is to pack a 64bit pointer into 32 bits, using <code>libc:MAP_32BIT</code> or some other way of ensuring high bits are not used. The JVM and V8 implementations use an offset from some arena allocator, and such approaches probably can be ported fine.</p>\n<p>There are <a href=\"https://users.rust-lang.org/t/32-bit-pointers-to-the-heap/58255\">some uses</a> of Rust that simply truncate the top 32 bits though, and rely on a simple cast back to a pointer.</p>",
        "id": 276282762,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648003715
    },
    {
        "content": "<p>User-memcpy: This is a well known issue in C, to the pointer where PNVI-ae-udi spends a good few paragraphs making sure this works. <a href=\"https://docs.rs/esp32-hal/latest/esp32_hal/mem/fn.memcpy.html\">Rust embedded</a>, does use these semantics, but these could probably be fixed by adding some notion of <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2021-June/151199.html\">LLVM's proposed byte type</a> to Rust proper.</p>",
        "id": 276282853,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648003813
    },
    {
        "content": "<ul>\n<li>several unixy APIs take int args that you're supposed to cast to pointers</li>\n<li>xor lists, technically</li>\n<li><em>possibly</em> unwinder stuff, needs more investigation</li>\n<li>ipc? swap?</li>\n</ul>",
        "id": 276283089,
        "sender_full_name": "Gankra",
        "timestamp": 1648004129
    },
    {
        "content": "<p>Garbage collectors: I can't do this any justice better than this comment. <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/248#issuecomment-749726380\">https://github.com/rust-lang/unsafe-code-guidelines/issues/248#issuecomment-749726380</a></p>\n<blockquote>\n<p>The garbage collected heap is a sea of aliasing, mutable pointers. Pointers are often tagged, and any object can (to a <br>\ngood approximation) point to any other object. Furthermore, some GC algorithms need to be able to go from one <br>\nobject to the object after it, even though there are no pointers from one to the other! That’s what I meant by <br>\n“unbounded provenance”: I need to be able to take a usize, mask off its tag bits, and cast it into a pointer that is valid <br>\nfor the entire heap. I can, however, promise that there are no references into the GC heap at all, except for transient <br>\nones when dereferencing raw pointers.</p>\n</blockquote>",
        "id": 276283183,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648004265
    },
    {
        "content": "<p>libc backcompat: A lot of this in Rust is just libc giving up and defining stuff like <a href=\"https://docs.rs/libc/latest/libc/type.sighandler_t.html\">sighandler_t</a> to be <code>size_t</code>, probably due to a lack of union support in Rust 1.0, and maybe due to the lack of extern types(?).</p>",
        "id": 276285760,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648007779
    },
    {
        "content": "<p>Yeah that's just wrong. :|</p>",
        "id": 276285865,
        "sender_full_name": "Jubilee",
        "timestamp": 1648007975
    },
    {
        "content": "<p>sighandler_t is a straightforward <code>Option&lt;extern fn(c_int)&gt;</code> at least on linux so I don't know why it was ever size_t</p>",
        "id": 276286193,
        "sender_full_name": "Talchas",
        "timestamp": 1648008347
    },
    {
        "content": "<p>(and in general it has to accept a function pointer, so I don't know if it's even a real impl-defined typedef or just \"function pointer types in C syntax suck\")</p>",
        "id": 276286279,
        "sender_full_name": "Talchas",
        "timestamp": 1648008440
    },
    {
        "content": "<p>but things like prctl just mean you just lose unless you write idiotic C wrappers</p>",
        "id": 276286365,
        "sender_full_name": "Talchas",
        "timestamp": 1648008537
    },
    {
        "content": "<p>meh, not the worst thing tbh.</p>",
        "id": 276286373,
        "sender_full_name": "Jubilee",
        "timestamp": 1648008558
    },
    {
        "content": "<p>\"no you can't do <code>foo(ptr.addr())</code> you have to write your own C wrapper that does literally the same thing\" is kinda inexcusable</p>",
        "id": 276286482,
        "sender_full_name": "Talchas",
        "timestamp": 1648008718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276283089\">said</a>:</p>\n<blockquote>\n<ul>\n<li>several unixy APIs take int args that you're supposed to cast to pointers</li>\n</ul>\n</blockquote>\n<p>Which APIs are you thinking of here?</p>",
        "id": 276291039,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648014128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276283089\">said</a>:</p>\n<blockquote>\n<ul>\n<li>ipc? swap?</li>\n</ul>\n</blockquote>\n<p>For both inter-process and intra-process communication, you could pass a pointer over a byte-serialized channel (e.g. a pipe), pick it up on the other end, and turn it back into a pointer. In the case of inter-process communication you'd probably want to base it on the start of your shared memory region, but I think some code just maps things to the same place in multiple address spaces.</p>\n<p>Also not sure if RDMA or similar might care here.</p>",
        "id": 276291095,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648014238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276291039\">said</a>:</p>\n<blockquote>\n<p>Which APIs are you thinking of here?</p>\n</blockquote>\n<p>prctl, makecontext (lol), clone3 and it looks like a few other modern linux syscalls that take pointers in a larger struct (which is relevant because it's done for layout) are what I know of offhand</p>",
        "id": 276292218,
        "sender_full_name": "Talchas",
        "timestamp": 1648015676
    },
    {
        "content": "<p>there's probably a few others like prctl where it's basically <code>union {pointer, integer}</code> but the authors saw no reason to bother and picked integer as the type to use rather than pointer basically at random</p>",
        "id": 276292285,
        "sender_full_name": "Talchas",
        "timestamp": 1648015757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276286482\">said</a>:</p>\n<blockquote>\n<p>\"no you can't do <code>foo(ptr.addr())</code> you have to write your own C wrapper that does literally the same thing\" is kinda inexcusable</p>\n</blockquote>\n<p>oh, no, I was thinking more that one would want to write a wrapper that has the Correct function signature, but that it's not really any harm to call <code>.addr()</code>.<br>\nbut tbh, I would be game for saying \"we should be able to provide more correct function signatures for C functions\", like saying \"no this isn't an integer, it's an integer/pointer union.\"</p>",
        "id": 276305589,
        "sender_full_name": "Jubilee",
        "timestamp": 1648027181
    },
    {
        "content": "<p>I mean, that's UB according to C and likely any rust AM too, sooo :P (it's probably not actually generating broken code anywhere, but LLVM's breakage around &amp;mut vs *mut certainly makes it somewhat sketchy)</p>",
        "id": 276363726,
        "sender_full_name": "Talchas",
        "timestamp": 1648053810
    },
    {
        "content": "<p>ehhhhhhhhhhhhhhhhhhhhhhhhh it's not for reasons that are hard to explain but boil down to \"you get to talk a lot of shit if you're actually the compiler\".</p>",
        "id": 276365460,
        "sender_full_name": "Jubilee",
        "timestamp": 1648054434
    },
    {
        "content": "<p>I mean, it is 100% absolutely UB by the C spec. You can say that on all platforms rust supports the ABI is the same, but now you need to list out exactly the valid replacements in the rust spec, because users need to be able to do this as well, not just stdlib</p>",
        "id": 276367081,
        "sender_full_name": "Talchas",
        "timestamp": 1648054934
    },
    {
        "content": "<p>and you need to trust / check that LLVM doesn't screw this up ever, despite being primarily designed for C where this is UB</p>",
        "id": 276367173,
        "sender_full_name": "Talchas",
        "timestamp": 1648054967
    },
    {
        "content": "<p>literally if the user does it wrong then you can emit a thunk instead.</p>",
        "id": 276367203,
        "sender_full_name": "Jubilee",
        "timestamp": 1648054979
    },
    {
        "content": "<p>you just happen to be emitting a thunk that does nothing and thus compiles away if they do it right.</p>",
        "id": 276367275,
        "sender_full_name": "Jubilee",
        "timestamp": 1648055010
    },
    {
        "content": "<p>thus \"you get to talk a lot of shit if you're actually the compiler\"</p>",
        "id": 276367418,
        "sender_full_name": "Jubilee",
        "timestamp": 1648055054
    },
    {
        "content": "<p>if you're not going the \"just trust that the ABI is the same\" route, you can't do that because shared objects, and non-LTO builds</p>",
        "id": 276367425,
        "sender_full_name": "Talchas",
        "timestamp": 1648055057
    },
    {
        "content": "<p>unless you mean making a special type that is \"int type X for ABI but exposed in rust as pointer\"</p>",
        "id": 276367537,
        "sender_full_name": "Talchas",
        "timestamp": 1648055093
    },
    {
        "content": "<p>I don't think explaining the precise steps I would take is going to be productive because any partial explanation is clearly going to be picked apart so there is no point in having this conversation as opposed to writing the essay and/or library.</p>",
        "id": 276367819,
        "sender_full_name": "Jubilee",
        "timestamp": 1648055200
    },
    {
        "content": "<blockquote>\n<p>unless you mean making a special type that is \"int type X for ABI but exposed in rust as pointer\"</p>\n</blockquote>\n<p>actually, that would be pretty useful. One of my complaints about forbidding int-&gt;ptr is that with integers, you can handle 32/64 bit the same way by just always using u64 to store pointers -- since 32 bit pointers are a subset of 64 bit pointers this works and reduces the need to write a special codepath for each.</p>",
        "id": 276367857,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648055223
    },
    {
        "content": "<p>It seems difficult to design though.</p>",
        "id": 276367943,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648055261
    },
    {
        "content": "<p>that's a useful note.</p>",
        "id": 276367985,
        "sender_full_name": "Jubilee",
        "timestamp": 1648055278
    },
    {
        "content": "<p>I mean, saying you can somehow generate the correct code to interface with a shared library loaded at runtime without an accurate description of its ABI deserves a \"no you can't, not even if you're the compiler\"</p>",
        "id": 276368794,
        "sender_full_name": "Talchas",
        "timestamp": 1648055588
    },
    {
        "content": "<p>At worst the stdlib could define Ptr32, Ptr64, Ptr128, types to bless this pattern, and since We're The Language we can just say \"lol it's an integer\" and only fix it when the compiler gets smart enough to care</p>",
        "id": 276369634,
        "sender_full_name": "Gankra",
        "timestamp": 1648055930
    },
    {
        "content": "<p>You can,<br>\nbut clang cannot generate code that correctly calls GCC 100% of the time anyways, so I don't see why we're pretending C isn't UB when calling C even if the C isn't UB.</p>",
        "id": 276369713,
        "sender_full_name": "Jubilee",
        "timestamp": 1648055969
    },
    {
        "content": "<p>I added a few of these things to the open questions on <a href=\"https://github.com/rust-lang/rust/issues/95228\">https://github.com/rust-lang/rust/issues/95228</a></p>",
        "id": 276369903,
        "sender_full_name": "Gankra",
        "timestamp": 1648056050
    },
    {
        "content": "<p>And there are several spots in the existing ABIs that can cause UB even just doing the call like you're supposed to.<br>\nSo no,<br>\nyou don't need an accurate description of the ABI.<br>\nYou need something even more powerful.</p>",
        "id": 276370025,
        "sender_full_name": "Jubilee",
        "timestamp": 1648056096
    },
    {
        "content": "<p>I explicitly wrote <a href=\"https://github.com/Gankra/abi-checker\">https://github.com/Gankra/abi-checker</a></p>\n<p>to help us validate that our claims of what Works are actually accurate against actual rustc and actual C compilers</p>",
        "id": 276370165,
        "sender_full_name": "Gankra",
        "timestamp": 1648056145
    },
    {
        "content": "<p>If we're talking about int2ptr and FFI, then another niche use-case are raw syscalls, which usually accept a list of longs which could be either pointers or integers</p>",
        "id": 276374047,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1648057761
    },
    {
        "content": "<p>Interop with C/C++/ASM: By all accounts, this code is currently valid. And even if technically UB in C proper right now, it's de facto guranteed, and will be valid with TS 6010/N2676. Or just imagine we're doing this in assembly.</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"nf\">ptrtoint</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"nf\">inttoptr</span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptrtoint</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">libc</span>::<span class=\"n\">c_void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">c</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Ditto goes for something that reinterprets numbers and integers in assembly or something. Now of course you could say that one/or all of these unsafe blocks is unsound, such as Rust pointers being unconvertible to integers even in C, but that's just <em>fun</em>.</p>",
        "id": 276375114,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648058180
    },
    {
        "content": "<p>it's worth noting that things like ASM and FFI are outside the scope of a memory model -- a foreign language gets to do whatever the fuck it wants as long as it works in practice</p>",
        "id": 276375781,
        "sender_full_name": "Gankra",
        "timestamp": 1648058444
    },
    {
        "content": "<p>Not really when it comes to provenance.</p>",
        "id": 276375841,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648058474
    },
    {
        "content": "<p>I miss concise code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Must use this</span>\n<span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Instead of this</span>\n<span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Would it be possible to make <code>+=</code> into <code>self.with_addr(self.addr() + other)</code> without breaking things?</p>",
        "id": 276376984,
        "sender_full_name": "Bot+",
        "timestamp": 1648058977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276375841\">said</a>:</p>\n<blockquote>\n<p>Not really when it comes to provenance.</p>\n</blockquote>\n<p>Yeah, basically let's imagine a world where all inttoptr/ptrtoint casts in Rust were FFI function calls to a language where this has defined behavior, with all else being equal. Would that model solve the issue with inttoptr/ptrtoint casts? (Yes I'm aware this is a very non academic model)</p>\n<p>But do any of the provenance simplifications work still? I'm sure we would lose some optimizations, but if you could get those back with <code>with_addr</code> and friends that might tractable. If that model doesn't work, then it looks to me like we can't really interop with C.</p>",
        "id": 276377474,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648059192
    },
    {
        "content": "<p>and if that model _does_ work, then why do you need the C functions rather than have two variants of inttoptr/ptrtoint, one of which works like C, and one of which gives you better optimizations when all you're doing is align/bit stuff or other things like that</p>",
        "id": 276377693,
        "sender_full_name": "Talchas",
        "timestamp": 1648059279
    },
    {
        "content": "<p>(and saying \"FFI is out of scope of the spec, so all that is fine\" is kinda a useless dodge since it means all rust programs are out of scope)</p>",
        "id": 276377860,
        "sender_full_name": "Talchas",
        "timestamp": 1648059349
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420380\">Bot+</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276376984\">said</a>:</p>\n<blockquote>\n<p>I miss concise code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Must use this</span>\n<span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Instead of this</span>\n<span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Would it be possible to make <code>+=</code> into <code>self.with_addr(self.addr() + other)</code> without breaking things?</p>\n</blockquote>\n<p>that would be very weird since everyone \"expects\" offsets to be strided (multiplied by size)</p>",
        "id": 276378596,
        "sender_full_name": "Gankra",
        "timestamp": 1648059634
    },
    {
        "content": "<p>also you can write <code>ptr.cast::&lt;u8&gt;().add(7).cast::&lt;u64&gt;()</code> which is <em>less</em> bad (I know, I always forget that .cast exists too, i am very stuck in the old ways...)</p>",
        "id": 276378788,
        "sender_full_name": "Gankra",
        "timestamp": 1648059719
    },
    {
        "content": "<p>I do think there's an argument for including .byte_offset() for this kind of fuckery tho</p>",
        "id": 276378902,
        "sender_full_name": "Gankra",
        "timestamp": 1648059756
    },
    {
        "content": "<p>Yeah, advancing a window by a variable amount and doing unaligned load is kinda niche performance trick.</p>",
        "id": 276379249,
        "sender_full_name": "Bot+",
        "timestamp": 1648059890
    },
    {
        "content": "<p>the main place where I felt the pain is in the unix stackguard code where you have <code>void*</code>s</p>",
        "id": 276379495,
        "sender_full_name": "Gankra",
        "timestamp": 1648059998
    },
    {
        "content": "<p>and like <em>probably</em> offset is by bytes for that but I'm not gonna play that game lol</p>",
        "id": 276379516,
        "sender_full_name": "Gankra",
        "timestamp": 1648060010
    },
    {
        "content": "<p>my understanding is that <code>void *</code> is in fact defined to have a stride of 1</p>",
        "id": 276382084,
        "sender_full_name": "Jubilee",
        "timestamp": 1648061135
    },
    {
        "content": "<p>Nope.</p>",
        "id": 276382151,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648061163
    },
    {
        "content": "<p><code>p+n</code> for <code>void* p;</code> is ill-formed in C.</p>",
        "id": 276382211,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648061185
    },
    {
        "content": "<p>It's a gcc extension that it's identical to <code>(void*)(((char*)p)+n)</code></p>",
        "id": 276382280,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648061222
    },
    {
        "content": "<p>an extremely common extension. but also rust defines it as a pointer to a Never enum which I am also Not Going To Fuck With</p>",
        "id": 276382357,
        "sender_full_name": "Gankra",
        "timestamp": 1648061255
    },
    {
        "content": "<p><em>sips coffee</em> I see.</p>",
        "id": 276382393,
        "sender_full_name": "Jubilee",
        "timestamp": 1648061274
    },
    {
        "content": "<p>everything decent in C is a gcc extension lol</p>",
        "id": 276382451,
        "sender_full_name": "Gankra",
        "timestamp": 1648061288
    },
    {
        "content": "<p>which makes it all the more impressive that msvc doesn't conform the meager standards lol</p>",
        "id": 276382602,
        "sender_full_name": "Gankra",
        "timestamp": 1648061357
    },
    {
        "content": "<p>In some cases, msvc is <em>more</em> compliant than gcc, because of gcc's myriad of extensions.</p>",
        "id": 276382754,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648061421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276382357\">said</a>:</p>\n<blockquote>\n<p>an extremely common extension. but also rust defines it as a pointer to a Never enum which I am also Not Going To Fuck With</p>\n</blockquote>\n<p><code>c_void</code> is a two-variant enum:<br>\n<a href=\"https://github.com/rust-lang/rust/blob/92804455704cc59d6d8272faf72f442c6125d395/library/core/src/ffi/mod.rs#L165\">https://github.com/rust-lang/rust/blob/92804455704cc59d6d8272faf72f442c6125d395/library/core/src/ffi/mod.rs#L165</a><br>\nunless you mean something else?</p>",
        "id": 276383018,
        "sender_full_name": "cuviper",
        "timestamp": 1648061563
    },
    {
        "content": "<p>Ah I must have misremembered/misread last time I looked</p>",
        "id": 276383625,
        "sender_full_name": "Gankra",
        "timestamp": 1648061833
    },
    {
        "content": "<p>I am also possibly biased by being around when people were theory crafting wild shit like maybe making sizeof::&lt;opaque&gt; effectively infinite and other weird shit to try to hack around the inexpressibility of \"no size\"</p>",
        "id": 276384293,
        "sender_full_name": "Gankra",
        "timestamp": 1648062122
    },
    {
        "content": "<p>I remember talking about <code>size_of::&lt;uninhabited&gt; == -∞</code> too</p>",
        "id": 276385264,
        "sender_full_name": "cuviper",
        "timestamp": 1648062530
    },
    {
        "content": "<p><code>impl Sized for ! { const SIZE_OF: f32 = f32::NAN; }</code></p>",
        "id": 276385292,
        "sender_full_name": "bstrie",
        "timestamp": 1648062548
    },
    {
        "content": "<p>hahaha.</p>",
        "id": 276385316,
        "sender_full_name": "Jubilee",
        "timestamp": 1648062557
    },
    {
        "content": "<p>Debuggers: These rely on I/O for pointers, but usually just cast them to call a platform API, so probably tractable. And I think CHERI even has OS-level support for them.</p>\n<p>Pointer obfuscation: Replaceable with new APIs for the most part, although some implementations do cursed things like scrambling 4 pointers together. This really should be an LLVM level-pass or something, but in C, having a ton of macros you have to use is... surprisingly common.</p>\n<p>Serialization: Somewhat of a mess... but <code>rkyv</code> doesn't do anything fundamentally incompatible unlike other implementations as it uses relative pointers. Stuff that requires you to be mmaped at a specific address is probably a lost cause though.</p>\n<p>That's about all the actual use-cases I've been able to find. Feels both like not that much and quite a bit at the same time for some weird reason. (Now I need to work on the essay that's due that I've really been procrastinating on)</p>",
        "id": 276556726,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648167600
    },
    {
        "content": "<p>rkyv is UCG 256/134. The issue with rkyv is not conjuring a pointer from nothing or doing ptr-int-ptr, it's converting a reference to a pointer then accessing outside of the referent.</p>",
        "id": 276557410,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648168116
    },
    {
        "content": "<p>worth noting that llvm has prior art for pointer ofuscation APIs: <a href=\"https://llvm.org/docs/PointerAuth.html\">https://llvm.org/docs/PointerAuth.html</a></p>",
        "id": 276557421,
        "sender_full_name": "Gankra",
        "timestamp": 1648168123
    },
    {
        "content": "<p>rkyv is another example like intrusive data structures where you can already do it, just not with references the way rkyv is trying to.</p>",
        "id": 276557475,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648168187
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">unsafe-code-guidelines#134</a> and <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/256\">unsafe-code-guidelines#256</a> you mean?</p>",
        "id": 276562041,
        "sender_full_name": "Jubilee",
        "timestamp": 1648172427
    },
    {
        "content": "<p>Yes, that is what I mean. The community discord sometimes uses those issues along with 133, <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133\">https://github.com/rust-lang/unsafe-code-guidelines/issues/133</a> as shorthand for particular patterns that people write often but are not permitted under SB.</p>",
        "id": 276565299,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648175961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276375114\">said</a>:</p>\n<blockquote>\n<p>Interop with C/C++/ASM: By all accounts, this code is currently valid. And even if technically UB in C proper right now, it's de facto guranteed, and will be valid with TS 6010/N2676. Or just imagine we're doing this in assembly.</p>\n<p><div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"nf\">ptrtoint</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"nf\">inttoptr</span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It's not UB, but implementation defined, unless I'm mistaken.</p>",
        "id": 276721663,
        "sender_full_name": "comex",
        "timestamp": 1648294894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276375781\">said</a>:</p>\n<blockquote>\n<p>it's worth noting that things like ASM and FFI are outside the scope of a memory model -- a foreign language gets to do whatever the fuck it wants as long as it works in practice</p>\n</blockquote>\n<p>It may be outside the scope of the <em>current</em> memory model, but IMO that means the memory model is incomplete.  For one thing, on platforms not named CHERI, the purpose of provenance is to enable optimizations, and with cross-language LTO, LLVM performs those optimizations on a mix of Rust and C code.  For another, even without cross-language LTO, you still have to define what optimizations around FFI calls are legal.</p>",
        "id": 276721902,
        "sender_full_name": "comex",
        "timestamp": 1648295266
    },
    {
        "content": "<p>cross-language LTO is a great point, in terms of needing to actually have a model that llvm can merge with C's model.</p>",
        "id": 276726993,
        "sender_full_name": "Gankra",
        "timestamp": 1648302482
    },
    {
        "content": "<p>(I don't think it would be a <em>tragedy</em> if Rust ended up with PNVI-ae-udi, and maybe FFI ends up acting like that? That's actually an interesting question if you can have stacked borrows / strict provenance as a layer \"on top of\" PNVI-ae-udi in a coherent way. Like the whole system is assumed to follow those semantics but the code we control has to follow stricter semantics? HMM...)</p>",
        "id": 276727104,
        "sender_full_name": "Gankra",
        "timestamp": 1648302615
    },
    {
        "content": "<p>also lmao one of the authors of the PNVI-ae-udi proposal (Martin Uecker) is just in my twitter mentions chatting me up and talking about collaboration lol</p>",
        "id": 276730046,
        "sender_full_name": "Gankra",
        "timestamp": 1648306861
    },
    {
        "content": "<p><a href=\"https://twitter.com/martin_uecker/status/1507713668141621255\">https://twitter.com/martin_uecker/status/1507713668141621255</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/martin_uecker/status/1507713668141621255\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/5b8ce1ec917f53c6b5a4d5922b274f0a9e4160ff/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313138313238323030343039383134363330352f6c63676630354d4b5f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> Oh definitely. Rust may go beyond this. But it would be good to exchange ideas and maybe stay synchronized where this is possible.</p><span>- Martin Uecker (@martin_uecker)</span></div></div>",
        "id": 276730133,
        "sender_full_name": "Gankra",
        "timestamp": 1648306985
    },
    {
        "content": "<p>Ralf's evergreen concern is that PNVI-ae-udi does not produce sensible ptr-int-ptr behavior in the presence of <code>restrict</code>.</p>\n<p>And it's interesting that in that paper they specifically talk about adding a no-expose annotation for memcpy to avoid pessimization. (Interesting because memcpy is probably the most common use of restrict)</p>",
        "id": 276731271,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648308688
    },
    {
        "content": "<p>But of course they're don't seem sure how this could be done</p>",
        "id": 276731311,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648308727
    },
    {
        "content": "<p>I think that is unrelated to <code>restrict</code>, and more related to <code>memcpy</code>  accessing pointer representations at <code>char</code> type which would be consider to 'expose' the pointer</p>",
        "id": 276734283,
        "sender_full_name": "RalfJ",
        "timestamp": 1648312696
    },
    {
        "content": "<p>if C had <code>MaybeUninit&lt;char&gt;</code> or the <code>byte</code> type some folks are proposing for LLVM, that would solve the issue of memcpy exposing</p>",
        "id": 276734293,
        "sender_full_name": "RalfJ",
        "timestamp": 1648312725
    },
    {
        "content": "<p>but wouldnt help with <code>restrict</code></p>",
        "id": 276734297,
        "sender_full_name": "RalfJ",
        "timestamp": 1648312736
    },
    {
        "content": "<p>Is there an explicit example lying around of how PNVI-ae-udi breaks the restrictions <code>restrict</code> is supposed to enforce / breaks typical ways optimizers would like to take advantage of said restrictions?</p>",
        "id": 276735762,
        "sender_full_name": "Talchas",
        "timestamp": 1648314706
    },
    {
        "content": "<p>an example, yes. I hope to write it up as a blog post done day but until then here's just the example:<br>\n<a href=\"https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html\">https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html</a></p>",
        "id": 276739807,
        "sender_full_name": "RalfJ",
        "timestamp": 1648320298
    },
    {
        "content": "<p>specifically this is an example against having 'dead cast elimination' with <code>restrict</code></p>",
        "id": 276739824,
        "sender_full_name": "RalfJ",
        "timestamp": 1648320326
    },
    {
        "content": "<p>PNVI and its variants dont really consider the case where there are multiple distinct valid provenances for a single location, so it's a bit hard to say where/if/how they would break -- it's simply out of scope for them</p>",
        "id": 276739891,
        "sender_full_name": "RalfJ",
        "timestamp": 1648320415
    },
    {
        "content": "<p>I think PNVI-ae in general needs to keep the cast metadata around? That doesn't seem like a special case with restrict? That is, since the various provenance specs clarify exactly how </p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">print</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>can't alias but </p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"p\">)((</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">math</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">print</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>can, you need to keep that metadata around by keeping the cast or whatever, even without <code>restrict</code> in play.</p>\n<p>And PNVI-ae-udi explicitly handles multiple distinct provenances with its ugly hack, and no part of that hack seems to actually rely on C having only two possible provenances for a given location.</p>",
        "id": 276741380,
        "sender_full_name": "Talchas",
        "timestamp": 1648322512
    },
    {
        "content": "<p>by \"ugly hack\" you mean that \"symbolic provenance\" they have? (not sure what they call it)</p>",
        "id": 276741563,
        "sender_full_name": "RalfJ",
        "timestamp": 1648322690
    },
    {
        "content": "<p>I mean making the world state be a set of possible states, and it's only real UB if there are no legal states left</p>",
        "id": 276741750,
        "sender_full_name": "Talchas",
        "timestamp": 1648322944
    },
    {
        "content": "<p>Yeah, but stacked borrows invalidating on read is a massive pain for that, as you quicky get into exponential blowup. And I think a greedy model or something would work, but that's beyond my ability to reason about, much less prove.</p>",
        "id": 276742113,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648323519
    },
    {
        "content": "<p>And fun fact: there exists a dialect of C that also allows pointer-integer transmutes (no-strict-aliasing), so if these models are actualized before Rust's we could probably get some benchmark numbers.</p>",
        "id": 276742516,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648324162
    },
    {
        "content": "<p>is anyone actually working on a formal model for -fno-strict-aliasing, or is it just going to be turning off TBAA info in the actual implementation?</p>",
        "id": 276742651,
        "sender_full_name": "Talchas",
        "timestamp": 1648324322
    },
    {
        "content": "<p>I may be wrong, but I think the provenance model is defined assuming no strict aliasing, (or at least considered if not officially defined), and strict aliasing \"simply\" allows those extra redundant store optimizations (in this case, there's many others).</p>",
        "id": 276742781,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648324470
    },
    {
        "content": "<p>hmm, yeah thinking about it the provenance models as currently written don't bother saying anything about types, since that's kinda a separate restriction</p>",
        "id": 276742859,
        "sender_full_name": "Talchas",
        "timestamp": 1648324614
    },
    {
        "content": "<p>re the exponential blowup, I'm not 100% convinced this is a problem for compilers, since they aren't operating on world state (and to the extent that they are, every if statement can do that). To the extent it causes linear blowup for the possible provenances for a given pointer, that /also/ is unavoidable for a compiler in any PNVI-ae world. It's inelegant for the theory, but that's fine. The part where it really causes problems is for miri of course, which probably just falls over.</p>",
        "id": 276743839,
        "sender_full_name": "Talchas",
        "timestamp": 1648325931
    },
    {
        "content": "<p>Yeah in general PNVI-ae is a semantic model that basically blesses what compilers are already doing, which is to say if you ever lose track of a pointer you toss it in the \"might be aliased bucket\" and if you ever get a pointer you don't know about it also goes in the \"might be aliased bucket\" and everything in that bucket is conservatively assumed to all be aliasing eachother</p>",
        "id": 276744011,
        "sender_full_name": "Gankra",
        "timestamp": 1648326233
    },
    {
        "content": "<p>even the weird boundary condition on \"one-past-the-end hittesting two exposed allocations\" is not Actually a problem in the sense that \"just only consistently access one\" is cromulently covered by \"might be aliased bucket\" rules.</p>",
        "id": 276744124,
        "sender_full_name": "Gankra",
        "timestamp": 1648326371
    },
    {
        "content": "<p>so idk why the compiler would have any obligation to <em>actually</em> track this stuff because it's always a valid implementation to just... assume things alias</p>",
        "id": 276744128,
        "sender_full_name": "Gankra",
        "timestamp": 1648326395
    },
    {
        "content": "<p>and the Really Important stuff like spills/return pointers is \"anonymous\" in the sense that it's Never Exposed</p>",
        "id": 276744144,
        "sender_full_name": "Gankra",
        "timestamp": 1648326445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276741750\">said</a>:</p>\n<blockquote>\n<p>I mean making the world state be a set of possible states, and it's only real UB if there are no legal states left</p>\n</blockquote>\n<p>PNVI doesn't even do that though, it \"just\" has a symbolic provenance and keeps track in a dedicated table of what that provenance \"means\".<br>\nwith SB / <code>restrict</code> you might indeed need the full \"set of possible states\" as the effect cannot be captured by a single table any more.</p>",
        "id": 276747827,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331617
    },
    {
        "content": "<p>formally speaking what is happening here is that we use <em>angelic non-determinism</em> to pick a provenance that works. and then we deterministically encode that angelic non-determinism by considering a set of possible executions at the same time, via the usual powerset construction for making a non-det state-machine deterministic.</p>",
        "id": 276747885,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331676
    },
    {
        "content": "<blockquote>\n<p>Yeah in general PNVI-ae is a semantic model that basically blesses what compilers are already doing, </p>\n</blockquote>\n<p>I wouldn't say that, what compilers are currently doing is <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">simply buggy</a> and PNVI hopefully helps convince them to fix it...</p>",
        "id": 276747909,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331719
    },
    {
        "content": "<p>ok sorry more accurately: expresses a well-formed version of what compilers basically want to be doing</p>",
        "id": 276747963,
        "sender_full_name": "Gankra",
        "timestamp": 1648331764
    },
    {
        "content": "<p>PNVI does say that a ptr-to-int cast has a side-effect (\"exposing\" the allocation) but AFAIK no compiler treats casts as having side-effects</p>",
        "id": 276747973,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331786
    },
    {
        "content": "<p>wow really? <em>that's</em> the part compilers have been refusing to implement?</p>",
        "id": 276747988,
        "sender_full_name": "Gankra",
        "timestamp": 1648331819
    },
    {
        "content": "<p>its not the only part</p>",
        "id": 276747997,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331831
    },
    {
        "content": "<p>also GVN on pointers and peephole-optimizing away ptr-int-ptr roundtrips</p>",
        "id": 276748005,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331849
    },
    {
        "content": "<p>FWIW, because of that side-effect I dont think PNVI is necessarily a great model for IRs, but C as a surface lang gets away with it</p>",
        "id": 276748020,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331871
    },
    {
        "content": "<p>Surely someone has cobbled together an implementation somewhere to gauge the performance impact</p>",
        "id": 276748076,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648331933
    },
    {
        "content": "<p>huh, why would ptr-int-ptr being optimized away be a problem?</p>",
        "id": 276748081,
        "sender_full_name": "Gankra",
        "timestamp": 1648331944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748081\">said</a>:</p>\n<blockquote>\n<p>huh, why would ptr-int-ptr being optimized away be a problem?</p>\n</blockquote>\n<p>see the blog post I linked ;)<br>\n<a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a></p>",
        "id": 276748090,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331968
    },
    {
        "content": "<p>ok FINE i will read your highly recommended post</p>",
        "id": 276748094,
        "sender_full_name": "Gankra",
        "timestamp": 1648331984
    },
    {
        "content": "<p>:D</p>",
        "id": 276748100,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331989
    },
    {
        "content": "<p><em>shakes fist</em></p>",
        "id": 276748101,
        "sender_full_name": "Gankra",
        "timestamp": 1648331990
    },
    {
        "content": "<p>also re: strict aliasing, AFAIK PNVI 'relies' on strict aliasing in the sense that that means they dont have to worry about things like <em>any load at integer type</em> potentially exposing a pointer that is being loaded...</p>",
        "id": 276748240,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332079
    },
    {
        "content": "<p>which is another aspect that makes PNVI less suited at least for LLVM</p>",
        "id": 276748242,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332092
    },
    {
        "content": "<p>this is the most evil code omg</p>",
        "id": 276748248,
        "sender_full_name": "Gankra",
        "timestamp": 1648332105
    },
    {
        "content": "<p>thanks <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 276748292,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332125
    },
    {
        "content": "<p>yeah, the proposal explicitly calls out that char* derefs would count as escapes and that there should be some way to tag a memcpy implementation as not qualifying</p>",
        "id": 276748343,
        "sender_full_name": "Talchas",
        "timestamp": 1648332221
    },
    {
        "content": "<p>and does this in the formal definitions section, where they have no formal definition for this</p>",
        "id": 276748346,
        "sender_full_name": "Talchas",
        "timestamp": 1648332235
    },
    {
        "content": "<p>yeah but making it formal isn't the problem</p>",
        "id": 276748472,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332364
    },
    {
        "content": "<p>(though in practice of course again the most important targets are likely to be known not to alias regardless, since the pointer-to-pointer will not have escaped, etc)</p>",
        "id": 276748478,
        "sender_full_name": "Talchas",
        "timestamp": 1648332368
    },
    {
        "content": "<p>the problem is that this means that every <code>char*</code> deref <em>can have a global side-effect</em></p>",
        "id": 276748485,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332377
    },
    {
        "content": "<p>which means it is <em>incorrect</em> to remove such a deref even if its result is not used</p>",
        "id": 276748489,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332386
    },
    {
        "content": "<p>and I have some even more horrible code that <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> will love at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806</a> to demonstrate this in Rust</p>",
        "id": 276748515,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332440
    },
    {
        "content": "<p>only if the compiler can't find a better way to lower those rules into optimizations, which it certainly feels like should be possible</p>",
        "id": 276748531,
        "sender_full_name": "Talchas",
        "timestamp": 1648332478
    },
    {
        "content": "<p>but might well not be</p>",
        "id": 276748575,
        "sender_full_name": "Talchas",
        "timestamp": 1648332485
    },
    {
        "content": "<p>so maybe when <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> suggests PNVI I should point to these problems rather than going on about <code>restrict</code>/<code>noalias</code> ;)</p>",
        "id": 276748616,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332593
    },
    {
        "content": "<p>interesting.</p>",
        "id": 276748658,
        "sender_full_name": "Jubilee",
        "timestamp": 1648332618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span>  not sure what \"lowering rules into optimizations\" means. what we need is an IR spec that (a) can be soundly compiled from C+PNVI and (b) still allows reasonable optimizations. I have a paper at <a href=\"https://www.ralfj.de/research/twinsem/twinsem.pdf\">https://www.ralfj.de/research/twinsem/twinsem.pdf</a> that proposes one. It still has some problems though, and LLVM doesn't seem eager to accept the <code>byte</code> type proposal that I think is crucial to this goal.</p>",
        "id": 276748660,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332624
    },
    {
        "content": "<p>(ofc in Rust \"every <code>char*</code> deref\" becomes \"basically every deref ever\" since we don't to TBAA)</p>",
        "id": 276748670,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748240\">said</a>:</p>\n<blockquote>\n<p>also re: strict aliasing, AFAIK PNVI 'relies' on strict aliasing in the sense that that means they dont have to worry about things like <em>any load at integer type</em> potentially exposing a pointer that is being loaded...</p>\n</blockquote>\n<p>oof.</p>",
        "id": 276748674,
        "sender_full_name": "Jubilee",
        "timestamp": 1648332663
    },
    {
        "content": "<p>the side-effect could instead be the store of the pointer into memory that could be aliased</p>",
        "id": 276748675,
        "sender_full_name": "Talchas",
        "timestamp": 1648332664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748675\">said</a>:</p>\n<blockquote>\n<p>the side-effect could instead be the store of the pointer into memory that could be aliased</p>\n</blockquote>\n<p>at store time the memory might not be aliased yet</p>",
        "id": 276748683,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332683
    },
    {
        "content": "<p>could at some point be aliased into an integer read</p>",
        "id": 276748741,
        "sender_full_name": "Talchas",
        "timestamp": 1648332774
    },
    {
        "content": "<p>that's impossible to tell in many cases though</p>",
        "id": 276748748,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332794
    },
    {
        "content": "<p>as it is a promise about <em>all future uses</em> of this memory</p>",
        "id": 276748750,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332803
    },
    {
        "content": "<p>because if the compiler can't prove that, in general it already can't prove that it wasn't stored into a global or something</p>",
        "id": 276748754,
        "sender_full_name": "Talchas",
        "timestamp": 1648332807
    },
    {
        "content": "<p>and thus must consider it escaped anyways</p>",
        "id": 276748757,
        "sender_full_name": "Talchas",
        "timestamp": 1648332818
    },
    {
        "content": "<p>not with <code>restrict</code>/SB</p>",
        "id": 276748758,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332824
    },
    {
        "content": "<p>so that leads me to \"we should forbid ptr-to-int transmutes\" (pointers must not be loaded at integer type) as the only way forward that I currently see here</p>",
        "id": 276748845,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332944
    },
    {
        "content": "<p>aka \"the validity invariant for integers says that there is no provenance\"</p>",
        "id": 276748896,
        "sender_full_name": "RalfJ",
        "timestamp": 1648332981
    },
    {
        "content": "<p>with restrict I can't see how to derive that offhand, but with SB I can certainly believe that, hmm</p>",
        "id": 276748918,
        "sender_full_name": "Talchas",
        "timestamp": 1648333038
    },
    {
        "content": "<p>(because restrict doesn't invalidate any pointers outside of its block)</p>",
        "id": 276748922,
        "sender_full_name": "Talchas",
        "timestamp": 1648333063
    },
    {
        "content": "<p>0.o it is very to interesting to see your suggesting in that issue that \"ptrtoint\" is clearly the \"evil\" one</p>",
        "id": 276748972,
        "sender_full_name": "Gankra",
        "timestamp": 1648333135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748896\">said</a>:</p>\n<blockquote>\n<p>aka \"the validity invariant for integers says that there is no provenance\"</p>\n</blockquote>\n<p>Agreed, but how does this imply that the transmute has to be UB? Why can't the place to value conversion at the integer type lose the provenance?</p>",
        "id": 276749046,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333284
    },
    {
        "content": "<p>There are already examples under SB of place to value conversions \"mutating\" the value, ie of <code>x = x;</code> not being a no-op</p>",
        "id": 276749091,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333324
    },
    {
        "content": "<p>transmute is defined such that it does not alter the bytes returned from the function.</p>",
        "id": 276749096,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648333339
    },
    {
        "content": "<p>I cannot imagine that that is true. Transmuting to a type with padding should definitely deinitialize it</p>",
        "id": 276749103,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333373
    },
    {
        "content": "<p>(also, functions don't return bytes but values, at least this is what I believe the intent is)</p>",
        "id": 276749114,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333399
    },
    {
        "content": "<p>I'd say that transmuting to the type wouldn't but the assignment (resulting Copy) would, since it copies <code>Pad</code>.</p>",
        "id": 276749126,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648333441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749114\">said</a>:</p>\n<blockquote>\n<p>(also, functions don't return bytes but values, at least this is what I believe the intent is)</p>\n</blockquote>\n<p>But it specifically returns a valid value that corresponds to the bytes of the value given in it's parameters, if such a value exists, or the behaviour is undefined otherwise.</p>",
        "id": 276749191,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648333524
    },
    {
        "content": "<p>I mean also transmute being defined that way is entirely an artifact of provenance not existing</p>",
        "id": 276749197,
        "sender_full_name": "Talchas",
        "timestamp": 1648333538
    },
    {
        "content": "<p>and definitely can be defined however rust/C wants when provenance is being formalized</p>",
        "id": 276749244,
        "sender_full_name": "Talchas",
        "timestamp": 1648333567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748972\">said</a>:</p>\n<blockquote>\n<p>0.o it is very to interesting to see your suggesting in that issue that \"ptrtoint\" is clearly the \"evil\" one</p>\n</blockquote>\n<p>well, it is evil if you want inttoptr to work. if not, we are fine.</p>",
        "id": 276749251,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333605
    },
    {
        "content": "<p>and the sort of side effect it is intended to avoid definitely does not include any side effect in <code>ptr as usize</code></p>",
        "id": 276749261,
        "sender_full_name": "Talchas",
        "timestamp": 1648333636
    },
    {
        "content": "<p>So this doesn't make much sense in MIR (or Rust) because neither of those have a notion of assignment with unequal types. Assignment operations occur from a value (in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">this sense</a>) which is the result of the right hand side to a place on the left hand side. There's no way to write MIR/Rust that has the value/place types not match, and so there are no operational semantics attached to such a thing - at least this is how I interpret the current status of things</p>",
        "id": 276749263,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749046\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748896\">said</a>:</p>\n<blockquote>\n<p>aka \"the validity invariant for integers says that there is no provenance\"</p>\n</blockquote>\n<p>Agreed, but how does this imply that the transmute has to be UB? Why can't the place to value conversion at the integer type lose the provenance?</p>\n</blockquote>\n<p>(a) because that means writing the same integer back to memory will actually have changed its value (so there are some optimizations this loses); that's what the example exploits.<br>\n(b) just \"losing provenance\" would otherwise be fine <em>if</em> nobody would expect a later inttoptr cast on that number to work. but if people expect the roundtrip to work (as C programmers typically will), then \"losing provenance\" has to be accompanied by \"marking that provenance as exposed\", so your load/transmute has to have a side-effect, and that is exactly the problem my proposed rule is supposed to fix.</p>",
        "id": 276749325,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333733
    },
    {
        "content": "<p>note also that Ralf's example literally doesn't actually <code>transmute</code> anything in terms of the actual transmute function, it's just making two pointers to that same value, writing a usize into one and reading a *mut out of the other</p>",
        "id": 276749331,
        "sender_full_name": "Gankra",
        "timestamp": 1648333751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749103\">said</a>:</p>\n<blockquote>\n<p>I cannot imagine that that is true. Transmuting to a type with padding should definitely deinitialize it</p>\n</blockquote>\n<p>that has nothing to do with transmute and everything to do with the target type</p>",
        "id": 276749335,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333762
    },
    {
        "content": "<p><em>any</em> <code>=</code> on a type with padding de-inits that padding</p>",
        "id": 276749339,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749339\">said</a>:</p>\n<blockquote>\n<p><em>any</em> <code>=</code> on a type with padding de-inits that padding</p>\n</blockquote>\n<p>But is it the <code>=</code> or the place to value conversion? I'd assume it's the latter</p>",
        "id": 276749353,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333794
    },
    {
        "content": "<p>I'd assume it to be the former.</p>",
        "id": 276749402,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648333810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749331\">said</a>:</p>\n<blockquote>\n<p>note also that Ralf's example literally doesn't actually <code>transmute</code> anything in terms of the actual transmute function, it's just making two pointers to that same value, writing a usize into one and reading a *mut out of the other</p>\n</blockquote>\n<p>right I am as usual using \"transmute\" as a term encompassing</p>\n<ul>\n<li><code>std::mem::transmute</code></li>\n<li>union-based type punning</li>\n<li>type punning by doing pointer casts and accessing the same data at different types</li>\n</ul>\n<p>I firmly hold that those should all be equivalent.</p>",
        "id": 276749413,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333826
    },
    {
        "content": "<p>After all, you can create and assign values of a type with padding w/o ever touching p2v.</p>",
        "id": 276749417,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648333835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749339\">said</a>:</p>\n<blockquote>\n<p><em>any</em> <code>=</code> on a type with padding de-inits that padding</p>\n</blockquote>\n<p>But is it the <code>=</code> or the place to value conversion? I'd assume it's the latter</p>\n</blockquote>\n<p>Eh, ok, I take that back</p>",
        "id": 276749440,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749339\">said</a>:</p>\n<blockquote>\n<p><em>any</em> <code>=</code> on a type with padding de-inits that padding</p>\n</blockquote>\n<p>But is it the <code>=</code> or the place to value conversion? I'd assume it's the latter</p>\n</blockquote>\n<p>well, the place-to-value covnersion \"forgets\" the padding and the value-to-place store then puts <code>uninit</code> into the padding at the target place</p>",
        "id": 276749444,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333904
    },
    {
        "content": "<p>Yeah, that's what I mean</p>",
        "id": 276749446,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333913
    },
    {
        "content": "<p>so, it's not clearly one of them, but a side-effect of the composed action of <code>=</code></p>",
        "id": 276749447,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749402\">said</a>:</p>\n<blockquote>\n<p>I'd assume it to be the former.</p>\n</blockquote>\n<p>Or, possibly both.</p>",
        "id": 276749449,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648333915
    },
    {
        "content": "<p>So this already means that <code>x = x;</code> is not a no-op in Rust. I don't see why we should require that of integers</p>",
        "id": 276749496,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333949
    },
    {
        "content": "<p>a \"value\" doesnt even have such a thing as padding. \"padding\" is what we call the bytes in a low-level representation that do not correspond to any part of the \"value\". (that's how I think about it anyway.)</p>",
        "id": 276749503,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749496\">said</a>:</p>\n<blockquote>\n<p>So this already means that <code>x = x;</code> is not a no-op in Rust. I don't see why we should require that of integers</p>\n</blockquote>\n<p>it's not a NOP <em>but it is a pure operation</em></p>",
        "id": 276749510,
        "sender_full_name": "RalfJ",
        "timestamp": 1648333975
    },
    {
        "content": "<p>So, I also have an example of a place to value conversion (and hence an <code>x = x;</code> assignment) not being a pure operation. Let me dig it up</p>",
        "id": 276749521,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648333998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749503\">said</a>:</p>\n<blockquote>\n<p>a \"value\" doesnt even have such a thing as padding. \"padding\" is what we call the bytes in a low-level representation that do not correspond to any part of the \"value\". (that's how I think about it anyway.)</p>\n</blockquote>\n<p>This is also how C++ defines it. Padding bytes (and bits) are parts of the object-representation that do not participate in the value-representation.</p>",
        "id": 276749533,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648334024
    },
    {
        "content": "<p>so, yes we could say that when turning \"a list of bytes that have provenance\" into \"value of integer type\" (a \"type load\" as I call it, e.g. at place-to-val conversion), that then we just ignore provenance. that would still be a pure operation.<br>\nbut then if you cast that int back to a ptr you have UB.</p>",
        "id": 276749536,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749521\">said</a>:</p>\n<blockquote>\n<p>So, I also have an example of a place to value conversion (and hence an <code>x = x;</code> assignment) not being a pure operation. Let me dig it up</p>\n</blockquote>\n<p>that sounds wrong.^^ there is the clear design goal that the compiler is allowed to optimize away <code>x=x</code>.<br>\nit is not a NOP but it is allowed to be a NOP.</p>",
        "id": 276749595,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334075
    },
    {
        "content": "<p>or, formally speaking: <code>x=x</code> is not (contextually) equivalent to a NOP, but it is (contextually) refined by a NOP, and the latter is really what we care about for optimizations</p>",
        "id": 276749613,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334109
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">r</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">rp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// `r`s memory now contains a `&amp;mut x`.</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// The `r as *const i32` is lowered to `&amp;raw *r` in MIR</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276749623,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334142
    },
    {
        "content": "<p>So this is indeed refined by a nop, but it is not equivalent to one and has \"side-effects\" in the sense of \"touches other state\"</p>",
        "id": 276749627,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334161
    },
    {
        "content": "<p>(Here my point is that loading the memory in <code>r</code> at type <code>&amp;i32</code> does things to the borrow stack of a value far away)</p>",
        "id": 276749670,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334180
    },
    {
        "content": "<p>Yeah, that wouldn't be pure.</p>",
        "id": 276749684,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648334215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749670\">said</a>:</p>\n<blockquote>\n<p>(Here my point is that loading the memory in <code>r</code> at type <code>&amp;i32</code> does things to the borrow stack of a value far away)</p>\n</blockquote>\n<p>oh yes but that is not at all an <code>x=x</code>. look at its MIR (the one Miri actually runs). there is an explicit reborrow there.</p>",
        "id": 276749695,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749627\">said</a>:</p>\n<blockquote>\n<p>So this is indeed refined by a nop, but it is not equivalent to one and has \"side-effects\" in the sense of \"touches other state\"</p>\n</blockquote>\n<p>and having side-effects means it is <em>not</em> refined by a NOP</p>",
        "id": 276749700,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334242
    },
    {
        "content": "<p>since replacing it by a NOP would change program behavior (by removing side-effects)</p>",
        "id": 276749707,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334256
    },
    {
        "content": "<p>If you did <code>r = r;</code>that's definately not a nop.</p>",
        "id": 276749708,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648334264
    },
    {
        "content": "<p>Ah, ok fair</p>",
        "id": 276749710,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334268
    },
    {
        "content": "<p>you need to pass <code>-Zmir-emit-retag</code> or so to get the MIR with these explicit operations</p>",
        "id": 276749763,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334303
    },
    {
        "content": "<p>some day we'll have to make that the default so that MIR optimizations don't go wrong...</p>",
        "id": 276749767,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749695\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276749670\">said</a>:</p>\n<blockquote>\n<p>(Here my point is that loading the memory in <code>r</code> at type <code>&amp;i32</code> does things to the borrow stack of a value far away)</p>\n</blockquote>\n<p>oh yes but that is not at all an <code>x=x</code>. look at its MIR (the one Miri actually runs). there is an explicit reborrow there.</p>\n</blockquote>\n<p>So, maybe we have different approaches to this, but I would greatly prefer if Miri interprets MIR that <em>doesn't</em> include retags. It's of course fine if CTFE/miri inserts them as a part of it's pipeline, but I don't think that the retags should exist at optimization time</p>",
        "id": 276749779,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334352
    },
    {
        "content": "<p>so yeah terminology is hard.^^ the <code>=</code> I was talking about al along is MIR assignment. a <code>=</code> in surface Rust might lower down to a MIR assignment <em>and some extra stuff</em> so that's a different operation.<br>\n(as I keep saying, language design is different for surface languages and IRs.)</p>",
        "id": 276749792,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334385
    },
    {
        "content": "<p>And because of that I am intentionally trying to look at the semantics of the MIR without retags emitted</p>",
        "id": 276749837,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334403
    },
    {
        "content": "<p>those are the wrong semantics though</p>",
        "id": 276749841,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334413
    },
    {
        "content": "<p>like, <code>Retag</code> is literally what makes the aliasing model work</p>",
        "id": 276749843,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334420
    },
    {
        "content": "<p>or, Rust/MIR without retags is Rust without any aliasing guarantees on its references</p>",
        "id": 276749848,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334430
    },
    {
        "content": "<p>Is it not possible to make the retag operations semantically a part of place to value (or back) conversions?</p>",
        "id": 276749868,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334468
    },
    {
        "content": "<p>it's possible but bad design IMO</p>",
        "id": 276749877,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334478
    },
    {
        "content": "<p>with IRs it is usually better to have instructions that do exactly one thing, and not have \"mega instructions\" that do a bunch of a priori unrelated tasks</p>",
        "id": 276749946,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334555
    },
    {
        "content": "<p>Hm, so this would mean that for <code>x: &amp;mut T</code> in MIR, an MIR opt could see a <code>x = move x</code> and then remove the retag statement that (normally) follows such an assignment to introduce more DB which then justifies its optimization?</p>",
        "id": 276749967,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334598
    },
    {
        "content": "<p>if it deems that useful, yes. (that would then also have to affect whether <code>noalias</code> is passed to LLVM.)</p>",
        "id": 276749973,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334628
    },
    {
        "content": "<p>basically, <code>Retag</code> \"compiles to\" <code>noalias</code> in LLVM</p>",
        "id": 276750017,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334645
    },
    {
        "content": "<p>but you are right that we could possibly make <code>retag</code> part of the action \"convert value into byte representation when storing it into place or passing it to a function\". this seems like a design discussion worth having at some point.<br>\nI dont think this is a good idea but I am also not implementing MIR optimizations.^^</p>",
        "id": 276750050,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334740
    },
    {
        "content": "<p>Actually, the retag statements don't justify it either as far as I can tell right now. The interesting MIR is here:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">_12</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">_1</span><span class=\"p\">);</span><span class=\"w\">          </span><span class=\"c1\">// scope 3 at test.rs:9:13: 9:14</span>\n<span class=\"w\">        </span><span class=\"n\">Retag</span><span class=\"p\">([</span><span class=\"n\">raw</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">_12</span><span class=\"p\">);</span><span class=\"w\">                </span><span class=\"c1\">// scope 3 at test.rs:9:13: 9:14</span>\n</code></pre></div>\n<p>(via <code>rustc +stage1 -Zmir-emit-retag=yes --emit mir --crate-type lib test.rs</code>)</p>",
        "id": 276750118,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334833
    },
    {
        "content": "<p>the function passing thing is a bit tricky since it is crucial for optimizations that the <em>callee</em> does the retag, but it is usually the <em>caller</em> that writes the arguments into a place.</p>",
        "id": 276750119,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> not sure what is (not) justified here?</p>",
        "id": 276750136,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334871
    },
    {
        "content": "<p><code>Retag</code>ing for <code>[raw]</code> would not cause UB if the write provenance was still preserved at that point, no?</p>",
        "id": 276750139,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334879
    },
    {
        "content": "<p>(or am I misunderstanding retag statements?)</p>",
        "id": 276750177,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334889
    },
    {
        "content": "<p><code>Retag(raw)</code> is basically the ptr-to-int \"broadcast\" operation</p>",
        "id": 276750199,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334939
    },
    {
        "content": "<p>Like, if the load out of <code>_1</code> preserved the write provenance of the pointer, it would be an SRW that then gets retagged as <code>[raw]</code> and so remains an SRW is my interpretation</p>",
        "id": 276750204,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648334946
    },
    {
        "content": "<p>I dont understand the goal of your example. which optimization do you claim is (not) correct on it?</p>",
        "id": 276750208,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334961
    },
    {
        "content": "<p>god Ralf's examples have made me More mad at inttoptr, somehow</p>",
        "id": 276750211,
        "sender_full_name": "Gankra",
        "timestamp": 1648334968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276750211\">said</a>:</p>\n<blockquote>\n<p>god Ralf's examples have made me More mad at inttoptr, somehow</p>\n</blockquote>\n<p>wow I am impressed that that is possible. and I feel quite honored. :D</p>",
        "id": 276750215,
        "sender_full_name": "RalfJ",
        "timestamp": 1648334985
    },
    {
        "content": "<p>I'm not claiming that any optimization is incorrect, I'm trying to understand how MIRI justifies reporting UB (it does) if the provenance does not change on the load at type <code>&amp;T</code></p>",
        "id": 276750248,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335003
    },
    {
        "content": "<p>I had actually forgotten (if I ever knew) the precise things the breaks under pointer provenance being ~vibes~ and tbh was mostly remotivating myself off of the fact that miri and CHERI both reify it and it sucks shit that the reification doesn't work</p>",
        "id": 276750275,
        "sender_full_name": "Gankra",
        "timestamp": 1648335061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276750248\">said</a>:</p>\n<blockquote>\n<p>I'm not claiming that any optimization is incorrect, I'm trying to understand how MIRI justifies reporting UB (it does) if the provenance does not change on the load at type <code>&amp;T</code></p>\n</blockquote>\n<p>there isnt even a load at type &amp;T here...?</p>",
        "id": 276750286,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335071
    },
    {
        "content": "<p>The load of <code>_1</code> that has to occur in order to dereference its value</p>",
        "id": 276750297,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335114
    },
    {
        "content": "<p>miri reports UB because you are writing using a pointer that has a tag whose associated permission is ReadOnly</p>",
        "id": 276750311,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335122
    },
    {
        "content": "<p><em>all</em> tags on the memory <code>r</code> points to have that permission so whether or not provenane ever changes doesnt even matter for this example</p>",
        "id": 276750346,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335144
    },
    {
        "content": "<p>Or does <code>*_1</code> not perform a place to value conversion of <code>_1</code> at its type</p>",
        "id": 276750348,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335147
    },
    {
        "content": "<p><code>&amp;raw const (*_1)</code> never loads _1, there is no place-to-val conversion here</p>",
        "id": 276750354,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335167
    },
    {
        "content": "<p>So how does dereferencing work?</p>",
        "id": 276750364,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335195
    },
    {
        "content": "<p>it constructs a place</p>",
        "id": 276750367,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335201
    },
    {
        "content": "<p>and <code>&amp;</code> turns a place into a value (namely a pointer pointing to the memory denoted by the place)</p>",
        "id": 276750381,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276750275\">said</a>:</p>\n<blockquote>\n<p>I had actually forgotten (if I ever knew) the precise things the breaks under pointer provenance being ~vibes~ and tbh was mostly remotivating myself off of the fact that miri and CHERI both reify it and it sucks shit that the reification doesn't work</p>\n</blockquote>\n<p>oh I see. well at least for Miri that is all exactly the same reason. ;)</p>",
        "id": 276750439,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335298
    },
    {
        "content": "<p>So, a place is not</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">SimplePlace</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">memory</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// other stuff</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Place</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Direct</span><span class=\"p\">(</span><span class=\"n\">SimplePlace</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Indirect</span><span class=\"p\">(</span><span class=\"n\">Place</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// Dereferencing constructs this</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276750447,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335312
    },
    {
        "content": "<p>no a place is basically</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Place</span><span class=\"p\">(</span><span class=\"n\">Pointer</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276750502,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335388
    },
    {
        "content": "<p>(it also has a type ofc)</p>",
        "id": 276750510,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335399
    },
    {
        "content": "<p>basically, look at Miri's <code>MemPlace</code>, that's what a place is</p>",
        "id": 276750517,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335421
    },
    {
        "content": "<p>Miri's <code>Place</code> exists just as an optimization to make the interpreter faster, it doesnt exist in the semantics</p>",
        "id": 276750525,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335440
    },
    {
        "content": "<p>What is <code>pointer</code> though? Is it the memory address, ie a <code>usize</code> (ish)?</p>",
        "id": 276750526,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335440
    },
    {
        "content": "<p>your life is better if you can treat <code>Pointer</code> as an opaque thing that you dont know the internals of ;)</p>",
        "id": 276750535,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335463
    },
    {
        "content": "<p>but basically it's a pair of an address and a provenance</p>",
        "id": 276750541,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335473
    },
    {
        "content": "<p>Well, right, but this seems to justify my interpretation</p>",
        "id": 276750543,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335479
    },
    {
        "content": "<p>In order to compute the pointer to put into the place for <code>*_1</code>, we need to load the data at <code>_1</code></p>",
        "id": 276750584,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335499
    },
    {
        "content": "<p>I don't think that place contains a pointer, but they're one and the same.</p>",
        "id": 276750593,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648335520
    },
    {
        "content": "<p>we are talking about <code>&amp;raw const (*_1)</code> right?</p>",
        "id": 276750596,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335524
    },
    {
        "content": "<p>there is no pointer put into the place <code>*_1</code> here</p>",
        "id": 276750598,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276750596\">said</a>:</p>\n<blockquote>\n<p>we are talking about <code>&amp;raw const (*_1)</code> right?</p>\n</blockquote>\n<p>My impression was that it shouldn't matter and these things compose</p>",
        "id": 276750606,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335546
    },
    {
        "content": "<p>yes they do</p>",
        "id": 276750610,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335552
    },
    {
        "content": "<p>so <code>_1</code> is a value expression that denotes some kind of pointer</p>",
        "id": 276750617,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335566
    },
    {
        "content": "<p><code>*</code> then creates a <code>Place</code> with that exact pointer</p>",
        "id": 276750623,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335572
    },
    {
        "content": "<p>ie my question is \"does the construction of the place <code>*_1</code> load the memory at <code>_1</code>?\"</p>",
        "id": 276750624,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335573
    },
    {
        "content": "<p>and <code>&amp;</code> turns that back into a value with that exact pointer</p>",
        "id": 276750627,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276750624\">said</a>:</p>\n<blockquote>\n<p>ie my question is \"does the construction of the place <code>*_1</code> load the memory at <code>_1</code>?\"</p>\n</blockquote>\n<p>no, never</p>",
        "id": 276750635,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335587
    },
    {
        "content": "<p>(assuming I understand what you mean by \"memory at\")</p>",
        "id": 276750682,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335604
    },
    {
        "content": "<p>Ehh, I mean \"the memory of <code>_1</code>\", ie the memory in the local</p>",
        "id": 276750731,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335622
    },
    {
        "content": "<p>ofc actually <code>_1</code> is itself a place and the full syntax for your expression is <code>&amp;raw const (*load(_1))</code></p>",
        "id": 276750742,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335629
    },
    {
        "content": "<p>Not the memory being referred to</p>",
        "id": 276750743,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335629
    },
    {
        "content": "<p>using <code>load</code> as syntax for place-to-val conversion</p>",
        "id": 276750755,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276750742\">said</a>:</p>\n<blockquote>\n<p>ofc actually <code>_1</code> is itself a place and the full syntax for your expression is <code>&amp;raw const (*load(_1))</code></p>\n</blockquote>\n<p>We just spent the last 10 minutes talking past each other then lol</p>",
        "id": 276750776,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335665
    },
    {
        "content": "<p>but that's not really changing anything? sorry I lost track of what the question is</p>",
        "id": 276750780,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335669
    },
    {
        "content": "<p>damn :(</p>",
        "id": 276750784,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335673
    },
    {
        "content": "<p>I mean it loads the bytes that are in the local <code>_1</code></p>",
        "id": 276750785,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648335674
    },
    {
        "content": "<p>okay could you write an example and explicit place2val conversion?</p>",
        "id": 276750791,
        "sender_full_name": "RalfJ",
        "timestamp": 1648335689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748240\">said</a>:</p>\n<blockquote>\n<p>also re: strict aliasing, AFAIK PNVI 'relies' on strict aliasing in the sense that that means they dont have to worry about things like <em>any load at integer type</em> potentially exposing a pointer that is being loaded...</p>\n</blockquote>\n<p>I haven't tested load elimination, but on your example in the issue a long time ago, Cerberus prevents redundant store elimination... Although I'm not sure how many compilers are actually aware of that and wont silently miscompile programs.</p>",
        "id": 276753179,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648338978
    },
    {
        "content": "<p><em>nervous laughter</em></p>",
        "id": 276754302,
        "sender_full_name": "Jubilee",
        "timestamp": 1648340692
    },
    {
        "content": "<p>-fno-strict-aliasing exists so you could see how it behaves if there's a good test that doesn't run also into the cast-based bugs</p>",
        "id": 276754525,
        "sender_full_name": "Talchas",
        "timestamp": 1648341004
    },
    {
        "content": "<p>(and somewhat assuming that they'll actually fix any issues there equivalent to the cast bugs)</p>",
        "id": 276754552,
        "sender_full_name": "Talchas",
        "timestamp": 1648341085
    },
    {
        "content": "<p>the thing is that my miscompilation examples are theoretical</p>",
        "id": 276789465,
        "sender_full_name": "RalfJ",
        "timestamp": 1648389128
    },
    {
        "content": "<p>as in, they chain together a bunch of optimizations that compilers <em>might</em> do -- in the sense that they consider them legal and will do them under certain circumstances</p>",
        "id": 276789469,
        "sender_full_name": "RalfJ",
        "timestamp": 1648389144
    },
    {
        "content": "<p>going from there to <em>actually</em> getting a compiler to do the right sequence of optimizations in the right order is rather tricky</p>",
        "id": 276789495,
        "sender_full_name": "RalfJ",
        "timestamp": 1648389188
    },
    {
        "content": "<p>with some help I managed to do that for the example from my blog post here: <a href=\"https://bugs.llvm.org/show_bug.cgi?id=35229\">https://bugs.llvm.org/show_bug.cgi?id=35229</a><br>\nEDIT: actually that's a slightly different example, where LLVM does GVN on pointers. (the example does it on integers.)</p>",
        "id": 276789513,
        "sender_full_name": "RalfJ",
        "timestamp": 1648389215
    },
    {
        "content": "<p>but I haven't tried it for the more complicated examples involving <code>restrict</code> or type punning</p>",
        "id": 276789573,
        "sender_full_name": "RalfJ",
        "timestamp": 1648389257
    },
    {
        "content": "<p>even without explicit examples of miscompilation, it would be good to have examples of the sort of alias info SB/restrict are supposed to guarantee but which seem /likely/ to be broken by int2ptr/transmute roundtrips (since a lot of the examples are just basic brokenness)</p>",
        "id": 276806617,
        "sender_full_name": "Talchas",
        "timestamp": 1648413499
    },
    {
        "content": "<p>we can ask \"is this optimization sound under that memory model\", but you are asking something else and I have no clue what.^^</p>",
        "id": 276806916,
        "sender_full_name": "RalfJ",
        "timestamp": 1648413944
    },
    {
        "content": "<p>I mean things like \"we want SB to permit the optimization of </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but this breaks if &amp;mut + field doesn't narrow narrow provenance\"<br>\nonly for <code>as usize</code> + <code>as *mut T</code> and pointer-to-pointer/pointer-to-usize casts/transmutes</p>",
        "id": 276808664,
        "sender_full_name": "Talchas",
        "timestamp": 1648416258
    },
    {
        "content": "<p>well <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806</a> (which I referenced above in this thread) is an example for pointer-to-usize transmutes (by means of type-punned loads)</p>",
        "id": 276809336,
        "sender_full_name": "RalfJ",
        "timestamp": 1648417131
    },
    {
        "content": "<p>The point is that that particular example is plausibly fixable as we talked about earlier, because it's simple enough and all available for the compiler to do alias analysis on. You said that the simple fixes around detecting potential aliasing wouldn't work with SB's restrict-like optimizations, and examples of that would be good. (Because even restrict-based examples I've seen for ptrtoint like <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html\">https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html</a> seem bogus - that one is importing knowledge of a ptrtoint cast without importing the alias info that making ptrtoint a side effect is meant to preserve)</p>",
        "id": 276810510,
        "sender_full_name": "Talchas",
        "timestamp": 1648418720
    },
    {
        "content": "<p>I'm sorry I don't know which point you are trying to make. The example demonstrates that when you have \"load followed by store of the same value to the same address\", you cannot eliminate the store. is the \"simple fix\" you refer to to simply not do that optimization? Sure that's always a fix...</p>",
        "id": 276813120,
        "sender_full_name": "RalfJ",
        "timestamp": 1648422869
    },
    {
        "content": "<p>sure we could teach the compiler to detect this particular surrounding pattern and not do the optimization then, but it is impossible to do this soundly. (we <em>could</em> teach the compiler to not do the optimization <em>unless</em> it has more information, of course. that's equivalent to saying \"sure this optimizaton is wrong but there are other correct optimizations\", which is obviously true and so I don't see the point of it.)</p>",
        "id": 276813165,
        "sender_full_name": "RalfJ",
        "timestamp": 1648422956
    },
    {
        "content": "<p>you can always spread this across enough different TUs that the compiler only sees the \"load followed by store of the same value\" and nothing else, and we have to decide if it's legal to remove the store or not. the answer is, if we say that a load implicitly performs a ptr2int cast, then it is not legal to remove the store. note that whether or not ptr2int has a side-effect doesn't even matter here, the argument applies even if we find a side-effect-free way of doing ptr2int.</p>",
        "id": 276813221,
        "sender_full_name": "RalfJ",
        "timestamp": 1648423034
    },
    {
        "content": "<p>the other example related to <code>restrict</code> is in a similar vein. I dont know in which sense you think it is \"bogus\". all these examples demonstrate that certain ways of doing optimizations (including the way LLVM and everyone else currently does it) is \"bogus\", that is literally their entire point.</p>",
        "id": 276813231,
        "sender_full_name": "RalfJ",
        "timestamp": 1648423067
    },
    {
        "content": "<p>if you already agree that ptr2int has a side-effect then sure the examples will not change your mind since you are already a believer. ;) but most of the ecosystem has certainly not accepted this; LLVM <em>will</em> remove ptr2int if their result is unused.</p>",
        "id": 276813504,
        "sender_full_name": "RalfJ",
        "timestamp": 1648423503
    },
    {
        "content": "<p>(and yes I know they have a side-effect in PNVI, but that's a surface language memory model so design constraints are very different. just because they have a side-effect in C doesn't mean they have to have a side-effect in LLVM. for example, integer addition has a potential side-effect in C [UB], but is always pure in LLVM, and that is totally sound.)</p>",
        "id": 276813572,
        "sender_full_name": "RalfJ",
        "timestamp": 1648423590
    },
    {
        "content": "<p>Hmm, I misremembered the llvm-dev example's argument and misread it when I doublechecked it. I thought it was showing additional problems with <code>restrict</code> rather than being an argument about the original ptr2int-as-sideeffect.</p>\n<p>The \"simple\" fix I was referring to the discussion around <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748675\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/276748675</a> - it sounded maybe plausible to me that there are ways under SB that (alias knowledge about) a pointer could escape via int shenanigans but be forbidden from escaping into globals, but I couldn't actually figure one out. This is what I wanted an example of.</p>\n<p>However related to your point about TU splitting and, the UCG/286 example split up as </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// init...</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">storage_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">paddr</span><span class=\"p\">.</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">storage_usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">qaddr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">**</span><span class=\"n\">storage_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">storage_usize</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">storage_usize</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">storage_usize</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">true</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>makes a point that optimization /followed/ by inlining could erase the relevant alias information that might otherwise get around <code>x == y</code> being a lie. I suppose that could somehow be tracked, but it's not obvious how. Requiring inlining to be before those passes seems worse, but maaaybe. (Though it looks like clang/llvm isn't doing this particular store optimization anyways for some reason, but it certainly looks like something that should be permitted in general)</p>",
        "id": 276821936,
        "sender_full_name": "Talchas",
        "timestamp": 1648435892
    },
    {
        "content": "<p>(I suppose a store of <code>paddr</code> to a known int-aliased memory could lose its known provenance, but at best then you need to not erase /that/ cast which has less direct downside but seems ugly; particularly if llvm makes all pointers just being <code>pointer</code>, so you'd need to keep _an_ int access)</p>",
        "id": 276823145,
        "sender_full_name": "Talchas",
        "timestamp": 1648437123
    },
    {
        "content": "<p>Thinking on this later, I'm still not sure that the original sort of solution I mentioned in the issue is a disaster: these dead stores have to be erased to <code>wrote_to(storage_usize)</code>. In particular, pointers still can have <code>if *x == a { *x = a; }</code> be not-a-NOP unless pointer equality is full on UB for overlapping addresses (which is a violation of C2x if C equality is lowered to <code>==</code>, and is certainly a violation of rust PartialEq for the same). So it's a question of if maintaining that sort of metadata instruction is likely to prevent too many optimizations when applied to non-<code>char</code> integers.</p>\n<p>(Yes it would require compiler changes, but given how much pointer equality and ptrtoint equality is broken in other ways where the obvious solution is also to keep metadata/not erase instructions, I don't think that is a valid objection)</p>",
        "id": 276827137,
        "sender_full_name": "Talchas",
        "timestamp": 1648443163
    },
    {
        "content": "<blockquote>\n<p>Requiring inlining to be before those passes seems worse, but maaaybe. (Though it looks like clang/llvm isn't doing this particular store optimization anyways for some reason, but it certainly looks like something that should be permitted in general)</p>\n</blockquote>\n<p>The compiler usually expects to be able to apply passes in any order, and in practice with LTO, you can have a situation where first the compiler runs an optimization pass on just the current translation unit to produce the <code>.o</code> file, then the linker runs another optimization pass on all <code>.o</code> files, including inlining.  I don't think this is viable.</p>",
        "id": 277008596,
        "sender_full_name": "comex",
        "timestamp": 1648562407
    },
    {
        "content": "<blockquote>\n<p>The compiler usually expects to be able to apply passes in any order</p>\n</blockquote>\n<p>lmao</p>",
        "id": 277009207,
        "sender_full_name": "Gankra",
        "timestamp": 1648562656
    },
    {
        "content": "<p>the llvm pass ordering struggle is Real</p>",
        "id": 277009227,
        "sender_full_name": "Gankra",
        "timestamp": 1648562669
    },
    {
        "content": "<p>Oh?  I know that pass ordering is a problem when it comes to generating optimal code - it's easy to miss optimizations - but I haven't heard of it being a problem for correctness.  I suppose there are analysis passes, but those have dependencies tracked explicitly...</p>",
        "id": 277009513,
        "sender_full_name": "comex",
        "timestamp": 1648562791
    },
    {
        "content": "<p>maybe it has gotten Better but my understanding is that in practice <em>MANY</em> passes are completely broken if they don't happen in the right order, and this order is completely unspecified because it's not intentional, but just a tower of poorly-specified cards that happen to work in the configurations people happen to use them in</p>",
        "id": 277010988,
        "sender_full_name": "Gankra",
        "timestamp": 1648563404
    },
    {
        "content": "<p>hrm, interesting.</p>",
        "id": 277011033,
        "sender_full_name": "comex",
        "timestamp": 1648563425
    },
    {
        "content": "<p>so yeah in general \"this pass depends on this other pass\" is extremely normal load-bearing stuff</p>",
        "id": 277011101,
        "sender_full_name": "Gankra",
        "timestamp": 1648563463
    },
    {
        "content": "<p>sad, but normal</p>",
        "id": 277011126,
        "sender_full_name": "Gankra",
        "timestamp": 1648563477
    },
    {
        "content": "<p>Do you have any examples?</p>",
        "id": 277011235,
        "sender_full_name": "comex",
        "timestamp": 1648563524
    },
    {
        "content": "<p>no this is just folklore to me, from compiler devs being sad</p>",
        "id": 277011304,
        "sender_full_name": "Gankra",
        "timestamp": 1648563560
    },
    {
        "content": "<p>Fair enough.</p>",
        "id": 277011314,
        "sender_full_name": "comex",
        "timestamp": 1648563566
    },
    {
        "content": "<blockquote>\n<p>these dead stores have to be erased to <code>wrote_to(storage_usize)</code>.</p>\n</blockquote>\n<p>My mediocre knowledge of LLVM optimizations says this could work.  Keep in mind that many dead stores are not of the form \"load then store same value\", but rather \"store the same value twice\".  For the latter type of dead store, the compiler knows which instruction originally stored the value; instead of adding any \"wrote_to\" instruction, it could move the <code>ptrtoint</code>-<code>inttoptr</code> conversion to happen earlier, before the original store, making the later store truly dead.  This would be less likely to inhibit future optimizations.  Similarly, if the compiler doesn't know which instruction stored the value but knows it must be one of a small list of possibilities (all in the current function), then it could add the conversion to all of them.  </p>\n<p>A major caveat is that <code>inttoptr</code> is defined as reconstituting provenance for something that _has been_ converted to integer, not something that _will be_ converted to integer in the future.  So in general it's not actually valid to move a <code>inttoptr</code> to earlier in the function, since you may be moving it past the <code>ptrtoint</code> that it's grabbing provenance from.  But it would be very useful to be able to move up <code>ptrtoint</code>-<code>inttoptr</code> pairs.  So I think it might make sense to define <code>inttoptr</code> in IR more broadly than it's defined in surface semantics – to say that it potentially pairs with a later <code>ptrtoint</code> rather than just an earlier one, allowing it to be moved up.  Alternately, create a different conversion that does have that broader definition.</p>",
        "id": 277016597,
        "sender_full_name": "comex",
        "timestamp": 1648565540
    },
    {
        "content": "<p>woah, doesn't reading values from the future have out-of-thin-air problems?</p>",
        "id": 277019133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648566501
    },
    {
        "content": "<p>the damage here is limited since it's restricted to runtime-invisible stuff, but I think you could still use it to forge provenance you couldn't possibly have obtained</p>",
        "id": 277019421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648566612
    },
    {
        "content": "<p>Perhaps; I haven't thought about it.  But as long as we're talking about provenance as interpreted in a compiler IR, the worst possible outcome is \"the compiler optimizes as if these accesses could alias even though they really can't\", so the damage really is limited.</p>",
        "id": 277019586,
        "sender_full_name": "comex",
        "timestamp": 1648566675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/277011304\">said</a>:</p>\n<blockquote>\n<p>no this is just folklore to me, from compiler devs being sad</p>\n</blockquote>\n<p>Come on, use the word, you know you want to =)</p>",
        "id": 277036859,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648573776
    },
    {
        "content": "<p>Also something to add. ptr2int2ptr may be problematic for code with a low MSRV. I write some low level 1.54 code. I don't think I have need for any ptr2int/int2ptr shenanigans, but I won't have strict-provenance available if I do.</p>",
        "id": 277225629,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648693452
    },
    {
        "content": "<p>So maybe there should be a documented way to polyfill them?</p>",
        "id": 277227922,
        "sender_full_name": "Nick12",
        "timestamp": 1648695986
    },
    {
        "content": "<p>the top of the tracking issue literally links the stable polyfill that works on like rust 1.10 probably because it just uses wrapping_add</p>",
        "id": 277227955,
        "sender_full_name": "Gankra",
        "timestamp": 1648696048
    },
    {
        "content": "<p>You'll have to dial back its edition, at least</p>",
        "id": 277229147,
        "sender_full_name": "cuviper",
        "timestamp": 1648697529
    },
    {
        "content": "<p>ah sure, forgot 2021 is a thing now</p>",
        "id": 277229183,
        "sender_full_name": "Gankra",
        "timestamp": 1648697610
    },
    {
        "content": "<p>publish 0.2.2 as rust 2015 with literally no changes lol</p>",
        "id": 277229457,
        "sender_full_name": "Gankra",
        "timestamp": 1648697853
    },
    {
        "content": "<p>Nice <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 277229557,
        "sender_full_name": "cuviper",
        "timestamp": 1648697951
    },
    {
        "content": "<p>i have no idea what rust 2018+ changed but i doubt i use it because i am ancient rust ghoul</p>",
        "id": 277229642,
        "sender_full_name": "Gankra",
        "timestamp": 1648698025
    },
    {
        "content": "<p>It should probably be <code>#![no_std]</code></p>",
        "id": 277229744,
        "sender_full_name": "cuviper",
        "timestamp": 1648698193
    },
    {
        "content": "<p><code>const fn</code> will be version-limiting, regardless of edition</p>",
        "id": 277229763,
        "sender_full_name": "cuviper",
        "timestamp": 1648698233
    },
    {
        "content": "<p>And <code>impl Trait</code></p>",
        "id": 277229815,
        "sender_full_name": "cuviper",
        "timestamp": 1648698275
    },
    {
        "content": "<p>I'm sure you'll draw the line somewhere, but I'm just looking for things that haven't been around forever</p>",
        "id": 277229839,
        "sender_full_name": "cuviper",
        "timestamp": 1648698307
    },
    {
        "content": "<p><code>pointer::cast</code> is 1.38</p>",
        "id": 277229930,
        "sender_full_name": "cuviper",
        "timestamp": 1648698435
    },
    {
        "content": "<p>the regex crate's msrv is 1.41, and regex is the standard for conservative msrv. (libc's is 1.13, but that's because libc is silly)</p>",
        "id": 277256572,
        "sender_full_name": "bstrie",
        "timestamp": 1648720187
    },
    {
        "content": "<p>I've recently published a new crate version that still works on 1.34, but that does feel like an outlier. Anything older than Stable Debain's rustc is probably an outlier.</p>",
        "id": 277280915,
        "sender_full_name": "Lokathor",
        "timestamp": 1648733637
    },
    {
        "content": "<p>syn is 1.31</p>",
        "id": 277281434,
        "sender_full_name": "lqd",
        "timestamp": 1648733854
    },
    {
        "content": "<p><code>memoffset</code> is 1.19+ because we dont want to give people any excuse not to use it^^</p>",
        "id": 277347352,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764979
    },
    {
        "content": "<p>For what it's worth, <a href=\"https://packages.debian.org/stable/rust/rustc\">Debian stable rustc</a> is rustc 1.48.</p>",
        "id": 277354210,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648769998
    },
    {
        "content": "<p>Hey so is there a \"wildcard function pointer\" type in Rust?</p>",
        "id": 277375241,
        "sender_full_name": "Jubilee",
        "timestamp": 1648794333
    },
    {
        "content": "<p>It feels like something I should know but it just completely escapes me and I have no idea what I would even a search for.</p>",
        "id": 277375299,
        "sender_full_name": "Jubilee",
        "timestamp": 1648794390
    },
    {
        "content": "<p>seeing as I know that was one of the things that came up a bunch in the PR re: \"Oxford casts\"</p>",
        "id": 277375306,
        "sender_full_name": "Jubilee",
        "timestamp": 1648794406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/277375241\">said</a>:</p>\n<blockquote>\n<p>Hey so is there a \"wildcard function pointer\" type in Rust?</p>\n</blockquote>\n<p>No, adding it is one of the A-strict-provenance issues I think</p>",
        "id": 277387603,
        "sender_full_name": "riking",
        "timestamp": 1648803520
    },
    {
        "content": "<p>Ah okay, thought so but wanted to make sure. Designer hat time!</p>",
        "id": 277387764,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803616
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/Gankra/sptr/pull/2\">sptr#2</a> to support MSRV 1.31 -- going any further will have to deal with conditional <code>const fn</code></p>",
        "id": 277458515,
        "sender_full_name": "cuviper",
        "timestamp": 1648836796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr/near/277011304\">said</a>:</p>\n<blockquote>\n<p>no this is just folklore to me, from compiler devs being sad</p>\n</blockquote>\n<p>In theory the passes _should_ be independent. In practice ordering matters first and foremost because some passes convert the IR to a shape that the next one expects to work with – we don't want to have each pass re-do all the preparatory work if the previous one can do it for free. For MIR due to its phased nature misordered passes will cause significant issues because pass might not be expecting to get e.g. pre-drop-elaboration IR and just ICE or do the wrong thing with e.g. <code>drop</code>s.</p>",
        "id": 277540434,
        "sender_full_name": "nagisa",
        "timestamp": 1648919215
    }
]