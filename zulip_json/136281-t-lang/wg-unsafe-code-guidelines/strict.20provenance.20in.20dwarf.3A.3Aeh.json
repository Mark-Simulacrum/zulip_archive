[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> wait you ~never need <code>union { *u8, usize }</code>, you can just do what CHERI <code>uintptr_t</code> does and switch code to pointers en-masse, use <code>wrapping_offset</code> for addition, <code>ptr::invalid</code> for injecting a raw integer, and <code>.addr()</code> for extracting a raw integer back out, heh</p>\n<p>(I <em>really</em> wish we had at least one Morello board between the two of us, so we can check actual in-practice behavior - although... they do have a working <code>qemu</code>, I just don't have a beefy enough machine atm to attempt using something like that for porting Rust)</p>",
        "id": 276196625,
        "sender_full_name": "eddyb",
        "timestamp": 1647959355
    },
    {
        "content": "<p>Pointers encoded as DW_EH_PE_absptr are directly included as bytes without ULEB128 encoding.</p>",
        "id": 276196661,
        "sender_full_name": "bjorn3",
        "timestamp": 1647959370
    },
    {
        "content": "<p>NB symbolic probably has its own implementations of these formats for dump_syms</p>",
        "id": 276196689,
        "sender_full_name": "Gankra",
        "timestamp": 1647959381
    },
    {
        "content": "<p>yeah <code>DW_EH_PE_absptr</code> is like the one case where I would maybe expect a real pointer and not just some kind of address/offset</p>",
        "id": 276196792,
        "sender_full_name": "eddyb",
        "timestamp": 1647959411
    },
    {
        "content": "<p>(and <code>DW_EH_PE_aligned</code>)</p>",
        "id": 276196812,
        "sender_full_name": "eddyb",
        "timestamp": 1647959424
    },
    {
        "content": "<p>Re DW_EH_PE_{textrel,datarel} the current code already takes two functions to get from encoded pointer to actual pointer. These can use a capability covering the entire .text/.data sections and derive the new pointer.</p>",
        "id": 276197173,
        "sender_full_name": "bjorn3",
        "timestamp": 1647959569
    },
    {
        "content": "<p>basically what I'm saying (for the more serious suggestion, not the \"put everything in a pointer\") is:</p>\n<ol>\n<li><a href=\"https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L161-L169\">https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L161-L169</a> should be handled by a separate integer-focused function that returns <code>usize</code>/<code>isize</code></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L172-L185\">https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L172-L185</a> should be nested within that \"I just read an integer offset\" case, and offset their respective base pointers</li>\n<li><code>DW_EH_PE_aligned</code>/<code>DW_EH_PE_absptr</code>/<code>DW_EH_PE_indirect</code> should all read a whole pointer</li>\n</ol>",
        "id": 276197290,
        "sender_full_name": "eddyb",
        "timestamp": 1647959626
    },
    {
        "content": "<p>by calling the 1. function directly you can bypass something being mistreated as a pointer when it's an offset (like the call site table fields)<br>\nthen 2. handles all the \"derived capability\" cases<br>\nand 3. deals with \"this is already a pointer\" without having to take an address and make a pointer out of it</p>",
        "id": 276197515,
        "sender_full_name": "eddyb",
        "timestamp": 1647959723
    },
    {
        "content": "<p>now someone has to rewrite that code and get it through review</p>",
        "id": 276197557,
        "sender_full_name": "eddyb",
        "timestamp": 1647959746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276197173\">said</a>:</p>\n<blockquote>\n<p>Re DW_EH_PE_{textrel,datarel} the current code already takes two functions to get from encoded pointer to actual pointer. These can use a capability covering the entire .text/.data sections and derive the new pointer.</p>\n</blockquote>\n<p>yupp. I was telling <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> earlier that those functions should be changed from <code>-&gt; usize</code> to <code>-&gt; *const u8</code></p>",
        "id": 276197659,
        "sender_full_name": "eddyb",
        "timestamp": 1647959772
    },
    {
        "content": "<p>every <code>usize</code> here basically <a href=\"https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L38-L50\">https://github.com/rust-lang/rust/blob/3ea44938e21f0de8ae7d4f6399a8a30f97867c70/library/panic_unwind/src/dwarf/eh.rs#L38-L50</a></p>",
        "id": 276197700,
        "sender_full_name": "eddyb",
        "timestamp": 1647959789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20in.20dwarf.3A.3Aeh/near/276196625\">said</a>:</p>\n<blockquote>\n<p>(I <em>really</em> wish we had at least one Morello board between the two of us, so we can check actual in-practice behavior - although... they do have a working <code>qemu</code>, I just don't have a beefy enough machine atm to attempt using something like that for porting Rust)</p>\n</blockquote>\n<p>my other regret is not being able to test this kind of code in miri because there's not really any way to compile to something that has this kind of GCC EH data, but which still has miri semantics</p>",
        "id": 276198684,
        "sender_full_name": "eddyb",
        "timestamp": 1647960204
    },
    {
        "content": "<p>closest thing I can think of is some kind of ubsan that doubles your memory usage so it can store miri-like information in the shadow side (but LLVM would have to be cooperating a lot with it, and I'm not sure existing sanitizers are strict enough)</p>",
        "id": 276198826,
        "sender_full_name": "eddyb",
        "timestamp": 1647960273
    },
    {
        "content": "<p>(the existing ubsan itself is very limited to pretty much non-asan like situations sadly <a href=\"https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html\">https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html</a>)</p>",
        "id": 276200861,
        "sender_full_name": "eddyb",
        "timestamp": 1647961010
    },
    {
        "content": "<p><a href=\"https://twitter.com/arichardson___/status/1506427082737340416\">https://twitter.com/arichardson___/status/1506427082737340416</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/arichardson___/status/1506427082737340416\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> Currently our LLVM emits .gcc_except_table targets as capabilities instead of offsets (<a href=\"https://t.co/HaIDj0HvFX\">https://cheri-compiler-explorer.cl.cam.ac.uk/z/n6GhhW</a>). And in some cases libunwind derives provenance from program header capabilities, using dl_iterate_phdrs (RTLD sets them up to span the DSO).</p><span>- Alex Richardson (@arichardson___)</span></div></div>",
        "id": 276315499,
        "sender_full_name": "eddyb",
        "timestamp": 1648032807
    },
    {
        "content": "<p>this was linked elsewhere by <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> but I just want to say that this confirms what I was hoping for (CHERI caps in <code>.gcc_except_table</code>, that the linker and/or dynamic loader accounts for)</p>",
        "id": 276315610,
        "sender_full_name": "eddyb",
        "timestamp": 1648032853
    },
    {
        "content": "<p>Huh, this now makes me think… what happens when the stack is non-linear (<code>stacker</code>)?</p>",
        "id": 276794686,
        "sender_full_name": "nagisa",
        "timestamp": 1648396573
    },
    {
        "content": "<p>it is quite plausible that the two distinct parts of the stack will be on the different sides of the address space and… see the <code>wrapping_offset</code> discussion.</p>",
        "id": 276794693,
        "sender_full_name": "nagisa",
        "timestamp": 1648396616
    },
    {
        "content": "<p>The stack contains a pointer to the previous stack segment. Stacker would just have to make sure that the pointer provenance covers enough of the stack segment.</p>",
        "id": 276794700,
        "sender_full_name": "bjorn3",
        "timestamp": 1648396646
    },
    {
        "content": "<p>It does, yeah.</p>",
        "id": 276794751,
        "sender_full_name": "nagisa",
        "timestamp": 1648396692
    }
]