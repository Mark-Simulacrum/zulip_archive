[
    {
        "content": "<p>Apparently <code>wrapping_offset</code> would in actual practice almost never break on CHERI:<br>\n<a href=\"https://twitter.com/arichardson___/status/1506041671670284295\">https://twitter.com/arichardson___/status/1506041671670284295</a><br>\n<a href=\"https://twitter.com/arichardson___/status/1506042840425635844\">https://twitter.com/arichardson___/status/1506042840425635844</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/arichardson___/status/1506041671670284295\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> <a href=\"https://twitter.com/brooksdavis\">@brooksdavis</a> <a href=\"https://twitter.com/workingjubilee\">@workingjubilee</a> <a href=\"https://twitter.com/MSpondee\">@MSpondee</a> <a href=\"https://twitter.com/clarfonthey\">@clarfonthey</a> I believe the last time we gathered those statistics was running the full FreeBSD testsuite using QEMU to log the out-of-bounds pointers: 155214 were out-of-bounds by more than one byte. 1205 pointed past the end and 81% were at most sizeof(void*) beyond\nthe bounds.</p><span>- Alex Richardson (@arichardson___)</span></div></div><div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/arichardson___/status/1506042840425635844\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> <a href=\"https://twitter.com/brooksdavis\">@brooksdavis</a> <a href=\"https://twitter.com/workingjubilee\">@workingjubilee</a> <a href=\"https://twitter.com/MSpondee\">@MSpondee</a> <a href=\"https://twitter.com/clarfonthey\">@clarfonthey</a> We now have a lot more software running on CheriBSD than back in early 2019 and the QEMU instrumentation still exists so it might be worth running that analysis again with something like e.g. a KDE desktop environment.</p><span>- Alex Richardson (@arichardson___)</span></div></div>",
        "id": 276124777,
        "sender_full_name": "Jubilee",
        "timestamp": 1647903750
    },
    {
        "content": "<p>And reduplicating it over here:</p>\n<blockquote>\n<h3>CheriBSD kernel</h3>\n<p>An extended version of the FreeBSD operating system whose kernel can be<br>\ncompiled either as hybrid-capability or pure-capability code, offering different degrees<br>\nof kernel memory protection. The CheriBSD kernel is also able to host legacy, hybrid-<br>\ncapability, and pure-capability userspace environments. The pure-capability process en-<br>\nvironment is known as CheriABI, and is a new OS ABI based on ubiquitous userspace use<br>\nof architectural capabilities. CheriBSD is also able to offer optional temporal memory<br>\nsafety for (non-stack) allocations in pure-capability userspace applications. In addition,<br>\nCheriBSD provides a libcheri intra-process compartmentalization framework, which<br>\nallows library-like components to operate in compartments within a larger application<br>\nprocess.</p>\n<h3>CheriBSD hybrid userspace</h3>\n<p>An extended version of the FreeBSD userspace that is mini-<br>\nmally modified to support hybrid-capability code execution, including modest additions<br>\nto the C runtime (CRT) and system libraries (including libc).</p>\n<h3>CheriBSD CheriABI userspace</h3>\n<p>An extended version of the FreeBSD userspace that supports<br>\npure-capability execution, with modest further extensions.</p>\n<h3>CheriBSD applications</h3>\n<p>A set of extended applications able to operate in the CheriABI pro-<br>\ncess environment, including integrated FreeBSD programs such as OpenSSH, and also<br>\nthird-party applications such as Apple’s WebKit and the PostgreSQL database. These all<br>\noperate with full spatial, referential, and temporal memory safety.</p>\n</blockquote>",
        "id": 276127985,
        "sender_full_name": "Jubilee",
        "timestamp": 1647906189
    },
    {
        "content": "<p>So the idea that CHERI fundamentally is incompatible with real practices in existing software and thus provides a significant barrier to mental models or use is... questionable at best. It is, yes, annoying that we have to roll back a line of documentation, but the documentation was incorrect and probably incorrect even according to the LLVM semantics we were compiling to, not just CHERI. As mentioned here:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276110058\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109846\">said</a>:</p>\n<blockquote>\n<p>so functionally, the problem with <code>wrapping_offset</code> is that, according to LLVM semantics, it creates a possibly-invalid pointer the moment we touch it, so we probably were wrong to say that it's a no-op to put it back in place.</p>\n</blockquote>\n<p>yeah I think this is the crux of it. calling it <code>wrapping_</code> suggests modular arithmetic which... I'm not sure LLVM <em>requires</em>?</p>\n</blockquote>",
        "id": 276129416,
        "sender_full_name": "Jubilee",
        "timestamp": 1647907407
    },
    {
        "content": "<p>oh right I meant to look that up, 'sec</p>",
        "id": 276129791,
        "sender_full_name": "eddyb",
        "timestamp": 1647907729
    },
    {
        "content": "<p>ah it does say two's complement, fair enough <a href=\"https://llvm.org/docs/GetElementPtr.html#what-happens-if-a-gep-computation-overflows\">https://llvm.org/docs/GetElementPtr.html#what-happens-if-a-gep-computation-overflows</a></p>",
        "id": 276129816,
        "sender_full_name": "eddyb",
        "timestamp": 1647907766
    },
    {
        "content": "<p>The tragedy is that pointer provenance is in fact about things like \"pointers have history and remember where they came from\". And so the assumption that <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> is a no-op fails <em>in the presence of pointers having history</em>, which means that we have in fact actually added two entries to the pointer's history. Of course, most of the time, we can ignore these.</p>",
        "id": 276130071,
        "sender_full_name": "Jubilee",
        "timestamp": 1647908017
    },
    {
        "content": "<p>one scenario i wonder about here is the idea of cramming pointers into NaNs- doing that while keeping provenance involves upper bit tagging, which seems like it might hit cheri limits? does anybody happen to know if the stuff they ported includes spidermonkey or webkit or luajit or anything? if so maybe they just use a fallback mode (since idk if cheri even has enough available upper bits like x86-64, which is itself on thin ice here lol)?</p>",
        "id": 276131118,
        "sender_full_name": "rpjohnst",
        "timestamp": 1647909061
    },
    {
        "content": "<p>if there are enough upper bits i imagine some of those could even treat their heap like an arena and keep 64-bit values</p>",
        "id": 276131241,
        "sender_full_name": "rpjohnst",
        "timestamp": 1647909185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276131118\">said</a>:</p>\n<blockquote>\n<p>one scenario i wonder about here is the idea of cramming pointers into NaNs- doing that while keeping provenance involves upper bit tagging, which seems like it might hit cheri limits? does anybody happen to know if the stuff they ported includes spidermonkey or webkit or luajit or anything?</p>\n</blockquote>\n<p>yes.</p>\n<blockquote>\n<h3>CheriBSD applications</h3>\n<p>A set of extended applications able to operate in the CheriABI pro-<br>\ncess environment, including integrated FreeBSD programs such as OpenSSH, and also<br>\nthird-party applications such as <strong>Apple’s WebKit</strong> and the PostgreSQL database. These all<br>\noperate with full spatial, referential, and temporal memory safety.</p>\n</blockquote>",
        "id": 276131325,
        "sender_full_name": "Jubilee",
        "timestamp": 1647909273
    },
    {
        "content": "<p>I have no idea what exactly they do but I suspect it has a lot to do with using arena allocation kinds of strategies and thus retaining a pointer that has the necessary privileges to all the possible locations.</p>",
        "id": 276131661,
        "sender_full_name": "Jubilee",
        "timestamp": 1647909691
    },
    {
        "content": "<p>note that webkit doesn't actually NaN Box</p>",
        "id": 276132127,
        "sender_full_name": "Gankra",
        "timestamp": 1647910234
    },
    {
        "content": "<p>it int-boxes</p>",
        "id": 276132138,
        "sender_full_name": "Gankra",
        "timestamp": 1647910249
    },
    {
        "content": "<p>They have a 31-bit integer type that gets tag-unioned with pointers</p>",
        "id": 276132163,
        "sender_full_name": "Gankra",
        "timestamp": 1647910281
    },
    {
        "content": "<p>aha.</p>",
        "id": 276132393,
        "sender_full_name": "Jubilee",
        "timestamp": 1647910560
    },
    {
        "content": "<p>Ah, I am reminded of another conversation:<br>\nWhen Rust runs on a virtual guest, the virtual host has kind of arbitrary power to force majeure the program even if it emits completely \"normal\" instructions. Indeed, in general, most processors that Rust compiles for can have even \"normal\" load instructions configured to trap by the host.</p>",
        "id": 276133232,
        "sender_full_name": "Jubilee",
        "timestamp": 1647911533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276132127\">said</a>:</p>\n<blockquote>\n<p>note that webkit doesn't actually NaN Box</p>\n</blockquote>\n<p>This seems like they're still nan-boxing: <a href=\"https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/JSCJSValue.h#L394-L454\">https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/JSCJSValue.h#L394-L454</a></p>\n<p>It's not the same scheme as other implementations, but it's still taking advantage of the NaN space to encode a pointer or float in 64 bits both.</p>",
        "id": 276133426,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1647911849
    },
    {
        "content": "<p>oh whoops, sorry specifically <em>chrome</em> doesn't, and my brain mapped webkit to chrome, which is wrong on many levels</p>",
        "id": 276133495,
        "sender_full_name": "Gankra",
        "timestamp": 1647911926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276130071\">said</a>:</p>\n<blockquote>\n<p>The tragedy is that pointer provenance is in fact about things like \"pointers have history and remember where they came from\". And so the assumption that <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> is a no-op fails <em>in the presence of pointers having history</em>, which means that we have in fact actually added two entries to the pointer's history. Of course, most of the time, we can ignore these.</p>\n</blockquote>\n<p>I beg to differ; \"pointers having history\" does not mean \"the pointers history includes all past values that lead here\".<br>\nprovenance is a <em>very specific kind of history</em>, and <code>wrapping_offset</code> is specifically defined to not alter that history. so <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> ought to be a NOP.</p>\n<p>so, I do agree with the concern that this makes CHERI a technically non-conforming implementation. and this is not the same as adding <code>abort()</code> somewhere in the stdlib, since this makes instructions abort <em>that LLVM would be allowed to assume will never abort</em>. silly example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">uwu</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"n\">HUGE</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">HUGE</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr2</span>:\n  <span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>LLVM is allowed to move the <code>*ptr2</code> out of the conditional, since it is the same as <code>ptr</code> and that ptr was already dereferenced. However, in CHERI that transformation would introduce a fault into a non-faulty program (if <code>b</code> is <code>false</code>).</p>\n<p>That said, the worst thing this platform quirk can do is introduce an unexpected fault. In that sense it is a lot less severe than some of our floating point quirks where computations can produce <em>incorrect results</em> on some targets (where \"correct\" = strictly what IEEE says).<br>\nSo the formal methods person inside me cries out loud because the compilation of <code>wrapping_offset</code> is simply <em>incorrect</em> and there is no papering over that, some other part of me just dies a little more inside and adds this to the list of things that make computers broken.</p>\n<p>But indeed if CHERI becomes supported this should definitely be documented.</p>",
        "id": 276731493,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309049
    },
    {
        "content": "<p>I agree this restriction of CHERI is not nice from a conceptual and formal methods point of view, but in most cases it should be possible to fold the multiple offsets into a value that does not go beyond the representable bounds. The example above would only fault without optimization, but obviously we can also come up with one that actually breaks with optimization. I'm not convinced those cases really occur in the real world (based on porting all sorts of software to run on CheriBSD, including PostgreSQL, WebKit, X11, the FreeBSD kernel, etc.)</p>",
        "id": 276735486,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648314318
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"473929\">@Alexander Richardson</span> I have seen speculation that CHERI might be able to handle high-bit-tagging because e.g. ARM has explicit extensions/support for this. Can you confirm/deny?</p>",
        "id": 276735896,
        "sender_full_name": "Gankra",
        "timestamp": 1648314893
    },
    {
        "content": "<p>(semantically high-bit-tagging is just an enormous offset, right?)</p>",
        "id": 276735911,
        "sender_full_name": "Gankra",
        "timestamp": 1648314910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> in arm's Morello implementation the bounds only cover the lower 56 bits so you can still use TBI to put whatever you want in the high bits. On CHERI-RISCV setting the high bits results in an enormous offset that will probably be beyond the representable bounds except for full address space bounds.</p>",
        "id": 276735997,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648315030
    },
    {
        "content": "<p>But TBI-like features might be added in the future, we have to see what happens with the RISC-V pointer masking proposal</p>",
        "id": 276736003,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648315049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"473929\">@Alexander Richardson</span> this probably still <em>wouldn't</em> allow for the cute trick in rustc right now where they actually <em>SHIFT</em> the entire pointer down to tag the \"high\" bits that are actually the low bits (because undoing it vaguely it optimizes better to x64/arm addressing modes)</p>",
        "id": 276736508,
        "sender_full_name": "Gankra",
        "timestamp": 1648315757
    },
    {
        "content": "<p>also it would be interesting to hear if you've taken a crack at Chromium's \"smi\" stuff --  <a href=\"https://v8.dev/blog/pointer-compression\">https://v8.dev/blog/pointer-compression</a></p>",
        "id": 276736755,
        "sender_full_name": "Gankra",
        "timestamp": 1648316066
    },
    {
        "content": "<p>A shift will be converted to setaddr(shift addr, X). However Morello has a SCFLGS instruction to set the high 8 bits while retaining all other bits</p>",
        "id": 276736844,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648316165
    },
    {
        "content": "<p>so rustc doesn't need to fix it's wild code?</p>",
        "id": 276736867,
        "sender_full_name": "Gankra",
        "timestamp": 1648316219
    },
    {
        "content": "<p>Regarding pointer compression, our view is that some language runtimes might want that to reduce memory overhead. In that case you can use 64 or 32 bit pointers and have loads be relative to a JS heap capability. You lose some bounds checking on those pointers but at least they can only corrupt other managed objects but none of the engine internals.</p>",
        "id": 276737031,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648316419
    },
    {
        "content": "<p>I'd have to see the code first, not entirely sure if it's safe</p>",
        "id": 276737054,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648316457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"473929\">@Alexander Richardson</span> in case you mean the rustc code, it's this: <a href=\"https://github.com/rust-lang/rust/pull/75590/files#diff-e60b36ce401c8219a469dbd39e3483bb58d32281e562163dc4232b6cca0240e5R61\">https://github.com/rust-lang/rust/pull/75590/files#diff-e60b36ce401c8219a469dbd39e3483bb58d32281e562163dc4232b6cca0240e5R61</a></p>",
        "id": 276737224,
        "sender_full_name": "Gankra",
        "timestamp": 1648316656
    },
    {
        "content": "<p>Thanks, looking at it briefly it seems like that implementation won't always work with CHERI since the pointer address will go quite far out of bounds. But I am still very new to rust syntax and semantics so I could be mis-parsing some of it. Nevertheless I think it should be easy enough to use the low bits for CHERI enabled architectures instead.</p>",
        "id": 276738268,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648318100
    },
    {
        "content": "<p>Or the high 8 bits for morello without shifting the pointer</p>",
        "id": 276738281,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648318130
    },
    {
        "content": "<p>I am extremely keen to try and get rustc working for CHERI and I will hopefully have a bit more time to play around with it soon.</p>",
        "id": 276738352,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648318247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"473929\">Alexander Richardson</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276736844\">said</a>:</p>\n<blockquote>\n<p>A shift will be converted to setaddr(shift addr, X).</p>\n</blockquote>\n<p>and I assume that invalidates the ptr if it moves too far OOB?</p>",
        "id": 276739787,
        "sender_full_name": "RalfJ",
        "timestamp": 1648320251
    },
    {
        "content": "<p>Yes exactly</p>",
        "id": 276740444,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648321213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276731493\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276130071\">said</a>:</p>\n<blockquote>\n<p>The tragedy is that pointer provenance is in fact about things like \"pointers have history and remember where they came from\". And so the assumption that <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> is a no-op fails <em>in the presence of pointers having history</em>, which means that we have in fact actually added two entries to the pointer's history. Of course, most of the time, we can ignore these.</p>\n</blockquote>\n<p>I beg to differ; \"pointers having history\" does not mean \"the pointers history includes all past values that lead here\".<br>\nprovenance is a <em>very specific kind of history</em>, and <code>wrapping_offset</code> is specifically defined to not alter that history. so <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> ought to be a NOP.</p>\n<p>so, I do agree with the concern that this makes CHERI a technically non-conforming implementation. and this is not the same as adding <code>abort()</code> somewhere in the stdlib, since this makes instructions abort <em>that LLVM would be allowed to assume will never abort</em>. silly example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">uwu</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"n\">HUGE</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">HUGE</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr2</span>:\n  <span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>LLVM is allowed to move the <code>*ptr2</code> out of the conditional, since it is the same as <code>ptr</code> and that ptr was already dereferenced. However, in CHERI that transformation would introduce a fault into a non-faulty program (if <code>b</code> is <code>false</code>).</p>\n<p>That said, the worst thing this platform quirk can do is introduce an unexpected fault. In that sense it is a lot less severe than some of our floating point quirks where computations can produce <em>incorrect results</em> on some targets (where \"correct\" = strictly what IEEE says).<br>\nSo the formal methods person inside me cries out loud because the compilation of <code>wrapping_offset</code> is simply <em>incorrect</em> and there is no papering over that, some other part of me just dies a little more inside and adds this to the list of things that make computers broken.</p>\n<p>But indeed if CHERI becomes supported this should definitely be documented.</p>\n</blockquote>\n<p>IMO I agree with you that it <strong>ought</strong> to be a NOP.<br>\nand only half joking: it sure would be if we guaranteed the optimization.</p>",
        "id": 276741659,
        "sender_full_name": "Jubilee",
        "timestamp": 1648322807
    },
    {
        "content": "<p>I discussed this with Alexander a bit more in private, so to clarify: in terms of <em>addr</em> it is coherent. They made sure that when the compression falls over if corrupts the metadata and not the address. And I believe they guarantee that if you offset back the whole 128-bit pointer will have the same bit representation. Just the validity bit will be corrupt because it's sticky. This is still unfortunate but... It Could Have Been Worse</p>",
        "id": 276743233,
        "sender_full_name": "Gankra",
        "timestamp": 1648325092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> said:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">uwu</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"n\">HUGE</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">HUGE</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr2</span>:\n  <span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I'm not so sure this can actually cause an incorrect fault? (Although I am very unfamiliar with LLVM internals, so this is a shot in the dark.)<br>\nFrom earlier in this thread, it was implied that GEP (without inbounds) makes LLVM no longer \"trust\" a pointer (because it would've gone out of bounds). If this is true, if <code>ptr2</code> has been offset to lose its capability, it's lost its \"trusted\" status in LLVM, thus LLVM won't spuriously dereference it.<br>\nOr IOW, I <em>think</em> the only way LLVM will lift the access is if it proves <code>ptr == ptr2</code>, in which case it will use <code>ptr</code>, not <code>ptr2</code>.<br>\n... Well I suppose it could use <code>ptr2</code>, which would fault, since they're equal, so I'm wrong, but also, it's already proved it can use the less prior work value, so it should be using that one</p>",
        "id": 276743386,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648325297
    },
    {
        "content": "<p>Theoretically (assuming the bit about GEP not inbounds is correct) this is something you could teach LLVM to avoid miscompiling, by only lifting the actually trusted ptr</p>",
        "id": 276743426,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648325361
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132829\">@Christopher Durham</span> that \"trust\" part is just how LLVM currently implements its analyses. It's irrelevant, what we care about is what LLVM (or MIR opts) <em>would be allowed to do</em> under the spec.</p>",
        "id": 276746798,
        "sender_full_name": "RalfJ",
        "timestamp": 1648330191
    },
    {
        "content": "<p>and I'd totally sign off on a MIR pass that replaces <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> by <code>ptr</code></p>",
        "id": 276746844,
        "sender_full_name": "RalfJ",
        "timestamp": 1648330207
    },
    {
        "content": "<p>and it is very possible that LLVM has peephole optimizations like that (but I don't know if it does, and it is not relevant for the argument)</p>",
        "id": 276746859,
        "sender_full_name": "RalfJ",
        "timestamp": 1648330242
    },
    {
        "content": "<p>But that wouldn't cause a trap to occur where it wouldn't otherwise<br>\nIt would only cause code which would trap due to platform limitations to succeed</p>",
        "id": 276746869,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648330253
    },
    {
        "content": "<p>Or am I misunderstanding your concern</p>",
        "id": 276746899,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648330297
    },
    {
        "content": "<p>oh right. I got my polarity wrong.<br>\nthe entire argument also works with a compiler that 'optimizes' <code>ptr</code> into <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> but even I will accept that is a stretch. ;) it's still formally a correct argument though.</p>",
        "id": 276746960,
        "sender_full_name": "RalfJ",
        "timestamp": 1648330331
    },
    {
        "content": "<p>I think the counterargument to that is that the compiler \"just shouldn't do that\" if it's targeting a platform where that could trap</p>",
        "id": 276746997,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648330414
    },
    {
        "content": "<p>But I'm not well versed in formal methods so I'll leave it there</p>",
        "id": 276747001,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648330428
    },
    {
        "content": "<p>i think the only really sketchy thing is if someone was writing platform-specific code and <em>semantically relying</em> on the fact that a really big offset would result in a downstream trap (but still getting the pointer back in bounds before the read), and that we scupper it by optimizing out the transiently bad offset</p>\n<p>that could would be uh.... \"\"\"interesting\"\"\" code to say the least</p>",
        "id": 276747257,
        "sender_full_name": "Gankra",
        "timestamp": 1648330799
    },
    {
        "content": "<p>Oh so what you're saying is that you could codegen bounds checks on arrays in CHERI using wrapping_offset?</p>",
        "id": 276747486,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648331158
    },
    {
        "content": "<p>Or like. A cursed version of the assert about an array length before doing a bunch of access</p>",
        "id": 276747538,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648331215
    },
    {
        "content": "<p>that is clearly just wrong though, like relying on any kind of target machine behavior that is not part of the Abstract Machine</p>",
        "id": 276747706,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276747486\">said</a>:</p>\n<blockquote>\n<p>Oh so what you're saying is that you could codegen bounds checks on arrays in CHERI using wrapping_offset?</p>\n</blockquote>\n<p>that's not even sufficient because e.g. on Morello you have <em>at minimum</em> 1KB of \"it's fine to offset into here\" space. It would have to be some Very Special code to organically trigger this. Maybe just code that tries to write garbage to the pointer and then undo it so it's Not UB.</p>",
        "id": 276747718,
        "sender_full_name": "Gankra",
        "timestamp": 1648331446
    },
    {
        "content": "<p>I am not saying such code is Good but I think it's fair to say folding of wrapping_offset is... Underspecified from Rust's side</p>",
        "id": 276747737,
        "sender_full_name": "Gankra",
        "timestamp": 1648331508
    },
    {
        "content": "<p>no it's pretty clear on the Rust side I think</p>",
        "id": 276747778,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331525
    },
    {
        "content": "<p>it's just incorrectly implemented by the CHERI backend</p>",
        "id": 276747781,
        "sender_full_name": "RalfJ",
        "timestamp": 1648331532
    },
    {
        "content": "<p>yeah i'd accept that argument</p>",
        "id": 276747821,
        "sender_full_name": "Gankra",
        "timestamp": 1648331596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/276114955\">said</a>:</p>\n<blockquote>\n<p>I think, often, \"make that more contained\" gets conflated with \"make that impossible\", and I'm in favor of the former as long as we don't do the latter.</p>\n</blockquote>\n<p>Or breaking existing x86-64 code, right? i.e. don't introduce optimizations on x86-64 that assume strict provenance.</p>",
        "id": 278376072,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649462658
    },
    {
        "content": "<p>(It sounds like the tower of weakenings implies introducing strict provenance alongside a commitment to not breaking existing code on x86-64 via new optimizations that assume strict provenance, which is a place I'd be very happy with.)</p>",
        "id": 278376251,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649462878
    },
    {
        "content": "<p>iiuc existing code won't break but it may take an optimization hit in some cases</p>",
        "id": 278376672,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649463375
    },
    {
        "content": "<p>I dont think we should special case any architecture like x86-64, but I also don't see why</p>",
        "id": 278379975,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F/near/278376672\">said</a>:</p>\n<blockquote>\n<p>iiuc existing code won't break but it may take an optimization hit in some cases</p>\n</blockquote>\n<p>in the sense of, currently some of the optimizations we do are <em>wrong</em> and if we want to fix that then code not using strict provenance will probably get fewer optimizations -- yes</p>",
        "id": 278380035,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467706
    }
]