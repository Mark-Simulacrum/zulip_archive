[
    {
        "content": "<p>Assuming that the <code>*mut T</code> is not used to mutate the value, is it legal to have it point to the same location as a live <code>&amp;T</code> points at?</p>",
        "id": 169252240,
        "sender_full_name": "Lokathor",
        "timestamp": 1561748083
    },
    {
        "content": "<p>in general yes, though it also matters how the ptrs got created</p>",
        "id": 169252296,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748134
    },
    {
        "content": "<p>if you created the <code>*mut T</code> <em>from</em> the <code>&amp;T</code> the certainly yes</p>",
        "id": 169252421,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748214
    },
    {
        "content": "<p>(via <code>my_ref as *const _ as *mut T</code>)</p>",
        "id": 169252434,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748223
    },
    {
        "content": "<p>if it's derived from a parent of <code>&amp;T</code>, then other things you did before might have already killed that pointer</p>",
        "id": 169252470,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748257
    },
    {
        "content": "<p>also anything I say is \"assuming Stacked Borrows\", which is not normative etc ;)</p>",
        "id": 169252484,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748270
    },
    {
        "content": "<p>I think it's the other way around. Ptr all the time, some of the time a &amp;T is made from it temporarily</p>",
        "id": 169252563,
        "sender_full_name": "Lokathor",
        "timestamp": 1561748298
    },
    {
        "content": "<p>you are making the &amp;T directly from the *mut T?</p>",
        "id": 169252626,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748356
    },
    {
        "content": "<p>then your code would even be safe if you replaced <code>*mut T</code> by <code>&amp;mut T</code>, so yes definitely allowed</p>",
        "id": 169252645,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748372
    },
    {
        "content": "<p>uh, i think. They've been updating some old async locking code</p>",
        "id": 169252662,
        "sender_full_name": "Lokathor",
        "timestamp": 1561748391
    },
    {
        "content": "<p>that's like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x_shr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x_shr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169252673,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748398
    },
    {
        "content": "<p>as you can see we can use both interchangabky</p>",
        "id": 169252734,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748410
    },
    {
        "content": "<p>They've been guided to use NonNull&lt;T&gt; instead of a raw pointer and then make either &amp;T or &amp;mut T depending of the type of lock the user takes on the data, which seems right</p>",
        "id": 169252755,
        "sender_full_name": "Lokathor",
        "timestamp": 1561748436
    },
    {
        "content": "<p><code>NonNull</code> is a raw ptr though</p>",
        "id": 169252808,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748484
    },
    {
        "content": "<p>just wrapped</p>",
        "id": 169252809,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748487
    },
    {
        "content": "<p>so that part doesnt change anything</p>",
        "id": 169252823,
        "sender_full_name": "RalfJ",
        "timestamp": 1561748497
    },
    {
        "content": "<p>Yeah that's what I thought :/</p>",
        "id": 169252921,
        "sender_full_name": "Lokathor",
        "timestamp": 1561748543
    },
    {
        "content": "<p>So <code>NonNull</code> has a niche, and <code>*const</code> doesn't allow writing directly to the value, but they're both otherwise effectively the same as <code>*mut</code>. It's just one \"raw pointer\" concept at the heart of all three?</p>",
        "id": 169253364,
        "sender_full_name": "Lokathor",
        "timestamp": 1561748875
    },
    {
        "content": "<p>basically, yes</p>",
        "id": 169253776,
        "sender_full_name": "RalfJ",
        "timestamp": 1561749141
    },
    {
        "content": "<p>with the one small caveat that <code>&amp;mut foo as *const T</code> implicitly goes through <code>&amp;T</code></p>",
        "id": 169253799,
        "sender_full_name": "RalfJ",
        "timestamp": 1561749169
    },
    {
        "content": "<p>so, which type you cast to affects which intermediate reference gets created</p>",
        "id": 169253819,
        "sender_full_name": "RalfJ",
        "timestamp": 1561749192
    },
    {
        "content": "<p>and shared references cannot be written to so this makes a difference</p>",
        "id": 169253838,
        "sender_full_name": "RalfJ",
        "timestamp": 1561749205
    },
    {
        "content": "<p>(that's at least what happens currently, I hope we can change that, but that might be hard)</p>",
        "id": 169253851,
        "sender_full_name": "RalfJ",
        "timestamp": 1561749218
    },
    {
        "content": "<p>that's a bit of a footgun technicality for sure</p>",
        "id": 169257414,
        "sender_full_name": "Lokathor",
        "timestamp": 1561751963
    },
    {
        "content": "<p><a href=\"https://github.com/64/spin-rs/blob/master/src/rw_lock.rs\" target=\"_blank\" title=\"https://github.com/64/spin-rs/blob/master/src/rw_lock.rs\">https://github.com/64/spin-rs/blob/master/src/rw_lock.rs</a> is apparently the full module they're working on, but it's like 700 lines so i don't expect folks to necessarily inspect it all. The crate does seem to get on the order of thousands of downloads a month though, so an eventual careful inspection wouldn't be out of place</p>",
        "id": 169257748,
        "sender_full_name": "Lokathor",
        "timestamp": 1561752151
    },
    {
        "content": "<p>i'm the author, would appreciate if you could take a look. i'm fixing an issue with the variance of the RAII guards atm</p>",
        "id": 169257940,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561752284
    },
    {
        "content": "<p>makes me wonder if you couldnt use <code>parking_lot</code> with a custom parking implementation that just spins, to avoid having to reimplement all these concurrency primitives?</p>",
        "id": 169258096,
        "sender_full_name": "RalfJ",
        "timestamp": 1561752389
    },
    {
        "content": "<p>it's supposed to be no_std, so i'm not sure how easy that would be</p>",
        "id": 169258124,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561752422
    },
    {
        "content": "<p>not sure either^^ sorry didnt mean it was obvious or so</p>",
        "id": 169258146,
        "sender_full_name": "RalfJ",
        "timestamp": 1561752447
    },
    {
        "content": "<p>just thinking of ways to maximize sharing with existing well-reviewed well-tested code :D</p>",
        "id": 169258169,
        "sender_full_name": "RalfJ",
        "timestamp": 1561752474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228354\">@Matt Taylor</span> someone in #black-magic in Rust Community Discord is combing through it for the past day or so. Perhaps you should chat. <a href=\"https://bit.ly/rust-community\" target=\"_blank\" title=\"https://bit.ly/rust-community\">https://bit.ly/rust-community</a></p>",
        "id": 169259050,
        "sender_full_name": "Shnatsel",
        "timestamp": 1561753140
    },
    {
        "content": "<p>i've successfully managed to impersonate myself, in that case</p>",
        "id": 169259087,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561753195
    },
    {
        "content": "<p>[that's me :^)]</p>",
        "id": 169259139,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561753211
    },
    {
        "content": "<p>now <em>that's</em> some effective identity theft</p>",
        "id": 169259824,
        "sender_full_name": "RalfJ",
        "timestamp": 1561753986
    },
    {
        "content": "<p>looks like we're going to need some further clarification: is this UB?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0_</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169269011,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561762346
    },
    {
        "content": "<p>miri flags the last line as UB</p>",
        "id": 169269027,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561762364
    },
    {
        "content": "<p>I believe so, yeah. Imagine there were two threads and the pointer was in one and the reference in another. This would allow for a data race (UB).</p>",
        "id": 169272112,
        "sender_full_name": "nagisa",
        "timestamp": 1561765649
    },
    {
        "content": "<p>note that data race is a result of invoking UB, in this case having mutable reference and \"live\" pointer to the same thing at the same time.</p>",
        "id": 169272169,
        "sender_full_name": "nagisa",
        "timestamp": 1561765712
    },
    {
        "content": "<p>Though that’s just my interpretation and the official answer and exact wording may be different.</p>",
        "id": 169272193,
        "sender_full_name": "nagisa",
        "timestamp": 1561765774
    },
    {
        "content": "<p>I think we are going to need some super simple examples like this one to teach stacked borrows.</p>",
        "id": 169272450,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561766121
    },
    {
        "content": "<p>And we don't only need to teach how it works, but also, why it works this way.</p>",
        "id": 169272457,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561766144
    },
    {
        "content": "<p>This example would be better if it would make a potential pitfall clearer</p>",
        "id": 169272466,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561766162
    },
    {
        "content": "<p>Maybe start with:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">P</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0_</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">thread</span>::<span class=\"n\">spawn</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// data-race</span>\n<span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169272684,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561766420
    },
    {
        "content": "<p>i definitely agree on that, i haven't been doing rust as long as some people here but these things seem are quite subtle and somehow i haven't heard about them before</p>",
        "id": 169272721,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561766477
    },
    {
        "content": "<p>what confuses me is that you could in theory synchronise access and make sure that the accesses on different threads never happen at the same time (eg by using an atomic)</p>",
        "id": 169272744,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561766520
    },
    {
        "content": "<p>you could, but the code doesn't do that</p>",
        "id": 169272788,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561766538
    },
    {
        "content": "<p>but the single threaded variant effectively synchronises them</p>",
        "id": 169272798,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561766554
    },
    {
        "content": "<p>weird the spawn code is ok</p>",
        "id": 169273198,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561767160
    },
    {
        "content": "<p>i didn't think miri could deal with multiple threads yet? (assuming gnzlbg is talking about miri)<br>\n<a href=\"https://github.com/rust-lang/miri/issues/789#issuecomment-505201476\" target=\"_blank\" title=\"https://github.com/rust-lang/miri/issues/789#issuecomment-505201476\">https://github.com/rust-lang/miri/issues/789#issuecomment-505201476</a></p>",
        "id": 169273216,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561767211
    },
    {
        "content": "<p>'for example, Miri currently does not support concurrency' from the readme</p>",
        "id": 169273279,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561767282
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228354\">@Matt Taylor</span> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=12c5c1a90341a63f7c5a4d66520321a1\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=12c5c1a90341a63f7c5a4d66520321a1\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=12c5c1a90341a63f7c5a4d66520321a1</a></p>",
        "id": 169273360,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561767381
    },
    {
        "content": "<p>that fails under miri</p>",
        "id": 169273362,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561767394
    },
    {
        "content": "<p>(I had to adapt the signature of spawn a bit - I guess for an example something like crossbeam::scope would be better)</p>",
        "id": 169273377,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561767449
    },
    {
        "content": "<p>yeah, makes sense given that the original example i posted is UB</p>",
        "id": 169273463,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561767600
    },
    {
        "content": "<p>it doesn't make sense that the 4 line example is UB given that it's clearly all in a single thread</p>",
        "id": 169274803,
        "sender_full_name": "Lokathor",
        "timestamp": 1561769820
    },
    {
        "content": "<p>i mean there's a lot of code that's UB if you suddenly make it multi-threaded, that doesn't make it UB single threaded</p>",
        "id": 169274814,
        "sender_full_name": "Lokathor",
        "timestamp": 1561769853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Rust’s mutable references introduce certain requirements to the code which you are not supposed to violate. One of them is no aliasing. This is what ultimately makes even something like this UB, even if you never really cause a data race to happen. The reason why I bought up the data race is because that is the most trivial way to demonstrate issues manifesting due to violating such kind of UB.</p>",
        "id": 169276057,
        "sender_full_name": "nagisa",
        "timestamp": 1561772124
    },
    {
        "content": "<p>Now, whether just having a mutable reference <em>and</em> an aliased, but \"dead\" (unused) pointer is a problem is another question altogether. However in their case the pointer is live which makes that particular piece of code UB.</p>",
        "id": 169276100,
        "sender_full_name": "nagisa",
        "timestamp": 1561772180
    },
    {
        "content": "<p>this is unfortunate and terrible</p>",
        "id": 169276286,
        "sender_full_name": "Lokathor",
        "timestamp": 1561772619
    },
    {
        "content": "<blockquote>\n<p>looks like we're going to need some further clarification: is this UB?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0_</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>\n\n\n</blockquote>\n<p>Miri flags this as UB because then you create a new mutable reference like <code>_y</code>, you are asserting that it is the only pointing to whatever-you-crated-it-from -- that's <code>v</code> in this case. So anything that already exists that points to <code>v</code> is now invalid.</p>",
        "id": 169289595,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799412
    },
    {
        "content": "<p>it's not really about concurrency at all, in my mind</p>",
        "id": 169289603,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799467
    },
    {
        "content": "<p>the point is that we'd like to optimize assuming that mutable references are unique</p>",
        "id": 169289604,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799478
    },
    {
        "content": "<p>and this code violates (some interpretation of) that uniqueness requirement</p>",
        "id": 169289606,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799487
    },
    {
        "content": "<p>however, also see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133\">https://github.com/rust-lang/unsafe-code-guidelines/issues/133</a>: I am aware that this asserting-uniqueness-on-creation is very aggressive, and maybe there is a way to do better here, i.e. to allow more code without losing (most) optimizations.</p>",
        "id": 169289648,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799542
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <span class=\"user-mention\" data-user-id=\"228354\">@Matt Taylor</span> question while I got your attention, how surprised are you by this code being UB? Any variant of Stacked Borrows that I can imagine makes this UB:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0_</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169289663,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799590
    },
    {
        "content": "<p>now the mutable reference gets used for an <em>access</em>, and at that point definitely it cannot have any aliases</p>",
        "id": 169289665,
        "sender_full_name": "RalfJ",
        "timestamp": 1561799603
    },
    {
        "content": "<p>Retep998 strongly believes that such code is not supposed to be UB because a pointer has no rules beyond C rules, and in C you could do that, and so _even if_ Rust rules apply while a reference exists (which is fair), basically once the reference stops existing things should \"revert\" to just being normal pointer-only rules, including a restoration of the <code>*const</code> pointer.</p>",
        "id": 169297215,
        "sender_full_name": "Lokathor",
        "timestamp": 1561814717
    },
    {
        "content": "<p>i tend to agree</p>",
        "id": 169297272,
        "sender_full_name": "Lokathor",
        "timestamp": 1561814794
    },
    {
        "content": "<p>Can you do that even if you mix it with a <code>restrict</code> pointer to the same memory location ?</p>",
        "id": 169297600,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561815299
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"k\">const</span><span class=\"o\">*</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span>\n<span class=\"p\">{</span> <span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"kr\">restrict</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span> <span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span> <span class=\"c1\">// OK ?</span>\n</pre></div>",
        "id": 169297666,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561815421
    },
    {
        "content": "<p>This is definitely UB in C:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"k\">const</span><span class=\"o\">*</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"kr\">restrict</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span> <span class=\"c1\">// UB</span>\n<span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>you can't access v via ptr because there is a restrict pointer to v in that scope that modifies it.</p>",
        "id": 169297894,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561815928
    },
    {
        "content": "<p>I suppose that the first example is OK in C, because the access doesn't happen in the scope of the restrict pointer, but this is also UB in C:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"k\">const</span><span class=\"o\">*</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"kr\">restrict</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span> <span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span> <span class=\"c1\">// UB</span>\n</pre></div>\n\n\n<p>(just removed the <code>{}</code> of the first example, increasing the scope of restrict)</p>",
        "id": 169297951,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561816005
    },
    {
        "content": "<blockquote>\n<p>Retep998 strongly believes that such code is not supposed to be UB because a pointer has no rules beyond C rules, and in C you could do that, and so _even if_ Rust rules apply while a reference exists (which is fair), basically once the reference stops existing things should \"revert\" to just being normal pointer-only rules, including a restoration of the <code>*const</code> pointer.</p>\n</blockquote>\n<p>the pointer has no rules, but the reference does</p>",
        "id": 169300239,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819482
    },
    {
        "content": "<p>if you use <em>only</em> pointers, you wont have a problem</p>",
        "id": 169300243,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819492
    },
    {
        "content": "<p>but you are mixing references with pointers. we <em>have to</em> make this UB if we want to get any benefit from  our aliasing.</p>",
        "id": 169300256,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819512
    },
    {
        "content": "<p>if I applied your argument, the following code would be fine:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"c1\">// Note that we emit noalias here, telling LLVM these don&#39;t alias!</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">local</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">local</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">local</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">raw</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// *oops*</span>\n</pre></div>",
        "id": 169300316,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819571
    },
    {
        "content": "<p>so <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> the only way to make such code not UB and do what Retep998 suggests is to <em>remove</em> the aliasing optimizations that we are already performing</p>",
        "id": 169300331,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819625
    },
    {
        "content": "<p>\"stops existing\" is not something I think we can formalize, and scopes clearly shouldnt matter</p>",
        "id": 169300364,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819682
    },
    {
        "content": "<p>so my code is the same as</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0_</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169300383,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819695
    },
    {
        "content": "<blockquote>\n<p>I suppose that the first example is OK in C, because the access doesn't happen in the scope of the restrict pointer, but this is also UB in C:</p>\n</blockquote>\n<p>in C it's not really clear what <code>restrict</code> means when not used as a function argument, I think</p>",
        "id": 169300397,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819725
    },
    {
        "content": "<p>So if you have *mut and then use .as_mut to get &amp;mut and then pass that to a function, and then the function returns... your *mut is dead so you just lost your value?</p>",
        "id": 169300490,
        "sender_full_name": "Lokathor",
        "timestamp": 1561819847
    },
    {
        "content": "<p>I think what you are basically saying is that raw pointers should exist \"next to\" the tracking that knows which references got \"derived from\" which other reference and so on... the problem with that is that you can create a reference from a raw pointer, and we have to know where that reference \"comes from\"</p>",
        "id": 169300506,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819897
    },
    {
        "content": "<blockquote>\n<p>So if you have *mut and then use .as_mut to get &amp;mut and then pass that to a function, and then the function returns... your *mut is dead so you just lost your value?</p>\n</blockquote>\n<p>if you create the <code>&amp;mut</code> <em>from</em> the <code>*mut</code> you are fine</p>",
        "id": 169300511,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819919
    },
    {
        "content": "<p>it's all about where the pointers \"come from\" being well-nested</p>",
        "id": 169300556,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819938
    },
    {
        "content": "<p>for your program, it's more like a tree... hm not sure how to draw that here</p>",
        "id": 169300560,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819956
    },
    {
        "content": "<p>yes, pointers next to references is the mental model that most people using unsafe code that I've spoken to subscribe to</p>",
        "id": 169300565,
        "sender_full_name": "Lokathor",
        "timestamp": 1561819967
    },
    {
        "content": "<p>the root is v. <code>ptr</code> is one child of <code>v</code> and <code>y</code> is another child of <code>v</code>. they exist next to each other and thus are in conflict</p>",
        "id": 169300571,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819984
    },
    {
        "content": "<p>whereas if you make <code>y</code> a child of <code>v</code>, the situation is very different</p>",
        "id": 169300576,
        "sender_full_name": "RalfJ",
        "timestamp": 1561819995
    },
    {
        "content": "<blockquote>\n<p>yes, pointers next to references is the mental model that most people using unsafe code that I've spoken to subscribe to</p>\n</blockquote>\n<p>but then what happens when you create a reference again? you have to \"put it somewhere\"</p>",
        "id": 169300585,
        "sender_full_name": "RalfJ",
        "timestamp": 1561820016
    },
    {
        "content": "<p>and that requires tracking raw pointers as well</p>",
        "id": 169300588,
        "sender_full_name": "RalfJ",
        "timestamp": 1561820026
    },
    {
        "content": "<p>like... let me see if I can make an example</p>",
        "id": 169300598,
        "sender_full_name": "RalfJ",
        "timestamp": 1561820042
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// y derived from x</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// z derived from y.</span>\n<span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// this has to make z invalid! if we used z again there was an access between creating it and using it, a clear aliasing violation.</span>\n<span class=\"c1\">// however, x remains valid, because y was &quot;created from&quot; x so x &quot;knows&quot; that mutations can happen through y.</span>\n<span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// however, now x may again assume that no mutations through anything else can happen.</span>\n</pre></div>",
        "id": 169300654,
        "sender_full_name": "RalfJ",
        "timestamp": 1561820150
    },
    {
        "content": "<p>the only way I know to explain this is to say that y is \"between\" x and z</p>",
        "id": 169300697,
        "sender_full_name": "RalfJ",
        "timestamp": 1561820189
    },
    {
        "content": "<p>okay i see what you're saying, but, if i had my way, *y=14 is UB since z is live, and the rest of the program is unimportant once that happens</p>",
        "id": 169300906,
        "sender_full_name": "Lokathor",
        "timestamp": 1561820552
    },
    {
        "content": "<p>That seems even worse for unsafe code authors?</p>",
        "id": 169300992,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1561820668
    },
    {
        "content": "<p>not that there couldn't be another model, there is apparently another model already, but you should post BUG HUGE signs about this sort of thing because most people are currently living under a model where addresses (only) are what matter, not any kind of source chain</p>",
        "id": 169300994,
        "sender_full_name": "Lokathor",
        "timestamp": 1561820670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> no it's a really easy model for unsafe code authors: \"is anyone else referencing this address <em>right now</em>? (no) is it aligned and a valid bit pattern and all that? (yes) Okay I can make a &amp;mut pointing at it and once I'm sure that &amp;mut is gone nothing else about my program is different.\"</p>",
        "id": 169301117,
        "sender_full_name": "Lokathor",
        "timestamp": 1561820904
    },
    {
        "content": "<blockquote>\n<p>okay i see what you're saying, but, if i had my way, *y=14 is UB since z is live, and the rest of the program is unimportant once that happens</p>\n</blockquote>\n<p>that's weird, because this is <em>safe</em>:</p>\n<div class=\"codehilite\"><pre><span></span>let x = &amp;mut 42;\nlet y = &amp;mut *x; // y derived from x\nlet z = &amp;mut *y; // z derived from y.\n*y = 14;\n*x = 14;\n</pre></div>",
        "id": 169301336,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821243
    },
    {
        "content": "<blockquote>\n<p>not that there couldn't be another model, there is apparently another model already, but you should post BUG HUGE signs about this sort of thing because most people are currently living under a model where addresses (only) are what matter, not any kind of source chain</p>\n</blockquote>\n<p>well most people are wrong in many ways ;)</p>",
        "id": 169301344,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821271
    },
    {
        "content": "<p>and even your model makes the source matter</p>",
        "id": 169301351,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821291
    },
    {
        "content": "<p>if I used <code>z</code> instead of <code>y</code> I assume you are fine, even though both point to the same address</p>",
        "id": 169301360,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  That is not the direction I'm worried about. You seem to suggest that creating raw pointers from a mutable reference and using them always causes UB, even if the mutable reference is not used while the raw pointer(s) are in use. On its face that seems to outlaw lots of unsafe code that should obviously work, e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">some_memory</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">some_memory</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Default</span>::<span class=\"n\">default</span><span class=\"p\">());</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169301362,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1561821309
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124289\">rkruppe</span> no it's a really easy model for unsafe code authors: \"is anyone else referencing this address <em>right now</em>? (no) is it aligned and a valid bit pattern and all that? (yes) Okay I can make a &amp;mut pointing at it and once I'm sure that &amp;mut is gone nothing else about my program is different.\"</p>\n</blockquote>\n<p>what does it mean \"referencing right now\"? in my safe example we have three references to the same thing, so it should be UB under your rules!</p>",
        "id": 169301367,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821342
    },
    {
        "content": "<p>oh i see, i read Ralf's example wrong</p>",
        "id": 169301485,
        "sender_full_name": "Lokathor",
        "timestamp": 1561821577
    },
    {
        "content": "<p>i should never look at code on my phone, my brain doesn't format it right somehow</p>",
        "id": 169301490,
        "sender_full_name": "Lokathor",
        "timestamp": 1561821597
    },
    {
        "content": "<p>^^</p>",
        "id": 169301528,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821603
    },
    {
        "content": "<p>I'll have to review and think again later today</p>",
        "id": 169301537,
        "sender_full_name": "Lokathor",
        "timestamp": 1561821623
    },
    {
        "content": "<p>Stacked Borrows tries to formalize a notion that is like \"liveness\", but we cannot use literal liveness because that's a static thing</p>",
        "id": 169301538,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821632
    },
    {
        "content": "<p>at the <code>*y = 14</code> we dont know yet if <code>z</code> is live as we cannot predict if it gets used in the future</p>",
        "id": 169301541,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821647
    },
    {
        "content": "<p>and I'd rather not make UB at one point depend on what the program does in the future^^ that route lies madness</p>",
        "id": 169301543,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821660
    },
    {
        "content": "<p>(I am aware that UB is atemporal, but this would be <em>far worse</em>)</p>",
        "id": 169301553,
        "sender_full_name": "RalfJ",
        "timestamp": 1561821678
    },
    {
        "content": "<p>so, what I've seen many people do is imagine it all as being similar to how drop works</p>",
        "id": 169301677,
        "sender_full_name": "Lokathor",
        "timestamp": 1561821925
    },
    {
        "content": "<p>if &amp;mut is in scope, even if it's not used later, it's illegal to violate the rules, it hasn't \"dropped\" yet</p>",
        "id": 169301685,
        "sender_full_name": "Lokathor",
        "timestamp": 1561821957
    },
    {
        "content": "<p>that's incompatible with NLL though</p>",
        "id": 169302139,
        "sender_full_name": "RalfJ",
        "timestamp": 1561822832
    },
    {
        "content": "<p>since NLL, reference lifetime has nothing to do with scopes any more</p>",
        "id": 169302143,
        "sender_full_name": "RalfJ",
        "timestamp": 1561822839
    },
    {
        "content": "<p>I tried implementing something \"drop-like\" some years ago: <a href=\"https://www.ralfj.de/blog/2017/07/17/types-as-contracts.html\" target=\"_blank\" title=\"https://www.ralfj.de/blog/2017/07/17/types-as-contracts.html\">https://www.ralfj.de/blog/2017/07/17/types-as-contracts.html</a></p>",
        "id": 169302145,
        "sender_full_name": "RalfJ",
        "timestamp": 1561822861
    },
    {
        "content": "<p>it didnt work</p>",
        "id": 169302148,
        "sender_full_name": "RalfJ",
        "timestamp": 1561822864
    },
    {
        "content": "<p>I find the current model intuitive. If I look at a pointer or a reference, I just need to walk up its ancestors, checking if they had other children that might have invalidated the reference i'm studying</p>",
        "id": 169303964,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561826235
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 169304007,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561826296
    },
    {
        "content": "<p>Well once it's explained it mostly makes sense</p>",
        "id": 169308773,
        "sender_full_name": "Lokathor",
        "timestamp": 1561835533
    },
    {
        "content": "<p>but this might need a PSA post, is I guess what I'm saying</p>\n<p>\"Hey, a lot of yall think it works like X, but really the rules are more like Y. This isn't even a change, it's been like this for a while now.\"</p>",
        "id": 169309236,
        "sender_full_name": "Lokathor",
        "timestamp": 1561836408
    },
    {
        "content": "<p>definitely agree. seems to be a lot of confusion</p>",
        "id": 169309303,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561836551
    },
    {
        "content": "<p>The rules aren't RFCed yet, so until that happens, its only interesting if you are using miri to find UB in your code</p>",
        "id": 169309435,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561836741
    },
    {
        "content": "<p>Even if the rules are RFC'ed, many users don't really need to know them</p>",
        "id": 169309449,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561836803
    },
    {
        "content": "<p>And from those who need to, listening to miri might be enough</p>",
        "id": 169309458,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561836841
    },
    {
        "content": "<p>Once the rules are written somewhere, learning all of this will be easier</p>",
        "id": 169309675,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561837203
    },
    {
        "content": "<p>right, these are the current WIP rules</p>",
        "id": 169311591,
        "sender_full_name": "RalfJ",
        "timestamp": 1561841215
    },
    {
        "content": "<p>the relevant posts are on my blog, they did get announced on reddit + IRLO</p>",
        "id": 169311599,
        "sender_full_name": "RalfJ",
        "timestamp": 1561841229
    },
    {
        "content": "<p>but nothing is official at this point</p>",
        "id": 169311603,
        "sender_full_name": "RalfJ",
        "timestamp": 1561841236
    },
    {
        "content": "<p>and it seems like anyway the rules will have to change again...</p>",
        "id": 169311607,
        "sender_full_name": "RalfJ",
        "timestamp": 1561841256
    },
    {
        "content": "<p>If people are triggering UB because they're writing code according to a different memory model than is the actual one, <em>everyone</em> cares about that.</p>\n<p>Let me put it another way: Lots of people write unsafe code, few of them use miri on that code because it's \"obviously\" already correct.</p>\n<p><em>Even if</em> the current rules are only temporary and subject to change later, people deserve to know what the current rules are at all times. Like, the usual Rust policy of saying little until one final ultimate stability push is over and done with, and then announcing however it ended, is a very bad plan in this situation.</p>\n<p>Yall are great, but people are out there footgunning themselves today, they don't wait for you to do anything, they just push unsound code like there's no tomorrow. Educational materials should be spread sooner, not later.</p>",
        "id": 169321467,
        "sender_full_name": "Lokathor",
        "timestamp": 1561862508
    },
    {
        "content": "<p>well I don't know what to do beyond writing blog posts and helping answer questions here. it's not like the rules are secret or anything.</p>\n<blockquote>\n<p>the usual Rust policy of saying little until one final ultimate stability push is over and done with</p>\n</blockquote>\n<p>this is unfair. first of all that's not at all the usual Rust policy, there is <em>so much</em> discussion everywhere, but of course if you wait until it appears on the official blog you won't see it. that's not what the official blog is for.<br>\nand secondly if we were to assign Stacked Borrows into the usual Rust process, it would be pre-RFC or pre-pre-RFC. there's not usually anything in the official channels or docs at that stage for <em>any</em> proposal, and rightly so. the official channels would drown in noise otherwise.</p>\n<p>we <em>do</em> have educational material that says \"references have strict aliasing rules, we dont know the rules yet so be conservative\". I don't think we can do much more on the official docs at this point in time. if people insist on ignoring that and instead doing things that are \"obviously correct\", I don't know what we can do about that.</p>",
        "id": 169332100,
        "sender_full_name": "RalfJ",
        "timestamp": 1561885862
    },
    {
        "content": "<p>if we say <em>anything</em> like \"the following thing is okay to do with raw pointers and references\", that's a <em>big commitment</em></p>",
        "id": 169332150,
        "sender_full_name": "RalfJ",
        "timestamp": 1561885949
    },
    {
        "content": "<p>I guess we could have a \"negative list\" somewhere -- \"the following things might seem obvious but they are not, don't do that\". and maybe hopefully that list wont just be ignored because it contains so many things that people want to do...</p>",
        "id": 169332214,
        "sender_full_name": "RalfJ",
        "timestamp": 1561886067
    },
    {
        "content": "<p>but I also have to add that I am at max capacity with what I am doing with Stacked Borrows and Miri and the Unsafe Code Guidelines currently. there's only so much one person can do in a day. (Not saying I am doing all of that alone, but Stacked Borrows so far has been mostly me -- it's also very complicated to get into so I am not blaming anyone. And some people have helped tremendously developing the model.)</p>",
        "id": 169332242,
        "sender_full_name": "RalfJ",
        "timestamp": 1561886123
    },
    {
        "content": "<p>Help writing more educational material is certainly welcome though. :-)<br>\nOf course, that all needs to be updated whenever things change, and they will... writing such things early costs a lot of resources that we currently just don't have.</p>",
        "id": 169332546,
        "sender_full_name": "RalfJ",
        "timestamp": 1561886723
    },
    {
        "content": "<p>I don't think that you need to say \"you can do this with raw pointers (now and for all time)\". I think you just need to say \"as of precisely June 30th of 2019, this is what you can do with raw pointers (and this is all \"unstable, implementation defined\" and can all change at any moment)\".</p>\n<p>I'm fairly good at putting out very large word counts of materials as necessary. If you were interested in setting up a place for \"what we think the rules currently mean\" to be written down I could probably fill in the prose parts in between some select code examples like the little 4 line example we had above. Vetting it for accuracy would still fall on the WG members. I'm not thinking that it has to be too complex, probably a single markdown file could cover it until things move from at least \"pre-pre-RFC\" up to \"pre-RFC\" or better.</p>\n<p>We could have great examples such as \"aliasing or not actually depends on the parentage of where the pointer/reference comes from\" and \"no, you currently cannot make a slice of uninitialized memory as a buffer to write to, please stop doing that\"</p>",
        "id": 169343293,
        "sender_full_name": "Lokathor",
        "timestamp": 1561907480
    },
    {
        "content": "<p>in terms of placement, sounds like a nomicon thing to me?</p>\n<blockquote>\n<p>\"no, you currently cannot make a slice of uninitialized memory as a buffer to write to, please stop doing that\"</p>\n</blockquote>\n<p>that's unrelated to Stacked Borrows, but I guess that distinction is not very meaningful \"from the outside\"</p>",
        "id": 169343446,
        "sender_full_name": "RalfJ",
        "timestamp": 1561907740
    },
    {
        "content": "<p>I mean that stacked borrows aren't the only thing that people regularly do wrong :)</p>\n<p>And yeah, maybe a \"grab bag\" page in the Nomicon would fit this situation.</p>",
        "id": 169344459,
        "sender_full_name": "Lokathor",
        "timestamp": 1561909569
    },
    {
        "content": "<blockquote>\n<p>I mean that stacked borrows aren't the only thing that people regularly do wrong :)</p>\n</blockquote>\n<p>sure. and while we have a lot of docs about what you <em>can</em> do, its much less clearer where to put docs about what you <em>cannot</em> do</p>",
        "id": 169344793,
        "sender_full_name": "RalfJ",
        "timestamp": 1561910229
    },
    {
        "content": "<p>these days, at least the docs for <code>MaybeUninit</code> and <code>mem::uninitialized</code> call out that you cant just run around with uninitialized memory</p>",
        "id": 169344797,
        "sender_full_name": "RalfJ",
        "timestamp": 1561910263
    },
    {
        "content": "<p>(on beta currently, will hit stable next week)</p>",
        "id": 169344799,
        "sender_full_name": "RalfJ",
        "timestamp": 1561910270
    },
    {
        "content": "<p>those might be good docs for you to look over and suggest ho they could be improved, maybe?</p>",
        "id": 169344841,
        "sender_full_name": "RalfJ",
        "timestamp": 1561910300
    },
    {
        "content": "<p>Sure, I'll have a look. I think my usual writing style is a bit more like the Nomicon or Too Many Linked Lists style than like the libstd style.</p>\n<p>The other problem is that some of this stuff is <em>currently</em> one way but as you say not really set in stone. For example, <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\">https://github.com/rust-lang/unsafe-code-guidelines/issues/71</a> might make advice against uninit <code>&amp;[u8]</code> obsolete eventually. In this case, people might use old compiler versions of course (eg: debian stable will be 1.34 for a long while), so <em>those versions</em> will need the old info of course. I'm not super clear how the libs/docs team feels about supplimental docs that need to change over time like that.</p>",
        "id": 169345688,
        "sender_full_name": "Lokathor",
        "timestamp": 1561911947
    },
    {
        "content": "<blockquote>\n<p>In this case, people might use old compiler versions of course (eg: debian stable will be 1.34 for a long while), so those versions will need the old info of course. </p>\n</blockquote>\n<p>actually, at least in this case, that's not true. the compiler is <em>already</em> compatible with a spec that says \"integers may be uninitialized as long as you dont do any arithmetic or so on them\"</p>",
        "id": 169346088,
        "sender_full_name": "RalfJ",
        "timestamp": 1561912719
    },
    {
        "content": "<p>we just dont want to commit to that yet</p>",
        "id": 169346089,
        "sender_full_name": "RalfJ",
        "timestamp": 1561912729
    },
    {
        "content": "<p>but once we do, this becomes retroactively correct for old compilers</p>",
        "id": 169346092,
        "sender_full_name": "RalfJ",
        "timestamp": 1561912739
    },
    {
        "content": "<p>i would personally like a bit more clarity on these two pages in particular <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">https://doc.rust-lang.org/reference/behavior-considered-undefined.html</a> <a href=\"https://doc.rust-lang.org/nomicon/aliasing.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nomicon/aliasing.html\">https://doc.rust-lang.org/nomicon/aliasing.html</a></p>",
        "id": 169346167,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561912896
    },
    {
        "content": "<p>the nomicon page currently only talks about references</p>",
        "id": 169346171,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561912919
    },
    {
        "content": "<p>and the reference basically says ‘pointers are like C, check llvm noalias docs for references’ - which is a problem because 1) noalias suggests there’s only a problem on <em>accesses</em> through noalias’d pointers, yet as per my original example it can be UB just by creating a &amp;mut T and not using it at all and 2) it doesn’t detail the interaction between pointers and refs</p>",
        "id": 169346345,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561913189
    },
    {
        "content": "<p>if i knew all the details in my head of C’s model and LLVM’s noalias i could probably figure that out for myself but people shouldn’t have to dig that far to see what’s allowed</p>",
        "id": 169346360,
        "sender_full_name": "Matt Taylor",
        "timestamp": 1561913252
    },
    {
        "content": "<p>I agree</p>",
        "id": 169346615,
        "sender_full_name": "RalfJ",
        "timestamp": 1561913743
    },
    {
        "content": "<p>the reference page seems good already</p>",
        "id": 169348028,
        "sender_full_name": "Lokathor",
        "timestamp": 1561916475
    },
    {
        "content": "<p>i mean, it's clearly needing more info later, but at the moment, the things it does say are relatively clear</p>",
        "id": 169348031,
        "sender_full_name": "Lokathor",
        "timestamp": 1561916502
    },
    {
        "content": "<p>the nomicon page... leaves a bit to be desired i think</p>",
        "id": 169348073,
        "sender_full_name": "Lokathor",
        "timestamp": 1561916531
    },
    {
        "content": "<p>If i have time later today, and I think I will, then I'll make an attempt at expanding that page a bit as my first programming priority of the day</p>",
        "id": 169348090,
        "sender_full_name": "Lokathor",
        "timestamp": 1561916601
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> :)<br>\nI can help reviewing, though I dont have any r+ powers for the reference or the nomicon. but we'll find someone who does.^^</p>",
        "id": 169348606,
        "sender_full_name": "RalfJ",
        "timestamp": 1561917543
    },
    {
        "content": "<p>I would have guessed the Nomicon to be under the direct control of the unsafe wg</p>",
        "id": 169348754,
        "sender_full_name": "Lokathor",
        "timestamp": 1561917772
    },
    {
        "content": "<p>no, the nomicon is waay older than we are</p>",
        "id": 169348877,
        "sender_full_name": "RalfJ",
        "timestamp": 1561918059
    },
    {
        "content": "<p>and we dont have anything directly to do with it.</p>",
        "id": 169348880,
        "sender_full_name": "RalfJ",
        "timestamp": 1561918070
    },
    {
        "content": "<p>but that sounds like a thing we might want to change :D</p>",
        "id": 169348881,
        "sender_full_name": "RalfJ",
        "timestamp": 1561918077
    },
    {
        "content": "<p>the problem is, the WG doesnt really have any leftover bandwidth. we can barely keep our discussions going...</p>",
        "id": 169348922,
        "sender_full_name": "RalfJ",
        "timestamp": 1561918093
    },
    {
        "content": "<p>assimilate more members</p>",
        "id": 169354202,
        "sender_full_name": "Lokathor",
        "timestamp": 1561928681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <a href=\"https://github.com/rust-lang-nursery/nomicon/pull/144\" target=\"_blank\" title=\"https://github.com/rust-lang-nursery/nomicon/pull/144\">https://github.com/rust-lang-nursery/nomicon/pull/144</a> is a very small edit to just the readme, just to get my feet wet since I haven't really PR'd at repo other than my own in a while. But it's a start</p>",
        "id": 169357478,
        "sender_full_name": "Lokathor",
        "timestamp": 1561935627
    },
    {
        "content": "<p>thanks :)</p>",
        "id": 169413567,
        "sender_full_name": "RalfJ",
        "timestamp": 1562001722
    },
    {
        "content": "<p>May I ask what is \"niches\" that was discussed here?</p>",
        "id": 171267195,
        "sender_full_name": "Ehsan M. Kermani",
        "timestamp": 1563550185
    },
    {
        "content": "<p>See <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#niche\" target=\"_blank\" title=\"https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#niche\">https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#niche</a></p>",
        "id": 171268043,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1563550776
    },
    {
        "content": "<p>Ah, thanks! <br>\nJust to make sure about the linked doc, type repr includes size, alignment, niches and abi and having these 4 defines a valid type? In other words, is it always a one-to-four relation?</p>",
        "id": 171272045,
        "sender_full_name": "Ehsan M. Kermani",
        "timestamp": 1563554025
    },
    {
        "content": "<p>repr(esentation) is overloaded and not currently defined in the glossary. I'm not sure what exactly the underlying question is to answer it directly. Certainly there is more a \"type\" than just these four things. Even for data layout considerations, the location (offsets) of the fields contained in it are important as well.</p>",
        "id": 171273347,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1563554980
    },
    {
        "content": "<p>Ok, just want to have a correct mental model of the constituents. So anything more than (size, align, offset, niche, abi) + underlying validity requirments?</p>",
        "id": 171273674,
        "sender_full_name": "Ehsan M. Kermani",
        "timestamp": 1563555239
    },
    {
        "content": "<p>Hm. I don't want to commit to that being exhaustive but it's roughly all I can think of that comes up in the current discussions.</p>",
        "id": 171274624,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1563555915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211549\">@Ehsan M. Kermani</span> there's also the validity invariant! What exactly that invariant is for various types is currently being discussed.</p>",
        "id": 171322997,
        "sender_full_name": "RalfJ",
        "timestamp": 1563620584
    },
    {
        "content": "<p>see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/active_discussion/validity.md\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/active_discussion/validity.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/active_discussion/validity.md</a> and <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aissue+is%3Aopen+label%3Atopic-validity\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aissue+is%3Aopen+label%3Atopic-validity\">https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aissue+is%3Aopen+label%3Atopic-validity</a></p>",
        "id": 171323001,
        "sender_full_name": "RalfJ",
        "timestamp": 1563620606
    },
    {
        "content": "<p>In light of niches discussion, I don't think the name is representative enough. In cases like boolian, it's not \"niches\" per say!</p>",
        "id": 171539002,
        "sender_full_name": "Ehsan M. Kermani",
        "timestamp": 1563902734
    },
    {
        "content": "<p>I do not understand what you are trying to say?</p>",
        "id": 171552053,
        "sender_full_name": "RalfJ",
        "timestamp": 1563911498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'm trying to see if there's a better name instead of \"niche\" <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 171554479,
        "sender_full_name": "Ehsan M. Kermani",
        "timestamp": 1563913258
    },
    {
        "content": "<p>ah. well there probably is but that'd be a discussion to have with @eddyb and t-compiler -- \"niche\" is what rustc calls it internally ;)</p>",
        "id": 171557541,
        "sender_full_name": "RalfJ",
        "timestamp": 1563915681
    },
    {
        "content": "<p>IMO as a native American English speaker, \"niche\" is about as good a term as we are likely to find.</p>",
        "id": 171558522,
        "sender_full_name": "Tom Phinney",
        "timestamp": 1563916450
    },
    {
        "content": "<p>Just try to get two people to agree on a pronunciation of \"niche\"</p>",
        "id": 171571395,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1563932376
    },
    {
        "content": "<p>It's like \"cache\" <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 171573318,
        "sender_full_name": "Tom Phinney",
        "timestamp": 1563935622
    },
    {
        "content": "<p>Of course, it really isn't; the terminal consonant is pronounced differently. But just as there are many pronunciations of \"cache\", there certainly will be similar variety with \"niche\".</p>",
        "id": 171573382,
        "sender_full_name": "Tom Phinney",
        "timestamp": 1563935706
    },
    {
        "content": "<p>Pronouncing it 'nitch' or 'nish' instead of <code>neesh</code> is passing on a perfectly justified opportunity for speaking French <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 171585408,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1563954523
    },
    {
        "content": "<p>You're right, of course. That's also how it's pronounced in the UK. However, in much of the US it's pronounced \"nitch\". See <a href=\"https://www.quickanddirtytips.com/education/grammar/how-do-you-pronounce-niche\" target=\"_blank\" title=\"https://www.quickanddirtytips.com/education/grammar/how-do-you-pronounce-niche\">https://www.quickanddirtytips.com/education/grammar/how-do-you-pronounce-niche</a> and <a href=\"https://www.google.com/search?q=Dictionary#dobs=niche\" target=\"_blank\" title=\"https://www.google.com/search?q=Dictionary#dobs=niche\">https://www.google.com/search?q=Dictionary#dobs=niche</a>. If we want to encourage a uniform pronunciation for Rustaceans, the it would be best to include parenthetical pronunciation, such as \"(preferably pronounced nēSH)\", at the first occurrence of the word in various major Rust teaching documents.</p>",
        "id": 171616288,
        "sender_full_name": "Tom Phinney",
        "timestamp": 1563982377
    },
    {
        "content": "<p>FWIW I always found it funny at conferences to hear how different people pronounce the different technical words</p>",
        "id": 171620783,
        "sender_full_name": "gnzlbg",
        "timestamp": 1563985753
    },
    {
        "content": "<p>I don't recall the differences in pronunciation ever being a problem, more like a curiosity</p>",
        "id": 171620876,
        "sender_full_name": "gnzlbg",
        "timestamp": 1563985823
    },
    {
        "content": "<p>e.g. some people pronounce <code>std</code> as \"stood\", while others say \"standard\" and others say \"es-tee-dee\"</p>",
        "id": 171620910,
        "sender_full_name": "gnzlbg",
        "timestamp": 1563985861
    },
    {
        "content": "<p>if we choose \"niche\" I don't really have a problem with people pronouncing it however they want, i really can't see the different pronunciations leading to communication problems, at most some people will get a laugh</p>",
        "id": 171621067,
        "sender_full_name": "gnzlbg",
        "timestamp": 1563986018
    },
    {
        "content": "<blockquote>\n<p>e.g. some people pronounce <code>std</code> as \"stood\", while others say \"standard\" and others say \"es-tee-dee\"</p>\n</blockquote>\n<p>I don't have any vowel in my version of <code>std</code>, its just \"shtd\"</p>",
        "id": 171624047,
        "sender_full_name": "RalfJ",
        "timestamp": 1563988154
    }
]