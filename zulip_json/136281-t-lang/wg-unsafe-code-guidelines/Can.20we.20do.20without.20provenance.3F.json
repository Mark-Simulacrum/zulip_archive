[
    {
        "content": "<p>Some more thoughts on <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>'s idea to have provenance \"on values\" but not \"in memory\"...</p>\n<p>My main concern with that proposal is this: losing provenance is bad news. In Stacked Borrows and everywhere else, if you cast a ptr to an integer, you give up everything you know about that pointer as now anyone might cast that integer back to a ptr, possibly even by \"guessing\" the integer if you leaked enough information about that. One might call this a \"broadcast\" operation, since the memory is now available to everyone. So, under a provenance model, a ptr-to-int cast is bad news for the alias analysis.<br>\nIf memory doesn't remember provenance, <em>every time a ptr is stored in memory is a boradcast</em>. Which is basically all the time since even local variables are backed by memory -- at least the adressable ones.<br>\n(And making a distinction between two kinds of local variables seems risky -- there's code that would be UB with one kind of variable but fine with the other, so in the hope of resolving the counterintuitive behavior arising from provenance you have introduced something similarly counterintuitive.)</p>",
        "id": 219882255,
        "sender_full_name": "RalfJ",
        "timestamp": 1607970552
    },
    {
        "content": "<p>What if instead of provenance, you track \"permission\" to access data? So you are allowed to invent whatever bit pattern you like, but it is UB to read random memory you have magicked up in this way</p>",
        "id": 219882608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607970714
    },
    {
        "content": "<p>This probably isn't possible in C, but rust's references give a pretty good guide to what permission you should have</p>",
        "id": 219882760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607970779
    },
    {
        "content": "<blockquote>\n<p>One might call this a \"broadcast\" operation, since the memory is now available to everyone.</p>\n</blockquote>\n<p>That is, the bit pattern is available to everyone, but the permission is only yours, and anyone else who tries to access the memory will cause UB.</p>",
        "id": 219883059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607970922
    },
    {
        "content": "<p>These permissions are tracked \"alongside\" values, but are not literally stored with values. Logically, we would say that the permission is the points-to assertion while the value is the bit pattern</p>",
        "id": 219883436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971080
    },
    {
        "content": "<p>How does this differ from provenance?</p>",
        "id": 219883523,
        "sender_full_name": "bjorn3",
        "timestamp": 1607971107
    },
    {
        "content": "<p>Mostly that it's not tied so directly to values that it has to get filtered through every operation. It's more similar to the facts that the compiler builds up by looking at flow control</p>",
        "id": 219883746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971206
    },
    {
        "content": "<p>if these permissions only exist in the compiler analysis they don't change anything about the program semantics</p>",
        "id": 219883814,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971238
    },
    {
        "content": "<p>that's right</p>",
        "id": 219883826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971245
    },
    {
        "content": "<p>as in, they cannot make things UB</p>",
        "id": 219883829,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971245
    },
    {
        "content": "<p>if they are involved in UB in any way, this sounds like another form of provenance to me</p>",
        "id": 219883852,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971258
    },
    {
        "content": "<p>there are hardware architectures like CHERI where pointers carry something like permissions, and I'd call that a form of provenance</p>",
        "id": 219883901,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219883436\">said</a>:</p>\n<blockquote>\n<p>These permissions are tracked \"alongside\" values, but are not literally stored with values. Logically, we would say that the permission is the points-to assertion while the value is the bit pattern</p>\n</blockquote>\n<p>points-to assertions only exist in the logic, so they cannot actually help make things UB and thus enable optimizations.<br>\nunless you want to say that the compiler contract becomes something like \"code is UB unless you can prove a separation logic spec about it\"... at which point you've replaced provenance by something that I don't think has a name but might be called PROVENANCE since there's just <em>so much</em> \"extra state\" now.^^ also you made your language semantics uncomputable. I don't think I'm a fan of this approach.^^</p>",
        "id": 219884206,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971423
    },
    {
        "content": "<p>I suppose in that respect they are like provenance. I have some operations that allow you to literally separate the pointer from the permission and compute with the latter, but I'm afraid it is actually the programmer doing separation logic in disguise</p>",
        "id": 219884457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971524
    },
    {
        "content": "<p>not to mention there's a cyclicity now -- the separation logic will be defined in terms of the operational semantics of the language (or at least related to it in its adequacy/soundness statement), and now the op.sem depends on the logic.</p>",
        "id": 219884528,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219884457\">said</a>:</p>\n<blockquote>\n<p>I suppose in that respect they are like provenance. I have some operations that allow you to literally separate the pointer from the permission and compute with the latter, but I'm afraid it is actually the programmer doing separation logic in disguise</p>\n</blockquote>\n<p>even in C/LLVM/Rust-style provenance you could imagine adding operations that allow the programmer to handle provenance more explicitly</p>",
        "id": 219884635,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971581
    },
    {
        "content": "<p>in fact people have already written functions like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Returns a pointer with the provenance of `prov` pointing to `addr`.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">copy_provenance</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">addr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">prov</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219884719,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971625
    },
    {
        "content": "<p>The part where C/LLVM-style provenance starts to get weird for me is when it gets sliced and diced and sent over the network though</p>",
        "id": 219884895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971698
    },
    {
        "content": "<p>but so far there's little work on this and indeed it could be interesting to work out what a set of useful primitives for \"working with provenance\" could be.</p>",
        "id": 219884919,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219884895\">said</a>:</p>\n<blockquote>\n<p>The part where provenance starts to get weird for me is when it gets sliced and diced and sent over the network though</p>\n</blockquote>\n<p>yeah, you can't do that^^</p>",
        "id": 219884931,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971719
    },
    {
        "content": "<p>there's always ptr-int casts and back</p>",
        "id": 219884942,
        "sender_full_name": "RalfJ",
        "timestamp": 1607971724
    },
    {
        "content": "<p>From my point of view it's the pointer that gets sliced and diced while the permission just sits there alongside. If you don't smuggle the permission separately then the pointer that comes out the other end is UB to use</p>",
        "id": 219885092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971798
    },
    {
        "content": "<p>One can imagine the compiler being able to route the permissions in most cases (similar to value computations with provenance), but for anything like ptr-int casts the programmer needs to be a bit more hands on</p>",
        "id": 219885393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607971914
    },
    {
        "content": "<p>Or I guess, when the programmer is not working in literal separation logic, they just do the op and if the permission isn't derivable from the function inputs then you get UB</p>",
        "id": 219885840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607972095
    },
    {
        "content": "<p>Regarding op.sem circularity, I don't think it's a problem because you can define the operational semantics with respect only to a flat memory model, and layer language level UB on top of that</p>",
        "id": 219886003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607972165
    },
    {
        "content": "<p>you can but then you cant exploit that language-level UB in proofs that you perform in the logic</p>",
        "id": 219886049,
        "sender_full_name": "RalfJ",
        "timestamp": 1607972192
    },
    {
        "content": "<p>since the logic is used to define language-level UB in the first place</p>",
        "id": 219886068,
        "sender_full_name": "RalfJ",
        "timestamp": 1607972203
    },
    {
        "content": "<p>so, that seems like a problem. maybe it isn't, but my intuition says it is.</p>",
        "id": 219886095,
        "sender_full_name": "RalfJ",
        "timestamp": 1607972218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219885393\">said</a>:</p>\n<blockquote>\n<p>One can imagine the compiler being able to route the permissions in most cases (similar to value computations with provenance), but for anything like ptr-int casts the programmer needs to be a bit more hands on</p>\n</blockquote>\n<p>the compiler doesn't have to route anything, this is an abstract machine concept we are talking about.</p>",
        "id": 219886102,
        "sender_full_name": "RalfJ",
        "timestamp": 1607972221
    },
    {
        "content": "<p>ah right, that's the problem with UB style formalization: since it's a negative property, you can't have a gap between what the compiler can reason about and what is language UB. If the compiler is allowed to say no even on some programs with no UB then you have some more flexibility</p>",
        "id": 219886655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607972453
    },
    {
        "content": "<p>i.e. the compiler says \"I was not able to ensure this program has no UB, please add assertions here and there and then I will think about compiling your code\"</p>",
        "id": 219886762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607972516
    },
    {
        "content": "<p>and the assertions are what actually change the operational semantics and introduce the necessary UB</p>",
        "id": 219887012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607972624
    },
    {
        "content": "<p>but that's all ivory tower stuff again</p>",
        "id": 219889012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607973552
    },
    {
        "content": "<p>Cranelift by default doesn't optimize memory operations. It does have a way to explicitly assert that loads/stores are aligned, don't trap or for loads that the loaded memory is constant during the execution of the current function though. While this is slightly different from your proposal (assume no UB vs erroring when absence of UB couldn't be proved) either way you have to explicitly add UB to your program.</p>",
        "id": 219892177,
        "sender_full_name": "bjorn3",
        "timestamp": 1607974843
    },
    {
        "content": "<p>I don't think that has anything to do with UB being negative</p>",
        "id": 219901749,
        "sender_full_name": "RalfJ",
        "timestamp": 1607979853
    },
    {
        "content": "<p>taking a negation doesn't change anything about the cyclicity^^</p>",
        "id": 219901764,
        "sender_full_name": "RalfJ",
        "timestamp": 1607979862
    },
    {
        "content": "<p>btw, one thing I am still wondering about <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> -- which of the three optimizations do you want to drop? it's one thing to say \"memory shouldnt have provenance\", but you'll still need to pick 2 (or fewer) out of 3 optimizations that you can make valid in this model. this is a fundamental choice each model will have to make (and we can categorize the models in 3 groups using this)</p>",
        "id": 219901975,
        "sender_full_name": "RalfJ",
        "timestamp": 1607979965
    },
    {
        "content": "<p>I think this framing is begging the question a bit, but to first approximation I would say the third one would be rejected because the reasoning that was used to get the first optimization would retain enough information to not make it look like q was never written to in the third optimization</p>",
        "id": 219902340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607980158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219884719\">said</a>:</p>\n<blockquote>\n<p>in fact people have already written functions like</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Returns a pointer with the provenance of `prov` pointing to `addr`.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">copy_provenance</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">addr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">prov</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>How do you write that function without offsetting from one pointer into a different allocation?</p>",
        "id": 219911475,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607984889
    },
    {
        "content": "<p>You wouldn't, but using <code>.wrapping_offset</code> is defined for that.</p>",
        "id": 219911923,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607985151
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">copy_provenance</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">addr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"n\">prov</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span>-&gt;<span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">prov</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">((</span><span class=\"n\">prov</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Would be a definition of that (which notably does not use any unsafe)</p>",
        "id": 219912142,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607985257
    },
    {
        "content": "<p>In a world where provenance exists, how is that pointer usable?</p>",
        "id": 219912271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985348
    },
    {
        "content": "<p>It would be useable iff addr points within the provenance of prov.</p>",
        "id": 219912363,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607985395
    },
    {
        "content": "<p>(there we go. Don't mind me failing to write rust properly)</p>",
        "id": 219912546,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607985486
    },
    {
        "content": "<p>Perhaps prov is from <code>sl.as_ptr()</code>, and addr is <code>&amp;mut sl[0] as *mut T</code>, where <code>sl</code> has type <code>&amp;mut [T]</code></p>",
        "id": 219912673,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607985596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219912673\">said</a>:</p>\n<blockquote>\n<p>Perhaps prov is from <code>sl.as_ptr()</code>, and addr is <code>&amp;mut sl[0] as *mut T</code>, where <code>sl</code> has type <code>&amp;mut [T]</code></p>\n</blockquote>\n<p>Do those not have the same provenance? They come from the same allocation.</p>",
        "id": 219913043,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985797
    },
    {
        "content": "<p>Or am I misunderstanding something?</p>",
        "id": 219913068,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985809
    },
    {
        "content": "<p>No, one only has \"access\" to the first element of the slice whereas as_ptr gives you access to the whole slice (at least by my understanding)</p>",
        "id": 219913388,
        "sender_full_name": "simulacrum",
        "timestamp": 1607986003
    },
    {
        "content": "<p>Indeed, under a strict interpretation of stacked borrows.</p>",
        "id": 219913685,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607986166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219902340\">said</a>:</p>\n<blockquote>\n<p>I think this framing is begging the question a bit, but to first approximation I would say the third one would be rejected because the reasoning that was used to get the first optimization would retain enough information to not make it look like q was never written to in the third optimization</p>\n</blockquote>\n<p>I dont think this is begging any question, these are just three transformations and for each of them an abstract machine def.n has to answer \"is this correct, yes or no\". that's the point of having a precise def.n.</p>\n<p>I meant the first optimization <em>exactly as shown</em>, not some variant of the optimization that adds anything extra to \"preserve something\". that's a different optimization. once you start changing the optimizations, it's easy to make all three of them correct.</p>",
        "id": 219956167,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219913043\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219912673\">said</a>:</p>\n<blockquote>\n<p>Perhaps prov is from <code>sl.as_ptr()</code>, and addr is <code>&amp;mut sl[0] as *mut T</code>, where <code>sl</code> has type <code>&amp;mut [T]</code></p>\n</blockquote>\n<p>Do those not have the same provenance? They come from the same allocation.</p>\n</blockquote>\n<p>they have the same provenance is C, but not in Stacked Borrows</p>",
        "id": 219956229,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025916
    },
    {
        "content": "<blockquote>\n<p>I meant the first optimization exactly as shown, not some variant of the optimization that adds anything extra to \"preserve something\".</p>\n</blockquote>\n<p>The problem with \"exactly as shown\" in your examples in the blog post is that they are written in C and two of those programs would be UB in C</p>",
        "id": 219956393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608025998
    },
    {
        "content": "<p>I charitably interpret the optimizations to be working on some IR, and on that IR I'm saying there would be operations introduced in the first optimization, not shown in the example because they aren't representable in C anyway, that would block the third optimization</p>",
        "id": 219956522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026069
    },
    {
        "content": "<p>Put more precisely, the way I resolve the issue with GVN style optimizations that transform <code>if p == q { f(p) }</code> to <code>if p == q { f(q) }</code> is that at the source level these are not equivalent because they have different inferred preconditions even though they are the same operation. That is, the first one elaborates to IR that looks like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">usable</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and GVN can rewrite this to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">usable</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or perhaps</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">usable</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"w\"> </span><span class=\"n\">via</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">equality</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but this is not the same as the result of the rewritten source program <code>if p == q { f(q) }</code>, which obtains:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">usable</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It is possible for this version to be UB while the first two are not.</p>",
        "id": 219957255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219956393\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I meant the first optimization exactly as shown, not some variant of the optimization that adds anything extra to \"preserve something\".</p>\n</blockquote>\n<p>The problem with \"exactly as shown\" in your examples in the blog post is that they are written in C and two of those programs would be UB in C</p>\n</blockquote>\n<p>they are written in LLVM IR using C syntax</p>",
        "id": 219957333,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026537
    },
    {
        "content": "<p>I assume that syntax has equivalences in whatever language you are imagining</p>",
        "id": 219957356,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219956522\">said</a>:</p>\n<blockquote>\n<p>I charitably interpret the optimizations to be working on some IR, and on that IR I'm saying there would be operations introduced in the first optimization, not shown in the example because they aren't representable in C anyway, that would block the third optimization</p>\n</blockquote>\n<p>that's a different optimization. I explicitly mean the syntax to reflect everything that happens.</p>",
        "id": 219957388,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026581
    },
    {
        "content": "<p>if the IR has extra operations, it's easy to make up some syntax to represent them.</p>",
        "id": 219957433,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026599
    },
    {
        "content": "<p>I don't disagree that LLVM, with its current set of optimizations and representation for these concepts, is in a bind</p>",
        "id": 219957523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026643
    },
    {
        "content": "<p>okay so what you are saying later seems to be that the first optimization is not correct, i.e., integers have provenance <span aria-label=\"scared\" class=\"emoji emoji-1f628\" role=\"img\" title=\"scared\">:scared:</span></p>",
        "id": 219957551,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026660
    },
    {
        "content": "<p>because if integers did not have provenance, then any predicate holding for <code>p: uintptr_t</code> also holds for <code>q: uintptr_t</code> after we know that <code>p==q</code></p>",
        "id": 219957605,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026699
    },
    {
        "content": "<p>In the code snippets just shown, <code>p</code> and <code>q</code> are plain bit patterns</p>",
        "id": 219957638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219957638\">said</a>:</p>\n<blockquote>\n<p>In the code snippets just shown, <code>p</code> and <code>q</code> are plain bit patterns</p>\n</blockquote>\n<p>that's a contradiction to what you said before :)</p>",
        "id": 219957659,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026734
    },
    {
        "content": "<p>the provenance is all in the assertions</p>",
        "id": 219957664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026737
    },
    {
        "content": "<p>if they are plain bit patterns and <code>p == q</code>, then <code>pred(p)</code> implies <code>pred(q)</code></p>",
        "id": 219957683,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219957664\">said</a>:</p>\n<blockquote>\n<p>the provenance is all in the assertions</p>\n</blockquote>\n<p>I have no idea what that means. either the provenance affects UB, then it exists in the abstract machine, or it doesnt, then it is irrelevant for this discussion.</p>",
        "id": 219957749,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026786
    },
    {
        "content": "<p>Well, <code>p is usable here</code> is a more complex thing, that refers to the way that <code>p</code> was obtained in the function, i.e. what you would call provenance</p>",
        "id": 219957777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219957777\">said</a>:</p>\n<blockquote>\n<p>Well, <code>p is usable here</code> is a more complex thing, that refers to the way that <code>p</code> was obtained in the function, i.e. what you would call provenance</p>\n</blockquote>\n<p>but then integers do have provenance, in the abstract machine</p>",
        "id": 219957819,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026849
    },
    {
        "content": "<p>which makes e.g. <code>x-x</code> very different from <code>0</code></p>",
        "id": 219957828,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026856
    },
    {
        "content": "<p>No? Again, <code>p</code> is just a plain number</p>",
        "id": 219957855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026875
    },
    {
        "content": "<p>I think you are contradicting yourself, and this is somewhat obfuscated by your approach to a \"logic-based model\", but once you make that precise the contradiction will show itself plainly</p>",
        "id": 219957927,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026901
    },
    {
        "content": "<p>but if you rewrite <code>x-x</code> to <code>0</code> you might still have a lingering assertion that makes reference to the way that <code>x</code> was obtained</p>",
        "id": 219957940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026913
    },
    {
        "content": "<p>you cannot at the same time posit \"<code>p</code> is just a plain number\" and \"a predicate on <code>p</code>, like <code>usable(p)</code>, reflects the way that <code>p</code> was computed\"</p>",
        "id": 219957974,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026940
    },
    {
        "content": "<p>I just don't think of provenance as attached to values, and your persistence to that POV is making us talk past each other</p>",
        "id": 219957996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026952
    },
    {
        "content": "<p>it's not a predicate on p</p>",
        "id": 219958007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026961
    },
    {
        "content": "<p>or at least not only on p</p>",
        "id": 219958012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608026966
    },
    {
        "content": "<p>I only insist on formal precision / explicitness</p>",
        "id": 219958013,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026966
    },
    {
        "content": "<p>formally it's a points to predicate</p>",
        "id": 219958063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027001
    },
    {
        "content": "<p>which gets passed down through the control flow</p>",
        "id": 219958113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027012
    },
    {
        "content": "<p>this predicate will involve facts about the parenthood of <code>p</code> even if you rewrite all the <code>p</code>'s to <code>q</code>'s</p>",
        "id": 219958199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027096
    },
    {
        "content": "<p>because the parenthood of <code>p</code> is some set of other local variables in the function, not literally a predicate \"the set of all things that <code>p</code> was obtained from\"</p>",
        "id": 219958298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027150
    },
    {
        "content": "<p>because that's not something that you can define as a function of the bit pattern that is <code>p</code></p>",
        "id": 219958323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027169
    },
    {
        "content": "<p>well... whatever that means.^^<br>\nI appreciate that this is just a sketch in your mind and not fully worked out. I encourage you to boil this down to the bare minimum that is still interesting, and try to work it out in more formal detail. define the syntax of your language, define its semantics, define UB, see what makes an optimization \"correct\".</p>",
        "id": 219958395,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027222
    },
    {
        "content": "<p>I have a <a href=\"https://github.com/digama0/mm0/blob/master/mm0-rs/mmc.md\">language spec</a>, but it isn't really framed to answer this question, and the compiler isn't done yet so it's hard to demonstrate these details. I will see if I can write something self contained and more coherent</p>",
        "id": 219958834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027475
    },
    {
        "content": "<p>To solve a hard problem like this, you actually need to do something <em>fundamentally different</em>, not just have a more complicated syntax and a more complicated notion of UB that involves a logic of some sort. I currently lack the imagination for what that different thing might be, and it hasn't become clear in what you wrote so far. If this works, there must be a <em>key insight</em> that makes it work.</p>",
        "id": 219958896,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027506
    },
    {
        "content": "<p>An actual compiler is explicitly not required since these are all theoretical discussions ;)</p>",
        "id": 219958911,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027521
    },
    {
        "content": "<p>The <em>fundamental</em> difference in the language I'm working on is that the programmer collaborates with the compiler to make these proofs go through</p>",
        "id": 219958976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027581
    },
    {
        "content": "<p>the compiler doesn't just guess all the predicates based on UB ops</p>",
        "id": 219959038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219958834\">said</a>:</p>\n<blockquote>\n<p>I have a <a href=\"https://github.com/digama0/mm0/blob/master/mm0-rs/mmc.md\">language spec</a>, but it isn't really framed to answer this question, and the compiler isn't done yet so it's hard to demonstrate these details. I will see if I can write something self contained and more coherent</p>\n</blockquote>\n<p>my recommendation would be to boil this down to a bare minimum.  the goal is not to create a usable language, the goal is to break my claim of this being a fundamental tradeoff in language design. a single integer type and a single pointer type are more than enough for that, for example.</p>",
        "id": 219959055,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219958976\">said</a>:</p>\n<blockquote>\n<p>The <em>fundamental</em> difference in the language I'm working on is that the programmer collaborates with the compiler to make these proofs go through</p>\n</blockquote>\n<p>that's not a fundamental difference. UB is a way for the programmer to collaborate with the compiler, by offloading part of the proof burden from the compiler onto the programmer..<br>\nit's somewhat crude, but the issue at hand is not caused by the crudeness of the interface, I claim.</p>",
        "id": 219959125,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027684
    },
    {
        "content": "<p>well my goal is actually to create a usable language ^_^ but I appreciate that it's not the most appropriate reference for the current discussion</p>",
        "id": 219959152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219959152\">said</a>:</p>\n<blockquote>\n<p>well my goal is actually to create a usable language ^_^ but I appreciate that it's not the most appropriate reference for the current discussion</p>\n</blockquote>\n<p>That's great, too. :-)</p>",
        "id": 219959218,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027727
    },
    {
        "content": "<p>but it's also hard</p>",
        "id": 219959226,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027732
    },
    {
        "content": "<p>there's a reason that in academia, when we try fundamentally new things, we always use toy examples</p>",
        "id": 219959238,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027744
    },
    {
        "content": "<p>you might call it \"prototyping\"; proper engineers do it, too ;)</p>",
        "id": 219959268,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027770
    },
    {
        "content": "<p>In my case I need the language to write a program, so I need it to be usable, but only barely and only by me</p>",
        "id": 219959306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027793
    },
    {
        "content": "<p>hm, that seems like a goal that is orthogonal to this discussion then</p>",
        "id": 219959347,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027822
    },
    {
        "content": "<p>(which is fair, just pointing that out)</p>",
        "id": 219959359,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027831
    },
    {
        "content": "<p>well that's just to say that I am somewhere between \"toy\" and \"production language\"</p>",
        "id": 219959422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027862
    },
    {
        "content": "<p>a minimal language also makes it much easier for the likes of me that want to figure out your key new idea -- if the new idea is \"burried\" in the huge amount of details that are needed to make a proper language, I need to spend a <em>lot</em> of time to read things that are just not relevant for this discussion</p>",
        "id": 219959460,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027891
    },
    {
        "content": "<p>Quite so, don't try too hard to read that spec</p>",
        "id": 219959508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027921
    },
    {
        "content": "<p>;)</p>",
        "id": 219959533,
        "sender_full_name": "RalfJ",
        "timestamp": 1608027937
    },
    {
        "content": "<p>That's mostly intended as evidence that this is actually somewhat worked out</p>",
        "id": 219959536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027939
    },
    {
        "content": "<p>but it hasn't been packaged for consumption yet</p>",
        "id": 219959558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608027954
    },
    {
        "content": "<p>fair :)</p>",
        "id": 219959665,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028013
    },
    {
        "content": "<p>this makes me wonder about what your claim really is... you said yourself above that the \"way <code>p</code> was computed\" matters. so in whatever level this matters, there <em>is</em> provenance. I thought your claim was that you have \"the advantages of stacked borrows but without provenance\", did I misunderstand?</p>",
        "id": 219959969,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028215
    },
    {
        "content": "<p>The provenance information is still there, in the sense that you still have all these dereferenceable and non-aliasing predicates on things, but they exist in separate variables that are tracked alongside the real variables</p>",
        "id": 219960136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028328
    },
    {
        "content": "<p>In a lot of ways this is basically \"having provenance\", because you can have variables carrying assertions about portions of memory and so on</p>",
        "id": 219960209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028380
    },
    {
        "content": "<p>but when you go through an int-ptr cast, nothing really happens to the provenance variable alongside it, and if it can't be routed on the other end then the compiler rejects the code</p>",
        "id": 219960312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028433
    },
    {
        "content": "<p>so what is the advantage then? In your notes I see it's all about having proofs of functional correctness built into the language -- making that usable is some kind of a holy grail of PL. ;) but for a language like Rust, that doesn't require proof of functional correctness for <em>all code</em>, what does this mean?</p>",
        "id": 219960446,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028509
    },
    {
        "content": "<p>or rather, in rust's setting when the user does something with that variable on the other end the compiler inserts an assertion op that invents a provenance for a value lacking one</p>",
        "id": 219960451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219960451\">said</a>:</p>\n<blockquote>\n<p>or rather, in rust's setting when the user does something with that variable on the other end the compiler inserts an assertion op that invents a provenance for a value lacking one</p>\n</blockquote>\n<p>but in general the compiler has no way to tell where \"the other end\" is</p>",
        "id": 219960502,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028545
    },
    {
        "content": "<p>many things can be done to the integer after it was cast from the pointer and before it is cast back</p>",
        "id": 219960521,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028559
    },
    {
        "content": "<p>it's when you use a value that the compiler has no provenance for</p>",
        "id": 219960562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028564
    },
    {
        "content": "<p>right, so that's each int-to-ptr cast in the entire program (and potentially more)</p>",
        "id": 219960580,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028583
    },
    {
        "content": "<p>and it is impossible to figure out which ptr-to-int cast this \"matches up\" with</p>",
        "id": 219960591,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028593
    },
    {
        "content": "<p>yeah the compiler doesn't try to match them up except possibly in trivial cases</p>",
        "id": 219960643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028628
    },
    {
        "content": "<p>Im not talking about the compiler, Im talking about the spec / abstract machine</p>",
        "id": 219960661,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028645
    },
    {
        "content": "<p>in most cases it will just insert an assertion op, and the assertion op will cause the UB</p>",
        "id": 219960666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028649
    },
    {
        "content": "<p>I dont care about the compiler^^ that's a detail that needs to follow the abstract machine rules</p>",
        "id": 219960681,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028655
    },
    {
        "content": "<p>the AM doesn't care about any of this, it simply requires that all pointer derefs are valid with one of these provenance validity tokens</p>",
        "id": 219960780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028708
    },
    {
        "content": "<p>where does the provenance validity token come from in a ptr cast from an int?</p>",
        "id": 219960802,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028737
    },
    {
        "content": "<p>there's a reason that all formal semantics with provenance and int-ptr-casts end up having some form of \"broadcast\" / \"loss of provenance\" on a ptr-int-ptr roundtrip. You cannot avoid that without giving integers provenance.</p>",
        "id": 219960803,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028738
    },
    {
        "content": "<p>so the problem is recast as an elaboration problem, where the compiler inserts assertions when it is not smart enough to figure out the reference is okay</p>",
        "id": 219960822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028751
    },
    {
        "content": "<p>well, even with elaboration, the source language still has <em>some</em> behavior</p>",
        "id": 219960922,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028805
    },
    {
        "content": "<p>so saying \"elaboration\" doesn't help at all to explain how Rust behaves</p>",
        "id": 219960934,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028816
    },
    {
        "content": "<p>It is the same as how the semantics of rust are defined wrt the MIR, not the source</p>",
        "id": 219960973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028849
    },
    {
        "content": "<p>also making elaboration depend on \"how smart the compiler is\" is extremely fragile... how can I as a user reason about the behavior of my code in such a world?</p>",
        "id": 219960978,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219960973\">said</a>:</p>\n<blockquote>\n<p>It is the same as how the semantics of rust are defined wrt the MIR, not the source</p>\n</blockquote>\n<p>yes, but there the elaboration is structural and fairly simple. you said yours is \"smart\" in a magic and not-yet-specified way that somehow solves this problem. I claim that's impossible.</p>",
        "id": 219961039,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028892
    },
    {
        "content": "<p>I was waiting for that objection. :) My preference would be that the compiler never has to invent the assertions, they are all explicitly in the code, but that's a lot less backward compatible</p>",
        "id": 219961083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028922
    },
    {
        "content": "<p>that's basically saying int-to-ptr-casts are not supported</p>",
        "id": 219961159,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028953
    },
    {
        "content": "<p>How so? I think it's closer to saying int ptr casts always lose provenance</p>",
        "id": 219961219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608028998
    },
    {
        "content": "<p>instead of having <code>int_to_ptr&lt;T&gt;(usize) -&gt; *mut T</code>, you can then only have something like <code>int_to_ptr&lt;T&gt;(addr: usize, take_provenance_from: *mut T&gt;) -&gt; *mut T</code></p>",
        "id": 219961233,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029008
    },
    {
        "content": "<p>(I know you want to split the provenance from the ptr, but \"take_provenance_from\" lets us talk about this without introducing syntax for the split and I think it is otherwise equivalent, only more cumbersome -- but closer to the semantics we understand better)</p>",
        "id": 219961338,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029072
    },
    {
        "content": "<p>you can have <code>int_to_ptr</code> call this assertion op, and it's UB if the assertion cannot be obtained when it is called</p>",
        "id": 219961340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029073
    },
    {
        "content": "<p>it's UB if the compiler isn't smart enough to figure something out? uh... that seems basically unusable from a programmer perspective^^</p>",
        "id": 219961400,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029108
    },
    {
        "content": "<p>as a programemr I need clear rules to make sure my code is not UB</p>",
        "id": 219961425,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029124
    },
    {
        "content": "<p>no, I mean it's UB if at run time the proposition does not hold</p>",
        "id": 219961434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029132
    },
    {
        "content": "<p>in the AM</p>",
        "id": 219961445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029138
    },
    {
        "content": "<p>proposition? I thought we're talking about a Rust-like language, not your \"everything is verified\" language?</p>",
        "id": 219961473,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029159
    },
    {
        "content": "<p>I call it an assertion because it's a property that can fail</p>",
        "id": 219961566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029198
    },
    {
        "content": "<p>so, like <code>assume</code>?</p>",
        "id": 219961588,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029214
    },
    {
        "content": "<p>not really because this is probably not (easily) decidable</p>",
        "id": 219961611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029229
    },
    {
        "content": "<p>if you try to take out a reference and it's already borrowed then boom</p>",
        "id": 219961621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029235
    },
    {
        "content": "<p>undecidable UB? uh... I dont like that but let's ignore this for now^^</p>",
        "id": 219961638,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029251
    },
    {
        "content": "<p>so what does <code>int_to_ptr&lt;T&gt;(usize) -&gt; *mut T</code> elaborate to? concretely?</p>",
        "id": 219961659,
        "sender_full_name": "RalfJ",
        "timestamp": 1608029266
    },
    {
        "content": "<p>I haven't thought carefully about it but possibly something miri-esque can get pretty close to deciding it</p>",
        "id": 219961671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029277
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>fn int_to_ptr(x: usize) -&gt; *mut T {\n  let prov = obtain_provenance_for(x);\n  x as *mut T\n}\n</code></pre></div>\n<p>oh, actually the provenance is not really needed here, my mistake</p>",
        "id": 219961826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029385
    },
    {
        "content": "<p>this is just a cast</p>",
        "id": 219961844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029394
    },
    {
        "content": "<p>it's only when you use the pointer that a token is needed</p>",
        "id": 219961899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029405
    },
    {
        "content": "<p>For rust, I would expect references to come bundled with a token while pointers have nothing</p>",
        "id": 219961969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029454
    },
    {
        "content": "<p>which makes int-to-ptr trivial</p>",
        "id": 219961990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219961638\">said</a>:</p>\n<blockquote>\n<p>undecidable UB? uh... I dont like that but let's ignore this for now^^</p>\n</blockquote>\n<p>In my case I don't really care about undecidable UB because the aim is manually / semi-automatically routed proof tokens, but that's obviously a bridge too far for rust</p>",
        "id": 219962295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608029658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219961899\">said</a>:</p>\n<blockquote>\n<p>it's only when you use the pointer that a token is needed</p>\n</blockquote>\n<p>but where does the token come from, if the ptr was cast from an int? are you saying the usual code one would currently write for this in Rust is UB since I am not giving a token? That's what I mean with <code>int_to_ptr&lt;T&gt;(addr: usize, take_provenance_from: *mut T&gt;) -&gt; *mut T</code> above -- to model the intr-to-ptr cast we have currently, which <em>does</em> produce a usable pointer, we need to have a \"token input\" at the cast.<br>\nYou seem to be also adding a mostly useless token-free int-to-ptr cast; not sure what that is good for but it's not the int-to-ptr operation that Rust or C have so it shouldn't be called that.</p>",
        "id": 219965259,
        "sender_full_name": "RalfJ",
        "timestamp": 1608031428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219961990\">said</a>:</p>\n<blockquote>\n<p>which makes int-to-ptr trivial</p>\n</blockquote>\n<p>you just shifted the exact same problem to the ptr-to-reference cast.<br>\nI'd say let's assume a language which does not distinguish ptrs and references; that distinction is just a distraction.</p>",
        "id": 219965276,
        "sender_full_name": "RalfJ",
        "timestamp": 1608031440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219965276\">said</a>:</p>\n<blockquote>\n<p>you just shifted the exact same problem to the ptr-to-reference cast.<br>\nI'd say let's assume a language which does not distinguish ptrs and references; that distinction is just a distraction.</p>\n</blockquote>\n<p>That's fair, but the reason I prefer to draw the line at ptr-to-ref is because references have a rich source of lifetime information in the source, so it is much more feasible to not have to invent tokens all the time when working with them</p>",
        "id": 219966662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608032338
    },
    {
        "content": "<blockquote>\n<p>are you saying the usual code one would currently write for this in Rust is UB since I am not giving a token?</p>\n</blockquote>\n<p>For the usual rust code, the compiler would have to invent a token by inserting a <code>let prov = obtain_provenance_for(x, Raw);</code> operation, and this operation is equivalent to the effect of a read/write in SB: the compiler supplies some tag like <code>Raw</code> or <code>Uniq(other_prov)</code> containing the provenance information for this access, and this obtains the permission to read/write with the requested provenance</p>",
        "id": 219967136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608032662
    },
    {
        "content": "<p>Remark: You say to transpose everything from refs and pointers to pointers and integers, but in rust you can't write <code>ptr_to_ref</code> as a standalone function, unless the target has static lifetime or is otherwise unsound</p>",
        "id": 219967482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608032961
    },
    {
        "content": "<blockquote>\n<p>For the usual rust code, the compiler would have to invent a token by inserting a let prov = obtain_provenance_for(x, Raw); operation</p>\n</blockquote>\n<p>Stacked Borrows <em>already</em> says that the tag obtained on an int-to-ptr cast is <code>Raw</code>. But that does nothing to solve this problem.</p>",
        "id": 219967647,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033103
    },
    {
        "content": "<p>Yes, this part is not qualitatively different from SB</p>",
        "id": 219967715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608033127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219967482\">said</a>:</p>\n<blockquote>\n<p>Remark: You say to transpose everything from refs and pointers to pointers and integers, but in rust you can't write <code>ptr_to_ref</code> as a standalone function, unless the target has static lifetime or is otherwise unsound</p>\n</blockquote>\n<p>we're concerned with UB here though, not with soundness in the \"unknown safe code around us may do anything\" sense</p>",
        "id": 219967718,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033130
    },
    {
        "content": "<p>Yeah, I think my model might actually conflate those (which explains why it's not likely to be decidable)</p>",
        "id": 219967784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608033186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219967715\">said</a>:</p>\n<blockquote>\n<p>Yes, this part is not qualitatively different from SB</p>\n</blockquote>\n<p>so if that <code>Raw</code> tag permits access to memory locations that were previously subject to a ptr-to-int cast... then you still have all the problems that the blog post points out. and if it doesn't, the cast is basically useless.</p>",
        "id": 219967786,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033187
    },
    {
        "content": "<p>It seems this is closer to a program logic for unsafe rust functions. I think you can get something with a more global sense of UB where functions are allowed to get tokens they were not passed by getting them from a global store of tokens, but that's just a fancy way of saying \"provenance is in memory\"</p>",
        "id": 219967918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608033268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219967784\">said</a>:</p>\n<blockquote>\n<p>Yeah, I think my model might actually conflate those (which explains why it's not likely to be decidable)</p>\n</blockquote>\n<p>Yeah I got that feeling a few times as well, but... defining <em>soundness</em> precisely is a monumental task. My thesis shows what it takes, and it is far from complete or final in that regard. And moreover, usually soundness is defined <em>in terms of a preexisting notion of UB</em>, and I dont know how to break that cycle if you now want to define UB in terms of soundness.</p>",
        "id": 219967941,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033288
    },
    {
        "content": "<p>also I'd prefer the Rust spec to not require a PhD in PL theory to understand ;)</p>",
        "id": 219968171,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033445
    },
    {
        "content": "<p>It's not a cycle here since this is just a weird undecidable definition of UB that acts more like soundness than op.sem failure, it's not saying not-UB = sound directly. It's probably also not true that not-UB = sound here, although the gap is a lot smaller than normal</p>",
        "id": 219968188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608033457
    },
    {
        "content": "<p>but of course exploring that direction could still be interesting even if it might not be the best choice for Rust :)</p>",
        "id": 219968253,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219968188\">said</a>:</p>\n<blockquote>\n<p>It's not a cycle here since this is just a weird undecidable definition of UB that acts more like soundness than op.sem failure, it's not saying not-UB = sound directly. It's probably also not true that not-UB = sound here, although the gap is a lot smaller than normal</p>\n</blockquote>\n<p>yeah I think that's the thing I would like to see worked out in detail for a language with no more than 2 types whose grammar and op.sem fits on a napkin, so one can focus on the soundness/UB/opsem interaction without being bogged down by other details^^</p>",
        "id": 219968298,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219968171\">said</a>:</p>\n<blockquote>\n<p>also I'd prefer the Rust spec to not require a PhD in PL theory to understand ;)</p>\n</blockquote>\n<p>That's all a matter of presentation. I think Rust itself is a good example that shows that something that only PL researchers could dream of can become part of a mainstream language</p>",
        "id": 219968304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608033528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219968304\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219968171\">said</a>:</p>\n<blockquote>\n<p>also I'd prefer the Rust spec to not require a PhD in PL theory to understand ;)</p>\n</blockquote>\n<p>That's all a matter of presentation. I think Rust itself is a good example that shows that something that only PL researchers could dream of can become part of a mainstream language</p>\n</blockquote>\n<p>FWIW, Rust went well beyond the things PL researchers dreamed off. ;) <code>&amp;mut</code>, the way Niko made it, is a key innovation in Rust that was not described in the literature before (I think).<br>\nBut what Rust did is make this usable without people having to understand it. The entire point about unsafe code is people have to understand the rules it follows to be able to write correct code. <em>Those rules</em> are what I say should not require a PhD.</p>",
        "id": 219968485,
        "sender_full_name": "RalfJ",
        "timestamp": 1608033640
    },
    {
        "content": "<p>Certainly the language I'm working on is intended to be designed so that you can get by with an operational understanding of the compiler as a kind of souped up borrow checker. It is still an open problem how well random programmers will take to types that are so precise as to basically be proofs, but I am more hopeful than most in this area, having spent a lot of time teaching dependent type theory to newcomers. But this is certainly not something that I expect to slot into the rust language as it exists today.</p>",
        "id": 219968871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608033901
    },
    {
        "content": "<p>it's inspiring to see people have big dreams :)</p>",
        "id": 219969216,
        "sender_full_name": "RalfJ",
        "timestamp": 1608034110
    },
    {
        "content": "<p>Focusing only on the question of how this could affect today's rust, I think it may turn out that all the stuff about separate provenance doesn't really matter considering the interface rust programmers are given, and the only actual novelty may be some intrinsics for producing provenances that have been erased</p>",
        "id": 219969240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034129
    },
    {
        "content": "<p>If we have such intrinsics, then it becomes more palatable to just say that int to ptr casts are provenance erasing</p>",
        "id": 219969293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219969293\">said</a>:</p>\n<blockquote>\n<p>If we have such intrinsics, then it becomes more palatable to just say that int to ptr casts are provenance erasing</p>\n</blockquote>\n<p>by erasing you mean, the resulting ptr is unusable without explicitly attaching provenance to it?</p>",
        "id": 219969337,
        "sender_full_name": "RalfJ",
        "timestamp": 1608034200
    },
    {
        "content": "<p>(so that would be the unnamed \"option 4\" in my post: the original program has UB)</p>",
        "id": 219969393,
        "sender_full_name": "RalfJ",
        "timestamp": 1608034219
    },
    {
        "content": "<p>ah, you're right. If it makes the pointer invalid then we're making lots of code UB, and if the compiler inserts a validity assertion then it's being magic and the desugaring is hard to predict</p>",
        "id": 219969504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034313
    },
    {
        "content": "<p>I suppose it's not too magical to say that source level int-to-ptr inserts a validity assertion</p>",
        "id": 219969655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034405
    },
    {
        "content": "<p>oh but the source of the provenance has to be invented too, and that probably will be too magical</p>",
        "id": 219969759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034459
    },
    {
        "content": "<p>unless it's always <code>Raw</code> and then we have stock SB</p>",
        "id": 219969783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034480
    },
    {
        "content": "<p>Okay, so revised plan: it's always <code>Raw</code> when you use <code>as *mut T</code>, but you can use another operation like <code>copy_provenance_from()</code> if you want to have a nontrivial provenance</p>",
        "id": 219969969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034577
    },
    {
        "content": "<p>that might not even differ from the status quo, at least as far as rust + SB is concerned. LLVM is still miscompiling</p>",
        "id": 219970208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608034758
    },
    {
        "content": "<p>I have been thinking about something I wanted to do to optimize Cranelift ir after <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>'s idea of using permissions rather than provenance. Let's take the example from the blog post</p>\n<div class=\"codehilite\"><pre><span></span><code>ss_p = stack_slot explicit 1\nss_q = stack_slot explicit 1\n%zero = iconst.i8 0\nstore ss_p, %zero\nstore ss_q, %zero\n%p = ptr2int(stack_addr ss_p)\n%ip = iadd_imm %p, 1\n%iq = ptr2int(stack_addr ss_q)\n%eq = icmp %iq, %ip\nbr_false %eq, bb_end\n%ten = iconst.i8 10\nstore int2ptr(%iq), %ten\n%q_0 = stack_load.i8 ss_q\nbb_end:\n</code></pre></div>\n<p>What if we separate the \"provenance\" from the pointer itself.</p>\n<div class=\"codehilite\"><pre><span></span><code>ss_p = stack_slot explicit 1\nss_q = stack_slot explicit 1\n%zero = iconst.i8 0\nstore {ss_p} ss_p, %zero\nstore {ss_q} ss_q, %zero\n%p = stack_addr ss_p\n%ip = iadd_imm %p, 1\n%iq = stack_addr ss_q\n%eq = icmp %iq, %ip\nbr_false %eq, bb_end\n%ten = iconst.i8 10\nstore {ss_q} iq, %ten\n%q_0 = stack_load.i8 {ss_q} ss_q\nbb_end:\n</code></pre></div>\n<p>The first optimization would then turn it into:</p>\n<div class=\"codehilite\"><pre><span></span><code>ss_p = stack_slot explicit 1\nss_q = stack_slot explicit 1\n%zero = iconst.i8 0\nstore {ss_p} ss_p, %zero\nstore {ss_q} ss_q, %zero\n%p = stack_addr ss_p\n%ip = iadd_imm %p, 1\n%iq = stack_addr ss_q\n%eq = icmp %iq, %ip\nbr_false %eq, bb_end\n%ten = iconst.i8 10\nstore {ss_q} ip, %ten\n%q_0 = stack_load.i8 {ss_q} ss_q\nbb_end:\n</code></pre></div>\n<p>The second optimization would have no effect as there are no integer &lt;-&gt; pointer casts in this provenance less ir.</p>\n<p>The third optimization wouldn't fire as both the store and the load have the same permission.</p>\n<p>This idea could be further extended by allowing more than one permission to be specified for memory operations. If any alone would allow the operation, the operation is allowed. Next up we could have permission groups that can be passed to other functions. All permission groups passed to a function are disjoint. If multiple pointers can alias, they will have to either have their permissions in the same group or specify all relevant permission groups when performing actual memory operations on them. In addition there will be a way to split a permission or permission group into multiple disjoint permissions/permission groups. This would be necessary to for example model <code>foo(&amp;mut a.0, &amp;mut a.1)</code>. Any pointers whose address is taken will have the permission necessary to use them added to a permission group reserved for globals.</p>\n<p>I am curious if something like this would be capable of modeling stacked borrows.</p>",
        "id": 219974364,
        "sender_full_name": "bjorn3",
        "timestamp": 1608037192
    },
    {
        "content": "<p>Yes! This is what I meant earlier. You've rewritten <code>q</code> to <code>p</code>, but <code>ss_q</code> is still there so the third optimization is blocked.</p>\n<p>To support stacked borrows, you need the permissions to be essentially borrow stacks; you can create a new one by extending an existing borrow stack (which locks that one until the newly created borrow stack is dropped / goes out of scope / is invalidated by an access to the parent).</p>\n<p>However, as observed above, this entails difficulties when manufacturing permissions from nothing, which happens primarily in int-to-ptr casts. To support this you have to be able to borrow from a permission you were not given, and have obtained only by reading memory at some integer location. If you have borrow stacks stored in memory in order to enable the access, you get essentially the SB model.</p>\n<p>But I think this is fine; it means the only difference is that provenances are stored separately in virtual registers of the SSA, while memory still has provenance and you tuple the provenance with the address when you read or write memory.</p>",
        "id": 219976518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608038114
    },
    {
        "content": "<p>Int-to-ptr casts would use the globals permission group.</p>",
        "id": 219976932,
        "sender_full_name": "bjorn3",
        "timestamp": 1608038299
    },
    {
        "content": "<blockquote>\n<p>To support stacked borrows, you need the permissions to be essentially borrow stacks; you can create a new one by extending an existing borrow stack (which locks that one until the newly created borrow stack is dropped / goes out of scope / is invalidated by an access to the parent).</p>\n</blockquote>\n<p>That would be the way to split permission groups and merge permission groups when calling functions I talked about, right?</p>",
        "id": 219977191,
        "sender_full_name": "bjorn3",
        "timestamp": 1608038408
    },
    {
        "content": "<p>well you want the permissions to still have an SB-like structure to support the kind of alias analysis that rust does</p>",
        "id": 219977272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608038459
    },
    {
        "content": "<p>bags of permissions would work but would not be precise enough for SB</p>",
        "id": 219977323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608038488
    },
    {
        "content": "<p>I think doing a split where you ignore one half would be equivalent to pushing an item to the borrow stack.</p>",
        "id": 219977391,
        "sender_full_name": "bjorn3",
        "timestamp": 1608038523
    },
    {
        "content": "<p>Oh I see you mean split like a partial read permission</p>",
        "id": 219977473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608038560
    },
    {
        "content": "<p>I think that would work, although I recall the formal model in the SB paper having more bells and whistles than this so I might be forgetting something</p>",
        "id": 219977648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608038650
    },
    {
        "content": "<p>A split would take one permission group and create multiple new ones. You could say that certain permission groups only allow read access, while others allow both read and write access.</p>",
        "id": 219977719,
        "sender_full_name": "bjorn3",
        "timestamp": 1608038690
    },
    {
        "content": "<p>These should basically follow the same rules as the separation logic assertions in the SB paper</p>",
        "id": 219977974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608038823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/219977974\">said</a>:</p>\n<blockquote>\n<p>These should basically follow the same rules as the separation logic assertions in the SB paper</p>\n</blockquote>\n<p>there are no separation logic assertions in the SB paper?</p>",
        "id": 220091949,
        "sender_full_name": "RalfJ",
        "timestamp": 1608109883
    },
    {
        "content": "<blockquote>\n<p>What if we separate the \"provenance\" from the pointer itself.</p>\n</blockquote>\n<p>The tricky bit is figuring out the <code>ss_q</code> in the <code>store {ss_q} iq</code>, isn't it? in general you have no idea where that integer is coming from.<br>\nIf you have a \"wildcard\" group, then I don't see how this makes anything any easier than implicitly adding the wildcard like current compilers do.</p>",
        "id": 220092041,
        "sender_full_name": "RalfJ",
        "timestamp": 1608109932
    },
    {
        "content": "<p><code>ss_q</code> here is a permission that allows access to just the stack slot containing <code>q</code>.</p>",
        "id": 220094629,
        "sender_full_name": "bjorn3",
        "timestamp": 1608111679
    },
    {
        "content": "<p>In the general case getting the permissions could be done by taking an ir that does have provenance and then elaborating it to this permission based model.</p>",
        "id": 220094719,
        "sender_full_name": "bjorn3",
        "timestamp": 1608111738
    },
    {
        "content": "<p>Oops, I meant the rustbelt paper, specifically the lifetime rules on p.23 of <a href=\"https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf\">https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf</a></p>",
        "id": 220095117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608112055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220095117\">said</a>:</p>\n<blockquote>\n<p>Oops, I meant the rustbelt paper, specifically the lifetime rules on p.23 of <a href=\"https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf\">https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf</a></p>\n</blockquote>\n<p>those rules are for references only. raw pointers probably need to be much less restricted than that.</p>",
        "id": 220115667,
        "sender_full_name": "RalfJ",
        "timestamp": 1608125913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220094629\">said</a>:</p>\n<blockquote>\n<p><code>ss_q</code> here is a permission that allows access to just the stack slot containing <code>q</code>.</p>\n</blockquote>\n<p>FWIW, I think \"permission\" and \"provenance\" are entirely synonynmous at this point... or at least if there is a distinction I dont see it.^^ your main point seems to be about adding some APIs that treat provenance more explicitly, but that could be easily added to any provenance model I think.</p>",
        "id": 220115765,
        "sender_full_name": "RalfJ",
        "timestamp": 1608125991
    },
    {
        "content": "<p>The thing I dont understand is which problem this solves / what the goal here is.</p>\n<p>Colleagues of mine are working on C verification and they have a language where int-to-ptr cast works different: you need to also provide a pointer from which the provenance is taken. That's along the lines of what I proposed above when I tried to understand <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>'s approach. This makes int-to-ptr casts <em>strictly weaker</em> (there is no way to lower Rust or LLVM IR into this), and the benefit they get for paying this price is that there is no need to \"guess\" a provenance when casting an int back to a ptr, and there is no such thing as a ptr-int-ptr roundtrip (because there is no operation of type <code>int -&gt; ptr</code>) that could be handled incorrectly.</p>\n<p>But you said you can lower Rust/MIR/LLVM IR to your proposal, so this must be something different. My guess is that it helps against \"forgetting that provenance exists\" by making provenance more explicit, but doesn't actually make precisely defining the behvavior of int-to-ptr casts any easier?</p>",
        "id": 220116279,
        "sender_full_name": "RalfJ",
        "timestamp": 1608126276
    },
    {
        "content": "<p>Basically, I am asking, what does LLVM's <code>inttoptr</code> (or the MIR equivalent) lower to in your proposal?</p>",
        "id": 220116374,
        "sender_full_name": "RalfJ",
        "timestamp": 1608126359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220115667\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220095117\">said</a>:</p>\n<blockquote>\n<p>Oops, I meant the rustbelt paper, specifically the lifetime rules on p.23 of <a href=\"https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf\">https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf</a></p>\n</blockquote>\n<p>those rules are for references only. raw pointers probably need to be much less restricted than that.</p>\n</blockquote>\n<p>Well, as I mentioned at the start, I prefer to draw the line at ptr-to-ref for exactly this reason. The rules for ptr-to-int are trivial. Sure, we wouldn't be able to do that in C, but I'm not talking about C.</p>",
        "id": 220116777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608126555
    },
    {
        "content": "<p>I agree that getting a sane provenance system for C is very difficult exactly because the annotations are basically absent, so the compiler and the semantics have to invent all the borrowing structure without any information, and so you get these crazy nondeterministic uncheckable rules.</p>",
        "id": 220117063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608126707
    },
    {
        "content": "<p>The difference between provenance and the proposed permissions is that provenance is attached to pointers themself while permissions are attached to memory operations.</p>",
        "id": 220117073,
        "sender_full_name": "bjorn3",
        "timestamp": 1608126714
    },
    {
        "content": "<blockquote>\n<p>But you said you can lower Rust/MIR/LLVM IR to your proposal, so this must be something different. My guess is that it helps against \"forgetting that provenance exists\" by making provenance more explicit, but doesn't actually make precisely defining the behvavior of int-to-ptr casts any easier?</p>\n</blockquote>\n<p>While I have come around to the view that they aren't as different as I thought originally, I believe that there is an advantage for IRs to keep them separate because it makes it easier to perform transformations on the two parts separately, and avoid errors like GVN that think that the provenance is a function of the bit pattern, which we know is false. It's possible to retrofit this into an IR that assumes that pointer values have provenance baked in, as long as you have a <code>copy_provenance</code> operation, so perhaps that's a better path forward for things like LLVM, but I personally find it a lot easier not to fall into erroneous thinking when you keep them separate.</p>",
        "id": 220117618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608126967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220116374\">said</a>:</p>\n<blockquote>\n<p>Basically, I am asking, what does LLVM's <code>inttoptr</code> (or the MIR equivalent) lower to in your proposal?</p>\n</blockquote>\n<p>Regarding LLVM's <code>inttoptr</code> operation, assuming LLVM style pointer provenance, it depends on whether integers also have provenance. In the provenance language, if ints have provenance then inttoptr just keeps that provenance, and if they don't then it creates a wildcard provenance; in the permissions language then the cast is just a bit pattern cast and we use the permission associated to the int (if ints have provenance and this one has a permission), otherwise we invent a wildcard permission. (There isn't anything fundamentally different between the models here.)</p>",
        "id": 220118617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608127436
    },
    {
        "content": "<p>Actually I guess there is a difference if we only invent the permission at first use rather than when we create the pointer in the first place; I'm not sure what the C rules say about when the UB is actually triggered.</p>",
        "id": 220118967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608127589
    },
    {
        "content": "<p>Permissions are more flexible than provenance. With provenance you have to determine in advance when creating an ir what has and doesn't have provenance, while with permissions the frontend is free to choose whatever permissions it wants. Functions that don't read or write any external memory are easily modeled as functions that don't accept any permissions rather than as a special attribute. For WASM it would also be possible to only give the WASM access to the linear memory and nothing else, not even pointers that had a ptr2int operation on them by only passing a single permission for the linear memory and no other permissions.</p>",
        "id": 220127987,
        "sender_full_name": "bjorn3",
        "timestamp": 1608131791
    },
    {
        "content": "<p>I think the big question is what to do about \"invented\" permissions. These are necessary to model ptr2int operations in a LLVM compatible way, but they are basically unsound if you take a strict approach to permissions. It's possible to do quite a lot without them, e.g. replacing int2ptr with <code>copy_provenance</code> as Ralf mentioned, and possibly this is sufficient for WASM, but assuming that these are needed and should not always be trivially UB, you need some story for how to borrow permission from a variable in another stack frame or even another thread without an actual data dependency.</p>",
        "id": 220129420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608132468
    },
    {
        "content": "<p>Borrowing a permission from a parent stack frame is a matter of passing the permission to the function. Borrowing a permission from a child stack frame would not be allowed as all stack allocations are deallocated. Borrowing from another thread is a good question how to do.</p>",
        "id": 220129694,
        "sender_full_name": "bjorn3",
        "timestamp": 1608132595
    },
    {
        "content": "<p>the problem is that those all require explicit data dependencies, and essentially a modification of the code</p>",
        "id": 220129802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608132630
    },
    {
        "content": "<p>in other words, it's totally possible for a language to be built like this and be pretty expressive, but if you want to capture \"in the wild\" C/Rust/LLVM code this won't cut it</p>",
        "id": 220129894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608132676
    },
    {
        "content": "<p>This example <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/263\">https://github.com/rust-lang/unsafe-code-guidelines/issues/263</a> shows raw pointers being used to enable \"action at a distance\", where the permission in the parent is never passed to the child but it obtains the permission anyway via raw pointers</p>",
        "id": 220130366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608132890
    },
    {
        "content": "<blockquote>\n<p>It's possible to retrofit this into an IR that assumes that pointer values have provenance baked in</p>\n</blockquote>\n<p>It's not just about the IRs. <em>Surface Rust</em> has provenance baked in, so any IR that wants to do something different needs to work quite a bit to get there.</p>",
        "id": 220409793,
        "sender_full_name": "RalfJ",
        "timestamp": 1608315653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220117073\">said</a>:</p>\n<blockquote>\n<p>The difference between provenance and the proposed permissions is that provenance is attached to pointers themself while permissions are attached to memory operations.</p>\n</blockquote>\n<p>I don't know what you mean by this... <em>the entire point</em> of provenance is that we need something that's attached to the value. That's what makes the aliasing rules work.</p>",
        "id": 220409882,
        "sender_full_name": "RalfJ",
        "timestamp": 1608315716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>in the permissions language then the cast is just a bit pattern cast and we use the permission associated to the int (if ints have provenance and this one has a permission), otherwise we invent a wildcard permission. (There isn't anything fundamentally different between the models here.)</p>\n</blockquote>\n<p>that makes sense and reaffirms my believe that they are equivalent. \"permissions\" are just slightly desugaring some of the things that are implicit in provenance. which can be very helpful to avoid mistakes, but does not fundamentally make the problem any easier. it's just a potentially better API to the same thing.</p>",
        "id": 220410135,
        "sender_full_name": "RalfJ",
        "timestamp": 1608315836
    },
    {
        "content": "<p>With provenance you have the value of a pointer and the provenance bundled together. The idea with permissions is that you split both, so you can optimize the pointers as if they are integers, but memory operations take a permission as a separate input from the integer value of the pointer.</p>",
        "id": 220410241,
        "sender_full_name": "bjorn3",
        "timestamp": 1608315888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> seems to think of something else entirely and I am entirely lost there.</p>\n<blockquote>\n<p>With provenance you have to determine in advance when creating an ir what has and doesn't have provenance, while with permissions the frontend is free to choose whatever permissions it wants. </p>\n</blockquote>\n<p>?!? The set of possible permissions needs to be defined up-front when the IR is defined, how does this have anything to do with provenance? How would Miri check \"permissions\" if they are not fixed as part of the IR? I am totally lost.</p>",
        "id": 220410301,
        "sender_full_name": "RalfJ",
        "timestamp": 1608315930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220410241\">said</a>:</p>\n<blockquote>\n<p>With provenance you have the value of a pointer and the provenance bundled together. The idea with permissions is that you split both, so you can optimize the pointers as if they are integers, but memory operations take a permission as a separate input from the integer value of the pointer.</p>\n</blockquote>\n<p>well but you need to model a language (Rust) where the permissions associated with a pointer are carried along with the pointer value</p>",
        "id": 220410344,
        "sender_full_name": "RalfJ",
        "timestamp": 1608315958
    },
    {
        "content": "<p>so is this any different than just replacing <code>ptr</code> by <code>(address, provenance)</code> as part of the lowering?</p>",
        "id": 220410419,
        "sender_full_name": "RalfJ",
        "timestamp": 1608315982
    },
    {
        "content": "<p>The lowering is just that, yes</p>",
        "id": 220410452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608316008
    },
    {
        "content": "<p>but during optimization the two will diverge more</p>",
        "id": 220410466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608316021
    },
    {
        "content": "<p>that sounds like an interesting experiment, but it is pretty much exactly what formal models of provenance already do</p>",
        "id": 220410545,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316064
    },
    {
        "content": "<p>just more explicitly exposed on the IR level</p>",
        "id": 220410557,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316071
    },
    {
        "content": "<p>so, there's no fundamental difference then. just a more explicit account of provenance. I'm all for that, I am just confused by the claims that this would somehow make any problems go away.^^</p>",
        "id": 220410647,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316103
    },
    {
        "content": "<p>I think that a strategy such as the one I'm taking in my language can actually make the problems go away, but that solution is most likely not applicable to rust</p>",
        "id": 220410749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608316158
    },
    {
        "content": "<p>Because provenance and pointer addresses are no longer bundled together in the ir, it becomes valid to optimize the pointer address in ways that would normally be invalid because of differing provenance.</p>",
        "id": 220410762,
        "sender_full_name": "bjorn3",
        "timestamp": 1608316165
    },
    {
        "content": "<p>maybe what <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> meant above by \"not having to determine things in advance\" is that many places don't care what exactly the structure of the <code>provenance</code> component is? the same is true in provenance models, though. and some optimizations <em>do</em> care so you still need to fix it when precisely spec'in an IR.</p>",
        "id": 220410814,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220410749\">said</a>:</p>\n<blockquote>\n<p>I think that a strategy such as the one I'm taking in my language can actually make the problems go away, but that solution is most likely not applicable to rust</p>\n</blockquote>\n<p>if you push this explicit view of provenance all the way to the user, then maybe you can avoid even having a wildcard provenance. is that the point? I'd agree with that.</p>",
        "id": 220410920,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316237
    },
    {
        "content": "<p>yes, that's the idea</p>",
        "id": 220410945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608316247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220410945\">said</a>:</p>\n<blockquote>\n<p>yes, that's the idea</p>\n</blockquote>\n<p>as I mentioned, that's eactly what some colleagues are doing for C verification</p>",
        "id": 220410990,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316269
    },
    {
        "content": "<p>you allow the user to actually validate int-ptr casts</p>",
        "id": 220410993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608316269
    },
    {
        "content": "<p>the engineers agreed it is okay to have to annotate provenance on int-to-ptr casts</p>",
        "id": 220411022,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316282
    },
    {
        "content": "<p>I am confused by the term \"validate\" here, do you mean anything else than \"explicitly indicating the provenance\"?</p>",
        "id": 220411059,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316301
    },
    {
        "content": "<p>I often get the sentiment from C programmers that they don't <em>like</em> that the compiler is making all these assumptions and want to be more explicit about things. I'm sure I'm giving them far more than they asked for though :)</p>",
        "id": 220411149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608316338
    },
    {
        "content": "<p>oh right it's because of your built-in logic? you don't even have to go there for such a model though. you can do this in C, just remove int-to-ptr casts and replace them by a different API.</p>",
        "id": 220411165,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Can.20we.20do.20without.20provenance.3F/near/220410762\">said</a>:</p>\n<blockquote>\n<p>Because provenance and pointer addresses are no longer bundled together in the ir, it becomes valid to optimize the pointer address in ways that would normally be invalid because of differing provenance.</p>\n</blockquote>\n<p>Okay, I see. the \"end points\" of the trade-offs don't change (the optimizations from my blog post still behave the same way), but it becomes possible to explore more of the \"middle-ground\" with this extra flexibility/expressiveness and that could be useful.</p>",
        "id": 220411275,
        "sender_full_name": "RalfJ",
        "timestamp": 1608316423
    }
]