[
    {
        "content": "<p>At some point I want to jot down my thoughts on data invariants, starting with the basic invariants that layout optimizations rely on -- what are they, and when do they have to hold, etc. What would be the best place to submit that? one of our two UCG github repos, a blog post, or directly an RFC?</p>",
        "id": 131137092,
        "sender_full_name": "RalfJ",
        "timestamp": 1533768408
    },
    {
        "content": "<p>what do you mean? I'd say, given an object of type <code>T</code>, that object should always hold a value of type <code>T</code>. That seems like the place you'd want to be.</p>",
        "id": 131137471,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533769034
    },
    {
        "content": "<blockquote>\n<p>At some point I want to jot down my thoughts on data invariants, starting with the basic invariants that layout optimizations rely on -- what are they, and when do they have to hold, etc. What would be the best place to submit that? one of our two UCG github repos, a blog post, or directly an RFC?</p>\n</blockquote>\n<p>I think it makes sense to write up something in <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/\">https://github.com/rust-rfcs/unsafe-code-guidelines/</a></p>",
        "id": 131137913,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533769791
    },
    {
        "content": "<p>If we're considering data layout invariants, one possible thing to think about is whether we offer guarantees when correct bit-patterns happen to be written</p>",
        "id": 131138270,
        "sender_full_name": "alercah",
        "timestamp": 1533770360
    },
    {
        "content": "<p>e.g. is it okay to store a repr(rust) value on disk and read it back out to memory? do we offer guarantees that this works across identically defined types? across different compiler versions? can the compiler randomly reassign discriminants for enums every time the program runs?</p>",
        "id": 131138360,
        "sender_full_name": "alercah",
        "timestamp": 1533770501
    },
    {
        "content": "<p>So this is a question of ABI - I'd argue that ABI should only be guaranteed (at the _most_) on exactly one compiler version and definition</p>",
        "id": 131139088,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533771654
    },
    {
        "content": "<p>(We've broken ABI before)</p>",
        "id": 131139097,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533771667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> well that is an entirely cyclic definition. ;) You just said \"the invariant to be maintained for <code>T</code> is the invariant for <code>T</code>\".</p>",
        "id": 131155971,
        "sender_full_name": "RalfJ",
        "timestamp": 1533799865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123893\">@alercah</span> These are interesting questions but somewhat orthogonal. At this point, I am concerned with what the rules are once a particular data layout is fixed by the compiler.</p>",
        "id": 131156026,
        "sender_full_name": "RalfJ",
        "timestamp": 1533799944
    },
    {
        "content": "<p>So, what I am imagining is something like:<br>\nWhen it has to hold: The layout invariant must hold always; whenever you construct a value of type <code>T</code> (<code>transmute</code>, are there other operations we have to list) and whenever you <em>load</em> a value of type <code>T</code> (i.e., actually deref a place or use <code>ptr::read</code>).<br>\nHowever, the invariant is pretty basic. It might be a good idea to adapt the principle that data layout invariants are the kind of invariant that, when it holds once for a value, it will always hold. That excludes making \"<code>&amp;</code> is dereferencable\" part of the invariant (because that could hold once, but then stop holding when memory gets deallocated), but would otherwise be nice for reasoning.<br>\nSo e.g. my proposal for the data layout invariant for <code>&amp;T</code> would be that it must be non-NULL and aligned. For <code>bool</code> it must be <code>0</code> or <code>1</code>, I think that is quite clear. Another interesting question is what about integer types: Is it okay to have <code>undef</code>/<code>poison</code> in an <code>i32</code>? For unions, I think the invariant should allow anything but <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> thinks we should have some invariant even here. Trait object pointers must have a valid vtable. And so on.</p>",
        "id": 131156238,
        "sender_full_name": "RalfJ",
        "timestamp": 1533800379
    },
    {
        "content": "<p>The reason I think not putting \"dereferencable\" here is that this falls out of my aliasing model: Whenever you load a reference, it gets activated and retagged. That is UB if the reference is not dereferencable.</p>",
        "id": 131156351,
        "sender_full_name": "RalfJ",
        "timestamp": 1533800540
    },
    {
        "content": "<p>No, there's a difference between \"values\" and \"objects\"</p>",
        "id": 131175103,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533824331
    },
    {
        "content": "<p>it's like, the value 5 vs the box that 5 gets put in</p>",
        "id": 131175127,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533824370
    },
    {
        "content": "<p>I recommend the book Elements of Programming, it goes over all of this stuff</p>",
        "id": 131175239,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533824463
    },
    {
        "content": "<p>Like, here's an illustration of the idea:</p>\n<p>Given a builtin type <code>T</code>, there exists a set of valid values for <code>T</code>; for a <code>bool</code>, that would be <code>{true,  false}</code>, for <code>i32</code>, that would be <code>[-2**31, 2**31) ∩ ℤ</code>, etc.</p>\n<p>Given a <code>struct</code> or <code>tuple</code> (hereafter referred to as a product) type <code>T</code>, there exists a set of valid values for <code>T</code> which is constructed by taking the tuple of it's members - i.e., for <code>(bool, bool)</code> that would be the set <code>bool * bool</code>, or <code>{(true, true), (true, false), (false, true), (false, false)}</code></p>\n<p>(continued)</p>",
        "id": 131177514,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533826642
    },
    {
        "content": "<p>Given a <code>union</code> or <code>enum</code> type <code>T</code>, hereafter referred to as a sum type, there exists a set of valid values for <code>T</code> which is constructed by either<br>\n  - (for the <code>union</code>) taking the union of the values of the member types - i.e., <code>union { bool, i32 }</code> would be the set <code>{true, false} ∪ ([-2**31, 2**31) ∩ ℤ)</code>,<br>\n  - (for the <code>enum</code>)<br>\n    - given a mapping <code>nth_ctor : (ℕ ∩ [0, N)) → Type</code> (where <code>N</code> is the number of constructors for <code>T</code>)<br>\n    - which is defined as the map from the ctor index to the product type of that ctor<br>\n    - the valid values of <code>T</code> are the set <code>∪(i = 0 to N) {(i, v) | v ∈ nth_ctor(i)}</code></p>",
        "id": 131178500,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533827568
    },
    {
        "content": "<p>Let's call this map from the type to the set of its values, <code>val : Type -&gt; Set Value</code></p>\n<p>A <code>Bit</code> is the set of values <code>{X, 1, 0}</code>.</p>\n<p><code>⊑ : List Bit * List Bit -&gt; Bool</code> is defined: <code>x ⊑ y</code> if and only if<br>\n  - the lists have the same length, <code>N</code><br>\n  - for each index <code>n ∈ [0, N) ∩ ℕ</code><br>\n    - if <code>yₙ = 0</code>, then <code>xₙ = 0</code><br>\n    - if <code>yₙ = 1</code>, then <code>xₙ = 1</code><br>\n    - if <code>yₙ = X</code>, then <code>xₙ</code> can be any bit<br>\nNote: this relation has the effect of saying whether <code>x</code> has the same value as <code>y</code>.</p>\n<p>Then, there exists a mapping <code>bits : val(T) → (l: List Bit)</code> where <code>l</code> has size <code>size_of::&lt;T&gt;()</code> - note that there exists no guarantee of distinctness, due to references and unions.</p>\n<p>An object <code>o</code> with type <code>T</code> also has a list of <code>Bit</code>s (of size <code>size_of::&lt;T&gt;()</code>). Let's call this list <code>repr : Object -&gt; List Bit</code>. An object <code>o</code> with type <code>T</code> is valid if and only if <code>∃v : val(T) s.t. repr(o) ⊑ bits(v)</code>.</p>",
        "id": 131179491,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533828494
    },
    {
        "content": "<p>Not sure when I will have tome to digest all of this, but just one comment up front: The Box that you put 5 in is also a value. that value is a pointer/address/location in memory.<br>\nit is entirely unnecessary to talk about objects here. no objects appear anywhere in any of my formal models. or maybe you are just using \"object\" as a term for \"location in memory\"?</p>",
        "id": 131187763,
        "sender_full_name": "RalfJ",
        "timestamp": 1533837472
    },
    {
        "content": "<p>Yes, an object is a location in memory with space for a value. You have to separate them when discussing mutation</p>",
        "id": 131192344,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533842444
    },
    {
        "content": "<p>You also have things like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">((</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which do type punning on a single object.</p>\n<p>If you don't have locations with values in them, how do you have mutation?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p><code>x</code> is one location, but it has both <code>0</code> and <code>1</code> in it at different times.</p>",
        "id": 131192370,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1533842475
    },
    {
        "content": "<p>Yeah, this distinction becomes important if we think about where it is legal to have a pointer (which indicates a location) pointing to an invalid value.</p>",
        "id": 132006934,
        "sender_full_name": "alercah",
        "timestamp": 1534098913
    },
    {
        "content": "<p>If we're talking about bits as the set of valid values, then a 0 reference is definitely invalid. An unaligned reference should be invalid as well.</p>",
        "id": 132007021,
        "sender_full_name": "alercah",
        "timestamp": 1534099085
    },
    {
        "content": "<p>We could require raw pointers be aligned as well, but I don't think it makes a big difference one way or the other.</p>",
        "id": 132007024,
        "sender_full_name": "alercah",
        "timestamp": 1534099136
    },
    {
        "content": "<p>(also by \"0 reference\" I mean the null value, which may or may not be all-bits-0)</p>",
        "id": 132007039,
        "sender_full_name": "alercah",
        "timestamp": 1534099156
    },
    {
        "content": "<p>If we make it a data layout invariant that fields are <em>always</em> nonoverlapping (I mentioned this on github and have more thoughts on this: a compiler could pack, say, multiple <code>bool</code>s into one byte in a struct/array if it could prove that there was never any separate addressing of them. But this could just be done by the as-if rule anyway.), then any arbitrarily nested field can be referred to without necessarily needing the rest of the struct (or any nested one) to be valid.</p>",
        "id": 132007131,
        "sender_full_name": "alercah",
        "timestamp": 1534099324
    },
    {
        "content": "<p>Likewise individual fields can be loaded without requiring validity of the others.</p>",
        "id": 132007136,
        "sender_full_name": "alercah",
        "timestamp": 1534099336
    },
    {
        "content": "<p>I can't think of any inherent reason we need to think of structs as being valid or invalid in toto.</p>",
        "id": 132007145,
        "sender_full_name": "alercah",
        "timestamp": 1534099405
    },
    {
        "content": "<p>You can refer to them safely without any problems. You can even move them around, and you still don't actually run into any problems. As long as you don't try to actually access a field or do anything conditional on it, I don't think that we can have any issues there. The only thing I can think of is if the compiler does an oversize load <em>and</em> relies on the validity of the extra memory loaded to perform some tricky optimization (e.g. for a boolean, knowing that only one bit is set,  so ANDing against something you know has the bit cleared will always produce zeroes). I'm not sure if that is worth keeping the door open to.</p>",
        "id": 132007291,
        "sender_full_name": "alercah",
        "timestamp": 1534099721
    },
    {
        "content": "<p>Actually I guess the most likely case I can think of that is if I have, e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">enum</span> <span class=\"nc\">Singleton</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Variant</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Thing</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">s</span>: <span class=\"nc\">Singleton</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">some_size</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">Thing</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">5</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">91</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>The compiler here might rely on <code>t.s</code> necessarily having value 0 in order to do an oversized load and then compare to 0. If this is an optimization we permit, then we have to define loading at the entire struct level, so that accessing a field for a load also loads the rest of the struct.</p>",
        "id": 132007297,
        "sender_full_name": "alercah",
        "timestamp": 1534099759
    },
    {
        "content": "<p>But then that rapidly becomes complicated if we consider that the load might happen deep in some other function: if, say, we pass <code>&amp;t.b</code> into another function, and then that loads from it, could the compiler inline and then do the oversize load? What if raw pointers were involved?</p>\n<p>So my temptation here is to say that the compiler cannot rely on invariants in values in oversized loads.</p>",
        "id": 132007452,
        "sender_full_name": "alercah",
        "timestamp": 1534100124
    },
    {
        "content": "<p>Enum layout optimizations do prevent us from allowing <code>*p = v</code> where <code>v</code> is invalid, but I don't think that applies for a fully-owned value. So <code>ptr::read</code> could read an invalid value safely if we wanted?</p>",
        "id": 132007663,
        "sender_full_name": "alercah",
        "timestamp": 1534100563
    },
    {
        "content": "<p>(provided that the result's invalid fields were not conditioned on, ofc)</p>",
        "id": 132007670,
        "sender_full_name": "alercah",
        "timestamp": 1534100592
    },
    {
        "content": "<p>But that may prove untenable in practice? not sure</p>",
        "id": 132007825,
        "sender_full_name": "alercah",
        "timestamp": 1534100932
    },
    {
        "content": "<p>worth thinking about that, though</p>",
        "id": 132007827,
        "sender_full_name": "alercah",
        "timestamp": 1534100942
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> I think bringing up some kind of denotational semantics for values like you are doing here is entirely unnecessary. in fact, from all I know, it is an unsolved problem to scale this to higher-order imperative languages. you'd have to explain \"values\" that makes up the function space, and then you run into recursive domain equation that you cannot solve... and much later you end up with essentially something like logical relations, where you do not need that abstract set of values at all. but anyway that is entirely off-topic, all we are discussion here is basic data layout invariants.</p>",
        "id": 132659124,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056483
    },
    {
        "content": "<p>these invariants are on values represented in memory, i..e, sequences of bytes -- where a \"byte\" is the byte of an abstract machine that keeps track of extra state like whether something is initialized.</p>",
        "id": 132659149,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056520
    },
    {
        "content": "<blockquote>\n<p>If you don't have locations with values in them, how do you have mutation?</p>\n</blockquote>\n<p>oh, we totally have locations, and we have a memory that maps locations to bytes. I know C uses the term object for some of this, but I think it is rather confusing as we are not talking about OOP.</p>",
        "id": 132659221,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056568
    },
    {
        "content": "<p>also, we are unlikely to adopt C's extremely complicated object model. In LLVM, locations form a mostly \"flat\" address space -- separate allocations are distinguished, but you can do pointer arithmetic within an allocation across what C would call object boundaries</p>",
        "id": 132659254,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123893\">@alercah</span> every <code>bool</code> can have its address taken so you cannot really change how an individual bool looks</p>",
        "id": 132659281,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056669
    },
    {
        "content": "<p><code>(bool, bool)</code> must always be 2 bytes</p>",
        "id": 132659286,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056675
    },
    {
        "content": "<p>So, coming back to memory, locations and objects -- I am coming at this from the perspctive that before you do anything else, you should define your state. C never does that, and it's a horrible mistake. that state will likely have some big finite partial function <code>location -fin&gt; byte</code> -- where both <code>location</code> and <code>byte</code>  don't have to be the \"obvious\" choice. in a boring IR, you could pick <code>location = u64</code> and <code>byte = u8</code>. in miri, we have <code>location = (AllocId, Offset)</code> and <code>byte</code> basically an enum <code>Initialized(u8), Uninit</code>, except we add some extra stuff to be able to also store pointers in memory. so on paper I would use <code>byte = enum { Data(u8), Uninit, PtrFragment { ptr: location, idx: u8 }</code> where <code>PtrFragment(ptr, n)</code> represents byte <code>n</code> of a pointer. the only reason we do not have that in miri is performance.</p>",
        "id": 132659497,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056922
    },
    {
        "content": "<p>so then, based on that, the validity invariant is a predicate over <code>byte^n</code> -- and maybe it can also depend on the current state of memory.</p>",
        "id": 132659553,
        "sender_full_name": "RalfJ",
        "timestamp": 1535056970
    },
    {
        "content": "<p>How C does this is that functions are not object - in fact, Rust is the same way. A function is fundamentally different from an object. That's why we have <code>&amp;T</code> and <code>fn()</code></p>",
        "id": 132704491,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535127579
    },
    {
        "content": "<p>A function doesn't have a value in the classical sense, in systems languages</p>",
        "id": 132704550,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535127661
    },
    {
        "content": "<p>Also, \"object\" for \"location + value\" is a common wording in systems languages, and I feel it's unnecessary to reinvent the wheel when it comes to language here</p>",
        "id": 132704567,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535127701
    },
    {
        "content": "<p>location + value? as in, the value stored at that location?</p>",
        "id": 132707064,
        "sender_full_name": "RalfJ",
        "timestamp": 1535130831
    },
    {
        "content": "<p>however that only makes sense when you also consider types. otherwise you do not know how many bytes to consider.</p>",
        "id": 132707109,
        "sender_full_name": "RalfJ",
        "timestamp": 1535130850
    },
    {
        "content": "<p>and memory is better treated as inherently untyped.</p>",
        "id": 132707112,
        "sender_full_name": "RalfJ",
        "timestamp": 1535130858
    },
    {
        "content": "<p>Yea, but lvalues are inherently typed</p>",
        "id": 132709799,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535133663
    },
    {
        "content": "<p>hm, no, I dont think so. in miri we have <code>Place</code> and it is not typed by itself. we often carry it along with its type information, but the concept makes sense without types.</p>",
        "id": 132709933,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133774
    },
    {
        "content": "<p>well, a Place is an \"expression\", essentially, in some context, so you can compute its type?</p>",
        "id": 132709964,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535133821
    },
    {
        "content": "<p>I was talking about <code>miri::Place</code>, not <code>mir::Place</code></p>",
        "id": 132709974,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133836
    },
    {
        "content": "<p>or maybe miri means something distinct from MIR when you say <code>Place</code></p>",
        "id": 132709975,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535133837
    },
    {
        "content": "<p>i.e. the thing the expression computes to</p>",
        "id": 132709979,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133840
    },
    {
        "content": "<p>I see, ok</p>",
        "id": 132710016,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535133844
    },
    {
        "content": "<p>which is essentially a location + alignment + info for unsized stuff</p>",
        "id": 132710021,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133853
    },
    {
        "content": "<p>but to be fair I think we have hardly any use in miri for a place without a type</p>",
        "id": 132710035,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133880
    },
    {
        "content": "<p>but that's because places are an \"ephemeral\" concept -- they exist during evluation of a statement, but are not really part of the machine state</p>",
        "id": 132710047,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133900
    },
    {
        "content": "<p>so you're saying you have <code>void*</code> for all lvalues, and each read is <code>read(type, offset, lvalue)</code>?</p>",
        "id": 132710049,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535133901
    },
    {
        "content": "<p>or something along those lines?</p>",
        "id": 132710062,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535133908
    },
    {
        "content": "<p>when you want to actually read you need a size, yes. not a full type though.</p>",
        "id": 132710076,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133946
    },
    {
        "content": "<p>(miri needs a type for reasons that are only related to optimizations)</p>",
        "id": 132710082,
        "sender_full_name": "RalfJ",
        "timestamp": 1535133955
    },
    {
        "content": "<p>that seems like a very odd model</p>",
        "id": 132710159,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134002
    },
    {
        "content": "<p>values... should... be typed</p>",
        "id": 132710171,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134011
    },
    {
        "content": "<p>no I dont think so. types only matter when you are actually computing.</p>",
        "id": 132710211,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134055
    },
    {
        "content": "<p>and even then, I'd make <code>unsigned-mul</code> and <code>signed-mul</code> just different operations</p>",
        "id": 132710230,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134080
    },
    {
        "content": "<p>and then both can work on untyped bytes</p>",
        "id": 132710278,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134089
    },
    {
        "content": "<p>I... really dislike that model</p>",
        "id": 132710281,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134094
    },
    {
        "content": "<p>I think types are just making trouble on this level</p>",
        "id": 132710302,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134115
    },
    {
        "content": "<p>I don't agree at all</p>",
        "id": 132710314,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134126
    },
    {
        "content": "<p>types should be used to <em>reason about</em> program behavior, not to <em>define</em> program behavior</p>",
        "id": 132710319,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134132
    },
    {
        "content": "<p>but I appreciate that this is an opinion :)</p>",
        "id": 132710323,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134141
    },
    {
        "content": "<p>and I can live with types being used during the evaluation of a single expression -- as long as the machine state that is kept from one evaluation step to the next does not have types</p>",
        "id": 132710479,
        "sender_full_name": "RalfJ",
        "timestamp": 1535134281
    },
    {
        "content": "<p>I would argue that, for example, <code>fn () -&gt; i32</code> should actually return <code>i32</code> in the model, and not just \"4 bytes\"</p>",
        "id": 132710628,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134417
    },
    {
        "content": "<p>and similarly, that <code>fn (i32) -&gt; i32</code> should be callable only with <code>i32</code></p>",
        "id": 132710645,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134438
    },
    {
        "content": "<blockquote>\n<p>values... should... be typed</p>\n</blockquote>\n<p>I mean -- values can have multiple types, clearly... (union, transmute). So you have to reconcile for that at minimum. This does tend to lead you towards Ralf's POV</p>",
        "id": 132710647,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535134439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I very much disagree</p>",
        "id": 132710713,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134464
    },
    {
        "content": "<p>although <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'd still like to understand how transmute plays with the ref tracking in stacked borrows =)</p>",
        "id": 132710729,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535134481
    },
    {
        "content": "<p><code>union</code> and <code>transmute</code> do not have values of multiple types</p>",
        "id": 132710734,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134484
    },
    {
        "content": "<p><code>transmute</code> takes the object representation of one value, and gives you a value of a different type with the same object representation</p>",
        "id": 132710770,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134548
    },
    {
        "content": "<p>my favorite example where, imo, that kind of thinking breaks down, is with return values of struct type</p>\n<p>given a type <code>struct i64x2 { x: i64, y: i64 }</code>, and a function <code>fn f() -&gt; i64x2 { i64x2 { x: 0, y: 0 } }</code>, there _does_ exist a value of type <code>i64x2</code>, but there never exists an _object_ of type <code>i64x2</code></p>",
        "id": 132711107,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134870
    },
    {
        "content": "<p>(assuming x64 ABI)</p>",
        "id": 132711125,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134889
    },
    {
        "content": "<p>you don't ever actually have a <code>byte ^ 16</code> thing</p>",
        "id": 132711145,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535134913
    },
    {
        "content": "<p>ABIs are implementation details though, for language semantics it seems absolutely fine -- even desirable for simplicity -- that every function writes its result to a place that is passed in (and indeed this is how MIR currently works)</p>",
        "id": 132726543,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535155429
    },
    {
        "content": "<p>why is that more simple than \"returns a value\"</p>",
        "id": 132727047,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535156460
    },
    {
        "content": "<p>it is also true that computer hardware is not typed; so there is some advantage if you can map your model to types being something that the code \"adds\" to the base layer</p>",
        "id": 132728540,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535159310
    },
    {
        "content": "<p>although the mapping between this base layer and hardware is...suggestive at best, I suppose :)</p>",
        "id": 132728544,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535159330
    },
    {
        "content": "<p>I think <code>transmute</code> is just a NOP</p>",
        "id": 132741312,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187482
    },
    {
        "content": "<p>it copies bytes around, done</p>",
        "id": 132741320,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187488
    },
    {
        "content": "<p>that thing with struct return value is entirely a platform implementation detail</p>",
        "id": 132741322,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187523
    },
    {
        "content": "<p>as far as language spec is concerned, a place exists somewhere that is prepared by the caller, and where the callee writes this return value into</p>",
        "id": 132741328,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187545
    },
    {
        "content": "<p>and by \"write the return value\", I mean that it does <code>return_place.x = 0; return_place.y = 0;</code></p>",
        "id": 132741332,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187565
    },
    {
        "content": "<p>or <code>return_place = i64x2 { ... }</code> if we have aggregate creation as primitive (which IIRC MIR has)</p>",
        "id": 132741337,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187600
    },
    {
        "content": "<blockquote>\n<p>why is that more simple than \"returns a value\"</p>\n<p>why is that more simple than \"returns a value\"</p>\n</blockquote>\n<p>we do not need the concept of a \"value\".</p>",
        "id": 132741385,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187649
    },
    {
        "content": "<p>we have scalars, which is something we can immediately perform computation on; everything else just exists as place/operand in memory</p>",
        "id": 132741393,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> sorry it's not inherently simpler in itself, but it's one component (along with having places rather than just values in other parts of the language) of allowing us to avoid specifying validity for values, or more generally a really formalized denotational semantics</p>",
        "id": 132741398,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535187696
    },
    {
        "content": "<p>no need to invent a concept of a \"value\" which is something like \"a bunch of bytes, but not sitting in memory currently\"</p>",
        "id": 132741399,
        "sender_full_name": "RalfJ",
        "timestamp": 1535187700
    },
    {
        "content": "<p>I think the question is \"what is the purpose of the model\". If it's \"allow people to reason about their Rust\", I'd argue a typed semantics is far easier to reason about; if the question is \"allow us to reason about the Rust model\", then it might be better to have it be untyped. I personally think it's much easier to reason about unsafe code which has values and types, not buffers and invariants.</p>",
        "id": 132751978,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535209540
    },
    {
        "content": "<p>quite a few of the tricky questions that people writing unsafe/systems-y code ask are naturally about memory contents: can i type pun this buffer, is this layout compatible with C, can i read this uninitialized memory and do X with it, etc. so i don't really see how a typed-values-first approach will be automatically more natural</p>",
        "id": 132752149,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535209800
    },
    {
        "content": "<p>that's kind of the less interesting parts of unsafe code, imo</p>",
        "id": 132752212,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535209859
    },
    {
        "content": "<p>maybe it's just due to being in the C++ community, where we have a value based semantics and it's very useful (and fairly reasonable) to read the standard</p>",
        "id": 132752298,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535210000
    },
    {
        "content": "<p>it also more closely matches the actual machine, imo</p>",
        "id": 132752407,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535210169
    },
    {
        "content": "<p>we really aren't dealing with memory, most of the time; we're dealing with registers (which are different depending on type!)</p>",
        "id": 132752411,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535210195
    },
    {
        "content": "<p>i think this is a red herring, despite 90% of my compiler work dealing intimately with these sorts of Real Machine Widgets<br>\na language definition needs to <em>permit</em> efficient compilation, but it doesn't need to be very suggestive of that compilation strategy, especially since any analogy to real machines will likely be superficial anyway</p>",
        "id": 132752473,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535210292
    },
    {
        "content": "<p>aside: if one really wanted a language semantics tailored to register machines, it would be more useful to give up the pretense that certain kinds of values (e.g., condition codes, masks, <em>variable-length</em> vectors) can be stored in memory _at all_</p>",
        "id": 132752503,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535210372
    },
    {
        "content": "<p>sure</p>",
        "id": 132752540,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535210402
    },
    {
        "content": "<p>I don't disagree with that idea lol</p>",
        "id": 132752560,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535210425
    },
    {
        "content": "<p>also, obviously this is all opinion, and Ralf's model is also entirely valid; I just think a value-based model is easier to understand (due to being super familiar with them with C++)</p>",
        "id": 132753034,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535211397
    },
    {
        "content": "<blockquote>\n<p>maybe it's just due to being in the C++ community, where we have a value based semantics and it's very useful (and fairly reasonable) to read the standard</p>\n</blockquote>\n<p>You are the first person that I hear say such things about C++.^^ I consider the C++ standard to be huge and unreadable... and also fundamentally deficient because it is not written int he style of an \"abstract machine\". C++ is axiomatic, it essentially says \"I wish all these things to be true\" and then leaves it to others to figure out if, and how, that is possible.</p>\n<p>All the work for actually reasoning formally about low-level code that I am ware of (first and foremost, CompCert) uses an untyped memory. Types make it harder to define what your machine is, and a more complicated machine is more complicated to reason about.</p>",
        "id": 133111745,
        "sender_full_name": "RalfJ",
        "timestamp": 1535704958
    },
    {
        "content": "<p>So, I think the purpose of this exercise is to <em>define</em> Rust, and a definition should be (a) executable, written with some form of abstract machine in mind, because that's how people think about their programs, and (b) as simple as possible. The latter is crucially important also when reasoning about your code.</p>\n<p>Registers are entirely an implementation detail. No need to clutter our language definition with such concerns.</p>",
        "id": 133111860,
        "sender_full_name": "RalfJ",
        "timestamp": 1535705112
    },
    {
        "content": "<p>That said, I know plenty of people who consider axiomatic models useful and maybe even superior to the operational approach I am proposing. There is certainly a large amount of personal preference in there, and it probably also depends on what you are doing. However, the history of UB in C/C++ IMHO shows that having only an axiomatic definition is not sufficient -- clearly, the axiomatic definition of C/C++ did not really help programmers to determine if their code is UB; in fact, even compiler authors and academics struggle to make sense out of it. I think that is a piece of hard evidence against such an axiomatic approach.</p>",
        "id": 133111968,
        "sender_full_name": "RalfJ",
        "timestamp": 1535705258
    },
    {
        "content": "<p>Also see <a href=\"https://blog.regehr.org/archives/1520\" target=\"_blank\" title=\"https://blog.regehr.org/archives/1520\">John Regehr advocating an operational definition</a>, and <a href=\"https://lkml.org/lkml/2018/6/7/761\" target=\"_blank\" title=\"https://lkml.org/lkml/2018/6/7/761\">even Torvalds agrees</a>.<br>\nAnother piece of evidence is the story of weak memory models: Initially they were all axiomatic, but none of them managed to solve the \"out of thin air\" problem. one of the best contenders we have right now is the <a href=\"https://people.mpi-sws.org/~viktor/papers/popl2017-promising.pdf\" target=\"_blank\" title=\"https://people.mpi-sws.org/~viktor/papers/popl2017-promising.pdf\">first realistic *operational* model of relaxed memory</a>.</p>",
        "id": 133112047,
        "sender_full_name": "RalfJ",
        "timestamp": 1535705377
    },
    {
        "content": "<p>I am not debating that a higher-level view is useful for reasoning, that's why I am working on program logics for my PhD. ;) but the gold standard here is to <em>prove</em> that your value-based fiction is actually correct with respect to a more low-level operational semantics. Thus we end up with a semantics that is reasonably close to \"the real thing\" (where \"reasonable\" of course depends on your PoV^^) -- LLVM's memory is untyped and just a \"bunch of bytes\", which is important because we have to <em>trust</em> that the semantics match what really happens. And we still get high-level reasoning, but in a way that we know is sound because there is a proof connecting it to the low-level \"reality\" (just another model, of course, but hopefully one that is much easier to declare realistic).</p>",
        "id": 133112233,
        "sender_full_name": "RalfJ",
        "timestamp": 1535705581
    },
    {
        "content": "<p>In most of my work, when I am not interested in pointer arithmetic or layout concerns, we have a very high-level view of memory where the \"value\" you can store in a location can be arbitrarily big, contain nested sums and products and closures and whatnot. We put all the burden on implementing this on the compiler. But that is not so hard because there is no pointer arithmetic and no transmute, there is no way for the program to observe what the compiler is doing. But if you'd now want to also define, <em>in the same language</em>, what happens with byte-level accesses -- that's where I have yet to see a high-level model that I would actually trust to match actual program behavior. (And it is about trust here, this is the fundamental definition of the language and we do not have a verified compiler.) <a href=\"https://robbertkrebbers.nl/thesis.html\" target=\"_blank\" title=\"https://robbertkrebbers.nl/thesis.html\">Robbert Krebber's thesis</a> is the closest I know, and it is very far from \"simple\".</p>",
        "id": 133112448,
        "sender_full_name": "RalfJ",
        "timestamp": 1535705801
    },
    {
        "content": "<p>Sorry for the long rant, I felt I had to explain where I am coming from.^^</p>\n<p>Do you know of a <em>simple</em> explanation of C++'s value-based model? Simple means it easily fits onto a dozen pages or so, but should still support some amount of both byte-level and high-level operations and give a precise description of what is UB. All I hear from my peers is hardly anyone tried formalizing C++ because it is so complicated.</p>\n<p><a href=\"https://hal.inria.fr/hal-00703441/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-00703441/document\">Here's a rather simple but realistic untyped model for a subset of C</a>. \"Simple\" because it fits in a paper -- it's almost 3 dozen pages but it's also giving lots of background and related work and so on. And \"realistic\" because it is the one used by CompCert to compile plenty of actual C code. It even provides some facilities for concurrent execution (just with locks, but still).</p>",
        "id": 133112704,
        "sender_full_name": "RalfJ",
        "timestamp": 1535706082
    },
    {
        "content": "<p>(The fact that there is hardly any formal work on reasoning about C++ also seems to contradict your statement that C++'s definition is well-suited for reasoning.)</p>",
        "id": 133113288,
        "sender_full_name": "RalfJ",
        "timestamp": 1535706898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I thought the C++ spec was written against an abstract machine (from <a href=\"https://www.youtube.com/watch?v=KoqY50HSuQg\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=KoqY50HSuQg\">https://www.youtube.com/watch?v=KoqY50HSuQg</a> slide 18, I tried to retrieve the source directly but the page seems to have changed and I can't find it :/). Did something changed since that video or are you speaking of something else?</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"KoqY50HSuQg\" href=\"https://www.youtube.com/watch?v=KoqY50HSuQg\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=KoqY50HSuQg\"><img src=\"https://i.ytimg.com/vi/KoqY50HSuQg/default.jpg\"></a></div>",
        "id": 133126332,
        "sender_full_name": "Basile Desloges",
        "timestamp": 1535724491
    },
    {
        "content": "<p>The C++ standard, at least every edition I have seen so far, is written like the C standard</p>",
        "id": 133126577,
        "sender_full_name": "RalfJ",
        "timestamp": 1535724775
    },
    {
        "content": "<p>and that's as far away from an abstract machine as it gets</p>",
        "id": 133126582,
        "sender_full_name": "RalfJ",
        "timestamp": 1535724783
    },
    {
        "content": "<p>but if I am wrong with that, that'd be great :D</p>",
        "id": 133126589,
        "sender_full_name": "RalfJ",
        "timestamp": 1535724791
    },
    {
        "content": "<p>You mean the way the standard is written then? Maybe it <em>is</em> written against an abstract machine, but not very clearly :)</p>",
        "id": 133126610,
        "sender_full_name": "Basile Desloges",
        "timestamp": 1535724827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> may be referring to the difference between an axiomatic definition (list of guarantees, but without directly describing how the abstract machine behaves) and an operational definition (which directly gives you an algorithm you can execute)</p>",
        "id": 133126768,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535724997
    },
    {
        "content": "<p>Oh I see thanks. I think I didn't really understood the difference between those two :)</p>",
        "id": 133126869,
        "sender_full_name": "Basile Desloges",
        "timestamp": 1535725096
    },
    {
        "content": "<p>Well, I have not seen anything resembling a definition of an abstract machine, which starts by saying: here's the machine <em>state</em>, and then here's the possible execution steps and how they manipulate said state.</p>",
        "id": 133126899,
        "sender_full_name": "RalfJ",
        "timestamp": 1535725155
    },
    {
        "content": "<p>maybe the authors had an abstract machine in mind, but never told us about it. But for C, writing a conforming abstract machine didn't happen until &lt;5 years ago in academia (it's still not normative, and it's huge and almost unusable for reasoning or any other purpose, really; but it's a start). And C++ is much harder.</p>",
        "id": 133126916,
        "sender_full_name": "RalfJ",
        "timestamp": 1535725184
    },
    {
        "content": "<p>It's a very <em>abstract</em> abstract machine</p>",
        "id": 133130004,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1535728590
    },
    {
        "content": "<p>I don't mean reasoning in a \"you\" sort of way, I mean reasoning in a \"user\" sort of way. Also, LLVM doesn't have the model of untyped memory; it has a C++ style memory + values model?</p>",
        "id": 133134200,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535733659
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://hal.inria.fr/hal-00703441/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-00703441/document\">Here's a rather simple but realistic untyped model for a subset of C</a></p>\n</blockquote>\n<p>Nice citation.</p>",
        "id": 133134208,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535733669
    },
    {
        "content": "<p>Also, here's the base model of C++: <a href=\"http://eel.is/c++draft/basic.memobj\" target=\"_blank\" title=\"http://eel.is/c++draft/basic.memobj\">http://eel.is/c++draft/basic.memobj</a></p>",
        "id": 133134294,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535733793
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> I think reasoning in a \"user\" sort of way is misguided and likely incorrect if it cannot be put on solid formal foundations.</p>",
        "id": 133134301,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733818
    },
    {
        "content": "<p>and no from all I see in the lang ref, LLVM's memory is entirely untyped</p>",
        "id": 133134309,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733831
    },
    {
        "content": "<p>it doesnt \"remember\" at which type bytes were put unto it</p>",
        "id": 133134317,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733841
    },
    {
        "content": "<p>also all the formal models I have seen for LLVM use untyped memory</p>",
        "id": 133134358,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733866
    },
    {
        "content": "<p>whereas for C, Robbert Krebber's thesis is an example of a formal \"kind-of typed\"(?) memory. at least, structs and arrays are visible as such in memory.</p>",
        "id": 133134390,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733916
    },
    {
        "content": "<p>whereas for LLVM, structs and arrays are only relevant to compute the address of an access. memory is \"flat\".</p>",
        "id": 133134397,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733930
    },
    {
        "content": "<p>I will stash these C++ references somewhere for consumption after my vacation :)</p>",
        "id": 133134464,
        "sender_full_name": "RalfJ",
        "timestamp": 1535733979
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>define i32 @main() {\nstart:\n  %0 = i32 0\n  ret i32 %0\n}\n</pre></div>\n\n\n<p>^ note that <code>%0</code> has type <code>i32</code></p>",
        "id": 133134478,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535734000
    },
    {
        "content": "<p>_memory_ doesn't have a type, but _values_ do</p>",
        "id": 133134486,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535734017
    },
    {
        "content": "<p>(which is what I'm arguing for)</p>",
        "id": 133134615,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535734153
    },
    {
        "content": "<blockquote>\n<p>I don't mean reasoning in a \"you\" sort of way, I mean reasoning in a \"user\" sort of way. </p>\n</blockquote>\n<p>I'm a bit curious about this — my impression is that many unsafe code authors (myself included) would prefer to have an underlying \"untyped\" model that they can reason about. The farther things get from how the underlying computer works (or at least the simple abstaction we have for it), the more confusing things are. Witness e.g. the common attempt to disable type-based aliasing etc, because it is hard to figure out if code is obeying those rules.</p>\n<p>I don't have real data on this, of course, and you seem to have the exact opposite impression. I could easily imagine that there are people who have the reverse opinion. It might be interesting to take some \"case study\" examples that highlight the differences and try to see what falls about from thinking through them in both \"styles\". I'm not sure exactly what that means =)</p>",
        "id": 133135729,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535735390
    },
    {
        "content": "<blockquote>\n<p>_memory_ doesn't have a type, but _values_ do</p>\n</blockquote>\n<p>Well that's already much less typed than I thought you would advocate. :)<br>\nmy argument, then, is that the value on the types solely serves to select the right operation. <em>operations</em> are typed, because it makes a difference whether you multiply signed or unsigned integers.</p>",
        "id": 133135905,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735544
    },
    {
        "content": "<p>but depending on what you mean by \"values\", they do not even exist very long -- in miri, \"values\" only exist to be fed into operations</p>",
        "id": 133135933,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735579
    },
    {
        "content": "<p>but between two execution steps, there is no notion of a \"value\"</p>",
        "id": 133135950,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735593
    },
    {
        "content": "<p>there is memory (allocations containing bytes), and a stack where the local variables are also just an allocation ID saying where in memory this local is stored.</p>",
        "id": 133135965,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735628
    },
    {
        "content": "<p>so if the \"values\" you speak of are a mostly ephemeral concept, I think we are actually pretty close.</p>",
        "id": 133136019,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735648
    },
    {
        "content": "<p>however, we do not really need anything other than primitive types to type those values, as primitive operations only act on primitive types</p>",
        "id": 133136055,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> there is actually research that tries to find out what people <em>think</em> C is, that might be relevant... let me see if I can find it</p>",
        "id": 133136106,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735737
    },
    {
        "content": "<p>ah yes I think I've seen it</p>",
        "id": 133136119,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535735752
    },
    {
        "content": "<p>but would like to see it again :)</p>",
        "id": 133136122,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535735754
    },
    {
        "content": "<p>I think that would be <a href=\"https://www.cl.cam.ac.uk/~pes20/cerberus/notes50-survey-discussion.html\" target=\"_blank\" title=\"https://www.cl.cam.ac.uk/~pes20/cerberus/notes50-survey-discussion.html\">https://www.cl.cam.ac.uk/~pes20/cerberus/notes50-survey-discussion.html</a></p>",
        "id": 133136162,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735763
    },
    {
        "content": "<p>and more general the Cerberus project is a good source of C-related information: <a href=\"https://www.cl.cam.ac.uk/~pes20/papers/topics.html#Cerberus\" target=\"_blank\" title=\"https://www.cl.cam.ac.uk/~pes20/papers/topics.html#Cerberus\">https://www.cl.cam.ac.uk/~pes20/papers/topics.html#Cerberus</a></p>",
        "id": 133136189,
        "sender_full_name": "RalfJ",
        "timestamp": 1535735799
    },
    {
        "content": "<p>yeah, you only should care about the type of values when you're using them; in that case, you do need full nominal types, if only because <code>struct A { x: i32, y: f32 }</code> and <code>struct B { x: i32, y: f32 }</code> aren't guaranteed to be layed out the same</p>",
        "id": 133136666,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535736397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> my experience is with C++ people. C people are very different from C++ people, ime</p>",
        "id": 133136762,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535736536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> did you read my initial idea for a model &gt;.&lt;</p>",
        "id": 133136782,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535736575
    },
    {
        "content": "<p>I absolutely don't think that memory should be typed, and I've argued that we (in this case meaning the C++ community) should change the C++ model to have untyped memory as well</p>",
        "id": 133136850,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535736609
    },
    {
        "content": "<p>you never really do anything with \"value\" of struct type, other than copying them around, for which you only need the size. so those types are not actually relevant, all we need is size annotations at copy operations. the only place where we need full types is for primitive operations -- arithmetic and the like. (these types are extremely relevant for <em>layout</em> concerns, of course, but I see that as mostly separate -- layout fixes the offsets of all the fields; the main semantics and memory model then say what happens for a given assignment of offsets.)</p>\n<p>I have seen an idea for a model of yours last year, yes -- but I did not get very far understanding it. :/ it started out introducing a huge host of terminology, and I was lost in that jungle of definitions before it even really started.</p>",
        "id": 133147632,
        "sender_full_name": "RalfJ",
        "timestamp": 1535748451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> that's not necessarily true - for example, <code>Box&lt;T&gt;</code> should always be non-zero when it's a value</p>",
        "id": 133151388,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535753350
    },
    {
        "content": "<p>what, specifically, do you mean by \"when it's a value\"? in particular, what does that cover that isn't covered by a non-null invariant on the bytes in memory, asserted e.g. when it's loaded?</p>",
        "id": 133151458,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535753481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> that's exactly what I mean - <code>let x: Box&lt;i32&gt; = e;</code> &lt;- at the point when this statement is executed, <code>e</code> better evaluate to a non-null <code>Box&lt;i32&gt;</code> value</p>",
        "id": 133151573,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535753659
    },
    {
        "content": "<p>ok but that doesn't require defining values and deciding invariants for them, it seems to me you can just put enough things into memory that everything we care about is in memory at the time where we want to assert that it's valid</p>",
        "id": 133151762,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535753941
    },
    {
        "content": "<p>wha..?</p>",
        "id": 133151788,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535753997
    },
    {
        "content": "<p>however you want to put it, if you have <code>define void @foo(i32 * nonnull noalias)</code>, that <code>i32*</code> value has to be both nonnull and noalias; there is no memory there</p>",
        "id": 133151892,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754098
    },
    {
        "content": "<p>for example in <code>let PAT = EXPR;</code> evaluation of <code>EXPR</code> writes the result to a temporary memory locations, and the <code>let</code> copies parts of that into named (and possibly longer-lived) memory locations</p>",
        "id": 133151898,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754108
    },
    {
        "content": "<p>once again, whatever we do at the LLVM IR level doesn't need to impact the language memory model, we only need to be able to justify the optimizations done on LLVM IR (including those made by the translation to LLVM IR)</p>",
        "id": 133151960,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754174
    },
    {
        "content": "<p>I don't think everything being memcpy's is especially understandable or useful, rather than just having values; it also ignores the reality of stuff like <code>let x = &amp;prvalue-expression;</code>, imo</p>",
        "id": 133152037,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754269
    },
    {
        "content": "<p>there is another angle to this -- we'll likely represent Box&lt;T&gt; just like any primitive pointer (e.g. as a scalar in miri), and can therefore do everything with this scalar that we do with other primitives, without introducing any value for \"a struct containing a single pointer\"</p>",
        "id": 133152123,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754435
    },
    {
        "content": "<p>or in other words, keeping the data model of the abstract machine limited to \"scalars + untyped memory\"</p>",
        "id": 133152187,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> what about <code>Rc&lt;T&gt;</code>? What about some user-defined pointer type? what about <code>&amp;[T]</code>?</p>",
        "id": 133152215,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754572
    },
    {
        "content": "<p>the _language_ doesn't say anything about invariants of Rc, does it? beyond what follows from the components that library code uses to create Rc</p>",
        "id": 133152262,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754605
    },
    {
        "content": "<p>yes it does have invariants on Rc, that's what <code>std::ptr::Shared</code> is for</p>",
        "id": 133152271,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754637
    },
    {
        "content": "<p>that's what i meant with \"what follows from the components\"</p>",
        "id": 133152280,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754662
    },
    {
        "content": "<p>also idk what you mean with \"the reality of stuff like <code>let x = &amp;prvalue-expression;</code>\" -- pretty much by definition that has to place the result of the prvalue-expression into memory?</p>",
        "id": 133152296,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754705
    },
    {
        "content": "<p>it doesn't do any memory copies tho</p>",
        "id": 133152356,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754770
    },
    {
        "content": "<p>yes, what's the problem? just evaluate the expression into a longer-lived stack slot (living as long as <code>x</code>) than for temporaries that live shorter</p>",
        "id": 133152412,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754835
    },
    {
        "content": "<p>i'll also note, since you apparently care about proximity to the compiled code more than I do, that evaluating an aggregate will indeed directly write the fields to memory (unless the aggregate is very small), or at least it will once we have proper RVO/move forwarding on MIR</p>",
        "id": 133152480,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754914
    },
    {
        "content": "<p>yes, but it won't then copy it?</p>",
        "id": 133152489,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754936
    },
    {
        "content": "<p>it'll just write it to the stack slot</p>",
        "id": 133152499,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535754955
    },
    {
        "content": "<p>ok apparently we're talking past each other</p>",
        "id": 133152550,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535754984
    },
    {
        "content": "<p>when and where do you think i'm saying what exactly is copied?</p>",
        "id": 133152560,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755006
    },
    {
        "content": "<p>and if we don't have a model beyond \"builtins and untyped memory\", what happens to <code>struct X { y: Unique&lt;T&gt;, z: i32 }</code>? <code>fn foo(x: X)</code> _requires_ that <code>x.y</code> is non-null</p>",
        "id": 133152563,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755022
    },
    {
        "content": "<blockquote>\n<p>evaluation of EXPR writes the result to a temporary memory locations, and the let copies parts of that into named (and possibly longer-lived) memory locations</p>\n</blockquote>",
        "id": 133152581,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755068
    },
    {
        "content": "<p>oh i forgot i put it like that</p>",
        "id": 133152623,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755090
    },
    {
        "content": "<p>sorry</p>",
        "id": 133152624,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755092
    },
    {
        "content": "<p>we very clearly have a value of type <code>X</code> getting passed to <code>foo</code> - we don't suddenly pass a memory buffer just because it's a UDT</p>",
        "id": 133152648,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755154
    },
    {
        "content": "<p>i can only plead again to separate the rules we impose on the language from the implementation</p>",
        "id": 133152658,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755187
    },
    {
        "content": "<p>also at least if you add another i32 field we will, in fact, create LLVM IR that passes the aggregate in memory</p>",
        "id": 133152707,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755211
    },
    {
        "content": "<p>yes, the implementation would differ based on what ABI you're targeting</p>",
        "id": 133152708,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755212
    },
    {
        "content": "<p>you would literally pass a pointer to an <code>X</code> object on x86</p>",
        "id": 133152715,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755235
    },
    {
        "content": "<p>but that _should not_ come into it</p>",
        "id": 133152717,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755248
    },
    {
        "content": "<p>ok good, but then i am <em>really</em> confused about what you're arguing</p>",
        "id": 133152724,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755264
    },
    {
        "content": "<p>what's important is that, on the virtual machine, you're doing a load of an <code>X</code> value from memory, and that the invariants _must_ be valid</p>",
        "id": 133152741,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755299
    },
    {
        "content": "<p>wait i thought you were advocating that in this scenario there's only values, nothing involving memory, least of all a load</p>",
        "id": 133152788,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755330
    },
    {
        "content": "<p>I mean, it depends on what you pass? I was assuming that you were loading from the stack when you're passing, but I guess you could also pass an rvalue expression in which case no loads happen</p>",
        "id": 133152804,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755384
    },
    {
        "content": "<p>so that load you refer to would have happened in the caller, if at all?</p>",
        "id": 133152825,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755423
    },
    {
        "content": "<p>yep</p>",
        "id": 133152829,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755440
    },
    {
        "content": "<p>and the reason why <code>foo</code> can assume <code>x.z</code> is non-null is a definition of validity on <code>X</code> <em>values</em>, recursing into the fields?</p>",
        "id": 133152873,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755469
    },
    {
        "content": "<p>yes - if you have a value of type <code>T</code>, that value must be valid</p>",
        "id": 133152898,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755512
    },
    {
        "content": "<p>if it's invalid in some way, then you've got UB</p>",
        "id": 133152903,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755522
    },
    {
        "content": "<p>ok so for contrast: the <code>nonnull</code> attribute can be justified in an untyped-memory model if you put <code>X</code> in memory and pass it by reference (note: this is different from passing <code>&amp;X</code>!) -- you enforce the validity invariant for <code>X</code> on the memory of the argument on entry</p>",
        "id": 133153059,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755692
    },
    {
        "content": "<p>yes, but then you have a weird model where you're enforcing validity invariants \"at some points\"</p>",
        "id": 133153137,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755807
    },
    {
        "content": "<p>instead of at exactly one point - any time there's an rvalue conversion</p>",
        "id": 133153147,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535755831
    },
    {
        "content": "<p><code>noalias</code> gets into the stacked borrows proposal but there likewise you can recurse into memory you own (going through <code>&amp;_</code> is unlikely to fly for other reasons), you just have to do it \"on memory\" rather than having values that represent aggregates</p>",
        "id": 133153150,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755840
    },
    {
        "content": "<p>in a model where rvalues are so pervasive, surely operations on them could result in invalid rvalues? when do those trigger UB? (and how do you even represent them in the data model)</p>",
        "id": 133153165,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535755897
    },
    {
        "content": "<p>It makes it really clear why this code (<a href=\"#narrow/stream/136281-wg-unsafe-code-guidelines/subject/Accessing.20uninitialized.20field.20lvalues/near/133104916\" title=\"#narrow/stream/136281-wg-unsafe-code-guidelines/subject/Accessing.20uninitialized.20field.20lvalues/near/133104916\">https://rust-lang.zulipchat.com/#narrow/stream/136281-wg-unsafe-code-guidelines/subject/Accessing.20uninitialized.20field.20lvalues/near/133104916</a>) is valid -</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">alloc</span>::<span class=\"n\">alloc</span><span class=\"p\">(</span><span class=\"n\">layout</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">IdentifierInner</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">).</span><span class=\"n\">size</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buff</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts_mut</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">).</span><span class=\"n\">mut_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ch</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">nfc</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ch</span><span class=\"p\">.</span><span class=\"n\">encode_utf8</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">).</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">buff</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buff</span><span class=\"p\">[</span><span class=\"n\">offset</span><span class=\"p\">..];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>because you never do an rvalue conversion - <code>(*ptr).size</code> is an lvalue expression of type <code>u32</code>, and you immediately give that lvalue expression to an <code>&amp;mut</code> operator, which converts the lvalue T to an rvalue &amp;mut T. There's no read of the <code>T</code></p>",
        "id": 133153254,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756041
    },
    {
        "content": "<p>similarly with <code>buff[offset...]</code> - the lvalue expression is immediately passed to the <code>&amp;mut</code> operator</p>",
        "id": 133153301,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756074
    },
    {
        "content": "<p>\"there is no load of the u32 at <code>(*ptr).size</code>\" is also true and also relevant in the style of model ralf has developed</p>",
        "id": 133153374,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756175
    },
    {
        "content": "<p>yes, because you never do an rvalue conversion - that's the literal \"thing\" that happens in Rust</p>",
        "id": 133153391,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756225
    },
    {
        "content": "<p>it feels like you're just saying \"load\" when you mean \"rvalue conversion\", except we pretend that that load goes directly into memory in between. You could definitely lower Rust into these memory semantics, but it seems odd?</p>",
        "id": 133153443,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756284
    },
    {
        "content": "<p>in this example there's no interesting differences between scalars+memory vs values+objects, because everything's happening in terms of scalars (ints and slice references)</p>",
        "id": 133153466,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756366
    },
    {
        "content": "<p>and it means, imo, that you now have to do a mental lowering from Rust semantics to low-level memory semantics to figure out whether you're doing something bad, which seems unfortunate, as opposed to just using Rust semantics in the model definition.</p>",
        "id": 133153514,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756404
    },
    {
        "content": "<p>ok i see where you are going</p>",
        "id": 133153560,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756469
    },
    {
        "content": "<p>also, it's not operations on scalars - they're operations on <code>IdentifierInner</code></p>",
        "id": 133153569,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756489
    },
    {
        "content": "<p>the lvalue expressions are on an uninitialized <code>IdentifierInner</code>, which is what makes it interesting</p>",
        "id": 133153576,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756508
    },
    {
        "content": "<p>at least, imo</p>",
        "id": 133153632,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756580
    },
    {
        "content": "<p>i can't think of any projections through lvalues that we've ever wanted to consider UB?</p>",
        "id": 133153635,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756583
    },
    {
        "content": "<p>as in, expressions like <code>&amp;foo.bar</code> are at most interesting wrt pointer arithmetic and rules about the resulting reference (which may in turn imply a bit about <code>foo</code> though it turns out probably not), not wrt validity of <code>foo</code> in itself</p>",
        "id": 133153694,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756674
    },
    {
        "content": "<p>right, exactly - we're projecting through an lvalue, which is distinct from accessing an rvalue? does that make sense?</p>\n<p>like, the model in rust is that <code>&amp;foo.bar</code> is an lvalue expression, which is distinct from say, <code>bar(foo)</code> which is an rvalue expression</p>",
        "id": 133153703,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756703
    },
    {
        "content": "<p>it seems we're in violent agreement here, so moving on</p>",
        "id": 133153711,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756725
    },
    {
        "content": "<p>what? you can't disagree, that's literally the model in Rust</p>",
        "id": 133153716,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756749
    },
    {
        "content": "<p>that's how the typechecker works</p>",
        "id": 133153717,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756755
    },
    {
        "content": "<p>hahaha, fair</p>",
        "id": 133153758,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756769
    },
    {
        "content": "<p>oops, <em>agreement</em>, not disagreement!!</p>",
        "id": 133153759,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756769
    },
    {
        "content": "<p>that's not how this idiom works, brain</p>",
        "id": 133153761,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756784
    },
    {
        "content": "<p>so regarding your point about \"lowering\" rust locations and rvalues to memory accesses - YES that is exactly the point, taking it all much lower level and breaking it down into simpler operations so that the spec is simpler and can be implemented much more directly (as in miri)</p>",
        "id": 133153769,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756821
    },
    {
        "content": "<p>this does, as you say, place some burden on people looking at source code</p>",
        "id": 133153776,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756843
    },
    {
        "content": "<p>yeah - my interest is making it easier for people who are reading and writing source code, as opposed to those who are writing the spec</p>",
        "id": 133153780,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756868
    },
    {
        "content": "<p>it's not just easier on the spec writers, it's also easier on rustc and miri developers</p>",
        "id": 133153822,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756905
    },
    {
        "content": "<p>because it's literally how MIR works</p>",
        "id": 133153824,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756910
    },
    {
        "content": "<p>sure; they're not who I'm interested in making the lives of easier tho :)</p>",
        "id": 133153830,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535756930
    },
    {
        "content": "<p>ah but a better miri means you often won't have to manually reason your way through whether something is ub!</p>",
        "id": 133153852,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535756969
    },
    {
        "content": "<p>whether something is UB is a runtime property dependent on data</p>",
        "id": 133153914,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535757008
    },
    {
        "content": "<p>I doubt Miri's ability to solve the halting problem</p>",
        "id": 133153921,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535757027
    },
    {
        "content": "<p>very funny. many questions do boil down to a specific litmus test with only one or two relevant traces, though</p>",
        "id": 133153996,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535757187
    },
    {
        "content": "<p>such as your example from above -- the addresses and buffer length don't matter, you just run it once with one input, miri doesn't complain about accessing an unintialized <code>size</code>, and you're in the clear</p>",
        "id": 133154041,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535757244
    },
    {
        "content": "<p>one other thought -- it's not unheard of to have multiple specs in a different style and prove them equivalent (or give a sound mapping from one to another). if a c++ style model is significantly easier to reason about for programmers -- which i am still not really sure about -- it might nevertheless make sense for the UCG to produce a simple low-level spec, implement it in miri, etc. and (later) provide programmers with a c++ style explanation that is proven equivalent</p>\n<p>however there is a very real chance that there will be differences (possibly only in edge cases) between the natural way to formulate these two models. in any case we won't know this until someone (<em>cough</em>) sits down and writes out a concrete proposal to compare and contrast</p>",
        "id": 133154959,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535758905
    },
    {
        "content": "<p>it's possible <code>nfc</code> has a bug for specific characters, tho</p>",
        "id": 133155524,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535759962
    },
    {
        "content": "<p>or <code>size_utf8</code>, or <code>encode_utf8</code></p>",
        "id": 133155530,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535759980
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> that's not necessarily true - for example, <code>Box&lt;T&gt;</code> should always be non-zero when it's a value</p>\n</blockquote>\n<p>Fair. Lang items are primitive types.</p>",
        "id": 133168485,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789143
    },
    {
        "content": "<p>But this is just a validity invariant</p>",
        "id": 133168530,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789187
    },
    {
        "content": "<p>which applies every time you \"touch\" data -- so again, the type comes from the operation. Doing assignment at type <code>T</code>? Copy the bytes, and enforce that they form a valid <code>T</code>. Everything is still bytes.</p>",
        "id": 133168542,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789223
    },
    {
        "content": "<p>and I think passing values between functions through memory is a great way to side-step many annoying questions.</p>",
        "id": 133168603,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789357
    },
    {
        "content": "<p>arguments, on the caller side, are an <code>Operand</code>, and on the callee side a <code>Place</code>. so the most natural thing to do for argument passing is \"copy operand to place\", an operation we <em>have to define anyway</em>. This is also what happens in miri, btw.</p>",
        "id": 133168666,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789460
    },
    {
        "content": "<p>and every time we write anything to a place, that operation happens at a type. so we copy the bytes, and then enforce validity of them according to said type.</p>",
        "id": 133168673,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789501
    },
    {
        "content": "<p>(I plan to implement this in miri when I come back from my vacation)</p>",
        "id": 133168675,
        "sender_full_name": "RalfJ",
        "timestamp": 1535789515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> for the record, I have been trying to avoid lvalue and rvalue and prvalue and the roughly one dozen kinds of <code>*value</code> C++ has, because I find this huge amount of terminology very confusing. And in fact the people defining MIR seem to think the same way. So MIR has places, which roughly correspond to lvalues, and Operands, which roughly correspond to rvalues.</p>\n<p><code>(*ptr).size</code> is indeed a place, and then for argument passing there is a <code>_tmp = &amp;mut (*ptr).size</code> where <code>&amp;mut</code> is the operation defining how the place of the left is to be filled; in this case, it is with the location (and metadata) computed on the right. There is actually no <code>Operand</code>/rvalue anywhere in this expression. MIR does not allow nesting <code>&amp;mut</code> in other expressions, so we can avoid that complication. So indeed the data \"pointed to\" by the <code>Place</code> <code>(*ptr).size</code> is never touched, and does not have to be valid; just the place itself must be valid.</p>\n<p>I see no need to introduce compound values here.</p>",
        "id": 133168936,
        "sender_full_name": "RalfJ",
        "timestamp": 1535790046
    },
    {
        "content": "<blockquote>\n<p>yeah - my interest is making it easier for people who are reading and writing source code, as opposed to those who are writing the spec</p>\n</blockquote>\n<p>I think that is a luxury we can try to achieve once we have a spec. First of all, I disagree that a spec with compound values is easier for people who are reading and writing source code, except if you restrict yourself to safe code only where there is hardly ever any disagreement about what the code will do.<br>\nHowever, irrespective of that, given how hard it is to spec low-level languages, we should do everything we can to make the work simpler for the spec writers. Finally, given that the spec is <em>trusted</em> in the sense that any proof about any Rust program ever takes the spec as a given, and relies on the spec making sense, it is of paramount importance to make the spec as easy to read as we possibly can. Basically, everything the spec says should be immediately obviously sensible to anyone reading it, so that w can have as many eyes as possible on it. If we screw up the spec, the entire tower resting on top of it crumbles. the harder to read a spec is, the less useful it is as a foundation for a language.</p>",
        "id": 133169038,
        "sender_full_name": "RalfJ",
        "timestamp": 1535790260
    },
    {
        "content": "<p>(And with that I am leaving for my vacation, see you in two weeks!)</p>",
        "id": 133169397,
        "sender_full_name": "RalfJ",
        "timestamp": 1535791106
    },
    {
        "content": "<blockquote>\n<p>for example in <code>let PAT = EXPR;</code> evaluation of <code>EXPR</code> writes the result to a temporary memory locations, and the <code>let</code> copies parts of that into named (and possibly longer-lived) memory locations</p>\n</blockquote>\n<p>I just want to point that this is exactly how it is desugared in MIR. For a non-trivial pattern, we first store EXPR into a temporary and then \"move\" that temporary into <code>PAT</code>. For a trivial pattern like <code>x</code>, we store directly into the memory for <code>x</code>.</p>",
        "id": 133172570,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535797980
    },
    {
        "content": "<p>that last part is quite important though, and my not mentioning it has caused confusion, mea culpa</p>",
        "id": 133172658,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535798151
    },
    {
        "content": "<blockquote>\n<p>that last part is quite important though, and my not mentioning it has caused confusion, mea culpa</p>\n</blockquote>\n<p>it's just an optimization, though</p>",
        "id": 133172779,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798322
    },
    {
        "content": "<p>we just wanted to avoid a temporary</p>",
        "id": 133172781,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798338
    },
    {
        "content": "<p>I don't think it's significant in any other way?</p>",
        "id": 133172784,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798345
    },
    {
        "content": "<p>It's visible in cases like <a href=\"https://github.com/rust-lang/rust/issues/53695\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/53695\">#53695</a></p>",
        "id": 133172831,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1535798416
    },
    {
        "content": "<blockquote>\n<p>yeah - my interest is making it easier for people who are reading and writing source code, as opposed to those who are writing the spec</p>\n</blockquote>\n<p>ps, <span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span>, I strongly agree with this ambition! However, I am not sure what is the best way to achieve it.</p>\n<p>In particular, I think that it often happens that unsafe code authors start with a view of what they want the hardware to do, and then work <strong>up</strong> to how to express that in Rust. In this case, having the spec be expressed in terms of more low-level concepts is helpful.</p>",
        "id": 133172843,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798440
    },
    {
        "content": "<blockquote>\n<p>It's visible in cases like <a href=\"https://github.com/rust-lang/rust/issues/53695\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/53695\">#53695</a></p>\n</blockquote>\n<p>hmm, I suppose that's true.</p>",
        "id": 133172852,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798476
    },
    {
        "content": "<p>well, that depends</p>",
        "id": 133172853,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798482
    },
    {
        "content": "<p>but yeah it depends on when the \"pattern storing\" takes place, and I guess that most logically it would take place after the block's data has been dropped</p>",
        "id": 133172896,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798550
    },
    {
        "content": "<p>i meant it caused confusion about the mental model, or how we justify validating the scalar corresponding to <code>Box&lt;_&gt;</code> (that was the context in which i wrote that)</p>",
        "id": 133172899,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535798560
    },
    {
        "content": "<p>that's an interesting point <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> that perhaps affects my opinion about that issue :)</p>",
        "id": 133172900,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798577
    },
    {
        "content": "<blockquote>\n<p>i meant it caused confusion about the mental model, or how we justify validating the scalar corresponding to <code>Box&lt;_&gt;</code> (that was the context in which i wrote that)</p>\n</blockquote>\n<p>I don't see why</p>",
        "id": 133172903,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798585
    },
    {
        "content": "<p>in particular, in both cases, we are storing into memory?</p>",
        "id": 133172906,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798593
    },
    {
        "content": "<p>in one case, we store directly to the memory for the local varibale, in the other to a temporary?</p>",
        "id": 133172909,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798603
    },
    {
        "content": "<p>I guess I have to re-read that part of your discussion, I got a bit lost there</p>",
        "id": 133172911,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798611
    },
    {
        "content": "<p>anyway, I should go do weekend things too <span class=\"emoji emoji-1f3d6\" title=\"beach\">:beach:</span> :P</p>",
        "id": 133172912,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798620
    },
    {
        "content": "<p>hm yes, the core thing i missed was that we can and should validate scalars when storing, not just when loading</p>",
        "id": 133172960,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535798671
    },
    {
        "content": "<p>i was very incorrectly going with \"scalars are validated on loads\" and then the extra copy is significant</p>",
        "id": 133173033,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535798814
    },
    {
        "content": "<p>ah, I see, yes, that makes sense :)</p>",
        "id": 133173046,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798858
    },
    {
        "content": "<p>well, I may also be mistaken, it's worth keeping in mind, particularly seeing as MIR does this optimization</p>",
        "id": 133173096,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798939
    },
    {
        "content": "<p>(and I believe that our first efforts at defining UB semantics will probably begin from MIR)</p>",
        "id": 133173102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798953
    },
    {
        "content": "<p>though it of course means we have to define lowering into MIR to get a full round-trip</p>",
        "id": 133173106,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798965
    },
    {
        "content": "<p>but then we sort of need that anyway, because otherwise we can't really spec out the borrow checker</p>",
        "id": 133173109,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535798991
    },
    {
        "content": "<p>i think it makes sense to define all evaluation wrt to a destination location, and then speccing this behavior is just a matter of passing along the right destination location in various contexts</p>",
        "id": 133173162,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535799050
    },
    {
        "content": "<p>it makes sense to look at MIR construction here — we have a few different \"modes\" of evaluation ultimately</p>",
        "id": 133173289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799335
    },
    {
        "content": "<p>but maybe those can be viewed as optimizations</p>",
        "id": 133173290,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799358
    },
    {
        "content": "<p>(and we'd want to show then that they are valid)</p>",
        "id": 133173332,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799375
    },
    {
        "content": "<p>e.g., we don't make a temporary value for something like <code>foo(22)</code> =)</p>",
        "id": 133173333,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799387
    },
    {
        "content": "<p>still, it'd obviously be nice to keep the \"reference model\" as simple as possible</p>",
        "id": 133173342,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799425
    },
    {
        "content": "<p>(and — in the early days of MIR — we did make temporaries for all those cases...)</p>",
        "id": 133173346,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799437
    },
    {
        "content": "<blockquote>\n<p>it makes sense to look at MIR construction here — we have a few different \"modes\" of evaluation ultimately</p>\n</blockquote>\n<p>this is a very good point, i am actually tragically uninformed about mir construction</p>",
        "id": 133173348,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535799439
    },
    {
        "content": "<p>the main other one is evaluating to a \"place\"</p>",
        "id": 133173350,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799450
    },
    {
        "content": "<p>e.g. for things like <code>&amp;foo.bar</code></p>",
        "id": 133173354,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799458
    },
    {
        "content": "<p>in cases like <code>&amp;bar()</code> it creates a temporary and returns that</p>",
        "id": 133173356,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799471
    },
    {
        "content": "<p>ah but this is 1. crucial for the semantics and 2. based on a syntactic classification of place expressions vs value expressions, right?</p>",
        "id": 133173399,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535799508
    },
    {
        "content": "<p>yes</p>",
        "id": 133173400,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799516
    },
    {
        "content": "<p>I raised it because it is a distinction we cannot eliminate</p>",
        "id": 133173402,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535799530
    },
    {
        "content": "<p>ok enough of my edification, go do weekend things :)</p>",
        "id": 133173411,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1535799597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I absolutely disagree, I guess, on how people write unsafe code. as a C++ developer with access to a good standard, I do not go that way at all; I look at how to solve my problems in the abstract model of C++.</p>",
        "id": 133178370,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535809675
    },
    {
        "content": "<p>similar to most other people I know in the C++ community</p>",
        "id": 133178412,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535809693
    },
    {
        "content": "<p>and I want Rust to be that way. I don't want people to think \"oh, I want to have a tagged pointer, I should give myself a pointer type and then tag the bottom bits, because that is valid on the hardware\". I want someone to think \"oh, I should have a <code>usize</code> which can be cast to a pointer, because rvalue-conversion on an invalid pointer is suspect at best\"</p>",
        "id": 133178487,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535809829
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> for the record, I have been trying to avoid lvalue and rvalue and prvalue and the roughly one dozen kinds of <code>*value</code> C++ has, because I find this huge amount of terminology very confusing. And in fact the people defining MIR seem to think the same way. So MIR has places, which roughly correspond to lvalues, and Operands, which roughly correspond to rvalues.</p>\n<p><code>(*ptr).size</code> is indeed a place, and then for argument passing there is a <code>_tmp = &amp;mut (*ptr).size</code> where <code>&amp;mut</code> is the operation defining how the place of the left is to be filled; in this case, it is with the location (and metadata) computed on the right. There is actually no <code>Operand</code>/rvalue anywhere in this expression. MIR does not allow nesting <code>&amp;mut</code> in other expressions, so we can avoid that complication. So indeed the data \"pointed to\" by the <code>Place</code> <code>(*ptr).size</code> is never touched, and does not have to be valid; just the place itself must be valid.</p>\n<p>I see no need to introduce compound values here.</p>\n</blockquote>\n<p>It's really not that hard, and it's kind of necessary to understand for purposes of typechecking Rust. There are 3 kinds of values in C++, and two categories, but one of those value kinds is unnecessary in Rust, and so the categories don't need to exist either.</p>\n<p>There are two kinds of things, lvalues, and rvalues. An lvalue is any expression which refers to a specific place in memory, and you can only access one of these through the <code>*</code> or <code>[]</code> operators. An rvalue is any expression which is not an lvalue. An rvalue conversion is when you want an rvalue (for example, to initialize a stack-local) but all you have is an lvalue.</p>\n<p>(note: There are three kinds of lvalues - read, read-write, and owned.)</p>\n<p>This is why I say it's not that complicated, and also, you need to understand this stuff anyways if you want to understand some stuff that Rust does around Drop/non-Copy types, and lifetimes, so I think it's entirely valid to define a model in terms of these things that Rust programmers should inherently understand. We should not define the model in terms of MIR, a specific lowering of Rust _that changes_ depending on optimizations and versions of Rust. I want to know what a valid lowering of Rust to assembler is, which means we should define a model in terms of Rust.</p>",
        "id": 133178835,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1535810441
    },
    {
        "content": "<p>I will admit, I have skimmed a lot of this conversation. I'm starting to think that the ideal model is to try to think of a value-level semantics in a way that becomes easy to translate things upward.</p>\n<blockquote>\n<p>whether something is UB is a runtime property dependent on data</p>\n</blockquote>\n<p>This stood out to me, in part because it's true, but in particular because I feel like we generally do not want UB to be dependent on the compiler. It ought not be possible to argue that a given interaction is fine simply because the compiler lets it happen sometimes. Any purely hardware-based or representation-based semantics would allow that, I think.</p>\n<p>A purely object-value based semantics like C's and C++'s are also difficult, however, because they lead to a lot of confusion and disagreement and underspecifiedness.</p>",
        "id": 133412029,
        "sender_full_name": "alercah",
        "timestamp": 1536192874
    },
    {
        "content": "<p>So perhaps there's some middle ground where we could define a machine which is concrete enough to code and teach people by, but abstract enough not to let coincidences slip by? I guess my metric here would be \"could we theoretically write a run-time sanitizer for this\".</p>",
        "id": 133412720,
        "sender_full_name": "alercah",
        "timestamp": 1536193651
    },
    {
        "content": "<p>(I suspect the answer is that yes, we could do so, provided that the program doesn't move bytes outside the sanitizer's purview. But we could imagine a world where e.g. the VM's extra tagging could include the filesystem and networked applications and such. I think the same would apply to RalfJ's tags in the stacked borrowed model)</p>",
        "id": 133412879,
        "sender_full_name": "alercah",
        "timestamp": 1536193812
    },
    {
        "content": "<p>I had a nice conversation tonight with <span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> on Discord and I think I'm pretty much in agreement with her. The stuff I wrote above seems wrong at the edges, so please don't nitpick it too deeply. ;)</p>",
        "id": 133424265,
        "sender_full_name": "alercah",
        "timestamp": 1536214635
    },
    {
        "content": "<p>Although I just mean that about the stuff I wrote above. I'm unsure about lvalue/rvalue terminology, except to say that if we agree on the concepts then I'm not too concerned for now about the actual terms for them.</p>",
        "id": 133424315,
        "sender_full_name": "alercah",
        "timestamp": 1536214755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123893\">@alercah</span> link to conversation, perhaps?</p>",
        "id": 133432362,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1536227552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> it was in a private message</p>",
        "id": 133456206,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1536254370
    },
    {
        "content": "<p>(oh, nvm, already addressed)</p>",
        "id": 133581798,
        "sender_full_name": "alercah",
        "timestamp": 1536440649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> </p>\n<blockquote>\n<p>This is why I say it's not that complicated, and also, you need to understand this stuff anyways if you want to understand some stuff that Rust does around Drop/non-Copy types, and lifetimes, so I think it's entirely valid to define a model in terms of these things that Rust programmers should inherently understand. We should not define the model in terms of MIR, a specific lowering of Rust _that changes_ depending on optimizations and versions of Rust. I want to know what a valid lowering of Rust to assembler is, which means we should define a model in terms of Rust.</p>\n</blockquote>\n<p>Rust is way too high-level to be specified directly. Things like pattern matching, struct initializers and other complex compound expressions should be desugared to a core language. I think it is one of the big mistakes of C/C++ to not do this. For the same reason that compiling C, C++ or Rust directly to hardware is hard and full of redundancy, it is not a good idea to specify them directly. IRs are extremely useful as a specification device, not just as building block of a compiler. For example, the fact that miri can \"specify\" (implement, really) Rust behavior without any notion of \"read, read/write and owned\" values to me is a big sign saying that we do not actually need these notions to talk about Rust behavior.</p>\n<p>That core language does not have to be MIR, but I think something close to MIR is a pretty good choice.</p>",
        "id": 134117058,
        "sender_full_name": "RalfJ",
        "timestamp": 1537207663
    },
    {
        "content": "<blockquote>\n<p>An lvalue is any expression which refers to a specific place in memory, and you can only access one of these through the * or [] operators. An rvalue is any expression which is not an lvalue. </p>\n</blockquote>\n<p>Your notion of a \"value\" must be very far from mine. In my world (using the usual PL terminology), expressions <em>evaluate to values</em>, but most of the time they <em>are not</em> values. A value is a fully computed \"thing\" -- a number, or a memory location, or so. It is something static. An expression is a computation that results in a value, it is something dynamic (and then we can bikeshed about whether it can have sideffects or whether those are treated separately).</p>",
        "id": 134117197,
        "sender_full_name": "RalfJ",
        "timestamp": 1537207801
    },
    {
        "content": "<p>the key thing is that an \"lvalue\" is really not a value, but an expression</p>",
        "id": 134117836,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537208422
    },
    {
        "content": "<p>basically synonym for a MIR <code>Place</code></p>",
        "id": 134117850,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537208436
    },
    {
        "content": "<p>or at least that's how I think of it...</p>",
        "id": 134117881,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537208467
    },
    {
        "content": "<p>...I am not sure perhaps the C++ Spec has a distinct notion</p>",
        "id": 134117892,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537208492
    },
    {
        "content": "<p>an lvalue or place is not a source language expression, although it includes field accesses and indexing and so on just as source language expressions do, so it's confusing to call it \"expression\" IMO. i prefer to think of them as something analogous to values, though with more complicated structure than e.g. u32</p>",
        "id": 134118023,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1537208628
    },
    {
        "content": "<p>As a compiler user not author, I've always found the terms \"lvalue\" and \"rvalue\" extremely opaque and generally not useful. I don't know how much y'all want to try to stick to existing / established terms vs making it more accessible tho.</p>",
        "id": 134121060,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1537211716
    },
    {
        "content": "<p>you're right, they're crap terms. we've already moved to \"place\" instead of \"lvalue\" in compiler internal identifiers and the reference, and i think i'm not the only one who would prefer to follow up by calling \"rvalues\" simply \"values\"</p>",
        "id": 134121141,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1537211802
    },
    {
        "content": "<p>Still candidates for the hypothetical glossary I advocate for ;-)</p>",
        "id": 134124055,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1537215417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> the glossary isn't hypothetical! it's just...not totally filled out (but i stuck it in the mdbook because i want it too!)</p>",
        "id": 134130079,
        "sender_full_name": "avadacatavra",
        "timestamp": 1537222331
    },
    {
        "content": "<p>oh, neat... where might I find it?</p>",
        "id": 134130106,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1537222360
    },
    {
        "content": "<p>s/hypothetical/unknown to me/</p>",
        "id": 134130115,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1537222373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> they are definitely non-descriptive, and value/place are better terms.</p>",
        "id": 134140642,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1537237084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I just fundamentally disagree. You can write your models all you want, but what's useful to the average rust programmer is a model in terms of Rust, not a model in terms of an IR that is definitely not Rust.</p>",
        "id": 134140667,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1537237187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> </p>\n<blockquote>\n<p>i think i'm not the only one who would prefer to follow up by calling \"rvalues\" simply \"values\"</p>\n</blockquote>\n<p>MIR/miri call them \"operands\". Personally I find \"value\" a bit confusing there because operands can live in memory (in <code>x = y;</code>, when <code>y</code> is big, what is the value? we do a memcpy here, not a \"first load, then store\".<br>\nHowever, it is possible that this is just an optimization -- that we can see values as \"chunks of bytes\", and the fact that an operand \"delays\" the load is not actually observable. that would be a nice model indeed, I think, and then we can call them \"values\".</p>",
        "id": 134150522,
        "sender_full_name": "RalfJ",
        "timestamp": 1537255930
    },
    {
        "content": "<p>On the subject of places, I think the \"value\" content here is a memory address. that is more complicated than <code>u32</code> indeed, but not very much so. In miri, a place is a triple of a pointer, an expected alignment, and metadata for unsized places.</p>",
        "id": 134150546,
        "sender_full_name": "RalfJ",
        "timestamp": 1537256004
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> seems the glossary is at <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/reference/src/introduction.md\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/reference/src/introduction.md\">https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/reference/src/introduction.md</a>. Took me a bit to find it because the filename does not exactly give it away^^</p>",
        "id": 134150607,
        "sender_full_name": "RalfJ",
        "timestamp": 1537256086
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I just fundamentally disagree. You can write your models all you want, but what's useful to the average rust programmer is a model in terms of Rust, not a model in terms of an IR that is definitely not Rust.</p>\n</blockquote>\n<p>What I am arguing for is that the best and most useful way to describe a complicated thing is by describing it in terms of something simpler. Instead of doing one HUGE step -- a direct semantics for surface-level Rust -- we do two much smaller steps: A semantics for a language with few, easy to understand concepts; and a translation into that language. the translation takes care of concerns like evaluation order and other things I mentioned. I think this is much more useful to a programmer than a complex HUGE direct semantics, because there is actually a chance they might understand it. Sometimes, adding an intermediate abstraction provides an overall huge complexity <em>reduction</em> and thus makes things much easier to understand, and I strongly believe language semantics is one of these cases. A direct semantics for the surface language is near useless as it is too complex, not understandable.</p>\n<p>I see a bunch of evidence for this:</p>\n<ul>\n<li>C/C++ are baroque standards, where even experts can argue for days about corner cases. It's not just me who thinks an abstract machine with a simpler language would make a big difference here, see also e.g. <a href=\"https://lkml.org/lkml/2018/6/7/761\" target=\"_blank\" title=\"https://lkml.org/lkml/2018/6/7/761\">https://lkml.org/lkml/2018/6/7/761</a>.</li>\n<li>Compilers introduce IR (several IRs, usually). E.g., Rust got MIR because it was just really hard and error-prone to work with HIR as there are so many powerful language constructs there (and HIR already desugared some stuff, but not enough). Surface languages are not even suited for compiler authors to think about program behavior, that makes them even less suited to programmers less famililar with the language.</li>\n<li>The vast majority of formal research on real languages proceeds by extracting a core calculus, again because there is a huge amount of complexity reduction achieved when one can first translate individual complex statements to sequences of simple statements, and then describe how the individual simple statements work.</li>\n<li>There is precedence for this in a light form even for PL standards, e.g. JavaScript describes the <a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-if-statement\" target=\"_blank\" title=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-if-statement\">semantics of every statement</a> etc. as a sequence of simple operations. These simple operations are in plain English, not in a proper formal language, but they are close enough that work on formalizing JS was able to turn the simple operations into a core language, translate the standard line-by-line into Coq, and obtain a proper formal semantics of JS that agrees very well with real implementations. See <a href=\"https://www.doc.ic.ac.uk/~pg/publications/FragosoSantos2018JaVerT.html\" target=\"_blank\" title=\"https://www.doc.ic.ac.uk/~pg/publications/FragosoSantos2018JaVerT.html\">https://www.doc.ic.ac.uk/~pg/publications/FragosoSantos2018JaVerT.html</a>.</li>\n<li>This doesnt just apply to programming languages; the official ARM documentation works the same way: Every instruction (many of which have multiple effects, e.g. multiple memory accesses etc.) is explained by a sequence of even-lower-level instructions that do one thing and one thing only. See <a href=\"https://static.docs.arm.com/ddi0557/ab/DDI0557A_b_armv8_1_supplement.pdf\" target=\"_blank\" title=\"https://static.docs.arm.com/ddi0557/ab/DDI0557A_b_armv8_1_supplement.pdf\">https://static.docs.arm.com/ddi0557/ab/DDI0557A_b_armv8_1_supplement.pdf</a> and <a href=\"https://www.cl.cam.ac.uk/~pes20/popl16-armv8/top.pdf\" target=\"_blank\" title=\"https://www.cl.cam.ac.uk/~pes20/popl16-armv8/top.pdf\">https://www.cl.cam.ac.uk/~pes20/popl16-armv8/top.pdf</a>.</li>\n</ul>",
        "id": 134151147,
        "sender_full_name": "RalfJ",
        "timestamp": 1537256962
    },
    {
        "content": "<p>So, I'd like to step back. I have a feeling that we all share the same endgoals:</p>\n<ul>\n<li>We want a spec that can serve <em>users</em> and <em>compiler authors</em></li>\n<li>We want a spec that is clear and — to the extent possible — checkable in an automated fashion</li>\n</ul>\n<p>My belief is that the best route to get there is to operate in layers. That is, defining UB for a \"MIR-like\" abstraction is hard enough. Assuming we find a model we are happy with, then we can define a mapping from Rust down to MIR, and we have a specification. Perhaps one that is not in the best form for universal consumption, but an actionable one. (And I tend to think that, while most Rust programmers aren't familiar with MIR per se, they have some kind of internal desugaring going on in their heads anyway — e.g., they eventually learn that <code>foo.bar()</code> is sugar for <code>Foo::bar(&amp;foo)</code> and so forth.)</p>\n<p>Now, given a specification, the task becomes to <em>explain</em> that spec in various ways such that it is understandable. I imagine that the best way to explain it will depend on the audience. e.g., C programmers might already have a kind of concrete abstraction for the machine and would prefer to start from a MIR-like level. People coming to Rust from some other background might prefer a different approach. </p>\n<p>In terms of audiences, I do think that compiler authors hold a mildly privileged space, in that (as <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> pointed out), they are the ones who have to apply the spec to decide whether a given optimization fits and so forth, as well as implementing dynamic checkers. For this reason, I think that having the \"primary, normative\" variant be done in terms of something quite close to the IR that they will be using for this (MIR) makes sense.</p>",
        "id": 134178549,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537289863
    },
    {
        "content": "<p>I'd expect \"revelations\" at one layer to propagate up and down the abstraction stack, informing decisions</p>",
        "id": 134178845,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1537290197
    },
    {
        "content": "<p>I do think it's reasonable to hold off on declaring anything \"stable\" or \"done\" until we're confident it can be reasoned about from multiple \"angles\"</p>",
        "id": 134178926,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537290270
    },
    {
        "content": "<p>and also I should say that when I say \"MIR\" I don't literally mean the compiler's representation, necessarily, but perhaps a slightly cleaned up and idealized form of it...</p>",
        "id": 134178957,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1537290306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/reference/src/introduction.md\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/reference/src/introduction.md\">https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/reference/src/introduction.md</a><br>\ni stuck it in the intro for now (thinking, maybe we should define terms before using them) but that's mostly just so that we have <em>something</em></p>",
        "id": 134225029,
        "sender_full_name": "avadacatavra",
        "timestamp": 1537355084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126854\">@avadacatavra</span> yup thanks! (<span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> linked it earlier and I <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/pull/30\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/pull/30\">submitted a PR</a> to add some words I'd like defined)</p>",
        "id": 134231199,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1537362883
    }
]