[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"491181\">@Zoey</span> indeed as <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> says, this is an operation that existed in an earlier draft of strict provenance but got cut to be able to get things landed quicker. most people involved are not embedded system experts. also there was the question of whether the operation should take a ptr+size for its new \"fake\" allocation, or just a ptr. (the latter would probably be required for CHERI, OTOH this is for low-level code that probably has no intention of being very portable anyway.)</p>",
        "id": 278355752,
        "sender_full_name": "RalfJ",
        "timestamp": 1649448369
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T</a> for prior discussion</p>",
        "id": 278355885,
        "sender_full_name": "RalfJ",
        "timestamp": 1649448472
    },
    {
        "content": "<p>I think that we should include the length in <code>fake_alloc</code> because it is better for static/dynamic analysis, although we could also just use the size of the pointer type for this (and use <code>*const [u8]</code> for dynamic length allocations)</p>",
        "id": 278358737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649450014
    },
    {
        "content": "<p>I am less sure about whether we should allow multiple overlapping <code>fake_alloc</code>s</p>",
        "id": 278358817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649450051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Create.20pointer.20to.20fixed-address.20memory.20region.20.28MMIO.2C.20.2E.2E.2E.29/near/278358817\">said</a>:</p>\n<blockquote>\n<p>I am less sure about whether we should allow multiple overlapping <code>fake_alloc</code>s</p>\n</blockquote>\n<p>overlapping with each other? hm then we couldnt annotate it <code>noalias</code> like <code>malloc</code> is annotated. but from a model perspective we could say there is a single FAKE_PROVENANCE used by all of them so as long as it doesnt overlap anything else that would still be fine.</p>",
        "id": 278359428,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450421
    },
    {
        "content": "<p>hm, those both sound like reasonable models with their own use cases</p>",
        "id": 278359629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649450534
    },
    {
        "content": "<p>like you could either consider different <code>fake_alloc</code>s as different allocations with known bounds and fresh allocation IDs, or as all coming from a single allocation called FAKE_PROVENANCE that rust doesn't know the full extent of</p>",
        "id": 278359727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649450595
    },
    {
        "content": "<p>In terms of \"do we take a size or not\", the answer i would propose is that we have both versions supported in the public API. The version with an address+size is the \"real\" way to do it, and then we also have a version that just lets you pass in only an address and it will just assume a size of one element and forward the call.</p>\n<p>It's certainly <em>correct</em> to track memory spans on mmio addresses, but a majority of the time an mmio \"object\" is a single int big, and then the next int in memory is \"some other object\" that is considered separately. For the common case of 1-element ranges we should provide library helpers.</p>",
        "id": 278363125,
        "sender_full_name": "Lokathor",
        "timestamp": 1649452482
    },
    {
        "content": "<p>As to <code>noalias</code>, doesn't that mean that outside forces aren't ever manipulating the value? In the general case that would be a very incorrect assumption.</p>",
        "id": 278363325,
        "sender_full_name": "Lokathor",
        "timestamp": 1649452604
    },
    {
        "content": "<p>Yeah, I think the easy way should ideally return references to some <code>VolatileUnsafeCell</code> or a raw pointer, and make it as little of a footgun as possible.</p>",
        "id": 278363531,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649452738
    },
    {
        "content": "<p>Oh no, I've spent over a year telling people to stop using the <code>&amp;VolatileCell</code> model in their code XD</p>",
        "id": 278363656,
        "sender_full_name": "Lokathor",
        "timestamp": 1649452788
    },
    {
        "content": "<p>Well, an actual <code>VolatileCell</code> that doestherightthingTM, not one that pretends to :P</p>",
        "id": 278363827,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649452824
    },
    {
        "content": "<p>Also a raw pointer isn't great because then you get unsafe all over the program</p>",
        "id": 278363875,
        "sender_full_name": "Lokathor",
        "timestamp": 1649452861
    },
    {
        "content": "<p>we want unsafe creation and then safe use thereafter</p>",
        "id": 278363884,
        "sender_full_name": "Lokathor",
        "timestamp": 1649452872
    },
    {
        "content": "<p>Someday I'll get around to working on some Deref traits that work well with raw pointers and unsafe code...</p>",
        "id": 278364261,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649453087
    },
    {
        "content": "<p>I don't know that such a thing is necessary. There's already the amazing and fantastic technicolor wonder of a crate that's <code>voladdress</code> (and please don't check who wrote it, no no).</p>\n<p>But more seriously, I think that if the \"make pointers not so terrible\" plans from granka get added, specifically the ones for syntax for accessing fields of pointed-to values, then that same syntax should be made to work with volatile address values.</p>",
        "id": 278364511,
        "sender_full_name": "Lokathor",
        "timestamp": 1649453262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Create.20pointer.20to.20fixed-address.20memory.20region.20.28MMIO.2C.20.2E.2E.2E.29/near/278363656\">said</a>:</p>\n<blockquote>\n<p>Oh no, I've spent over a year telling people to stop using the <code>&amp;VolatileCell</code> model in their code XD</p>\n</blockquote>\n<p>I would like to have one that works, though. It makes doing things with magic symbols easier.</p>",
        "id": 278380864,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649468914
    },
    {
        "content": "<p>I know that it would make accessing a field offset from a base address easier. Is there anything else?</p>",
        "id": 278410106,
        "sender_full_name": "Lokathor",
        "timestamp": 1649510725
    }
]