[
    {
        "content": "<p>there are plenty of requests to relax Stacked Borrows to <em>not</em> restrict the range of the reference to <code>T</code></p>",
        "id": 277642838,
        "sender_full_name": "RalfJ",
        "timestamp": 1649000167
    },
    {
        "content": "<p>so, while SB as-is would let use use that annotation a lot, my impression is that that's a problem and I hope to fix it in a future aliasing model</p>",
        "id": 277642903,
        "sender_full_name": "RalfJ",
        "timestamp": 1649000212
    },
    {
        "content": "<p>That would be odd, in light of the safety requirements on unchecked slice indexing</p>",
        "id": 277650720,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649006472
    },
    {
        "content": "<p>well, if we fix <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a> then OOB unchecked slice indexing will probably not be language UB any more (if the access is not conflicting with others, and still inbounds of the allocation)</p>",
        "id": 277653633,
        "sender_full_name": "RalfJ",
        "timestamp": 1649010245
    },
    {
        "content": "<p>it can still be library UB</p>",
        "id": 277653653,
        "sender_full_name": "RalfJ",
        "timestamp": 1649010268
    },
    {
        "content": "<p>Similar to strict provenance being an experiment on library additions supporting going \"all the way\" on enforcing pointer validity, I wonder what that would look like for subobject slicing. Specifically, non-subobject access needs to be supported for <code>extern type</code> to work, so what would it take to make annotating use cases that want the looser semantics (e.g. with <code>extern type</code>) tractable.</p>",
        "id": 277724093,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649075801
    },
    {
        "content": "<p>For the examples in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">#134</a>, <code>&amp;slice[0] as *const</code> is a C-ism which I think has mostly been conditioned away and people use the correct <code>.as_ptr()</code> now. Implementing <code>Rc::[into|from]_inner</code> is still easy to get wrong, but <code>&amp;raw mut</code> makes it as easy to write correctly as incorrectly.</p>",
        "id": 277724629,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649076059
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/256\">#256</a> <em>literally</em> wants an <code>extern type</code> tail on <code>&amp;Header</code>.</p>",
        "id": 277724726,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649076115
    },
    {
        "content": "<p>It's a simpler model for the developer if reference don't restrict their accessible range to <code>size_of_val(self)</code>, and likely simpler for SB as well (since you don't have to have two kinds of types, one which restricts, and one which doesn't), so my intuition says fixing <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/276\">#276</a> and applying the same semantics to plain references to fix <a href=\"https://github.com/rust-lang/rust/issues/134\">#134</a> is the better path</p>",
        "id": 277725523,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649076523
    },
    {
        "content": "<p>Leave subobject provenance slicing as something which is done on the allocator boundary</p>",
        "id": 277725576,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649076561
    },
    {
        "content": "<p>Additionally, while extern type models &amp;Header well, it doesn't really address container_of use cases... although CHERI addresses container_of by annotating the type, so maybe it's tractable? I don't know how much subobject slicing they do beyond the allocation layer, though.</p>",
        "id": 277725808,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649076674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277725523\">said</a>:</p>\n<blockquote>\n<p>It's a simpler model for the developer if reference don't restrict their accessible range to <code>size_of_val(self)</code></p>\n</blockquote>\n<p>I don't know about that. I don't know how <code>split_at_mut</code> makes any sense if the references have overlapping access</p>",
        "id": 277729908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649078620
    },
    {
        "content": "<p>Certainly in safe code references don't have any access outside the specified range, so I would consider that the default position</p>",
        "id": 277730032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649078671
    },
    {
        "content": "<p>(why does the mobile app not have a quote option)</p>",
        "id": 277736537,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649081563
    },
    {
        "content": "<p><code>split_at_mut</code> still makes sense because <code>&amp;mut</code> still asserts uniqueness over <code>size_of_val(self)</code></p>",
        "id": 277736623,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649081615
    },
    {
        "content": "<p>I agree that references restricting provenance is ideologically correct, but the UCG repo documents a number of examples of people wanting it not to be true</p>",
        "id": 277736870,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649081728
    },
    {
        "content": "<p>I'd love a usable type-based solution for encoding when references do/don't subslice provenance, though. The practicality of such depends a lot on how extern type is handled both in the language and in SB, though.</p>",
        "id": 277737299,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649081910
    },
    {
        "content": "<p>Another use case is <code>bitvec</code>'s use of a ZST slice reference to represent a slice of a packed bit vector: <a href=\"https://myrrlyn.net/blog/bitvec/addressing-bits\">https://myrrlyn.net/blog/bitvec/addressing-bits</a></p>",
        "id": 277747961,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649086002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277736537\">said</a>:</p>\n<blockquote>\n<p>(why does the mobile app not have a quote option)</p>\n</blockquote>\n<p>you inspired me to finally get around to looking for the zulip issue: <a href=\"https://github.com/zulip/zulip-mobile/issues/1975\">https://github.com/zulip/zulip-mobile/issues/1975</a></p>",
        "id": 277752414,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1649087743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277725808\">said</a>:</p>\n<blockquote>\n<p>Additionally, while extern type models &amp;Header well, it doesn't really address container_of use cases... although CHERI addresses container_of by annotating the type, so maybe it's tractable? I don't know how much subobject slicing they do beyond the allocation layer, though.</p>\n</blockquote>\n<p>By default we don't do any subobject slicing. Even with the most conservative mode, you lose some C compatibility so it can't be on by default. We do enable it and use annotations on the CheriBSD kernel (FreeBSD derived), but haven't tried a really wide array of software.</p>",
        "id": 277796317,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649107748
    },
    {
        "content": "<p>Yet, wearing my security hat, there are quite a few vulnerabilities that would be prevented on CHERI only in the presence of subobject slicing.</p>\n<p>For that reason, my tentative opinion is that the Rust spec <em>should</em> restrict provenance ranges when you access subobjects.  Perhaps not when you just convert between pointers and references or whatnot; there's room to be less strict wrt <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a>.  But at least when it comes to struct fields – if you write <code>&amp;mut foo.bar</code>, you should not be able to convert that to a raw pointer and then walk to <code>foo.baz</code>, even if <code>foo.baz</code> is not otherwise borrowed.  The same should probably be true for array indexing.</p>\n<p>And then there absolutely should be an opt-out on a per-struct or per-field level for when you want to use container_of.</p>",
        "id": 277800170,
        "sender_full_name": "comex",
        "timestamp": 1649109841
    },
    {
        "content": "<p>So, one thing I wanted to mention here: In some of the other conversations, people were indicating that they believed the optimization opportunities to be rather small. I'd like to point out that for subobject provenance, that is <em>decidedly</em> not the case. <code>foo(&amp;mut bar.field)</code> not interfering with SROA is a potentially <em>very</em> significant win, and it's not out of reach for rustc to exploit by any means, even in the near-ish future</p>",
        "id": 277800417,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649109963
    },
    {
        "content": "<p>True.  In fact, having that not interfere with SROA is a fundamental enabler for some kinds of zero-cost abstractions.  If I group a bunch of variables together in a struct, but never expose a pointer to the whole struct, that should not be any slower than having a bunch of separate variables.</p>",
        "id": 277800678,
        "sender_full_name": "comex",
        "timestamp": 1649110157
    },
    {
        "content": "<p>I have a specific use case in mind involving an interpreter.</p>",
        "id": 277800799,
        "sender_full_name": "comex",
        "timestamp": 1649110223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800170\">said</a>:</p>\n<blockquote>\n<p>Yet, wearing my security hat, there are quite a few vulnerabilities that would be prevented on CHERI only in the presence of subobject slicing.</p>\n<p>For that reason, my tentative opinion is that the Rust spec <em>should</em> restrict provenance ranges when you access subobjects.  Perhaps not when you just convert between pointers and references or whatnot; there's room to be less strict wrt <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a>.  But at least when it comes to struct fields – if you write <code>&amp;mut foo.bar</code>, you should not be able to convert that to a raw pointer and then walk to <code>foo.baz</code>, even if <code>foo.baz</code> is not otherwise borrowed.  The same should probably be true for array indexing.</p>\n<p>And then there absolutely should be an opt-out on a per-struct or per-field level for when you want to use container_of.</p>\n</blockquote>\n<p>That sounds like a good balance for Rust. One one likes bugs like <a href=\"https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html\">https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html</a>. For CHERI C our current view is that subobject bounds violates guarantees in the C standard and requires too many changes by default, but we hope to find ways to use them more broadly in C.</p>",
        "id": 277907010,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649176467
    },
    {
        "content": "<p>Do you mean “more broadly than in C”?</p>",
        "id": 277907423,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649176648
    },
    {
        "content": "<p>For languages like Rust where it appears bound can be set without breaking the language, I encourage people to do so. For C, I want to try using them more broadly and make it easier to do so because we do currently miss certain classes of bugs, but doing so means yet another language variant.</p>",
        "id": 277908316,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649177004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277729908\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277725523\">said</a>:</p>\n<blockquote>\n<p>It's a simpler model for the developer if reference don't restrict their accessible range to <code>size_of_val(self)</code></p>\n</blockquote>\n<p>I don't know about that. I don't know how <code>split_at_mut</code> makes any sense if the references have overlapping access</p>\n</blockquote>\n<p>if they would overlap you could still cause UB under the non-subslicing model by doing ABA accesses</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">.</span><span class=\"n\">split_at_mut</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span>:\n<span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// let's say this aliases `a[0]`</span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277923288,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183241
    },
    {
        "content": "<p>but crucially, it's the <em>accesses</em> that define the boundary, not the type</p>",
        "id": 277923468,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183303
    },
    {
        "content": "<p>this is, I think, what many people hoped Stacked Borrows would be. but I like types...</p>",
        "id": 277923523,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800170\">said</a>:</p>\n<blockquote>\n<p>Yet, wearing my security hat, there are quite a few vulnerabilities that would be prevented on CHERI only in the presence of subobject slicing.</p>\n<p>For that reason, my tentative opinion is that the Rust spec <em>should</em> restrict provenance ranges when you access subobjects.  Perhaps not when you just convert between pointers and references or whatnot; there's room to be less strict wrt <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a>.  But at least when it comes to struct fields – if you write <code>&amp;mut foo.bar</code>, you should not be able to convert that to a raw pointer and then walk to <code>foo.baz</code>, even if <code>foo.baz</code> is not otherwise borrowed.  The same should probably be true for array indexing.</p>\n<p>And then there absolutely should be an opt-out on a per-struct or per-field level for when you want to use container_of.</p>\n</blockquote>\n<p>I imagine being restrictive in some cases could be integrated into a model that is generally more permissive.</p>\n<p>however, on a high level your argument seems to be \"let's make more things UB to make things more secure\" and... that's a bad argument for UB, I think. at best it is an argument for \"we say this is definitely wrong and code shouldnt do it but we will also never do optimizations that would break code which does do it\"</p>",
        "id": 277923971,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183478
    },
    {
        "content": "<p>I have seen arguments claiming integer overflow UB in C is a good thing because it means we can have checkers that check against integer overflow. I think that's a terrible argument, why do we need UB (and unexpected compilation results and all the fun associated with that) to have such checkers?!? we really don't. all we need is consensus that integer overflow is a bug.<br>\nincidentally, in Rust we have checkers that check against integer overflow (we even do it by default in debug builds), while they are not UB. so this is constructive proof that the argument is wrong.</p>",
        "id": 277924259,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183566
    },
    {
        "content": "<p><em>In addition</em> <code>clang</code> has <code>-fsanitize=unsigned-integer-overflow</code> which does what it says on the tin. So... yeah.</p>",
        "id": 277952407,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649197992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800417\">said</a>:</p>\n<blockquote>\n<p><code>foo(&amp;mut bar.field)</code> not interfering with SROA is a potentially <em>very</em> significant win, and it's not out of reach for rustc to exploit by any means, even in the near-ish future</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800678\">said</a>:</p>\n<blockquote>\n<p>If I group a bunch of variables together in a struct, but never expose a pointer to the whole struct, that should not be any slower than having a bunch of separate variables.</p>\n</blockquote>\n<p>Personally, this convinces me that subobject slicing is the desirable default for reference retagging on field access. I wonder if doing subobject slicing when taking a reference to a field but not <code>&amp;raw</code> or just when normally retagging is a simple enough model that gets benefits of both worlds?</p>",
        "id": 278443059,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649557061
    },
    {
        "content": "<p>I believe that is the status quo, and am hopeful that this is simple enough. Especially with improved ergonomics around <code>&amp;raw</code> and such things</p>",
        "id": 278446273,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649562783
    },
    {
        "content": "<p>I'm fairly sure (but not 100%) that retagging <code>&amp;Header</code> restricts it to just <code>size_of::&lt;Header&gt;()</code> bytes</p>",
        "id": 278446340,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649562910
    },
    {
        "content": "<p>I also believe that is the case, so I must have misunderstood what you meant then</p>",
        "id": 278446347,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649562956
    },
    {
        "content": "<p>What I meant is that <code>&amp;object.field</code> would slice provenance, but <code>&amp;*&amp;raw const object.field</code> wouldn't</p>",
        "id": 278446396,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563005
    },
    {
        "content": "<p>I have no idea how to spec such in SB tbh</p>",
        "id": 278446410,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563036
    },
    {
        "content": "<p>Since both are \"reference of place\" operations</p>",
        "id": 278446412,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563047
    },
    {
        "content": "<p>It's not necessarily a good idea, but just a wonder about whether subobject slicing could be restricted to just when taking a subfield reference but allowing <code>&amp;Header</code> to carry provenance for an erased VLA tail if carefully constructed</p>",
        "id": 278446454,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563110
    },
    {
        "content": "<p>Some attribute to opt-out of subobject provenance probably would be useful for those cases. I think CHERI has some opt-in stuff on the C side.</p>",
        "id": 278446464,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649563155
    },
    {
        "content": "<p>Yeah, i don't know how such a thing could work either - <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> had mentioned one time that he had an idea for this, I don't know if he ever shared what it was though</p>",
        "id": 278446473,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649563187
    },
    {
        "content": "<p>The opt-out already has to exist for <code>extern type</code>, so for the tail it's \"just\" using an <code>extern type</code> tail</p>",
        "id": 278446495,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563203
    },
    {
        "content": "<p>The interesting case is when you want a <code>container_of!</code> style operation to work</p>",
        "id": 278446553,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563222
    },
    {
        "content": "<p>Access <code>ptr[-1]</code> or so</p>",
        "id": 278446572,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649563231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham (CAD97)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278443059\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800417\">said</a>:</p>\n<blockquote>\n<p><code>foo(&amp;mut bar.field)</code> not interfering with SROA is a potentially <em>very</em> significant win, and it's not out of reach for rustc to exploit by any means, even in the near-ish future</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/277800678\">said</a>:</p>\n<blockquote>\n<p>If I group a bunch of variables together in a struct, but never expose a pointer to the whole struct, that should not be any slower than having a bunch of separate variables.</p>\n</blockquote>\n<p>Personally, this convinces me that subobject slicing is the desirable default for reference retagging on field access. I wonder if doing subobject slicing when taking a reference to a field but not <code>&amp;raw</code> or just when normally retagging is a simple enough model that gets benefits of both worlds?</p>\n</blockquote>\n<p>how would that work with \"access the header before the object\" style code? that just seems like a fundamental conflict to me.</p>",
        "id": 278467538,
        "sender_full_name": "RalfJ",
        "timestamp": 1649596318
    },
    {
        "content": "<p>also note that SROA when a pointer to a field has been taken is <em>really subtle</em> because no matter what we do with subobject provenance, this also affects the addresses things will be at.</p>",
        "id": 278467587,
        "sender_full_name": "RalfJ",
        "timestamp": 1649596372
    },
    {
        "content": "<p>like, when I do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">field1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">foo2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">field2</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then the two functions could cooperate to calculate the offset between the two fields, and if this is <code>repr(C)</code> that is fully determined. doesn't that prevent SROA?<br>\neven with <code>repr(Rust)</code> this must be consistent, e.g. if the code is executed mutliple times it must always be the same distance -- which is not generally true if <code>field1</code> and <code>field2</code> just become local variables.</p>",
        "id": 278467641,
        "sender_full_name": "RalfJ",
        "timestamp": 1649596458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham (CAD97)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278446495\">said</a>:</p>\n<blockquote>\n<p>The opt-out already has to exist for <code>extern type</code>, so for the tail it's \"just\" using an <code>extern type</code> tail</p>\n</blockquote>\n<p>I am also not quite sure how to do that while still having subobject provenance elsewhere</p>",
        "id": 278467665,
        "sender_full_name": "RalfJ",
        "timestamp": 1649596528
    },
    {
        "content": "<p>since we are discussing <code>ptr::Unique</code>  in another topic, something that occurred to me -- I think what I am imagining for <code>&amp;mut</code> would basically make them equivalent to <code>Unique</code>, except that <code>&amp;mut</code> also does this \"protector\" stuff in SB (needed to ensure it remains dereferencable for the duration of the call). not sure if that is a good thing or a bad thing.</p>",
        "id": 278481207,
        "sender_full_name": "RalfJ",
        "timestamp": 1649613362
    },
    {
        "content": "<p>probably not super relevant here but it would be nice to have some kind of \"&amp; but i don't care about the address\" type- it would let this <code>foo1</code>/<code>foo2</code> example do SROA, it could represent small objects directly, etc...</p>",
        "id": 278482495,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649615026
    },
    {
        "content": "<p>I honestly don't know, and tbh most of this discussion is kind of moot until we have an actual model of the <code>extern type</code>-supporting SB, since it's mostly just conjecturing about hypotheticals</p>",
        "id": 278483711,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649616738
    },
    {
        "content": "<p>My very rough hypothetical for \"subobject slicing except for <code>extern type</code>\" is \"retagging references does today's operations for types without an <code>extern type</code> tail and the nonslicing retag if the type has an <code>extern type</code> tail\"</p>",
        "id": 278483745,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649616833
    },
    {
        "content": "<p>Which is basically a cop-out and doesn't make any sense if the rest of the world's state isn't identical between the two models</p>",
        "id": 278483796,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649616872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278446464\">said</a>:</p>\n<blockquote>\n<p>Some attribute to opt-out of subobject provenance probably would be useful for those cases. I think CHERI has some opt-in stuff on the C side.</p>\n</blockquote>\n<p>CHERI Clang has an opt-in compiler flag (with varying degrees of aggressiveness) and opt-out <code>__attribute__</code>s (and a <code>__builtin_addressof</code> variant that doesn't set bounds, though not sure if we ever actually make use of that)</p>",
        "id": 278487762,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649622107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278467641\">said</a>:</p>\n<blockquote>\n<p>like, when I do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">field1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">foo2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">field2</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then the two functions could cooperate to calculate the offset between the two fields, and if this is <code>repr(C)</code> that is fully determined. doesn't that prevent SROA?<br>\neven with <code>repr(Rust)</code> this must be consistent, e.g. if the code is executed mutliple times it must always be the same distance -- which is not generally true if <code>field1</code> and <code>field2</code> just become local variables.</p>\n</blockquote>\n<p>Yeah, I ended up realizing this, and it's actually even worse than that. We can't even SROA in this scenario:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Because we need to ensure that <code>arg2.addr() - arg1.addr()</code> is at least 2. This particular case could be fixed by not guaranteeing address uniqueness, but of course my proposal for that doesn't work in a non-strict provenance world</p>",
        "id": 278488521,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649623149
    },
    {
        "content": "<p>This is <em>really</em> sad, I wonder if there's a way to salvage it...</p>",
        "id": 278489000,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649623817
    },
    {
        "content": "<p>I think this might be the same as <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/244\">https://github.com/rust-lang/unsafe-code-guidelines/issues/244</a> ?</p>",
        "id": 278489123,
        "sender_full_name": "RalfJ",
        "timestamp": 1649623980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/subobject.20provenance/near/278489000\">said</a>:</p>\n<blockquote>\n<p>This is <em>really</em> sad, I wonder if there's a way to salvage it...</p>\n</blockquote>\n<p>at the very least, we'd have to have references whose 'address' is truly unobservable -- casting them to raw pointers would have to be unsafe. then we also need an operational model that actually justifies this...</p>",
        "id": 278489196,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624058
    },
    {
        "content": "<p>you can always just do the compiler thing and do an escape analysis on the address of the pointer, with no model changes</p>",
        "id": 278489230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649624158
    },
    {
        "content": "<p>Yeah, it sounds like this is something we'll need to do</p>",
        "id": 278489327,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649624266
    },
    {
        "content": "<p>I don't think we have any inter-procedural analyses in rustc yet, so that'll be an interesting project</p>",
        "id": 278489370,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649624284
    },
    {
        "content": "<p>you mean we should write a smart compiler rather than putting the burden on programmers? shocking!! ;)</p>",
        "id": 278489402,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624353
    },
    {
        "content": "<p>but yeah this discussion was about SROA when a reference to one field escapes, where escape analysis will just shrug its shoulders</p>",
        "id": 278489407,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624377
    },
    {
        "content": "<p>well, the \"inter-procedural analysis\" part is that we can go look in <code>foo</code> to find out if it <em>really</em> escapes instead of just assuming the worst</p>",
        "id": 278489743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649624703
    },
    {
        "content": "<p>sure, if we know <code>foo</code> the game changes</p>",
        "id": 278489755,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624728
    },
    {
        "content": "<p>since it is a reasonable estimate that most references do not have their addresses inspected</p>",
        "id": 278489761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649624741
    },
    {
        "content": "<p>but it is unlikely that a local analysis can deduce this</p>",
        "id": 278489804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649624763
    }
]