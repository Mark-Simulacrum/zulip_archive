[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issue-913788476\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issue-913788476</a> shows an example in which <code>==</code> is assumed to ignore provenance when comparing <code>usize</code> at least. </p>\n<p>Does it have to?</p>",
        "id": 250478591,
        "sender_full_name": "hannahE2",
        "timestamp": 1629809016
    },
    {
        "content": "<p>It would be extremely shocking and in my opinion broken if equality on usize was anything other than a numeric value comparison.</p>",
        "id": 250483547,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1629811254
    },
    {
        "content": "<p>Provenance isn't really a runtime thing so I don't know if it even makes sense to compare it</p>",
        "id": 250487512,
        "sender_full_name": "Kestrer",
        "timestamp": 1629813044
    },
    {
        "content": "<blockquote>\n<p>Provenance isn't really a runtime thing so I don't know if it even makes sense to compare it</p>\n</blockquote>\n<p>Well, for pointers, there is an argument to be made that it can. For example, the C++ standard states that the result of comparing a pointer past-the-end of one object with a pointer to another is unspecified - even if it would otherwise be true (because the two pointers represent the same address, either by chance or by abi requirement). Whether or not this is intended to be true of rust, I don't know (llvm may make doing that difficult, though). Though for integers, this should not impact the result at all.</p>",
        "id": 250495309,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629816269
    },
    {
        "content": "<p>yeah, the compiler can utilize provenance of the pointer to optimize out the comparison entirely.</p>",
        "id": 250505417,
        "sender_full_name": "nagisa",
        "timestamp": 1629820359
    },
    {
        "content": "<p>that's what allows to elide e.g. null checks.</p>",
        "id": 250505433,
        "sender_full_name": "nagisa",
        "timestamp": 1629820366
    },
    {
        "content": "<p>Compiler may also elide various ptrtoint conversions if it deems that possible for some reason, which would make provenance-free usize comparison into a provenance-aware ptr comparison.</p>",
        "id": 250505593,
        "sender_full_name": "nagisa",
        "timestamp": 1629820431
    },
    {
        "content": "<blockquote>\n<p>It would be extremely shocking and in my opinion broken if equality on usize was anything other than a numeric value comparison.</p>\n</blockquote>\n<p>The same argument can be made about comparing pointers, e.g., \"It would be extremely shocking and broken if equality on pointers was anything other than a comparison of the pointer address bit representation\".</p>",
        "id": 250552380,
        "sender_full_name": "hannahE2",
        "timestamp": 1629840843
    },
    {
        "content": "<p>If we were to allow provenance to play a role in integers that are actually pointer addresses, we would need a way to remove that. We could add a <code>freeze</code>-like operation that explicitly removes it.</p>",
        "id": 250552612,
        "sender_full_name": "hannahE2",
        "timestamp": 1629840972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F/near/250552380\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It would be extremely shocking and in my opinion broken if equality on usize was anything other than a numeric value comparison.</p>\n</blockquote>\n<p>The same argument can be made about comparing pointers, e.g., \"It would be extremely shocking and broken if equality on pointers was anything other than a comparison of the pointer address bit representation\".</p>\n</blockquote>\n<p>I believe that is also the case, though</p>",
        "id": 250565875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629849801
    },
    {
        "content": "<p>using the <code>==</code> function on two pointers compares them bitwise</p>",
        "id": 250565885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629849816
    },
    {
        "content": "<p>However it may be the case that comparing pointers of different provenance is UB. This is how it is in C/C++, and probably what you get by default from LLVM, but I'm not sure if Rust has decided whether to use this or specify always defined bitwise comparison. In any case, a bitwise comparison is always a correct implementation, but having UB there also allows the compiler to optimize some such comparisons to <code>false</code> instead of comparing anything.</p>",
        "id": 250566095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629850003
    },
    {
        "content": "<p>I think it isn't possible for Rust to allow <code>==</code> on two source level <code>*const T</code>s to be UB because this operation is safe</p>",
        "id": 250566109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629850028
    },
    {
        "content": "<blockquote>\n<p>However it may be the case that comparing pointers of different provenance is UB. This is how it is in C/C++, and probably what you get by default from LLVM, but I'm not sure if Rust has decided whether to use this or specify always defined bitwise comparison. In any case, a bitwise comparison is always a correct implementation, but having UB there also allows the compiler to optimize some such comparisons to <code>false</code> instead of comparing anything.</p>\n</blockquote>\n<p>It is not UB in C++. In fact, equality comparison is well-defined in C++ on valid pointer values pairwise, except when comparing a past-the-end pointer with a pointer to a different object. I noted this above.</p>",
        "id": 250576317,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629861677
    },
    {
        "content": "<p>So, given</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>p==q is well-defined (false) and (p+1)==q is unspecified (not undefined). The optimization you mentioned is still allowed, though.</p>",
        "id": 250576413,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629861839
    },
    {
        "content": "<p>I presume rust inherited this rule, though whether or not it was by choice, I wouldn't know.</p>",
        "id": 250576551,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629861983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360486\">Kestrer</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F/near/250487512\">said</a>:</p>\n<blockquote>\n<p>Provenance isn't really a runtime thing so I don't know if it even makes sense to compare it</p>\n</blockquote>\n<p>it is a thing in the runtime of the Abstract Machine. the actual runtime on a real CPU has to be a correct simulation of that abstract machine behavior.</p>",
        "id": 252033578,
        "sender_full_name": "RalfJ",
        "timestamp": 1630797838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20.3D.3D.20have.20to.20ignore.20provenance.3F/near/250505417\">said</a>:</p>\n<blockquote>\n<p>yeah, the compiler can utilize provenance of the pointer to optimize out the comparison entirely.</p>\n</blockquote>\n<p>hm, no I dont think it can actually</p>",
        "id": 252033626,
        "sender_full_name": "RalfJ",
        "timestamp": 1630797859
    },
    {
        "content": "<p>for integers, there is (almost certainly) no provenance anyway, so the question is moot</p>",
        "id": 252033667,
        "sender_full_name": "RalfJ",
        "timestamp": 1630797907
    },
    {
        "content": "<p>but for pointers, it is a good question. my understanding is that in LLVM, ptr comparison (both equality but also greater/less) is always well-defined and ignores provenance. that would be the intended semantics for Rust as well, I'd say.</p>",
        "id": 252033694,
        "sender_full_name": "RalfJ",
        "timestamp": 1630797960
    },
    {
        "content": "<p>That's a relief.</p>",
        "id": 252034565,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630799026
    },
    {
        "content": "<p>It's important to be able to compare arbitrary unrelated pointers.</p>",
        "id": 252034571,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630799040
    },
    {
        "content": "<p>For instance, consider the approach of avoiding ABBA deadlocks by sorting lock acquisition by address.</p>",
        "id": 252034624,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630799073
    },
    {
        "content": "<p>yeah I know this is done in real life, but it's also UB in C (and maybe C++) which makes the situation tricky given that we are basically using a C compiler as a backend^^</p>",
        "id": 252088269,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861108
    },
    {
        "content": "<p>and LLVM does some... shady... things around ptr comparison. however I think they still intent to uphold the semantics as I described it above. It will be interesting what happens if/when it ever turns out that that is fundamentally incompatible with an optimization they want to perform...</p>",
        "id": 252088328,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861200
    },
    {
        "content": "<p>I noted that C++ makes it well-defined to compare pointers for equality <em>except</em> comparing a past-the-end pointer to a pointer-to-object (which is unspecified, not undefined).<br>\nSee <a href=\"http://eel.is/c++draft/expr.eq#3\">http://eel.is/c++draft/expr.eq#3</a>.<br>\nRelational operators on pointers from different arrays/objects are only unspecified</p>",
        "id": 252089384,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630862274
    },
    {
        "content": "<p>Equality comparison is well-defined, but &lt; &gt; are not.</p>",
        "id": 252089537,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630862415
    },
    {
        "content": "<blockquote>\n<p>I noted that C++ makes it well-defined to compare pointers for equality except comparing a past-the-end pointer to a pointer-to-object (which is unspecified, not undefined).</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> doesnt C++ do \"pointer lifetime end zapping\", whereby pointers to an object become indeterminate when that object is deallocated? (C does that, not sure about C++) and then comparing indeterminate pointers is... UB or unspecified I guess? So that would be another case for this list.</p>",
        "id": 252917880,
        "sender_full_name": "RalfJ",
        "timestamp": 1631375424
    },
    {
        "content": "<p>I believe so. Specifically, I believe deallocating an object turns pointers into an indeterminate value. It's at the end of the object's storage duration, though, not lifetime (which is different since C++ lets you forcibly end object lifetimes, then create new ones in that storage)</p>",
        "id": 252920011,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631377587
    },
    {
        "content": "<p>(Though outside of doing allocator stuff, or stuff that's cursed for C++ standards, the only real difference for automatic objects is the length of the destructor - if any).</p>",
        "id": 252920125,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631377684
    },
    {
        "content": "<p>If I'm correct about it being an indeterminate value (and not just an indeterminate pointer), the question about comparing them is that you won't even get that far before UB.</p>",
        "id": 252920194,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631377774
    },
    {
        "content": "<p>Oh, should have checked. I'm wrong, it becomes an invalid pointer value<br>\n<a href=\"http://eel.is/c++draft/basic.stc#general-4\">http://eel.is/c++draft/basic.stc#general-4</a><br>\nIndirecting it is UB, everything else is implementation-defined.</p>",
        "id": 252920283,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631377839
    },
    {
        "content": "<p>(Although, the footnote implies trivial copying is included in \"everything else\", so, uh, a well-documented indeterminate value I guess)</p>",
        "id": 252920462,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631378054
    }
]