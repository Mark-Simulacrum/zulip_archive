[
    {
        "content": "<p>That's all I've got, really.</p>\n<p>If the full ptr-&gt;int-&gt;ptr cycle is allowed as a side effect on any pointer and any integer... I'm ignoring the discussion of constants, here... then any <code>fn(ptr, int) -&gt; ptr</code> no longer preserves any benefits of modular reasoning. The pointer may now be fully based on the integer, and we are being asked to somehow derive the provenance from a previous program state involving a stack. And we must now inspect the contents of every function we call in order to see whether it is affecting the global pointer state. It doesn't matter if you can salvage it with \"broadcasting\" or whatever other model.</p>\n<p>I assert this will make it functionally almost impossible to write <code>unsafe</code> code that exploits this correctly, while also making any model that tries to incorporate such an insanely complex design take at least twice as much time to get off the ground and also prove itself as sound... if it succeeds at all. By comparison, banning the cycle makes Rust optimization models almost trivial to implement. If you think that it will still take an enormous amount of work... you're right!</p>",
        "id": 274318796,
        "sender_full_name": "Jubilee",
        "timestamp": 1646588727
    },
    {
        "content": "<p>Suppose, for the sake of argument, ptr-&gt;int-&gt;ptr casts are allowed but only with arcane safety invariants tailored for miri / an executable AM, that no user can reasonably keep track of. What are the benefits and drawbacks compared to banning ptr-&gt;int-&gt;ptr entirely? As I see it:</p>\n<ol>\n<li>Drawback: the model is more complex. It is unclear how much to weight this factor; all things being equal simpler is better, but all other things are not equal here.</li>\n<li>Users can't use ptr-&gt;int-&gt;ptr sensibly: not a distinguishing factor, since you can't use them in either case. Having them available but difficult to use means that it is at least possible to put in the legwork if you need to.</li>\n<li>Formal models are impacted: I'm not really convinced by this. If you are verifying specific code, you always have the option to avoid it if there are alternatives, just the same as in (2). In particular, re: \"prove itself as sound\", I don't see how this is an issue if the safety invariant is sufficiently generous to provide all the needed hypotheses. It might be a hideous nonlocal condition but there is always a weakest precondition for correctness that we can use, for which correctness is trivially satisfied by construction.</li>\n</ol>\n<p>I am exaggerating the complexity of the safety invariant here, but even in the worst case it doesn't seem like a huge problem. Certainly there are libraries with these kinds of nonlocal safety invariants, like <code>memmap</code>.</p>",
        "id": 274319411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646589601
    },
    {
        "content": "<p>Regarding modular reasoning: yes, it is completely non-modular and should be avoided whenever possible. Unfortunately Rust programmers today are not given the tools to do this in most cases, so I think we should first try to work on that aspect before legislating them away. Concrete things we can do to make int-&gt;ptr a less attractive option:</p>\n<ul>\n<li>Put <code>int_to_ptr_with_provenance</code> and <code>ptr::map</code> in std</li>\n<li>Add atomic algebraic operations on <code>AtomicPtr</code></li>\n<li>Add a function for creating pointers to memory which <em>cannot</em> be used for rust memory</li>\n<li>Separate the \"broadcast\" and \"non-broadcast\" variants of ptr-&gt;int (unsure which one can become <code>as</code>)</li>\n</ul>",
        "id": 274319582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646589694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/274319411\">said</a>:</p>\n<blockquote>\n<p>Suppose, for the sake of argument, ptr-&gt;int-&gt;ptr casts are allowed but only with arcane safety invariants tailored for miri / an executable AM, that no user can reasonably keep track of. What are the benefits and drawbacks compared to banning ptr-&gt;int-&gt;ptr entirely? As I see it:</p>\n<ol start=\"2\">\n<li>Users can't use ptr-&gt;int-&gt;ptr sensibly: not a distinguishing factor, since you can't use them in either case. Having them available but difficult to use means that it is at least possible to put in the legwork if you need to.</li>\n</ol>\n</blockquote>\n<p>(Also in reply <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> in the old thread)</p>\n<p>The thing is, AIUI union provenance is <em>not</em> this. It is ridiculous if you care about all the possible provenances a given inttoptr-produced pointer might have, but a user never cares about <em>all</em> of them. A user wants precisely <em>one</em> of those many provenances, and so long as that one is always part of the union (via the straightforward rule \"the provenance of any escaped raw pointer which is a) still valid by SB and b) covers/one-past-the-end this memory address\" or similar) , all the other provenances are irrelevant and are just optimization loss.</p>\n<p>Implementing miri or other checkers via this model may be too impractical because they don't know which provenance the user wants, but a user only has to verify the SB raw pointer rules for the one escaped raw pointer that they care about.</p>",
        "id": 274320227,
        "sender_full_name": "Talchas",
        "timestamp": 1646590593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/274318796\">said</a>:</p>\n<blockquote>\n<p>I'm ignoring the discussion of constants, here... then any <code>fn(ptr, int) -&gt; ptr</code> no longer preserves any benefits of modular reasoning.</p>\n</blockquote>\n<p>But mutable globals exist, so this is already true. What's the difference between the body being <code>int_x as *const X</code> and <code>global[int_x]</code>?</p>",
        "id": 274320322,
        "sender_full_name": "Talchas",
        "timestamp": 1646590790
    },
    {
        "content": "<p>You know that <code>global</code> doesn't alias <code>ptr</code> if <code>ptr</code> is derived from the stack. You don't know that <code>int_x as *const X</code> doesn't alias <code>ptr</code> even if <code>ptr</code> is derived from the stack unless there exists a broadcasting operation.</p>",
        "id": 274320477,
        "sender_full_name": "bjorn3",
        "timestamp": 1646590925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/274319582\">said</a>:</p>\n<blockquote>\n<p>Regarding modular reasoning: yes, it is completely non-modular and should be avoided whenever possible. Unfortunately Rust programmers today are not given the tools to do this in most cases, so I think we should first try to work on that aspect before legislating them away. Concrete things we can do to make int-&gt;ptr a less attractive option:</p>\n<ul>\n<li>Put <code>int_to_ptr_with_provenance</code> and <code>ptr::map</code> in std</li>\n<li>Add atomic algebraic operations on <code>AtomicPtr</code></li>\n<li>Add a function for creating pointers to memory which <em>cannot</em> be used for rust memory</li>\n<li>Separate the \"broadcast\" and \"non-broadcast\" variants of ptr-&gt;int (unsure which one can become <code>as</code>)</li>\n</ul>\n</blockquote>\n<p>Yes, I should note that even if we do wind up with whatever is approximately equal to \"retire ptr-&gt;int-&gt;ptr entirely\" it would be the absolute last step after we draft up other replacements for things. I mostly am making my case now because I have already seen that <strong>many</strong> people will speak out against even adding tools that make it easier to write <code>unsafe</code> code in a modular way if they see it as being done in furtherance of a model they dislike.</p>",
        "id": 274321077,
        "sender_full_name": "Jubilee",
        "timestamp": 1646591737
    },
    {
        "content": "<p>I believe that <code>global[i]</code> can alias <code>ptr</code> in exactly the same sorts of situations it can for an int cast? <code>global[i]</code> requires a previous store, and <code>i as *const X</code> requires a previous <code>as usize</code>? (Unless you mean \"<code>as usize</code> is a side effect\" as \"exists a broadcasting operation\", in which case yes I agree) (there's also the full PVI option and just leave it up to the compiler implementation when to give up, but that's also \"fun\")</p>",
        "id": 274321234,
        "sender_full_name": "Talchas",
        "timestamp": 1646591927
    },
    {
        "content": "<blockquote>\n<p>Unless you mean \"as usize is a side effect\" as \"exists a broadcasting operation\"</p>\n</blockquote>\n<p>Yes that.</p>",
        "id": 274321316,
        "sender_full_name": "bjorn3",
        "timestamp": 1646592008
    },
    {
        "content": "<p>In an ideal world, I would like to make <code>*const T as usize</code> a <em>non</em>-broadcasting operation, and instead there is a function (in the semantics and possibly also in real code) <code>fn broadcast(ptr: *const T) { /* side-effect */ }</code> such that any broadcasting ptr-&gt;int is desugared to <code>broadcast(ptr); ptr as usize</code>. Then the <code>as usize</code> can be optimized away if the result is unused as usual.</p>\n<p>The <code>broadcast()</code> operation can be viewed as <code>BROADCASTED.push(ptr)</code> where <code>BROADCASTED</code> is a global array of all broadcasted pointers. (Doing this literally has <code>static mut</code> issues, which also relate to the complications of doing this concurrently...) Then int-&gt;ptr just searches this array for the best pointer which covers the target address. AFAICT there is no additional magic to the operation beyond this, so I agree that this is exactly as non-modular as other uses of global mutable state.</p>",
        "id": 274324224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646595614
    },
    {
        "content": "<blockquote>\n<p>Then int-&gt;ptr just searches this array for the best pointer which covers the target address.</p>\n</blockquote>\n<p>Selecting the best pointer is one of the problems. What is the <em>best</em> pointer when multiple pointers have the same address but different permissions and ranges?</p>",
        "id": 274324312,
        "sender_full_name": "bjorn3",
        "timestamp": 1646595738
    },
    {
        "content": "<p>Registers are different than stacks.<br>\nA global mutable variable is not the same as a global mutable stack.</p>",
        "id": 274324320,
        "sender_full_name": "Jubilee",
        "timestamp": 1646595759
    },
    {
        "content": "<p>Frankly, most of this discussion has been repeated enough times it is extremely close to</p>\n<blockquote>\n<p>Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.</p>\n</blockquote>\n<p>Nonetheless I am having it anyways because I believe, quite simply, that anyone who opens a PR to improve the situation risks having their PR bogged down by this argument anyways.</p>",
        "id": 274324406,
        "sender_full_name": "Jubilee",
        "timestamp": 1646595856
    },
    {
        "content": "<p>There isn't really a \"best\". So we pick something that looks best-ish and call it a day, and if the user didn't arrange for their pointer to be the best-ish then they will get some undesirable UB. And then maybe they will listen to Jubilee's advice and maybe stay away from ptr-&gt;int-&gt;ptr</p>",
        "id": 274324554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646596061
    },
    {
        "content": "<p>One option that is slightly less evil to the user (but still kind of unhelpful) is to declare UB if there is no single best pointer</p>",
        "id": 274324695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646596207
    },
    {
        "content": "<p>that is at least a bit more principled and still executable</p>",
        "id": 274324708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646596236
    },
    {
        "content": "<p>That's still absolutely execrable and will be rightly treated by programmers as effectively no better than C, possibly less.</p>",
        "id": 274325382,
        "sender_full_name": "Jubilee",
        "timestamp": 1646597039
    },
    {
        "content": "<p>Also I want to put forward that I am both pretty happy to work on implementing the model I proposed and likely will have a reasonable amount of time for it over the next year, even if it might not be my first priority. Nonetheless it matters to my existing work for hopefully somewhat obvious reasons, and I have managed to put time into that and also a bit of time into all the little side issues that touches.</p>\n<p>That also is why I cannot pretend I am keen on semantics that resist parallelization for this.</p>",
        "id": 274325528,
        "sender_full_name": "Jubilee",
        "timestamp": 1646597209
    },
    {
        "content": "<p>As someone's who read N2676 but still doesn't quite understand the model, what's the general overview of it and its differences from N2676? There have been quite a few different points and models/semantics raised that I'm not quite sure which one you proposed.</p>",
        "id": 274325945,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1646597794
    },
    {
        "content": "<p>Union provenance is roughly equivalent to PNVI-ae-udi, though there's likely to be more overlap available rather than merely one-past-the-end. I believe PNVI-ae makes inttoptr of one-past-the-end be UB, which is debatable in C, but doesn't save you in rust since there's more metadata in provenance than just the original allocation (and more use of ZSTs, though who knows about ZST-pointers-cast-to-int).</p>\n<p>Picking a \"best\" pointer could be similar to PNVI-ae if the heuristic is good enough, but if it's not it could be nearly as bad as \"remove inttoptr, but with more footguns\". <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/273\">UCG #273</a> has an example of where the heuristic chosen matters.</p>\n<p>Removing inttoptr is equivalent to none of them, though combined with adding more math options to pointers/AtomicPtr you can keep all the more obvious align+bitset stuff. (And since ptrtoint isn't a side effect, <code>from_usize(provenance: *const T, address: usize) -&gt; *const T</code> can be a library function that could optimized well for wrappers that do <code>from_usize(ptr, ptr as usize | 1)</code> and such)</p>",
        "id": 274327542,
        "sender_full_name": "Talchas",
        "timestamp": 1646600114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/274325528\">said</a>:</p>\n<blockquote>\n<p>Also I want to put forward that I am both pretty happy to work on implementing the model I proposed and likely will have a reasonable amount of time for it over the next year, even if it might not be my first priority. Nonetheless it matters to my existing work for hopefully somewhat obvious reasons, and I have managed to put time into that and also a bit of time into all the little side issues that touches.</p>\n<p>That also is why I cannot pretend I am keen on semantics that resist parallelization for this.</p>\n</blockquote>\n<p>Can you clarify what model you mean here (just a link to a message or such)? I'm also somewhat lost in this conversation</p>",
        "id": 274328314,
        "sender_full_name": "Jake",
        "timestamp": 1646601039
    },
    {
        "content": "<p>Functionally, \"implement enough of an interface that ptr-&gt;int-&gt;ptr is technically unnecessary\", yes.<br>\nwhich in relation to the ISO C provenance papers functionally somewhat resembles \"definitely not <code>PNVI-ae*</code> or <code>PVI</code>, but possibly looks like <code>PNVI-plain</code>, if you first do a headstand (that is to say: invert the problem).\"</p>",
        "id": 274328878,
        "sender_full_name": "Jubilee",
        "timestamp": 1646601753
    },
    {
        "content": "<p><a href=\"https://gankra.github.io/blah/fix-rust-pointers/\">https://gankra.github.io/blah/fix-rust-pointers/</a> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 275934176,
        "sender_full_name": "Jubilee",
        "timestamp": 1647730017
    },
    {
        "content": "<p>look llvm and rust have been playing the bUt mAyBe iT mAkEs SeNsE game for like a decade maybe we should just accept that int-ptr is nonsene <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span></p>",
        "id": 275939763,
        "sender_full_name": "Gankra",
        "timestamp": 1647738595
    },
    {
        "content": "<p>plus i just wrote most of the RFC and user docs for you so :3c</p>",
        "id": 275939823,
        "sender_full_name": "Gankra",
        "timestamp": 1647738701
    },
    {
        "content": "<blockquote>\n<p>This section can be skipped entirely if you know everything about computers.</p>\n</blockquote>",
        "id": 275943056,
        "sender_full_name": "Lokathor",
        "timestamp": 1647744318
    },
    {
        "content": "<p>I love it when people do even worse things by accident like cast pointers to u8s.</p>",
        "id": 275951405,
        "sender_full_name": "Jubilee",
        "timestamp": 1647758095
    },
    {
        "content": "<p>By the way, AFAIK, the <code>cheri_address_set</code> operation can already be written in Rust:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">ptr_address_set</span><span class=\"o\">&lt;</span><span class=\"n\">Pointee</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// \"capability\" / \"base\"</span>\n<span class=\"w\">    </span><span class=\"n\">provenance</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Pointee</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">new_address</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Pointee</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">provenance</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">new_address</span><span class=\"p\">.</span><span class=\"n\">wrapping_sub</span><span class=\"p\">(</span><span class=\"n\">provenance</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">cast</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which, by the way, given the \"returns a changed pointer\" signature, would be more idiomatic to name <code>.with_address()</code> rather than <code>set…</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new_bit</span>: <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">addr_without_bit</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"mb\">0b1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">with_address</span><span class=\"p\">(</span><span class=\"n\">addr_without_bit</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">new_bit</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275964411,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1647779251
    },
    {
        "content": "<p>Yes I believe this is a pattern Ralf has shared a few different times for helping miri users explicitly reestablish pointer provenance, which is all cheri_address_set <em>is</em> as far as I know</p>",
        "id": 275969782,
        "sender_full_name": "Gankra",
        "timestamp": 1647786378
    },
    {
        "content": "<p>One interesting thing I've noticed is that XOR lists appear to be fundamentally incompatible with CHERI and therefore my strict definition of provenance. IMO they are a meme but people <em>do</em> use them...</p>",
        "id": 275969811,
        "sender_full_name": "Gankra",
        "timestamp": 1647786428
    },
    {
        "content": "<p>well specifically \"XOR lists where each pointer is genuinely its own box allocation\" if you have like a XOR list in an arena you can get it to work by keeping around a pointer to the arena to \"reconstitute\" the XOR'd addresses</p>",
        "id": 275969956,
        "sender_full_name": "Gankra",
        "timestamp": 1647786616
    },
    {
        "content": "<p><a href=\"https://twitter.com/Gankra_/status/1505966152115277829\">https://twitter.com/Gankra_/status/1505966152115277829</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/Gankra_/status/1505966152115277829\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/37663fd2872232bfa24553d81b8b079cdd79fc11/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313233373135353532323631343336363230382f6c68686b554158395f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/brooksdavis\">@brooksdavis</a> <a href=\"https://twitter.com/MSpondee\">@MSpondee</a> hrm this actually has nasty semantic consequences, because it means\n\ngood_ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE) is not in general a sound operation!\n\n<a href=\"https://t.co/xOXX7QKsGQ\">https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset</a> <a href=\"https://t.co/0pRgN31cmK\">https://twitter.com/Gankra_/status/1505966152115277829/photo/1</a></p><span>- Aria the Cat (@Gankra_)</span><div class=\"twitter-image\"><a href=\"https://t.co/0pRgN31cmK\"><img src=\"https://uploads.zulipusercontent.net/e15055ad48d6984cb7c6198c5c2222a7a6c8d815/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f464f5a446b6665584d4149744247562e6a70673a6d656469756d\"></a></div><div class=\"twitter-image\"><a href=\"https://t.co/0pRgN31cmK\"><img src=\"https://uploads.zulipusercontent.net/e9b0a1d913da160125ae6276c5748068321bf1a5/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f464f5a454d5739584541455579556d2e6a70673a7468756d62\"></a></div></div></div>",
        "id": 276090080,
        "sender_full_name": "Gankra",
        "timestamp": 1647885320
    },
    {
        "content": "<p>That might be the straw that breaks the camel's back insofar as CHERI is concerned.</p>",
        "id": 276092152,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647886259
    },
    {
        "content": "<p>idk, rust very universally discourages wrapping_offset, and we can potentially formalize \"wrapping_offset is not Free Real Estate and has platform-specific restrictions\"</p>",
        "id": 276092368,
        "sender_full_name": "Gankra",
        "timestamp": 1647886329
    },
    {
        "content": "<p>like any pointer tagging scheme is already doing Platform Specific Fuckery and wrapping_offset can be conceptualized as that</p>",
        "id": 276092469,
        "sender_full_name": "Gankra",
        "timestamp": 1647886382
    },
    {
        "content": "<p>also it's very nice that due to the nature of CHERI you are guaranteed to fault if you fuck up</p>",
        "id": 276092714,
        "sender_full_name": "Gankra",
        "timestamp": 1647886490
    },
    {
        "content": "<p>like yes the language generally models \"faulting\" as UB but we <em>can</em> just let it be a Safe Fuck You</p>",
        "id": 276092919,
        "sender_full_name": "Gankra",
        "timestamp": 1647886572
    },
    {
        "content": "<p>just like blowing the stack</p>",
        "id": 276092933,
        "sender_full_name": "Gankra",
        "timestamp": 1647886578
    },
    {
        "content": "<p><a href=\"https://twitter.com/Gankra_/status/1505972146291593227\">https://twitter.com/Gankra_/status/1505972146291593227</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/Gankra_/status/1505972146291593227\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/37663fd2872232bfa24553d81b8b079cdd79fc11/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313233373135353532323631343336363230382f6c68686b554158395f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/brooksdavis\">@brooksdavis</a> <a href=\"https://twitter.com/MSpondee\">@MSpondee</a> one interesting interpretation of this is that it's exactly the same as blowing the stack: rust pretends like you have infinite stack but we install a guard page/probes that fault when you run out.\n\nCHERI *guarantees* a fault if you fuck this up, so it's kinda the same thing?</p><span>- Aria the Cat (@Gankra_)</span></div></div>",
        "id": 276093307,
        "sender_full_name": "Gankra",
        "timestamp": 1647886740
    },
    {
        "content": "<p>That just completely kills top-bit tagging though right?</p>",
        "id": 276094032,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647887049
    },
    {
        "content": "<p>yes</p>",
        "id": 276094109,
        "sender_full_name": "Gankra",
        "timestamp": 1647887081
    },
    {
        "content": "<p>but pointer-tagging is <em>always</em> a platform-specific trick, <em>especially</em> high-bit stuff</p>",
        "id": 276094222,
        "sender_full_name": "Gankra",
        "timestamp": 1647887125
    },
    {
        "content": "<p>Right, that's fine. The bigger issue is as you said there's no way to make <code>with_addr</code> be general, which means instead of killing  <code>as</code> casts and replacing them with methods we'll have to nuke them with no replacement.</p>",
        "id": 276095710,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647887682
    },
    {
        "content": "<p>with_addr defers to wrapping_offset's semantics already, so we just need a clear story for wrapping_offset</p>",
        "id": 276097874,
        "sender_full_name": "Gankra",
        "timestamp": 1647888668
    },
    {
        "content": "<p>(with_addr doesn't actually let you cheat on provenance, but provenance only \"matters\" when you load/store, as far as I know -- certainly that's CHERI's interpretation)</p>",
        "id": 276098410,
        "sender_full_name": "Gankra",
        "timestamp": 1647888925
    },
    {
        "content": "<p>Is it a recoverable fault</p>",
        "id": 276098500,
        "sender_full_name": "Jubilee",
        "timestamp": 1647888964
    },
    {
        "content": "<p>Like, the OS then has the option to kill the process or not, yes?</p>",
        "id": 276098555,
        "sender_full_name": "Jubilee",
        "timestamp": 1647888995
    },
    {
        "content": "<p>The OS might, but an application surely can't</p>",
        "id": 276098592,
        "sender_full_name": "Gankra",
        "timestamp": 1647889017
    },
    {
        "content": "<p>Ah I see.</p>",
        "id": 276098602,
        "sender_full_name": "Jubilee",
        "timestamp": 1647889023
    },
    {
        "content": "<p>(absolutely no idea, pure guess)</p>",
        "id": 276098617,
        "sender_full_name": "Gankra",
        "timestamp": 1647889033
    },
    {
        "content": "<p>like, what happens when you hit the stack's guard page</p>",
        "id": 276098663,
        "sender_full_name": "Gankra",
        "timestamp": 1647889060
    },
    {
        "content": "<p>i assume this is wholy identical</p>",
        "id": 276098675,
        "sender_full_name": "Gankra",
        "timestamp": 1647889067
    },
    {
        "content": "<p>Right.</p>",
        "id": 276098856,
        "sender_full_name": "Jubilee",
        "timestamp": 1647889157
    },
    {
        "content": "<p>I think it's a fun issue if <code>p.wrapping_offset(o).wrapping_offset(-o)</code> isn't guaranteed to yield p, because that is already guaranteed.</p>",
        "id": 276099828,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647889585
    },
    {
        "content": "<p>we're already writing a lot of checks with our mouth that our ass can't cash</p>",
        "id": 276099922,
        "sender_full_name": "Jubilee",
        "timestamp": 1647889638
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 276099937,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647889651
    },
    {
        "content": "<p>so like one more on the pile tbh just further illustrates the need to declare bankruptcy.</p>",
        "id": 276100031,
        "sender_full_name": "Jubilee",
        "timestamp": 1647889684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276098663\">said</a>:</p>\n<blockquote>\n<p>like, what happens when you hit the stack's guard page</p>\n</blockquote>\n<p><code>SIGSEGV</code>, which <code>std</code> turns into an abort</p>",
        "id": 276100175,
        "sender_full_name": "cuviper",
        "timestamp": 1647889785
    },
    {
        "content": "<p>Ah yes, and we have an absolutely godawful story for signal handling.</p>",
        "id": 276100353,
        "sender_full_name": "Jubilee",
        "timestamp": 1647889874
    },
    {
        "content": "<p>on that note, I wonder how untyped pointer access like stack-probing will work in CHERI</p>",
        "id": 276100375,
        "sender_full_name": "cuviper",
        "timestamp": 1647889890
    },
    {
        "content": "<p>Mind, I very rarely, almost never, actually see C programs try to do signal handling either.</p>",
        "id": 276100377,
        "sender_full_name": "Jubilee",
        "timestamp": 1647889892
    },
    {
        "content": "<p>or is stack probing just not a thing, given the stronger pointer protections already?</p>",
        "id": 276100467,
        "sender_full_name": "cuviper",
        "timestamp": 1647889924
    },
    {
        "content": "<p>I think from our perspective \"yes, there is a guard page, it's called the capability management itself.\"</p>",
        "id": 276100737,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890047
    },
    {
        "content": "<p>the thing is, stack overflow is not necessarily a bad pointer at all, just recursion gone too far most of the time</p>",
        "id": 276100894,
        "sender_full_name": "cuviper",
        "timestamp": 1647890140
    },
    {
        "content": "<p>okay but<br>\nstack pointers</p>",
        "id": 276100981,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276092368\">said</a>:</p>\n<blockquote>\n<p>idk, rust very universally discourages wrapping_offset, and we can potentially formalize \"wrapping_offset is not Free Real Estate and has platform-specific restrictions\"</p>\n</blockquote>\n<p>Whoa, what? Rust discourages <code>wrapping_offset</code>? Since when?</p>",
        "id": 276100989,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647890188
    },
    {
        "content": "<p>and probing is just protecting against going too far with a frame size greater than the guard page</p>",
        "id": 276100990,
        "sender_full_name": "cuviper",
        "timestamp": 1647890188
    },
    {
        "content": "<p>I have no idea how CHERI manages stack pointers and its size. I guess this must have been thought through already.</p>",
        "id": 276101067,
        "sender_full_name": "cuviper",
        "timestamp": 1647890253
    },
    {
        "content": "<p>I am not entirely sure, I am just saying that the stack pointer is in fact a pointer into memory also.</p>",
        "id": 276101133,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890283
    },
    {
        "content": "<p>And that the \"high-level\" idea of a pointer need not apply.</p>",
        "id": 276101175,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890305
    },
    {
        "content": "<p>Anyways, on CHERI, we can read the metadata and detect whether the pointer would actually go out of bounds, couldn't we?</p>",
        "id": 276101201,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890326
    },
    {
        "content": "<p>yeah, ok. a probe is just an offset from that stack pointer.</p>",
        "id": 276101212,
        "sender_full_name": "cuviper",
        "timestamp": 1647890340
    },
    {
        "content": "<blockquote>\n<p>An out of bounds access produces a hardware fault. In a simple program running in CheriBSD it’s usually turned into a SIGPROT which defaults to killing the process, but can be caught.</p>\n</blockquote>\n<p>Aha.</p>",
        "id": 276101276,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890382
    },
    {
        "content": "<p>I have no idea what we would do with that lmao.</p>",
        "id": 276101371,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890416
    },
    {
        "content": "<p>just give it a nicer <code>rtabort!</code> message, I suppose, like we do for stack overflow</p>",
        "id": 276101494,
        "sender_full_name": "cuviper",
        "timestamp": 1647890491
    },
    {
        "content": "<p>Also I feel I should note, as I have a few times before: The idea you can just shuffle-puck a pointer around in C is in fact depending on</p>\n<blockquote>\n<h3>6.3.2.3 Pointers</h3>\n<p>[...]<br>\n5. An integer may be converted to any pointer type. Except as previously specified, the result is<br>\n   implementation-defined, might not be correctly aligned, might not point to an entity of the referenced<br>\n   type, and might be a trap representation.</p>\n</blockquote>\n<p>having a consistent definition, and not merely a compiler-defined one... and how closely have you read your compiler manual, exactly? <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 276102065,
        "sender_full_name": "Jubilee",
        "timestamp": 1647890872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276099828\">said</a>:</p>\n<blockquote>\n<p>I think it's a fun issue if <code>p.wrapping_offset(o).wrapping_offset(-o)</code> isn't guaranteed to yield p, because that is already guaranteed.</p>\n</blockquote>\n<p>it <em>does</em> yield p, it just <em>also</em> sets a flag somewhere in the ~hardware that says \"if they dereference this i WILL fault\"</p>",
        "id": 276102457,
        "sender_full_name": "Gankra",
        "timestamp": 1647891101
    },
    {
        "content": "<p>That's not yielding <code>p</code>, though.</p>",
        "id": 276102528,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891123
    },
    {
        "content": "<p>Its yielding <code>invalidate(p)</code>.</p>",
        "id": 276102559,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891139
    },
    {
        "content": "<p>CHERI disagrees lol.</p>",
        "id": 276102577,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891151
    },
    {
        "content": "<p>p isn't just the memory representation of p, but also it's provenance, both in-memory and outside of memory.</p>",
        "id": 276102645,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891189
    },
    {
        "content": "<p>I mean in a technical sense yes, you are right, Connor, but I don't think users can observe the difference.</p>",
        "id": 276102650,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891192
    },
    {
        "content": "<p>They can, because it faults on dereference when <code>p</code> does not.</p>",
        "id": 276102691,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891216
    },
    {
        "content": "<p>yes but a program has a hard time observing it has terminated.</p>",
        "id": 276102795,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276100989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276092368\">said</a>:</p>\n<blockquote>\n<p>idk, rust very universally discourages wrapping_offset, and we can potentially formalize \"wrapping_offset is not Free Real Estate and has platform-specific restrictions\"</p>\n</blockquote>\n<p>Whoa, what? Rust discourages <code>wrapping_offset</code>? Since when?</p>\n</blockquote>\n<p>literally always? It took until 1.16.0 for us to even be willing to add it.</p>",
        "id": 276102796,
        "sender_full_name": "Gankra",
        "timestamp": 1647891261
    },
    {
        "content": "<p>Which is a crucial guarantee of <code>p.wrapping_offset(o)</code> -&gt; that <code>p.wrapping_offset(o).wrapping_offset(-o)</code> is <code>p</code> and has the same effects as <code>p</code>, in paticular, it's validity.</p>",
        "id": 276102842,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891293
    },
    {
        "content": "<p>At least under <em>my</em> tenure all of std was <em>incredibly</em> meticulous about <em>always</em> using <code>offset</code></p>",
        "id": 276102859,
        "sender_full_name": "Gankra",
        "timestamp": 1647891306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276102795\">said</a>:</p>\n<blockquote>\n<p>yes but a program has a hard time observing it has terminated.</p>\n</blockquote>\n<p>It alters the observable behaviour, though. It prevents output that would otherwise have occured.</p>",
        "id": 276102875,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891316
    },
    {
        "content": "<p>Right, I mean that the program is the user.</p>",
        "id": 276102885,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891326
    },
    {
        "content": "<p>Sorry, confusion in terms.</p>",
        "id": 276102900,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276102796\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276100989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276092368\">said</a>:</p>\n<blockquote>\n<p>idk, rust very universally discourages wrapping_offset, and we can potentially formalize \"wrapping_offset is not Free Real Estate and has platform-specific restrictions\"</p>\n</blockquote>\n<p>Whoa, what? Rust discourages <code>wrapping_offset</code>? Since when?</p>\n</blockquote>\n<p>literally always? It took until 1.16.0 for us to even be willing to add it.</p>\n</blockquote>\n<p>Interesting. I post-date 1.16 by a fair margin.<br>\nMy experience is that <code>wrapping_offset</code> is the only way to stick provenance back onto a pointer in Miri, and also it is useful for some kinds of creative code that I think cuviper has maintained in <code>primal</code></p>",
        "id": 276102903,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647891335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276102796\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276100989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276092368\">said</a>:</p>\n<blockquote>\n<p>idk, rust very universally discourages wrapping_offset, and we can potentially formalize \"wrapping_offset is not Free Real Estate and has platform-specific restrictions\"</p>\n</blockquote>\n<p>Whoa, what? Rust discourages <code>wrapping_offset</code>? Since when?</p>\n</blockquote>\n<p>literally always? It took until 1.16.0 for us to even be willing to add it.</p>\n</blockquote>\n<p>MaybeUninit was 1.31. <code>addr_of</code> was 1.51. <code>asm</code> was 1.59. Are all of those \"discouraged\"?</p>",
        "id": 276103006,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891374
    },
    {
        "content": "<p>to be clear: wrapping_offset is useful and necessary but you should <em>definitely</em> always start off by trying to use normal offset, because it is Better and Right</p>",
        "id": 276103032,
        "sender_full_name": "Gankra",
        "timestamp": 1647891391
    },
    {
        "content": "<p>chadyes.jpg</p>",
        "id": 276103034,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891391
    },
    {
        "content": "<p>wrapping_offset is the \"i am doing crimes\" offset</p>",
        "id": 276103054,
        "sender_full_name": "Gankra",
        "timestamp": 1647891404
    },
    {
        "content": "<p>Really, one of the problems we're running into is this:<br>\nLLVM has not done the best job of keeping its own house clean and its own semantics in order.</p>",
        "id": 276103103,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103054\">said</a>:</p>\n<blockquote>\n<p>wrapping_offset is the \"i am doing crimes\" offset</p>\n</blockquote>\n<p>I'm worried that it is the \"the offset contract is too narrow for the way I think about pointers\" offset</p>",
        "id": 276103118,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647891441
    },
    {
        "content": "<p>And they adhere to <strong>much</strong> less strict stability guarantees than we do.</p>",
        "id": 276103157,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891464
    },
    {
        "content": "<p>And cheri will happily and safely abort!() your program if you are wrong, just like index-out-of-bounds :)</p>",
        "id": 276103187,
        "sender_full_name": "Gankra",
        "timestamp": 1647891479
    },
    {
        "content": "<p>it's not necessarily useful to complain about llvm here, since gcc has similar wonkyness around e.g. not actually being able to have offsets larger than isize aiui</p>",
        "id": 276103286,
        "sender_full_name": "Gankra",
        "timestamp": 1647891525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103187\">said</a>:</p>\n<blockquote>\n<p>And cheri will happily and safely abort!() your program if you are wrong, just like index-out-of-bounds :)</p>\n</blockquote>\n<p>Except the difference here is that CHERI is aborting on <code>[].get(0)</code> instead of <code>[][0]</code>/<code>[].get_unchecked(0)</code>.</p>",
        "id": 276103306,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891543
    },
    {
        "content": "<p>no?</p>",
        "id": 276103335,
        "sender_full_name": "Gankra",
        "timestamp": 1647891562
    },
    {
        "content": "<p>pointer loads can <em>always</em> fault</p>",
        "id": 276103343,
        "sender_full_name": "Gankra",
        "timestamp": 1647891569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103286\">said</a>:</p>\n<blockquote>\n<p>it's not necessarily useful to complain about llvm here, since gcc has similar wonkyness around e.g. not actually being able to have offsets larger than isize aiui</p>\n</blockquote>\n<p>My indictments of LLVM can be considered applicable to all C compilers, tbh.</p>",
        "id": 276103426,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891604
    },
    {
        "content": "<p>A pointer load from a pointer that the language guarantees is valid cannot ever fault on a valid implementation, period, not in any way that affects the observable behaviour of the program in contradiction of the as-if rule.</p>",
        "id": 276103441,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891613
    },
    {
        "content": "<p>that's an exceptionally strong claim that sounds extremely untrue in practice</p>",
        "id": 276103493,
        "sender_full_name": "Gankra",
        "timestamp": 1647891648
    },
    {
        "content": "<p>Yeah where does that claim come from?</p>",
        "id": 276103527,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891673
    },
    {
        "content": "<p>like at a minimum this is objectively false for CoW memory</p>",
        "id": 276103545,
        "sender_full_name": "Gankra",
        "timestamp": 1647891689
    },
    {
        "content": "<p>It comes from the fact that the as-if rule guarantees the observable behaviour of the program be preserved unless undefined behaviour,</p>",
        "id": 276103564,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891699
    },
    {
        "content": "<p>what as-if rule?</p>",
        "id": 276103581,
        "sender_full_name": "Gankra",
        "timestamp": 1647891711
    },
    {
        "content": "<p>Literally what \"as-if\" rule?</p>",
        "id": 276103584,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103545\">said</a>:</p>\n<blockquote>\n<p>like at a minimum this is objectively false for CoW memory</p>\n</blockquote>\n<p>If the fault doesn't affect the observable behaviour, then it's fine. But if I have</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"bar: {}\"</span><span class=\"p\">,</span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">q</span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Then it's required to print </p>\n<blockquote>\n<p>foo<br>\nbar: 0</p>\n</blockquote>",
        "id": 276103887,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891876
    },
    {
        "content": "<p>well no, stdout could be missing</p>",
        "id": 276103923,
        "sender_full_name": "Gankra",
        "timestamp": 1647891894
    },
    {
        "content": "<p>or you could run out of stack</p>",
        "id": 276103932,
        "sender_full_name": "Gankra",
        "timestamp": 1647891898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103584\">said</a>:</p>\n<blockquote>\n<p>Literally what \"as-if\" rule?</p>\n</blockquote>\n<p>The one that's at the very least implied in the fact that the language makes any guarantees of behaviour.,</p>",
        "id": 276103933,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891900
    },
    {
        "content": "<p>Yeah you have two panics there.</p>",
        "id": 276103979,
        "sender_full_name": "Jubilee",
        "timestamp": 1647891932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103923\">said</a>:</p>\n<blockquote>\n<p>well no, stdout could be missing</p>\n</blockquote>\n<p>Print as in write to w/e stdout is.</p>",
        "id": 276103993,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891940
    },
    {
        "content": "<p>If there's no stdout, then it panics, yes. If there is a stdout, though, it writes to it. This is the observable behaviour of the program.</p>",
        "id": 276104085,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647891971
    },
    {
        "content": "<p>And yes, stack overflow is an implementation limit, but a clearly known one (and likely unapplicable if that code is written inside of <code>main</code>)</p>",
        "id": 276104154,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892016
    },
    {
        "content": "<p>I am pretty sure <code>println!</code> can panic if <code>stdout</code> is present but it can't be acquired.</p>",
        "id": 276104196,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892040
    },
    {
        "content": "<p>There is currently some ambiguity about whether programs are allowed to close stdout. <code>std::io::Stdout</code> handles <code>EBADF</code>, but nothing prevents an unrelated <code>File::open</code> from later reusing fd value 1.</p>",
        "id": 276104217,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1647892054
    },
    {
        "content": "<p>laughing.</p>",
        "id": 276104314,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892087
    },
    {
        "content": "<p>Programming languages will <em>always</em> be \"i'm just doing my best!\"</p>",
        "id": 276104333,
        "sender_full_name": "Gankra",
        "timestamp": 1647892097
    },
    {
        "content": "<p>... Allow me to be more precise. Rust does not allow the read from <code>q</code> to be the cause of a crash, if any, because dereferencing a pointer does not panic and in that code is well-defined from a language perspective.</p>",
        "id": 276104429,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276104154\">said</a>:</p>\n<blockquote>\n<p>And yes, stack overflow is an implementation limit, but a clearly known one (and likely unapplicable if that code is written inside of <code>main</code>)</p>\n</blockquote>\n<p>i mean, this exact same argument would have applied when computers started introducing memory protection, right? like \"everyone knows you can just access all of memory whenever you want!\"</p>",
        "id": 276104444,
        "sender_full_name": "Gankra",
        "timestamp": 1647892163
    },
    {
        "content": "<p>It would be the same if linux decided to unmap my stack out from under me, and hand my program a SIGSEGV on the read. That isn't a valid implementation.</p>",
        "id": 276104506,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892201
    },
    {
        "content": "<p>rust largely does not guarantee forward progress, only what happens if we <em>do</em> make progress</p>",
        "id": 276104597,
        "sender_full_name": "Gankra",
        "timestamp": 1647892239
    },
    {
        "content": "<p>We have deprecated methods before because they proved to be rotten on the mere premise of them. You are advancing an excellent argument in favor of deprecating <code>wrapping_offset</code>.</p>",
        "id": 276104654,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892276
    },
    {
        "content": "<p>So... I can't rely on my program doing anything at all other then crash? That makes rust a very difficult language to use.</p>",
        "id": 276104669,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892286
    },
    {
        "content": "<p>this is the exact guarantee all programming languages make, I regret to inform you</p>",
        "id": 276104688,
        "sender_full_name": "Gankra",
        "timestamp": 1647892301
    },
    {
        "content": "<p>Well i dont know we all seem to be doing a pretty good job at using it <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 276104690,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1647892303
    },
    {
        "content": "<p>I think we can read the metadata though.</p>",
        "id": 276104712,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892314
    },
    {
        "content": "<p>And thus it might be possible to write <code>try_map_addr</code>.</p>",
        "id": 276104777,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892331
    },
    {
        "content": "<p>(proof: task manager exists and wins all arguments)</p>",
        "id": 276104847,
        "sender_full_name": "Gankra",
        "timestamp": 1647892362
    },
    {
        "content": "<p>From what I read it looks like we might be getting Rust 2 sooner than we thought.</p>",
        "id": 276104869,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647892371
    },
    {
        "content": "<p>lol</p>",
        "id": 276104901,
        "sender_full_name": "Gankra",
        "timestamp": 1647892386
    },
    {
        "content": "<p>Outside manipulation is very out of scope.</p>",
        "id": 276104911,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892391
    },
    {
        "content": "<p><span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 276104915,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892392
    },
    {
        "content": "<p>AHA.</p>",
        "id": 276104930,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892400
    },
    {
        "content": "<p>But this is internal manipulation by the implementation of rust in play.</p>",
        "id": 276104961,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892419
    },
    {
        "content": "<p>But you see, from the perspective of Rust, the CHERI hardware <strong>is</strong> outside intervention.</p>",
        "id": 276104975,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892424
    },
    {
        "content": "<p>Your program is terminated by force majeure.</p>",
        "id": 276105006,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892441
    },
    {
        "content": "<p>Not \"I'm the OS and I'm being told to kill this process\".</p>",
        "id": 276105048,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892446
    },
    {
        "content": "<p>...except that's exactly what happens!</p>",
        "id": 276105075,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276104975\">said</a>:</p>\n<blockquote>\n<p>But you see, from the perspective of Rust, the CHERI hardware <strong>is</strong> outside intervention.</p>\n</blockquote>\n<p>The same argument would see x86 hardware faults as outside intervention as well, though.</p>",
        "id": 276105082,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892463
    },
    {
        "content": "<p>At that point /proc/self/mem comes back into play and we lose the ability to actually reason about things.</p>",
        "id": 276105083,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647892463
    },
    {
        "content": "<p>You dereference the pointer, the hardware gets <del>God</del> the OS on the line, and the OS decides what happens next.</p>",
        "id": 276105138,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892499
    },
    {
        "content": "<p>So can I have gcc just insert a call to mprotect that deallocates the stack? Oh, well, the #PF the kernel turns into SIGSEGV is outside intervention.</p>",
        "id": 276105146,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276100990\">said</a>:</p>\n<blockquote>\n<p>and probing is just protecting against going too far with a frame size greater than the guard page</p>\n</blockquote>\n<p>funny thing about not needing a guard page is you can make the stack some arbitrary size, like 777 bytes, with byte granularity allocations before and after (say, <code>String</code>s' contents) and be perfectly safe</p>",
        "id": 276105254,
        "sender_full_name": "eddyb",
        "timestamp": 1647892575
    },
    {
        "content": "<p>Forgive me if I find the argument that the CPU trapping, being caused precisely by the precise rust code that rust prescribes to be a functional no-op, is outside intervention and not in scope for the semantics of rust unconvincing.</p>",
        "id": 276105331,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892639
    },
    {
        "content": "<p>lccc is not required to support <code>wrapping_offset</code> nor CHERI. <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 276105544,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892752
    },
    {
        "content": "<p>This isn't from my perspective as an implementor, this from my perspective as a user.</p>",
        "id": 276105610,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892787
    },
    {
        "content": "<p>Well that's fair.</p>",
        "id": 276105704,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892815
    },
    {
        "content": "<p>Anyways,</p>\n<blockquote>\n<p>The delayed check only considers the value of the pointer that was dereferenced, not the intermediate values used during the computation of the final result. For example, <code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> is always the same as <code>x</code>. In other words, leaving the allocated object and then re-entering it later is permitted.</p>\n</blockquote>\n<p>I think we simply got this wrong tho'.</p>",
        "id": 276105748,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892828
    },
    {
        "content": "<p>We have done <em>far</em> more extreme changes in the past with basically no problems -- mem::unitialized is the most notable one here</p>",
        "id": 276105762,
        "sender_full_name": "Gankra",
        "timestamp": 1647892833
    },
    {
        "content": "<p>And all code that runs on all supported platforms will be unaffected</p>",
        "id": 276105802,
        "sender_full_name": "Gankra",
        "timestamp": 1647892857
    },
    {
        "content": "<p>This is carving out \"but on weird platforms, the world is more complicated\"</p>",
        "id": 276105835,
        "sender_full_name": "Gankra",
        "timestamp": 1647892879
    },
    {
        "content": "<p>This also goes to soundness.</p>",
        "id": 276105842,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647892887
    },
    {
        "content": "<p>And it should be noted that <code>wrapping_offset</code> basically still works if you use it \"as intended\"... you can push a pointer VERY far out of bounds on CHERI without breaking The Law.</p>",
        "id": 276105858,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892900
    },
    {
        "content": "<p>no one in std would ever argue that adding an abort!() for a degenerate situation is unsound</p>",
        "id": 276105946,
        "sender_full_name": "Gankra",
        "timestamp": 1647892926
    },
    {
        "content": "<p>at least, very far out of bounds relatively speaking if T is to something less than 4kb in stride.</p>",
        "id": 276105950,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892927
    },
    {
        "content": "<p>As a random user who tries to undersand SB/miri/etc and unsafe (And def. not a compiler writer) I share that perspective. I think there's a difference between outside intervention and the machine code rust lowers itself having the problem. This sounds more like \"This target/hardware has semantics that are incompatible with the rust abstract machine\". And sure, rust could change what wrapping_offset means but wouldn't that be a breaking change? I'm pretty sure I've seen wrapping_offset used multiple times to create a ptr with an arbitrary addr and a given provenance, and I think I've seen Ralf suggest that too</p>",
        "id": 276105971,
        "sender_full_name": "Nick12",
        "timestamp": 1647892937
    },
    {
        "content": "<p>Note that <em>this will still be allowed on CHERI</em> there will just be restrictions on how large the offset can be, dependent on how large the allocation is</p>",
        "id": 276106064,
        "sender_full_name": "Gankra",
        "timestamp": 1647892986
    },
    {
        "content": "<p>The clauses of our stability contract add up to something more precisely phrased as \"breaking changes aren't breaking it if's necessary for soundness\".</p>",
        "id": 276106069,
        "sender_full_name": "Jubilee",
        "timestamp": 1647892988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103118\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276103054\">said</a>:</p>\n<blockquote>\n<p>wrapping_offset is the \"i am doing crimes\" offset</p>\n</blockquote>\n<p>I'm worried that it is the \"the offset contract is too narrow for the way I think about pointers\" offset</p>\n</blockquote>\n<p>as in, you leave the allocation and come back? or do you hop <em>between</em> allocations? (the latter being UB to actually access memory through)</p>\n<p>what CHERI and miri do is they more concretely define the concept of \"object\" from the C standard (as \"allocation\") and effectively deny \"allocation hopping\", at various levels - a lot of misunderstanding around pointers as they exist in C or Rust is due to being fuzzy about that \"allocation\" concept</p>",
        "id": 276106073,
        "sender_full_name": "eddyb",
        "timestamp": 1647892990
    },
    {
        "content": "<p>Yeah, this straight up seems to be a fundamental incompatibility between the prescribed semantics of the rust abstract machine and the emulation that is <em>insert-compiler-here</em> on cheri-<em>os</em>.</p>",
        "id": 276106139,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219940\">Nick12</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276105971\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure I've seen wrapping_offset used multiple times to create a ptr with an arbitrary addr and a given provenance, and I think I've seen Ralf suggest that too</p>\n</blockquote>\n<p>that's only within the same allocation, which is the only valid use for that operation (if you plan to use the resulting pointer for memory access), and that will <em>never</em> trap by definition</p>",
        "id": 276106145,
        "sender_full_name": "eddyb",
        "timestamp": 1647893029
    },
    {
        "content": "<p>The standard \"I am tagging the low bits based on my knowledge of alignment\" stuff all works</p>",
        "id": 276106148,
        "sender_full_name": "Gankra",
        "timestamp": 1647893031
    },
    {
        "content": "<p>There's no formal Rust abstract machine prescription stuff tho'.</p>",
        "id": 276106209,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893045
    },
    {
        "content": "<p>Anything based on high bits was <em>always</em> platform-specific and unportable</p>",
        "id": 276106210,
        "sender_full_name": "Gankra",
        "timestamp": 1647893045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106209\">said</a>:</p>\n<blockquote>\n<p>There's no formal Rust abstract machine prescription stuff tho'.</p>\n</blockquote>\n<p>stdlib docs FTW.</p>",
        "id": 276106233,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893058
    },
    {
        "content": "<p>Also, the \"things are weird on weird machines\" argument only goes so far.</p>",
        "id": 276106287,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893085
    },
    {
        "content": "<p>If every update to documentation has to be treated as a strict behavior guarantee forever, then we need to FCP every single documentation change.</p>",
        "id": 276106334,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106069\">said</a>:</p>\n<blockquote>\n<p>The clauses of our stability contract add up to something more precisely phrased as \"breaking changes aren't breaking it if's necessary for soundness\".</p>\n</blockquote>\n<p>Does this apply if there is no soundness issue in existing platforms? I thought this was meant to fix bugs, not add new platforms where sound things can't be lowered</p>",
        "id": 276106363,
        "sender_full_name": "Nick12",
        "timestamp": 1647893123
    },
    {
        "content": "<p>Which we have not been doing.</p>",
        "id": 276106377,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893127
    },
    {
        "content": "<p>please give me some <em>useful</em> code that you believe is good and should work but won't work under CHERI so we can have a productive conversation. ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE) is not code anyone <em>actually</em> has a reason to care about</p>",
        "id": 276106409,
        "sender_full_name": "Gankra",
        "timestamp": 1647893147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276102065\">said</a>:</p>\n<blockquote>\n<p>Also I feel I should note, as I have a few times before: The idea you can just shuffle-puck a pointer around in C is in fact depending on</p>\n<blockquote>\n<h3>6.3.2.3 Pointers</h3>\n<p>[...]<br>\n5. An integer may be converted to any pointer type. Except as previously specified, the result is<br>\n   implementation-defined, might not be correctly aligned, might not point to an entity of the referenced<br>\n   type, and might be a trap representation.</p>\n</blockquote>\n<p>having a consistent definition, and not merely a compiler-defined one... and how closely have you read your compiler manual, exactly? <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>\n</blockquote>\n<p>This is (effectively) not true, you are missing the (placed later, lol C standard) statement:</p>\n<blockquote>\n<p>The following type designates an unsigned integer type with the property that any valid pointer to void can be converted to this type, then converted back to pointer to void, and the result will compare equal to the original pointer. <code>uintptr_t</code></p>\n</blockquote>\n<p>So that's only true in the sense that uintptr_t is optional, and thus is irrelevant to these arguments.</p>",
        "id": 276106464,
        "sender_full_name": "Talchas",
        "timestamp": 1647893163
    },
    {
        "content": "<p>Ahh, but there's a caveat: that only covers exact round-trips.</p>",
        "id": 276106554,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893216
    },
    {
        "content": "<p>Manipulating <code>uintptr_t</code> does not provide the same guarantee, obviously.</p>",
        "id": 276106590,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893239
    },
    {
        "content": "<p>yes, it's technically allowed to have a uselessly different representation, because indeed, lol C</p>",
        "id": 276106598,
        "sender_full_name": "Talchas",
        "timestamp": 1647893243
    },
    {
        "content": "<p>Rust prescribes twos-compliment for signed integers. You can't just pick a platform that does ones-compliment arithmetic, throw rust on it, and say \"Oh weird platforms are weird\" to avoid the fact you've altered the prescribed behaviour of the language.<br>\nThis may or may not be comparable, but the argument is not all-defeating.</p>",
        "id": 276106622,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276104712\">said</a>:</p>\n<blockquote>\n<p>I think we can read the metadata though.</p>\n</blockquote>\n<p>yeah, CHERI doesn't make any effort to hide the metadata (at least right now, would be cool if the perms bits could control it), I <em>think</em> you can literally transmute <code>*T</code> to <code>u128</code></p>\n<p>however, I would still try to make such an API work with the most restrictive form of miri (i.e. the one use for CTFE) though, and some kind of metadata-hiding CHERI variant, it's easy to be too platform-specific D:</p>",
        "id": 276106710,
        "sender_full_name": "eddyb",
        "timestamp": 1647893285
    },
    {
        "content": "<p>CHERI explicitly notes: <a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf#page=28\">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf#page=28</a></p>\n<blockquote>\n<p>In general, programmers should not rely on support for arbitrary out-of-bounds pointers.<br>\nNevertheless, in practice, we have found that the CHERI capability compression scheme sup-<br>\nports almost all in-the-field out-of-bounds behavior in widely used software such as FreeBSD,<br>\nPostgreSQL, and WebKit.</p>\n</blockquote>\n<p>Are you interested in hairier code than \"an entire operation system, a major database, and the most complicated webbrowser\"?</p>",
        "id": 276106758,
        "sender_full_name": "Gankra",
        "timestamp": 1647893313
    },
    {
        "content": "<p>Lower bit pointer tagging would work fine for CHERI due to needing to go less than 1KiB out of bounds, right?</p>",
        "id": 276106819,
        "sender_full_name": "bjorn3",
        "timestamp": 1647893353
    },
    {
        "content": "<p>yes</p>",
        "id": 276106835,
        "sender_full_name": "Gankra",
        "timestamp": 1647893360
    },
    {
        "content": "<p>(the link I posted formally describes the constraint)</p>",
        "id": 276106853,
        "sender_full_name": "Gankra",
        "timestamp": 1647893373
    },
    {
        "content": "<p>alignment tagging in particular will <em>always work</em> on <em>any bounds-checking system</em> for a relatively simple reason: <code>align_of::&lt;T&gt;() &lt;= size_of::&lt;T&gt;()</code> (I guess outside of ZSTs heh)</p>",
        "id": 276106937,
        "sender_full_name": "eddyb",
        "timestamp": 1647893407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106334\">said</a>:</p>\n<blockquote>\n<p>If every update to documentation has to be treated as a strict behavior guarantee forever, then we need to FCP every single documentation change.</p>\n</blockquote>\n<p>I think it would be a huge issue if users could not rely on the documentation of the standard library, especially the safety constraints and allowances that unsafe code relies upon to avoid undefined behaviour.</p>",
        "id": 276106939,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106409\">said</a>:</p>\n<blockquote>\n<p>please give me some <em>useful</em> code that you believe is good and should work but won't work under CHERI so we can have a productive conversation. ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE) is not code anyone <em>actually</em> has a reason to care about</p>\n</blockquote>\n<p>This <em>only</em> matters because of an intention/desire to deprecate and remove ptr-int-ptr roundtrips. This isn't something that's come up normally because rust just lets you do <code>as</code>.</p>",
        "id": 276106952,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647893414
    },
    {
        "content": "<p>Can we say that ptr2int2ptr is not valid and introduce an operation that can only do pointer tagging with less than 10bits?</p>",
        "id": 276106966,
        "sender_full_name": "bjorn3",
        "timestamp": 1647893421
    },
    {
        "content": "<p>if you make it alignment-oriented it will be quite reliable IMO</p>",
        "id": 276107053,
        "sender_full_name": "eddyb",
        "timestamp": 1647893491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106622\">said</a>:</p>\n<blockquote>\n<p>Rust prescribes twos-compliment for signed integers. You can't just pick a platform that does ones-compliment arithmetic, throw rust on it, and say \"Oh weird platforms are weird\" to avoid the fact you've altered the prescribed behaviour of the language.<br>\nThis may or may not be comparable, but the argument is not all-defeating.</p>\n</blockquote>\n<p>this changes the behaviour under forward progress, not whether forward progress is made</p>\n<p>now you have a fair complaint that supporting CHERI <em>strongly</em> encourages us to decouple usize and *mut</p>",
        "id": 276107062,
        "sender_full_name": "Gankra",
        "timestamp": 1647893499
    },
    {
        "content": "<p>In CHERI's case, it's adding undefined behaviour to the program.</p>",
        "id": 276107154,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893549
    },
    {
        "content": "<p>no the behaviour is <em>extremely</em> defined</p>",
        "id": 276107184,
        "sender_full_name": "Gankra",
        "timestamp": 1647893569
    },
    {
        "content": "<p>Maybe at the hardware level, but not at any other level.</p>",
        "id": 276107205,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893586
    },
    {
        "content": "<p>And compilers will assume that it won't trap.</p>",
        "id": 276107221,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893597
    },
    {
        "content": "<p>aborting is pretty defined behavior tbh.</p>",
        "id": 276107230,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893601
    },
    {
        "content": "<p>It's not what I would like, mind.</p>",
        "id": 276107241,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893614
    },
    {
        "content": "<p>llvm I know presumes that any memory access at all other than a volatile write will continue execution.</p>",
        "id": 276107280,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106966\">said</a>:</p>\n<blockquote>\n<p>Can we say that ptr2int2ptr is not valid and introduce an operation that can only do pointer tagging with less than 10bits?</p>\n</blockquote>\n<p>well, that depends, do you care about anything where pointers are being stored in usize/uintptr_t for various \"bad\" reasons, mostly C FFI reasons: C pointers have Ord gotchas, vaguely reasonable C styles (\"if you can't deref it right now don't put it in a pointer\"), ancient backcompat (is there some old windows API that only takes an int that you want a pointer in? I know there's terrible posix ones), etc.</p>",
        "id": 276107350,
        "sender_full_name": "Talchas",
        "timestamp": 1647893660
    },
    {
        "content": "<p>i maintain that this is identical behaviour to getting random stack overflows. library code cannot possibly know what stack size it will be run on. it just has to do it's best and sometimes the configuration it was run under means it gets shot and dies.</p>",
        "id": 276107351,
        "sender_full_name": "Gankra",
        "timestamp": 1647893661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> IOW, if <code>(ptr: *T).offset(align_of::&lt;T&gt;())</code> is not UB, and <code>ptr.addr() % align_of::&lt;T&gt;() == 0</code> (both of them true for a pointer obtained from <code>&amp;T</code> or any other safe pointer with <code>size_of::&lt;T&gt;() &gt; 0</code>), you can use those lower bits as much as you want</p>",
        "id": 276107364,
        "sender_full_name": "eddyb",
        "timestamp": 1647893668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276107351\">said</a>:</p>\n<blockquote>\n<p>i maintain that this is identical behaviour to getting random stack overflows. library code cannot possibly know what stack size it will be run on. it just has to do it's best and sometimes the configuration it was run under means it gets shot and dies.</p>\n</blockquote>\n<p>Now program code can't rely on it, though.</p>",
        "id": 276107393,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893685
    },
    {
        "content": "<p>uhh, stack overflow is not even remotely the same</p>",
        "id": 276107410,
        "sender_full_name": "Talchas",
        "timestamp": 1647893696
    },
    {
        "content": "<p>If I plop my example code into main, can I not rely on it running to completion, presuming I don't send it any signals and my computer doesn't HCF?</p>",
        "id": 276107456,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893726
    },
    {
        "content": "<p>Also, is llvm allowed to move the I/O past the read?</p>",
        "id": 276107661,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893823
    },
    {
        "content": "<p>your example code tries to acquire the lock on stdout sooooo</p>",
        "id": 276107663,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893823
    },
    {
        "content": "<p><em>please</em> specify code that won't still have that property that is <em>actually useful</em></p>",
        "id": 276107671,
        "sender_full_name": "Gankra",
        "timestamp": 1647893827
    },
    {
        "content": "<p>what's kind of sad is that this discussion would be moot if we were willing to accept a 4x increase in pointer size instead of 2x, because then all bytes would be byte granularity</p>",
        "id": 276107723,
        "sender_full_name": "eddyb",
        "timestamp": 1647893863
    },
    {
        "content": "<p>I don't have any specific useful code, but that doesn't mean it doesn't exist.</p>",
        "id": 276107791,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647893891
    },
    {
        "content": "<p>(it's even better than that because it's actually the same size for slices, since byte granularity CHERI lets you fit a whole <code>&amp;[T]</code> in one <code>*T</code>)</p>",
        "id": 276107792,
        "sender_full_name": "eddyb",
        "timestamp": 1647893892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276107723\">said</a>:</p>\n<blockquote>\n<p>... if <strong>we</strong> were willing to accept ...</p>\n</blockquote>\n<p>well, not Rust devs, but \"everyone with an interest in CHERI\"</p>",
        "id": 276107851,
        "sender_full_name": "eddyb",
        "timestamp": 1647893937
    },
    {
        "content": "<p>I am actually very, very sympathetic to your positions in general, Connor, but this is the point at which I feel concern-trolled, to be quite honest.</p>",
        "id": 276107880,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893956
    },
    {
        "content": "<p>My concern is on the stability of rust and not fundamentally sidestepping it.<br>\nIt may be reasonable to change the guarantees of the function ex-post-facto, but I would advise extraordinary caution, since this fundamentally alters soundness of programs.</p>",
        "id": 276108019,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894027
    },
    {
        "content": "<p>i agree, there is no useful progress to be made if you're unwilling to specify a usecase</p>",
        "id": 276108026,
        "sender_full_name": "Gankra",
        "timestamp": 1647894032
    },
    {
        "content": "<p>I promise you, I will do my best to make sure this does not harm any existing programs.</p>",
        "id": 276108061,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894058
    },
    {
        "content": "<p>NB: it's not unsound unless you optimize assuming it doesn't happen. randomly killing the process is not unsound, that's why we inject panics for various things</p>",
        "id": 276108096,
        "sender_full_name": "eddyb",
        "timestamp": 1647894076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276108096\">said</a>:</p>\n<blockquote>\n<p>NB: it's not unsound unless you optimize assuming it doesn't happen. randomly killing the process is not unsound, that's why we inject panics for various things</p>\n</blockquote>\n<p>At least llvm assumes a memory read can't kill the process.</p>",
        "id": 276108155,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894108
    },
    {
        "content": "<p>it cannot affect the soundness of existing programs, rust does not run on any architecture where wrapping_offset would need restrictions</p>",
        "id": 276108230,
        "sender_full_name": "Gankra",
        "timestamp": 1647894128
    },
    {
        "content": "<p>lccc will likely as well unless the read has an access class contianing <code>volatile</code>.</p>",
        "id": 276108278,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894152
    },
    {
        "content": "<p>LLVM assumes no such thing? it assumes that code executing <em>after</em> a <code>load</code> (<strong>EDIT</strong>: after it \"becomes inevitable\") can <code>load</code> again from the same address without trapping</p>",
        "id": 276108351,
        "sender_full_name": "eddyb",
        "timestamp": 1647894203
    },
    {
        "content": "<p>?</p>",
        "id": 276108388,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894230
    },
    {
        "content": "<p>or, sorry, I forgot the \"inevitability\" thing</p>",
        "id": 276108455,
        "sender_full_name": "eddyb",
        "timestamp": 1647894249
    },
    {
        "content": "<p>Also, this case <em>is</em> the same address.</p>",
        "id": 276108487,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894270
    },
    {
        "content": "<p>I mean, the real problem, tbh</p>",
        "id": 276108609,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894345
    },
    {
        "content": "<p>if a memory access is \"inevitable\" (whatever the exact UB-wording is), it assumes that it won't trap. there might be some interesting things here wrt removing software bounds-checking on e.g. Rust slices</p>",
        "id": 276108672,
        "sender_full_name": "eddyb",
        "timestamp": 1647894364
    },
    {
        "content": "<blockquote>\n<p>The allowed side-effects for volatile accesses are limited. If a non-volatile store to a given address would be legal, a volatile operation may modify the memory at that address. A volatile operation may not modify any other memory accessible by the module being compiled. A volatile operation may not call any code in the current module.</p>\n<p>The compiler may assume execution will continue after a volatile operation, so operations which modify memory or may have undefined behavior can be hoisted past a volatile operation.</p>\n</blockquote>\n<p><a href=\"https://llvm.org/docs/LangRef.html#volatile-memory-accesses\">https://llvm.org/docs/LangRef.html#volatile-memory-accesses</a><br>\nI'd be suprised if non-volatile accesses have <em>less</em> guarantees to the optimizer than volatile-guarantees.</p>",
        "id": 276108689,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894372
    },
    {
        "content": "<p>but we were talking about <code>wrapping_offset</code> not <code>load</code>/<code>store</code> anyway</p>",
        "id": 276108716,
        "sender_full_name": "eddyb",
        "timestamp": 1647894388
    },
    {
        "content": "<p>wrapping_offset into a read (in the example case, from a println)</p>",
        "id": 276108765,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894417
    },
    {
        "content": "<p><code>wrapping_offset</code> (non-<code>inbounds</code> GEP) makes LLVM lose any guarantees about the pointer being useful, that it might've had before. unless it's constant-folded out, ofc</p>",
        "id": 276108850,
        "sender_full_name": "eddyb",
        "timestamp": 1647894478
    },
    {
        "content": "<p>the real problematic code, IMO, is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cap</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"p\">.</span><span class=\"n\">into_raw_parts</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr_wrapped</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"n\">HUGE</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">HUGE</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>under optimization.</p>",
        "id": 276108942,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894512
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// p is created from a Rust reference, dereferencable</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// equality replaces p with q, sound because same provenance and value.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">q</span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// crash</span>\n<span class=\"n\">platform_call</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Again, this is all a bit lost in the weeds. The main problem is that we're trying to deprecate not just fundamental parts of Rust but a fundamental mental model, to support a weird platform, and claiming that this somehow doesn't de facto break backwards compatibility.</p>",
        "id": 276108962,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647894519
    },
    {
        "content": "<p>CHERI's C++ implementation is built on top of clang, so seemingly this llvm boogeyman is not actually a problem</p>",
        "id": 276109022,
        "sender_full_name": "Gankra",
        "timestamp": 1647894552
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 276109032,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> optimizing the <code>wrapping_offset</code>s, the <code>read</code>s, or both?</p>",
        "id": 276109072,
        "sender_full_name": "eddyb",
        "timestamp": 1647894587
    },
    {
        "content": "<p>\"lol, lmao\".</p>",
        "id": 276109091,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894599
    },
    {
        "content": "<p>Pick any or both.</p>",
        "id": 276109147,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894608
    },
    {
        "content": "<p>I can think of so many possibilities of that.</p>",
        "id": 276109194,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894639
    },
    {
        "content": "<p>(I was just asking for clarification of \"under optimization\", to be clear)</p>",
        "id": 276109198,
        "sender_full_name": "eddyb",
        "timestamp": 1647894643
    },
    {
        "content": "<p>Uhh, I think optimizing either would remove the SIGSEGV.</p>",
        "id": 276109239,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276108962\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// p is created from a Rust reference, dereferencable</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// equality replaces p with q, sound because same provenance and value.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">q</span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// crash</span>\n<span class=\"n\">platform_call</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Again, this is all a bit lost in the weeds. The main problem is that we're trying to deprecate not just fundamental parts of Rust but a fundamental mental model, to support a weird platform, and claiming that this somehow doesn't de facto break backwards compatibility.</p>\n</blockquote>\n<p>You misunderstand: Rust (and C, and C++) are already foundationally <em>broken</em> because pointer provenance is genuinely gibberish. CHERI is just the \"excuse\" to sit down and fix it because people who harumph about \"real\" things and \"hardware\" now lose the argument</p>",
        "id": 276109247,
        "sender_full_name": "Gankra",
        "timestamp": 1647894672
    },
    {
        "content": "<p>Like <strong>my</strong> only concern is really \"this code runs fine under optimization but crashes under debug???\" issues.</p>",
        "id": 276109251,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109022\">said</a>:</p>\n<blockquote>\n<p>CHERI's C++ implementation is built on top of clang, so seemingly this llvm boogeyman is not actually a problem</p>\n</blockquote>\n<p>C++ doesn't have <code>wrapping_offset</code>.</p>",
        "id": 276109252,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894677
    },
    {
        "content": "<p>Yes but there is no such language as \"C\" or \"C++\" only a pile of weird implementations that code vaguely works on</p>",
        "id": 276109309,
        "sender_full_name": "Gankra",
        "timestamp": 1647894714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109198\">said</a>:</p>\n<blockquote>\n<p>(I was just asking for clarification of \"under optimization\", to be clear)</p>\n</blockquote>\n<p>I don't know which LLVM would consider valid optimizations though, fwiw.</p>",
        "id": 276109368,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109251\">said</a>:</p>\n<blockquote>\n<p>Like <strong>my</strong> only concern is really \"this code runs fine under optimization but crashes under debug???\" issues.</p>\n</blockquote>\n<p>right, I keep trying to formulate something similar myself. this optimization is <em>not</em> the kind of UB I was thinking about though</p>",
        "id": 276109443,
        "sender_full_name": "eddyb",
        "timestamp": 1647894774
    },
    {
        "content": "<p>I consider it less UB and more confusing.</p>",
        "id": 276109470,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109251\">said</a>:</p>\n<blockquote>\n<p>Like <strong>my</strong> only concern is really \"this code runs fine under optimization but crashes under debug???\" issues.</p>\n</blockquote>\n<p>tbf that's also just true of all integer overflow</p>",
        "id": 276109486,
        "sender_full_name": "Gankra",
        "timestamp": 1647894805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276105946\">said</a>:</p>\n<blockquote>\n<p>no one in std would ever argue that adding an abort!() for a degenerate situation is unsound</p>\n</blockquote>\n<p>I don't think anyone would argue against that statement as made; the argument will always be over what is considered \"degenerate\". :)</p>",
        "id": 276109491,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647894808
    },
    {
        "content": "<p>fair.</p>",
        "id": 276109496,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894811
    },
    {
        "content": "<p><del>what if integer overflow was a mistake</del></p>",
        "id": 276109522,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894826
    },
    {
        "content": "<p>we _do_ have an option for that and its on by default in nonrelease :P</p>",
        "id": 276109593,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1647894851
    },
    {
        "content": "<p>Swift agrees, convince apple to make it a hardware trap :)</p>",
        "id": 276109595,
        "sender_full_name": "Gankra",
        "timestamp": 1647894851
    },
    {
        "content": "<p>ha.</p>",
        "id": 276109605,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109251\">said</a>:</p>\n<blockquote>\n<p>Like <strong>my</strong> only concern is really \"this code runs fine under optimization but crashes under debug???\" issues.</p>\n</blockquote>\n<p>Oh look</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">uninitialized</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>On lccc with overflow checks on vs. off (Although we don't yet have have overflow checks yet... or callable<code>core::mem::uninitialized</code>).</p>",
        "id": 276109612,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894862
    },
    {
        "content": "<p><code>core::mem::uninitialized</code> is deprecated like hella.</p>",
        "id": 276109653,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894890
    },
    {
        "content": "<p>it is the canonical example of what we are doing</p>",
        "id": 276109687,
        "sender_full_name": "Gankra",
        "timestamp": 1647894908
    },
    {
        "content": "<p>Now I can understand this mental model being wrong and working to fix it, but even the C standard writers understand that their standards have real power when declaring things UB, and TS 6010 has been much more loathe to declare existing practices \"wrong\". I've seen talks about how PNVI-ae-uni is not enough for dealing with restrict, but nobody talks outright about banning these casts outright.</p>",
        "id": 276109705,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647894917
    },
    {
        "content": "<p>me. I do.</p>",
        "id": 276109732,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894934
    },
    {
        "content": "<p>(For context, in debug this generates an <code>add checked</code> then a branch to a panic, and the constant propagater in the codegen gets <code>unint</code> as the branch control, which causes it to generate <code>ud2</code>, in release it just generates <code>add wrapping</code>)</p>",
        "id": 276109756,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647894955
    },
    {
        "content": "<p>like Mongols, I am the exception.</p>",
        "id": 276109760,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894956
    },
    {
        "content": "<p>Sorry, missing the in C-land qualifier</p>",
        "id": 276109761,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647894957
    },
    {
        "content": "<p>Ah fair... oh uhhhh.</p>",
        "id": 276109811,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106334\">said</a>:</p>\n<blockquote>\n<p>If every update to documentation has to be treated as a strict behavior guarantee forever, then we need to FCP every single documentation change.</p>\n</blockquote>\n<p>...we kinda do, or at least try to. I've regularly seen both lang and libs FCPs to documentation changes on the basis of \"do we want to make this commitment\".</p>\n<p>That doesn't mean we don't change those commitments, on the crater-based basis of \"if breakage happens in a Rust and nobody in <a href=\"http://crates.io\">crates.io</a> is around to hear it, did it really break\", but we do at least attempt to review those commitments.</p>",
        "id": 276109813,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647894965
    },
    {
        "content": "<p>...I have seen them actually.</p>",
        "id": 276109822,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276108962\">said</a>:</p>\n<blockquote>\n<p>Again, this is all a bit lost in the weeds. The main problem is that we're trying to deprecate not just fundamental parts of Rust but a fundamental mental model, to support a weird platform, and claiming that this somehow doesn't de facto break backwards compatibility.</p>\n</blockquote>\n<p>so functionally, the problem with <code>wrapping_offset</code> is that, according to LLVM semantics, it creates a possibly-invalid pointer the moment we touch it, so we probably were wrong to say that it's a no-op to put it back in place.</p>",
        "id": 276109846,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894991
    },
    {
        "content": "<p>Rust is <em>extremely</em> willing to say \"this is just wrong\".</p>\n<p>C is not making an honourable stance, they are acknowledging that the C standard has no power and is defacto descriptive of the bajillion compilers in existence which absolutely will not change</p>",
        "id": 276109864,
        "sender_full_name": "Gankra",
        "timestamp": 1647894998
    },
    {
        "content": "<p>Oh mind giving me a link? (Not trying to call you out, genuinely interested in this kinda stuff).</p>",
        "id": 276109880,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647895008
    },
    {
        "content": "<p>I would have to go digging, my apologies. (if you mean people talking about banning pointer casts)</p>",
        "id": 276109911,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895023
    },
    {
        "content": "<p>I mean, you can always have PNVI-ae-udi and then plop down the existing hilarious restrict rules, at very least if you don't care about restrict's optimization potential</p>",
        "id": 276109936,
        "sender_full_name": "Talchas",
        "timestamp": 1647895041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109813\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106334\">said</a>:</p>\n<blockquote>\n<p>If every update to documentation has to be treated as a strict behavior guarantee forever, then we need to FCP every single documentation change.</p>\n</blockquote>\n<p>...we kinda do, or at least try to. I've regularly seen both lang and libs FCPs to documentation changes on the basis of \"do we want to make this commitment\".</p>\n<p>That doesn't mean we don't change those commitments, on the crater-based basis of \"if breakage happens in a Rust and nobody in <a href=\"http://crates.io\">crates.io</a> is around to hear it, did it really break\", but we do at least attempt to review those commitments.</p>\n</blockquote>\n<p>Although this one will be a really difficult change to trace. After all, it's silently adding UB that does anything at all on all of 1 platform. At least with <code>core::mem::uninitialized()</code> compilers start doing weird stuff everywhere.</p>",
        "id": 276109977,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647895074
    },
    {
        "content": "<p><em>headtilt</em></p>",
        "id": 276110043,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895092
    },
    {
        "content": "<p>I have not seen the links to whatever it is that is supposed to break restrict + PNVI-ae-udi, but it's plausible</p>",
        "id": 276110046,
        "sender_full_name": "Talchas",
        "timestamp": 1647895094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109846\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276108962\">said</a>:</p>\n<blockquote>\n<p>Again, this is all a bit lost in the weeds. The main problem is that we're trying to deprecate not just fundamental parts of Rust but a fundamental mental model, to support a weird platform, and claiming that this somehow doesn't de facto break backwards compatibility.</p>\n</blockquote>\n<p>so functionally, the problem with <code>wrapping_offset</code> is that, according to LLVM semantics, it creates a possibly-invalid pointer the moment we touch it, so we probably were wrong to say that it's a no-op to put it back in place.</p>\n</blockquote>\n<p>yeah I think this is the crux of it. calling it <code>wrapping_</code> suggests modular arithmetic which... I'm not sure LLVM <em>requires</em>?</p>",
        "id": 276110058,
        "sender_full_name": "eddyb",
        "timestamp": 1647895115
    },
    {
        "content": "<p>No no.</p>",
        "id": 276110059,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895115
    },
    {
        "content": "<p>I would be very interested in saturating pointer arithmetic (with the top of the address space unmapped just like the null page :P)</p>",
        "id": 276110123,
        "sender_full_name": "eddyb",
        "timestamp": 1647895144
    },
    {
        "content": "<p>The UB is at the point of dereference.</p>",
        "id": 276110137,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895151
    },
    {
        "content": "<p>At very least I think we can all agree that all the PNVI stuff is extremely \"this is a weird hack that maybe makes things vaguely work\" and not \"this is a good model we all love\"</p>",
        "id": 276110147,
        "sender_full_name": "Gankra",
        "timestamp": 1647895158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276109522\">said</a>:</p>\n<blockquote>\n<p><del>what if integer overflow was a mistake</del></p>\n</blockquote>\n<p>I'd be <em>entirely</em> in favor of turning integer overflow checking on by default if we have a hardware implementation that adds near-zero overhead. The argument against it was primarily one of performance.</p>",
        "id": 276110162,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647895166
    },
    {
        "content": "<p>we require modular arithmetic for actual ints, require that usize is an actual int and the size of a pointer, and if we don't require usize to sanely map to pointer operations I'd call that a spec bug</p>",
        "id": 276110165,
        "sender_full_name": "Talchas",
        "timestamp": 1647895169
    },
    {
        "content": "<p>Honestly I think the central question is how much forgeability we want pointers to have. Keep in mind we still allow (without diagnosis of any kind) transmutes from integers to pointers, which are much more of a mess.</p>",
        "id": 276110203,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647895194
    },
    {
        "content": "<p><code>usize</code> is <code>size_t</code>/<code>ptraddr_t</code> not <code>uintptr_t</code> under the model in <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span>'s blog post (which I support) FWIW</p>",
        "id": 276110263,
        "sender_full_name": "eddyb",
        "timestamp": 1647895210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276108942\">said</a>:</p>\n<blockquote>\n<p>the real problematic code, IMO, is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cap</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"p\">.</span><span class=\"n\">into_raw_parts</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr_wrapped</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"n\">HUGE</span><span class=\"p\">).</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">HUGE</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>under optimization.</p>\n</blockquote>\n<p>added the <code>unsafe</code> blocks I was eliding (or I guess assuming that the code was in the context of one already) to reassert: these are the points at which an <code>unsafe</code> assertion entered the program.</p>",
        "id": 276110321,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895238
    },
    {
        "content": "<p>I mean, that there is already a breaking change (or at least blaming the ecosystem when for breaking CHERI when they don't change their code)</p>",
        "id": 276110367,
        "sender_full_name": "Talchas",
        "timestamp": 1647895278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276110263\">said</a>:</p>\n<blockquote>\n<p><code>usize</code> is <code>size_t</code>/<code>ptraddr_t</code> not <code>uintptr_t</code> under the model in <span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span>'s blog post (which I support) FWIW</p>\n</blockquote>\n<p>Please don't make <code>usize</code> into <code>ptraddr_t</code>. Please, anything else. I'll take the 13 cycle overhead for <code>uintptr_t</code> on w65, just don't make <code>p as usize</code> impossible on 8086.</p>",
        "id": 276110382,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647895287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276110162\">said</a>:</p>\n<blockquote>\n<p>I'd be <em>entirely</em> in favor of turning integer overflow checking on by default if we have a hardware implementation that adds near-zero overhead. The argument against it was primarily one of performance.</p>\n</blockquote>\n<p>my opinion is actually the reverse.</p>",
        "id": 276110388,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276110382\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276110263\">said</a>:</p>\n<blockquote>\n<p><code>usize</code> is <code>size_t</code>/<code>ptraddr_t</code> not <code>uintptr_t</code> under the model in <span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span>'s blog post (which I support) FWIW</p>\n</blockquote>\n<p>Please don't make <code>usize</code> into <code>ptraddr_t</code>. Please, anything else. I'll take the 13 cycle overhead for <code>uintptr_t</code> on w65, just don't make <code>p as usize</code> impossible on 8086.</p>\n</blockquote>\n<p>8086 is just not supported by this model, it would require further expansion</p>",
        "id": 276110470,
        "sender_full_name": "eddyb",
        "timestamp": 1647895326
    },
    {
        "content": "<p>there's not much else to say about it, IMO it's offtopic</p>",
        "id": 276110487,
        "sender_full_name": "eddyb",
        "timestamp": 1647895337
    },
    {
        "content": "<p>note that the model in question is a <em>relaxation</em>. we currently effectively require <code>size_t</code> == <code>uintptr_t</code> == <code>ptraddr_t</code> and whatnot</p>",
        "id": 276110524,
        "sender_full_name": "eddyb",
        "timestamp": 1647895368
    },
    {
        "content": "<p>(we may have specified it more imprecisely than that but we simply do not support anything else)</p>",
        "id": 276110552,
        "sender_full_name": "eddyb",
        "timestamp": 1647895386
    },
    {
        "content": "<p>it is a relaxation on implementations, which is an increase in burden on crates</p>",
        "id": 276110603,
        "sender_full_name": "Talchas",
        "timestamp": 1647895414
    },
    {
        "content": "<p>Depends on what those crates want to support.</p>",
        "id": 276110717,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895472
    },
    {
        "content": "<p>The portability lint <em>appears</em> to be making good progress, from the POV of someone who's looked at the issue once.</p>",
        "id": 276110729,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647895482
    },
    {
        "content": "<p>Yeah, half the reason I want to get more precise semantics here is so we know what we actually should lint on.</p>",
        "id": 276110787,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895516
    },
    {
        "content": "<p>making a uptr type or whatever is definitely implying \"if you don't support these being different that is a failing on your part\"</p>",
        "id": 276110810,
        "sender_full_name": "Talchas",
        "timestamp": 1647895541
    },
    {
        "content": "<p>Ehhh we're leaning away from that by this point.</p>",
        "id": 276110880,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895564
    },
    {
        "content": "<p>I mean, requiring literally <code>uintptr_t</code> is infeasible on CHERI because they defined <code>uintptr_t</code> to be an integer mimic wrapping a <code>void*</code>, not a real integer type, and it only works in a handwavey sense</p>",
        "id": 276110895,
        "sender_full_name": "eddyb",
        "timestamp": 1647895571
    },
    {
        "content": "<p>I mean that's kind of a community problem to an extent, but we do have crates that say, don't work on ARM, and I don't think this will be any  different.</p>",
        "id": 276110911,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647895583
    },
    {
        "content": "<p>Right.</p>",
        "id": 276110922,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895591
    },
    {
        "content": "<p>CHERI C support also tries to do pointer-vs-integer inference in fuzzy ways that Rust mostly doesn't need</p>",
        "id": 276110923,
        "sender_full_name": "eddyb",
        "timestamp": 1647895591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276110911\">said</a>:</p>\n<blockquote>\n<p>I mean that's kind of a community problem to an extent, but we do have crates that say, don't work on ARM, and I don't think this will be any  different.</p>\n</blockquote>\n<p>funny thing about that, I am aware of crates meant for wasm that, when I looked at them, didn't stop you from compiling to other targets, but were not concurrency-safe</p>",
        "id": 276111012,
        "sender_full_name": "eddyb",
        "timestamp": 1647895645
    },
    {
        "content": "<p>(the good 'ol \"we wanted a thread-local but we didn't bother and instead made an unlocked mutable global\")</p>",
        "id": 276111117,
        "sender_full_name": "eddyb",
        "timestamp": 1647895686
    },
    {
        "content": "<p>&lt;_&lt;</p>",
        "id": 276111185,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895725
    },
    {
        "content": "<p>so you should be able to turn them into UAFs</p>",
        "id": 276111194,
        "sender_full_name": "eddyb",
        "timestamp": 1647895731
    },
    {
        "content": "<p>frankly I'm accumulating an increased amount of \"broken stuff I know about but can't do much about so it just sits in the back of my head\", it's unhealthy</p>",
        "id": 276111233,
        "sender_full_name": "eddyb",
        "timestamp": 1647895758
    },
    {
        "content": "<p>(also some of the proposals at least have suggested warn/deprecate/error on ptr/usize casts so those versions would _definitely_ cause breakage)</p>",
        "id": 276111282,
        "sender_full_name": "Talchas",
        "timestamp": 1647895799
    },
    {
        "content": "<p>more relevant to this discussion, 32-bit userspace on 64-bit kernels (or 32-bit w/ PAE) can too easily break the <code>GEPi</code>/<code>&lt;*T&gt;::offset</code> invariants</p>",
        "id": 276111321,
        "sender_full_name": "eddyb",
        "timestamp": 1647895803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276111282\">said</a>:</p>\n<blockquote>\n<p>(also some of the proposals at least have suggested warn/deprecate/error on ptr/usize casts so those versions would _definitely_ cause breakage)</p>\n</blockquote>\n<p>that would require an edition change.</p>",
        "id": 276111352,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895820
    },
    {
        "content": "<p>(which my article always said)</p>",
        "id": 276111414,
        "sender_full_name": "Gankra",
        "timestamp": 1647895863
    },
    {
        "content": "<p>you need more than 32-bit userspace, you need _x32_ userspace, which is indeed cursed</p>",
        "id": 276111538,
        "sender_full_name": "Talchas",
        "timestamp": 1647895926
    },
    {
        "content": "<p>anyway unlike the concern trolls I am actually prototyping this so we can experiment with this on the ecosystem + miri to understand what the material fallout is</p>",
        "id": 276111556,
        "sender_full_name": "Gankra",
        "timestamp": 1647895938
    },
    {
        "content": "<p>worst case we could keep ptr2int2ptr around on CHERI by doing the good 'ol \"global concurrent btree of <code>ptr2int</code>'d pointers\" and \"just\" warning that it will be quite inefficient :P</p>",
        "id": 276111653,
        "sender_full_name": "eddyb",
        "timestamp": 1647895982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276111538\">said</a>:</p>\n<blockquote>\n<p>you need more than 32-bit userspace, you need _x32_ userspace, which is indeed cursed</p>\n</blockquote>\n<p>nope, plain i686 Linux on a x64 host can do UB with safe Rust (and I think one <a href=\"http://crates.io\">crates.io</a> dependency?)</p>",
        "id": 276111685,
        "sender_full_name": "eddyb",
        "timestamp": 1647896013
    },
    {
        "content": "<p>I had a hard time weaponizing the UB into a miscompilation and it was 3-4 rabbit hole levels deep so I gave up on it</p>",
        "id": 276111710,
        "sender_full_name": "eddyb",
        "timestamp": 1647896031
    },
    {
        "content": "<p>I... think I would rather simply say that code before <code>format!(\"edition = \\\"202{N}\\\"\");</code>does not run on CHERI. &lt;_&lt;</p>",
        "id": 276111898,
        "sender_full_name": "Jubilee",
        "timestamp": 1647896097
    },
    {
        "content": "<p>anyways, I definitely object to CHERI as a motivating example because a) it hard rules out some solutions and b) it's super special in irretrievable ways that make pandering to it on point a questionable</p>",
        "id": 276111955,
        "sender_full_name": "Talchas",
        "timestamp": 1647896109
    },
    {
        "content": "<p>On that note, where is the work on the portability lint? Would love to see how feasible some of my ideas are before spending this week writing my thoughts down.</p>",
        "id": 276112115,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647896145
    },
    {
        "content": "<blockquote>\n<p>(the good 'ol \"we wanted a thread-local but we didn't bother and instead made an unlocked mutable global\")</p>\n</blockquote>\n<p>the <code>gba</code> crate does this but the crate docs clearly ask that you <em>please don't</em></p>",
        "id": 276112172,
        "sender_full_name": "Lokathor",
        "timestamp": 1647896158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276111685\">said</a>:<br>\nnope, plain i686 Linux on a x64 host can do UB with safe Rust (and I think one <a href=\"http://crates.io\">crates.io</a> dependency?)</p>\n<p>Do you have a short summary offhand?</p>",
        "id": 276112248,
        "sender_full_name": "Talchas",
        "timestamp": 1647896167
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/E0CG8Qk6XUlEOBZqwdyXEgXk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/E0CG8Qk6XUlEOBZqwdyXEgXk/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/E0CG8Qk6XUlEOBZqwdyXEgXk/image.png\"></a></div>",
        "id": 276112316,
        "sender_full_name": "eddyb",
        "timestamp": 1647896182
    },
    {
        "content": "<p>I was trying to find this again. this is all you need (with the <code>wee_alloc</code> dependency)</p>",
        "id": 276112408,
        "sender_full_name": "eddyb",
        "timestamp": 1647896203
    },
    {
        "content": "<p>ohh, because the &gt;isize allocations can succeed and all the C allocation functions take unsigned</p>",
        "id": 276112475,
        "sender_full_name": "Talchas",
        "timestamp": 1647896218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112115\">said</a>:</p>\n<blockquote>\n<p>On that note, where is the work on the portability lint? Would love to see how feasible some of my ideas are before spending this week writing my thoughts down.</p>\n</blockquote>\n<p>I am not sure, to be quite frank. last I checked it was Kinda Stuck.</p>",
        "id": 276112508,
        "sender_full_name": "Jubilee",
        "timestamp": 1647896224
    },
    {
        "content": "<p>portability lint stabilizes the release after the never type</p>",
        "id": 276112587,
        "sender_full_name": "Lokathor",
        "timestamp": 1647896262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112408\">said</a>:</p>\n<blockquote>\n<p>I was trying to find this again. this is all you need (with the <code>wee_alloc</code> dependency)</p>\n</blockquote>\n<p>has the missing guard in Rc not been fixed yet?</p>",
        "id": 276112590,
        "sender_full_name": "Gankra",
        "timestamp": 1647896264
    },
    {
        "content": "<p>I think in that sense it could happen in just 32/32 depending on the kernel code model</p>",
        "id": 276112602,
        "sender_full_name": "Talchas",
        "timestamp": 1647896268
    },
    {
        "content": "<p>as long as the kernel isn't eating 2G that can happen</p>",
        "id": 276112674,
        "sender_full_name": "Talchas",
        "timestamp": 1647896287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112590\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112408\">said</a>:</p>\n<blockquote>\n<p>I was trying to find this again. this is all you need (with the <code>wee_alloc</code> dependency)</p>\n</blockquote>\n<p>has the missing guard in Rc not been fixed yet?</p>\n</blockquote>\n<p>I never reported it because I didn't have time to write an exploit <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 276112691,
        "sender_full_name": "eddyb",
        "timestamp": 1647896292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112602\">said</a>:</p>\n<blockquote>\n<p>I think in that sense it could happen in just 32/32 depending on the kernel code model</p>\n</blockquote>\n<p>yeah I think you can do almost 4G userspace w/ PAE, and 3G w/o maybe?</p>",
        "id": 276112735,
        "sender_full_name": "eddyb",
        "timestamp": 1647896317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112508\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276112115\">said</a>:</p>\n<blockquote>\n<p>On that note, where is the work on the portability lint? Would love to see how feasible some of my ideas are before spending this week writing my thoughts down.</p>\n</blockquote>\n<p>I am not sure, to be quite frank. last I checked it was Kinda Stuck.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> has a credible plan for reviving it in terms of where clauses: <code>where Target: Posix</code> or similar.</p>",
        "id": 276112766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647896334
    },
    {
        "content": "<p>ahhh nulary typeclasses aka axioms :D</p>",
        "id": 276112839,
        "sender_full_name": "eddyb",
        "timestamp": 1647896367
    },
    {
        "content": "<p>yeah, I don't remember the state of affairs on 32-bit linux, I know windows has flags for that, but don't recall if they require PAE</p>",
        "id": 276112871,
        "sender_full_name": "Talchas",
        "timestamp": 1647896389
    },
    {
        "content": "<p>I'm super excited to be able to write <code>where Target: Is64Bit</code> or similar at the top of my program, and then <code>let x: usize = some_u64.into()</code> and vice versa.</p>",
        "id": 276112925,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647896402
    },
    {
        "content": "<p>(this trick is p common in proof assistants, and you can often scope them out really nicely)</p>",
        "id": 276112956,
        "sender_full_name": "eddyb",
        "timestamp": 1647896410
    },
    {
        "content": "<p>cool we're getting generic modules too then :P?</p>",
        "id": 276113031,
        "sender_full_name": "eddyb",
        "timestamp": 1647896428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276113031\">said</a>:</p>\n<blockquote>\n<p>cool we're getting generic modules too then :P?</p>\n</blockquote>\n<p>That's the main bit of design work that needs to happen to make the <code>where</code>-based portability mechanism work well. :)</p>",
        "id": 276113072,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647896451
    },
    {
        "content": "<p>I suppose if you don't need to monomorphize over them, just scope some <code>where</code> clauses, it's very easy!</p>",
        "id": 276113155,
        "sender_full_name": "eddyb",
        "timestamp": 1647896494
    },
    {
        "content": "<p>(moved my reply to the portability stuff to <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/portability.20lint.20using.20where.20clauses/near/276112839\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/portability.20lint.20using.20where.20clauses/near/276112839</a>)</p>",
        "id": 276113764,
        "sender_full_name": "eddyb",
        "timestamp": 1647896790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> (can't figure out how to reply on mobile) what exactly are you prototyping, and how does it relate to Miri?</p>",
        "id": 276113830,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647896834
    },
    {
        "content": "<p>the APIs in my proposal + deprecating all ptr&lt;-&gt;int casts, to see how bad the fallout is and how many changes actual codebases need to compile without warnings</p>",
        "id": 276113943,
        "sender_full_name": "Gankra",
        "timestamp": 1647896891
    },
    {
        "content": "<p>miri should automatically get Perfect Provenance due to all usize -&gt; ptr casts being replaced with</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">with_addr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">addr</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// FIXME: I am magic and should be a compiler intrinsic.</span>\n<span class=\"w\">        </span><span class=\"c1\">//</span>\n<span class=\"w\">        </span><span class=\"c1\">// In the mean-time, this operation is defined to be \"as if\" it was</span>\n<span class=\"w\">        </span><span class=\"c1\">// a wrapping_offset, so we can emulate it as such. This should properly</span>\n<span class=\"w\">        </span><span class=\"c1\">// restore pointer provenance even under today's compiler.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">self_addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">isize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dest_addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">isize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dest_addr</span><span class=\"p\">.</span><span class=\"n\">wrapping_sub</span><span class=\"p\">(</span><span class=\"n\">self_addr</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"c1\">// This is the canonical desugarring of this operation</span>\n<span class=\"w\">        </span><span class=\"c1\">//</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">wrapping_offset</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"p\">).</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276114018,
        "sender_full_name": "Gankra",
        "timestamp": 1647896942
    },
    {
        "content": "<p>(assuming I remember that this makes miri happy)</p>",
        "id": 276114063,
        "sender_full_name": "Gankra",
        "timestamp": 1647896974
    },
    {
        "content": "<p>Mmmmmm interesting</p>",
        "id": 276114088,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647896991
    },
    {
        "content": "<p>my first blocker is that my rustc checkout has corrupted itself because submodules continue to be the worst design in the universe</p>",
        "id": 276114164,
        "sender_full_name": "Gankra",
        "timestamp": 1647897021
    },
    {
        "content": "<p>time to reclone i guess</p>",
        "id": 276114178,
        "sender_full_name": "Gankra",
        "timestamp": 1647897031
    },
    {
        "content": "<p>I'm doing this thing (again) where I run Miri on like 10,000 crates so if you need examples of crates that do things let me know</p>",
        "id": 276114191,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647897037
    },
    {
        "content": "<p>nice thanks</p>",
        "id": 276114236,
        "sender_full_name": "Gankra",
        "timestamp": 1647897065
    },
    {
        "content": "<p>the ones you probably most want for this are ones that won't work at all under miri though (except for all the helper lib crates, which might or might not)</p>",
        "id": 276114421,
        "sender_full_name": "Talchas",
        "timestamp": 1647897148
    },
    {
        "content": "<p>(or rather, the ones most likely to break and have trouble fixing it)</p>",
        "id": 276114454,
        "sender_full_name": "Talchas",
        "timestamp": 1647897168
    },
    {
        "content": "<p>Even there I have examples <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 276114509,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647897187
    },
    {
        "content": "<p>FWIW, while I made some comments upthread about documentation and committments, I should clarify that I'm entirely in favor of testing and carefully transitioning (over an edition) to a model in which usize is not pointer-sized.</p>",
        "id": 276114748,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897241
    },
    {
        "content": "<p>I do still want it to be possible to do pointer tagging and other such tricks, but I like the idea of introducing a new \"pointer container\" integer type that is capable of doing such operations while making it easier on the compiler to compile that code correctly.</p>",
        "id": 276114911,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897288
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> FWIW I'm sure I would have more of those examples if bindgen didn't just emit UB as a matter of course</p>",
        "id": 276114936,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647897304
    },
    {
        "content": "<p>I think, often, \"make that more contained\" gets conflated with \"make that impossible\", and I'm in favor of the former as long as we don't do the latter.</p>",
        "id": 276114955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276114911\">said</a>:</p>\n<blockquote>\n<p>I do still want it to be possible to do pointer tagging and other such tricks, but I like the idea of introducing a new \"pointer container\" integer type that is capable of doing such operations while making it easier on the compiler to compile that code correctly.</p>\n</blockquote>\n<p>you would still allowed to do all those things, you just use <code>addr()</code> and <code>with_addr()</code> instead of <code>as usize</code> and <code>as ptr</code></p>",
        "id": 276115082,
        "sender_full_name": "Gankra",
        "timestamp": 1647897378
    },
    {
        "content": "<p>pointer tagging is the trivial part implementation-wise (but also the most defensible), and there's a fine argument for adding it regardless of what the model winds up being</p>",
        "id": 276115142,
        "sender_full_name": "Talchas",
        "timestamp": 1647897417
    },
    {
        "content": "<p>That sounds generally reasonable, modulo \"what do you do when you don't have a pointer to call <code>with_addr</code> on\".</p>",
        "id": 276115150,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"sd\">/// Claim that you have \"allocated\" and have unique access to the range</span>\n<span class=\"w\">    </span><span class=\"sd\">/// of memory `address .. address + len * size_of::&lt;T&gt;()`.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// (This is an extremely \"shot in the dark\" design, but throwing it out</span>\n<span class=\"w\">    </span><span class=\"sd\">/// here as a possible sketch of an answer to the problem.)</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// When dealing with low-level situations like memory-mapped peripherals,</span>\n<span class=\"w\">    </span><span class=\"sd\">/// the programmer typically needs to just blindly assume a specific address</span>\n<span class=\"w\">    </span><span class=\"sd\">/// can be interpretted as a pointer and read/written.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// This is a problem for Pointer Provenance and Segmenting, because there</span>\n<span class=\"w\">    </span><span class=\"sd\">/// is no \"chain of custody\" to an allocation. One possible solution to this</span>\n<span class=\"w\">    </span><span class=\"sd\">/// is for the programmer to Pretend To Be Malloc and \"allocate\" the address.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// See [`with_addr`] for more details.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Just as with *real* malloc, the compiler is free to assume the pointer</span>\n<span class=\"w\">    </span><span class=\"sd\">/// returned from this function is completely unaliased, and that all accesses</span>\n<span class=\"w\">    </span><span class=\"sd\">/// to this range of memory occur *only* from pointers with provenance derived</span>\n<span class=\"w\">    </span><span class=\"sd\">/// from this one. These assumptions can be loosened with operations like</span>\n<span class=\"w\">    </span><span class=\"sd\">/// [`read_volatile`][] which you were probably going to use already.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// This is only sound to do if:</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * You are actually allowed to access that specified range of memory</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * All future accesses to this range of memory are through this pointer</span>\n<span class=\"w\">    </span><span class=\"sd\">/// * You never `claim_alloc` this memory again (Maybe? Should we have claim_dealloc?)</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Basically, pretend you're `malloc` and think about how bad it would be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// if `malloc` returned the same pointer twice (without any freeing).</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// This design needs to be workshopped but needless to say it is Extremely</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Undefined Behaviour to do wrong things with this.</span>\n<span class=\"w\">    </span><span class=\"cp\">#[unstable(feature = </span><span class=\"s\">\"robust_pointer_provenance\"</span><span class=\"cp\">, issue = </span><span class=\"s\">\"99999999\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">claim_alloc</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">addr</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_len</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// FIXME: I am magic and should be a compiler intrinsic.</span>\n<span class=\"w\">        </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276115200,
        "sender_full_name": "Gankra",
        "timestamp": 1647897452
    },
    {
        "content": "<p>(well, except for high-bits tagging and models that want to explicitly lowest-common-denominator including CHERI more than \"it's obviously platform-defined if any high bits are available\")</p>",
        "id": 276115256,
        "sender_full_name": "Talchas",
        "timestamp": 1647897483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276115082\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276114911\">said</a>:</p>\n<blockquote>\n<p>I do still want it to be possible to do pointer tagging and other such tricks, but I like the idea of introducing a new \"pointer container\" integer type that is capable of doing such operations while making it easier on the compiler to compile that code correctly.</p>\n</blockquote>\n<p>you would still allowed to do all those things, you just use <code>addr()</code> and <code>with_addr()</code> instead of <code>as usize</code> and <code>as ptr</code></p>\n</blockquote>\n<p>I think any model here would have to consider the whole group of pointer-weird platforms.</p>",
        "id": 276115276,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I think that's exactly the right approach for synthesizing a pointer out of nothing. That's not quite the use case I was asking about, but I'm hugely in favor of that as an API for things like \"make up an MMIO pointer\" or \"access a fixed-offset hardware table\".</p>",
        "id": 276115309,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897520
    },
    {
        "content": "<p>that one is definitely _not_ the model always used, in the sense that it asserts that you don't claim it again</p>",
        "id": 276115419,
        "sender_full_name": "Talchas",
        "timestamp": 1647897590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276115419\">said</a>:</p>\n<blockquote>\n<p>that one is definitely _not_ the model always used, in the sense that it asserts that you don't claim it again</p>\n</blockquote>\n<p>I'm reading the \"Should we have <code>claim_dealloc</code>\" part of that comment with great interest. :)</p>",
        "id": 276115501,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> Hypothetically, if we <em>don't</em> have any backwards compatibility constraints at all, and we only have the requirement to make something <em>possible</em> without making it use the <em>same code</em> as it did before, and we're fine with requiring unsafe operations but we need to provide a well-defined non-UB way to do something, what APIs <em>would</em> we want people to use for something like an XOR linked list that stores only one pointer-sized value in each node (plus the data)?</p>",
        "id": 276115586,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897678
    },
    {
        "content": "<p>the sketch is useful if only to force the kind of people who \"need\" it under this model to come out of the woodwork and explain why it is Insufficient</p>",
        "id": 276115597,
        "sender_full_name": "Gankra",
        "timestamp": 1647897687
    },
    {
        "content": "<p>Forget for a moment what horrible cursed things people <em>currently</em> do to implement XOR linked lists and similar. What would be the <em>right</em> way to support those?</p>",
        "id": 276115648,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897719
    },
    {
        "content": "<p>xorlist is cursed anyways.</p>",
        "id": 276115709,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897736
    },
    {
        "content": "<p>Yeah XOR list is the real \"this is seemingly impossible\" thing unless you build your XOR list in an ~arena and use the arena ptr to rehydrate your addresses</p>",
        "id": 276115720,
        "sender_full_name": "Gankra",
        "timestamp": 1647897743
    },
    {
        "content": "<p>I don't think you can do xorlist without union provenance? (or cheating and requiring an arena, yeah)</p>",
        "id": 276115747,
        "sender_full_name": "Talchas",
        "timestamp": 1647897761
    },
    {
        "content": "<p>I've heard that in C++ some people used <code>volatile</code> to avoid the compiler eliding the data structure.</p>",
        "id": 276115761,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276115747\">said</a>:</p>\n<blockquote>\n<p>I don't think you can do xorlist without union provenance? (or cheating and requiring an arena, yeah)</p>\n</blockquote>\n<p>What would union provenance look like for an XOR linked list? (I can guess what it <em>means</em> from the name, but what would the API look like?)</p>",
        "id": 276115774,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897774
    },
    {
        "content": "<p>provenance(a xor b) = provenance(a) union provenance(b) (really maybe s/xor/bitop/ at that point)</p>",
        "id": 276115846,
        "sender_full_name": "Talchas",
        "timestamp": 1647897814
    },
    {
        "content": "<p><code>x as *mut T</code></p>",
        "id": 276115849,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897817
    },
    {
        "content": "<p>XOR lists are the kind of thing I think of when I think about cursed things people do that don't <em>have</em> to work exactly as they did before but do still need to have some recommended code pattern other than \"don't\".</p>",
        "id": 276115851,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897820
    },
    {
        "content": "<p>provenance tracking size goes to the moon</p>",
        "id": 276115878,
        "sender_full_name": "Talchas",
        "timestamp": 1647897831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276115846\">said</a>:</p>\n<blockquote>\n<p>provenance(a xor b) = provenance(a) union provenance(b) (really maybe s/xor/bitop/ at that point)</p>\n</blockquote>\n<p>Also not quite since it's <code>provenance(a xor b) = provenance(a) | provenance(b)</code></p>",
        "id": 276115961,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897856
    },
    {
        "content": "<p>union find is a good algorithm, it'll be fine, right? (oops SB)</p>",
        "id": 276115963,
        "sender_full_name": "Talchas",
        "timestamp": 1647897857
    },
    {
        "content": "<p>for xorlists to work you need it to actually be union I think</p>",
        "id": 276116030,
        "sender_full_name": "Talchas",
        "timestamp": 1647897894
    },
    {
        "content": "<p>(Union here being the union of possible provenance<strong>s</strong>, not the union of the available provenance)</p>",
        "id": 276116051,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116030\">said</a>:</p>\n<blockquote>\n<p>for xorlists to work you need it to actually be union I think</p>\n</blockquote>\n<p>Or just straight up PNVI-ae w/ union provenance on backcasting.</p>",
        "id": 276116108,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897929
    },
    {
        "content": "<p>I'm pretty sure xorlist is UB in every language you can theoretically write it in that isn't assembly, so IDK if we have to worry about breaking it.</p>",
        "id": 276116174,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647897960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116174\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure xorlist is UB in every language you can theoretically write it in that isn't assembly, so IDK if we have to worry about breaking it.</p>\n</blockquote>\n<p>I don't subscribe to the \"it's UB so we can just break it\" theory of compiler design. :)</p>",
        "id": 276116265,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647897997
    },
    {
        "content": "<p>yeah, I was thinking of PVI unnecessarily</p>",
        "id": 276116275,
        "sender_full_name": "Talchas",
        "timestamp": 1647898004
    },
    {
        "content": "<p>/me looks up and reads the PNVI-ae-udi paper.</p>",
        "id": 276116306,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898028
    },
    {
        "content": "<p>(recommendations welcome for the best starting point for that)</p>",
        "id": 276116335,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116335\">said</a>:</p>\n<blockquote>\n<p>(recommendations welcome for the best starting point for that)</p>\n</blockquote>\n<p>N2676 is the latest one and is pretty approachable (for someone versed in compiler lingo), and is favored by WG14 (or 21 I forget) to move forward, even without any changes.</p>",
        "id": 276116439,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647898090
    },
    {
        "content": "<p>/me is still of the belief that PNVI-ae w/o union provenance isn't valid for rust b/c of <a href=\"https://doc.rust-lang.org/nightly/core/ptr/index.html#safety\">https://doc.rust-lang.org/nightly/core/ptr/index.html#safety</a></p>",
        "id": 276116528,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898154
    },
    {
        "content": "<p>Which part of that</p>",
        "id": 276116593,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647898181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116439\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116335\">said</a>:</p>\n<blockquote>\n<p>(recommendations welcome for the best starting point for that)</p>\n</blockquote>\n<p>N2676 is the latest one and is pretty approachable (for someone versed in compiler lingo), and is favored by WG14 (or 21 I forget) to move forward, even without any changes.</p>\n</blockquote>\n<p>WG14. WG21 is C++, which last I heard was still clinging onto int2ptr model.</p>",
        "id": 276116601,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116593\">said</a>:</p>\n<blockquote>\n<p>Which part of that</p>\n</blockquote>\n<p>Access for zero sized allocations being valid for <code>non-zero-const as *mut ()</code></p>",
        "id": 276116676,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276115720\">said</a>:</p>\n<blockquote>\n<p>Yeah XOR list is the real \"this is seemingly impossible\" thing unless you build your XOR list in an ~arena and use the arena ptr to rehydrate your addresses</p>\n</blockquote>\n<p>Well... depending on the semantics we decide on for splitting provenance between pointer bytes... You could certainly store the provenance for the next element in the lowest byte and the provenance for the previous element in the next lowest byte and then do some cursed thing for reconstructing the full pointer</p>",
        "id": 276116773,
        "sender_full_name": "Jake",
        "timestamp": 1647898274
    },
    {
        "content": "<p>(Currently miri errors if you leak an allocation, guess it's address in a constant and cast back, deallocate, then access the new pointer as <code>()</code>)</p>",
        "id": 276116830,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898311
    },
    {
        "content": "<p>We could always define an extension to the spec for ZSTs to the tune of everything is valid with proper alignment, but LLVM rears its head.</p>",
        "id": 276116913,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647898348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> BTW, in response to one item in your blog post, I would be <em>entirely</em> in favor of just adding native syntax to get the field offset of a struct, and once we have that, I don't mind if we break existing ways of writing that as a macro or similar (over an edition boundary).</p>",
        "id": 276116934,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898370
    },
    {
        "content": "<p>Same with me, since I'd like consistent semantics for reads in a generic function.</p>",
        "id": 276116937,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898375
    },
    {
        "content": "<p>I don't think we need to make it possible to hack offsetof together in a macro the way C does, it's fine if it needs native language support.</p>",
        "id": 276116966,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898402
    },
    {
        "content": "<p>afaik you can write offsetof fine today with MaybeUninit&lt;T&gt;, no?</p>",
        "id": 276116993,
        "sender_full_name": "Gankra",
        "timestamp": 1647898422
    },
    {
        "content": "<p>it's just that everyone thinks they're very Smart and tries to do it off null because it's so elegant</p>",
        "id": 276117054,
        "sender_full_name": "Gankra",
        "timestamp": 1647898442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116993\">said</a>:</p>\n<blockquote>\n<p>afaik you can write offsetof fine today with MaybeUninit&lt;T&gt;, no?</p>\n</blockquote>\n<p>As long as your type isn't larger than your stack, sure</p>",
        "id": 276117066,
        "sender_full_name": "Jake",
        "timestamp": 1647898445
    },
    {
        "content": "<p>sure</p>",
        "id": 276117084,
        "sender_full_name": "Gankra",
        "timestamp": 1647898455
    },
    {
        "content": "<p>With the next beta, memoffset works in const, avoiding the need to have it on the stack.</p>",
        "id": 276117093,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647898461
    },
    {
        "content": "<p>and in release i would be <em>very</em> surprised if llvm didn't const-fold it all away</p>",
        "id": 276117122,
        "sender_full_name": "Gankra",
        "timestamp": 1647898477
    },
    {
        "content": "<p>But a lot of people are concerned about supply-chain attacks or minimizing dependencies or w/e and handcode offset_of.</p>",
        "id": 276117136,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647898487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276116993\">said</a>:</p>\n<blockquote>\n<p>afaik you can write offsetof fine today with MaybeUninit&lt;T&gt;, no?</p>\n</blockquote>\n<p>I'm not sure what the non-UB version looks like exactly.</p>",
        "id": 276117139,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898489
    },
    {
        "content": "<p><code>addr_of!((*MaybeUninit&lt;T&gt;::uninit().as_mut_ptr()).field.subfield)</code></p>\n<p>I think</p>",
        "id": 276117207,
        "sender_full_name": "Gankra",
        "timestamp": 1647898542
    },
    {
        "content": "<p>I think if there were a native version in the language people wouldn't have any cause to open-code it anymore.</p>",
        "id": 276117208,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898543
    },
    {
        "content": "<p>i would not do it as one expression</p>",
        "id": 276117223,
        "sender_full_name": "Gankra",
        "timestamp": 1647898552
    },
    {
        "content": "<p>because I am paranoid about temporaries, but that's the gist</p>",
        "id": 276117275,
        "sender_full_name": "Gankra",
        "timestamp": 1647898563
    },
    {
        "content": "<p>const technically isn't a guarantee though, right? (at very least not without too much pain)<br>\nthough it's probably good enough</p>",
        "id": 276117293,
        "sender_full_name": "Talchas",
        "timestamp": 1647898569
    },
    {
        "content": "<p>oh whoops sorry you also subtract the pointer from as_mut_ptr</p>",
        "id": 276117318,
        "sender_full_name": "Gankra",
        "timestamp": 1647898589
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"cp\">$ty</span><span class=\"o\">&gt;</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">addr_of</span><span class=\"o\">!</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">).</span><span class=\"cp\">$field</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">offset_from</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276117319,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276117207\">said</a>:</p>\n<blockquote>\n<p><code>addr_of!((*MaybeUninit&lt;T&gt;::uninit().as_mut_ptr()).field.subfield)</code></p>\n<p>I think</p>\n</blockquote>\n<p>Ah, of course, why didn't I think of that? (I'd forgotten about <code>addr_of!</code>.)</p>",
        "id": 276117323,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647898591
    },
    {
        "content": "<p>yeah, builtin would let you dodge all the Deref/Index issues that at least for Deref are doable but are ugly</p>",
        "id": 276117355,
        "sender_full_name": "Talchas",
        "timestamp": 1647898612
    },
    {
        "content": "<p>(With appropriate checks to make sure that <code>(*ptr).$field</code> isn't calling <code>Deref</code>.</p>",
        "id": 276117391,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647898639
    },
    {
        "content": "<p>yeah addr_of! is actually useful and it's good we have it, it's just Jank</p>",
        "id": 276117594,
        "sender_full_name": "Gankra",
        "timestamp": 1647898775
    },
    {
        "content": "<p>I think the xorlist trick only works consistently between compilers in practice with the addition of the arena and arena pointer.</p>",
        "id": 276118966,
        "sender_full_name": "Jubilee",
        "timestamp": 1647899545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276115200\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"sd\">/// Claim that you have \"allocated\" and have unique access to the range</span>\n<span class=\"w\">    </span><span class=\"sd\">/// of memory `address .. address + len * size_of::&lt;T&gt;()`.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// (This is an extremely \"shot in the dark\" design, but throwing it out</span>\n<span class=\"w\">    </span><span class=\"sd\">/// here as a possible sketch of an answer to the problem.)</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// When dealing with low-level situations like memory-mapped peripherals,</span>\n<span class=\"w\">    </span><span class=\"sd\">/// the programmer typically needs to just blindly assume a specific address</span>\n<span class=\"w\">    </span><span class=\"sd\">/// can be interpretted as a pointer and read/written.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// [...]</span>\n<span class=\"w\">    </span><span class=\"cp\">#[unstable(feature = </span><span class=\"s\">\"robust_pointer_provenance\"</span><span class=\"cp\">, issue = </span><span class=\"s\">\"99999999\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">claim_alloc</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">addr</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_len</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// FIXME: I am magic and should be a compiler intrinsic.</span>\n<span class=\"w\">        </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I am not sure that in practice we wouldn't want to canonize something like a nicer <code>VolAddr</code>, see:<br>\n<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/265#issuecomment-761587844\">https://github.com/rust-lang/unsafe-code-guidelines/issues/265#issuecomment-761587844</a></p>",
        "id": 276119557,
        "sender_full_name": "Jubilee",
        "timestamp": 1647899962
    },
    {
        "content": "<p>Apologies to anyone confused by all the messages suddenly disappearing, this had diverged even further than it already had so I sliced up the subtopics into new threads.</p>",
        "id": 276121213,
        "sender_full_name": "Jubilee",
        "timestamp": 1647901062
    },
    {
        "content": "<p>So on my quest to find real-world use cases I came across this very cursed thing. On a side note, I really should figure out how to ripgrep GH:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2012.htm#clarifying-the-c-memory-object-model-pointer-provenance\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2012.htm#clarifying-the-c-memory-object-model-pointer-provenance</a></p>\n<blockquote>\n<p>2.6.1 Q19. Can one make a usable pointer via IO?<br>\nThis is used in practice: in graphics code for marshalling/unmarshalling (using %p), in xlib (using SCNuPTR), and in debuggers.</p>\n</blockquote>",
        "id": 276122568,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647902108
    },
    {
        "content": "<p>I've seen real-world code that walks a data structure, subtracts an offset from every pointer in that data structure, and then serializes the data structure to disk. Then, when reading it back off disk, it adds the offset back to every pointer.</p>",
        "id": 276122760,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647902231
    },
    {
        "content": "<p>IIRC that code <em>effectively</em> used an arena though.</p>",
        "id": 276122799,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647902269
    },
    {
        "content": "<p>oh is this like chrome JS runtime fastboot stuff</p>",
        "id": 276122850,
        "sender_full_name": "Gankra",
        "timestamp": 1647902288
    },
    {
        "content": "<p>cuz yeah that apply an offset part sounds a lot like \"load it into the big slab of memory for the runtime\"</p>",
        "id": 276122894,
        "sender_full_name": "Gankra",
        "timestamp": 1647902334
    },
    {
        "content": "<p>in which case the pointers are actually the ones that are offsets and strict-provenance would be quite fine with that</p>",
        "id": 276122923,
        "sender_full_name": "Gankra",
        "timestamp": 1647902365
    },
    {
        "content": "<p>Yeah, I didn't anticipate that case being a problem.</p>",
        "id": 276123012,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647902440
    },
    {
        "content": "<p>Does provenance apply,  de facto or de jure,  for loads of ZSTs? It would have to be no right, or are we doing the whole there's an allocated object behind each address that could be a ZST?</p>",
        "id": 276124372,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647903510
    }
]