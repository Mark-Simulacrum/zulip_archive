[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I saw you cursing about fn ptr issues with AVR and you keep mentioning them here as well, but I don't actually understand the problem. Could you summarize what the issue is?</p>",
        "id": 276794922,
        "sender_full_name": "RalfJ",
        "timestamp": 1648396918
    },
    {
        "content": "<p>There are a few problems</p>",
        "id": 276794968,
        "sender_full_name": "Gankra",
        "timestamp": 1648396942
    },
    {
        "content": "<ol>\n<li>Function Pointers and Data Pointers may be in different segments/representations and therefore a fn&lt;-&gt;*mut cast has unclear semantics</li>\n</ol>",
        "id": 276794992,
        "sender_full_name": "Gankra",
        "timestamp": 1648396988
    },
    {
        "content": "<ol start=\"2\">\n<li>Because those casts have unclear semantics, it is desirable to go directly to usize because this can have a more coherent interpretation and Actually Avoids ICEs on AVR (WASM is the other example but we make it \"work\" there more)</li>\n</ol>\n<p><a href=\"https://doc.rust-lang.org/src/core/ptr/mod.rs.html#1431\">https://doc.rust-lang.org/src/core/ptr/mod.rs.html#1431</a></p>\n<p><a href=\"https://github.com/avr-rust/rust/issues/143\">https://github.com/avr-rust/rust/issues/143</a></p>",
        "id": 276795053,
        "sender_full_name": "Gankra",
        "timestamp": 1648397129
    },
    {
        "content": "<ol start=\"3\">\n<li>The absence of a way to generically/opaquely talk about \"some\" function pointer encourages you to cast them to *mut or ints to do so (the linux dynamic linking code just <em>transmute_copies</em> an int to T where T is just blindly assumed to be a function pointer of the expected type)</li>\n</ol>",
        "id": 276795119,
        "sender_full_name": "Gankra",
        "timestamp": 1648397230
    },
    {
        "content": "<p>do fn ptrs have provenance though?</p>",
        "id": 276795212,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795119\">said</a>:</p>\n<blockquote>\n<p>some code in the linux dynamic linking function loading code just <em>transmute_copies</em> an int to T</p>\n</blockquote>\n<p>There's also the fact that<code>dlsym</code> returns a <code>void *</code> and it could be either a function pointer or a pointer to data (static), so some mechanism to construct a pointer in the correct addrspace with address from <code>void *</code> is necessaryâ€¦</p>",
        "id": 276795215,
        "sender_full_name": "nagisa",
        "timestamp": 1648397378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795212\">said</a>:</p>\n<blockquote>\n<p>do fn ptrs have provenance though?</p>\n</blockquote>\n<p>In my head they should because you \"shouldn't\" be allowed to call a function you have no business knowing about, but tbh my main concern is just straight-up getting confusing/incorrect results at runtime when trying to do things like compare function pointers</p>",
        "id": 276795310,
        "sender_full_name": "Gankra",
        "timestamp": 1648397516
    },
    {
        "content": "<p>(function pointers <em>can</em> be freed by unlinking dynamic code!)</p>",
        "id": 276795354,
        "sender_full_name": "Gankra",
        "timestamp": 1648397558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795212\">said</a>:</p>\n<blockquote>\n<p>do fn ptrs have provenance though?</p>\n</blockquote>\n<p>Sort of? It's far more limited than raw pointer provenance.</p>",
        "id": 276795374,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648397615
    },
    {
        "content": "<p>AFAIK compilers so far dont do interesting provenance analysis on fn ptrs so we could treat them as not having provenance. but who knows what compiler authors will do in the future...</p>",
        "id": 276795378,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397622
    },
    {
        "content": "<p>yeah it's less memory-model and more \"we are generating garbage because we are letting people ask questions we do not properly define the answers to\" (and which may have no coherent answer)</p>",
        "id": 276795457,
        "sender_full_name": "Gankra",
        "timestamp": 1648397705
    },
    {
        "content": "<p>OTOH in Miri they do have provenance. in fact they are basically \"only provenance\" since there is no offsetting...</p>",
        "id": 276795460,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795457\">said</a>:</p>\n<blockquote>\n<p>yeah it's less memory-model and more \"we are generating garbage because we are letting people ask questions we do not properly define the answers to\" (and which may have no coherent answer)</p>\n</blockquote>\n<p>I would have expected that fn ptr to raw ptr cast is basically a transmute, so the fact that their address space is disjoint doesn't matter. is that not coherent?</p>",
        "id": 276795518,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397779
    },
    {
        "content": "<p>It could be a transmute but it also could not be.</p>",
        "id": 276795535,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648397812
    },
    {
        "content": "<p>The AVR backend seems to disagree! I haven't looked into the details.</p>",
        "id": 276795537,
        "sender_full_name": "Gankra",
        "timestamp": 1648397821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> sure but what I am saying is: in Rust we should define it to be. Is there anything wrong with that?</p>",
        "id": 276795553,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397844
    },
    {
        "content": "<p>On 8086, with <code>-mnear-data-far-fn</code>, you can't transmute from data pointers to fn pointers (nor the other way arround, but you can transmute_copy in reverse).</p>",
        "id": 276795559,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648397855
    },
    {
        "content": "<p>ah I should have known you would pull up some obscure system from the 80s ;)</p>",
        "id": 276795570,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397877
    },
    {
        "content": "<p>In WASM there is just a fixed-size array of functions and a \"function pointer\" is actually an index into that array. You can turn that into a \"fake\" pointer like any integer, but you are doing something Confusing to say the least at that point.</p>",
        "id": 276795609,
        "sender_full_name": "Gankra",
        "timestamp": 1648397883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I view that array as just another address space <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 276795618,
        "sender_full_name": "RalfJ",
        "timestamp": 1648397910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795570\">said</a>:</p>\n<blockquote>\n<p>ah I should have known you would pull up some obscure system from the 80s ;)</p>\n</blockquote>\n<p>:P.<br>\nI mean, I do want to work on codegen for 8086, so...</p>",
        "id": 276795631,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648397945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795618\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> I view that array as just another address space <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</blockquote>\n<p>Yep, but Rust has punted on What That Means up until now, and it would be good to... Not.</p>",
        "id": 276795636,
        "sender_full_name": "Gankra",
        "timestamp": 1648397963
    },
    {
        "content": "<p>Like ideally, just as with strict-provenance, we could make it easier in rust to stay in fn-ptr land forever and not cross the streams because doing so raises Questions</p>",
        "id": 276795707,
        "sender_full_name": "Gankra",
        "timestamp": 1648398022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795631\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276795570\">said</a>:</p>\n<blockquote>\n<p>ah I should have known you would pull up some obscure system from the 80s ;)</p>\n</blockquote>\n<p>:P.<br>\nI mean, I do want to work on codegen for 8086, so...</p>\n</blockquote>\n<p>yeah fair, I'm just to a fan of mistakes or obsolete decisions made in the 80s holding us back now. ;)</p>",
        "id": 276795708,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398024
    },
    {
        "content": "<p>Anyways, either form of \"One is a near pointer, one is a far pointer\" would stop transmutes, and stop transmute_copy in one direction.<br>\nThe transmute_copy could also be nonsensical, depending on the order of <code>(offset,segment)</code> (I'd probably want to define it to be that order, but if other compilers think it's the other way arround...)</p>",
        "id": 276795714,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648398048
    },
    {
        "content": "<p>We can have Answers That Are Coherent to those questions but it will be in some sense \"garbage in, garbage out\", and it would be good to avoid the \"garbage in\" part</p>",
        "id": 276795744,
        "sender_full_name": "Gankra",
        "timestamp": 1648398085
    },
    {
        "content": "<p>so basically, we need a RawFnPtr type?</p>",
        "id": 276795755,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398107
    },
    {
        "content": "<p>yeah that's my default solution</p>",
        "id": 276795759,
        "sender_full_name": "Gankra",
        "timestamp": 1648398120
    },
    {
        "content": "<p>hey I thought I'm the type system guy here^^</p>",
        "id": 276795802,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398129
    },
    {
        "content": "<p><code>#[repr(transparent)] OpaqueFnPtr(fn() -&gt; ())</code></p>",
        "id": 276795809,
        "sender_full_name": "Gankra",
        "timestamp": 1648398147
    },
    {
        "content": "<p>can just be some shit in the stdlib</p>",
        "id": 276795810,
        "sender_full_name": "Gankra",
        "timestamp": 1648398156
    },
    {
        "content": "<p>hm it doesnt need lang suppport?</p>",
        "id": 276795825,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398175
    },
    {
        "content": "<p>it might just to define casts or something, needs Design Work</p>",
        "id": 276795839,
        "sender_full_name": "Gankra",
        "timestamp": 1648398203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Also <em>I'm</em> the one who gave you NonNull and Unique to play with :p</p>",
        "id": 276795848,
        "sender_full_name": "Gankra",
        "timestamp": 1648398221
    },
    {
        "content": "<p>fn ptr's only validity invariant is !null, so it could probably sit in stdlib with the defn being <code>Option&lt;fn()&gt;</code> instead of just <code>fn()</code>.</p>",
        "id": 276795849,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648398221
    },
    {
        "content": "<p>yeah but you cant write code that is generic over all fn ptrs</p>",
        "id": 276795900,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398264
    },
    {
        "content": "<p>like converting them to/from RawFnPtr</p>",
        "id": 276795905,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398272
    },
    {
        "content": "<p>(I think I prefer Raw over Opaque, in analogy with raw pointers)</p>",
        "id": 276795923,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398310
    },
    {
        "content": "<p>True. That needs stuff (but we need that anyways <em>stare</em>)</p>",
        "id": 276795925,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648398315
    },
    {
        "content": "<p>The level one solution is just \"yeah still do the transmute\", but at least the type is always known by the compiler to be A Function Pointer and handled as such</p>",
        "id": 276795940,
        "sender_full_name": "Gankra",
        "timestamp": 1648398351
    },
    {
        "content": "<p>yeah we'd need <code>T: FnPtr</code> at least...</p>",
        "id": 276795985,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398377
    },
    {
        "content": "<p>that or a builtin cast, yeah</p>",
        "id": 276795995,
        "sender_full_name": "Gankra",
        "timestamp": 1648398403
    },
    {
        "content": "<p>OTOH if we definitely dont need provenance we could just say <code>RawFnPtr = usize</code>...^^</p>",
        "id": 276795998,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398410
    },
    {
        "content": "<p>It can be Whatever Works :)</p>",
        "id": 276796003,
        "sender_full_name": "Gankra",
        "timestamp": 1648398422
    },
    {
        "content": "<p>we already assume they have the same size anyway, right?</p>",
        "id": 276796013,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398440
    },
    {
        "content": "<p>I don't think rust assumes <code>size_of::&lt;*mut ()&gt;()==size_of::&lt;fn()&gt;()</code></p>",
        "id": 276796020,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648398475
    },
    {
        "content": "<p>hm, Miri and CTFE certainly assume that all pointers are the same size -- raw and fn ptrs included</p>",
        "id": 276796069,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398508
    },
    {
        "content": "<p>Joy.</p>",
        "id": 276796077,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648398533
    },
    {
        "content": "<p>and <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/abi/struct.TargetDataLayout.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/abi/struct.TargetDataLayout.html</a> doesnt have fn_ptr_size so I am pretty sure this assumption is all across the compiler</p>",
        "id": 276796088,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398560
    },
    {
        "content": "<p>I think it defacto does but there isn't anywhere that <em>says</em> that just because, as I am always complaining, you cannot hang docs off <code>as</code>. Certainly I would want A Better Story For Letting People Stay In FnPtr Repr At All Times before really pushing on that door. For the exact same reasons a side-effect of strict-provenance is making it easier to loosen usize.</p>",
        "id": 276796089,
        "sender_full_name": "Gankra",
        "timestamp": 1648398561
    },
    {
        "content": "<p>(That reminds me, I need to fix something of the kind in lccc...)</p>",
        "id": 276796091,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648398562
    },
    {
        "content": "<p>Architectures that need fat function pointers (Itanium, for example) tend to specify the ABI such that function pointers are a thin pointer to the fat pointer (the descriptor, on itanium).</p>\n<p>And while technically IIUC wasm function pointers could be 32 bits even on wasm64, I don't think this matters in practice, since you can just zero-pad it up.</p>",
        "id": 276796149,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648398612
    },
    {
        "content": "<p>Technically I suppose for the Rust ABI we could go against this but it's nice to have e.g. dlsym work.</p>",
        "id": 276796180,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648398676
    },
    {
        "content": "<blockquote>\n<p>Architectures that need fat function pointers (Itanium, for example) tend to specify the ABI such that function pointers are a thin pointer to the fat pointer (the descriptor, on itanium).</p>\n</blockquote>\n<p>lol that's almost what happens to Miri, where a fn ptr is basically a pointer to the <code>ty::Instance</code> of the function ;)</p>",
        "id": 276796186,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398702
    },
    {
        "content": "<p>It's a pretty reasonable design</p>",
        "id": 276796247,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648398796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276796089\">said</a>:</p>\n<blockquote>\n<p>I think it defacto does but there isn't anywhere that <em>says</em> that just because, as I am always complaining, you cannot hang docs off <code>as</code>. Certainly I would want A Better Story For Letting People Stay In FnPtr Repr At All Times before really pushing on that door. For the exact same reasons a side-effect of strict-provenance is making it easier to loosen usize.</p>\n</blockquote>\n<p>yeah it'd be kind of a shame to do the nice disciplined thing for raw pointers, and then just say \"fn ptrs are NonZeroUsize\". OTOH for fn ptrs there's less pressure (due to them not having provenance, at least currently) and it's more annoying (since you can't be generic over them)...</p>",
        "id": 276796252,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398807
    },
    {
        "content": "<p>ofc Miri will yell at you if you transmute a fn ptrs to usize since they do have provenance there ;)</p>",
        "id": 276796307,
        "sender_full_name": "RalfJ",
        "timestamp": 1648398863
    },
    {
        "content": "<p>hence why this is a \"tertiary\" goal of strict provenance. If we're already renovating the house, we should take a look at the shed out back, y'know?</p>",
        "id": 276796309,
        "sender_full_name": "Gankra",
        "timestamp": 1648398865
    },
    {
        "content": "<p>fwiw I believe <span class=\"user-mention\" data-user-id=\"473929\">@Alexander Richardson</span>(?) was working on patches in this vein</p>",
        "id": 276796339,
        "sender_full_name": "Gankra",
        "timestamp": 1648398941
    },
    {
        "content": "<p>(and i would be genuinely shocked if CHERI didn't treat function pointers as proper capabilities)</p>",
        "id": 276796409,
        "sender_full_name": "Gankra",
        "timestamp": 1648399028
    },
    {
        "content": "<p>I'd have to do some research in how other compilers handled far-fn-ptrs in near-data-ptr models, but intuitively, <code>fn()</code> in <code>-mfar-fn</code> and <code>fn() _far</code> (Not Real Syntax) would be the same, and I'd be suprised if there's an ABI-level difference between far data and far fn-pointers. <br>\nIf both of these are in fact true, then the double-indirection trick used by Itanium doesn't work.</p>",
        "id": 276796474,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648399105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276796409\">said</a>:</p>\n<blockquote>\n<p>(and i would be genuinely shocked if CHERI didn't treat function pointers as proper capabilities)</p>\n</blockquote>\n<p>Yes, function pointers are also capabilities, but they are generally derived from a different root capability so that they have the execute permission, which will not be the case for global data pointers. We have had some \"fun\" issues in the past where calling into assembly code would crash because the code was missing the <code>.type   foo,@function</code> directive. In that case the run-time linker will derive the capability from the R/W data capability instead of the R/X one spanning the .text segment and jumping to that capability will fault with a Permit_Execute trap.</p>",
        "id": 276797172,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648400117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276796339\">said</a>:</p>\n<blockquote>\n<p>fwiw I believe <span class=\"user-mention silent\" data-user-id=\"473929\">Alexander Richardson</span>(?) was working on patches in this vein</p>\n</blockquote>\n<p>the patches I was working on were to parse all pointer descriptions from the LLVM data layout which can then be used to differentiate pointers to the alloca/globals/program address space. I will try to upload those shortly, but please don't expect high-quality code, those are my first ever lines of rust.</p>",
        "id": 276797245,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648400214
    },
    {
        "content": "<p>that is very common for rust-lang contributions, and why IMO code quality/correctness is 95% the problem of the reviewer and not the contributor for all PRs :)</p>",
        "id": 276797305,
        "sender_full_name": "Gankra",
        "timestamp": 1648400296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/276796089\">said</a>:</p>\n<blockquote>\n<p>I think it defacto does but there isn't anywhere that <em>says</em> that just because, as I am always complaining, you cannot hang docs off <code>as</code>. Certainly I would want A Better Story For Letting People Stay In FnPtr Repr At All Times before really pushing on that door. For the exact same reasons a side-effect of strict-provenance is making it easier to loosen usize.</p>\n</blockquote>\n<p>The reference has a section on as casts <a href=\"https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\">https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions</a><br>\nBut I don't know how many people actually read it, and I think the reference might be less normative than std docs</p>",
        "id": 276806207,
        "sender_full_name": "Nick12",
        "timestamp": 1648412995
    },
    {
        "content": "<p>It's extremely hard to find anything in the reference, yeah. it feels like it's entirely structured around parsing, the least important thing to \"reference\" lol</p>",
        "id": 276806348,
        "sender_full_name": "Gankra",
        "timestamp": 1648413141
    },
    {
        "content": "<p>at least it has a search but damn a restructure would be welcome.</p>",
        "id": 276806970,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648414011
    },
    {
        "content": "<p>well but to be fair at least we <em>have</em> a reference for parsing; on the semantics we have a lot more questions than answers ;)</p>",
        "id": 276807031,
        "sender_full_name": "RalfJ",
        "timestamp": 1648414092
    },
    {
        "content": "<blockquote>\n<p>so basically, we need a RawFnPtr type?</p>\n</blockquote>\n<p>While you're at it, introduce a <code>Ptr</code> type and deprecate <code>*const T</code> and <code>*mut T</code>, thanks :)</p>",
        "id": 277066469,
        "sender_full_name": "bstrie",
        "timestamp": 1648589032
    },
    {
        "content": "<p><code>type Ptr&lt;T&gt; = Option&lt;NonNull&lt;T&gt;&gt;;</code></p>",
        "id": 277066980,
        "sender_full_name": "scottmcm",
        "timestamp": 1648589305
    },
    {
        "content": "<p>Or just give us a new type, make it bivariant, and let us do what we please.</p>",
        "id": 277068104,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590002
    },
    {
        "content": "<p>you know i tried in like 2015 but no one wants to let me change rust's syntax :(</p>",
        "id": 277068353,
        "sender_full_name": "Gankra",
        "timestamp": 1648590164
    },
    {
        "content": "<p>the secret is to make it a macro. they let me add <code>addr_of!</code>. now nobody is happy. hooray!</p>",
        "id": 277068440,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590227
    },
    {
        "content": "<p>True.</p>",
        "id": 277068570,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590327
    },
    {
        "content": "<p>the telltale signs of a compromise solution ;)</p>",
        "id": 277068727,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590426
    },
    {
        "content": "<p>it's good that you did but i do truly hate it with a passion</p>",
        "id": 277068748,
        "sender_full_name": "Gankra",
        "timestamp": 1648590444
    },
    {
        "content": "<p>But also we need a million different kinds of pointer types.<br>\nPointers to different address spaces, near pointers, far pointers, contravariant pointers.</p>",
        "id": 277068757,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590450
    },
    {
        "content": "<p>underaligned pointers</p>",
        "id": 277068772,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590461
    },
    {
        "content": "<p>Well, those are just raw pointers as they are now.</p>",
        "id": 277068836,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590486
    },
    {
        "content": "<p>well, underaligned references</p>",
        "id": 277068852,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590499
    },
    {
        "content": "<p>evil</p>",
        "id": 277068858,
        "sender_full_name": "Gankra",
        "timestamp": 1648590504
    },
    {
        "content": "<p>with all reference guarantees except alignment</p>",
        "id": 277068860,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590505
    },
    {
        "content": "<p>it's alignment that is evil, really</p>",
        "id": 277068912,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590538
    },
    {
        "content": "<p>a world without padding.... aah.........</p>",
        "id": 277068937,
        "sender_full_name": "Gankra",
        "timestamp": 1648590553
    },
    {
        "content": "<p>IDK, I like fast, non-faulting code.</p>",
        "id": 277068943,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590559
    },
    {
        "content": "<p>alignment's alignment is clearly chaotic evil. or so.</p>",
        "id": 277068947,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/277068937\">said</a>:</p>\n<blockquote>\n<p>a world without padding.... aah.........</p>\n</blockquote>\n<p>Just sort fields in descending order by alignment requirement. Then you only have tail padding.</p>",
        "id": 277069020,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590600
    },
    {
        "content": "<p>I like to pretend that hardware either doesnt exist or is magic and we dont need to leak its limitations into software.</p>",
        "id": 277069086,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590615
    },
    {
        "content": "<p>the problem is the existence of <em>any</em> padding and the eternal struggle it introduces for talking about memcpy/memset</p>",
        "id": 277069140,
        "sender_full_name": "Gankra",
        "timestamp": 1648590655
    },
    {
        "content": "<p>like \"bytes that exist but don't\" is ass</p>",
        "id": 277069189,
        "sender_full_name": "Gankra",
        "timestamp": 1648590683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/277069086\">said</a>:</p>\n<blockquote>\n<p>I like to pretend that hardware either doesnt exist or is magic and we dont need to leak its limitations into software.</p>\n</blockquote>\n<p>I also like to pretend I have an infinitely sized address space and it's as efficient to perform 4 reads of 1 byte each as to perform one read of 4 bytes.</p>",
        "id": 277069193,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648590687
    },
    {
        "content": "<p>dunno, doesnt seem so bad? like it's bad in C but in Rust where we have <code>MaybeUninit</code> it seems fine</p>",
        "id": 277069202,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590692
    },
    {
        "content": "<p>it breaks memcmp and some people think they can use it on data with padsding and that truly is terrible</p>",
        "id": 277069229,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590710
    },
    {
        "content": "<p>or atomic compare_and_set on data with padding, that's also evil</p>",
        "id": 277069276,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590723
    },
    {
        "content": "<p>but otherwise...</p>",
        "id": 277069296,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/277069193\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/277069086\">said</a>:</p>\n<blockquote>\n<p>I like to pretend that hardware either doesnt exist or is magic and we dont need to leak its limitations into software.</p>\n</blockquote>\n<p>I also like to pretend I have an infinitely sized address space and it's as efficient to perform 4 reads of 1 byte each as to perform one read of 4 bytes.</p>\n</blockquote>\n<p>oh yes finite memory suuuucks</p>",
        "id": 277069318,
        "sender_full_name": "RalfJ",
        "timestamp": 1648590751
    },
    {
        "content": "<p>ah but Ralf, have you considered, finite memory makes all things O(1), so who could really say if it's bad, or not,,</p>",
        "id": 277069375,
        "sender_full_name": "Gankra",
        "timestamp": 1648590795
    },
    {
        "content": "<p>i will accept only two realities: everything is O(1) or i am allowed to use <a href=\"https://en.wikipedia.org/wiki/Real_RAM\">Real RAM</a> in algorithms</p>",
        "id": 277069560,
        "sender_full_name": "Gankra",
        "timestamp": 1648590914
    },
    {
        "content": "<p>everything else is cowardice</p>",
        "id": 277069568,
        "sender_full_name": "Gankra",
        "timestamp": 1648590920
    },
    {
        "content": "<p>What I want is pointers that are assumed to point to init data and be aligned, but that aren't exclusive.</p>",
        "id": 277069689,
        "sender_full_name": "Lokathor",
        "timestamp": 1648590985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20and.20Harvard.20architectures/near/277069020\">said</a>:</p>\n<blockquote>\n<p>Just sort fields in descending order by alignment requirement. Then you only have tail padding.</p>\n</blockquote>\n<p>Well <code>repr(Rust)</code> <em>does</em> sort by alignment, these days.  (Just an implementation detail, not a guarantee, of course.)</p>",
        "id": 277076701,
        "sender_full_name": "scottmcm",
        "timestamp": 1648595892
    },
    {
        "content": "<p>Heh, great minds think alike I guess. That's what I spec'd for lccc's ABI.</p>",
        "id": 277079182,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648598082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> see <a href=\"https://www.ahicks.io/posts/April%202017/rust-struct-field-reordering/\">https://www.ahicks.io/posts/April%202017/rust-struct-field-reordering/</a> for details -- apparently enums sort the other way, to easier sneak in the discriminant at the beginning.</p>",
        "id": 277079889,
        "sender_full_name": "scottmcm",
        "timestamp": 1648598582
    },
    {
        "content": "<p>Hmm... Nice. Probably won't change the definition, though. It's easier to define enums as unions of structs.</p>",
        "id": 277080084,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648598755
    }
]