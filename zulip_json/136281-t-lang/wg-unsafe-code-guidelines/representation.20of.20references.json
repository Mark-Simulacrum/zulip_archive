[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span>  I don't understand the latest comments in the representation of references</p>",
        "id": 148794746,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543505905
    },
    {
        "content": "<p>Alignment is part of representation, but whether Option::&lt;&amp;T&gt;::None is \"equal\" to ptr::null::&lt;*const T&gt;() is part of validity</p>",
        "id": 148794798,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543505961
    },
    {
        "content": "<p>You mean <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/issues/16#issuecomment-442877094\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/issues/16#issuecomment-442877094\">https://github.com/rust-rfcs/unsafe-code-guidelines/issues/16#issuecomment-442877094</a>?</p>",
        "id": 148794802,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543505965
    },
    {
        "content": "<p>I don't know if there is any document defining these terms yet</p>",
        "id": 148794823,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543505984
    },
    {
        "content": "<p>I'm unsure that I understood them correctly</p>",
        "id": 148794899,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506016
    },
    {
        "content": "<p>Indeed, we're hitting issues about basic definitions :/</p>",
        "id": 148794924,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506034
    },
    {
        "content": "<p>AFAIK there are at least three terms we use here: representation, validity, and safety</p>",
        "id": 148794931,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506042
    },
    {
        "content": "<p>representation answer the question: what shape do the bits that the type occupies in memory have</p>",
        "id": 148794969,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506074
    },
    {
        "content": "<p>Certainly being non-zero is part of representation, but I'm not sure about alignment.</p>",
        "id": 148794973,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506078
    },
    {
        "content": "<p>aligned of the type is part of representation, but whether the <em>value</em> of type <code>&amp;T</code> must be aligned is part of validity</p>",
        "id": 148794987,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506088
    },
    {
        "content": "<p>that's basically, what's the type's size, what's its alignment</p>",
        "id": 148794992,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506091
    },
    {
        "content": "<blockquote>\n<p>Certainly being non-zero is part of representation, but I'm not sure about alignment.</p>\n</blockquote>\n<p>no, non-zero is also validity</p>",
        "id": 148795010,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506108
    },
    {
        "content": "<p>repr is: align+size of the type, and then the offsets of its fields. and ABI stuff.</p>",
        "id": 148795061,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506127
    },
    {
        "content": "<p>for DSTs representation is more complicated, and attributes like repr(C, packed, align, simd, ...) alter all of this</p>",
        "id": 148795063,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> but non-zero impacts repr, due to <code>Option&lt;T&gt;</code> optimization.</p>",
        "id": 148795074,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506142
    },
    {
        "content": "<p>ah yes, ABI / calling convention stuff is probably also part of representation</p>",
        "id": 148795075,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> no it does not, that impacts validity</p>",
        "id": 148795093,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> enums exploit the validity invariant in how their layout is computed, yes</p>",
        "id": 148795096,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506164
    },
    {
        "content": "<p>the discussions are not entirely separate</p>",
        "id": 148795105,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506170
    },
    {
        "content": "<p>The size, alignment, of Option&lt;&amp;T&gt;  does not depend on which value ptr::null has</p>",
        "id": 148795126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506187
    },
    {
        "content": "<p>but there was so much to talk about in terms of field offsets for structs and tranmuting arrays to homogenous tuples and such things that we decided to split them up</p>",
        "id": 148795131,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> so for you, repr can be based on validity?</p>",
        "id": 148795133,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> it's a cyclic dependency</p>",
        "id": 148795146,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506210
    },
    {
        "content": "<p>validity: which values are the bits of the representation allowed to take</p>",
        "id": 148795147,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ugh</p>",
        "id": 148795150,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506219
    },
    {
        "content": "<p>validity of a struct depends on repr, i.e., on the offsets of the fields</p>",
        "id": 148795156,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506223
    },
    {
        "content": "<p>I thought validity depended on repr, but not vice versa.</p>",
        "id": 148795161,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506236
    },
    {
        "content": "<p>repr: what's the shape of the bits, validity: which values can the bits take</p>",
        "id": 148795210,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506255
    },
    {
        "content": "<p>yeah no enum optimizations make these form a cycle</p>",
        "id": 148795215,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506261
    },
    {
        "content": "<p>depending on padding, etc. , repr interacts with validity</p>",
        "id": 148795218,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506266
    },
    {
        "content": "<p>but most of the time one can treat these separate</p>",
        "id": 148795230,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506283
    },
    {
        "content": "<p>so if we say: the bit values of <code>ptr::null()</code> are not a <strong>valid</strong> bit pattern for <code>&amp;T</code>, that's validity, and because <code>Option</code> is an enum, and enums can exploit invalid bit patterns (called <strong>niches</strong>), that <code>Option&lt;&amp;T&gt;::None</code> has the same bit pattern as <code>ptr::null()</code> follows from all of that</p>",
        "id": 148795293,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506359
    },
    {
        "content": "<p>I'd been interpreting them as repr includes which bitstrings are valid just looking at the bitstring, no looking at the rest of memory.</p>",
        "id": 148795344,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think we need a half a page definition of these terms somewhere in the reference</p>",
        "id": 148795359,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506405
    },
    {
        "content": "<p>Validity is the invariant including the state of the rest of memory.</p>",
        "id": 148795364,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506406
    },
    {
        "content": "<p>I am not sure, but I think you might be talking about <strong>safety</strong></p>",
        "id": 148795422,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506470
    },
    {
        "content": "<p><strong>validity</strong> is a property of the type, it does not interact with memory beyond the type AFAICT</p>",
        "id": 148795475,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> is this the same as your use of safety vs validity?</p>",
        "id": 148795515,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506555
    },
    {
        "content": "<p><strong>safety</strong> would be, e.g., pre-conditions on unsafe methods such that safe Rust calling safe methods remains safe, or something like that</p>",
        "id": 148795533,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506580
    },
    {
        "content": "<p>e.g. constructing a <code>&amp;str</code> using <code>from_utf8_unchecked</code> requires that the byte string passed as argument actually is valid UTF-8 for <strong>safety</strong></p>",
        "id": 148795605,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> it's definitely not the same approach to defining the terms, and if they happen to coincide it's by accident. but i think the way things are going, not even that seems true -- the validity invariants mostly/likely <em>do not</em> look at other memory. (e.g. reference validity might not look at the memory the reference points at)</p>",
        "id": 148795668,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543506688
    },
    {
        "content": "<p>/me is rereading <a href=\"https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html\" target=\"_blank\" title=\"https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html\">https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html</a></p>",
        "id": 148795671,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506690
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think we need a half a page definition of these terms somewhere in the reference</p>\n</blockquote>\n<p>I was actually thinking that we merge these two discussions in the text after we are done with both</p>",
        "id": 148795685,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506704
    },
    {
        "content": "<p>but yes we also need definitions^^</p>",
        "id": 148795743,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506732
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> sorry, which two discussions?</p>",
        "id": 148795750,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506742
    },
    {
        "content": "<p>having to go through the couple of blog posts to figure out all the definitions is maybe a too high a barrier of entry</p>",
        "id": 148795762,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506763
    },
    {
        "content": "<p>repr and validity</p>",
        "id": 148795766,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506767
    },
    {
        "content": "<p>the distinction between validity and safety for me is that validity is what must <em>always</em> hold, even in unsafe code, while safety is what safe code can rely on (but unsafe code is allowed to temporarily violate)</p>",
        "id": 148795778,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> do we have a name for \"correctness of a bitstring without looking at the rest of memory\"?</p>",
        "id": 148795822,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506831
    },
    {
        "content": "<p>references must always be dereferencable, but validity actually kind-of can depend on memory.</p>",
        "id": 148795835,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506838
    },
    {
        "content": "<p>(e.g. &amp;T being T-aligned, bool being just 0 and 1 etc.)</p>",
        "id": 148795901,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543506862
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> what do you mean by \"correctness\" ?</p>",
        "id": 148795907,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> I don't think we have that concept. there is no situation in which a reference must be aligned but may be dangling.</p>",
        "id": 148795915,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506884
    },
    {
        "content": "<p>If I have a <code>struct PrimeInt(i32);</code> would that include a bit representation that does not represent a prime number ?</p>",
        "id": 148795923,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506890
    },
    {
        "content": "<blockquote>\n<p>If I have a <code>struct PrimeInt(i32);</code> would that include a bit representation that does not represent a prime number ?</p>\n</blockquote>\n<p>validity is compiler-defined, you cannot just pick it</p>",
        "id": 148795952,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506912
    },
    {
        "content": "<p>safety OTOH can be user-defined if you have custom invariants</p>",
        "id": 148795958,
        "sender_full_name": "RalfJ",
        "timestamp": 1543506921
    },
    {
        "content": "<p>that's why i'm asking <span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> what they mean by \"correctness\"</p>",
        "id": 148795968,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506932
    },
    {
        "content": "<p>depending on what they mean, they might be talking about validity, or safety, or both =/</p>",
        "id": 148795983,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543506952
    },
    {
        "content": "<p>Good question, I guess (as with safety) there's the invariants enforced by the language, and then possibly stricter ones that are user-defined.</p>",
        "id": 148796065,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> it is possible to phrase things a bit differently such that validity does not depend on memory (or rather, it only depends in ways that can never be invalidated once something is valid: <code>&amp;dyn Trait</code> must have a proper vtable, that is validity, but once true it can never be non-true because vtables live in constant memory). then the fact that references are dereferencable follows from \"retagging\" as part of Stacked Borrows. I am not sure if that helps, though...</p>",
        "id": 148796093,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507037
    },
    {
        "content": "<p>As a concrete instance, the statement that <code>bool</code> contains only 0 and 1, is that validity?</p>",
        "id": 148796185,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507117
    },
    {
        "content": "<p>so, I don't think that it is useful to have a notion of \"there exists a memory for which this is valid, whether or not that's the current memory\".</p>",
        "id": 148796202,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507129
    },
    {
        "content": "<blockquote>\n<p>As a concrete instance, the statement that <code>bool</code> contains only 0 and 1, is that validity?</p>\n</blockquote>\n<p>yes.</p>",
        "id": 148796205,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507135
    },
    {
        "content": "<p>Which bits a type is allowed to take without being undefined behavior is specified by <strong>validity</strong>. Which bits a type is allowed to take such that safe code remains safe is specified by <strong>safety</strong> - <code>unsafe</code> code can break <strong>safety</strong> temporarily as long as safe Rust code cannot exploit it in the meantime to run into undefined behavior - <code>unsafe</code> code cannot break <strong>validity</strong>, doing so is undefined behavior</p>",
        "id": 148796207,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507138
    },
    {
        "content": "<p><code>bool</code>'s validity happens to not depend on memory</p>",
        "id": 148796214,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507144
    },
    {
        "content": "<p><code>&amp;T</code>'s validity, however, <em>does</em> depend on memory</p>",
        "id": 148796226,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507150
    },
    {
        "content": "<p>you cannot create a <code>bool</code> with a value of <code>3</code> ever, not even in <code>unsafe</code> code - that's UB</p>",
        "id": 148796242,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> because a valid <code>&amp;T</code> is required to be dereferencable?</p>",
        "id": 148796257,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507182
    },
    {
        "content": "<p>what <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> said. moreover, both validity and safety <em>may</em> talk about memory, but they don't <em>have</em> to</p>",
        "id": 148796329,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507206
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> because a valid <code>&amp;T</code> is required to be dereferencable?</p>\n</blockquote>\n<p>yes</p>",
        "id": 148796333,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507209
    },
    {
        "content": "<p>It also depends on where the object of type <code>T</code> is, if the object is at an unaligned address, then <code>&amp;T</code> bit pattern would contain an unaligned memory address, which is not <strong>valid</strong></p>",
        "id": 148796341,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507224
    },
    {
        "content": "<p>because <code>&amp;T</code> is not allowed to point to unaligned memory</p>",
        "id": 148796357,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507242
    },
    {
        "content": "<p>that's something that not even <code>unsafe</code> Rust code can temporarily violate</p>",
        "id": 148796376,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507256
    },
    {
        "content": "<p>Hmm, so unsafe code isn't allowed to create an undereferencable <code>&amp;T</code> temporarily?</p>",
        "id": 148796398,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507273
    },
    {
        "content": "<p>and to be clear, the alignment requirement is not really \"talking about memory\" -- it just inspects the address bits in the pointer</p>",
        "id": 148796406,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543507284
    },
    {
        "content": "<p>right, so validity for <code>x: &amp;T</code> makes the following requirements (and maybe more, we haven't discussed that yet^^)</p>\n<ul>\n<li><code>x</code> is not 0x0</li>\n<li><code>x</code> is aligned to <code>mem::align_of_val(x)</code></li>\n<li><code>x</code> is dereferencable: <code>mem::sitze_of_val(x)</code> many bytes starting at address <code>x</code> are allocated and can be read</li>\n</ul>",
        "id": 148796429,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507308
    },
    {
        "content": "<p>exactly, we don't have to dereference a <code>&amp;T</code> to check whether its valid, we can always just tell by looking at <code>&amp;T</code></p>",
        "id": 148796438,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507317
    },
    {
        "content": "<p>So unsafe code can't transmute a <code>&amp;[T]</code> to a <code>&amp;T</code>?</p>",
        "id": 148796519,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507347
    },
    {
        "content": "<blockquote>\n<p>exactly, we don't have to dereference a <code>&amp;T</code> to check whether its valid, we can always just tell by looking at <code>&amp;T</code></p>\n</blockquote>\n<p>well, we have to figure out if memory is allocated. which you cannot actually do inside the language.</p>",
        "id": 148796525,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507355
    },
    {
        "content": "<p>because the <code>&amp;[T]</code> might be empty.</p>",
        "id": 148796532,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507361
    },
    {
        "content": "<blockquote>\n<p>So unsafe code can't transmute a <code>&amp;[T]</code> to a <code>&amp;T</code>?</p>\n</blockquote>\n<p>correct. if the slice is empty, that's UB.</p>",
        "id": 148796539,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507366
    },
    {
        "content": "<p>also they have different size so you cannot immediately transmute. I assume you mean some cast through a raw ptr.</p>",
        "id": 148796557,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507383
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> that's a stronger requirement than C's UB IIRC.</p>",
        "id": 148796611,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543507429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> it is</p>",
        "id": 148796613,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507436
    },
    {
        "content": "<p>it's similar to <code>int&amp;</code></p>",
        "id": 148796656,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507444
    },
    {
        "content": "<p>Note that C++ references have similar requirements</p>",
        "id": 148796661,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507446
    },
    {
        "content": "<p>but even stronger</p>",
        "id": 148796666,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507451
    },
    {
        "content": "<p>references just have to be dereferencable when created and when used</p>",
        "id": 148796678,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507465
    },
    {
        "content": "<p>they can't be null</p>",
        "id": 148796689,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507479
    },
    {
        "content": "<p>in rust, even just assigning a variable asserts validity of the being-assigned data</p>",
        "id": 148796691,
        "sender_full_name": "RalfJ",
        "timestamp": 1543507481
    },
    {
        "content": "<p>I think that's UB in C++ too</p>",
        "id": 148796726,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507505
    },
    {
        "content": "<p>C++ references are not pointers, they are not even objects, they can't be null, they have to always point to a valid T, which due to strict aliasing, has to be properly aligned, etc. etc.</p>",
        "id": 148796762,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507534
    },
    {
        "content": "<p>Is this valid C++? <code>void foo() { int *p = new int; int &amp;r = *p; delete p; }</code></p>",
        "id": 148796846,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543507580
    },
    {
        "content": "<p>the equivalent Rust would be UB because <code>r</code> is no longer dereferenceable at the last line</p>",
        "id": 148796885,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543507606
    },
    {
        "content": "<p>it is, yes, C++ references do not have to be dereferenceable, as long as you don't dereference them obviously, they can dangle</p>",
        "id": 148796915,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507638
    },
    {
        "content": "<p>so that snippet just contains a dangling reference, which is ok in C++, but this reference is not null, and its memory address is appropriately aligned for a <code>T</code></p>",
        "id": 148797001,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543507685
    },
    {
        "content": "<p>I always wondered why C++ compilers do not error when dangling references are returned from functions. Maybe this is why: dangling references are ok.</p>",
        "id": 148797393,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508024
    },
    {
        "content": "<p>So in Rust, the following code can produce UB<code>fn foo(x: &amp;[u8]) -&gt; Option&lt;&amp;u8&gt; { unsafe { let result = &amp;*(x as *u8); if x.len() == 0 { None } else { Some(result) } } }</code>.</p>",
        "id": 148797458,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543508050
    },
    {
        "content": "<blockquote>\n<p>the equivalent Rust would be UB because <code>r</code> is no longer dereferenceable at the last line</p>\n</blockquote>\n<p>that's not true, <code>r</code> is not used again</p>",
        "id": 148797472,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508064
    },
    {
        "content": "<p>i think that depends on what does <code>dereferenceable</code> mean</p>",
        "id": 148797497,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> if that is what you're proposing, I don't see how it justifies <code>dereferenceable</code>? Because that attribute licenses introducing loads <em>anywhere</em> in the function, even after its last use. That is the core of why Clang's use of dereferenceable is unsound, too.</p>",
        "id": 148797563,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543508160
    },
    {
        "content": "<p>this would be UB though:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// UB: copying a dangling ref</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 148797649,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508209
    },
    {
        "content": "<blockquote>\n<p>Because that attribute licenses introducing loads anywhere in the function, even after its last use. That is the core of why Clang's use of dereferenceable is unsound, too.</p>\n</blockquote>\n<p>it was my understanding that this is the case when the attribute is on a <em>parameter</em>?</p>",
        "id": 148797666,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508229
    },
    {
        "content": "<p>there must be some limit to the scope of the attribute</p>",
        "id": 148797672,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508235
    },
    {
        "content": "<p>I have no idea how it works when used inside a function. I mean, it can't just be \"until the end of the current function\" because then inlining would be broken</p>",
        "id": 148797686,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508257
    },
    {
        "content": "<p>this would be UB as well:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"cm\">/* r is dropped afterwards */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 148797701,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508276
    },
    {
        "content": "<p>for parameters, Stacked Borrows has a special thing ensuring you dont allocate them while the function runs (\"barriers\")</p>",
        "id": 148797746,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508283
    },
    {
        "content": "<blockquote>\n<p>this would be UB as well:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"cm\">/* r is dropped afterwards */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n</blockquote>\n<p>no, <code>r</code> has no drop glue</p>",
        "id": 148797759,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508297
    },
    {
        "content": "<p>and NLL lets us witness that that is the case</p>",
        "id": 148797776,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508310
    },
    {
        "content": "<p>but it is still alive, even if there is nothing to drop ?</p>",
        "id": 148797784,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508316
    },
    {
        "content": "<p>or is <code>r</code> \"dead\" before <code>drop(b)</code> ?</p>",
        "id": 148797793,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508325
    },
    {
        "content": "<p>it does not require <code>r</code> to be live at the end</p>",
        "id": 148797796,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508327
    },
    {
        "content": "<blockquote>\n<p>or is <code>r</code> \"dead\" before <code>drop(b)</code> ?</p>\n</blockquote>\n<p>yes</p>",
        "id": 148797808,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508338
    },
    {
        "content": "<p>so values of types without drop glue are dead \"as soon as possible\" ?</p>",
        "id": 148797825,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508368
    },
    {
        "content": "<blockquote>\n<p>for parameters, Stacked Borrows has a special thing ensuring you dont allocate them while the function runs (\"barriers\")</p>\n</blockquote>\n<p>OK I've not kept up with stacked borrows as much as I wanted to so I'm going to take this on faith and then it should be fine. I was just confused because it sounded a bit like the validity invariant \"points to allocated memory of right size\" was supposed to justify the attribute on its own.</p>",
        "id": 148797844,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543508385
    },
    {
        "content": "<p>no. it's the other way around: values of types with drop glue have a use when they are dropped</p>",
        "id": 148797854,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508396
    },
    {
        "content": "<p>so values of types without drop glue die on their last use ?</p>",
        "id": 148797919,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508435
    },
    {
        "content": "<p>and then yes stuff with function scope is complicated, and that's where we cannot really tease apart validity and Stacked Borrows any more. (or, we can, but now \"dereferencable\" becomes part of stacked borrows, not of validity.)</p>",
        "id": 148797924,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508445
    },
    {
        "content": "<p>not sure what you mean by \"die\"</p>",
        "id": 148797936,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508460
    },
    {
        "content": "<p>they have to be valid at all uses</p>",
        "id": 148797945,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508466
    },
    {
        "content": "<blockquote>\n<p>so values of types without drop glue die on their last use ?</p>\n</blockquote>\n<p>Values don't die, they cease to be live because there are no more uses. The reason types with drop glue <em>don't</em> \"die early\" is because the drop is a use very late in the function.</p>",
        "id": 148797958,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543508485
    },
    {
        "content": "<p>end of story. \"dereferencable\" is a bit special in that it is entangled with Stacked Borrows because of its function scope</p>",
        "id": 148797966,
        "sender_full_name": "RalfJ",
        "timestamp": 1543508496
    },
    {
        "content": "<p>TIL - thanks - I think I have to read about \"valid at all uses\", that wasn't really part of my mental model</p>",
        "id": 148798053,
        "sender_full_name": "gnzlbg",
        "timestamp": 1543508573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> it's not really cyclic - it's more like a dag</p>",
        "id": 148799188,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> it's mutually recursive but well-founded, as repr of an enum only depends on validity of its fields.</p>",
        "id": 148799315,
        "sender_full_name": "RalfJ",
        "timestamp": 1543509768
    },
    {
        "content": "<p>for any given type T, validity depends on the representation of T, and the validity and representation of all T's sub-objects</p>",
        "id": 148799319,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509776
    },
    {
        "content": "<p>mmh</p>",
        "id": 148799329,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509783
    },
    {
        "content": "<p>yeah, okay</p>",
        "id": 148799334,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509785
    },
    {
        "content": "<p>I think you said the same thing in different words^^</p>",
        "id": 148799357,
        "sender_full_name": "RalfJ",
        "timestamp": 1543509812
    },
    {
        "content": "<p>yep!</p>",
        "id": 148799363,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509817
    },
    {
        "content": "<p>\"well-founded\" is a good term</p>",
        "id": 148799384,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509839
    },
    {
        "content": "<p>sometimes, research is good for something ;)</p>",
        "id": 148799448,
        "sender_full_name": "RalfJ",
        "timestamp": 1543509859
    },
    {
        "content": "<p>I am literally a mathematics major :P</p>",
        "id": 148799523,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543509938
    },
    {
        "content": "<p>I know, I'm joking :D</p>",
        "id": 148799529,
        "sender_full_name": "RalfJ",
        "timestamp": 1543509948
    },
    {
        "content": "<p>I'm taking an abstract algebra course next quarter</p>",
        "id": 148799632,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543510053
    },
    {
        "content": "<p>I am _very_ excited</p>",
        "id": 148799637,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543510059
    },
    {
        "content": "<p><span class=\"emoji emoji-2764\" title=\"heart\">:heart:</span> algebra</p>",
        "id": 148799753,
        "sender_full_name": "RalfJ",
        "timestamp": 1543510148
    },
    {
        "content": "<p>Submitted <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/pull/51\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/pull/51\">https://github.com/rust-rfcs/unsafe-code-guidelines/pull/51</a></p>",
        "id": 148801099,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1543511250
    },
    {
        "content": "<p>OK, silly naming question. Does \"reference\" in Rust include trait objects or not?</p>",
        "id": 151396609,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544472230
    },
    {
        "content": "<p>I think the answer is \"yes\", in which case how do I refer to \"<code>&amp;T</code> or <code>&amp;mut T</code> where <code>T</code> is a type\"?</p>",
        "id": 151396751,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544472287
    },
    {
        "content": "<p>This is coming up in the context of <span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span>'s comment at <a href=\"https://github.com/rust-rfcs/unsafe-code-guidelines/pull/51#pullrequestreview-181964318\" target=\"_blank\" title=\"https://github.com/rust-rfcs/unsafe-code-guidelines/pull/51#pullrequestreview-181964318\">https://github.com/rust-rfcs/unsafe-code-guidelines/pull/51#pullrequestreview-181964318</a></p>",
        "id": 151396953,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544472375
    },
    {
        "content": "<p>for which the fix is to say something like \"The alignment of <code>&amp;T</code> and <code>&amp;mut T</code>, where <code>T</code> is a type, is the word size\" which is quite clunky.</p>",
        "id": 151397208,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544472495
    },
    {
        "content": "<p>in code you'd say <code>where T: Sized</code>, iirc, but i'm not totally sure how to word that for docs that succinctly</p>",
        "id": 151397368,
        "sender_full_name": "QuietMisdreavus",
        "timestamp": 1544472571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133692\">@QuietMisdreavus</span> trait objects are the issue here, the problem is that the alignment of <code>&amp;dyn Trait</code>might be more than the word size, sigh.</p>",
        "id": 151397618,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544472697
    },
    {
        "content": "<p>oh, you're right, custom DSTs too.</p>",
        "id": 151397822,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544472803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> I am a bit confused, because your two first questions do not connect.^^ yes, reference include <code>&amp;dyn Trait</code>. in <code>&amp;T</code>, <code>T</code> is always a type. we have some old syntax where without context we can confuse types and traits, but we also have <code>dyn Trait</code> as new syntax to avoid that ambiguity.</p>",
        "id": 151404477,
        "sender_full_name": "RalfJ",
        "timestamp": 1544479018
    },
    {
        "content": "<p>also when you are talking about the alignment of <code>&amp;T</code>, do you mean the alignment of this type itself (the same way that <code>i32</code> has alignment 4), or the required alignment of <em>values of the given type</em> (which is just the alignment of <code>T</code>)?</p>",
        "id": 151404558,
        "sender_full_name": "RalfJ",
        "timestamp": 1544479096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I was meaning the alignment of <code>&amp;T</code> itself, not the valid values (which are multiples of <code>T</code>s alignment).</p>",
        "id": 151406454,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544480810
    },
    {
        "content": "<p>The problem being that if <code>T</code> is a custom DST, then <code>&amp;T</code> might have alignment greater than the word, sigh.</p>",
        "id": 151406500,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544480856
    },
    {
        "content": "<p>So in order to not box ourselves in for DSTs, we need to allow <code>&amp;T</code> to have alignment that's possibly greater than a word.</p>",
        "id": 151406568,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544480916
    },
    {
        "content": "<p>Sigh.</p>",
        "id": 151406576,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544480927
    },
    {
        "content": "<p>ah I see</p>",
        "id": 151428988,
        "sender_full_name": "RalfJ",
        "timestamp": 1544514631
    },
    {
        "content": "<p>I don't see what's so bad about that though^^ you can always determine the current alignment with <code>align_of</code>, after all</p>",
        "id": 151428989,
        "sender_full_name": "RalfJ",
        "timestamp": 1544514650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> it makes the definition wordier, rather than just \"<code>&amp;T</code> is word-aligned\" we have \"<code>&amp;T</code> is at least word-aligned, and is word-aligned in the following cases...\"</p>",
        "id": 151453915,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1544542279
    },
    {
        "content": "<p>seems like the definition should be in terms of a desugaring to a <code>struct</code></p>",
        "id": 151453969,
        "sender_full_name": "RalfJ",
        "timestamp": 1544542320
    },
    {
        "content": "<p>there are no new rules here, right? the fact that <code>u64</code> metadata can increase alignment is just like <code>(*const (), u64)</code> having a larger-than-word alignment</p>",
        "id": 151454054,
        "sender_full_name": "RalfJ",
        "timestamp": 1544542363
    },
    {
        "content": "<p>that's why I preferred the generic definition for DSTs, but the equivalent without that is to just say that \"<code>&amp;T</code> has the same layout as ...\"</p>",
        "id": 151454687,
        "sender_full_name": "gnzlbg",
        "timestamp": 1544542914
    }
]