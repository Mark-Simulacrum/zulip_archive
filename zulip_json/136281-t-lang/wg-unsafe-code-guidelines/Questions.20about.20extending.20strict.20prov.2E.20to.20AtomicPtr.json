[
    {
        "content": "<p>Currently, the unstable strict_provenance API can express almost everything except for AtomicPtr ops. This is <a href=\"https://github.com/rust-lang/rust/issues/95492\">https://github.com/rust-lang/rust/issues/95492</a>. I'd like to implement this (and have time to take a stab this weekend), because I have code that does int-&gt;ptr-&gt;int for atomics, and feel it might be a useful data-point. I also think answering these questions will help prove out the model in different ways.</p>\n<p>However, I think the API is not as trivial as just copying the design of AtomicUsize and supergluing it onto the pointer. In particular, I've raised three questions in my comment on the issue about it. I've reproduced them here for the lazy.</p>\n<ol>\n<li>\n<p>What should the argument type to <code>AtomicPtr::&lt;T&gt;::fetch_and(&amp;self, arg: ???) -&gt; *mut T</code> be?</p>\n<p>Is there a way to make this work as a bit-clear operation? Note that this is required for many uses (one from inside <code>parking_lot_core</code> is linked).</p>\n</li>\n<li>\n<p>I can think of uses for <code>fetch_and</code>, <code>fetch_or</code>, and <code>fetch_xor</code> (the latter sounds cursed but is useful for doing an atomic bitflip), but what about <code>fetch_nand</code>, <code>fetch_max</code>, and <code>fetch_min</code>. Are these coherent?</p>\n</li>\n<li>\n<p>What should the units be for <code>fetch_wrapping_{add,sub,offset}</code>? I think bytes are clearly the most useful and general (especially given that you cannot turn <code>&amp;AtomicPtr&lt;T&gt;</code> into <code>&amp;AtomicPtr&lt;u8&gt;</code> easily), but this is unsymmetric with the APIs in <code>core::ptr</code></p>\n</li>\n</ol>\n<p>Thoughts?</p>",
        "id": 277343480,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648762648
    },
    {
        "content": "<p>For 3. you can easily tranamute. I think we should also get a safe cast() operation like there is on raw pointers.</p>",
        "id": 277343944,
        "sender_full_name": "bjorn3",
        "timestamp": 1648762958
    },
    {
        "content": "<p>Yeah, that seems reasonable.</p>",
        "id": 277344000,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763022
    },
    {
        "content": "<p>I guess I'll answer 3 by \"units of T\" and do a separate PR to add <code>AtomicPtr::&lt;T&gt;::cast::&lt;U&gt;</code>. It's only really useful in the context of those functions, but isnt really related to the rest.</p>",
        "id": 277344128,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763110
    },
    {
        "content": "<p>I think the arguments for <code>fetch_op</code> should all be usize</p>",
        "id": 277344133,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763118
    },
    {
        "content": "<p>Hmm</p>",
        "id": 277344138,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763123
    },
    {
        "content": "<p>these are all operations of the form <code>new_ptr = old_ptr OP x</code></p>",
        "id": 277344149,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763132
    },
    {
        "content": "<p>I suppose that's reasonable.</p>",
        "id": 277344172,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763155
    },
    {
        "content": "<p>what is the provenance of <code>new_ptr</code>?</p>",
        "id": 277344174,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763156
    },
    {
        "content": "<p>the only unambiguous option is to say, the one of <code>old_ptr</code>, and <code>x</code> can't have any</p>",
        "id": 277344226,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763168
    },
    {
        "content": "<p>I was thinking the old ptr might be ptr::invalid(1) and you might want to fetch_or in the new poitner or something</p>",
        "id": 277344233,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763172
    },
    {
        "content": "<p>I see.</p>",
        "id": 277344242,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763181
    },
    {
        "content": "<p>then you need two operations though</p>",
        "id": 277344246,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763186
    },
    {
        "content": "<p>But realistically</p>",
        "id": 277344250,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763187
    },
    {
        "content": "<p>one that uses provenacne-from-the-left</p>",
        "id": 277344254,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763190
    },
    {
        "content": "<p>I can't imagine that being done without a cas</p>",
        "id": 277344256,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763194
    },
    {
        "content": "<p>and one that uses provenance-from-the-right</p>",
        "id": 277344257,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763196
    },
    {
        "content": "<p>yeah i see</p>",
        "id": 277344258,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763196
    },
    {
        "content": "<p>Okay, so it would be usize</p>",
        "id": 277344264,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763204
    },
    {
        "content": "<p>Thats 2/3 questions down then</p>",
        "id": 277344286,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763221
    },
    {
        "content": "<p>The last question would be if those operations are coherent, I think I'll stand by \"no\" just to be conservative for now.</p>",
        "id": 277344318,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763252
    },
    {
        "content": "<p>for 2, I mean all operations are 'coherent': <code>new_ptr = old_ptr.map_addr(|a| a OP x)</code></p>",
        "id": 277344320,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763254
    },
    {
        "content": "<p>well</p>",
        "id": 277344324,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763260
    },
    {
        "content": "<p>hmm</p>",
        "id": 277344328,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763263
    },
    {
        "content": "<p>so it would only apply to the addr?</p>",
        "id": 277344331,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763267
    },
    {
        "content": "<p>so everything AtomivUsize has, AtomicPtr can have</p>",
        "id": 277344334,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763268
    },
    {
        "content": "<p>okay</p>",
        "id": 277344345,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763275
    },
    {
        "content": "<p>that's all three then</p>",
        "id": 277344372,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763282
    },
    {
        "content": "<p>whether that actually makes any sense I cannot tell you</p>",
        "id": 277344406,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763286
    },
    {
        "content": "<p>but any <code>(usize, usize) → usize</code> is easily lifted to <code>(ptr, usize) → ptr</code> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277344446,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763311
    },
    {
        "content": "<p>I dont know, but it would be a shame for someone to resort to AtomicUsize because of this. That said they'll get yeeted from the patch if I hit snags with LLVM for whatever reason</p>",
        "id": 277344470,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763325
    },
    {
        "content": "<p>yeah LLVM might not like any of this</p>",
        "id": 277344489,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763343
    },
    {
        "content": "<p>Well, I know how to add intrinsics more or less, so I can futz a bit with that</p>",
        "id": 277344543,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763381
    },
    {
        "content": "<p>But when I poked at it before it didnt seem needed</p>",
        "id": 277344552,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763390
    },
    {
        "content": "<p>I'm also willing to do crimes to make it work for now.</p>",
        "id": 277344655,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763431
    },
    {
        "content": "<p>but dont expect to need to</p>",
        "id": 277344666,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763445
    },
    {
        "content": "<p>Oh, I think 1b isn't answered.</p>",
        "id": 277344688,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763468
    },
    {
        "content": "<p>So do all of these get compiled to a CAS? I assume hardware has support for at least some of these. Maybe the right metric is \"we should add the dedicated function if we expect it to be faster than implementing the same thing via <code>.atomic_map_addr()</code>\"</p>",
        "id": 277344701,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648763476
    },
    {
        "content": "<p>parking_lot wants to use <code>fetch_and</code> to clear a bit</p>",
        "id": 277344704,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277344701\">said</a>:</p>\n<blockquote>\n<p>So do all of these get compiled to a CAS? I assume hardware has support for at least some of these. Maybe the right metric is \"we should add the dedicated function if we expect it to be faster than implementing the same thing via <code>.atomic_map_addr()</code>\"</p>\n</blockquote>\n<p>Depends on the hardware. hardware exists that has all of these as starvation-free atomic ops (e.g. not cas loops)</p>",
        "id": 277344744,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277344704\">said</a>:</p>\n<blockquote>\n<p>parking_lot wants to use <code>fetch_and</code> to clear a bit</p>\n</blockquote>\n<p>E.g. it does <code>p.fetch_and(!LOCKED_BIT)</code> or something. But if ptr size &gt; usize size, then this would clear the top bits</p>",
        "id": 277344863,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763584
    },
    {
        "content": "<p>e.g. cheri's special provenance stuff</p>",
        "id": 277344886,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763596
    },
    {
        "content": "<p>Actually, now that I've said it... is <code>atomic_map_addr</code> something we might want to add, gated both on this feature and on <code>#![feature(strict_provenance)]</code>?</p>",
        "id": 277344945,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648763627
    },
    {
        "content": "<p>I guess but it would just be sugar for fetch_update + with_addr</p>",
        "id": 277345021,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763655
    },
    {
        "content": "<p>I don't really care about that</p>",
        "id": 277345027,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763658
    },
    {
        "content": "<p>Hmm, I guess that the bitclear operation isn't needed if these are all defined to only operate on the addr.</p>",
        "id": 277345344,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648763852
    },
    {
        "content": "<p>I think this is resolved. I guess I'll mark it as such for now.</p>",
        "id": 277346830,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648764660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> has marked this topic as resolved.</p>",
        "id": 277346833,
        "sender_full_name": "Notification Bot",
        "timestamp": 1648764661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.E2.9C.94.20Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277344688\">said</a>:</p>\n<blockquote>\n<p>Oh, I think 1b isn't answered.</p>\n</blockquote>\n<p>I dont know what a bit-clear operation is^^</p>",
        "id": 277348359,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.E2.9C.94.20Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277344945\">said</a>:</p>\n<blockquote>\n<p>Actually, now that I've said it... is <code>atomic_map_addr</code> something we might want to add, gated both on this feature and on <code>#![feature(strict_provenance)]</code>?</p>\n</blockquote>\n<p>how'd that work? it has to be <em>atomic</em></p>",
        "id": 277348403,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765681
    },
    {
        "content": "<p>you can't just atomically execute an arbitrary <code>usize → usize</code> closure^^</p>",
        "id": 277348451,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> has marked this topic as unresolved.</p>",
        "id": 277348470,
        "sender_full_name": "Notification Bot",
        "timestamp": 1648765718
    },
    {
        "content": "<p>bit-clear is <code>a &amp; !b</code>. e.g. parking_lot wants to do <code>a.fetch_and(!LOCKED_BIT)</code> or something, to clear the locked bit</p>",
        "id": 277348492,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277348403\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.E2.9C.94.20Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277344945\">said</a>:</p>\n<blockquote>\n<p>Actually, now that I've said it... is <code>atomic_map_addr</code> something we might want to add, gated both on this feature and on <code>#![feature(strict_provenance)]</code>?</p>\n</blockquote>\n<p>how'd that work? it has to be <em>atomic</em></p>\n</blockquote>\n<p>CAS loop</p>",
        "id": 277348511,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648765760
    },
    {
        "content": "<p>yeah but that kinda sucks. maybe someone can add that on top of `fetch_update if they care</p>",
        "id": 277348527,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765779
    },
    {
        "content": "<p>personally i do not</p>",
        "id": 277348541,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765789
    },
    {
        "content": "<p>Yeah, I'm not that hung up on it to be clear, I was just thinking about it in the spirit of \"APIs we can add to stop people from doing non-strict provenance stuff\"</p>",
        "id": 277348617,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648765824
    },
    {
        "content": "<p>i actually think this one might cause more confusion</p>",
        "id": 277348626,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765840
    },
    {
        "content": "<p>but about the atomicness</p>",
        "id": 277348629,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765845
    },
    {
        "content": "<p>like there's good reasons to do <code>fetch_and</code> over <code>fetch_update(|a| Some(a &amp; b)).unwrap()</code></p>",
        "id": 277348635,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765859
    },
    {
        "content": "<p>specifically it's much more likely to be implemented in a starvation-free manner</p>",
        "id": 277348689,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765906
    },
    {
        "content": "<p>i think atomic_map_addr would just confuse people into thinking the other parts aren't provenance aware</p>",
        "id": 277348793,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648765961
    },
    {
        "content": "<p>Yeah, that's fair</p>",
        "id": 277348938,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648766054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277348492\">said</a>:</p>\n<blockquote>\n<p>bit-clear is <code>a &amp; !b</code>. e.g. parking_lot wants to do <code>a.fetch_and(!LOCKED_BIT)</code> or something, to clear the locked bit</p>\n</blockquote>\n<p>oh so its just another operation? sure, why would that one be special?</p>",
        "id": 277351521,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767744
    },
    {
        "content": "<p>it's unclear if it needs to be another operation or if we can just get by with fetch_and</p>",
        "id": 277352156,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648768268
    },
    {
        "content": "<p>e.g. if <code>usize</code> is smaller then a pointer, then <code>fetch_and(!LOCKED_BIT)</code> would clear parts of the pointers bits</p>",
        "id": 277352193,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648768300
    },
    {
        "content": "<p>in addition to clearing LOCKED_BIT</p>",
        "id": 277352204,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648768311
    },
    {
        "content": "<p>right?</p>",
        "id": 277352213,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648768315
    },
    {
        "content": "<p>oh you are thinking of CHERI?</p>",
        "id": 277352275,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768338
    },
    {
        "content": "<p>I can't help with that I am afraid...</p>",
        "id": 277352282,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768351
    },
    {
        "content": "<p>hmm.</p>",
        "id": 277352306,
        "sender_full_name": "Jubilee",
        "timestamp": 1648768378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277352275\">said</a>:</p>\n<blockquote>\n<p>oh you are thinking of CHERI?</p>\n</blockquote>\n<p>a little, since its a motivating concern of the strict provenance work. but cheri's pointer atomics all work on a pointer-sized type.</p>",
        "id": 277354564,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648770351
    },
    {
        "content": "<p>(and ofc we need to avoid mixed-size access)</p>",
        "id": 277354616,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648770383
    },
    {
        "content": "<p>so the usizes need to be widened, but that changes what happens for some of them</p>",
        "id": 277354634,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648770404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277354564\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277352275\">said</a>:</p>\n<blockquote>\n<p>oh you are thinking of CHERI?</p>\n</blockquote>\n<p>a little, since its a motivating concern of the strict provenance work. but cheri's pointer atomics all work on a pointer-sized type.</p>\n</blockquote>\n<p>hm that seems to contradict what was said in the issue though?</p>",
        "id": 277358721,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277354634\">said</a>:</p>\n<blockquote>\n<p>so the usizes need to be widened, but that changes what happens for some of them</p>\n</blockquote>\n<p>ah okay, I see why min/max sound bad^^</p>",
        "id": 277358850,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774539
    },
    {
        "content": "<p>but for bit-and and bit-or there are neutral elements one could widen it to</p>",
        "id": 277358855,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774548
    },
    {
        "content": "<p>From <a href=\"https://github.com/rust-lang/rust/issues/95492#issuecomment-1085283380\">https://github.com/rust-lang/rust/issues/95492#issuecomment-1085283380</a> it seems that on CHERI there are addr-only atomic operations, so you don't need to widen anything?</p>",
        "id": 277382427,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1648800456
    },
    {
        "content": "<p>For CHERI all the RMW atomics only operate on the address part of the pointer. Only (compare-and-)swap updates the full 129 bits</p>",
        "id": 277388327,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648803923
    },
    {
        "content": "<p>RMW atomics would have to update the provenance too, right? Otherwise you could forge arbitrary pointers with valid provenance by using an atomic add on a pointer with a provenance allowing access to a non-zero sized memory region.</p>",
        "id": 277391400,
        "sender_full_name": "bjorn3",
        "timestamp": 1648805716
    },
    {
        "content": "<p>if it's just <code>ptr.map_addr(|p| p + n)</code> I don't see how you can forge anything. You get the same provenance as the original value, and hence the RMW doesn't even need to touch the capability bits</p>",
        "id": 277413543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648818029
    },
    {
        "content": "<p>if you have a pointer with a capability covering 1 byte, then an atomic add on it will almost certainly make it no longer usable</p>",
        "id": 277413831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648818142
    },
    {
        "content": "<p>map_addr needs to change the capibility bits to reflected changed address, right?</p>",
        "id": 277418987,
        "sender_full_name": "bjorn3",
        "timestamp": 1648820305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277418987\">said</a>:</p>\n<blockquote>\n<p>map_addr needs to change the capibility bits to reflected changed address, right?</p>\n</blockquote>\n<p>I guess that depends on how the capability bits are encoded, i.e. whether they are 'relative' to the address part of the pointer</p>",
        "id": 277420212,
        "sender_full_name": "RalfJ",
        "timestamp": 1648820830
    },
    {
        "content": "<p>\"kinda\"</p>",
        "id": 277433180,
        "sender_full_name": "Jubilee",
        "timestamp": 1648826042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277420212\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Questions.20about.20extending.20strict.20prov.2E.20to.20AtomicPtr/near/277418987\">said</a>:</p>\n<blockquote>\n<p>map_addr needs to change the capibility bits to reflected changed address, right?</p>\n</blockquote>\n<p>I guess that depends on how the capability bits are encoded, i.e. whether they are 'relative' to the address part of the pointer</p>\n</blockquote>\n<p>For far more than you probably want to know about capability encoding see our CHERI Concentrate paper <a href=\"https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2019tc-cheri-concentrate.pdf\">https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2019tc-cheri-concentrate.pdf</a></p>",
        "id": 277438730,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648828390
    },
    {
        "content": "<p>The TL;DR is that bounds are encoded relative to the address. If the address goes too far out of bounds the tag is cleared as you have a capability-shaped bag of bits that you can't dereference or jump to.</p>",
        "id": 277439326,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648828612
    },
    {
        "content": "<p>Thanks for pointing me to that paper!</p>",
        "id": 277440474,
        "sender_full_name": "bjorn3",
        "timestamp": 1648829044
    },
    {
        "content": "<p>It's worth noting that Morello made some slightly different choices (e.g., more bits for bounds), but fundamentally they follow the model (and found bugs in the paper while implementing)</p>",
        "id": 277440633,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648829115
    },
    {
        "content": "<blockquote>\n<p>(and found bugs in the paper while implementing)</p>\n</blockquote>\n<p>Like what?</p>",
        "id": 277440863,
        "sender_full_name": "bjorn3",
        "timestamp": 1648829197
    },
    {
        "content": "<p>IIRC small errors in the math in some edge cases.</p>",
        "id": 277441872,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648829602
    },
    {
        "content": "<p>but if the bounds are relative that means the atomic ops need to also adjust the bounds when the address is masked?</p>",
        "id": 277459370,
        "sender_full_name": "RalfJ",
        "timestamp": 1648837163
    },
    {
        "content": "<p>The hardware has to ensure that the validity bit is cleared if the change in address is large enough to change the interpretation of the bounds. The other metadata bits remain unchanged</p>",
        "id": 277460650,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648837682
    },
    {
        "content": "<p>okay sounds cool :)</p>",
        "id": 277492177,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857453
    },
    {
        "content": "<p>then I guess the next question is how to express that with LLVM intrinsics? not sure how far <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> got here</p>",
        "id": 277492188,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857467
    },
    {
        "content": "<p>I haven't started yet, but when I poked around with it before, it <em>seemed</em> to just work. That said, if I need to do some hacks in LLVM-IR I'm not bothered by that</p>",
        "id": 277492256,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648857517
    },
    {
        "content": "<p>(well, I have my limits for how much I'll work to make this happen, if it's gonna take too long I'll just comment about why it's a mess and link to an unfinished branch or something)</p>",
        "id": 277492456,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648857657
    },
    {
        "content": "<p>But my hope is that as it's unstable, it can be imperfect and just good enough to experiment with</p>",
        "id": 277492502,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648857697
    },
    {
        "content": "<p>That said the proposed API is different now, since most things will probably just take usize/isize and be defined only to operate on the address.</p>",
        "id": 277492565,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648857726
    },
    {
        "content": "<p>e.g. the outcome of the discussion from earlier in this thread.</p>",
        "id": 277492573,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648857736
    },
    {
        "content": "<p>Actually parking_lot uses <code>fetch_sub</code> to clear a bit since that optimizes better on x86 (x86 has atomic add/sub but needs a cmpxchg loop for and/or/xor). I did that for <code>WordLock::unlock</code> but forgot to do it when releasing the queue lock.</p>",
        "id": 278054752,
        "sender_full_name": "Amanieu",
        "timestamp": 1649264463
    },
    {
        "content": "<p>conceptually fetch_add and fetch_sub on AtomicPtr make a lot more sense than the bitwise ops anyway -- they correspond wrapping_offset, basically, whereas we dont even have the bitops for non-atomic pointers</p>",
        "id": 278067624,
        "sender_full_name": "RalfJ",
        "timestamp": 1649270232
    },
    {
        "content": "<p>Not in this case though: we're not using <code>fetch_sub</code> to subtract a multiple of the size of the pointed type. We're using it to clear a tag bit in the low (alignment) bits of the pointer value.</p>",
        "id": 278068147,
        "sender_full_name": "Amanieu",
        "timestamp": 1649270507
    },
    {
        "content": "<p>yeah but that's still just like <code>wrapping_offset</code>?</p>",
        "id": 278070065,
        "sender_full_name": "RalfJ",
        "timestamp": 1649271441
    },
    {
        "content": "<p>No, <code>wrapping_offset</code> still multiplies the offset by <code>size_of::&lt;T&gt;</code>. I want to clear a tag bit (bit 0) when <code>T</code> is a large struct with an alignment of at least 4.</p>",
        "id": 278070355,
        "sender_full_name": "Amanieu",
        "timestamp": 1649271573
    },
    {
        "content": "<p>ah sorry yes I was thinking of <code>wrapping_offset_bytes</code></p>",
        "id": 278073407,
        "sender_full_name": "RalfJ",
        "timestamp": 1649273021
    },
    {
        "content": "<p>Yes that would work.</p>",
        "id": 278073729,
        "sender_full_name": "Amanieu",
        "timestamp": 1649273185
    }
]