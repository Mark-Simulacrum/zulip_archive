[
    {
        "content": "<p>I see there are new docs on the raw ref macros: <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field\">https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</a></p>\n<p>Is this really safe? I assumed that the subexpression <code>(*ptr)</code> is instant UB if the data behind ptr is uninitialized.<br>\nMiri even says  that my assumption is correct in isolation: <a href=\"https://play.rust-lang.org/?gist=d211dc58740ce93d458f4f0527eab6a3\">https://play.rust-lang.org/?gist=d211dc58740ce93d458f4f0527eab6a3</a></p>\n<p>So is there some magic here because of the raw ref around it? I assumed that <code>&amp;raw (*ptr).list</code> is equivalent to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">raw_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">list</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now if there is some magic here, it definitely solves a lot of problems (initializing by field, getting a pointer to a field without going through an intermediate reference(from a pointer to a struct), and for <code>offset_of!</code> macros).<br>\nbut A. I find it confusing. B. If it's fine then the deref there shouldn't require an unsafe block.</p>",
        "id": 232188413,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1616960721
    },
    {
        "content": "<p>I assume you mean</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">raw_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">).</span><span class=\"n\">list</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>? (Assuming that <code>ptr: *const Foo</code>.)</p>",
        "id": 232190161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616962509
    },
    {
        "content": "<p>Even so, this is not true; the whole point of raw-ref syntax is that we don't create any temporary references to subpaths in the place expression</p>",
        "id": 232190264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616962610
    },
    {
        "content": "<p>The \"magic\" is that the whole expression <code>&amp;raw (*a).list</code> is a single operation; MIR (and LLVM!) directly has an instruction for getting a subpart of a data structure given by a number of dereferences and array accesses</p>",
        "id": 232190377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616962719
    },
    {
        "content": "<p>So it's a single expression, ha.<br>\nis nesting derefs there also single expression? (e.g. <code>&amp;raw (*(*ptr).field).inner</code>)</p>\n<p>and shouldn't this operation be safe?</p>",
        "id": 232198864,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1616971847
    },
    {
        "content": "<p>It is a single expression (IIRC), but the computation would still need to read memory at <code>(*ptr).field</code> in order to construct the place, so I think that is not safe</p>",
        "id": 232199643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616972676
    },
    {
        "content": "<p>although it's possible that <code>let _ = (*(*ptr).field).inner;</code> would be safe</p>",
        "id": 232199734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616972766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232199643\">said</a>:</p>\n<blockquote>\n<p>It is a single expression (IIRC), but the computation would still need to read memory at <code>(*ptr).field</code> in order to construct the place, so I think that is not safe</p>\n</blockquote>\n<p>that means that <code>&amp;raw const (*ptr::null::&lt;A&gt;()).field</code> isn't valid?<br>\nalso, if there's an actual read then the field by field initialization isn't safe?</p>",
        "id": 232237782,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617008812
    },
    {
        "content": "<p>No, that's fine, it's only when you have 2+ layers of dereferencing that you have a problem, essentially because <code>*p</code> is an operation that turns a value into a place, so you need to insert a <code>place2value</code> in <code>&amp;raw **p</code>, to convert the place <code>*p</code> into a value, so that <code>**p</code> can be a place whose address is taken with <code>&amp;raw **p</code>. The <code>place2value(*p)</code> needs to actually read memory at the location <code>p</code>, so it can fail, but even if <code>*p</code> is null <code>&amp;raw **p</code> would make sense.</p>",
        "id": 232239465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617009743
    },
    {
        "content": "<p>An alternative notation would take as primitives the operations <code>p.field() := &amp;raw (*p).field</code> (offsetting a pointer to a subfield, always safe) and <code>p.deref() := place2value(*p)</code> (read memory at a pointer location, can cause UB), in which case <code>&amp;raw (*ptr).field</code> is <code>ptr.field()</code>, which is safe, while <code>let x = *(*ptr).field</code> is <code>let x = ptr.field().deref()</code> (not safe) and <code>&amp;raw (*(*ptr).field).inner</code> is <code>ptr.field().deref().inner()</code> (which is not safe because of the <code>deref</code>).</p>",
        "id": 232240105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617010131
    },
    {
        "content": "<p>damn this is confusing.</p>\n<p>if this is the syntax we stay with then at least differentiating to safe/unsafe like you showed will help a lot in avoiding accidental UB here</p>",
        "id": 232290965,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617033284
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>No, that's fine,</p>\n</blockquote>\n<p>No it's not! See <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">https://doc.rust-lang.org/reference/behavior-considered-undefined.html</a> -- <code>*ptr</code> is UB when ptr dangles or is unaligned, even as part of <code>addr_of!((*ptr).field)</code>.</p>",
        "id": 232561959,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183483
    },
    {
        "content": "<p>These are the current rules, anyway. I <a href=\"#narrow/stream/213817-t-lang/topic/Alignment.20and.20raw.20pointer.20deref\">hope we can change them</a> but it is not yet clear what we should change them to.</p>",
        "id": 232562053,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183534
    },
    {
        "content": "<p>However, it <em>is</em> okay to do these things when the data is <em>uninitialized</em> -- the initialization requirement only comes into play when constructing an actual value of the type, as in <code>let _val = *ptr;</code>.</p>",
        "id": 232562132,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183594
    },
    {
        "content": "<p>However your original equivalence certainly doesn't hold, <span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span>. It's more like, <code>&amp;expr</code> is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"o\">&amp;*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"c1\">// cast raw-ptr to reference</span>\n</code></pre></div>",
        "id": 232562437,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183770
    },
    {
        "content": "<p>the second step, casting to a reference, introduces some extra restrictions, like <code>ptr</code> having to be aligned and pointing to valid (initialized) data</p>",
        "id": 232562501,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183820
    },
    {
        "content": "<p><code>addr_of!</code> is a way to get rid of those restrictions</p>",
        "id": 232562522,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183836
    },
    {
        "content": "<p>but at least so far, this has no effect on the rules for <code>*</code> (ptr deref)</p>",
        "id": 232562567,
        "sender_full_name": "RalfJ",
        "timestamp": 1617183845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232562567\">said</a>:</p>\n<blockquote>\n<p>but at least so far, this has no effect on the rules for <code>*</code> (ptr deref)</p>\n</blockquote>\n<p>But it looks like it does?<br>\n<code>let _v_field = &amp;raw (*ptr).list;</code> // this is valid even if <code>ptr</code> points at uninitialized values.<br>\n<code>let _v = *ptr</code>  // this isn't valid as it reads from uninitialized memory.</p>\n<p>so the expression <code>(*ptr)</code> has different effect if it's part of a <code>&amp;raw</code> expression and when it's not part of a raw expression</p>",
        "id": 232573584,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617189930
    },
    {
        "content": "<p>That's a property of the read, not the dereference, though.</p>",
        "id": 232575404,
        "sender_full_name": "Connor Horman",
        "timestamp": 1617190918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232575404\">said</a>:</p>\n<blockquote>\n<p>That's a property of the read, not the dereference, though.</p>\n</blockquote>\n<p>I thought that a dereference means a read (except for the <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/261\">weirdness</a> of <code>let _ = *ptr</code>)</p>",
        "id": 232593650,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617198383
    },
    {
        "content": "<p>I don't know for rust specifically, but with my background in C and C++, to me, dereference means the actual indirection, IE. the <code>*ptr</code> in <code>let _v = *ptr;</code>. The read is the place-to-value conversion (or lvalue-to-rvalue conversion, in C++), but the dereference operation produces said place (however, <code>let _ = *ptr;</code> makes that definition wierd, as you said).</p>",
        "id": 232597821,
        "sender_full_name": "Connor Horman",
        "timestamp": 1617199831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232561959\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> </p>\n<blockquote>\n<p>No, that's fine,</p>\n</blockquote>\n<p>No it's not! See <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">https://doc.rust-lang.org/reference/behavior-considered-undefined.html</a> -- <code>*ptr</code> is UB when ptr dangles or is unaligned, even as part of <code>addr_of!((*ptr).field)</code>.</p>\n</blockquote>\n<p>Wasn't this exactly the behavior we were talking about <a href=\"#narrow/stream/213817-t-lang/topic/Alignment.20and.20raw.20pointer.20deref/near/232154596\">in the other thread</a>? Maybe it's undefined right now but I thought we were in agreement that this should be a safe operation, equivalent to (wrapping) <code>ptr + offset_of!(field)</code> on the underlying integers</p>",
        "id": 232608602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617203589
    },
    {
        "content": "<p>Otherwise it is impossible to work with packed structs</p>",
        "id": 232608680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617203626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232575404\">said</a>:</p>\n<blockquote>\n<p>That's a property of the read, not the dereference, though.</p>\n</blockquote>\n<p>exactly. Or rather, I'd say (as you also clarified later) it's a property of the place-to-value coercion (which involves reading the contents of the place and making it a value).<br>\nthis <em>constructs</em> a value, that hence has to satisfy the validity invariant of its type.</p>",
        "id": 232643866,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232593650\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232575404\">said</a>:</p>\n<blockquote>\n<p>That's a property of the read, not the dereference, though.</p>\n</blockquote>\n<p>I thought that a dereference means a read (except for the <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/261\">weirdness</a> of <code>let _ = *ptr</code>)</p>\n</blockquote>\n<p>no, in <code>&amp;*ptr</code>, a deref certainly does not read anything from memory</p>",
        "id": 232643914,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216275
    },
    {
        "content": "<blockquote>\n<p>Maybe it's undefined right now but I thought we were in agreement that this should be a safe operation, equivalent to (wrapping) ptr + offset_of!(field) on the underlying integers</p>\n</blockquote>\n<p>So first of all, if it's UB right now then I wouldn't tell people that it's valid. ;)<br>\nAnd secondly, I don't think we have that agreement. the main thrust is the other thread was that <code>addr_of!((*ptr).field)</code> should be equivalent to <code>add_no_overflow(ptr, field_offset)</code>, i.e., it would still be unsafe and cause UB in case of overflow.</p>",
        "id": 232644250,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232608680\">said</a>:</p>\n<blockquote>\n<p>Otherwise it is impossible to work with packed structs</p>\n</blockquote>\n<p>I don't think that is true at all, though it depends on what exactly you mean. however, we could fix packed structs entirely by saying that <code>addr_of!((*ptr).field)</code> is equivalent to <code>ptr.offset_bytes(field_offset)</code>. This would still be unsafe.</p>",
        "id": 232644565,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216547
    },
    {
        "content": "<blockquote>\n<p>if it's UB right now then I wouldn't tell people that it's valid. :)</p>\n</blockquote>\n<p>Well, rust doesn't really have a spec yet, so I generally assume everything is hand-wavy unless it is explicitly called out. As for the overflow thing, you are right, I misremembered that aspect. (But I think overflowing pointers is a relatively rare and unimportant phenomenon, so I don't mind any particular solution to it.)</p>",
        "id": 232644682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216601
    },
    {
        "content": "<p>so to summarize, we have 4 possible sets of rules for <code>addr_of!((*ptr).field)</code>:</p>\n<ol>\n<li>the current official rules: <code>ptr</code> must be aligned and the offset must be inbounds (like with the <code>offset</code> Rust method)</li>\n<li>the currently <em>implemented</em> rules, i.e. what we tell LLVM: the offset must be inbounds (but <code>ptr</code> might be misaligned)</li>\n<li>the version that I think has most thrust behind it: the offset must not overflow (but <code>ptr</code> might dangle or be misaligned)</li>\n<li>the safe version: this is just overflowing addition and never UB</li>\n</ol>",
        "id": 232644870,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216654
    },
    {
        "content": "<p>there is also \"0. the pointer must be valid, aligned and dereferenceable\", which I don't think we want but seems like what C expects</p>",
        "id": 232645071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232644682\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>if it's UB right now then I wouldn't tell people that it's valid. :)</p>\n</blockquote>\n<p>Well, rust doesn't really have a spec yet, so I generally assume everything is hand-wavy unless it is explicitly called out. As for the overflow thing, you are right, I misremembered that aspect. (But I think overflowing pointers is a relatively rare and unimportant phenomenon, so I don't mind any particular solution to it.)</p>\n</blockquote>\n<p><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">https://doc.rust-lang.org/reference/behavior-considered-undefined.html</a> is pretty clear in this regard. and the reason it is clear that because we dont have a spec, we need wiggle-room to be able to write one. by telling people to do things that are currently UB, you restrict the design space for a possible spec -- you basically preempt a decision the lang team hasn't even made yet. there's a reason the decision hasn't been made yet: the tradeoffs are complicated. so let's take our time for these rules and not make it impossible to make certain decisions by telling people to do things that we might end up making UB.</p>",
        "id": 232645140,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232645071\">said</a>:</p>\n<blockquote>\n<p>there is also \"0. the pointer must be valid, aligned and dereferenceable\", which I don't think we want but seems like what C expects</p>\n</blockquote>\n<p>what does \"valid\" mean? I think C does 1 or 2</p>",
        "id": 232645180,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216788
    },
    {
        "content": "<p>pointing to a live allocation</p>",
        "id": 232645206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216805
    },
    {
        "content": "<p>that's dereferencable</p>",
        "id": 232645218,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216812
    },
    {
        "content": "<p>so its part of 1</p>",
        "id": 232645227,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216820
    },
    {
        "content": "<p>if the offset is inbounds then the ptr is clearly dereferencable</p>",
        "id": 232645240,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216828
    },
    {
        "content": "<p>ah, gotcha</p>",
        "id": 232645261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216842
    },
    {
        "content": "<p>By the way, I read \"dereferencing\" as <code>place2value(*ptr)</code> (unlike connor), is this term defined anywhere? That's part of why I think we disagree on the reading of what has been decreed UB on that page</p>",
        "id": 232645474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216923
    },
    {
        "content": "<p>Basically I think we should make 2 official because I see very little benefit from the extra UB that 1 has, and it still leaves us free to go with 3 or 4 later. But until it was actually made official I'd recommend against exploiting that. Even under 2, <code>&amp;raw const (*ptr::null::&lt;A&gt;()).field</code> (which the question was about) is UB.</p>",
        "id": 232645549,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216951
    },
    {
        "content": "<p>If <code>*ptr</code> itself (the place) is already UB, then I don't see how <code>addr_of!((*ptr).field)</code> can avoid being UB as well</p>",
        "id": 232645642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232645474\">said</a>:</p>\n<blockquote>\n<p>By the way, I read \"dereferencing\" as <code>place2value(*ptr)</code> (unlike connor), is this term defined anywhere? That's part of why I think we disagree on the reading of what has been decreed UB on that page</p>\n</blockquote>\n<p>the term is awfully ambiguous, I agree. :/ that's why I wrote in the reference that it specifically refers to the <code>*</code> operator</p>",
        "id": 232645647,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216979
    },
    {
        "content": "<p>That's still ambiguous though</p>",
        "id": 232645674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617216990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232645642\">said</a>:</p>\n<blockquote>\n<p>If <code>*ptr</code> itself (the place) is already UB, then I don't see how <code>addr_of!((*ptr).field)</code> can avoid being UB as well</p>\n</blockquote>\n<p>indeed, to move to 2 we have to change the rules</p>",
        "id": 232645684,
        "sender_full_name": "RalfJ",
        "timestamp": 1617216997
    },
    {
        "content": "<p>because <code>place2value</code> has no surface syntax</p>",
        "id": 232645707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232645674\">said</a>:</p>\n<blockquote>\n<p>That's still ambiguous though</p>\n</blockquote>\n<p>I don't think so. when I talk about addition it would be unreasonable to assume I meant <code>(a+b)*c</code>. So likewise, when I talk about <code>*</code>, why would you assume I talk about <code>*</code> <em>followed by another operation</em>?</p>",
        "id": 232645764,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217040
    },
    {
        "content": "<p>so reasonable people will disagree on whether <code>*ptr</code> means the place or the value</p>",
        "id": 232645769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217046
    },
    {
        "content": "<p>because it means both</p>",
        "id": 232645788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217053
    },
    {
        "content": "<p>hm</p>",
        "id": 232645801,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217059
    },
    {
        "content": "<p>okay I will try to clarify this</p>",
        "id": 232645941,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217106
    },
    {
        "content": "<p>If <code>place2value</code> was an actual thing people wrote then I agree it would be a lot less ambiguous, but you have to lead with that and explain it, because I think a lot of people don't understand what lvalues or places are</p>",
        "id": 232646013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217142
    },
    {
        "content": "<p>I propose to change the wording to something like</p>\n<blockquote>\n<p>Dereferencing (i.e., the <code>*expr</code> <em>place</em> expression) a dangling or unaligned raw pointer.</p>\n</blockquote>\n<p>would that help?</p>",
        "id": 232646288,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217245
    },
    {
        "content": "<p>yes we certainly have to properly explain place2value at some point; that's what's blocking me from proposing the move to (2)</p>",
        "id": 232646409,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217278
    },
    {
        "content": "<p>but I don't know how much work that would be and I currently dont have the time to figure that out^^</p>",
        "id": 232646458,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217303
    },
    {
        "content": "<p>Yes that would be better, although I would rather that not be UB :/</p>",
        "id": 232646487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217314
    },
    {
        "content": "<p>but that's just me</p>",
        "id": 232646505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217319
    },
    {
        "content": "<p>Is it legal (as a validity property) to have a dangling reference? Because I think the compiler can insert <code>&amp;*foo_ref</code> reborrows where the user wrote <code>foo_ref</code>, and the latter can be UB if <code>foo_ref</code> is dangling if the place <code>*foo_ref</code> is already UB</p>",
        "id": 232646929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232646487\">said</a>:</p>\n<blockquote>\n<p>Yes that would be better, although I would rather that not be UB :/</p>\n</blockquote>\n<p>sure, same here. but that's more than an editorial change. ;)</p>",
        "id": 232646970,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217485
    },
    {
        "content": "<blockquote>\n<p>Is it legal (as a validity property) to have a dangling reference?</p>\n</blockquote>\n<p>no:</p>\n<blockquote>\n<p>The following values are invalid (at their respective type): <br>\n[...]<br>\nA reference or Box&lt;T&gt; that is dangling, unaligned, or points to an invalid value.</p>\n</blockquote>",
        "id": 232647057,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217529
    },
    {
        "content": "<p>I want to change this to just</p>\n<blockquote>\n<p>A reference or Box&lt;T&gt; that is dangling, unaligned, or points to an uninhabited type (i.e. a type with no valid value inhabiting it)</p>\n</blockquote>\n<p>but that's a whole separate discussion ;)</p>",
        "id": 232647119,
        "sender_full_name": "RalfJ",
        "timestamp": 1617217556
    },
    {
        "content": "<p>I guess you can't do the same with pointers unless you use <code>&amp;raw *foo_ptr</code> or <code>addr_of!(*foo_ptr)</code></p>",
        "id": 232647287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617217618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232646487\">said</a>:</p>\n<blockquote>\n<p>Yes that would be better, although I would rather that not be UB :/</p>\n</blockquote>\n<p>Yeah, I'm still confused on what exactly is and isn't UB here, and if we can somehow make <code>&amp;raw (*null::&lt;A&gt;()).field</code> safe then the compiler will help me know i'm not doing anything UB there.</p>\n<p>an example of where I'm confused is on a more complex operation like <code>&amp;raw (*(*ptr).field).inner_field</code> do both dereferences need to follow rule 1 currently? or if <code>field</code> points to uninit data it is UB? (a value read IIUC).<br>\nor maybe it should be <code>&amp;raw (*(&amp;raw (*ptr).field)).inner_field</code>?</p>",
        "id": 232736764,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617273902
    },
    {
        "content": "<p>Irrespective of whether it is UB, it's not even really possible to ascribe a semantic meaning to <code>&amp;raw (*(*ptr).field).inner_field</code> other than \"a garbage pointer possibly following an access to possibly read protected memory\" if <code>ptr</code> points to deallocated or otherwise invalid memory</p>",
        "id": 232738966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617275095
    },
    {
        "content": "<p>Which is to say, this basically has to be UB</p>",
        "id": 232739204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617275247
    },
    {
        "content": "<p>In the case of <code>&amp;raw (*ptr).field</code>, there is at least a reasonable candidate for what it could mean when <code>ptr</code> is not valid, so we have options here</p>",
        "id": 232739374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617275333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232647287\">said</a>:</p>\n<blockquote>\n<p>I guess you can't do the same with pointers unless you use <code>&amp;raw *foo_ptr</code> or <code>addr_of!(*foo_ptr)</code></p>\n</blockquote>\n<p>can't do what with pointers?</p>",
        "id": 232921471,
        "sender_full_name": "RalfJ",
        "timestamp": 1617381882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232736764\">said</a>:</p>\n<blockquote>\n<p>Yeah, I'm still confused on what exactly is and isn't UB here, and if we can somehow make <code>&amp;raw (*null::&lt;A&gt;()).field</code> safe then the compiler will help me know i'm not doing anything UB there.</p>\n</blockquote>\n<p>currently <code>&amp;raw (*null::&lt;A&gt;()).field</code> is always UB</p>",
        "id": 232921516,
        "sender_full_name": "RalfJ",
        "timestamp": 1617381908
    },
    {
        "content": "<p>automatic reborrowing is not a thing that happens for pointers</p>",
        "id": 232921520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617381909
    },
    {
        "content": "<p>but I would really like <code>&amp;raw *foo_ptr</code> to be an identity function on pointers</p>",
        "id": 232921560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617381927
    },
    {
        "content": "<p>the confusion arises because in this discussion we are mixing \"advice to a users trying to understand and follow the current Rust rules\" and \"arguments for how and why the Rust rules could or should be changed in the future\"</p>",
        "id": 232921584,
        "sender_full_name": "RalfJ",
        "timestamp": 1617381938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> if you want to write UB-free code, ignore all the discussion about hypothetical future changes to what is UB, and focus on</p>\n<blockquote>\n<p>Dereferencing (i.e., the <code>*expr</code> place expression) a dangling or unaligned raw pointer is UB.</p>\n</blockquote>",
        "id": 232921681,
        "sender_full_name": "RalfJ",
        "timestamp": 1617381979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232921560\">said</a>:</p>\n<blockquote>\n<p>but I would really like <code>&amp;raw *foo_ptr</code> to be an identity function on pointers</p>\n</blockquote>\n<p>in particular, a <em>total</em> identity function, not a partial one?</p>",
        "id": 232921726,
        "sender_full_name": "RalfJ",
        "timestamp": 1617382007
    },
    {
        "content": "<p>yes, i.e. it does not assert validity of <code>foo_ptr</code></p>",
        "id": 232921753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617382024
    },
    {
        "content": "<p>yes</p>",
        "id": 232921781,
        "sender_full_name": "RalfJ",
        "timestamp": 1617382036
    },
    {
        "content": "<p>that seems like a linux-kernel-bug style footgun</p>",
        "id": 232921804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617382040
    },
    {
        "content": "<p>I agree that's a nice property to have; but e.g. <span class=\"user-mention\" data-user-id=\"294290\">@NeoRaider</span> has expressed the exact opposite preference</p>",
        "id": 232921841,
        "sender_full_name": "RalfJ",
        "timestamp": 1617382058
    },
    {
        "content": "<p>So clearly more discussion needs to be had before we can tell people to write such code :)</p>",
        "id": 232921923,
        "sender_full_name": "RalfJ",
        "timestamp": 1617382083
    },
    {
        "content": "<p>true, true</p>",
        "id": 232921952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617382091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232921681\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> if you want to write UB-free code, ignore all the discussion about hypothetical future changes to what is UB, and focus on</p>\n<blockquote>\n<p>Dereferencing (i.e., the <code>*expr</code> place expression) a dangling or unaligned raw pointer is UB.</p>\n</blockquote>\n</blockquote>\n<p>So the only difference(in the dereference, not the reborrowing) is that the dereference doesn't require the data to be initialized?</p>",
        "id": 232959465,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617402639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232738966\">said</a>:</p>\n<blockquote>\n<p>Irrespective of whether it is UB, it's not even really possible to ascribe a semantic meaning to <code>&amp;raw (*(*ptr).field).inner_field</code> other than \"a garbage pointer possibly following an access to possibly read protected memory\" if <code>ptr</code> points to deallocated or otherwise invalid memory</p>\n</blockquote>\n<p>Couldn't it be theoretically translated to <code>ptr as usize + offset_of!(OuterType.field) + offset_of!(InnerType.field)</code>? (that's weaker semantics than C afaik)</p>",
        "id": 232959570,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617402725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232921584\">said</a>:</p>\n<blockquote>\n<p>the confusion arises because in this discussion we are mixing \"advice to a users trying to understand and follow the current Rust rules\" and \"arguments for how and why the Rust rules could or should be changed in the future\"</p>\n</blockquote>\n<p>yeah that's on me, I'm trying to both understand how to avoid UB right now, and also figure out if we can make it easier and less restrictive</p>",
        "id": 232959603,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1617402769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232959570\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232738966\">said</a>:</p>\n<blockquote>\n<p>Irrespective of whether it is UB, it's not even really possible to ascribe a semantic meaning to <code>&amp;raw (*(*ptr).field).inner_field</code> other than \"a garbage pointer possibly following an access to possibly read protected memory\" if <code>ptr</code> points to deallocated or otherwise invalid memory</p>\n</blockquote>\n<p>Couldn't it be theoretically translated to <code>ptr as usize + offset_of!(OuterType.field) + offset_of!(InnerType.field)</code>? (that's weaker semantics than C afaik)</p>\n</blockquote>\n<p>That would be <code>&amp;raw (*ptr).field.inner_field</code>, and I agree that this should be defined (although as Ralf has pointed out, it isn't according to the current wording in the reference)</p>",
        "id": 232961725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617404521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232959465\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232921681\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> if you want to write UB-free code, ignore all the discussion about hypothetical future changes to what is UB, and focus on</p>\n<blockquote>\n<p>Dereferencing (i.e., the <code>*expr</code> place expression) a dangling or unaligned raw pointer is UB.</p>\n</blockquote>\n</blockquote>\n<p>So the only difference(in the dereference, not the reborrowing) is that the dereference doesn't require the data to be initialized?</p>\n</blockquote>\n<p>yes, basically</p>",
        "id": 232991192,
        "sender_full_name": "RalfJ",
        "timestamp": 1617438372
    },
    {
        "content": "<p>Wait, does <code>&amp;raw (*outer).inner.field</code> create an intermediate reference even when no <code>Deref</code> shenanigans are involved?</p>",
        "id": 232999480,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617448740
    },
    {
        "content": "<p>I'd expect that to be equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">outer</span><span class=\"p\">).</span><span class=\"n\">inner</span><span class=\"p\">)).</span><span class=\"n\">field</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 232999562,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617448816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232999480\">said</a>:</p>\n<blockquote>\n<p>Wait, does <code>&amp;raw (*outer).inner.field</code> create an intermediate reference even when no <code>Deref</code> shenanigans are involved?</p>\n</blockquote>\n<p>it does not</p>",
        "id": 233000094,
        "sender_full_name": "RalfJ",
        "timestamp": 1617449438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232999562\">said</a>:</p>\n<blockquote>\n<p>I'd expect that to be equivalent to</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">outer</span><span class=\"p\">).</span><span class=\"n\">inner</span><span class=\"p\">)).</span><span class=\"n\">field</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>wait... what are your types here? now there are nested pointers so I am confused.^^</p>",
        "id": 233000105,
        "sender_full_name": "RalfJ",
        "timestamp": 1617449466
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232644870\">here</a> for a summary of the previous discussion</p>",
        "id": 233000126,
        "sender_full_name": "RalfJ",
        "timestamp": 1617449522
    },
    {
        "content": "<p>The types would be plain flat structural records (that's what I meant by lack of <code>Deref</code>, although I should have mentioned lack of references too)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Outer</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inner</span>: <span class=\"nc\">Inner</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Inner</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span>: <span class=\"nc\">Field</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">storage</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"n\">Outer</span><span class=\"o\">&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">outer</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Outer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">storage</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/233000094\">said</a>:</p>\n<blockquote>\n<p>it does not</p>\n</blockquote>\n<p>Good, that's what I'd have expected, but I got confused because of:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232961725\">said</a>:</p>\n<blockquote>\n<p>(although as Ralf has pointed out, [<code>&amp;raw (*ptr).field.inner_field</code>] isn't [[well] defined] according to the current wording in the reference)</p>\n</blockquote>",
        "id": 233002293,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617451970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> we were talking about two different situations above: one where there's a ptr to a struct containing a struct, and one where there's a ptr to a struct containing a <em>ptr to</em> a struct</p>",
        "id": 233002591,
        "sender_full_name": "RalfJ",
        "timestamp": 1617452287
    },
    {
        "content": "<p>I think you mixed up responses from the two different discussions</p>",
        "id": 233002602,
        "sender_full_name": "RalfJ",
        "timestamp": 1617452295
    },
    {
        "content": "<blockquote>\n<p>Good, that's what I'd have expected, but I got confused because of:</p>\n</blockquote>\n<p>again, <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/raw.20ref.20semantics/near/232644870\">see here</a>. there are situations where this is not well-defined.</p>",
        "id": 233002636,
        "sender_full_name": "RalfJ",
        "timestamp": 1617452347
    },
    {
        "content": "<p>but sadly this thread is full of not-self-contained examples so just reading any part of it is extremely confusing^^</p>",
        "id": 233002650,
        "sender_full_name": "RalfJ",
        "timestamp": 1617452362
    },
    {
        "content": "<p>Yes yes, I was mainly focusing on nested place access (but without extra indirection); as I mentioned, I wanted to make sure the equivalent held (actually, it may not hold if <code>field</code> is unaligned (packed struct) if we keep the alignment requirement <span aria-label=\"warning\" class=\"emoji emoji-26a0\" role=\"img\" title=\"warning\">:warning:</span>)</p>",
        "id": 233002873,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617452606
    },
    {
        "content": "<p>Actually, this last point changes things.</p>\n<p>EDIT: I follow this point on the appropriate thread; <a href=\"#narrow/stream/213817-t-lang/topic/Alignment.20and.20raw.20pointer.20deref/near/233003780\">link to my comment with the code snippet</a></p>",
        "id": 233003187,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617452935
    },
    {
        "content": "<p>That last UB is why I started <a href=\"#narrow/stream/213817-t-lang/topic/Alignment.20and.20raw.20pointer.20deref\">this thread</a></p>",
        "id": 233003312,
        "sender_full_name": "RalfJ",
        "timestamp": 1617453062
    },
    {
        "content": "<p>but currently it is indeed UB</p>",
        "id": 233003315,
        "sender_full_name": "RalfJ",
        "timestamp": 1617453067
    },
    {
        "content": "<p>the first branch is indeed okay</p>",
        "id": 233003329,
        "sender_full_name": "RalfJ",
        "timestamp": 1617453087
    },
    {
        "content": "<p>Yeah, I am mixing a bit these two threads since there is an overlap <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. <del>I'll move my post there.</del> I can't  move cross-streams <span aria-label=\"disappointed\" class=\"emoji emoji-1f61e\" role=\"img\" title=\"disappointed\">:disappointed:</span>, so I have manually cut-and-pasted it.</p>",
        "id": 233003586,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617453304
    },
    {
        "content": "<p>yeah the two theads were created without much coordination, mostly by coincidence^^</p>",
        "id": 233003909,
        "sender_full_name": "RalfJ",
        "timestamp": 1617453642
    }
]