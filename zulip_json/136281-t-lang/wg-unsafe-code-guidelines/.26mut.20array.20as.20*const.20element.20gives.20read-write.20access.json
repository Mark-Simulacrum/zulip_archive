[
    {
        "content": "<p>I was exploring the array-pointer cast, and noted something interesting.<br>\nIt is currently not possible to directly cast <code>&amp;mut [T;N] as *const T</code>, as is the same with <code>&amp;mut T as *const T</code>. However, both casts are valid because of an implicit conversion. In the latter case, this is an implicit reborrow as shared, which denies write access to the value. However, the former contains a reborrow as raw mut, which does not.<br>\nSee: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=61f1899effe5bc5b5e244dfcb0366835\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=61f1899effe5bc5b5e244dfcb0366835</a> (array case) vs. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d27c7e9218693952aa104db6e1cf9412\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d27c7e9218693952aa104db6e1cf9412</a> (non-array) case.</p>\n<p>This seems odd, if not a potential footgun. It may be useful to clarify which of these behaviours is the correct one for both: does it reborrow as <code>*mut T</code> preserving write access, or does it reborrow as <code>&amp;T</code> denying it.</p>",
        "id": 269283172,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643128431
    },
    {
        "content": "<p>oh interesting... I guess this is some quirk in how the MIR is generated</p>",
        "id": 269467207,
        "sender_full_name": "RalfJ",
        "timestamp": 1643225046
    },
    {
        "content": "<p>the array version does</p>\n<div class=\"codehilite\"><pre><span></span><code>        _4 = &amp;mut _5;                    // scope 1 at src/main.rs:3:29: 3:40\n        _3 = &amp;raw mut (*_4);             // scope 1 at src/main.rs:3:29: 3:40\n</code></pre></div>\n<p>while the other one does</p>\n<div class=\"codehilite\"><pre><span></span><code>       _3 = &amp;mut _4;                    // scope 1 at src/main.rs:3:29: 3:38\n        _2 = &amp;raw const (*_3);           // scope 1 at src/main.rs:3:29: 3:38\n</code></pre></div>\n<p>I am not a MIR building expert (I mostly take MIR as given and then do my best to define a precise semantics starting there), so... no idea why this happens, but indeed this should probably be changed one way or the other^^</p>",
        "id": 269467451,
        "sender_full_name": "RalfJ",
        "timestamp": 1643225153
    },
    {
        "content": "<p>Simply because it's the only non-coercion cast allowed on references, so it handled by different code.</p>\n<p>The exact function is <code>check_ref_cast</code> in rustc_typeck/src/check/cast.rs</p>",
        "id": 269504480,
        "sender_full_name": "spunit262",
        "timestamp": 1643243282
    },
    {
        "content": "<p>Sounds like a fun thing for me to codegen. TBH, it seems easier to just derive into equivalent of <code>*const</code> from my perspective, then to do any sort of fancy tricks that makes either of them UB (I may get to handle that <em>soon</em> even).</p>",
        "id": 269504938,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643243613
    },
    {
        "content": "<p>Don't they both result in different, disjoint sets of UB? You can't write through one but you can alias the other one</p>",
        "id": 269510077,
        "sender_full_name": "Nick12",
        "timestamp": 1643244096
    },
    {
        "content": "<p>you can alias <code>*mut</code> pointers</p>",
        "id": 269510193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643244169
    }
]