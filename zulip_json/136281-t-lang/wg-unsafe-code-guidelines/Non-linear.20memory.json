[
    {
        "content": "<p>Many embedded systems have a memory system that's non-linear[^1], and it is also possible to construct such memory with an MMU on contemporary consumer-oriented systems as well. In systems following such model it seems to me like it might be possible to obtain mutable references without it immediately looking wrong (<code>e.g. std::slice::from_raw_parts_mut(0x2000_0000, 0x2000_0001): &amp;mut [u8]</code> would alias the byte at first and last element.)</p>\n<p>While this is clearly invalid, I haven't seen this brought up anywhere so far, hence my ramblings here ^^</p>\n<p>[^1]: The MCUs I have worked with seemed to largely just mask out bits of the address when accessing memory, allowing to access the same memory at e.g. address <code>0</code>, <code>0x2000_0000</code>, <code>0x4000_0000</code>, etc.</p>",
        "id": 275980824,
        "sender_full_name": "nagisa",
        "timestamp": 1647800720
    },
    {
        "content": "<p>Unless memory regions are overlapping, I don't think that it's <em>per se</em> unsound to have non-linear memory.</p>",
        "id": 275980903,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647800872
    },
    {
        "content": "<p>It's unsound to create a reference to memory that has \"holes\" (like the SNES's MMIO registers, which fall out into open bus) or that can alias a region of memory via another address that there is also a reference to (or is otherwise accessed).</p>",
        "id": 275980980,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647800963
    },
    {
        "content": "<p>On (some?) ARM MCUs they are overlapping (address space acts as a ring)</p>",
        "id": 275986645,
        "sender_full_name": "nagisa",
        "timestamp": 1647808930
    },
    {
        "content": "<p>The reason this topic got pulled into my L1 cache at all, was because I was thinking about ways for a WebAssembly runtime to avoid memory access checks, and I kinda remembered MCUs having this wrapping address space behaviour.</p>",
        "id": 275986739,
        "sender_full_name": "nagisa",
        "timestamp": 1647809091
    },
    {
        "content": "<p>(which turns out to be not applicable to webassembly because it does require linear memoryâ€¦, but that led me thinking about what it means for using Rust on MCUs like that)</p>",
        "id": 275986772,
        "sender_full_name": "nagisa",
        "timestamp": 1647809149
    },
    {
        "content": "<p>Is this the same as \"mirrored memory\"? Because I've encountered that before, and just tried to mostly avoid using the mirrors.</p>",
        "id": 276008630,
        "sender_full_name": "Lokathor",
        "timestamp": 1647841565
    },
    {
        "content": "<p>Yeah that would be another source of this.</p>",
        "id": 276034895,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647861078
    },
    {
        "content": "<p>an even more extreme example is some Arm MCUs have a special address region where each byte (or 32-bit word? icr) maps to a single bit in another region.</p>",
        "id": 276120967,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647900865
    }
]