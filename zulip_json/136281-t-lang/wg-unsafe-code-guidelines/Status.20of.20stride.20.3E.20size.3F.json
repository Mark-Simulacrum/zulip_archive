[
    {
        "content": "<p>So I have had the \"pleasure\" in recent memory of being in several conversations that ended up coming back to the topic of whether stride of an array could ever be greater than the array's type, pointing in particular to the possibility that structs and tuples could end up having an effective data size smaller than their alignment. Effectively dropping padding.</p>",
        "id": 278649074,
        "sender_full_name": "alercah",
        "timestamp": 1649740312
    },
    {
        "content": "<p>Is this not precluded by <code>size_of</code>'s docs, though, which explicitly <em>define</em> the size of a time as being its stride?</p>",
        "id": 278649140,
        "sender_full_name": "alercah",
        "timestamp": 1649740385
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/stable/std/mem/fn.size_of.html\">https://doc.rust-lang.org/stable/std/mem/fn.size_of.html</a></p>",
        "id": 278649144,
        "sender_full_name": "alercah",
        "timestamp": 1649740388
    },
    {
        "content": "<p>As far as I can tell, the only two paths to making stride &gt; size would be:</p>\n<ol>\n<li>Break the current contract of <code>size_of</code>, which is probably unacceptable due to stability guarantee (I have a hard time envisioning a migration path, sadly).</li>\n<li>Deprecate <code>size_of</code> as-is because it's really <code>stride_of</code>, and declare UB any code which foolishly believes it actually represents the true data size of <code>T</code></li>\n</ol>",
        "id": 278649230,
        "sender_full_name": "alercah",
        "timestamp": 1649740531
    },
    {
        "content": "<p>Note that <code>std::alloc::Layout</code> doesn't make the same mistake in its design, but when provided with a specific type in its implementation for a particular type <code>T</code> it does use <code>size_of</code>.</p>",
        "id": 278649472,
        "sender_full_name": "alercah",
        "timestamp": 1649740844
    },
    {
        "content": "<p>I would love for there to be a path to change this, but I'm not sure I see a good one.</p>",
        "id": 278649486,
        "sender_full_name": "alercah",
        "timestamp": 1649740862
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/std/array/fn.from_mut.html\">https://doc.rust-lang.org/nightly/std/array/fn.from_mut.html</a> is stable, which most directly means that said requirement has to apply for anything where you have a reference</p>",
        "id": 278650708,
        "sender_full_name": "scottmcm",
        "timestamp": 1649742543
    },
    {
        "content": "<p>As you say, changing this is effectively impossible because existing unsafe code depends on being able to read/write <code>sizeof(T)</code> bytes behind a pointer or reference to <code>T</code>.</p>",
        "id": 278650808,
        "sender_full_name": "scottmcm",
        "timestamp": 1649742614
    },
    {
        "content": "<p>The only feasible thing that we can do, I think, is have a \"sufficient copy length\" API that tells people \"well, you can copy this N-byte prefix instead of the full <code>size_of</code> for this type/value, if you want\".  (Or it could be more generally \"these subranges\", at code of a much more complex API.)</p>\n<p>Then that could be used to copy less sometimes, but one still couldn't <em>allocate</em> less, because code would always be able to copy the full <code>size_of</code>.</p>",
        "id": 278651037,
        "sender_full_name": "scottmcm",
        "timestamp": 1649742902
    },
    {
        "content": "<p>(Well, there's the \"just make all existing code invalid\" cop-out of a <code>?SizeEqualStride</code> thing, but lang really doesn't want any more of those, and I don't think saving a few bytes of padding occasionally comes anywhere close to being important enough to do it.)</p>",
        "id": 278651126,
        "sender_full_name": "scottmcm",
        "timestamp": 1649743031
    },
    {
        "content": "<p>I also don't see a reason to allow this.<br>\nThis could not be taken advantage of for <code>repr(C)</code>, so thus only <code>repr(Rust)</code>, thus it would be an implementation's choice whether to have a type with size &lt; stride, and I can't really see many implementations even having the machinery to support it, let alone utilising it.</p>",
        "id": 278678244,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649762393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Status.20of.20stride.20.3E.20size.3F/near/278651126\">said</a>:</p>\n<blockquote>\n<p>(Well, there's the \"just make all existing code invalid\" cop-out of a <code>?SizeEqualStride</code> thing, but lang really doesn't want any more of those, and I don't think saving a few bytes of padding occasionally comes anywhere close to being important enough to do it.)</p>\n</blockquote>\n<p>I also think my point makes that even more problematic, since whether or not a type satisfies the bound is not only a question of the definition of the struct, but also the implementation.</p>",
        "id": 278678344,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649762468
    },
    {
        "content": "<p>also see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/306\">https://github.com/rust-lang/unsafe-code-guidelines/issues/306</a>, <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/176\">https://github.com/rust-lang/unsafe-code-guidelines/issues/176</a></p>",
        "id": 278701088,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773941
    },
    {
        "content": "<p>I dont have a strong opinion myself, other than that I'd prefer if we made <em>some</em> proper decision on this :D</p>",
        "id": 278701128,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773958
    },
    {
        "content": "<p>One thing of note is that Swift 5's defined ABI includes a layout algorithm which distinguishes size and stride.<br>\nHowever, Swift also uses stride (min 1) when allocating and laying out <code>Array</code>(<code>Vec</code>) elements.</p>",
        "id": 278738371,
        "sender_full_name": "Dante Broggi",
        "timestamp": 1649790240
    }
]