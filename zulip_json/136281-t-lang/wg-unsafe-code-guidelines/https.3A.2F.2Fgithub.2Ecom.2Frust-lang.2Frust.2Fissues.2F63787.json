[
    {
        "content": "<p>I have some questions about this issue</p>",
        "id": 173953597,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551292
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> said that it was important to answer the question: Do we want non-repr(transparent)-structs containing references to be marked noalias?</p>",
        "id": 173953609,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551312
    },
    {
        "content": "<p>but this question feels like the wrong question to ask to me.</p>",
        "id": 173953630,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551334
    },
    {
        "content": "<p>It boils down to answering the question: Do we want <code>struct Foo&lt;'a, T&gt;(&amp;'a mut T)</code> to be equivalent to <code>&amp;'a mut T</code> ?</p>",
        "id": 173953668,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551398
    },
    {
        "content": "<p>There, <code>Foo</code> is not <code>noalias</code>, its only field is.</p>",
        "id": 173953737,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551435
    },
    {
        "content": "<p>When calling <code>fn foo&lt;'a, T&gt;(x: Foo&lt;'a, T&gt;)</code>, whether <code>x</code> will be <code>noalias</code> or not, depends on the Abi of <code>Foo</code>, and the calling convention used.</p>",
        "id": 173953755,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551471
    },
    {
        "content": "<p>Everything about the LLVM IR generated is ultimately influenced by \"encoding details\" such as how we translate the Rust function signature to LLVM function signatures. That doesn't seem very interesting or relevant to me.</p>",
        "id": 173953843,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566551546
    },
    {
        "content": "<p>The interesting bit is whether soundness requires encoding details in a particular way</p>",
        "id": 173953870,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551576
    },
    {
        "content": "<p>E.g. if a field is of reference type and part of a non-repr-transparent Adt then its ABI is not \"Reference\" but \"RawPointer\"</p>",
        "id": 173953903,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551619
    },
    {
        "content": "<p>a direct consequence being there is a big and subtle difference between <code>Foo</code> and <code>&amp;mut T</code></p>",
        "id": 173953951,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551654
    },
    {
        "content": "<p>If for silly reasons we don't communicate aliasing information we have to LLVM, then that's not a soundness issue, just a missed optimization.<br>\n I guess it's true that the real question could better be stated at a higher level (e.g., about retagging recursing into structures) which then justifies (or not) LLVM IR we generate, but this is just nitpicking IMO.</p>",
        "id": 173953989,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566551710
    },
    {
        "content": "<p>The main question I have from that issue is whether the library types violate the \"validity invariant\" for references</p>",
        "id": 173954001,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551724
    },
    {
        "content": "<p>if we want references to be noalias, and their validity invariant makes sure that's always correct, how can passing Foo by memory or by value make a difference ?</p>",
        "id": 173954024,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551758
    },
    {
        "content": "<p>Validity of reference isn't what justifies <code>noalias</code>, never was</p>",
        "id": 173954068,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566551767
    },
    {
        "content": "<p>I thought it was part of validity that, e.g., &amp;mut T references can't alias each other ?</p>",
        "id": 173954100,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551807
    },
    {
        "content": "<p>or is that only part of the aliasing model ?</p>",
        "id": 173954107,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551818
    },
    {
        "content": "<p>Leaving aside the question of how you'd even say that in the validity predicate, <code>noalias</code> holds for the entirety of the function while validity is only asserted at typed copies, so validity can't very well ensure <code>noalias</code> is applicable</p>",
        "id": 173954228,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566551893
    },
    {
        "content": "<p>So how do we know when we can use <code>noalias</code> ?</p>",
        "id": 173954245,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551914
    },
    {
        "content": "<p>Stacked borrows (at least it's supposed to, there's open UCG issues about mismatches IIRC)</p>",
        "id": 173954267,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566551956
    },
    {
        "content": "<p>In the examples, I have the feeling that we can make them correct, by instead of requiring <code>noalias</code> which holds for the whole function, using something else that only holds till last use.</p>",
        "id": 173954269,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551959
    },
    {
        "content": "<p>That's not <code>noalias</code> though</p>",
        "id": 173954289,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566551974
    },
    {
        "content": "<p>No</p>",
        "id": 173954292,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551978
    },
    {
        "content": "<p>It would be something that probably doesn't exist in LLVM</p>",
        "id": 173954303,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566551992
    },
    {
        "content": "<p>and for good reasons</p>",
        "id": 173954346,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552004
    },
    {
        "content": "<p>But <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> mentions that we could make this a language bug</p>",
        "id": 173954355,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552018
    },
    {
        "content": "<p>A language fix would be, e.g., to only require in the aliasing model for the reference to not alias till last use</p>",
        "id": 173954364,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552044
    },
    {
        "content": "<p>which doesn't hold for these examples, and therefore <code>noalias</code> would be incorrect</p>",
        "id": 173954372,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552060
    },
    {
        "content": "<p>where did he suggest that?</p>",
        "id": 173954388,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552077
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/63787#issuecomment-523968728\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63787#issuecomment-523968728\">https://github.com/rust-lang/rust/issues/63787#issuecomment-523968728</a></p>",
        "id": 173954392,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552090
    },
    {
        "content": "<p>They suggest that we can make this either a language bug, or a library bug</p>",
        "id": 173954405,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552110
    },
    {
        "content": "<p>For this to be a library bug, <code>noalias</code> would need to be correct, which means that the aliasing model would somehow have to require on function arguments that references don't alias for the whole function</p>",
        "id": 173954463,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552146
    },
    {
        "content": "<p>For this to be a language bug, <code>noalias</code> would need to be incorrect, which means the language would not have to require the above, but something else</p>",
        "id": 173954476,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552171
    },
    {
        "content": "<p>I don't see the suggestion you describe there. On its own it just suggests we could fix the soundness issue by not using <code>noalias</code> there, which is true but doesn't imply we'll add anything more</p>",
        "id": 173954481,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552180
    },
    {
        "content": "<p>How do we justify no using <code>noalias</code> there is the question</p>",
        "id": 173954510,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552212
    },
    {
        "content": "<p>By changing how stacked borrows (or whatever else justifies noalias) treats newtypes around references, obviously</p>",
        "id": 173954527,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552236
    },
    {
        "content": "<p>It's unclear to me whether that's better than calling this a library bug</p>",
        "id": 173954590,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552286
    },
    {
        "content": "<p>Congratulations, you now have formed an opinion on the question at hand ;)</p>",
        "id": 173954607,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552310
    },
    {
        "content": "<p>I mean, without having an aliasing model at least, we can't really tell who is at fault here</p>",
        "id": 173954611,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552315
    },
    {
        "content": "<p>We can go either way</p>",
        "id": 173954615,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552327
    },
    {
        "content": "<p>That's precisely the question</p>",
        "id": 173954623,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552343
    },
    {
        "content": "<p>But fixing this at the library level is trivial, and fixing this at the language level requires subtle changes to the Abi and calling conventions</p>",
        "id": 173954633,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552354
    },
    {
        "content": "<p>I get the impression you've had your questions-about-the-question answered and are now thinking out loud. Have fun with that</p>",
        "id": 173954681,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566552379
    },
    {
        "content": "<p>Thanks</p>",
        "id": 173954685,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552390
    },
    {
        "content": "<p>I'll think out loud in the issue</p>",
        "id": 173954722,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566552459
    },
    {
        "content": "<p>we could say we only care about aliasing of \"bare\" references. that doesn't change anything about their ABI, but it does mean that newtyped references get fewer optimizations, which might be undesirable.</p>",
        "id": 174035298,
        "sender_full_name": "RalfJ",
        "timestamp": 1566645865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> </p>\n<blockquote>\n<p>I think we wall agree that it is legal to have C FFI with type Option&lt;&amp;mut T&gt; where C uses a pointer, right?</p>\n</blockquote>\n<p>Can you explain how could that work ?</p>",
        "id": 174036203,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566647760
    },
    {
        "content": "<p>In C, <code>T*</code> and <code>T* restrict</code> are incompatible types, so you can't write a function definition using one, and write a declaration using the other, without invoking undefined behavior.</p>",
        "id": 174036242,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566647789
    },
    {
        "content": "<p>Whether you provide the definition/declaration in Rust/C doesn't matter. That is, in C, the equivalent of:</p>",
        "id": 174036247,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566647821
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// crate A:</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// crate B:</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 174036307,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566647899
    },
    {
        "content": "<p>is UB.</p>",
        "id": 174036330,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566647969
    },
    {
        "content": "<p>Because in the <code>bar</code> declaration <code>x</code> is <code>noalias</code>, in C at least it would be fine, e.g., using LTO, to make the <code>NonNull&lt;T&gt;</code> in the <code>bar</code> definition <code>noalias</code> as well.</p>",
        "id": 174036430,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566648099
    },
    {
        "content": "<p>So if you are compiling Rust code with a <code>fn bar(x: &amp;mut T)</code> definition, and linking that with C code using <code>void bar(T* x)</code>, which calls <code>bar</code> with aliasing pointers, LTO could propagate <code>noalias</code> to <code>bar</code> C definition, and compile it under the assumption that <code>x</code> doesn't alias.</p>",
        "id": 174036491,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566648234
    },
    {
        "content": "<p>That wouldn't break the Rust code calling it via <code>&amp;mut T</code>, but it might break other code that is using <code>NonNull&lt;T&gt;</code> to avoid <code>noalias</code></p>",
        "id": 174036533,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566648290
    },
    {
        "content": "<p>I don't know if LLVM does this \"\"optimization\"\", but it could.</p>",
        "id": 174036587,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566648371
    },
    {
        "content": "<p>E.g. a C header file can declare <code>void foo(T* restrict x);</code> and the C implementation file can implement it as <code>void foo(T* x) { ... }</code>, and you'd definitely want to make use of the fact that <code>x</code> is <code>noalias</code> when compiling the implementation</p>",
        "id": 174036596,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566648432
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> </p>\n<blockquote>\n<p>I think we wall agree that it is legal to have C FFI with type Option&lt;&amp;mut T&gt; where C uses a pointer, right?</p>\n</blockquote>\n<p>Can you explain how could that work ?</p>\n</blockquote>\n<p>AFAIK many people do it? I recall being told by various people that this is a good way to write your FFI.  And why would it not work? The FFI lint was even adjusted to be fine with this, IIRC. I am very confused about your opposition here.</p>\n<p>As I said on GH, I don't think C's rules are very relevant unless LLVM copies them -- but in LLVM, attributes dont affect ABI.</p>",
        "id": 174036753,
        "sender_full_name": "RalfJ",
        "timestamp": 1566648732
    },
    {
        "content": "<p>also, do you know why C declares them incompatible? I don't quite see the point.</p>",
        "id": 174036755,
        "sender_full_name": "RalfJ",
        "timestamp": 1566648751
    },
    {
        "content": "<p>Similar to how in rust, <code>mut</code> isnt part  of the signature (as in <code>fn foo(mut x: i32)</code>, the same should apply to the aliasing stuff</p>",
        "id": 174036764,
        "sender_full_name": "RalfJ",
        "timestamp": 1566648782
    },
    {
        "content": "<blockquote>\n<p>[...] in LLVM, attributes dont affect ABI.</p>\n</blockquote>\n<p>NB this is not generally true, consider <code>sret</code> or <code>zeroext</code> for example. I think it's true for <code>noalias</code> tho</p>",
        "id": 174036842,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566648954
    },
    {
        "content": "<p>hm okay. I was thinking of things like <code>readonly</code> etc as well</p>",
        "id": 174036893,
        "sender_full_name": "RalfJ",
        "timestamp": 1566649021
    },
    {
        "content": "<p>To be more specific, in C, the following program has undefined behavior:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"kr\">restrict</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"kr\">restrict</span> <span class=\"n\">y</span><span class=\"p\">);</span>\n<span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Because the definition and the declaration must be compatible per C11 6.2.7p2 (<a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.2.7p2\" target=\"_blank\" title=\"https://port70.net/~nsz/c/c11/n1570.html#6.2.7p2\">https://port70.net/~nsz/c/c11/n1570.html#6.2.7p2</a>) says:</p>\n<blockquote>\n<p>All declarations that refer to the same object or function shall have compatible type; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>For two function prototypes to be compatible, the function argument types must be compatible, per C11 6.7.6.3p15 (<a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p15\" target=\"_blank\" title=\"https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p15\">https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p15</a>):</p>\n<blockquote>\n<p>For two function types to be compatible, [...] corresponding parameters shall have compatible types</p>\n</blockquote>\n<p>And two pointer types are only compatible if they are identically cvr-qualified, per C11 6.7.6.1p2 (<a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.7.6.1p2\" target=\"_blank\" title=\"https://port70.net/~nsz/c/c11/n1570.html#6.7.6.1p2\">https://port70.net/~nsz/c/c11/n1570.html#6.7.6.1p2</a>) says:</p>\n<blockquote>\n<p>For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.</p>\n</blockquote>",
        "id": 174037215,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566649586
    },
    {
        "content": "<p>I believe you that it does, but is there a good reason for this?</p>",
        "id": 174037225,
        "sender_full_name": "RalfJ",
        "timestamp": 1566649660
    },
    {
        "content": "<p>It's quite common to properly qualify a declaration in a header file, which is where the API is specified, and then do \"whatever\" in the definition.</p>",
        "id": 174037269,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566649706
    },
    {
        "content": "<p>C allows, for example, this code: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">();</span>\n<span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n</pre></div>",
        "id": 174037273,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566649736
    },
    {
        "content": "<p>for compatibility with C89</p>",
        "id": 174037280,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566649758
    },
    {
        "content": "<p>So backward compatibility with code written that way is probably a main reason as well.</p>",
        "id": 174037290,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566649785
    },
    {
        "content": "<p>how does adding more UB help with backwards compatibility?</p>",
        "id": 174037354,
        "sender_full_name": "RalfJ",
        "timestamp": 1566649884
    },
    {
        "content": "<p>There are two issues. C does not require putting arguments on declarations. If you don't, the argument type must match exactly when calling the function, or else UB. If you do put the arguments on the declaration, they must precisely match, or else UB - independently of whether the function is called at all.</p>",
        "id": 174037683,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566650447
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 174037694,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566650466
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 174037711,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566650520
    },
    {
        "content": "<p>IIUC you want this to be correct UB free Rust code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// crate A:</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// crate B:</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 174037768,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566650592
    },
    {
        "content": "<p>If that code is correct, then we need to find a way to precisely word why using the <code>foo</code> declaration according to its signature violates the validity invariant. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">..;</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>We can say that the <code>foo</code> declaration is \"valid\" (aka not instant UB), but that passing it pointers that do not alias is part of its \"safety\" invariant (which isn't documented anywhere), and that the <code>unsafe { ... }</code> block violates it.</p>",
        "id": 174037846,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566650761
    },
    {
        "content": "<p>In C, the declaration itself is \"invalid\" because in C <code>T* restrict</code> is not compatible with <code>T*</code>. </p>\n<p>In Rust we can say  that <code>Option&lt;&amp;mut T&gt;</code>/<code>Option&lt;&amp;T&gt;</code> are compatible with either <code>T*</code> _OR_ <code>T* restrict</code>, but not both, because these two types are incompatible. Since the Rust pointer types are <code>noalias</code>, I'd rather pick <code>T* restrict</code>. Otherwise:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>cannot be called using non-aliasing pointer types from C, which is a requirement that C would place on calling such a function.</p>",
        "id": 174038023,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566651045
    },
    {
        "content": "<p>Why C does things this way would matter if we could change how C does things. It would be cool if you could use a function like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">...</span> <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>via a <code>void foo(T* restrict, T* restrict);</code> prototype from a context in which you know that the pointers will never alias. That would allow calling such a function from Rust using <code>Option&lt;&amp;mut T&gt;</code> instead of <code>*mut T</code>.</p>",
        "id": 174038092,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566651178
    },
    {
        "content": "<blockquote>\n<p>In Rust we can say that Option&lt;&amp;mut T&gt;/Option&lt;&amp;T&gt; are compatible with either T* _OR_ T* restrict, but not both</p>\n</blockquote>\n<p>I disagree. They are incompatible on the C language level but we do not care about that, we only care about the ABI level, and there they are fine.</p>",
        "id": 174044637,
        "sender_full_name": "RalfJ",
        "timestamp": 1566662867
    },
    {
        "content": "<blockquote>\n<p>Why C does things this way would matter if we could change how C does things</p>\n</blockquote>\n<p>no, it also matters to understand the rules. maybe there is a good reason. but if it's just C being silly, and LLVM didnt copy that silliness, there is no reason for us to even talk about it.</p>",
        "id": 174044681,
        "sender_full_name": "RalfJ",
        "timestamp": 1566662911
    },
    {
        "content": "<blockquote>\n<p>IIUC you want this to be correct UB free Rust code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// crate A:</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// crate B:</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n</blockquote>\n<p>we already guarantee that this works, IMO: <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums\" target=\"_blank\" title=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums\">https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums</a></p>",
        "id": 174044694,
        "sender_full_name": "RalfJ",
        "timestamp": 1566662970
    },
    {
        "content": "<p>together with <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/pointers.html\" target=\"_blank\" title=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/pointers.html\">https://rust-lang.github.io/unsafe-code-guidelines/layout/pointers.html</a>:</p>\n<blockquote>\n<p>The layouts of &amp;T, &amp;mut T, *const T and *mut T are the same.</p>\n</blockquote>",
        "id": 174044743,
        "sender_full_name": "RalfJ",
        "timestamp": 1566663010
    },
    {
        "content": "<blockquote>\n<p>I disagree. They are incompatible on the C language level but we do not care about that, we only care about the ABI level, and there they are fine.</p>\n</blockquote>\n<p>This bans cross-lang-LTO</p>",
        "id": 174055381,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682437
    },
    {
        "content": "<p>xLTO happens on the LLVM IR level, what are you talking about?</p>",
        "id": 174055429,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566682487
    },
    {
        "content": "<p>Or would at least impose some extra requirements on it</p>",
        "id": 174055432,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682493
    },
    {
        "content": "<p>hmm, wait, in LLVM-IR, noalias is not part of fn declarations right ?</p>",
        "id": 174055447,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682557
    },
    {
        "content": "<p>it is</p>",
        "id": 174055498,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> two llvm modules, one with a declaration <code>declare void @foo(i32* noalias);</code> and one with a definition <code>define void @foo(i32* %0) { ... }</code></p>",
        "id": 174055544,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682695
    },
    {
        "content": "<p>a valid optimization for C would be to make the <code>i32*</code> in the definition <code>noalias</code>, because a declaration exists that makes it <code>noalias</code></p>",
        "id": 174055546,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682731
    },
    {
        "content": "<p>For most (all?) of this thread so far you've argued in terms of C level types and rules, which is plainly irrelevant on LLVM IR level (and hence, irrelevant for xLTO)</p>",
        "id": 174055555,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566682755
    },
    {
        "content": "<p>the declaration containing noalias could come from Rust code, the definition could be C code</p>",
        "id": 174055558,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682780
    },
    {
        "content": "<p>If you think there is an issue with the LLVM IR and optimizations on it (in the face of xLTO or otherwise) then <strong>please</strong> state it on that level, don't mix in different abstraction levels</p>",
        "id": 174055603,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566682807
    },
    {
        "content": "<p><code>noalias</code> in LLVM-IR is modeled after C restrict</p>",
        "id": 174055605,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> it is a problem on all levels</p>",
        "id": 174055666,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566682954
    },
    {
        "content": "<p>Problem 1 is that xLTO makes Rust and C visible to each other</p>",
        "id": 174055674,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683022
    },
    {
        "content": "<p>Problem 2 is that Option&lt;&amp;mut T&gt; can't be equivalent to both T* and T* restrict because they are not equivalent</p>",
        "id": 174055718,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  is correct in that the layout of <em>mut T and &amp;mut T and T</em> and T* restrict is the same</p>",
        "id": 174055732,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683133
    },
    {
        "content": "<p>It mixes <strong>LLVM IR</strong> generated from both languages. So for example the stuff about cvr-qualified types you cited earlier is only relevant if and insofar it is reflected in the IR semantics. So whatever the problem is, I am very sure you can state it in terms of LLVM IR, which is also the best way to make it legible.</p>",
        "id": 174055733,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683135
    },
    {
        "content": "<p>but that does not mean that *mut T and &amp;mut T can be freely substituted for each other</p>",
        "id": 174055777,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683165
    },
    {
        "content": "<p>It clearly already doesn't mean that by Rust's rules alone, so this is not exactly a revelation</p>",
        "id": 174055782,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683203
    },
    {
        "content": "<p>Yes, if you use <code>&amp;mut T</code> in FFI signatures that also implies aliasing restrictions for the other side of the FFI. That's a far cry from there being an automatic ABI incompatibility.</p>",
        "id": 174055789,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683233
    },
    {
        "content": "<p>If C could see the declaration with mismatching cvr-quals, the behavior would be instantaneously undefined, per C own rules</p>",
        "id": 174055846,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683399
    },
    {
        "content": "<p>that's the problem, not ABI incompatibility - for ABI incompatibility, you'd at least need to call the function to trigger UB</p>",
        "id": 174055897,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683440
    },
    {
        "content": "<p>I don't know how many more ways I can find to say that this is irrelevant because the interop and xLTO is in terms of LLVM IR, not C source code. I feel like I'm not getting this point through to you.</p>",
        "id": 174055909,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683486
    },
    {
        "content": "<p>In terms of LLVM-IR, the question is whether mismatching declarations and definitions when it comes to <code>noalias</code> are ok</p>",
        "id": 174055944,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683523
    },
    {
        "content": "<p>Finally we agree on what's even the right question to ask ;)</p>",
        "id": 174055960,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683560
    },
    {
        "content": "<p>A mismatch in the set of attributes isn't a problem per se. For example, attribute inference might add all sorts of attributes in one module where the body is visible, while being unable to affect the declarations in other modules. I see no reason why noalias would be different.</p>",
        "id": 174055984,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683639
    },
    {
        "content": "<p>With LTO, could LLVM propagate noalias in a declaration to a definition in another module ?</p>",
        "id": 174056040,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683700
    },
    {
        "content": "<p>It's going to merge the attributes (or pick one of the signatures) ~somehow~ I guess</p>",
        "id": 174056049,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683730
    },
    {
        "content": "<p>That could be problematic if it were to happen</p>",
        "id": 174056092,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683767
    },
    {
        "content": "<p>I don't see why this is all that interesting though. If the <code>noalias</code> is present <em>anywhere</em> and it's violated by passing aliasing pointers, that's UB right then and there, even if it may not be visible to the optimizer which looks at any particular module (or even set of modules).</p>",
        "id": 174056097,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683812
    },
    {
        "content": "<p>E.g. if C generates a definition without noalias, but because Rust uses <code>Option&lt;&amp;mut T&gt;</code> in a declaration , LLVM merges them applying noalias to the definiton, something that the original C code did not do, and optimize the definition based on that</p>",
        "id": 174056098,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683819
    },
    {
        "content": "<p>Then some C code calls the definition with aliasing pointers, which would have been ok</p>",
        "id": 174056105,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683874
    },
    {
        "content": "<p>but because of the Rust declaration, now it is not</p>",
        "id": 174056145,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683887
    },
    {
        "content": "<p>The Rust code using <code>Option&lt;&amp;mut T&gt;</code> might never pass aliasing pointers</p>",
        "id": 174056150,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683911
    },
    {
        "content": "<p>That isn't the issue</p>",
        "id": 174056151,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683916
    },
    {
        "content": "<p>Oh I guess this is the same problem as <a href=\"https://github.com/rust-lang/rust/issues/46188\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/46188\">https://github.com/rust-lang/rust/issues/46188</a></p>",
        "id": 174056153,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566683933
    },
    {
        "content": "<p>I didn't knew about this issue</p>",
        "id": 174056161,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683959
    },
    {
        "content": "<p>but that's exactly what I had in mind</p>",
        "id": 174056162,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566683970
    },
    {
        "content": "<p>The question is, can this also happen in Rust code ?</p>",
        "id": 174056205,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684010
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// crate A:</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// crate B:</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;Rust&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 174056214,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684051
    },
    {
        "content": "<p>Could the declaration in crate B result in <code>x</code> and <code>y</code> in the definition becoming <code>noalias</code> after LLVM optimizations ?</p>",
        "id": 174056225,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684078
    },
    {
        "content": "<p>Sure, why not</p>",
        "id": 174056226,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566684091
    },
    {
        "content": "<p>So then it isn't ok</p>",
        "id": 174056231,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684098
    },
    {
        "content": "<p><code>Option&lt;&amp;mut T&gt;</code> is not a type that you can use in an FFI declaration to interface with any pointer type at the other side</p>",
        "id": 174056273,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684124
    },
    {
        "content": "<p>that's too strong a conclusion</p>",
        "id": 174056274,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566684152
    },
    {
        "content": "<p>yes, i suppose we can be more careful with not emitting <code>noalias</code> in declarations</p>",
        "id": 174056275,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684172
    },
    {
        "content": "<p>that's not what i meant</p>",
        "id": 174056280,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566684188
    },
    {
        "content": "<p>a declaration using <code>Option&lt;&amp;mut T&gt;</code> implying it's noalias (and deref'able, and aligned, and ...) can be fine w.r.t. the definition, if it requires all those things anyway</p>",
        "id": 174056324,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1566684255
    },
    {
        "content": "<p>yes</p>",
        "id": 174056337,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684332
    },
    {
        "content": "<p>it could also be always fine, even if the definition doesn't require any of those</p>",
        "id": 174056339,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684353
    },
    {
        "content": "<p>we could say that it is a feature that you can write a definition without requirements, and that if you have a piece of code where you only use it with some requirements met, you can declare it with a \"stronger\" signature, and use that instead</p>",
        "id": 174056386,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684404
    },
    {
        "content": "<p>either way, this should be an explicit design decision, and not something that happens by accident</p>",
        "id": 174056453,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566684552
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// crate A:</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// crate B:</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;Rust&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n</blockquote>\n<p>won't the Rust stuff be mangled? Isn't this only a problem for <code>extern \"C\"</code> because there is no mangling?</p>",
        "id": 174075528,
        "sender_full_name": "RalfJ",
        "timestamp": 1566722407
    },
    {
        "content": "<p>or maybe mangling is always disabled for <code>extern</code>? I don't have a good model of <code>extern \"Rust\"</code></p>",
        "id": 174075535,
        "sender_full_name": "RalfJ",
        "timestamp": 1566722456
    },
    {
        "content": "<p>to my knowledge, there's quite a bit of code out there that uses references (with or without <code>Option</code>) on the Rust side of an <code>extern \"C\"</code> function. some people say this helps them avoid mistakes when writing the FFI glue code.<br>\nFor the case without <code>Option</code>, <a href=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html#interoperability-with-foreign-code\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html#interoperability-with-foreign-code\">https://doc.rust-lang.org/nightly/nomicon/ffi.html#interoperability-with-foreign-code</a> IMO says this is okay for references (and <code>Box</code>, when done right -- also see <a href=\"https://github.com/rust-lang/rust/pull/62514\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/62514\">https://github.com/rust-lang/rust/pull/62514</a>).<br>\nFor the case with <code>Option</code>, <a href=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html#the-nullable-pointer-optimization\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html#the-nullable-pointer-optimization\">https://doc.rust-lang.org/nightly/nomicon/ffi.html#the-nullable-pointer-optimization</a> says very explicitly that this is okay for function pointers<br>\nI read the UCG documents as saying that this is also okay for references with and without <code>Option</code>.<br>\nFor all of these cases we rely on it being okay in LLVM to have a function defined without <code>noalias</code> or <code>dereferencable</code>, and then to call it through a declaration with <code>noalias</code> etc.</p>",
        "id": 174075723,
        "sender_full_name": "RalfJ",
        "timestamp": 1566722777
    },
    {
        "content": "<blockquote>\n<p>I don't have a good model of extern \"Rust\"</p>\n</blockquote>\n<p>You do: <code>extern \"Rust\" fn</code> and <code>fn</code> are two ways of writing the same thing.</p>",
        "id": 174076479,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724420
    },
    {
        "content": "<blockquote>\n<p>For the case without Option, <a href=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html#interoperability-with-foreign-code\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html#interoperability-with-foreign-code\">https://doc.rust-lang.org/nightly/nomicon/ffi.html#interoperability-with-foreign-code</a> IMO says this is okay for references (and Box, when done right -- also see <a href=\"https://github.com/rust-lang/rust/pull/62514\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/62514\">https://github.com/rust-lang/rust/pull/62514</a>).</p>\n</blockquote>\n<p>That is probably wrong, or at least, it did not consider all aspects of the problem. cc <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span></p>",
        "id": 174076524,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724464
    },
    {
        "content": "<p>but fur <code>extern \"Rust\"</code> blocks... is there any name mangling?</p>",
        "id": 174076525,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724467
    },
    {
        "content": "<p>Rust one</p>",
        "id": 174076530,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724481
    },
    {
        "content": "<p>All Rust functions are <code>extern \"Rust\"</code></p>",
        "id": 174076533,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724493
    },
    {
        "content": "<p>You just don't have to write it</p>",
        "id": 174076541,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724510
    },
    {
        "content": "<p>I am talking specifically about extern <em>blocks</em></p>",
        "id": 174076543,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724515
    },
    {
        "content": "<p>I know</p>",
        "id": 174076546,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724526
    },
    {
        "content": "<p>That provides declarations with some ABI</p>",
        "id": 174076552,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724538
    },
    {
        "content": "<p>normal fns are not in an extern block, so your \"all rust fns are\" doesn't apply</p>",
        "id": 174076554,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724551
    },
    {
        "content": "<p><code>fn foo() { ... }</code> is _exactly the same_ as <code>extern \"Rust\" fn foo() { ... }</code></p>",
        "id": 174076595,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724573
    },
    {
        "content": "<p>yes and that has nothing to do with my question :)</p>",
        "id": 174076598,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724584
    },
    {
        "content": "<p>and if extern blocks have mangling that would mean it matters in which crate/module you define them? that makes little sense...</p>",
        "id": 174076599,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724589
    },
    {
        "content": "<p>when you call <code>foo</code> via <code>other_crate::foo()</code> that's exactly the same as doing <code>extern \"Rust\" { fn other_crate_foo() }</code> and calling that</p>",
        "id": 174076602,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724600
    },
    {
        "content": "<p>extern blocks have mangling</p>",
        "id": 174076611,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724650
    },
    {
        "content": "<blockquote>\n<p>when you call <code>foo</code> via <code>other_crate::foo()</code> that's exactly the same as doing <code>extern \"Rust\" { fn other_crate_foo() }</code> and calling that</p>\n</blockquote>\n<p>I dont think that can be right.</p>",
        "id": 174076615,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724672
    },
    {
        "content": "<p>the mangling of the ABI you choose (for C, that's none)</p>",
        "id": 174076617,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724675
    },
    {
        "content": "<p>how does it figure out the module name etc?</p>",
        "id": 174076656,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724688
    },
    {
        "content": "<p>Good question</p>",
        "id": 174076657,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724695
    },
    {
        "content": "<p>In this case, they are in the same crate</p>",
        "id": 174076659,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724708
    },
    {
        "content": "<p>so that isn't an issue</p>",
        "id": 174076660,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724713
    },
    {
        "content": "<p>in different crates, I don't know</p>",
        "id": 174076662,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724725
    },
    {
        "content": "<p>The reference doesn't say</p>",
        "id": 174076666,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724743
    },
    {
        "content": "<p>no mangling: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f976fe163c70645529ae6e1b15fd82a\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f976fe163c70645529ae6e1b15fd82a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f976fe163c70645529ae6e1b15fd82a</a></p>",
        "id": 174076669,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724749
    },
    {
        "content": "<p>(let it generate LLVM IR)</p>",
        "id": 174076671,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724769
    },
    {
        "content": "<p>So you'd need to write the appropriate <code>#[link_name]</code></p>",
        "id": 174076721,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724818
    },
    {
        "content": "<p>or make the Rust item <code>#[no_mangle]</code></p>",
        "id": 174076725,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724824
    },
    {
        "content": "<p>we should write that down in the reference</p>",
        "id": 174076727,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566724830
    },
    {
        "content": "<p>so I don't think your <code>foo</code> example above is an issue -- but if one would do the right mangling manually, it could be. that essentially a duplicate of <a href=\"https://github.com/rust-lang/rust/issues/28179\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/28179\">https://github.com/rust-lang/rust/issues/28179</a> though.</p>",
        "id": 174076735,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724863
    },
    {
        "content": "<blockquote>\n<p>we should write that down in the reference</p>\n</blockquote>\n<p>yeah... <a href=\"https://doc.rust-lang.org/reference/items/external-blocks.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/reference/items/external-blocks.html\">https://doc.rust-lang.org/reference/items/external-blocks.html</a> should probably say that there is no mangling?</p>",
        "id": 174076740,
        "sender_full_name": "RalfJ",
        "timestamp": 1566724902
    },
    {
        "content": "<p>I dont think this has anything to do with <a href=\"https://github.com/rust-lang/rust/issues/28179\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/28179\">#28179</a> .</p>",
        "id": 174076840,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725045
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// crate A:</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// crate B:</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;Rust&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"cp\">$mangled_foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 174076844,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725065
    },
    {
        "content": "<p>has the same issue, no <code>#[no_mangle]</code> involved</p>",
        "id": 174076845,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725073
    },
    {
        "content": "<p>(resolved)</p>",
        "id": 174076846,
        "sender_full_name": "RalfJ",
        "timestamp": 1566725087
    },
    {
        "content": "<p>You don't need any unsafe Rust code to make <code>foo</code> arguments noalias in its definition.</p>",
        "id": 174076895,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725186
    },
    {
        "content": "<p>And we have a well defined mangling scheme, so you could have a <code>build.rs</code> generate <code>$mangled_foo</code> and a macro expand it.</p>",
        "id": 174076907,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725228
    },
    {
        "content": "<p>This is a duplicate of <a href=\"https://github.com/rust-lang/rust/issues/46188\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/46188\">https://github.com/rust-lang/rust/issues/46188</a></p>",
        "id": 174076952,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725291
    },
    {
        "content": "<p>It just happens that that issue is not restricted to <code>extern \"C\"</code></p>",
        "id": 174076956,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725321
    },
    {
        "content": "<p>FWIW for <code>noalias</code>, at least right now, LLVM doesn't do this: <a href=\"https://llvm.godbolt.org/z/EPE_hE\" target=\"_blank\" title=\"https://llvm.godbolt.org/z/EPE_hE\">https://llvm.godbolt.org/z/EPE_hE</a></p>",
        "id": 174077147,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725720
    },
    {
        "content": "<blockquote>\n<p>has the same issue, no <code>#[no_mangle]</code> involved</p>\n</blockquote>\n<p>yeah, not exactly the same issue but similar. there's also one there with <code>link_name</code> or so</p>",
        "id": 174077150,
        "sender_full_name": "RalfJ",
        "timestamp": 1566725733
    },
    {
        "content": "<p>It inlines <code>foo</code> and applies <code>noalias</code> to a copy of <code>foo</code></p>",
        "id": 174077153,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725758
    },
    {
        "content": "<p>(for noalias in argument position)</p>",
        "id": 174077196,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566725814
    },
    {
        "content": "<p>Boom: <a href=\"https://llvm.godbolt.org/z/POZ7Xw\" target=\"_blank\" title=\"https://llvm.godbolt.org/z/POZ7Xw\">https://llvm.godbolt.org/z/POZ7Xw</a></p>",
        "id": 174077648,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566726762
    },
    {
        "content": "<p>It does happen for noalias in argument position</p>",
        "id": 174077650,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566726773
    },
    {
        "content": "<p>(try commenting out the <code>cfg(...)</code>, and see how the declarations are merged)</p>",
        "id": 174077656,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566726788
    },
    {
        "content": "<p>What I haven't been able to trigger is to have that actually add <code>noalias</code> to a definition.</p>",
        "id": 174077714,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566726899
    },
    {
        "content": "<blockquote>\n<p>Boom: <a href=\"https://llvm.godbolt.org/z/POZ7Xw\" target=\"_blank\" title=\"https://llvm.godbolt.org/z/POZ7Xw\">https://llvm.godbolt.org/z/POZ7Xw</a></p>\n</blockquote>\n<p>so, what is that demonstrating?</p>",
        "id": 174078087,
        "sender_full_name": "RalfJ",
        "timestamp": 1566727632
    },
    {
        "content": "<p>looks like a fn ptr transmute to me</p>",
        "id": 174078090,
        "sender_full_name": "RalfJ",
        "timestamp": 1566727638
    },
    {
        "content": "<p>ah LLVM is applying the declaration of one fn to the other?</p>",
        "id": 174078093,
        "sender_full_name": "RalfJ",
        "timestamp": 1566727669
    },
    {
        "content": "<p>yes</p>",
        "id": 174078343,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566728058
    },
    {
        "content": "<p>LLVM transforms <code>declare void @foo(i32*)</code> to <code>declare void @foo(i32* noalias align 4 dereferenceable(4))</code></p>",
        "id": 174078362,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566728108
    },
    {
        "content": "<p>That means that even if the declaration of <code>declare void @foo(i32*)</code> would be correct, and code would use it correctly,  maaaaybe UB could happen - it is unclear to me what the impact of those attributes on the declaration is for optimizations</p>",
        "id": 174078440,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566728212
    },
    {
        "content": "<p>looking at the IR of <code>good::baz(x)</code>, this function only calls a declaration, which requires <code>x</code> to be <code>noalias</code>, so AFAICT propagating all those attributes to <code>baz</code> argument would be ok</p>",
        "id": 174078453,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566728251
    },
    {
        "content": "<p>but LLVM is not doing that</p>",
        "id": 174078455,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566728254
    },
    {
        "content": "<p>That feels like a missed optimization though</p>",
        "id": 174078508,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566728295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> shall we open a rust-lang/rust issue for the declaration/definition xLTO thingy ?</p>",
        "id": 174133217,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566818896
    },
    {
        "content": "<p>I wonder whether a part of the issue that says that:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;Rust&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"cp\">$foo_mangled</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>is ok should be added to the reference.</p>",
        "id": 174133451,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566819123
    },
    {
        "content": "<p>and the other issue should be used to track the bug.</p>",
        "id": 174133477,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566819170
    },
    {
        "content": "<p>Or whether this being ok at all should be discussed first.</p>",
        "id": 174133490,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566819190
    },
    {
        "content": "<blockquote>\n<p><em>gnzlbg</em>: @RalfJ @rkruppe shall i open a rust-lang/rust issue for the<br>\ndeclaration/definition xLTO thingy ?</p>\n</blockquote>\n<p>I think a UCG issue would make more sense?</p>",
        "id": 174134598,
        "sender_full_name": "RalfJ",
        "timestamp": 1566820398
    },
    {
        "content": "<p>I'm not sure</p>",
        "id": 174135186,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566821019
    },
    {
        "content": "<p>One thing is whether the code with the incompatible declarations is correct Rust code.</p>",
        "id": 174135193,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566821037
    },
    {
        "content": "<p>I've got the feeling that either it is, or it should be (because otherwise too much code in the wild could be broken).</p>",
        "id": 174135253,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566821075
    },
    {
        "content": "<p>I don't know if that would fit the reference, or rust-lang/rust, or the rfc repo, but UCGs feels too niche for that</p>",
        "id": 174135263,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566821099
    },
    {
        "content": "<p>once that is settled, then what might remain is just the codegen bug that's already filled upstream</p>",
        "id": 174135284,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566821121
    },
    {
        "content": "<p>(dang, I posted this via reply-by-email and that does not seem to put things into the right topic. sorry.)</p>",
        "id": 174159508,
        "sender_full_name": "RalfJ",
        "timestamp": 1566839605
    },
    {
        "content": "<blockquote>\n<p>once that is settled, then what might remain is just the codegen bug that's already filled upstream</p>\n</blockquote>\n<p>which codegen bug?</p>",
        "id": 174159594,
        "sender_full_name": "RalfJ",
        "timestamp": 1566839674
    },
    {
        "content": "<blockquote>\n<p>I don't know if that would fit the reference, or rust-lang/rust, or the rfc repo, but UCGs feels too niche for that</p>\n</blockquote>\n<p>the UCG would be the right place for figuring out the rules. if you think we have consensus on the rules, this might be more of a reference or nomicon thing.</p>",
        "id": 174159621,
        "sender_full_name": "RalfJ",
        "timestamp": 1566839714
    },
    {
        "content": "<blockquote>\n<p>which codegen bug?</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/issues/46188\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/46188\">https://github.com/rust-lang/rust/issues/46188</a></p>\n<blockquote>\n<p>if you think we have consensus on the rules, this might be more of a reference or nomicon thing.</p>\n</blockquote>\n<p>That boils down to whether we can say that this is ok or not:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[no_mangle]</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">mod</span> <span class=\"nn\">maybe_bad0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// OK or UB ?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">mod</span> <span class=\"nn\">maybe_bad1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">&quot;C&quot;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">NonNull</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// OK or UB ?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// what if `foo` is defined in C? Does that change anything?</span>\n</pre></div>",
        "id": 174167309,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566845861
    },
    {
        "content": "<p>I expect it there to be so much code using <code>&amp;mut T</code>, <code>NonNull&lt;T&gt;</code>, or <code>Option&lt;&amp;mut T&gt;</code> where C expects <code>T*</code>, that if we make any of that UB all FFI code would break.</p>",
        "id": 174167559,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566846044
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 174167590,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566846073
    },
    {
        "content": "<p>Also, that code has no <code>unsafe</code>, so... if we make it UB, safe Rust with <code>#[no_mangle]</code> _or_ linking C would have UB, which it arguably already has, but it would be just another footgun</p>",
        "id": 174167634,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566846118
    },
    {
        "content": "<p>If that code is OK, is it OK to add <code>noalias</code> to <code>maybe_bad1::foo</code>'s argument ?</p>",
        "id": 174167902,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566846286
    },
    {
        "content": "<p>Is it OK to add it to the <code>foo</code> definition ?</p>",
        "id": 174167919,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566846303
    },
    {
        "content": "<hr>\n<p>Looks like there are enough questions for opening an UCG issue :/</p>",
        "id": 174167944,
        "sender_full_name": "gnzlbg",
        "timestamp": 1566846322
    },
    {
        "content": "<p>;)</p>",
        "id": 174168142,
        "sender_full_name": "RalfJ",
        "timestamp": 1566846495
    }
]