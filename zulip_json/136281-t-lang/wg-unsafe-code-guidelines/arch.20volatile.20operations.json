[
    {
        "content": "<p>It was tangentially discussed that we could add volatile load/stores to core::arch with stronger guarantees. </p>\n<p>This is a sketch of how that could look like: <a href=\"https://gist.github.com/gnzlbg/c8ef62c12e692a420face245c5df7123\" target=\"_blank\" title=\"https://gist.github.com/gnzlbg/c8ef62c12e692a420face245c5df7123\">https://gist.github.com/gnzlbg/c8ef62c12e692a420face245c5df7123</a></p>",
        "id": 169118169,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561627881
    },
    {
        "content": "<p>that's the tearing thing, right?<br>\nthe alternative is to do what C++ did: some kind of compiler-implemented <code>trait VolatileAccess { const DOES_NOT_TEAR: bool; }</code></p>",
        "id": 169153909,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> what does \"with side-effects that freezes its result\" mean? in particular I am confused by the \"side-effects\" part</p>",
        "id": 169154305,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655759
    },
    {
        "content": "<p>is that any different from just \"that freezes its result\"?</p>",
        "id": 169154360,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655773
    },
    {
        "content": "<p>in particular, this should <em>not</em> have the side-effect of freezing whatever is in memory at that position</p>",
        "id": 169154384,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655792
    },
    {
        "content": "<p>side-effects is that it is an unknown function</p>",
        "id": 169154391,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561655796
    },
    {
        "content": "<p>freeze is that the value that is loaded, is frozen</p>",
        "id": 169154410,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561655814
    },
    {
        "content": "<p>like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">freeze</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169154448,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561655840
    },
    {
        "content": "<p>so even if the memory is undef, these never return undef</p>",
        "id": 169154469,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561655862
    },
    {
        "content": "<p>oh, so that's:</p>\n<p>16/32/64-bit atomic relaxed load from aligned <code>x</code><br>\n- with side-effects ( -&gt; volatile)<br>\n- that freezes its result.</p>\n<p>that wasnt clear :D</p>",
        "id": 169154482,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655872
    },
    {
        "content": "<p>yeah, i should use \"and\" or commas :P</p>",
        "id": 169154554,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561655903
    },
    {
        "content": "<p>I read it as \"with (side-effects that freezes its result)\"</p>",
        "id": 169154565,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655911
    },
    {
        "content": "<p>maybe \"with side-effects and its result is frozen\" ?</p>",
        "id": 169154585,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561655939
    },
    {
        "content": "<p>I dont think many people will get the \"with side-effects\" part</p>",
        "id": 169154634,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655981
    },
    {
        "content": "<p>In the one-sentence version I'd just use the adjective \"volatile\"</p>",
        "id": 169154650,
        "sender_full_name": "RalfJ",
        "timestamp": 1561655993
    },
    {
        "content": "<p>and then add a paragraph explaining that \"volatile\" basically means the read is speciifed to have side effects that are unknown to the compiler, which implies it cannot be duplicated or removed</p>",
        "id": 169154722,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656021
    },
    {
        "content": "<p>-&gt; MMIO</p>",
        "id": 169154726,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656026
    },
    {
        "content": "<p>or reordered across other volatile operations</p>",
        "id": 169154736,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656048
    },
    {
        "content": "<p>or reordered across syscalls or whatever</p>",
        "id": 169154769,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656067
    },
    {
        "content": "<p>when I started writing that, I used the term \"synchronizes with volatile in the same thread of execution\"</p>",
        "id": 169154786,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656081
    },
    {
        "content": "<p>no that's \"atomic\" terminology</p>",
        "id": 169154802,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656094
    },
    {
        "content": "<p>that is, there is no \"happens before\" across threads, but within the same thread</p>",
        "id": 169154819,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656111
    },
    {
        "content": "<p>which seems wrong here</p>",
        "id": 169154831,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656121
    },
    {
        "content": "<p>you can reorder some stuff around volatile loads</p>",
        "id": 169154873,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656125
    },
    {
        "content": "<p>speaking of which:<br>\n\"This operation is not atomic but it is data-race free.\"</p>\n<p>here two meanings of the word \"atomic\" collide :/<br>\nin my world, being data-race free is the definition of \"atomic\"</p>",
        "id": 169154878,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656130
    },
    {
        "content": "<p>if you are accessing the memory using volatile and non volatile operations</p>",
        "id": 169154895,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656153
    },
    {
        "content": "<p>sure, just like with other externally observable behavior</p>",
        "id": 169154908,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656172
    },
    {
        "content": "<p>you dont needs happens-before to specify that</p>",
        "id": 169154924,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656185
    },
    {
        "content": "<p>for the \"not atomic but data-race-free\", I'd say something like \"this operation consists of multiple atomic operations -- so it causes no data races, but the result might be a mix of values written at different times\".<br>\nor maybe \"this operation is not atomic in the sense that it does not behave transactional, but it is atomic in the sense that it does not cause data races\"</p>",
        "id": 169155093,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656290
    },
    {
        "content": "<p>it kind of says that</p>\n<blockquote>\n<p>This operation is not atomic but it is data-race free.</p>\n<p>The load from <code>x</code> is performed by (multiple) smaller or equally-wide volatile atomic <br>\nloads in an unspecified order.</p>\n</blockquote>",
        "id": 169155154,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656351
    },
    {
        "content": "<p>How about: The operation is not an atomic load, but it loads the memory in a data-race free way, by performing (potentially multiple) smaller or equally-wide volatile atomic loads in an unspecified order.</p>",
        "id": 169155241,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656398
    },
    {
        "content": "<p>what about \"is not a single atomic load\"?^^</p>",
        "id": 169155308,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656454
    },
    {
        "content": "<p>The operation is not necessarily a single atomic load. The memory is read in a data-race free way by performing either a single volatile atomic load, or multiple smaller volatile atomic loads in an unspecified order .</p>",
        "id": 169155509,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656568
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  i've updated the gist a bit.</p>",
        "id": 169155826,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656794
    },
    {
        "content": "<p>I think we could nail down the finer print, if this ever gets RFCed</p>",
        "id": 169155839,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656809
    },
    {
        "content": "<p>sounds good</p>",
        "id": 169155865,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656834
    },
    {
        "content": "<p>I think we could retrofit <code>read_volatile</code> to have these semantics</p>",
        "id": 169155874,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656842
    },
    {
        "content": "<p>what about this:</p>\n<blockquote>\n<p>that's the tearing thing, right?<br>\nthe alternative is to do what C++ did: some kind of compiler-implemented <code>trait VolatileAccess { const DOES_NOT_TEAR: bool; }</code></p>\n</blockquote>",
        "id": 169155916,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656846
    },
    {
        "content": "<p>your approach shares the problem of the <code>Atomic*</code> types that e.g. doing it on a <code>(u8, u16)</code> requires some awful code</p>",
        "id": 169155952,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656887
    },
    {
        "content": "<p>what should implement the trait?</p>",
        "id": 169155962,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656896
    },
    {
        "content": "<p>everything that's small enough to be lowered to a single volatile atomic access</p>",
        "id": 169155979,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656909
    },
    {
        "content": "<p>note that because it freezes the result, it should have less problems than the atomics</p>",
        "id": 169155986,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656914
    },
    {
        "content": "<p>fair</p>",
        "id": 169155996,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656924
    },
    {
        "content": "<p>maybe we should do that for the atomics to..</p>",
        "id": 169156006,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656935
    },
    {
        "content": "<p>so only aligned pointers are supported right?</p>",
        "id": 169156015,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656946
    },
    {
        "content": "<p>that precludes \"de-atomization\" optimizations</p>",
        "id": 169156016,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656948
    },
    {
        "content": "<p>supported for what?</p>",
        "id": 169156029,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656957
    },
    {
        "content": "<p>like the current <code>read_volatile</code> is UB if the pointer is not aligned</p>",
        "id": 169156034,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656959
    },
    {
        "content": "<p>yes</p>",
        "id": 169156042,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656963
    },
    {
        "content": "<p>note that the last set of intrinsics in the gist, supports unaligned loads</p>",
        "id": 169156093,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561656974
    },
    {
        "content": "<p>people asked for a <code>read_volatile_unaligned</code> but I am not sure if it was ever added</p>",
        "id": 169156094,
        "sender_full_name": "RalfJ",
        "timestamp": 1561656975
    },
    {
        "content": "<p>looks like it was added as intrinsic but not exposed? weird</p>",
        "id": 169156119,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657003
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/core/intrinsics/fn.unaligned_volatile_load.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/core/intrinsics/fn.unaligned_volatile_load.html\">https://doc.rust-lang.org/nightly/core/intrinsics/fn.unaligned_volatile_load.html</a></p>",
        "id": 169156127,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657012
    },
    {
        "content": "<p>so if your pointer is unaligned, the chances that you get tearing are super high</p>",
        "id": 169156162,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657034
    },
    {
        "content": "<p>even on x86_64</p>",
        "id": 169156175,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657042
    },
    {
        "content": "<p>if an operation does not require alignment you should say that explicitly</p>",
        "id": 169156185,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657049
    },
    {
        "content": "<p>it's kind of the default to require alignment ;)</p>",
        "id": 169156202,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657067
    },
    {
        "content": "<p>ok so I should change the names in the gist</p>",
        "id": 169156229,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657080
    },
    {
        "content": "<p>anyway I am not saying I have a preference either way, just pointing out that C++ followed a different route</p>",
        "id": 169156256,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657083
    },
    {
        "content": "<p>i prefer to have aligned in the name, because that's something that the user should know about, unaligned means we accept everything</p>",
        "id": 169156303,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657101
    },
    {
        "content": "<blockquote>\n<p>ok so I should change the names in the gist</p>\n</blockquote>\n<p>yes, we usually only add <code>unaligned</code> explicitly but not <code>aligned</code></p>",
        "id": 169156309,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657106
    },
    {
        "content": "<p>I understand the sentiment but it's now how any other API works, so users just have to learn that</p>",
        "id": 169156338,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657131
    },
    {
        "content": "<p>that feels a bit like adding a <code>_this_function_does_not_have_preconditions</code> :D</p>",
        "id": 169156340,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657132
    },
    {
        "content": "<p>but I'll change that, so naming aside, the trait</p>",
        "id": 169156370,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657148
    },
    {
        "content": "<p>that can work</p>",
        "id": 169156378,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657152
    },
    {
        "content": "<p>or you convince t-libs to deprecate <code>ptr::read</code> in favor of <code>ptr::read_aligned</code> :D</p>",
        "id": 169156384,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657157
    },
    {
        "content": "<p>but we need to implement it for types of certain layout</p>",
        "id": 169156409,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657171
    },
    {
        "content": "<p>yes it would be a weird trait</p>",
        "id": 169156419,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657179
    },
    {
        "content": "<p>so I don't know how we could do that</p>",
        "id": 169156421,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657182
    },
    {
        "content": "<p>an alternative might be a <code>const fn volatile_access_does_not_tear&lt;T&gt;() -&gt; bool</code></p>",
        "id": 169156522,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657217
    },
    {
        "content": "<p>maybe that makes more sense</p>",
        "id": 169156527,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657222
    },
    {
        "content": "<p>I think that such an API could be built on top of the core::arch intrinsics</p>",
        "id": 169156530,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657223
    },
    {
        "content": "<p>in a library</p>",
        "id": 169156536,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657228
    },
    {
        "content": "<p>and then it's easy to look at the layout</p>",
        "id": 169156537,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657230
    },
    {
        "content": "<p>depends if you want to support all Ts with the same layout as e.g. u8, or you are ok with u8</p>",
        "id": 169156563,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657253
    },
    {
        "content": "<p>like if you have a different type, you only need <code>*mut T as _</code> in the function call</p>",
        "id": 169156597,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657270
    },
    {
        "content": "<p>the implementation of a polymorphic <code>const fn</code> can juts look at the <code>TyLayout</code>, check the <code>Abi</code>, and work with that</p>",
        "id": 169156599,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657274
    },
    {
        "content": "<blockquote>\n<p>like if you have a different type, you only need <code>*mut T as _</code> in the function call</p>\n</blockquote>\n<p>what do you mean?</p>",
        "id": 169156641,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657302
    },
    {
        "content": "<p>I don't think we need const fn, we need something like what <code>transmute</code> did, before it was <code>const fn</code> (although these should be const fn)</p>",
        "id": 169156667,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657321
    },
    {
        "content": "<p>...?</p>",
        "id": 169156730,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657339
    },
    {
        "content": "<p>i mean calling ,e.g., <code> volatile_load_u16</code></p>",
        "id": 169156734,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657342
    },
    {
        "content": "<p>I have no idea what you mean</p>",
        "id": 169156749,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657359
    },
    {
        "content": "<p>or what problem you are even talking about^^</p>",
        "id": 169156768,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657375
    },
    {
        "content": "<p>you mentioned that if we don't have a trait, user code would be weird for <code>(u8, u32)</code>, but it looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">arch</span>::<span class=\"n\">volatile_load_u32</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169156808,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657406
    },
    {
        "content": "<p>but now <code>r</code> has the wrong type</p>",
        "id": 169156845,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657435
    },
    {
        "content": "<p>and also <code>x as _</code> gives me shivers^^</p>",
        "id": 169156916,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657466
    },
    {
        "content": "<p>raw ptr casts are already dangerous when they are fully spelled out...</p>",
        "id": 169156930,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657476
    },
    {
        "content": "<p>i mean, we could do a transmute</p>",
        "id": 169156940,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657478
    },
    {
        "content": "<p>internally</p>",
        "id": 169156946,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657483
    },
    {
        "content": "<p><code>core::arch::volatile_load_32(y);</code> would cast internally y to a <code>*const u32</code>, do the load, and transmute back to <code>T</code></p>",
        "id": 169156976,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657512
    },
    {
        "content": "<p><code>volatile_load_u32&lt;T&gt;(x: *const T) -&gt; T where mem::size_of::&lt;T&gt;() == 4</code>?</p>",
        "id": 169156979,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657512
    },
    {
        "content": "<p>yeah</p>",
        "id": 169157002,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657524
    },
    {
        "content": "<p>that would make <code>u32</code> a misnomer</p>",
        "id": 169157020,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657533
    },
    {
        "content": "<p>but, sure, many things one can try :D</p>",
        "id": 169157033,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657539
    },
    {
        "content": "<p>(I changed it above)</p>",
        "id": 169157037,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657542
    },
    {
        "content": "<p>but yeah</p>",
        "id": 169157045,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657547
    },
    {
        "content": "<p>I have another concern though: calling this a \"relaxed\" access</p>",
        "id": 169157051,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657549
    },
    {
        "content": "<p>I am not sure if that's correct</p>",
        "id": 169157060,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657558
    },
    {
        "content": "<p>i used that to save words</p>",
        "id": 169157066,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657561
    },
    {
        "content": "<p>but that has a very specific technical meaning</p>",
        "id": 169157125,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657571
    },
    {
        "content": "<p>and I dont think we want that</p>",
        "id": 169157135,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657575
    },
    {
        "content": "<p>otherwise I need wording about data-race freedom in the other variants</p>",
        "id": 169157136,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657575
    },
    {
        "content": "<p>well the accesses are atomic, and the ordering is relaxed (they don't synchronize)</p>",
        "id": 169157160,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657595
    },
    {
        "content": "<p><code> release_fence();relaxed_store(x, 4);</code> is \"almost\" the same as <code>release_store(x, 4);</code></p>",
        "id": 169157186,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657612
    },
    {
        "content": "<p>I dont think we want to guarantee that for volatile stores</p>",
        "id": 169157193,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657618
    },
    {
        "content": "<p>relaxed <em>does</em> synchronize when it is program-order-before a release fence</p>",
        "id": 169157212,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657639
    },
    {
        "content": "<p>well in some sense</p>",
        "id": 169157259,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657676
    },
    {
        "content": "<p>what I mean is that you can implement synchronization with relaxed accesses and fences</p>",
        "id": 169157307,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657690
    },
    {
        "content": "<p>and I dont know if we can guarnatee that you can implement synchronization with volatile accesses and fences.</p>",
        "id": 169157329,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657719
    },
    {
        "content": "<p>ah I got the order wrong, dang^^ (fixed above)</p>",
        "id": 169157460,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657806
    },
    {
        "content": "<p>so I thought that a relaxed load / store could be reordered across a release fence</p>",
        "id": 169157519,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657844
    },
    {
        "content": "<p>so the rule is something like: release-fence program-order-before relaxed store which is read-from a relaxed load which is program-order-before an acquire fence... then we have a happens-before between the fences</p>",
        "id": 169157522,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657850
    },
    {
        "content": "<p>they can be reordered one way but not the other</p>",
        "id": 169157534,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657863
    },
    {
        "content": "<p>you can NOT move a relaxed store UP to before a release-fence</p>",
        "id": 169157558,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657878
    },
    {
        "content": "<p>because that would kill the synchronization in the rule I just mentioned</p>",
        "id": 169157577,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657896
    },
    {
        "content": "<p>(I hope I am getting the details right, but I know for sure that some pattern like this is legal for programmers, and hence a restriction for compilers)</p>",
        "id": 169157665,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657947
    },
    {
        "content": "<p>so you are right</p>",
        "id": 169157683,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561657963
    },
    {
        "content": "<p>there's some explanation of this at <a href=\"http://plv.mpi-sws.org/fsl/base/paper.pdf\" target=\"_blank\" title=\"http://plv.mpi-sws.org/fsl/base/paper.pdf\">http://plv.mpi-sws.org/fsl/base/paper.pdf</a>... at least that's the best kind of explanation for me, YMMV ;)</p>",
        "id": 169157704,
        "sender_full_name": "RalfJ",
        "timestamp": 1561657980
    },
    {
        "content": "<p>a release_fence followed by a relaxed store is a release_store, and a relaxed_load followed by a acquire_fence is a acquire_load</p>",
        "id": 169157750,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658014
    },
    {
        "content": "<p>no that's not correct either</p>",
        "id": 169157759,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658023
    },
    {
        "content": "<p>aquire_load sorry</p>",
        "id": 169157837,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658054
    },
    {
        "content": "<p>no thats not it</p>",
        "id": 169157845,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658059
    },
    {
        "content": "<p>a release-fence followed by  a relaxed-store will build up happens-before <em>only</em> with something followed by an acquire fence</p>",
        "id": 169157855,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658065
    },
    {
        "content": "<p>whereas a release-store will build-up happens-before <em>only</em> with an acquire load <em>to the same location</em></p>",
        "id": 169157878,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658084
    },
    {
        "content": "<p>a relaxed_load followed by an acquire_fence is an acquire_load</p>",
        "id": 169157938,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658115
    },
    {
        "content": "<p>no</p>",
        "id": 169157948,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658119
    },
    {
        "content": "<p>let me type out the counterexample</p>",
        "id": 169157970,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658132
    },
    {
        "content": "<p>(you are right in x86/ARM but not in C/C++/Rust)</p>",
        "id": 169157984,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658142
    },
    {
        "content": "<p>(well for x86 it's moot because TLS but whatever^^)</p>",
        "id": 169158014,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658160
    },
    {
        "content": "<p>coming back to your point</p>",
        "id": 169158161,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658219
    },
    {
        "content": "<p>if we use the term atomic relaxed, then the fences would synchronize with volatile operations, and we don't want that</p>",
        "id": 169158205,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658237
    },
    {
        "content": "<p>Thread 1:</p>\n<div class=\"codehilite\"><pre><span></span>data = 32; // non-atomic\nfence_release();\nstore_relaxed(flag, 1);\n</pre></div>\n\n\n<p>Thread 2:</p>\n<div class=\"codehilite\"><pre><span></span>while load_relaxed(flat) == 0 { }\nfence_acquire();\nprint(data); // non-atomic\n</pre></div>",
        "id": 169158208,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658238
    },
    {
        "content": "<p>this code is okay and data-race-free</p>",
        "id": 169158217,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658246
    },
    {
        "content": "<p>now after replacing the relaxed-store-followed-by-release-fence we have<br>\nThread 1:</p>\n<div class=\"codehilite\"><pre><span></span>data = 32; // non-atomic\nstore_release(flag, 1);\n</pre></div>\n\n\n<p>Thread 2:</p>\n<div class=\"codehilite\"><pre><span></span>while load_relaxed(flat) == 0 { }\nfence_acquire();\nprint(data); // non-atomic\n</pre></div>\n\n\n<p>This code has a data race and is UB.</p>",
        "id": 169158262,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658281
    },
    {
        "content": "<p>and that's because fences only sync with fences</p>",
        "id": 169158356,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658326
    },
    {
        "content": "<p>but there's just one fence here so nothing it can sync with</p>",
        "id": 169158372,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658336
    },
    {
        "content": "<p>argh ordered my fences wrong again^^ fixing that</p>",
        "id": 169158417,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658361
    },
    {
        "content": "<p>hmm</p>",
        "id": 169158456,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658390
    },
    {
        "content": "<p>you would need to replace the code in thread 2 with an acquire_load to fix the data race</p>",
        "id": 169158520,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658408
    },
    {
        "content": "<p>yes</p>",
        "id": 169158541,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658413
    },
    {
        "content": "<p>that's what I was trying to say</p>",
        "id": 169158575,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658436
    },
    {
        "content": "<p>so a release-acquire store pair has basically the same effect as a release-relaxed-relaxed-aquire store-fence-fence-load quadruple</p>",
        "id": 169158593,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658456
    },
    {
        "content": "<p>but I see your point, in that the relaxed load and stores do not synchronize with anything, its the fences</p>",
        "id": 169158598,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658459
    },
    {
        "content": "<p>but you have to use the same thing \"on both sides\"</p>",
        "id": 169158609,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658464
    },
    {
        "content": "<p>so can we use \"atomic relaxed\" as wording for the atomic volatile operations ?</p>",
        "id": 169158652,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658495
    },
    {
        "content": "<p>they don't synchronize with anything</p>",
        "id": 169158663,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658501
    },
    {
        "content": "<p>(and in terms of efficiency, the fences are more likely to \"accidentally\" synchronize with other things as they are less specific... but then you get better control, like in my example where you get an acquire fence only after the successful read)</p>",
        "id": 169158664,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658502
    },
    {
        "content": "<p>you would need two fences, and then its up to the fences</p>",
        "id": 169158674,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658509
    },
    {
        "content": "<p>no the fence son their own dont do anything</p>",
        "id": 169158689,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658518
    },
    {
        "content": "<p>its the  release-relaxed-relaxed-aquire fence-store-load-fence quadruple that does the synchronization</p>",
        "id": 169158758,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658534
    },
    {
        "content": "<p>and we dont want to include volatile accesses in those</p>",
        "id": 169158770,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658542
    },
    {
        "content": "<p>that's why we cannot call them \"relaxed\"</p>",
        "id": 169158780,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658547
    },
    {
        "content": "<p>i thought the fences synchronize, and this determines which stores are seen by which loads, etc.</p>",
        "id": 169158803,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658562
    },
    {
        "content": "<p>there's no way to define what it means for two fences to synchronize, in the axiomatic model</p>",
        "id": 169158846,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658586
    },
    {
        "content": "<p>synchronization is ultimately always seeded by a reads-from relationship -- some thread read a thing and thereby observed some other thread's write</p>",
        "id": 169158895,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658617
    },
    {
        "content": "<p>once that happens, <em>sometimes</em> this induces a \"synchronizes-with\" (which implies happens-before)</p>",
        "id": 169158920,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658635
    },
    {
        "content": "<p>so I always thought of this as the fences synchronize with each other, and that determines which stores happen before which loads</p>",
        "id": 169159015,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658685
    },
    {
        "content": "<p>and that <em>sometimes</em> is</p>\n<ul>\n<li>either the store was release and the load acquire, then we can a synchronizes-with between the two,</li>\n<li>or there was a release-fence program-order-before the store, and an acquire-fence progrm-order after the load, then the fences get a synchronizes-with</li>\n</ul>",
        "id": 169159024,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658697
    },
    {
        "content": "<p>for the 2nd clause, the store and load still need to be at least relaxed</p>",
        "id": 169159037,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658705
    },
    {
        "content": "<p>and I'd like to avoid including volatile there</p>",
        "id": 169159053,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658713
    },
    {
        "content": "<p>we have to, otherwise a volatile write can be observed by a relaxed read</p>",
        "id": 169159084,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658732
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 169159109,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658748
    },
    {
        "content": "<p>for MMIO, it would mean that a non-volatile read was performed</p>",
        "id": 169159177,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658770
    },
    {
        "content": "<blockquote>\n<p>so I always thought of this as the fences synchronize with each other, and that determines which stores happen before which loads</p>\n</blockquote>\n<p>well doing the same thing with non-atomics is still a data race despite the fences, so... that's not quire it in C11 I'm afraid.</p>",
        "id": 169159197,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658788
    },
    {
        "content": "<p>as in, if you are doing MMIO, the reads and the writes must be volatile, or UB probably</p>",
        "id": 169159202,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658793
    },
    {
        "content": "<p>no I mean what do we have to do and why can who observe what if we dont?^^</p>",
        "id": 169159210,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658801
    },
    {
        "content": "<p>i mean that if we say that a volatile store is atomic relaxed, then a non-volatile relaxed load in another thread would be ok, depending on fences</p>",
        "id": 169159271,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658836
    },
    {
        "content": "<p>but we probably want to make that \"not ok\", and require the load to be volatile as well</p>",
        "id": 169159297,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658852
    },
    {
        "content": "<p>and also prevent people from using volatile for intra-thread synchronization</p>",
        "id": 169159332,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658877
    },
    {
        "content": "<p>yes. in fact I'd say <em>even if</em> the load is also volatile, it should still yield <code>undef</code> as this is a data race</p>",
        "id": 169159360,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658882
    },
    {
        "content": "<p>yes</p>",
        "id": 169159392,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658890
    },
    {
        "content": "<p>the exemption from data races is just for UB-ness, not for whether they happen</p>",
        "id": 169159402,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658897
    },
    {
        "content": "<p>the docs should probably say that^^</p>",
        "id": 169159414,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658902
    },
    {
        "content": "<p>well... if we use freeze, undef will never be returned</p>",
        "id": 169159449,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658920
    },
    {
        "content": "<p>yes but that's still very different from the normal atomic relaxed</p>",
        "id": 169159473,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658933
    },
    {
        "content": "<p>which returns the old or the new value</p>",
        "id": 169159478,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658937
    },
    {
        "content": "<p>well its not atomic</p>",
        "id": 169159485,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658940
    },
    {
        "content": "<p>so you are not guaranted either the old or the new, you can get something in between</p>",
        "id": 169159515,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561658956
    },
    {
        "content": "<p>if its relaxed its atomic, otherwise the term makes no sense^^</p>",
        "id": 169159516,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658956
    },
    {
        "content": "<blockquote>\n<p>so you are not guaranted either the old or the new, you can get something in between</p>\n</blockquote>\n<p>you can get anything. I've been told about weird compiler optimizations where you can even see values that never were there</p>",
        "id": 169159554,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658980
    },
    {
        "content": "<p>this can occur due to reorderings</p>",
        "id": 169159564,
        "sender_full_name": "RalfJ",
        "timestamp": 1561658984
    },
    {
        "content": "<p>well volatile cannot be reordered around volatile</p>",
        "id": 169159588,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561659001
    },
    {
        "content": "<p>they were never there in the source program but reorderdings make them \"be there\" in the assembly</p>",
        "id": 169159634,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659004
    },
    {
        "content": "<p>but the non-atomic write from which this volatile read reads is subject to all optimizations</p>",
        "id": 169159677,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659022
    },
    {
        "content": "<p>so we cant guarantee that you wlll only read a combination of the values you have written</p>",
        "id": 169159713,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659045
    },
    {
        "content": "<p>maybe if <em>all</em> accesses to this location are volatile... but why would we want a special case for that?</p>",
        "id": 169159747,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659064
    },
    {
        "content": "<p>well C kind of does</p>",
        "id": 169159785,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561659086
    },
    {
        "content": "<p>the data is volatile, not the accesses</p>",
        "id": 169159802,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561659098
    },
    {
        "content": "<p>some of the proposals that are linked are suggesting to change that, IIRC</p>",
        "id": 169159837,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659115
    },
    {
        "content": "<p>also LLVM doesnt work that way</p>",
        "id": 169159847,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659119
    },
    {
        "content": "<p>and IMO LLVM's model is better</p>",
        "id": 169159892,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659124
    },
    {
        "content": "<p>also \"de-facto C\" has a notion of volatile accesses and the Linux kernel and many more programs rely on that to work</p>",
        "id": 169159922,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659144
    },
    {
        "content": "<p>the C standard basically just ignores reality here</p>",
        "id": 169159944,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659162
    },
    {
        "content": "<p>so are volatile reads/writes to the same memory from different threads without synchronization UB ?</p>",
        "id": 169160015,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561659204
    },
    {
        "content": "<p>i feel am back to square 1 :D</p>",
        "id": 169160031,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561659215
    },
    {
        "content": "<p>so, anyone, coming back to your proposal... (a) please avoid the term \"relaxed\", and (b) when you say there are no data races, maybe it's better to say that data races are <em>not</em> UB but return initialized data?</p>",
        "id": 169160039,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659230
    },
    {
        "content": "<p>that's for volatile reads</p>",
        "id": 169160059,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659241
    },
    {
        "content": "<p>what to do about stores... not sure. write-write races are UB in LLVM, so if we want two concurrent volatile writes to the same location NOT UB, we'd have to ask LLVM first to give us better guarantees.</p>",
        "id": 169160168,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659298
    },
    {
        "content": "<blockquote>\n<p>so are volatile reads/writes to the same memory from different threads without synchronization UB ?</p>\n</blockquote>\n<p>the read vs write thing makes a difference here ;) if both are writes, dunno (yes if you ask the LLVM LangRef). otherwise (if at least one is a read), no.</p>",
        "id": 169160202,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659324
    },
    {
        "content": "<p>is that true for volatile writes as well?</p>",
        "id": 169160401,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561659446
    },
    {
        "content": "<p>I have not seen an exception for volatile writes</p>",
        "id": 169160422,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659479
    },
    {
        "content": "<p>nor for volatile reads, btw -- in LLVM, reads never cause UB due to data races</p>",
        "id": 169160472,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659490
    },
    {
        "content": "<p>they just return <code>undef</code></p>",
        "id": 169160478,
        "sender_full_name": "RalfJ",
        "timestamp": 1561659498
    },
    {
        "content": "<p>so I was wondering if we should say that volatile load / stores have side-effects / are unknown functions at all</p>",
        "id": 169215342,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561719966
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">assert_ne</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">read_volatile</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>LLVM is allowed to re-order the <code>b.read()</code> before the <code>a.read_volatile()</code> AFAICT</p>",
        "id": 169215444,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561720086
    },
    {
        "content": "<p>if <code>read_volatile</code> was an unknown function or had unknown side-effects, this isn't possible, because those side-effects could modify the memory at <code>b</code> (and the re-ordering would change program semantics).</p>",
        "id": 169215455,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561720127
    },
    {
        "content": "<p>so what we really want to say is that the compiler must emit volatile loads and stores, and that these cannot be re-ordered across other volatile loads/stores</p>",
        "id": 169215470,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561720165
    },
    {
        "content": "<p>and just leave it as that</p>",
        "id": 169215533,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561720214
    },
    {
        "content": "<p>I've updated the gist with write operations: <a href=\"https://gist.github.com/gnzlbg/c8ef62c12e692a420face245c5df7123\" target=\"_blank\" title=\"https://gist.github.com/gnzlbg/c8ef62c12e692a420face245c5df7123\">https://gist.github.com/gnzlbg/c8ef62c12e692a420face245c5df7123</a></p>",
        "id": 169217387,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561722347
    },
    {
        "content": "<blockquote>\n<p>if <code>read_volatile</code> was an unknown function or had unknown side-effects, this isn't possible, because those side-effects could modify the memory at <code>b</code> (and the re-ordering would change program semantics).</p>\n</blockquote>\n<p>that's why I wrote, when I specified volatile, that they are unknown function calls that LLVM may make assumptions about. namely... &lt;finding my own post to copy-paste&gt;</p>",
        "id": 169239953,
        "sender_full_name": "RalfJ",
        "timestamp": 1561739223
    },
    {
        "content": "<blockquote>\n<p>\"doesn't mutate any memory I know about that is not aliased with x..x+size\"</p>\n</blockquote>\n<p>(\"I\" = the compiler)</p>",
        "id": 169239998,
        "sender_full_name": "RalfJ",
        "timestamp": 1561739272
    },
    {
        "content": "<p>probably even stronger, doesn't <em>access</em> that memory</p>",
        "id": 169240064,
        "sender_full_name": "RalfJ",
        "timestamp": 1561739295
    },
    {
        "content": "<p>but if you want to avoid that, please still talk about them being externally observable events</p>",
        "id": 169240101,
        "sender_full_name": "RalfJ",
        "timestamp": 1561739320
    },
    {
        "content": "<p>such that they cannot be reordered wrt other externally obsevrable events -- in particular, other volatile accesses</p>",
        "id": 169240132,
        "sender_full_name": "RalfJ",
        "timestamp": 1561739338
    },
    {
        "content": "<p>but also syscalls</p>",
        "id": 169240160,
        "sender_full_name": "RalfJ",
        "timestamp": 1561739355
    }
]