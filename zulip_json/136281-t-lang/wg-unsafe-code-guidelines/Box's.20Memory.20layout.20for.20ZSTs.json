[
    {
        "content": "<p>Hi,<br>\nBox documents nicely its memory layout and which pointers can you pass for deallocation to it. (<a href=\"https://doc.rust-lang.org/std/boxed/index.html#memory-layout\">https://doc.rust-lang.org/std/boxed/index.html#memory-layout</a>)<br>\nit does not specify the memory layout for ZSTs and which pointers can I pass to it.<br>\nSpecifically I'm interested in things like:</p>\n<div class=\"codehilite\"><pre><span></span><code>Box::from_raw(&amp;mut [0u8; 0] as *mut [u8] );\nBox::from_raw(&amp;[0u8; 0] as *const [u8] as *mut [u8] );\nBox::from_raw((NonNull::&lt;[u8;0]&gt;::dangling() as NonNull&lt;[u8]&gt;).as_ptr());\n</code></pre></div>\n\n\n<p>(obv all ZSTs are interesting but these apply to some concerns I have)</p>",
        "id": 208276910,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598562667
    },
    {
        "content": "<p>I think it should be something like:</p>\n<blockquote>\n<p>For zero-sized-types the pointer must be non-null and aligned for the type. </p>\n</blockquote>\n<p>And maybe even be explicit and say that:</p>\n<blockquote>\n<p>You can obtain a pointer that is usable as data for zero-sized type using NonNull::dangling().</p>\n</blockquote>\n<p>But maybe I'm wrong?</p>",
        "id": 208278597,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598563546
    },
    {
        "content": "<p>The last would allow you to fabricate a value of any ZST, e.g. by <code>let v: SomeZst = *Box::from_raw(NonNull::&lt;SomeZst&gt;::dangling());</code>. I've seen plenty of code that uses ZSTs as tokens that \"prove\" some initialization has taken place. The others could allow duplication of non-copy ZST values which is probably bad too. (No clue if the particulars of using it as a slice is okay, though)</p>",
        "id": 208285770,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1598568516
    },
    {
        "content": "<p>Oh you mean that the problem is that the Drop impl will be called and might invalidate some library invariant?</p>",
        "id": 208288851,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598571120
    },
    {
        "content": "<p>yeah if you drop a \"proof\" zst that was fake, bad things can happen</p>",
        "id": 208292835,
        "sender_full_name": "Lokathor",
        "timestamp": 1598575031
    },
    {
        "content": "<p>I use some ZST structs with private constructors as arguments to <code>const fn</code>, to prove that a trait has been implemented, some of those traits are unsafe.</p>",
        "id": 208310613,
        "sender_full_name": "matt1992",
        "timestamp": 1598597214
    },
    {
        "content": "<p>I do that because there's no way to write trait bounds in <code>const fn</code>s in stable Rust.</p>",
        "id": 208310696,
        "sender_full_name": "matt1992",
        "timestamp": 1598597328
    },
    {
        "content": "<p>I would consider it fine to <code>mem::forget(zst)</code> then construct a <code>Box&lt;ThatZstType&gt;</code> with a dummy pointer.<br>\nThe issue is constructing one from nowhere.</p>",
        "id": 208311261,
        "sender_full_name": "matt1992",
        "timestamp": 1598597972
    },
    {
        "content": "<p>Somewhat related: <a href=\"https://github.com/rust-lang/rust-memory-model/issues/44#issuecomment-355139160\">https://github.com/rust-lang/rust-memory-model/issues/44#issuecomment-355139160</a></p>\n<p>So it's _valid_ but not necessarily _safe_ to summon ZSTs from the Ã¦ther.</p>",
        "id": 208317150,
        "sender_full_name": "scottmcm",
        "timestamp": 1598603425
    },
    {
        "content": "<p>I'm not sure this is relevant to my question though.</p>\n<p>It is safe to allocate any ZST and to then deallocate, if that ZST has some library invariants it's your job to handle them. This is true for all types, not just ZST.<br>\nThe question is about the memory model of Box/GlobalAlloc, and what is UB and what is not.<br>\nNot about if you should be careful when manually allocating foreign types.</p>",
        "id": 208322166,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598607064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> I agree. When we document the layout of ZST <code>Box</code> that doesn't mean it becomes <em>safe</em> to just construct a <code>Box</code> for any ZST with that recipe. However, it might be worth mentioning this explicitly.</p>",
        "id": 208365139,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632191
    },
    {
        "content": "<p>regarding the actual invariant... you'd think it is just \"non-null and aligned\", but I think it is more tricky. specifically, I think the following is UB:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"k\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">zst_box</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208365292,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632256
    },
    {
        "content": "<p>the problem is that <code>zst_box</code> is a dangling pointer, and LLVM knows it. Doing <code>getelementptr inbounds</code> on such pointers most likely is UB. (I was not able to get LLVM devs to commit otherwise, in a long mailing list discussion. I am not sure most of them even understood what I was going on about...)</p>",
        "id": 208365386,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632311
    },
    {
        "content": "<p>so how is <code>align_of::&lt;ZST&gt;() as *const ZST</code> is not a dangling pointer in the same sense?</p>",
        "id": 208365533,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598632363
    },
    {
        "content": "<p>I just realized <a href=\"https://doc.rust-lang.org/nightly/core/ptr/index.html\">https://doc.rust-lang.org/nightly/core/ptr/index.html</a> also gets this wrong, I think :/</p>",
        "id": 208365556,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> there's a big difference between a ptr cast from integer, and a ptr obtaiend via <code>malloc</code></p>",
        "id": 208365592,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632394
    },
    {
        "content": "<p>it's related to ptr provenance</p>",
        "id": 208365599,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632399
    },
    {
        "content": "<p>FYI <a href=\"https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety\">https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety</a></p>",
        "id": 208365647,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598632436
    },
    {
        "content": "<p><code>align_of::&lt;ZST&gt;() as *const ZST</code> is a ptr that, as far as LLVM is concerned, <em>might</em> dangle. or not.<br>\n<code>zst_box</code> above <em>definitely</em> dangles.</p>",
        "id": 208365700,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632452
    },
    {
        "content": "<p>yes. we'll have to adjust \"valid for 0 bytes\" to take this into account.</p>",
        "id": 208365735,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208365592\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> there's a big difference between a ptr cast from integer, and a ptr obtaiend via <code>malloc</code></p>\n</blockquote>\n<p>So we're back in a pointer provenance situation here?</p>",
        "id": 208365962,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598632592
    },
    {
        "content": "<p>we're always in a ptr provenance situation when talking about pointers :(</p>",
        "id": 208366001,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632614
    },
    {
        "content": "<p>At least other languages are also having trouble with this <a href=\"https://play.golang.org/p/g4cjteaaUeQ\">https://play.golang.org/p/g4cjteaaUeQ</a> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 208366282,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598632776
    },
    {
        "content": "<p>it's a hard problem^^</p>",
        "id": 208366646,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632952
    },
    {
        "content": "<p>and more troublesome many people haven't yet realized that there even is a problem...</p>",
        "id": 208366686,
        "sender_full_name": "RalfJ",
        "timestamp": 1598632974
    },
    {
        "content": "<p>Wait a minute, in go you can observe the provenance information at runtime by using <code>==</code> but not by inspecting the pointer? That's .. uh .. I'll need an explanation.</p>",
        "id": 208366799,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1598633028
    },
    {
        "content": "<p>so I think what we can and should do here is:</p>\n<ul>\n<li>adjust the docs for \"valid ptr\" to say that even for ZSTs, they may not point to <em>deallocated</em> memory. they are however allowed to point to a fixed (non-0) integer -- memory that conceivably could actually exist.</li>\n<li>for <code>Box</code>, document that the memory needs to be aligned and valid. then the above clause kicks in.</li>\n</ul>",
        "id": 208366825,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229913\">HeroicKatora</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208366799\">said</a>:</p>\n<blockquote>\n<p>Wait a minute, in go you can observe the provenance information at runtime by using <code>==</code> but not by inspecting the pointer? That's .. uh .. I'll need an explanation.</p>\n</blockquote>\n<p>I dont knowmuch about go, but in LLVM what you are actually observing is non-determinism</p>",
        "id": 208366917,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633069
    },
    {
        "content": "<p>provenance is nit observable in LLVM, <code>==</code> ignores provenance -- that's the claim, anyway. And so far the LLVM devs treat it as a bug when we find counterexamples.^^</p>",
        "id": 208366960,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633096
    },
    {
        "content": "<p>but we still can have effects like that example <span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> posted because of non-determinism, and because different optimization choices can restrict non-determinism in different ways.</p>",
        "id": 208367018,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208366917\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"229913\">HeroicKatora</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208366799\">said</a>:</p>\n<blockquote>\n<p>Wait a minute, in go you can observe the provenance information at runtime by using <code>==</code> but not by inspecting the pointer? That's .. uh .. I'll need an explanation.</p>\n</blockquote>\n<p>I dont knowmuch about go, but in LLVM what you are actually observing is non-determinism</p>\n</blockquote>\n<p>Ah, I see. They don't use any particular dangling pointer as rust currently does for known zst slices allocation. E.g. the default impl for <code>&amp;_ [T]</code>.</p>",
        "id": 208367159,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1598633167
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> wait. \"memory that conceivably could actually exist\" is debatable. I've heard people say that \"ZSTs in rust sometimes have invalid pointers because it's in the null page\"</p>",
        "id": 208367383,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598633284
    },
    {
        "content": "<p>the null page is not part of the rust spec</p>",
        "id": 208367467,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633335
    },
    {
        "content": "<p>just specifically the NULL ptr is</p>",
        "id": 208367484,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633340
    },
    {
        "content": "<p>it is the only fixed integer address that rust assumes to definitely not exist</p>",
        "id": 208367516,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633359
    },
    {
        "content": "<p>(the very last address of the address space also cannot be allocated as if it was, computing the 1-past-the-end ptr would overflow. but unlike NULL, the very last address <em>can</em> be 1-past-the-end of another allocation.)</p>",
        "id": 208367642,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633405
    },
    {
        "content": "<p>I guess that's a fair answer. Rust doesn't care how computers are implemented in practice, it can theoretically compile down to different memory addresses(I think?)</p>",
        "id": 208367644,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598633406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208367644\">said</a>:</p>\n<blockquote>\n<p>I guess that's a fair answer. Rust doesn't care how computers are implemented in practice, it can theoretically compile down to different memory addresses(I think?)</p>\n</blockquote>\n<p>I mean whenever I say \"we dont care how computers work\" someone reminds me that rust programs run on real computers ;) but in principle, yes.</p>",
        "id": 208367692,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633434
    },
    {
        "content": "<p>real computers inform the spec, but once we have a spec, only the spec matters.</p>",
        "id": 208367712,
        "sender_full_name": "RalfJ",
        "timestamp": 1598633445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208367692\">said</a>:</p>\n<blockquote>\n<p>I mean whenever I say \"we dont care how computers work\" someone reminds me that rust programs run on real computers ;) but in principle, yes.</p>\n</blockquote>\n<p>lol, yeah, my point is that theoretically we can say that whenever you see in rust a pointer at address 100 in the machine it will be 200, and rust will convert it whenever you try to observe the pointer(not sure if this is valid, and it is way off the subject anyway)</p>",
        "id": 208368048,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598633612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208366825\">said</a>:</p>\n<blockquote>\n<p>so I think what we can and should do here is:</p>\n<ul>\n<li>adjust the docs for \"valid ptr\" to say that even for ZSTs, they may not point to <em>deallocated</em> memory. they are however allowed to point to a fixed (non-0) integer -- memory that conceivably could actually exist.</li>\n<li>for <code>Box</code>, document that the memory needs to be aligned and valid. then the above clause kicks in.</li>\n</ul>\n</blockquote>\n<p>I like that :) also maybe the <code>Box</code> documentation should link to the pointer docs</p>",
        "id": 208368296,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598633728
    },
    {
        "content": "<p>Is <code>may not point to deallocated memory</code> enough? or should it say something like <code>may not point to memory obtained from a different object allocated or deallocated</code></p>",
        "id": 208368817,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598633964
    },
    {
        "content": "<blockquote>\n<p>lol, yeah, my point is that theoretically we can say that whenever you see in rust a pointer at address 100 in the machine it will be 200, and rust will convert it whenever you try to observe the pointer(not sure if this is valid, and it is way off the subject anyway)</p>\n</blockquote>\n<p>if we can actually make every other part of the spec work -- then yes. but given tht rust has ptr-int casts and bytewise accesses, I doubt this can actually be done.</p>",
        "id": 208368954,
        "sender_full_name": "RalfJ",
        "timestamp": 1598634006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208368817\">said</a>:</p>\n<blockquote>\n<p>Is <code>may not point to deallocated memory</code> enough? or should it say something like <code>may not point to memory obtained from a different object allocated or deallocated</code></p>\n</blockquote>\n<p>I dont know what the second variant means.</p>",
        "id": 208369003,
        "sender_full_name": "RalfJ",
        "timestamp": 1598634029
    },
    {
        "content": "<p>it means that this is also not allowed: even though it is not deallocated</p>\n<div class=\"codehilite\"><pre><span></span><code>let mut a = 5i32;\nlet b = &amp;mut a as *mut i32 as *mut ();\nlet zst_box = Box::from_Raw(b);\n</code></pre></div>",
        "id": 208369271,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598634124
    },
    {
        "content": "<p>no that code is fine</p>",
        "id": 208369387,
        "sender_full_name": "RalfJ",
        "timestamp": 1598634199
    },
    {
        "content": "<p>\"different object\" in your def.n begs the question \"different from what\"</p>",
        "id": 208369414,
        "sender_full_name": "RalfJ",
        "timestamp": 1598634216
    },
    {
        "content": "<p>it's okay for a ZST box to point to some actually existing memory. just when that memory is deallocated, the box becomes invalid.</p>",
        "id": 208369449,
        "sender_full_name": "RalfJ",
        "timestamp": 1598634234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208369449\">said</a>:</p>\n<blockquote>\n<p>it's okay for a ZST box to point to some actually existing memory. just when that memory is deallocated, the box becomes invalid.</p>\n</blockquote>\n<p>omg lol, that's crazier than I'd thought</p>",
        "id": 208370286,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598634661
    },
    {
        "content": "<p>how's that crazier? it's just a consequence of what I said earlier I think?</p>",
        "id": 208371781,
        "sender_full_name": "RalfJ",
        "timestamp": 1598635446
    },
    {
        "content": "<p>it is exactly what you said, I just tried to apply some (apparently invalid) logic here (that the problem is that it is a different object etc, not <em>just</em> that it was deallocated)<br>\nis the deallocation true also for stack deallocation?</p>",
        "id": 208374801,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598637005
    },
    {
        "content": "<p>yes</p>",
        "id": 208376044,
        "sender_full_name": "RalfJ",
        "timestamp": 1598637697
    },
    {
        "content": "<p>on the spec level, there is not much of a difference between stack and heap allocations</p>",
        "id": 208376059,
        "sender_full_name": "RalfJ",
        "timestamp": 1598637710
    },
    {
        "content": "<p>basically the only difference is that if you try to <code>free</code> a stack allocation, that's UB ;)</p>",
        "id": 208376112,
        "sender_full_name": "RalfJ",
        "timestamp": 1598637724
    },
    {
        "content": "<p>also, \"stack allocation\" here means \"individual stack-allocated variable\". there is no such thing as a stack frame.</p>",
        "id": 208376151,
        "sender_full_name": "RalfJ",
        "timestamp": 1598637748
    },
    {
        "content": "<p>Whaat? This spec sounds crazy. Why should \"potentially deallocated memory\" be okay but \"definitely deallocated memory\" is not? Besides the fact that LLVM may not be smart enough to rough up the code in one case, from a spec perspective that shouldn't matter</p>",
        "id": 208386408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598643401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208365292\">said</a>:</p>\n<blockquote>\n<p>regarding the actual invariant... you'd think it is just \"non-null and aligned\", but I think it is more tricky. specifically, I think the following is UB:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"k\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">zst_box</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>the problem is that <code>zst_box</code> is a dangling pointer, and LLVM knows it. Doing <code>getelementptr inbounds</code> on such pointers most likely is UB. (I was not able to get LLVM devs to commit otherwise, in a long mailing list discussion. I am not sure most of them even understood what I was going on about...)</p>\n</blockquote>\n<p>This sounds like an LLVM problem, not a rust problem. I don't see how you could ever <code>getelementptr inbounds</code> on a ZST pointer except with offset 0, and it should be easy enough to make that defined to equal the input</p>",
        "id": 208386829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598643657
    },
    {
        "content": "<p>Here's a thought: model ZST pointers as the same as integers (i.e. with the same provenance as what you would get by casting a pointer to an integer). They can't actually be dereferenced, or really anything else except casting to other types (since offsetting does nothing), so a simple integer model should be possible</p>",
        "id": 208387331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598643947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208386408\">said</a>:</p>\n<blockquote>\n<p>Whaat? This spec sounds crazy. Why should \"potentially deallocated memory\" be okay but \"definitely deallocated memory\" is not? Besides the fact that LLVM may not be smart enough to rough up the code in one case, from a spec perspective that shouldn't matter</p>\n</blockquote>\n<p>There is a difference between a deallocated allocation and sonething that was never an allocation at all, but instead a plain integer.</p>",
        "id": 208397730,
        "sender_full_name": "bjorn3",
        "timestamp": 1598650672
    },
    {
        "content": "<p>I know, but I don't think that difference should matter for validity of ZST pointers</p>",
        "id": 208398121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598650956
    },
    {
        "content": "<p>While I can imagine that some rusty semantics can be placed on ZST pointers enforcing some lifetime rules (actually... stacked borrows uses per memory location tracking so this might be a problem... setting that aside), at the LLVM level, because malloc does not allow zero size calls, it's not really possible to get ZST types to live in a real allocation in the first place. So unless they are being used to smuggle a different pointer type, in which case you can use the same pointer provenance rules as ptr-to-int casts, they should have no relation with memory at all. In short, a ZST pointer is just an (aligned nonzero) int.</p>",
        "id": 208398347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598651154
    },
    {
        "content": "<p>For example, it is impossible to construct a valid <code>*const [(u8, Void); 0]</code> in the sense of pointing to somewhere between the beginning and one past the end of an allocation, because all <em>nonzero</em> allocations of the type are invalid, so there is no valid <code>malloc</code> call that could be used to derive such a pointer. For this to make any sense \"dangling\" pointers to the type have to be valid. (Not to mention the obvious, that <code>NonNull::dangling()</code> is the officially correct way to construct ZST pointers so the spec is constrained to make this valid).</p>",
        "id": 208399072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598651754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>This sounds like an LLVM problem, not a rust problem. I don't see how you could ever getelementptr inbounds on a ZST pointer except with offset 0, and it should be easy enough to make that defined to equal the input</p>\n</blockquote>\n<p>should be easy, yes. if you'd like to work on putting that into the LLVM langref, I would be delighted. :) I tried to do that by starting a mailing list discussion, which went nowhere. Maybe there is a better approach. The thing is, I have no idea if there are LLVM optimizations that rely on <code>GEP inbounds</code>-by-0 being UB for dangling pointers.<br>\nbut with the status quo, we have to work with what we are given, I am afraid.</p>",
        "id": 208426051,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208387331\">said</a>:</p>\n<blockquote>\n<p>Here's a thought: model ZST pointers as the same as integers (i.e. with the same provenance as what you would get by casting a pointer to an integer). They can't actually be dereferenced, or really anything else except casting to other types (since offsetting does nothing), so a simple integer model should be possible</p>\n</blockquote>\n<p>nono that would be an awful lot of complexity. having pointers with provenance cast to and from integers without is bad enough. <em>everything</em> based on provenance would suddenly have to rely on an analysis \"is this a ZST ptr or not\" (and with dynamically sized types or polymorphic MIR code you might not even know).</p>",
        "id": 208426103,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208398121\">said</a>:</p>\n<blockquote>\n<p>I know, but I don't think that difference should matter for validity of ZST pointers</p>\n</blockquote>\n<p>I agree. I described reality as it is, not as it should be. ;)</p>",
        "id": 208426113,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694377
    },
    {
        "content": "<blockquote>\n<p>While I can imagine that some rusty semantics can be placed on ZST pointers enforcing some lifetime rules (actually... stacked borrows uses per memory location tracking so this might be a problem... setting that aside)</p>\n</blockquote>\n<p>stacked borrows works on the locations affected by doing things with a pointer. ZST references/pointers affect no memory, so stacked borrows doesn't care.</p>",
        "id": 208426173,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694502
    },
    {
        "content": "<blockquote>\n<p>For example, it is impossible to construct a valid *const [(u8, Void); 0] in the sense of pointing to somewhere between the beginning and one past the end of an allocation</p>\n</blockquote>\n<p>that's not true. just construct a pointer to <code>([Void; 0], i32)</code>.</p>",
        "id": 208426174,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694517
    },
    {
        "content": "<p>re: LLVM, there is also the option of adjusting rustc codegen to guarantee that we never go <code>GEP inbounds</code> for ZST. I am not sure if that is realistic. it would be a hack to work around an LLVM problem.</p>",
        "id": 208426245,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694640
    },
    {
        "content": "<p>(Cc <span class=\"user-group-mention\" data-user-group-id=\"1176\">@WG-llvm</span> maybe some of you can help here -- <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208426051\">this comment</a> summarizes the problem quite well.)</p>",
        "id": 208426256,
        "sender_full_name": "RalfJ",
        "timestamp": 1598694670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> LLVM has to consider pointers that come out of thin air (i.e. <code>intptrcast</code>ed from some arbitrary non-zero integer) \"valid\", so \"dangling\" is not a problem I believe, and so <code>GEPi (inttoptr $align)</code> should also be fine.</p>",
        "id": 208437590,
        "sender_full_name": "nagisa",
        "timestamp": 1598712799
    },
    {
        "content": "<p>in particular <a href=\"https://llvm.org/docs/LangRef.html#pointer-aliasing-rules\">https://llvm.org/docs/LangRef.html#pointer-aliasing-rules</a> says this (I canât find anything more concrete, but I remember this being the case for some reason)</p>\n<blockquote>\n<p>An integer constant other than zero or a pointer value returned from a function not defined within LLVM may be associated with address ranges allocated through mechanisms other than those provided by LLVM. Such ranges shall not overlap with any ranges of addresses allocated by mechanisms provided by LLVM.</p>\n</blockquote>",
        "id": 208437596,
        "sender_full_name": "nagisa",
        "timestamp": 1598712811
    },
    {
        "content": "<p>I feel like the only potential problem we could have is if we were to mark mutable references to these dangling pointers as <code>noalias</code></p>",
        "id": 208437674,
        "sender_full_name": "nagisa",
        "timestamp": 1598712902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208437590\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> LLVM has to consider pointers that come out of thin air (i.e. <code>intptrcast</code>ed from some arbitrary non-zero integer) \"valid\", so \"dangling\" is not a problem I believe, and so <code>GEPi (inttoptr $align)</code> should also be fine.</p>\n</blockquote>\n<p>yes, that's what I said. the interesting question is, what about pointers that are not intrptrcasted, but come from some actual allocation, and that allocation has been free'd.</p>",
        "id": 208438280,
        "sender_full_name": "RalfJ",
        "timestamp": 1598713603
    },
    {
        "content": "<p>aha, yeah that seems UB, GEPi requires it is used on a valid object. As an obvious optimisation compiler could do is have something that replaces gepis with <code>unreachable</code> if it knows the gepi is on an invalid object. Iâm almost 100% sure such an optimisation would not have 0-size as a special case.</p>",
        "id": 208439137,
        "sender_full_name": "nagisa",
        "timestamp": 1598714762
    },
    {
        "content": "<blockquote>\n<p>If the inbounds keyword is present, the result value of the getelementptr is a poison value if the base pointer is not an in bounds address of an allocated object</p>\n</blockquote>\n<p>looks like I'm wrong, you'd get some poison not ub</p>",
        "id": 208439181,
        "sender_full_name": "nagisa",
        "timestamp": 1598714808
    },
    {
        "content": "<p>yeah but poison is bad enough</p>",
        "id": 208444195,
        "sender_full_name": "RalfJ",
        "timestamp": 1598721361
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> I agree that such a pass is conceivable and legal under some interpretation of the LLVM rules. but it has some annoying consequences for ZST references in rust, and I am not convinced there's enough benefit here -- for example, everything alias-analysis-related that comes out of <code>inbounds</code> still remains valid if we say \"inbounds-by-0 is always okay (except on the NULL ptr)\".</p>",
        "id": 208444262,
        "sender_full_name": "RalfJ",
        "timestamp": 1598721448
    },
    {
        "content": "<p>so basically I am saying this poison causes more trouble than it is worth. but unfortunately it is likely not something we can change.</p>",
        "id": 208444272,
        "sender_full_name": "RalfJ",
        "timestamp": 1598721473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208426103\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208387331\">said</a>:</p>\n<blockquote>\n<p>Here's a thought: model ZST pointers as the same as integers (i.e. with the same provenance as what you would get by casting a pointer to an integer). They can't actually be dereferenced, or really anything else except casting to other types (since offsetting does nothing), so a simple integer model should be possible</p>\n</blockquote>\n<p>nono that would be an awful lot of complexity. having pointers with provenance cast to and from integers without is bad enough. <em>everything</em> based on provenance would suddenly have to rely on an analysis \"is this a ZST ptr or not\" (and with dynamically sized types or polymorphic MIR code you might not even know).</p>\n</blockquote>\n<p>Just to clarify: I was under the impression that LLVM doesn't deal with polymorphic rust code at all. My proposal is to treat ZST pointers the same way that integers are treated when lowering to LLVM. I don't think it adds any additional complexity around provenance beyond what ptr-to-int casts already deal with. At the rust / MIR level they can still be pointers and analysis can treat them as such, but because LLVM doesn't know about zero size allocations (and in any case I don't think we want to generate fake allocation code in the first place), there is no other appropriate pointer-like model for ZST pointers besides simple integers (or more accurately, <code>usize</code> values as opaque types with no operations).</p>",
        "id": 208459984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598745055
    },
    {
        "content": "<blockquote>\n<p>I was under the impression that LLVM doesn't deal with polymorphic rust code at all. </p>\n</blockquote>\n<p>True. But we also do some optimizations on the MIR, pre-monomorphization, and we'd like to do more of that in the future.<br>\n\"optimziations\" != \"LLVM\".</p>",
        "id": 208471775,
        "sender_full_name": "RalfJ",
        "timestamp": 1598769857
    },
    {
        "content": "<p>and also, there's <code>&amp;dyn Trait</code> and <code>&amp;[i32]</code>, where you cannot tell during LLVM lowering whether it's a ZST or not</p>",
        "id": 208471784,
        "sender_full_name": "RalfJ",
        "timestamp": 1598769910
    },
    {
        "content": "<p>I'm hoping that all optimizations except the LLVM lowered stuff can be taught that ZST pointers are pointers but have a different notion of \"within bounds\"</p>",
        "id": 208472525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598771431
    },
    {
        "content": "<p>The <code>&amp;dyn Trait</code> and <code>&amp;[i32]</code> examples are interesting. How are these represented in LLVM? I would guess the latter is a <code>(*const i32, usize)</code> pair. Does this suffer from mis-optimization in the zero case?</p>",
        "id": 208472546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598771511
    },
    {
        "content": "<p>they are pairs of pointers and metadata (where metadata is a vtable ptr or the length, respectively)</p>",
        "id": 208472836,
        "sender_full_name": "RalfJ",
        "timestamp": 1598772064
    },
    {
        "content": "<p>and the problem isnt how to lower the pointers, the problem is how to lower the <em>operations</em> on them</p>",
        "id": 208472846,
        "sender_full_name": "RalfJ",
        "timestamp": 1598772100
    },
    {
        "content": "<p>basically, we'd need to never do <code>getelementptr inbounds</code> with a zero offset, as we <em>might</em> be in a ZST when we do that. and we need to change the <code>offset</code> intrinsic to also avoid this -- the latter alone could kill this entire idea as the offset there can be dynamically determined and this is for hot loops, sow e certainly do not want a branch</p>",
        "id": 208472900,
        "sender_full_name": "RalfJ",
        "timestamp": 1598772181
    },
    {
        "content": "<p>is there a <code>getelementptr outofbounds</code>?</p>",
        "id": 208473291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598772856
    },
    {
        "content": "<p>I can see how this might be a fatal problem without LLVM changes though</p>",
        "id": 208473303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598772887
    },
    {
        "content": "<p>Do you have a link to that LLVM mailing list conversation?</p>",
        "id": 208473363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598773005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208473291\">said</a>:</p>\n<blockquote>\n<p>is there a <code>getelementptr outofbounds</code>?</p>\n</blockquote>\n<p>there's plain <code>getelementptr</code> without \"inbounds\"</p>",
        "id": 208473774,
        "sender_full_name": "RalfJ",
        "timestamp": 1598773923
    },
    {
        "content": "<p><code>getelementptr inbounds</code> corresponds to <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset\">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset</a>.<br>\n<code>getelementptr</code> corresponds to <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.wrapping_offset\">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.wrapping_offset</a>.</p>",
        "id": 208473783,
        "sender_full_name": "RalfJ",
        "timestamp": 1598773961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208473363\">said</a>:</p>\n<blockquote>\n<p>Do you have a link to that LLVM mailing list conversation?</p>\n</blockquote>\n<p>as usual mailman archives are horrible...<br>\nhere's my initial mail: <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2019-February/130452.html\">https://lists.llvm.org/pipermail/llvm-dev/2019-February/130452.html</a><br>\nthe first email of the March part of that thread: <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2019-March/130831.html\">https://lists.llvm.org/pipermail/llvm-dev/2019-March/130831.html</a><br>\nfirst email of the april part: <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2019-April/131693.html\">https://lists.llvm.org/pipermail/llvm-dev/2019-April/131693.html</a><br>\nand I think that's it</p>",
        "id": 208473842,
        "sender_full_name": "RalfJ",
        "timestamp": 1598774065
    },
    {
        "content": "<p>Thanks, that was an interesting read. How feasible do you think it would be to only put the <code>inbounds</code> in when we can prove (on the rust side) that the pointer is not a ZST or the offset is not 0?</p>",
        "id": 208474449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775303
    },
    {
        "content": "<p>it's sufficient to be able to prove that the offset is not 0</p>",
        "id": 208474479,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775363
    },
    {
        "content": "<p>well the first thing might be easier since usually the type is known</p>",
        "id": 208474500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775384
    },
    {
        "content": "<p>and while this might be feasible for struct field accesses, I am not at all sure it is feasible for the <code>offset</code> intrinsic</p>",
        "id": 208474501,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208474500\">said</a>:</p>\n<blockquote>\n<p>well the first thing might be easier since usually the type is known</p>\n</blockquote>\n<p>when the type is known, the field is also known and then we can just use that^^ I don't think looking at the type helps</p>",
        "id": 208474506,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775411
    },
    {
        "content": "<p>I mean if it is <code>&amp;x[n]</code> where <code>x: &amp;[T]</code> and <code>T</code> is not a zst</p>",
        "id": 208474510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775449
    },
    {
        "content": "<p>oh, for indexing... right.</p>",
        "id": 208474557,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775494
    },
    {
        "content": "<p>I was thinking more of <code>ptr.field</code>.</p>",
        "id": 208474559,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775501
    },
    {
        "content": "<p>ah, a zst with zst fields?</p>",
        "id": 208474562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775522
    },
    {
        "content": "<p>yes</p>",
        "id": 208474567,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775564
    },
    {
        "content": "<p>so I'm sure the basic <code>offset</code> intrinsic will not be able to prove this in general. How significant of a pessimization would it be to leave off the <code>inbounds</code> there?</p>",
        "id": 208474571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775598
    },
    {
        "content": "<p>It's still just an addition, there is no branch being introduced</p>",
        "id": 208474614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775628
    },
    {
        "content": "<p>my understanding is that it just gives LLVM less aliasing info to work with</p>",
        "id": 208474621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775658
    },
    {
        "content": "<p>so the immediate effects aren't obvious, it will cause some optimization to not trigger in some cases</p>",
        "id": 208474673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208474571\">said</a>:</p>\n<blockquote>\n<p>so I'm sure the basic <code>offset</code> intrinsic will not be able to prove this in general. How significant of a pessimization would it be to leave off the <code>inbounds</code> there?</p>\n</blockquote>\n<p>I have no numbers. but the entire reason it exists (beyond <code>wrapping_offset</code>) is to have the <code>inbounds</code>.</p>",
        "id": 208474680,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775772
    },
    {
        "content": "<p>But do you think it is used often on types that are not provably ZST or non-ZST?</p>",
        "id": 208474689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775817
    },
    {
        "content": "<p>You have to be working with unsized types to get into such a situation AFAICT</p>",
        "id": 208474732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208474689\">said</a>:</p>\n<blockquote>\n<p>But do you think it is used often on types that are not provably ZST or non-ZST?</p>\n</blockquote>\n<p>this is a raw ptr method</p>",
        "id": 208474735,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775887
    },
    {
        "content": "<p>you cannot use the types for anything</p>",
        "id": 208474736,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775892
    },
    {
        "content": "<p>you'd have to prove that the actual offset is not 0</p>",
        "id": 208474748,
        "sender_full_name": "RalfJ",
        "timestamp": 1598775932
    },
    {
        "content": "<p>Maybe I'm misunderstanding the effect of the <code>offset</code> function. I thought it was the same as C's <code>&amp;x[n]</code></p>",
        "id": 208474755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598775953
    },
    {
        "content": "<p>kindof, yeah</p>",
        "id": 208474802,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776003
    },
    {
        "content": "<p>but if we want to say that offset-by-0 is okay on deallocated pointers, we have to cahnge behavior of all offset-by-0</p>",
        "id": 208474805,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776020
    },
    {
        "content": "<p>Double checking the signature, it has a <code>&lt;T&gt;</code>. My contention is that if <code>sizeof(T) != 0</code> then GEPi is okay</p>",
        "id": 208474811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776031
    },
    {
        "content": "<p>we cannot rely on type information. this is used by unsafe code, including for actual ZST but after some type casts.</p>",
        "id": 208474813,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776037
    },
    {
        "content": "<p>so you are saying that <code>offset&lt;T&gt;(p, n)</code> is defined to have the same effect as <code>offset&lt;u8&gt;(p as *const u8, n * sizeof&lt;T&gt;())</code>?</p>",
        "id": 208474874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776153
    },
    {
        "content": "<p>Is it also the same as <code>(p as usize) + n * sizeof&lt;T&gt;()</code> (in terms of runtime behavior / UB, not necessarily information as conveyed to LLVM)?</p>",
        "id": 208474938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776295
    },
    {
        "content": "<p>The <a href=\"https://doc.rust-lang.org/std/intrinsics/fn.offset.html\">doc</a> says:</p>\n<blockquote>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of an allocated object. If either pointer is out of bounds or arithmetic overflow occurs then any further use of the returned value will result in undefined behavior.</p>\n</blockquote>\n<p>which looks cribbed straight from LLVM. How is that return value modeled? Does Miri also have <code>poison</code>?</p>",
        "id": 208474987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776383
    },
    {
        "content": "<p>oh right, miri doesn't like pointers</p>",
        "id": 208475039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208474874\">said</a>:</p>\n<blockquote>\n<p>so you are saying that <code>offset&lt;T&gt;(p, n)</code> is defined to have the same effect as <code>offset&lt;u8&gt;(p as *const u8, n * sizeof&lt;T&gt;())</code>?</p>\n</blockquote>\n<p>I think it would be really confusing if it didn't. and \"confusing\" is the last thing we want for unsafe APIs.</p>",
        "id": 208475062,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208474938\">said</a>:</p>\n<blockquote>\n<p>Is it also the same as <code>(p as usize) + n * sizeof&lt;T&gt;()</code> (in terms of runtime behavior / UB, not necessarily information as conveyed to LLVM)?</p>\n</blockquote>\n<p>no, not at all. ineteger addition is very different from pointer arithmetic. (the same is true in C.)</p>",
        "id": 208475063,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208475039\">said</a>:</p>\n<blockquote>\n<p>oh right, miri doesn't like pointers</p>\n</blockquote>\n<p>not sure what you mean. miri fully supports pointers.</p>",
        "id": 208475113,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208474987\">said</a>:</p>\n<blockquote>\n<p>The <a href=\"https://doc.rust-lang.org/std/intrinsics/fn.offset.html\">doc</a> says:</p>\n<blockquote>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of an allocated object. If either pointer is out of bounds or arithmetic overflow occurs then any further use of the returned value will result in undefined behavior.</p>\n</blockquote>\n<p>which looks cribbed straight from LLVM. How is that return value modeled? Does Miri also have <code>poison</code>?</p>\n</blockquote>\n<p>yes, this is basically just forwarding LLVM requirements -- except in Rust we say it is insta-UB to violate this condition. so we don't need poison for this.</p>",
        "id": 208475118,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776606
    },
    {
        "content": "<p>maybe I'm confusing it with const-eval</p>",
        "id": 208475119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776608
    },
    {
        "content": "<p>that said, miri does have poison; it is called <code>Uninit</code>.</p>",
        "id": 208475122,
        "sender_full_name": "RalfJ",
        "timestamp": 1598776615
    },
    {
        "content": "<p>Okay so to take a different tack, suppose there is a fictional zero-malloc dispensing valid ZST pointers at address 4. All valid ZSTs must point into a valid allocation, including that one. What are the issues with that model? I guess that's the closest to current reality</p>",
        "id": 208475194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776767
    },
    {
        "content": "<p>One thing I can see is that the zero-malloc might dispense memory in the middle of another allocation (unlikely but possible if the ZST has large alignment). So you can get say <code>(4..20): &amp;mut [u8]</code> and <code>8: &amp;mut [u64; 0]</code> at the same time, which is bad</p>",
        "id": 208475289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598776943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208475194\">said</a>:</p>\n<blockquote>\n<p>Okay so to take a different tack, suppose there is a fictional zero-malloc dispensing valid ZST pointers at address 4. All valid ZSTs must point into a valid allocation, including that one. What are the issues with that model? I guess that's the closest to current reality</p>\n</blockquote>\n<p>kinda, yeah. LLVM doesn't assume it knows that <em>all</em> allocations exist, and allocations of size 0 are rather inconsequential. so they might just exist anywhere.</p>",
        "id": 208475447,
        "sender_full_name": "RalfJ",
        "timestamp": 1598777289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208475289\">said</a>:</p>\n<blockquote>\n<p>One thing I can see is that the zero-malloc might dispense memory in the middle of another allocation (unlikely but possible if the ZST has large alignment). So you can get say <code>(4..20): &amp;mut [u8]</code> and <code>8: &amp;mut [u64; 0]</code> at the same time, which is bad</p>\n</blockquote>\n<p>indeed, I have been wondering about the same thing.</p>",
        "id": 208475448,
        "sender_full_name": "RalfJ",
        "timestamp": 1598777309
    },
    {
        "content": "<p>Is there a maximum alignment? It doesn't seem too onerous to guarantee that non-ZST types must never be allocated (by a proper allocator) at addresses smaller than the largest alignment. At least on normal platforms that's certainly the case</p>",
        "id": 208476451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598779377
    },
    {
        "content": "<p>no I dont think there is a maximum alignment</p>",
        "id": 208477222,
        "sender_full_name": "RalfJ",
        "timestamp": 1598780875
    },
    {
        "content": "<p>You can very easily have an alignment significantly higher than the page size, and there are a few open issues about them actually.</p>",
        "id": 208477270,
        "sender_full_name": "Peter Rabbit",
        "timestamp": 1598780916
    },
    {
        "content": "<p>I suspect that these requirements are close enough to plausible that it's actually possible to get miscompilation: use a very large regular allocation <code>x</code> that spans a power of 2 address, use <code>dangling()</code> to construct a ZST pointer <code>y</code> with the same address, and then pass both mutable pointers to a function (that assumes they are disjoint), and do something in the function to make it call GEPi 0 on the ZST (and hence assert validity of the address). Now LLVM will be able to prove that <code>x.begin() &lt; y &lt; x.end()</code> is false even though it is true at run time, so you can put some UB behind an if statement saying <code>!(x.begin() &lt; y &lt; x.end())</code> and boom, UB in safe code.</p>",
        "id": 208481223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598787804
    },
    {
        "content": "<p>alias assumptions are not used to optimize pointer comparisons, and indeed that would be wrong</p>",
        "id": 208482145,
        "sender_full_name": "RalfJ",
        "timestamp": 1598789184
    },
    {
        "content": "<p>like, <code>&amp;mut ()</code> and <code>&amp;mut i32</code> can have the same value, if they point to the two fields of a <code>((), i32)</code>.</p>",
        "id": 208482149,
        "sender_full_name": "RalfJ",
        "timestamp": 1598789203
    },
    {
        "content": "<p>True, but <em>strict</em> inequalities?</p>",
        "id": 208482699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598790126
    },
    {
        "content": "<p>I realize disjoint allocations can abut, but I don't think they can nest</p>",
        "id": 208482712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598790155
    },
    {
        "content": "<p>I tried to set up my test, and managed to get lucky enough to get malloc to give me an allocation spanning a power of two, namely 2^46, but I was not able to declare a ZST with that alignment:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[repr(align(0x4000_0000_0000))]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyZST</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// invalid `repr(align)` attribute: larger than 2^29</span>\n</code></pre></div>\n\n\n<p>So I guess there are limits after all, at least in the attribute</p>",
        "id": 208482791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598790277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208482699\">said</a>:</p>\n<blockquote>\n<p>True, but <em>strict</em> inequalities?</p>\n</blockquote>\n<p>not sure how that makes any difference? non-aliasing pointers can still be <em>equal</em>.</p>",
        "id": 208483014,
        "sender_full_name": "RalfJ",
        "timestamp": 1598790643
    },
    {
        "content": "<p>Success! It turns out that calling a function with mut pointers is not needed, even the box creation itself fails. This segfaults on my machine if and only if the final ZST box line is present (you may have to tweak the constants so that you don't run out of memory too early):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[repr(align(0x2000_0000))]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyZST</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">34</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">29</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Box</span>::<span class=\"n\">leak</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">into_boxed_slice</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">MyZST</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208483295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598791180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208483014\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208482699\">said</a>:</p>\n<blockquote>\n<p>True, but <em>strict</em> inequalities?</p>\n</blockquote>\n<p>not sure how that makes any difference? non-aliasing pointers can still be <em>equal</em>.</p>\n</blockquote>\n<p>Non aliasing pointers can not be in a strict nesting relation, <code>p1 &lt; q1 = q2 &lt; p2</code></p>",
        "id": 208483417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598791361
    },
    {
        "content": "<p>which is what this test sets up</p>",
        "id": 208483418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598791371
    },
    {
        "content": "<p>that segfault might just be one of the bugs related to large alignments not working properly though</p>",
        "id": 208483594,
        "sender_full_name": "RalfJ",
        "timestamp": 1598791678
    },
    {
        "content": "<blockquote>\n<p>Non aliasing pointers can not be in a strict nesting relation, p1 &lt; q1 = q2 &lt; p2</p>\n</blockquote>\n<p>I have no idea what you mean by this, there are 4 pointers here?</p>",
        "id": 208483641,
        "sender_full_name": "RalfJ",
        "timestamp": 1598791710
    },
    {
        "content": "<p>LLVM will AFAIK not ever optimize <code>&lt;</code> or any other ptr comparison based on <code>noalias</code></p>",
        "id": 208483645,
        "sender_full_name": "RalfJ",
        "timestamp": 1598791725
    },
    {
        "content": "<p>and I am pretty sure it would be wrong to do so even disregarding anything related to ZST</p>",
        "id": 208483649,
        "sender_full_name": "RalfJ",
        "timestamp": 1598791741
    },
    {
        "content": "<p>note that <code>Box</code> and <code>&amp;mut</code> do not even have <code>noalias</code> currently for various reasons, so I doubt your test has anything to do with <code>noalias</code></p>",
        "id": 208483697,
        "sender_full_name": "RalfJ",
        "timestamp": 1598791766
    },
    {
        "content": "<p>also, <code>&amp;</code> <em>does</em> have <code>noalias</code> (when there is no <code>UnsafeCell</code>). and clearly shared references can be in any kind of nesting relationship as they can freely alias. that's why I keep saying that <code>noalias</code> says absolutely nothing about pointer comparisons.</p>",
        "id": 208483713,
        "sender_full_name": "RalfJ",
        "timestamp": 1598791783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208483641\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Non aliasing pointers can not be in a strict nesting relation, p1 &lt; q1 = q2 &lt; p2</p>\n</blockquote>\n<p>I have no idea what you mean by this, there are 4 pointers here?</p>\n</blockquote>\n<p>There are two allocation regions, in this case a u8 slice vs a ZST</p>",
        "id": 208483861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598791983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208483594\">said</a>:</p>\n<blockquote>\n<p>that segfault might just be one of the bugs related to large alignments not working properly though</p>\n</blockquote>\n<p>damn, you are right. the box alone causes the segfault. lowering the alignment causes it to work, although at alignment <code>0x40_0000</code> the stack overflows, which is not a good sign considering this is a ZST</p>",
        "id": 208484035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598792119
    },
    {
        "content": "<p>I think this is the issue you ran into: <a href=\"https://github.com/rust-lang/rust/issues/70143\">https://github.com/rust-lang/rust/issues/70143</a></p>",
        "id": 208484273,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792491
    },
    {
        "content": "<p>Okay, we're back in business. This uses placement new to avoid aligning the stack, and shows the situation with overlapping mutable pointers:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#![feature(box_syntax, slice_ptr_range)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Field</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[repr(align(0x2000_0000))]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyZST</span><span class=\"p\">(</span><span class=\"n\">Field</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">34</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">29</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Box</span>::<span class=\"n\">leak</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">into_boxed_slice</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">zst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"n\">MyZST</span><span class=\"p\">(</span><span class=\"n\">Field</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">zst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">big_alloc</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">zst</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">MyZST</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">big_alloc</span><span class=\"p\">.</span><span class=\"n\">as_ptr_range</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{:x} &lt; {:x} &lt; {:x}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">zst</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208484327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598792527
    },
    {
        "content": "<p>right, but what does it show? it's totally okay for ZST mutable refs to overlap with other mutable refs</p>",
        "id": 208484343,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792582
    },
    {
        "content": "<p>my only concern here -- the reason I said above that I thought about this before -- is an integer-cast ZST that happens to overlap with an actual allocation, and then that allocation going away. that could lead LLVM to conclude that the ZST dangles and that would be bad.</p>",
        "id": 208484363,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792641
    },
    {
        "content": "<p>that would not be allowed for any other type. I will have to play with LLVM optimizations to get it to do something interesting but I can make it GEPi 0 here and then LLVM will believe false things</p>",
        "id": 208484414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598792668
    },
    {
        "content": "<p>\"for any other type\"?</p>",
        "id": 208484504,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792825
    },
    {
        "content": "<p>what I said is not a weird exception, it falls out of the general rules of Stacked Borrows</p>",
        "id": 208484511,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792870
    },
    {
        "content": "<p>namely aliasing of mutable references is about whether the sets of locations covered by two references are disjoint</p>",
        "id": 208484554,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792892
    },
    {
        "content": "<p>a ZST reference covers no location, and since the empty set is disjoint from every set, it follows that it can never alias with any other reference</p>",
        "id": 208484561,
        "sender_full_name": "RalfJ",
        "timestamp": 1598792913
    },
    {
        "content": "<p>I understand that, and from the viewpoint that regions are just sets of locations that makes perfect sense</p>",
        "id": 208484584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598792971
    },
    {
        "content": "<p>but another implementation of region disjointness is as inequality constraints on pairs, and I expect LLVM to be using this representation internally</p>",
        "id": 208484631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598793016
    },
    {
        "content": "<p>especially considering that they are mostly used to dealing with C where there are no zero size allocations</p>",
        "id": 208484651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598793062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208484631\">said</a>:</p>\n<blockquote>\n<p>but another implementation of region disjointness is as inequality constraints on pairs, and I expect LLVM to be using this representation internally</p>\n</blockquote>\n<p>I am pretty sure it is not using that representation</p>",
        "id": 208484768,
        "sender_full_name": "RalfJ",
        "timestamp": 1598793251
    },
    {
        "content": "<p>To be more precise, the rule \"<code>[a, b)</code> is disjoint from <code>[c, d)</code> if and only if <code>b &lt; c</code> or <code>d &lt; a</code>\" is true only when <code>a &lt; b</code> and <code>c &lt; d</code>, which is always true for C allocations</p>",
        "id": 208484770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598793254
    },
    {
        "content": "<p>that would be very very incompatible with using <code>noalias</code> on shared references (that have no <code>UnsafeCell</code>)</p>",
        "id": 208484773,
        "sender_full_name": "RalfJ",
        "timestamp": 1598793261
    },
    {
        "content": "<p>not sure if you saw above when I mentioned that</p>",
        "id": 208484774,
        "sender_full_name": "RalfJ",
        "timestamp": 1598793268
    },
    {
        "content": "<p>for LVLM, aliasing is all about whether memory accesses can be reordered</p>",
        "id": 208484782,
        "sender_full_name": "RalfJ",
        "timestamp": 1598793292
    },
    {
        "content": "<p>that's the only thing that actually matters</p>",
        "id": 208484783,
        "sender_full_name": "RalfJ",
        "timestamp": 1598793300
    },
    {
        "content": "<p>(For C <code>restrict</code>, I have seen both claims -- that aliasing pointers are okay when they are left read-only, and that they are not okay.)</p>",
        "id": 208484793,
        "sender_full_name": "RalfJ",
        "timestamp": 1598793328
    },
    {
        "content": "<p>I admit I don't have a good enough grasp on LLVM inner workings to determine how to exploit this possible bug. At this point it's mostly a spec mismatch, which might cause an exploitable problem and might not</p>",
        "id": 208484928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598793501
    },
    {
        "content": "<p>Hm, it looks like rust outsmarted me, and is using <code>bitcast</code> instead of GEP to extract ZST fields of a ZST</p>",
        "id": 208485249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598794090
    },
    {
        "content": "<p>it sometimes does that yes</p>",
        "id": 208485338,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794253
    },
    {
        "content": "<p>when the type from which you project is not actually compiled to a struct in LLVM</p>",
        "id": 208485344,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794266
    },
    {
        "content": "<p>make sure you have more than 2 non-ZST elements in your struct, that should sidestep this</p>",
        "id": 208485353,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794287
    },
    {
        "content": "<p>wait, if it has non-ZST elements then how is it supposed to be a ZST?</p>",
        "id": 208485424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598794391
    },
    {
        "content": "<p>oh I misread, I thought you were going for a ZST field of a non-ZST</p>",
        "id": 208485577,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794613
    },
    {
        "content": "<p>yeah... hm so maybe we already always do a bitcast instead of a GEP? Cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 208485585,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794627
    },
    {
        "content": "<p>what is the relevant context?</p>",
        "id": 208485603,
        "sender_full_name": "eddyb",
        "timestamp": 1598794675
    },
    {
        "content": "<p>when projecting to ZST fields of a ZST, do we always use bitcast? Or do we sometimes use <code>GEPi</code>?</p>",
        "id": 208485654,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794733
    },
    {
        "content": "<p>what's the offset?</p>",
        "id": 208485661,
        "sender_full_name": "eddyb",
        "timestamp": 1598794745
    },
    {
        "content": "<p>necessarily 0?</p>",
        "id": 208485667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598794756
    },
    {
        "content": "<p>how does GEPi with 0 offset meaningfully differ from <code>bitcast</code>?</p>",
        "id": 208485674,
        "sender_full_name": "eddyb",
        "timestamp": 1598794774
    },
    {
        "content": "<p>are we talking about the <code>inbounds</code> part?</p>",
        "id": 208485676,
        "sender_full_name": "eddyb",
        "timestamp": 1598794782
    },
    {
        "content": "<p>yes</p>",
        "id": 208485679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598794786
    },
    {
        "content": "<p>LLVM reads weird validity info from it</p>",
        "id": 208485684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598794800
    },
    {
        "content": "<p>you'd need a LLVM expert</p>",
        "id": 208485685,
        "sender_full_name": "eddyb",
        "timestamp": 1598794800
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> <span class=\"user-mention\" data-user-id=\"133224\">@Nikita Popov</span></p>",
        "id": 208485727,
        "sender_full_name": "eddyb",
        "timestamp": 1598794812
    },
    {
        "content": "<p>using <code>bitcast</code> avoids the silliness around <code>GEP</code> requiring a struct type, but maybe we can just use a noop <code>GEPi</code> followed by a bitcast?</p>",
        "id": 208485740,
        "sender_full_name": "eddyb",
        "timestamp": 1598794876
    },
    {
        "content": "<p>I think we covered the LLVM side -- most people agree LangRef says it differs</p>",
        "id": 208485741,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794876
    },
    {
        "content": "<p>the question is, does <del>LLVM</del> Rust ever emit a <code>GEPi 0</code> on a ZST ref as part of field accesses?</p>",
        "id": 208485750,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794903
    },
    {
        "content": "<p><del>why would LLVM emit LLVM instructions?</del></p>",
        "id": 208485799,
        "sender_full_name": "eddyb",
        "timestamp": 1598794929
    },
    {
        "content": "<p>(oops, I meant rustc)</p>",
        "id": 208485803,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794943
    },
    {
        "content": "<p>to be fair, it does emit this elsewhere, in particular for <code>ptr::offset</code>, so even if we dont do it for fields it doesn't really help that much</p>",
        "id": 208485804,
        "sender_full_name": "RalfJ",
        "timestamp": 1598794945
    },
    {
        "content": "<p>yeah you'll easily hit this for array accesses</p>",
        "id": 208485807,
        "sender_full_name": "eddyb",
        "timestamp": 1598794959
    },
    {
        "content": "<p>is there a reason we <em>shouldn't</em> set <code>inbounds</code> when accessing something inside a ZST?</p>",
        "id": 208485813,
        "sender_full_name": "eddyb",
        "timestamp": 1598794983
    },
    {
        "content": "<p>(i.e. not any ZST field, but specifically a ZST field of a ZST type)</p>",
        "id": 208485818,
        "sender_full_name": "eddyb",
        "timestamp": 1598795001
    },
    {
        "content": "<p>we can probably avoid it if it matters, even for <code>ptr::offset</code>, with the right checks</p>",
        "id": 208485828,
        "sender_full_name": "eddyb",
        "timestamp": 1598795033
    },
    {
        "content": "<p>the problem is that ZSTs were never allocated</p>",
        "id": 208485874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795065
    },
    {
        "content": "<blockquote>\n<p>If the inbounds keyword is present, the result value of the getelementptr is a poison value if the base pointer is not an in bounds address of an allocated object, or if any of the addresses that would be formed by successive addition of the offsets implied by the indices to the base address with infinitely precise signed arithmetic are not an in bounds address of that allocated object.</p>\n</blockquote>",
        "id": 208485883,
        "sender_full_name": "eddyb",
        "timestamp": 1598795089
    },
    {
        "content": "<p>and in particular the standard \"allocator\" for ZSTs can place them inside other allocations</p>",
        "id": 208485887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795100
    },
    {
        "content": "<p>okay I see, I didn't know it had requirements on the base pointer, only on additions</p>",
        "id": 208485890,
        "sender_full_name": "eddyb",
        "timestamp": 1598795103
    },
    {
        "content": "<p>doesn't LLVM replace noop GEPs with <code>bitcast</code>s ASAP?</p>",
        "id": 208485898,
        "sender_full_name": "eddyb",
        "timestamp": 1598795114
    },
    {
        "content": "<p>LLVM tends to replace bitcasts with zero index GEPs.</p>",
        "id": 208485942,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598795164
    },
    {
        "content": "<p>the other way around? wow</p>",
        "id": 208485950,
        "sender_full_name": "eddyb",
        "timestamp": 1598795175
    },
    {
        "content": "<p>Okay, here's the latest version of the test</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#![feature(box_syntax, slice_ptr_range)]</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Field</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[repr(align(0x2000_0000))]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyZST</span><span class=\"p\">(</span><span class=\"n\">Field</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">34</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">29</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Box</span>::<span class=\"n\">leak</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">into_boxed_slice</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">zst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"n\">MyZST</span><span class=\"p\">(</span><span class=\"n\">Field</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">diff</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">zst</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">MyZST</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">zst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">diff</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">big_alloc</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">zst</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">MyZST</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">diff</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">zst2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">zst</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">not_zst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">big_alloc</span><span class=\"p\">[</span><span class=\"n\">diff</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">((</span><span class=\"n\">zst2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">not_zst</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>I suspect that LLVM will be able to prove that the assertion is false</p>",
        "id": 208485957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I mean, as far as ZSTs are concerned, there's \"objects\" between every consecutive pair of bytes (except at address <code>0</code> for null reasons), but I'm not sure LLVM agrees</p>",
        "id": 208485967,
        "sender_full_name": "eddyb",
        "timestamp": 1598795230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133224\">@Nikita Popov</span> but those GEPs are not <code>inbounds</code>, right?</p>",
        "id": 208486048,
        "sender_full_name": "eddyb",
        "timestamp": 1598795381
    },
    {
        "content": "<p>I still haven't figured out how to force a GEPi yet though. Since <code>not_zst</code> is (validly, <code>inbounds</code>) derived from a valid allocation, and <code>zst</code> is marked <code>noalias</code>, LLVM should be able to prove that they are not equal</p>",
        "id": 208486108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> <a href=\"https://github.com/llvm/llvm-project/blob/11cf6346fd49a54cf1f0a8fbf5dee0dab0f4f217/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp#L2543-L2573\">https://github.com/llvm/llvm-project/blob/11cf6346fd49a54cf1f0a8fbf5dee0dab0f4f217/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp#L2543-L2573</a></p>",
        "id": 208486129,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598795503
    },
    {
        "content": "<p>So yes, it's a non-inbounds gep unless we know it's derefable (or null).</p>",
        "id": 208486179,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598795540
    },
    {
        "content": "<p>okay that makes sense</p>",
        "id": 208486184,
        "sender_full_name": "eddyb",
        "timestamp": 1598795552
    },
    {
        "content": "<p>not too happy with it but it's not like it's wrong, and given how much of LLVM relies too much on seeing GEPs, it probably makes sense</p>",
        "id": 208486192,
        "sender_full_name": "eddyb",
        "timestamp": 1598795595
    },
    {
        "content": "<p>but that means that ZST pointers qualify, right?</p>",
        "id": 208486239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795653
    },
    {
        "content": "<p>no, a <code>&amp;Zst</code> argument shouldn't be marked <code>dereferenceable</code></p>",
        "id": 208486250,
        "sender_full_name": "eddyb",
        "timestamp": 1598795682
    },
    {
        "content": "<p><code>%MyZST* noalias nonnull readonly align 536870912 %zst</code></p>",
        "id": 208486309,
        "sender_full_name": "eddyb",
        "timestamp": 1598795770
    },
    {
        "content": "<p>yeah it's not</p>",
        "id": 208486311,
        "sender_full_name": "eddyb",
        "timestamp": 1598795774
    },
    {
        "content": "<p>aha</p>",
        "id": 208486312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795779
    },
    {
        "content": "<p>maybe it should also not be <code>noalias</code>?</p>",
        "id": 208486315,
        "sender_full_name": "eddyb",
        "timestamp": 1598795785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> anyway, like <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> said, try <code>ptr::offset</code></p>",
        "id": 208486319,
        "sender_full_name": "eddyb",
        "timestamp": 1598795799
    },
    {
        "content": "<p>or just indexing <code>array: [Zst; 1]</code> with <code>&amp;array[0]</code></p>",
        "id": 208486327,
        "sender_full_name": "eddyb",
        "timestamp": 1598795827
    },
    {
        "content": "<p>(if that gets folded into a field-like access, use a variable that happens to be <code>0</code>, heh, or pass it as an argument, etc.)</p>",
        "id": 208486345,
        "sender_full_name": "eddyb",
        "timestamp": 1598795874
    },
    {
        "content": "<p>wait I have this right here, I can test that</p>",
        "id": 208486394,
        "sender_full_name": "eddyb",
        "timestamp": 1598795919
    },
    {
        "content": "<p>bingo</p>",
        "id": 208486396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795923
    },
    {
        "content": "<p>the array worked</p>",
        "id": 208486398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598795931
    },
    {
        "content": "<p><a href=\"https://godbolt.org/z/MW86oc\">https://godbolt.org/z/MW86oc</a></p>",
        "id": 208486404,
        "sender_full_name": "eddyb",
        "timestamp": 1598795944
    },
    {
        "content": "<p>it doesn't optimize <code>foo</code> itself, nor <code>main</code> with <code>foo</code> inlined in it</p>",
        "id": 208486419,
        "sender_full_name": "eddyb",
        "timestamp": 1598795999
    },
    {
        "content": "<p>checking with <code>fn main</code> and <code>-O</code> removed, it does emit <code>inbounds</code> for the ZST at first</p>",
        "id": 208486473,
        "sender_full_name": "eddyb",
        "timestamp": 1598796059
    },
    {
        "content": "<p>but then it gets optimized into something simpler. and it doesn't make assumptions based on <code>noalias</code></p>",
        "id": 208486484,
        "sender_full_name": "eddyb",
        "timestamp": 1598796094
    },
    {
        "content": "<p>I highly suspect <code>noalias</code> only matters for accesses, not <code>inbounds</code>, but I have no easy way to prove that. and we can just remove either or both <em>shrug</em></p>",
        "id": 208486496,
        "sender_full_name": "eddyb",
        "timestamp": 1598796117
    },
    {
        "content": "<p>I was using two <code>&amp;mut</code>'s initially but that didn't get the <code>noalias</code></p>",
        "id": 208486543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598796145
    },
    {
        "content": "<p>you need a flag IIRC?</p>",
        "id": 208486554,
        "sender_full_name": "eddyb",
        "timestamp": 1598796159
    },
    {
        "content": "<p>because of another LLVM bug?</p>",
        "id": 208486558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598796178
    },
    {
        "content": "<p><code>-Z mutable-noalias</code></p>",
        "id": 208486571,
        "sender_full_name": "eddyb",
        "timestamp": 1598796216
    },
    {
        "content": "<p>doesn't really change the result though <a href=\"https://godbolt.org/z/Kea8e8\">https://godbolt.org/z/Kea8e8</a></p>",
        "id": 208486576,
        "sender_full_name": "eddyb",
        "timestamp": 1598796234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>  the original question was, what do we have to require for things like <code>slice::from_raw_parts</code>, for empty slices -- or <code>Box::from_raw</code> for ZST? With these <code>GEPi</code> we have to distinguish between <code>Box::&lt;()&gt;::from_raw(4usize as _)</code>, which is fine, and <code>Box::from_raw</code> on a pointer to a memory allocation that has been freed (which is not fine).</p>",
        "id": 208487411,
        "sender_full_name": "RalfJ",
        "timestamp": 1598797516
    },
    {
        "content": "<p>That distinction comes as quite the surprise to most (and in fact so far we fail to properly document it in the <code>ptr</code> module)</p>",
        "id": 208487418,
        "sender_full_name": "RalfJ",
        "timestamp": 1598797537
    },
    {
        "content": "<p>I would require nothing for ZSTs and fix the impl to not tell LLVM lies in those cases, but that's just personal preference</p>",
        "id": 208487487,
        "sender_full_name": "eddyb",
        "timestamp": 1598797598
    },
    {
        "content": "<p>thankfully <code>size_of::&lt;T&gt;() == 0</code> is free in many cases, but I would be worried about <code>ptr::offset(p, dynamically_zero)</code> on a <code>*mut NotZST</code> that happens to be used as a ZST pointer later</p>",
        "id": 208487507,
        "sender_full_name": "eddyb",
        "timestamp": 1598797649
    },
    {
        "content": "<blockquote>\n<p>but I would be worried about ptr::offset(p, dynamically_zero) on a *mut NotZST that happens to be used as a ZST pointer later</p>\n</blockquote>\n<p>exactly that is the case I am also worried about</p>",
        "id": 208487561,
        "sender_full_name": "RalfJ",
        "timestamp": 1598797712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208487487\">said</a>:</p>\n<blockquote>\n<p>I would require nothing for ZSTs and fix the impl to not tell LLVM lies in those cases, but that's just personal preference</p>\n</blockquote>\n<p>if we can make that happen that would be best, yes. (or else convince LLVM to guarantee that <code>GEPi</code>-by-0 is always okay, but that seems unlikely.)<br>\nit's just not clear if we can get there -- and it seems a bit fragile, every single GEPi we emit anywhere must be carefully scrutinized.</p>",
        "id": 208487582,
        "sender_full_name": "RalfJ",
        "timestamp": 1598797784
    },
    {
        "content": "<p>unfortunately <code>offset(i)</code> doesn't work on a ZST type</p>",
        "id": 208487700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598798004
    },
    {
        "content": "<blockquote>\n<p>and Box::from_raw on a pointer to a memory allocation that has been freed (which is not fine).</p>\n</blockquote>\n<p>As in, the ZST address coincides with that pointer, or is actually created from it?</p>",
        "id": 208487703,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598798010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133224\">Nikita Popov</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208487703\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>and Box::from_raw on a pointer to a memory allocation that has been freed (which is not fine).</p>\n</blockquote>\n<p>As in, the ZST address coincides with that pointer, or is actually created from it?</p>\n</blockquote>\n<p>has actually been created from it</p>",
        "id": 208487881,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798220
    },
    {
        "content": "<p>Why would that be legal?</p>",
        "id": 208487896,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598798236
    },
    {
        "content": "<p>why wouldnt it? \"any non-null aligned ptr is a valid ZST reference\" is an easy and sensible principle</p>",
        "id": 208487906,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798262
    },
    {
        "content": "<p>(the \"coincides\" part is something I am worried about even if we tell people that their ZST pointers must \"come from\" constant integers or actual live references)</p>",
        "id": 208487913,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798280
    },
    {
        "content": "<p>a formal semantics of GEPi, such <a href=\"https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf\">as this one</a>, <em>already</em> has to work with \"deferred inbounds checks\", as that is the only way to make GEPi pure and not depend on current memory. So I have a hard time imagining useful optimizations that would be broken by this. but I also don't know what many optimizations so this does not mean all too much. ;)</p>",
        "id": 208487989,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798389
    },
    {
        "content": "<p>Well, you can always put up a review on phab that changes the langref wording and see what people have to say about it :)</p>",
        "id": 208488070,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598798480
    },
    {
        "content": "<p>I imagine the primary appeal of the current spec is that it tells you unconditionally that the gep base is a valid object. You wouldn't get that with a zero offset exception.</p>",
        "id": 208488080,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598798512
    },
    {
        "content": "<p>Okay, finally a GEPi: <a href=\"https://godbolt.org/z/14b934\">https://godbolt.org/z/14b934</a></p>",
        "id": 208488138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598798568
    },
    {
        "content": "<p>still not getting any interesting LLVM optimizations</p>",
        "id": 208488143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598798584
    },
    {
        "content": "<p>Anyway, memory model is very much not my strong suit. Possibly it would be enough to say that \"if the gep base address points to a valid object, then the gep result also points into the same object\" or so, to allow all useful optimizations.</p>",
        "id": 208488283,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598798791
    },
    {
        "content": "<p>At least I imagine that the main thing we really care about is that gep doesn't jump between objects.</p>",
        "id": 208488301,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1598798869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133224\">Nikita Popov</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208488080\">said</a>:</p>\n<blockquote>\n<p>I imagine the primary appeal of the current spec is that it tells you unconditionally that the gep base is a valid object. You wouldn't get that with a zero offset exception.</p>\n</blockquote>\n<p>well, but <code>0x4</code> is allowed as a base for offset 0</p>",
        "id": 208488358,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798923
    },
    {
        "content": "<p>not sure in which useful sense that is a \"valid object\"</p>",
        "id": 208488367,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798930
    },
    {
        "content": "<p>for ZST pointers they just don't need to be valid</p>",
        "id": 208488387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598798970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133224\">Nikita Popov</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208488301\">said</a>:</p>\n<blockquote>\n<p>At least I imagine that the main thing we really care about is that gep doesn't jump between objects.</p>\n</blockquote>\n<p>yeah that is my thinking to. which is why I feel like an exception for the case of offset 0 would make a lot of sense</p>",
        "id": 208488391,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133224\">Nikita Popov</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Box's.20Memory.20layout.20for.20ZSTs/near/208488070\">said</a>:</p>\n<blockquote>\n<p>Well, you can always put up a review on phab that changes the langref wording and see what people have to say about it :)</p>\n</blockquote>\n<p>I have no idea how to ensure that optimizations conform to this stronger spec though^^</p>",
        "id": 208488397,
        "sender_full_name": "RalfJ",
        "timestamp": 1598798990
    },
    {
        "content": "<p>at least in the sense of not dereferenceable</p>",
        "id": 208488398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598798991
    },
    {
        "content": "<p>Wow 180 messages, I didn't think it will start such a big discussion <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 208493438,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598806004
    },
    {
        "content": "<p>I finally opened a PR for clarifying the docs: <a href=\"https://github.com/rust-lang/rust/pull/77844\">https://github.com/rust-lang/rust/pull/77844</a></p>",
        "id": 213009615,
        "sender_full_name": "RalfJ",
        "timestamp": 1602490735
    },
    {
        "content": "<p>Great, i had a boxed zst issue just today actually.</p>",
        "id": 213010354,
        "sender_full_name": "Lokathor",
        "timestamp": 1602491230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> thanks :)</p>",
        "id": 213052459,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1602516259
    }
]