[
    {
        "content": "<p>I was surprised to notice, today, that <code>offset_from</code> is an intrinsic, since the slice iterators demonstrate that it seemingly doesn't <em>need</em> to be one: &lt;<a href=\"https://github.com/rust-lang/rust/blob/e745b4ddbd05026c75aae4506aef39fdfe1603c5/library/core/src/slice/iter/macros.rs#L25-L35\">https://github.com/rust-lang/rust/blob/e745b4ddbd05026c75aae4506aef39fdfe1603c5/library/core/src/slice/iter/macros.rs#L25-L35</a>&gt;</p>\n<p>Am I missing something?  Should the <code>unsigned_offset_from</code> <em>also</em> be an intrinsic?</p>",
        "id": 278262311,
        "sender_full_name": "scottmcm",
        "timestamp": 1649399842
    },
    {
        "content": "<p>That looks to miss a couple of invariants of <code>offset_of</code>. In particular, that looks closer to a <code>wrapping_offset_from</code> then <code>offset_from</code>.</p>",
        "id": 278289098,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649416551
    },
    {
        "content": "<p>Well, it's not really <code>wrapping</code> because it's using <code>sub nuw</code> (and <code>udiv exact</code>) -- which is why it's actually <em>more</em> optimized than the intrinsic, in some cases.</p>\n<p>The primary difference is that it's not explicitly doing a provenance check, but subtracting pointers the way it does is, while not UB, already meaningless without that.  Hmm, I would have thought that the \"you can't do arbitrary things with integers from unrelated pointers\" logic would have caught misuse, but apparently it doesn't: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=04a7cd267657f31b880e4357efccb0de\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=04a7cd267657f31b880e4357efccb0de</a></p>\n<p>So I guess that's a demonstration that it ought to be an intrinsic, and my question is answered <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>(EDIT: Doesn't catch it for heap allocations either, <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=50b7253d3e506d1a2ef1a62e0ff5f17c\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=50b7253d3e506d1a2ef1a62e0ff5f17c</a> )</p>",
        "id": 278325397,
        "sender_full_name": "scottmcm",
        "timestamp": 1649433804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> mostly it is an intrsic so that it can be <code>const fn</code></p>",
        "id": 278353394,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447076
    },
    {
        "content": "<blockquote>\n<p>\"you can't do arbitrary things with integers from unrelated pointers\" logic</p>\n</blockquote>\n<p>not sure which logic you are referring to here</p>",
        "id": 278353486,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447139
    },
    {
        "content": "<p>integers from pointers are just integers. you can do with them whatever you can do with all integers.</p>",
        "id": 278353512,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447154
    },
    {
        "content": "<p>I guess I was thinking the CTFE execution model had something it doesn't.</p>\n<p>But being <code>const</code> and having better precondition checking both seem like good reasons for this being an intrinsic.</p>",
        "id": 278358030,
        "sender_full_name": "scottmcm",
        "timestamp": 1649449643
    },
    {
        "content": "<p>better precondition checking in Miri, you mean?</p>",
        "id": 278358129,
        "sender_full_name": "RalfJ",
        "timestamp": 1649449687
    },
    {
        "content": "<p>for codegen nothing is checked^^</p>",
        "id": 278358135,
        "sender_full_name": "RalfJ",
        "timestamp": 1649449692
    },
    {
        "content": "<p>yes, in miri/ctfe.</p>",
        "id": 278358272,
        "sender_full_name": "scottmcm",
        "timestamp": 1649449783
    },
    {
        "content": "<p>speaking of offset_from, also see <a href=\"https://github.com/rust-lang/rust/issues/92512\">https://github.com/rust-lang/rust/issues/92512</a> -- I would like to slightly weaken its precondition</p>",
        "id": 278359072,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450229
    },
    {
        "content": "<p>for the goal of having an operation that works in CTFE, it is slightly stronger than required</p>",
        "id": 278359103,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450247
    },
    {
        "content": "<p>Oh, to make it just require same provenance, not <code>inbounds</code>?</p>",
        "id": 278359995,
        "sender_full_name": "scottmcm",
        "timestamp": 1649450735
    },
    {
        "content": "<p>yes</p>",
        "id": 278360133,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450808
    },
    {
        "content": "<p>I think this would be required to use this operation in slice iterators</p>",
        "id": 278360152,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450828
    },
    {
        "content": "<p>where for the ZST case, dangling raw pointers are used</p>",
        "id": 278360175,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450841
    },
    {
        "content": "<p>But <code>offset_from</code> doesn't work for ZSTs anyway, since it contains the <code>div exact</code> by size -- the slice iterators have a different code path for ZSTs that does something else.</p>",
        "id": 278360273,
        "sender_full_name": "scottmcm",
        "timestamp": 1649450892
    },
    {
        "content": "<p>you still have to cast to a different ptr type, yes</p>",
        "id": 278360289,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450912
    },
    {
        "content": "<p>but that's possible in <code>const</code></p>",
        "id": 278360296,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450916
    },
    {
        "content": "<p>casting to an integer and subtracting there is not ;)</p>",
        "id": 278360315,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450927
    },
    {
        "content": "<p>Hmm, and I guess it's unlikely that the inbounds restriction would actually be anything useful to communicate to the optimizer anyway, since it's not like it can avoid the subtraction or anything using it.</p>",
        "id": 278360709,
        "sender_full_name": "scottmcm",
        "timestamp": 1649451160
    },
    {
        "content": "<p>The \"no wrapping the address space\" and \"no more than isize::MAX\" bytes are the important parts for anything that could really help understand the resulting value.</p>",
        "id": 278361514,
        "sender_full_name": "scottmcm",
        "timestamp": 1649451589
    },
    {
        "content": "<p>yeah</p>",
        "id": 278362847,
        "sender_full_name": "RalfJ",
        "timestamp": 1649452300
    },
    {
        "content": "<p>as a case in point, the only formal version of this intrinsic I am aware of is <code>ptrdiff</code> in the <a href=\"https://www.ralfj.de/research/twinsem/twinsem.pdf\">LLVM twinsem</a> paper and it does not have that inbounds restriction either. it does show that this intrinsic is useful to avoid considering pointers as \"escaped\" during alias analysis.</p>",
        "id": 278362947,
        "sender_full_name": "RalfJ",
        "timestamp": 1649452356
    },
    {
        "content": "<p>Hmm, actually, it's not obvious to me that provenance is exactly the right thing here either.</p>\n<p>If I were to <code>.with_addr</code> to launder a provenance to match, I still shouldn't be able to <code>offset_from</code> between different locals, right?</p>",
        "id": 278363270,
        "sender_full_name": "scottmcm",
        "timestamp": 1649452567
    },
    {
        "content": "<p>why not?</p>",
        "id": 278363870,
        "sender_full_name": "RalfJ",
        "timestamp": 1649452856
    },
    {
        "content": "<p>in CTFE, <code>addr</code> doesn't work, so you cant use tricks like that</p>",
        "id": 278364019,
        "sender_full_name": "RalfJ",
        "timestamp": 1649452940
    },
    {
        "content": "<p>for alias analysis, it'd be very syntactically obvious which two pointers flowed into this computation so all should be fine. (that LLVM twinsem model has <code>getelementptr</code> without <code>inbound</code>, so <code>with_addr</code> is expressible)</p>",
        "id": 278364157,
        "sender_full_name": "RalfJ",
        "timestamp": 1649453038
    },
    {
        "content": "<p>I guess I was expecting the C++ rule that it's UB to do things like that (at least I think that's their rule?), but I guess we're willing to say that you can't <em>rely</em> on it, even though you can compute it?</p>",
        "id": 278365692,
        "sender_full_name": "scottmcm",
        "timestamp": 1649454044
    },
    {
        "content": "<p>well we already differ from C++ in that you can <code>==</code> and even <code>&lt;</code> compare arbitrary pointers (including dangling pointers) in safe code</p>",
        "id": 278379872,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467514
    },
    {
        "content": "<p>If you spell <code>a &lt; b</code> as <code>std::less&lt;void*&gt;()(a, b)</code> you can do that in C++ too.</p>",
        "id": 278381909,
        "sender_full_name": "scottmcm",
        "timestamp": 1649470312
    },
    {
        "content": "<p>ah fair. in C I think you cannot though?</p>",
        "id": 278381978,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470424
    },
    {
        "content": "<p>C has <code>==</code> but not <code>&lt;</code> unless you cast to uintptr_t (not well-behaved <code>&lt;</code>, that is)</p>",
        "id": 278382109,
        "sender_full_name": "Talchas",
        "timestamp": 1649470568
    },
    {
        "content": "<p>and <code>==</code> sometimes produces \"indeterminate\" results which might mean it is UB to <code>if</code> on them</p>",
        "id": 278382143,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470650
    },
    {
        "content": "<p>or was that C++? I keep mixing that up</p>",
        "id": 278382154,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470662
    },
    {
        "content": "<p>no, even C11 says \"compare equal if and only if....\"</p>",
        "id": 278382195,
        "sender_full_name": "Talchas",
        "timestamp": 1649470683
    },
    {
        "content": "<p>it might be C++, haven't checked its wording</p>",
        "id": 278382200,
        "sender_full_name": "Talchas",
        "timestamp": 1649470694
    },
    {
        "content": "<p>(or might have been C99, since I do vaguely recall == being screwy, and don't know if it was C++ or just &lt;)</p>",
        "id": 278382207,
        "sender_full_name": "Talchas",
        "timestamp": 1649470727
    },
    {
        "content": "<blockquote>\n<p>Two pointers compare equal if and only if both are null pointers, both are pointers to the<br>\nsame object (including a pointer to an object and a subobject at its beginning) or function,<br>\nboth are pointers to one past the last element of the same array object, or one is a pointer<br>\nto one past the end of one array object and the other is a pointer to the start of a different<br>\narray object that happens to immediately follow the first array object in the address<br>\nspace.109)</p>\n</blockquote>",
        "id": 278383052,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649471985
    },
    {
        "content": "<p>(PR out adding <code>unsigned_offset_from</code>: <a href=\"https://github.com/rust-lang/rust/pull/95837\">https://github.com/rust-lang/rust/pull/95837</a> )</p>",
        "id": 278397166,
        "sender_full_name": "scottmcm",
        "timestamp": 1649493326
    }
]