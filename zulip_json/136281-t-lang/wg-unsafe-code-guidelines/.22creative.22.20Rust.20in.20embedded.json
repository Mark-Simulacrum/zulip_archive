[
    {
        "content": "<p>and likewise I think using a numeric hex literal to declare an address you want to poke at, that you know is there to interact with because you <strong>read it in the manual</strong>, is fine.</p>",
        "id": 274062605,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274062525\">said</a>:</p>\n<blockquote>\n<p>well...in embedded, there may not be a way to do out-of-process debugging</p>\n</blockquote>\n<p>in-process debugging is a recipe for the compiler tearing your code to shreds. Everything to do with it. Entirely.</p>",
        "id": 274062629,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354342
    },
    {
        "content": "<p>embedded has JTAG dunnit</p>",
        "id": 274062642,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354357
    },
    {
        "content": "<p>crazy idea: <code>usize::try_into(_): *const T</code></p>",
        "id": 274062645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646354359
    },
    {
        "content": "<p>heheh</p>",
        "id": 274062659,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354375
    },
    {
        "content": "<p>Unrelated to whether or not <code>usize</code> and <code>*const T</code> are the same size.</p>",
        "id": 274062663,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354380
    },
    {
        "content": "<p>what if your jtag is soldered to ground, making it in-accessible?</p>",
        "id": 274062672,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274062605\">said</a>:</p>\n<blockquote>\n<p>and likewise I think using a numeric hex literal to declare an address you want to poke at, that you know is there to interact with because you <strong>read it in the manual</strong>, is fine.</p>\n</blockquote>\n<p>Yes, as long as it's not memory the compiler controls.</p>",
        "id": 274062685,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354400
    },
    {
        "content": "<p>yeah, sorry, i've veered well off-topic</p>",
        "id": 274062745,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274062672\">said</a>:</p>\n<blockquote>\n<p>what if your jtag is soldered to ground, making it in-accessible?</p>\n</blockquote>\n<p><del>buy better tools</del></p>",
        "id": 274062766,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354445
    },
    {
        "content": "<p>&lt;_&lt;</p>",
        "id": 274062784,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274062672\">said</a>:</p>\n<blockquote>\n<p>what if your jtag is soldered to ground, making it in-accessible?</p>\n</blockquote>\n<p>blackbox debugger time</p>",
        "id": 274062795,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354470
    },
    {
        "content": "<p>in-process debugger to the rescue!</p>",
        "id": 274062833,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354502
    },
    {
        "content": "<p>also, there are cpus without any debugging hardware whatsoever</p>",
        "id": 274062921,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354551
    },
    {
        "content": "<p>I am aware and their creators should be uninvited from making more hardware.</p>",
        "id": 274062938,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354570
    },
    {
        "content": "<p>well...</p>",
        "id": 274062954,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354585
    },
    {
        "content": "<p><a href=\"https://github.com/programmerjake/rv32\">https://github.com/programmerjake/rv32</a></p>",
        "id": 274062957,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354588
    },
    {
        "content": "<p>AHA</p>",
        "id": 274062974,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354606
    },
    {
        "content": "<p>no debugging hardware cuz i ran out of time before finals</p>",
        "id": 274062979,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354610
    },
    {
        "content": "<p>THE CRIMINAL IS THEE</p>",
        "id": 274062980,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354611
    },
    {
        "content": "<p>well I suppose that's fair.</p>",
        "id": 274062985,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354617
    },
    {
        "content": "<p>but that's just going to be simulated / FPGA'd anyways</p>",
        "id": 274063051,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354646
    },
    {
        "content": "<p>fpgas don't necessarily let you access their internals...</p>",
        "id": 274063082,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354673
    },
    {
        "content": "<p>You're not shipping that to customers. If you are, we are going to have to have a talk.</p>",
        "id": 274063088,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354678
    },
    {
        "content": "<p>instructors can be customers...</p>",
        "id": 274063101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646354696
    },
    {
        "content": "<p>Maybe fork this discussion?</p>",
        "id": 274063125,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354711
    },
    {
        "content": "<p>what about the riscv core embedded in some dram controller, where there is no debugger cuz that takes too much space?</p>",
        "id": 274063153,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354746
    },
    {
        "content": "<p>done.</p>",
        "id": 274063213,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354770
    },
    {
        "content": "<p>That reminds me, I need debugging lines in the Clever-ISA hardware reference.</p>",
        "id": 274063261,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354818
    },
    {
        "content": "<blockquote>\n<p>Maybe fork this discussion?</p>\n</blockquote>\n<p>yeah, sorry, afaict i don't have the required privileges to move existing messages to a new discussion... <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> do you?</p>",
        "id": 274063391,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354907
    },
    {
        "content": "<p>refresh your Zulip.</p>",
        "id": 274063419,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354938
    },
    {
        "content": "<p>anyone can edit topics</p>",
        "id": 274063439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646354961
    },
    {
        "content": "<p>moving streams requires fancy permissions</p>",
        "id": 274063449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646354973
    },
    {
        "content": "<p>thx!</p>",
        "id": 274063587,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646355060
    },
    {
        "content": "<p>It was mentioned that \"magic linker symbols\" can do this (pointers to non-rust memory), and strictly speaking they can, but I do wonder how much optimization that will kill.</p>",
        "id": 274075394,
        "sender_full_name": "Lokathor",
        "timestamp": 1646364605
    },
    {
        "content": "<p>I mean, no more than any other external static.</p>",
        "id": 274075585,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646364654
    },
    {
        "content": "<p>(SIde note, if people want to see creative, wait until I support z80/8080 in lccc <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>)</p>",
        "id": 274075820,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646364918
    },
    {
        "content": "<p>(Disclaimer: may not actually happen)</p>",
        "id": 274075853,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646364960
    },
    {
        "content": "<p>well, you could probably get a working rustc for z80, using this wip z80 backend for llvm (idk how far along it is though): <a href=\"https://github.com/jacobly0/llvm-project/wiki\">https://github.com/jacobly0/llvm-project/wiki</a></p>",
        "id": 274076333,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646365429
    },
    {
        "content": "<blockquote>\n<p>I mean, no more than any other external static.</p>\n</blockquote>\n<p>Yes, exactly. However if you're targeting a particular device you can instead use constants, and then the compiler has the chance to optimize them the same as any other math.</p>",
        "id": 274141831,
        "sender_full_name": "Lokathor",
        "timestamp": 1646406458
    },
    {
        "content": "<p>Right. It may be a magic linker symbol but there's no reason you can't be asking the compiler to generate it and to specially take it into account.</p>",
        "id": 274167620,
        "sender_full_name": "Jubilee",
        "timestamp": 1646417550
    },
    {
        "content": "<p>Also, in a lot of cases, the lookup can simply be moved to link time, by encoding an addend to the relocation.</p>",
        "id": 274170736,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646418942
    },
    {
        "content": "<p>I'm not clear on what case you're imagining.</p>\n<p>I'm thinking of a case where the compiler would see that you access several locations that <em>it turns out</em> happen to all be within a few bytes of each other. Then the compiler can put the lowest value in a register and access the others via an offset, which can free up some registers, which can prevent pushing to the stack.</p>\n<p>If that location info was held back until link time then the linker can substitute in the value but it (likely) cannot go and reassess the register usage for the entire function.</p>",
        "id": 274173336,
        "sender_full_name": "Lokathor",
        "timestamp": 1646420120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.22creative.22.20Rust.20in.20embedded/near/274173336\">said</a>:</p>\n<blockquote>\n<p>I'm not clear on what case you're imagining.</p>\n</blockquote>\n<p>At least <strong>I</strong> am imagining that there's a macro or attribute or something that ideally creates a symbol that the entire compiler toolchain becomes aware of as meaning that it denotes a Special Place that you want a pointer to and it should be Allowed in spite of it possibly otherwise bending the rules of Rust, and that would allow the compiler to do the reasoning you are talking about and make sure everywhere else in the program also participates in that reasoning.</p>",
        "id": 274174857,
        "sender_full_name": "Jubilee",
        "timestamp": 1646420779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.22creative.22.20Rust.20in.20embedded/near/274060768\">said</a>:</p>\n<blockquote>\n<p>there are also cases where I need <code>0x12345678 as *mut T</code>, mostly for embedded stuff</p>\n</blockquote>\n<p>yes that is why I keep repeating all the time that it is the int2ptr cast <em>in a ptr2int2ptr roundtrip</em> that is causing trouble.<br>\ncasting a fixed address <em>that is disjoint from all the memory the abstract machine knows about</em> is totally fine. Basically, <code>0x12345678 as *mut T</code> is like a call to <code>malloc</code> where you already know the result. it synthesizes a fresh provenance, and crucially this pointer <em>may not be used to access any memory with any other provenance</em>.</p>",
        "id": 274254836,
        "sender_full_name": "RalfJ",
        "timestamp": 1646500938
    },
    {
        "content": "<p>Is there any concrete guidance somewhere on what users <em>should</em> be doing? This discussion is making me quite concerned about one of the projects I'm working on, which is basically a tiny OS that needs to manage its own memory, and if I wanted to bring up these concerns to people I would need something specific to point at</p>",
        "id": 274255452,
        "sender_full_name": "bstrie",
        "timestamp": 1646501653
    },
    {
        "content": "<p>well, we are still figuring that out...</p>",
        "id": 274255963,
        "sender_full_name": "RalfJ",
        "timestamp": 1646502286
    },
    {
        "content": "<p>meanwhile I would say the more you can avoid int2ptr roundtrip casts and instead work with an <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a2f5075d11a23222e95d3dee844beaac\">API like this</a>, the better -- but there's tons of low-level code out there that does int2ptr roundtrip casts and there's probably more important things to worry about in unsafe code...</p>",
        "id": 274256140,
        "sender_full_name": "RalfJ",
        "timestamp": 1646502591
    },
    {
        "content": "<p>Interesting perspective, to call it a weird form of <code>malloc</code>. Could this be explicit? In the sense of platform/arch specific functions such as<br>\n<code>unsafe fn arch::x86::new_virtual_address(addr: usize, len: usize) -&gt; *const [u8]</code><br>\nas it allows us to invent any address if we just write a number to a page table. And some architecture might miss similar functions, have alternatives for mmio wherever llvm makes a difference, if they have non-usize-sized pointers, if it's fallible.</p>",
        "id": 275838497,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1647625400
    },
    {
        "content": "<p>I'm unclear what benefits that would give to the programmer compared to the current system. Does that function give me more assurances, or have some sort of debug mode check, or anything like that?</p>",
        "id": 275840525,
        "sender_full_name": "Lokathor",
        "timestamp": 1647626331
    },
    {
        "content": "<p>it makes more explicit what happens and lets us avoid <code>as</code></p>",
        "id": 275845060,
        "sender_full_name": "RalfJ",
        "timestamp": 1647628540
    },
    {
        "content": "<p>so it's somewhat similar in spirit to avoiding <code>as</code> in other tricky situations (like lossy casts)</p>",
        "id": 275845097,
        "sender_full_name": "RalfJ",
        "timestamp": 1647628557
    },
    {
        "content": "<p>Two main differences: it's <code>unsafe</code>, with case-by-case documented preconditions. That provides a decent incentive to transition implementations away from the generic and (probably) improper safe <code>as</code> usage by providing an alternative. At the same time, similar to <code>size_of_val_raw</code> being underdefined, it could be explicit where Rust has and where it has not stabilized defined semantics.<br>\nSecondly, some platforms may consume two arguments where <code>as</code> is inherently a unary operator. The showcased  <code>len</code> argument could be a helpful opt-in assertion by the programmer that's consumed in MIR or hardware provenance tracking, without needing to resort to dynamic usage analysis or a tag with unbounded access.</p>",
        "id": 275849673,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1647630755
    },
    {
        "content": "<p>Another not so important one in terms of soundess, at least as far as I can tell: by providing it in <code>arch::</code> (or another submodule) it becomes immediately obvious that such code is highly dependent on the hardware. And it will fail to compile on platforms that couldn't provide a sound, generic int2ptr. (Random thought: are there any scenarios where we could have a sound <code>const fn addr_to_static(???) -&gt; *const </code> in any shape of form, such as by linker tricks?)</p>",
        "id": 275850149,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1647630997
    },
    {
        "content": "<p>my understanding is that const evaluation happens within the object file generation phase, and static addresses aren't selected until linking.</p>",
        "id": 275851999,
        "sender_full_name": "Lokathor",
        "timestamp": 1647631916
    },
    {
        "content": "<p>To go back a point or two though, I don't view a function call as any more explicit than <code>as</code>. It's just an expression that does something, and the way you type it doesn't really affect the amount of visible explicitness (in my mind).</p>\n<p>I am very interested in what the documentation would be for these pre-conditions would say.</p>",
        "id": 275852533,
        "sender_full_name": "Lokathor",
        "timestamp": 1647632176
    },
    {
        "content": "<p>I think it actually would be postconditions since the <code>unsafe</code> would be the dereferencing or similar functions.<br>\n\"Give this a static address and you get a pointer. Using it to push data in or out is probably <code>unsafe</code>!\"</p>",
        "id": 275853225,
        "sender_full_name": "Jubilee",
        "timestamp": 1647632552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.22creative.22.20Rust.20in.20embedded/near/275852533\">said</a>:</p>\n<blockquote>\n<p>To go back a point or two though, I don't view a function call as any more explicit than <code>as</code>. It's just an expression that does something, and the way you type it doesn't really affect the amount of visible explicitness (in my mind).</p>\n<p>I am very interested in what the documentation would be for these pre-conditions would say.</p>\n</blockquote>\n<p>functions have (sometimes evocative) names, which IMO makes them a lot more explicit than <code>as</code>. <code>as</code> says nothing about what is converted to what and how.<br>\nwe also have things like <code>cast</code> on pointers as an explicitly named alternative to <code>as</code>. and that is useful, e.g. it avoids accidentally casting a const raw ptr to/from a mutable raw ptr.</p>",
        "id": 275853563,
        "sender_full_name": "RalfJ",
        "timestamp": 1647632762
    },
    {
        "content": "<p>The obvious would be the non-arch-specific, that we could introduce in conformance with LLVM.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// # Safety</span>\n<span class=\"sd\">/// The argument must be a value created directly from a cast pointer-to-usize.</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">from_ptr_addr</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This is rather restrictive in usage but allows to transition those casts which we all deem inherently sound away from <code>as</code>, freeing up some budget for the semantics of <code>as</code> implementation. At least conceptually. But other functions may perform their pointer cast with explicitly different methods, e.g. cast through non-integral pointers whenever LLVM actually agrees on what that means</p>",
        "id": 275853647,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1647632789
    },
    {
        "content": "<p>Doing this via explicit functions gets an explicit affirmation by the programmer that those are the semantics that they meant to assert. This is better than <code>as</code> which must be generic enough to cover all possible uses. This hurts the optimizer. The previously mentioned alloc-semantics can't be implemented with as because it can not assume non-aliasing (by itself). A new <code>unsafe fn</code> could have a precondition that requires non-aliasing with any existing pointers (exact semantics to be determined, this one might be too strict).</p>",
        "id": 275853949,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1647632972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229913\">HeroicKatora</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.22creative.22.20Rust.20in.20embedded/near/275853647\">said</a>:</p>\n<blockquote>\n<p>The obvious would be the non-arch-specific, that we could introduce in conformance with LLVM.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// # Safety</span>\n<span class=\"sd\">/// The argument must be a value created directly from a cast pointer-to-usize.</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">from_ptr_addr</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This is rather restrictive in usage but allows to transition those casts which we all deem inherently sound away from <code>as</code>, freeing up some budget for the semantics of <code>as</code> implementation. At least conceptually. But other functions may perform their pointer cast with explicitly different methods, e.g. cast through non-integral pointers whenever LLVM actually agrees on what that means</p>\n</blockquote>\n<p>that is exactly the kind of roundtrip we are hoping to discourage though :)</p>",
        "id": 275854966,
        "sender_full_name": "RalfJ",
        "timestamp": 1647633535
    },
    {
        "content": "<p>yeah that <code>fn</code> is not fun for mmio.</p>",
        "id": 275859212,
        "sender_full_name": "Lokathor",
        "timestamp": 1647635585
    },
    {
        "content": "<p>Discouarging is fine, and I do believe this would actually help with that. The motivating case of known external address could not soundly use this function; by design. Because conversely, whatever means we would add to permit MMIO can be forbidden to be used for ptr2int2ptr. This ties into the post-condition interpretation: currently the optimizer-known post-conditions of int2ptr-<code>as</code> is the union of all those different ways of divining a pointer, because there is no way to introspect between the cases in the virtual machine—effectively though this implies there are no known post-conditions. </p>\n<p>For the set of argument-output pairs, we'd like to restrict it to a dependent sum of 'ways to create pointers' to 'some post condition of the so-created pointer result' but with <code>as</code> in its form there is no way to reliably <em>distinguish</em> between the input cases in the VM semantics (as integers don't get provenance). And so we can approximate this set only as the cross product of all inputs/outputs—which provides no useful information. What I'm asking with different functions is for the <em>programmer</em> to do (at least part of) this case distinction for us.</p>\n<p>Doesn't it get significantly easier to add more restrictive and proper MIR/LLVM treatment (and semantics) to at least some of non-ptr2int2ptr cases if the separate use-cases go through different symbols and intrinsics? Can't different symbols also be linted differently, with regards to discouraging/edition changes? The hypothetical <code>unsafe fn alloc_from_mmio(usize) -&gt; *const u8</code> (with little regard to semantics) could actually be allowed to have post-conditions. For example, 'the pointer mustn't alias any existing pointer.'.</p>",
        "id": 275861657,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1647637028
    },
    {
        "content": "<p>I see these functions as having a distinction w/o a difference under PVNI-ae.</p>",
        "id": 275862286,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647637332
    },
    {
        "content": "<blockquote>\n<p>Doesn't it get significantly easier to add more restrictive and proper MIR/LLVM treatment (and semantics) to at least some of non-ptr2int2ptr cases if the separate use-cases go through different symbols and intrinsics?</p>\n</blockquote>\n<p>Not really... the moment roundtrips exist at all, it doesn't matter how they are exposed. they infect everything.</p>",
        "id": 275862425,
        "sender_full_name": "RalfJ",
        "timestamp": 1647637423
    },
    {
        "content": "<p>I can't see either function being implemented uniquely on lccc at least, and I'd imagine a similar story from llvm and gcc.</p>",
        "id": 275862434,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647637429
    },
    {
        "content": "<p>So you'd have undefined behaviour for the sake of being pedantic about this distinction.</p>",
        "id": 275862540,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647637465
    },
    {
        "content": "<p>or we'd have UB for the sake of a sane future we might one day be able to wake up in</p>",
        "id": 275862786,
        "sender_full_name": "RalfJ",
        "timestamp": 1647637605
    },
    {
        "content": "<p>Alas, unless you can convice WG14 and WG21 to break a ton of legacy C and C++ code, I doubt that future will ever come, at least for the three I mentioned.</p>",
        "id": 275863008,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647637738
    },
    {
        "content": "<p>Although I suppose rust implementation <em>foo</em> could exploit the UB by virtue of solely being a rust implementation.</p>",
        "id": 275863138,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647637818
    },
    {
        "content": "<p>if GCC/LLVM ever sort out their mess here I am curious how the result will look. but I wouldn't want to bet the sanity of a Rust spec on that happening any time soon... (and no, PNVI is not enough, it fails to account for <code>restrict</code> which makes everything a lot more complicated)</p>",
        "id": 275924619,
        "sender_full_name": "RalfJ",
        "timestamp": 1647716806
    },
    {
        "content": "<p>I still would like to hear a more full example of how <code>restrict</code> breaks PNVI! Even though I agree.</p>",
        "id": 275986410,
        "sender_full_name": "Jubilee",
        "timestamp": 1647808627
    }
]