[
    {
        "content": "<p>I would like to continue <a href=\"https://github.com/rust-lang/rust/issues/95228\">95228</a> here. </p>\n<p><span class=\"user-mention\" data-user-id=\"295632\">@Diggsey</span> <a href=\"https://github.com/rust-lang/rust/issues/95228#issuecomment-1084672019\">wrote</a>:</p>\n<blockquote>\n<p>Right, I think we'd still want to be clear that (assuming this all goes through) we think the strict provenance model is the future - that it's something that all crates should aspire to support, but it at least gives us a way to guarantee that existing code can continue to work.</p>\n</blockquote>\n<p>I see it differently ‚Äî I want <code>strict</code> to be the default in some future edition, with PNVI-whatever still supported.</p>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <a href=\"https://github.com/rust-lang/rust/issues/95228#issuecomment-1084651137\">wrote</a>:</p>\n<blockquote>\n<p>Strict provenance is a memory model question, which means it is a global choice.</p>\n</blockquote>\n<p>Specifying a Rust with strict_provenance semantics would be much <del>harder</del> easier than one with PNVI semantics ‚Äî am I understanding that correctly?</p>\n<hr>\n<p>If C/Clang/LLVM adopt PNVI-AE-*, then I suspect we can simply add a non-exposing <code>ptr2int</code> to LLVM IR. That is, we don't vary the optimization passes, but the optimization passes \"know\" where they are safe to apply and where they aren't safe to apply.</p>\n<p>Then</p>\n<ul>\n<li>we get miri / formal specifications for devs who put in the work to avoid <code>ptr2int2ptr</code> altogether</li>\n<li>the ecosystem can use <code>ptr2int2ptr</code></li>\n<li>in practice we get all the speed of <code>strict</code></li>\n<li>CHERI works for everyone</li>\n<li>Rust-on-CHERI has negligible performance overhead for devs who put in the work to avoid <code>ptr2int2ptr</code> altogether</li>\n</ul>",
        "id": 277295704,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648739314
    },
    {
        "content": "<p>I'm proposing that Rust (the standard that defines execution for programs) would have two logical memory models:</p>\n<ul>\n<li><code>strict</code>, which is used when all crates have <code>ptr2int2ptr = false</code>, and which we aim to formally specify</li>\n<li><code>pnvi</code>, which is used otherwise, and which may be infeasible to formally specify.</li>\n</ul>\n<p>As I understand it, execution of a <code>strict</code> program without UB is faithfully mimiced by execution of the same program under <code>pnvi</code> semantics.</p>",
        "id": 277297327,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648739998
    },
    {
        "content": "<blockquote>\n<p>Specifying a Rust with strict_provenance semantics would be much harder than one with PNVI semantics ‚Äî am I understanding that correctly?</p>\n</blockquote>\n<p>No, its the other way around. strict provenance makes specifying things a lot simpler.</p>",
        "id": 277300872,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741389
    },
    {
        "content": "<p>I dont think we can use PNVI for anything, it's designed for C</p>",
        "id": 277300953,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741428
    },
    {
        "content": "<p>Yes, that‚Äôs what I meant =)</p>",
        "id": 277300957,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648741429
    },
    {
        "content": "<p>unless you mean PNVI in the broad sense of \"models that support ptr2int2ptr\"^^ (while integers themselves do not have provenance)</p>",
        "id": 277301025,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741445
    },
    {
        "content": "<p>but the Rust version of that will look very different from the PNVI proposals I think</p>",
        "id": 277301048,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741456
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>üèª some people like to do evil inttoptr tricks. If some people can identify C with PVNI Rust, the barrier to adoption becomes lower</p>",
        "id": 277301122,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648741490
    },
    {
        "content": "<p>PNVI is a great proposal for C, but</p>\n<ul>\n<li>it relies on strict aliasing</li>\n<li>it is currently incompatible with LLVM</li>\n</ul>\n<p>as long as those remain open, I dont think it is a useful model for Rust</p>",
        "id": 277301240,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741556
    },
    {
        "content": "<p>Or maybe some people need e.g. pointer compression for some application</p>",
        "id": 277301245,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648741558
    },
    {
        "content": "<p>I think we can have int2ptr2int in a Rust way and we shouldnt just copy what C does</p>",
        "id": 277301326,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741586
    },
    {
        "content": "<p>I think we pretty much agree. I want mostly the strict_provenance execution model. I just want it in a way that integrates okay with old / loose code (you just lose all the formal specification)</p>",
        "id": 277301422,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648741628
    },
    {
        "content": "<p>so, like <a href=\"https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392\">https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392</a> ? ;)</p>",
        "id": 277301504,
        "sender_full_name": "RalfJ",
        "timestamp": 1648741670
    },
    {
        "content": "<p>Pretty much! But (assuming LLVM will switch to PNVI) I want extra optimizations as well that are opt-in per crate.</p>",
        "id": 277301963,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648741869
    },
    {
        "content": "<p>Opt-in per crate doesn't really work though, since Rust will inline things from one crate into another crate, and really relies on this for zero-cost abstractions to work.</p>",
        "id": 277302112,
        "sender_full_name": "comex",
        "timestamp": 1648741925
    },
    {
        "content": "<p>Not to mention the issue of cross-language LTO.</p>",
        "id": 277302124,
        "sender_full_name": "comex",
        "timestamp": 1648741933
    },
    {
        "content": "<p>Opt-in per crate would be more about opt-in within in the ecosystem, than within a program. Crate authors could opt in, or not, and then people wanting to use the stricter model at runtime would need to ensure all their dependencies opt in, so that the whole program agrees.</p>",
        "id": 277302496,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648742108
    },
    {
        "content": "<p>It‚Äôs not obvious to me that it can‚Äôt work. We could vary the meaning of ptrtoint (in terms of its lowering to LLVM IR) as per my GitHub comment</p>",
        "id": 277302584,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648742152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277301326\">said</a>:</p>\n<blockquote>\n<p>I think we can have int2ptr2int in a Rust way and we shouldnt just copy what C does</p>\n</blockquote>\n<p>What about ptr2int2ptr?</p>\n<p>I think int2ptr2int basically has to work, since it's doable from fully safe code -- maybe we can say it's nondeterministic, but that would honestly be very surprising.</p>",
        "id": 277302591,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648742156
    },
    {
        "content": "<p>To expose its input only when the crate is PVNI</p>",
        "id": 277302670,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648742171
    },
    {
        "content": "<p>This is assuming C/C++ settle on some variant of PVNI-AE</p>",
        "id": 277302722,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648742198
    },
    {
        "content": "<p>If we're going to do that, it doesn't need to be a per-crate flag.  We could just say that \"<code>.addr()</code> doesn't expose its input, but legacy <code>as usize</code> does\".</p>",
        "id": 277302823,
        "sender_full_name": "comex",
        "timestamp": 1648742246
    },
    {
        "content": "<p>Ah, yes. Very nice</p>",
        "id": 277303208,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648742412
    },
    {
        "content": "<blockquote>\n<p>What about ptr2int2ptr? I think int2ptr2int basically has to work, since it's doable from fully safe code -- maybe we can say it's nondeterministic, but that would honestly be very surprising.</p>\n</blockquote>\n<p>What do you mean by \"work\"? You certainly can't dereference pointers in safe code, and the UB here is only when you dereference a pointer - you can still create invalid pointers under strict provenance.</p>",
        "id": 277303660,
        "sender_full_name": "Diggsey",
        "timestamp": 1648742537
    },
    {
        "content": "<p>I guess we all agree that int2ptr2int is fine (cannot cause UB). I think we also agree that you should get the original int back (‚Äúdeterministic‚Äù?).</p>\n<p>IIUC we‚Äôre trying to make ptr2int2ptr work in certain cases for code that cannot be strict.</p>",
        "id": 277304298,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648742812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> </p>\n<blockquote>\n<p>so, like <a href=\"https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392\">https://github.com/rust-lang/rust/issues/95228#issuecomment-1084037392</a> ? ;)</p>\n</blockquote>\n<p>That certainly makes sense to me as the \"most incremental\" step that could be taken next, and it allows us to answer the question \"is this unsafe code sound?\" with a definite \"yes\" in more cases, but it doesn't help answer the question \"is this optimization pass sound?\" with a \"yes\" in more cases.</p>\n<p>My suggestion of explicitly defining optimization levels based on which provenance model can be used, could be the next step after that, which might be more palatable than fully committing to strict provenance. I don't think it would be good if we stayed permanently in the limbo of being unable to answer if some programs are UB.</p>",
        "id": 277305681,
        "sender_full_name": "Diggsey",
        "timestamp": 1648743348
    },
    {
        "content": "<p>I think it's important to distinguish two things: what LLVM does today and what LLVM hypothetically could do.</p>",
        "id": 277306312,
        "sender_full_name": "comex",
        "timestamp": 1648743660
    },
    {
        "content": "<p>Right now I suspect LLVM's optimizations are not sound even for code that follows strict_provenance (although I can't prove it).</p>",
        "id": 277306367,
        "sender_full_name": "comex",
        "timestamp": 1648743693
    },
    {
        "content": "<p>And there's little bandwidth from the Rust side to work on this, and from the LLVM core side, they want to adopt a sound model for C but it's not particularly urgent.</p>",
        "id": 277306459,
        "sender_full_name": "comex",
        "timestamp": 1648743730
    },
    {
        "content": "<p>Actually, I can prove it: AFAIK LLVM does global value numbering on pointers and that messes up provenance.</p>",
        "id": 277306564,
        "sender_full_name": "comex",
        "timestamp": 1648743789
    },
    {
        "content": "<p>Making LLVM sound for any of strict_provenance, PNVI, or \"PNVI without strict aliasing\" would result in some loss of optimization potential.  We know the loss is probably minimal in the case of strict_provenance.  We also know that PNVI should be easier to optimize than \"PNVI without strict aliasing\" because of issues like being unable to remove dead loads.  But we don't really know how much optimization potential is lost in each case.  Personally I've never actually written a compiler optimization, but I suspect even a true expert wouldn't know for sure without trying to implement it.</p>",
        "id": 277306824,
        "sender_full_name": "comex",
        "timestamp": 1648743911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277305681\">said</a>:</p>\n<blockquote>\n<p>My suggestion of explicitly defining optimization levels based on which provenance model can be used, could be the next step after that, which might be more palatable than fully committing to strict provenance. I don't think it would be good if we stayed permanently in the limbo of being unable to answer if some programs are UB.</p>\n</blockquote>\n<p>If we have separate functions for <code>strict_ptr2int</code> and <code>pnvi_ae_ptr2int</code>, then we can specify UB precisely for all programs that don't use <code>pnvi_ae_ptr2int</code></p>",
        "id": 277307043,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744010
    },
    {
        "content": "<p>In particular, regarding \"PNVI without strict aliasing\", I speculated the other day about how, even if you can't literally eliminate dead stores (the same principle would apply to dead loads), you could replace them with a \"might have leaked provenance\" annotation, or do a different transformation‚Ä¶ But that was just speculation.  It seems possible to me that \"PNVI without strict aliasing\" is simply infeasible as a compiler model, but also possible that it is feasible.</p>",
        "id": 277307132,
        "sender_full_name": "comex",
        "timestamp": 1648744057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277306564\">said</a>:</p>\n<blockquote>\n<p>Actually, I can prove it: AFAIK LLVM does global value numbering on pointers and that messes up provenance.</p>\n</blockquote>\n<p>I would love to see this worked out in an example</p>",
        "id": 277307156,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744071
    },
    {
        "content": "<p>Maybe we just have to deal with the fact that nobody is going to spend the time to implement that right now, so for the foreseeable future, we just don't know.  And perhaps have to assume the worst, which is arguably what strict_provenance is.</p>",
        "id": 277307251,
        "sender_full_name": "comex",
        "timestamp": 1648744107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277307156\">said</a>:</p>\n<blockquote>\n<p>I would love to see this worked out in an example</p>\n</blockquote>\n<p>Sure, let me try.</p>",
        "id": 277307261,
        "sender_full_name": "comex",
        "timestamp": 1648744115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277307132\">said</a>:</p>\n<blockquote>\n<p>a \"might have leaked provenance\" annotation</p>\n</blockquote>\n<p>In my understanding, this is what <code>-ae-</code> means: they are proposing that <code>ptr2int</code> means (1) please compute an integer, (2) please mark the pointer as <code>address exposed</code></p>",
        "id": 277307540,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744265
    },
    {
        "content": "<p>So if LLVM wants to be sound, then it seems easy for me to have a separate instruction (variant) in LLVM IC that does only (1) and not (2)</p>",
        "id": 277307605,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744312
    },
    {
        "content": "<p>I used PNVI-AE-UDI because it seemed like the most promising model that allowed ptr&lt;-&gt;int round-trips, but you can substitute that with whatever \"weaker than strict provenance\" model makes the most sense to keep existing unsafe code working and reasonably well optimized</p>",
        "id": 277307675,
        "sender_full_name": "Diggsey",
        "timestamp": 1648744335
    },
    {
        "content": "<p>Are there PNVI models on the table for C/C++ that aren't PNVI-AE?</p>",
        "id": 277307754,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744381
    },
    {
        "content": "<blockquote>\n<p>So if LLVM wants to be sound, then it seems easy for me to have a separate instruction (variant) in LLVM IC that does only (1) and not (2)</p>\n</blockquote>\n<p>At some point we might actually want to be able to do optimizations assuming strict provenance though.</p>",
        "id": 277308029,
        "sender_full_name": "Diggsey",
        "timestamp": 1648744501
    },
    {
        "content": "<p>Not really. WG14 is looking to move forward with PNVI-ae-udi.</p>",
        "id": 277308129,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648744543
    },
    {
        "content": "<blockquote>\n<p>At some point we might actually want to be able to do optimizations assuming strict provenance though.</p>\n</blockquote>\n<p>I mean we could presumably always enable those optimizations, if they just shut themselves down whenever <code>pvni_ae_ptr2int</code> appears nearby</p>",
        "id": 277308614,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744770
    },
    {
        "content": "<p>So the optimizations could work on parts of a translation unit</p>",
        "id": 277308647,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648744797
    },
    {
        "content": "<p>Well \"nearby\" is the problem. The optimizations don't work if <code>pvni_ae_ptr2int</code> is used anywhere in the program, not just \"nearby\".</p>",
        "id": 277308748,
        "sender_full_name": "Diggsey",
        "timestamp": 1648744832
    },
    {
        "content": "<p>And by \"don't work\" I mean, they are unsound - may change the program into one that does something completely different</p>",
        "id": 277308810,
        "sender_full_name": "Diggsey",
        "timestamp": 1648744876
    },
    {
        "content": "<p>Really? What kind of optimization are you thinking about?</p>",
        "id": 277309056,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648745013
    },
    {
        "content": "<p>presumably strict provenance means that int2ptr cannot be used to access memory even if pointers to that memory went into \"unknown code\"</p>",
        "id": 277309254,
        "sender_full_name": "eddyb",
        "timestamp": 1648745125
    },
    {
        "content": "<p>so something like this I'm guessing?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">opaque</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277309462,
        "sender_full_name": "eddyb",
        "timestamp": 1648745252
    },
    {
        "content": "<p>Correct, strict provenance means that int2ptr pointers cannot be used to access memory</p>",
        "id": 277309487,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648745254
    },
    {
        "content": "<p>now that example feels silly because of the int2ptr cast and I just mentioned strict provenance... but I think some variation on it must be relevant</p>",
        "id": 277309633,
        "sender_full_name": "eddyb",
        "timestamp": 1648745312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> Here is an example of how LLVM currently does global value numbering on pointers in a way that's unsound, even with no pointer-integer casts involved: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=65a08ab926a212da05b2577c62b6c0fb\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=65a08ab926a212da05b2577c62b6c0fb</a></p>",
        "id": 277309638,
        "sender_full_name": "comex",
        "timestamp": 1648745314
    },
    {
        "content": "<p>wait, GVN takes <code>icmp</code>s into account?</p>",
        "id": 277309805,
        "sender_full_name": "eddyb",
        "timestamp": 1648745409
    },
    {
        "content": "<p>are you saying that inside <code>if xs.len() == 5 {...}</code> every further use of <code>xs.len()</code> would be replaced with <code>5</code> by GVN itself? that's... IMO very strange interpretation of what \"GVN\" means on LLVM's part</p>",
        "id": 277309903,
        "sender_full_name": "eddyb",
        "timestamp": 1648745476
    },
    {
        "content": "<p>presumably this is one of those things where LLVM overloading things too much leads to \"type confusion\". <code>==</code> should probably be something like <code>ptr_addr_cmp</code>, and <em>not</em> be considered to imply anything about the pointers as a whole (tho ideally LLVM should just encode the <code>.addr()</code> operation directly and maybe use <code>icmp</code> on that - I wonder what CHERI does here?)</p>",
        "id": 277310111,
        "sender_full_name": "eddyb",
        "timestamp": 1648745579
    },
    {
        "content": "<p>Actually, I'm not sure if it calls it GVN; in that case it's <code>SimplifyCFGPass</code> that does the simplification.</p>",
        "id": 277310189,
        "sender_full_name": "comex",
        "timestamp": 1648745630
    },
    {
        "content": "<p>len is a usize, not a pointer. I don‚Äôt see why it wouldn‚Äôt participate in GVN</p>",
        "id": 277310194,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648745632
    },
    {
        "content": "<p>GVN's job is to deduplicate (pure) <em>work</em>, so it should turn:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>into:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277310348,
        "sender_full_name": "eddyb",
        "timestamp": 1648745711
    },
    {
        "content": "<p>Oops, I lied.</p>",
        "id": 277310350,
        "sender_full_name": "comex",
        "timestamp": 1648745712
    },
    {
        "content": "<p>It's <code>InstCombinePass</code>.</p>",
        "id": 277310368,
        "sender_full_name": "comex",
        "timestamp": 1648745726
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">***</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">Dump</span><span class=\"w\"> </span><span class=\"n\">After</span><span class=\"w\"> </span><span class=\"n\">SimplifyCFGPass</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class=\"w\"> </span><span class=\"o\">***</span><span class=\"w\"></span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Attrs</span>: <span class=\"nc\">mustprogress</span><span class=\"w\"> </span><span class=\"n\">nofree</span><span class=\"w\"> </span><span class=\"n\">norecurse</span><span class=\"w\"> </span><span class=\"n\">nosync</span><span class=\"w\"> </span><span class=\"n\">nounwind</span><span class=\"w\"> </span><span class=\"n\">uwtable</span><span class=\"w\"> </span><span class=\"n\">willreturn</span><span class=\"w\"> </span><span class=\"n\">writeonly</span><span class=\"w\"></span>\n<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">internal</span><span class=\"w\"> </span><span class=\"n\">fastcc</span><span class=\"w\"> </span><span class=\"n\">noundef</span><span class=\"w\"> </span><span class=\"n\">zeroext</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">writeonly</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">writeon</span><span class=\"w\"></span>\n<span class=\"n\">ly</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">unnamed_addr</span><span class=\"w\"> </span>#<span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">%</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">icmp</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">%</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">select</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">200</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">3</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"o\">***</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">Dump</span><span class=\"w\"> </span><span class=\"n\">After</span><span class=\"w\"> </span><span class=\"n\">InstCombinePass</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class=\"w\"> </span><span class=\"o\">***</span><span class=\"w\"></span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Attrs</span>: <span class=\"nc\">mustprogress</span><span class=\"w\"> </span><span class=\"n\">nofree</span><span class=\"w\"> </span><span class=\"n\">norecurse</span><span class=\"w\"> </span><span class=\"n\">nosync</span><span class=\"w\"> </span><span class=\"n\">nounwind</span><span class=\"w\"> </span><span class=\"n\">uwtable</span><span class=\"w\"> </span><span class=\"n\">willreturn</span><span class=\"w\"> </span><span class=\"n\">writeonly</span><span class=\"w\"></span>\n<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">internal</span><span class=\"w\"> </span><span class=\"n\">fastcc</span><span class=\"w\"> </span><span class=\"n\">noundef</span><span class=\"w\"> </span><span class=\"n\">zeroext</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">_ZN9stale_ptr12write_to_one17h13990181c4a3c8eeE</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">writeonly</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">writeon</span><span class=\"w\"></span>\n<span class=\"n\">ly</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">unnamed_addr</span><span class=\"w\"> </span>#<span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">%</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">icmp</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">200</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"mi\">3</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277310388,
        "sender_full_name": "comex",
        "timestamp": 1648745746
    },
    {
        "content": "<p>(whereas replacing <code>y = len</code> with <code>y = 5</code> is some form of predicated reasoning. I'm not sure what it's typically called but you can generally \"assume\" a condition holds true on paths that require that condition to hold, and that can have a plethora of consequences)</p>",
        "id": 277310591,
        "sender_full_name": "eddyb",
        "timestamp": 1648745858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277310368\">said</a>:</p>\n<blockquote>\n<p>It's <code>InstCombinePass</code>.</p>\n</blockquote>\n<p>ah hah, looks like a <code>select (icmp eq x, y), x, y</code> to <code>y</code> rule</p>",
        "id": 277310621,
        "sender_full_name": "eddyb",
        "timestamp": 1648745880
    },
    {
        "content": "<p>so yeah the issue is the overload of <code>icmp</code>. presumably it doesn't even bother checking any types</p>",
        "id": 277310683,
        "sender_full_name": "eddyb",
        "timestamp": 1648745896
    },
    {
        "content": "<p>But‚Ä¶ it looks like LLVM's 'GVN' pass can do something like that as well.  This is from <code>lib/Transforms/Scalar/GVN.cpp</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"c1\">// If we find an equality fact, canonicalize all dominated uses in this block</span>\n<span class=\"w\">  </span><span class=\"c1\">// to one of the two values.  We heuristically choice the \"oldest\" of the</span>\n<span class=\"w\">  </span><span class=\"c1\">// two where age is determined by value number. (Note that propagateEquality</span>\n<span class=\"w\">  </span><span class=\"c1\">// above handles the cross block case.)</span>\n<span class=\"w\">  </span><span class=\"c1\">//</span>\n<span class=\"w\">  </span><span class=\"c1\">// Key case to cover are:</span>\n<span class=\"w\">  </span><span class=\"c1\">// 1)</span>\n<span class=\"w\">  </span><span class=\"c1\">// %cmp = fcmp oeq float 3.000000e+00, %0 ; const on lhs could happen</span>\n<span class=\"w\">  </span><span class=\"c1\">// call void @llvm.assume(i1 %cmp)</span>\n<span class=\"w\">  </span><span class=\"c1\">// ret float %0 ; will change it to ret float 3.000000e+00</span>\n<span class=\"w\">  </span><span class=\"c1\">// 2)</span>\n<span class=\"w\">  </span><span class=\"c1\">// %load = load float, float* %addr</span>\n<span class=\"w\">  </span><span class=\"c1\">// %cmp = fcmp oeq float %load, %0</span>\n<span class=\"w\">  </span><span class=\"c1\">// call void @llvm.assume(i1 %cmp)</span>\n<span class=\"w\">  </span><span class=\"c1\">// ret float %load ; will change it to ret float %0</span>\n</code></pre></div>",
        "id": 277311009,
        "sender_full_name": "comex",
        "timestamp": 1648746039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277302591\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277301326\">said</a>:</p>\n<blockquote>\n<p>I think we can have int2ptr2int in a Rust way and we shouldnt just copy what C does</p>\n</blockquote>\n<p>What about ptr2int2ptr?</p>\n<p>I think int2ptr2int basically has to work, since it's doable from fully safe code -- maybe we can say it's nondeterministic, but that would honestly be very surprising.</p>\n</blockquote>\n<p>sorry, I meant ptr2int2ptr</p>",
        "id": 277312584,
        "sender_full_name": "RalfJ",
        "timestamp": 1648746857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277311009\">said</a>:</p>\n<blockquote>\n<p>But‚Ä¶ it looks like LLVM's 'GVN' pass can do something like that as well.  This is from <code>lib/Transforms/Scalar/GVN.cpp</code>:</p>\n</blockquote>\n<p>oh dear, <code>llvm.assume</code> is even wilder than branch predication</p>",
        "id": 277312654,
        "sender_full_name": "eddyb",
        "timestamp": 1648746904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> </p>\n<blockquote>\n<p>Bram Geron: Really? What kind of optimization are you thinking about?</p>\n</blockquote>\n<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">cond</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"mi\">1000000</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">int2ptr</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">total</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Let's assume this results through inlining or something - obviously you wouldn't write this code by hand. With strict provenance you can optimize this to just multiplying <code>arg</code> by 1000000. Under weaker models you can't because <code>arg</code> may have originated from <code>ptr2int</code> to a large enough array.</p>",
        "id": 277312717,
        "sender_full_name": "Diggsey",
        "timestamp": 1648746936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277306367\">said</a>:</p>\n<blockquote>\n<p>Right now I suspect LLVM's optimizations are not sound even for code that follows strict_provenance (although I can't prove it).</p>\n</blockquote>\n<p>I think it might be fine actually. all the nasty examples I am ware of rely on ptr2int2ptr.</p>",
        "id": 277312898,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747011
    },
    {
        "content": "<blockquote>\n<p>That certainly makes sense to me as the \"most incremental\" step that could be taken next, and it allows us to answer the question \"is this unsafe code sound?\" with a definite \"yes\" in more cases, but it doesn't help answer the question \"is this optimization pass sound?\" with a \"yes\" in more cases.</p>\n</blockquote>\n<p>Well, yeah.<br>\nBut I don't think having <em>two different memory models</em> with a per-crate choice is going to make anything any simpler. cross-memory-model interactions is a hugely complicated subject. it would probably be easier to work out the memory model with ptr2int2ptr roundtrips than to work out this hybrid thing.</p>",
        "id": 277313059,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747079
    },
    {
        "content": "<p>Cross-crate memory model means that the implementation needs to support the union of all of them at once.</p>",
        "id": 277313194,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648747125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277306564\">said</a>:</p>\n<blockquote>\n<p>Actually, I can prove it: AFAIK LLVM does global value numbering on pointers and that messes up provenance.</p>\n</blockquote>\n<p>oh yeah, there's that. that is still unsound and they know it for years and don't fix it<br>\n<a href=\"https://bugs.llvm.org/show_bug.cgi?id=35229\">https://bugs.llvm.org/show_bug.cgi?id=35229</a><br>\nI love how that bug got retitled from my \"LLVM miscompiles program with ptr comparison\" to \"memory model needs more rigor\" <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 277313210,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747129
    },
    {
        "content": "<p>As long as strict provenance <em>is</em> strictly stricter than the weaker model, and the decision is made for the whole crate graph then I don't see why you'd need to worry about interactions between the two models.</p>",
        "id": 277313282,
        "sender_full_name": "Diggsey",
        "timestamp": 1648747161
    },
    {
        "content": "<p>I suppose you might have to worry about MIR optimizations</p>",
        "id": 277313389,
        "sender_full_name": "eddyb",
        "timestamp": 1648747199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313194\">said</a>:</p>\n<blockquote>\n<p>Cross-crate memory model means that the implementation needs to support the union of all of them at once.</p>\n</blockquote>\n<p>except that \"union\" is not even a well-defined term here</p>",
        "id": 277313546,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747263
    },
    {
        "content": "<p>it's more like their product. but in a way that they stay coherently in sync.</p>",
        "id": 277313567,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747281
    },
    {
        "content": "<p>And while you could have a separate flag, I was imaging something possibly tied to edition, so eg. we bring in strict provenance with edition 2025, and then if any crates are on prior editions we only run optimizations that are compatible with the weaker memory model.</p>",
        "id": 277313622,
        "sender_full_name": "Diggsey",
        "timestamp": 1648747304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313282\">said</a>:</p>\n<blockquote>\n<p>As long as strict provenance <em>is</em> strictly stricter than the weaker model, and the decision is made for the whole crate graph then I don't see why you'd need to worry about interactions between the two models.</p>\n</blockquote>\n<p>yes sorry some people are saying this should be a per-crate thing. if it's a whole-program thing it works. but it means we have two language dialects.</p>",
        "id": 277313656,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277309462\">said</a>:</p>\n<blockquote>\n<p>so something like this I'm guessing?</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">opaque</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>ah wait I can fix this, lol:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ptr2int</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">int2ptr</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr2int</span><span class=\"p\">(</span><span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">int2ptr</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277313696,
        "sender_full_name": "eddyb",
        "timestamp": 1648747324
    },
    {
        "content": "<p>which is I guess what the other example was doing</p>",
        "id": 277313734,
        "sender_full_name": "eddyb",
        "timestamp": 1648747343
    },
    {
        "content": "<p>though, funnily enough, that actually can't be optimized</p>",
        "id": 277313771,
        "sender_full_name": "eddyb",
        "timestamp": 1648747363
    },
    {
        "content": "<p>because you could emulate a global <code>BTreeMap&lt;usize, *mut u8&gt;</code> or w/e</p>",
        "id": 277313812,
        "sender_full_name": "eddyb",
        "timestamp": 1648747382
    },
    {
        "content": "<p>so in some sense, strict provenance still allows some modular reasoning without explicit knowledge of \"lurking\" ptr2int2ptr</p>",
        "id": 277313892,
        "sender_full_name": "eddyb",
        "timestamp": 1648747427
    },
    {
        "content": "<blockquote>\n<p>but it means we have two language dialects</p>\n</blockquote>\n<p>Well.. we already have no_std/std crates. I think as long as we keep a strict hierarchy (ie. everything that works with strict provenance also works without it) then it's an acceptable cost in order to maintain backwards compatibility, whilst also allowing us to get real benefits from strict provenance</p>",
        "id": 277313907,
        "sender_full_name": "Diggsey",
        "timestamp": 1648747436
    },
    {
        "content": "<p>(as long as the ptr2int2ptr model can be \"emulated\", which <em>some</em> can, though accurate allocation ranges aren't directly available without e.g. CHERI metadata)</p>",
        "id": 277314026,
        "sender_full_name": "eddyb",
        "timestamp": 1648747484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313622\">said</a>:</p>\n<blockquote>\n<p>And while you could have a separate flag, I was imaging something possibly tied to edition, so eg. we bring in strict provenance with edition 2025, and then if any crates are on prior editions we only run optimizations that are compatible with the weaker memory model.</p>\n</blockquote>\n<p>\"any\" being a predicate only Cargo can compute, and then rustc just enforces that the choice is globally uniform (i.e. cannot depend on a crate with a different setting)?</p>",
        "id": 277314200,
        "sender_full_name": "eddyb",
        "timestamp": 1648747568
    },
    {
        "content": "<p>that's not really practical -- it means no codegen until the final binary is produced</p>",
        "id": 277314281,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747617
    },
    {
        "content": "<p>also some crates have extreme MSRV and will probably never go to a new edition</p>",
        "id": 277314305,
        "sender_full_name": "RalfJ",
        "timestamp": 1648747629
    },
    {
        "content": "<p>you can do codegen before but only if what I described happens (Cargo computes the \"worst case\" and rustc forces much stricter \"everything must agree\" semantics)</p>",
        "id": 277314449,
        "sender_full_name": "eddyb",
        "timestamp": 1648747696
    },
    {
        "content": "<p>it still isn't great though</p>",
        "id": 277314471,
        "sender_full_name": "eddyb",
        "timestamp": 1648747713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313210\">said</a>:<br>\noh yeah, there's that. that is still unsound and they know it for years and don't fix it<br>\n<a href=\"https://bugs.llvm.org/show_bug.cgi?id=35229\">https://bugs.llvm.org/show_bug.cgi?id=35229</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">So</span><span class=\"w\"> </span><span class=\"err\">‚Äî</span><span class=\"w\"> </span><span class=\"n\">maybe</span><span class=\"w\"> </span><span class=\"n\">realistically</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">strict_provenance</span><span class=\"err\">`</span><span class=\"o\">-</span><span class=\"n\">specific</span><span class=\"w\"> </span><span class=\"n\">optimizations</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MIR</span><span class=\"w\"> </span><span class=\"n\">level</span><span class=\"w\"> </span>:<span class=\"nc\">thinking</span>:\n</code></pre></div>",
        "id": 277315011,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648747995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Bram Geron: Really? What kind of optimization are you thinking about?</p>\n</blockquote>\n<p>For example: [example]</p>\n</blockquote>\n<p>I think you could optimize this to <code>arg*1000000</code> without any global toggle, because <code>*strict_int2ptr(..)</code> is just plain UB so the if..then..else goes away. This seems feasible on the MIR level as well.</p>",
        "id": 277315306,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277314449\">said</a>:</p>\n<blockquote>\n<p>you can do codegen before but only if what I described happens (Cargo computes the \"worst case\" and rustc forces much stricter \"everything must agree\" semantics)</p>\n</blockquote>\n<p>well it's somewhat non-trivial to argue that a codegen pass is correct under both semantics. you basically need to have two separate correctness arguments then...</p>",
        "id": 277315401,
        "sender_full_name": "RalfJ",
        "timestamp": 1648748206
    },
    {
        "content": "<blockquote>\n<p>So ‚Äî maybe realistically we can only have <code>strict_provenance</code>-specific optimizations on the MIR level <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>no, we just need to get LLVM to fix their stuff if this becomes a problem</p>",
        "id": 277315474,
        "sender_full_name": "RalfJ",
        "timestamp": 1648748255
    },
    {
        "content": "<p>everything in the LLVM LangRef indicates that strict provenance is compatible with LLVM, they don't have an excuse here</p>",
        "id": 277315511,
        "sender_full_name": "RalfJ",
        "timestamp": 1648748272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315306\">said</a>:</p>\n<blockquote>\n<p>I think you could optimize this to <code>arg*1000000</code> without any global toggle, because <code>*strict_int2ptr(..)</code> is just plain UB so the if..then..else goes away. This seems feasible on the MIR level as well.</p>\n</blockquote>\n<p>Again, my goal is to support both PNVI-AE and <code>strict</code> crates inside the PNVI-AE memory model, by just extending PNVI-AE with a non-exposing int2ptr</p>",
        "id": 277315621,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748321
    },
    {
        "content": "<p>So no union or product of memory models needed</p>",
        "id": 277315661,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748346
    },
    {
        "content": "<p>But that means any implementation needs to support PNVI-ae, instead of just supporting strict-provenance.</p>",
        "id": 277315702,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748369
    },
    {
        "content": "<p>Which effectively means that all implementations are PNVI-ae, and not strict-provenance, it just pretending for some crates to be strict-provenance.</p>",
        "id": 277315872,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748453
    },
    {
        "content": "<p>I mean realistically any implementation needs to support both anyways because of C (sigh).</p>",
        "id": 277315879,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648748459
    },
    {
        "content": "<p>And there, what's the point?</p>",
        "id": 277315886,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315879\">said</a>:</p>\n<blockquote>\n<p>I mean realistically any implementation needs to support both anyways because of C (sigh).</p>\n</blockquote>\n<p>I mean, you could have a just-rust implementation.</p>",
        "id": 277315906,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748475
    },
    {
        "content": "<p>Correct.</p>\n<p>I think <code>rustc</code> cannot ditch PNVI-AE without massive backwards incompatibility*.</p>\n<p>*backwards compatibility can't formally be defined because we don't have a formal spec</p>",
        "id": 277315914,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748483
    },
    {
        "content": "<p>Also, still supporting PNVI-ae means we rule out CHERI.</p>",
        "id": 277316041,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748545
    },
    {
        "content": "<p>Which I'm pretty sure was the whole point.</p>",
        "id": 277316077,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313696\">said</a>:</p>\n<blockquote>\n<p>ah wait I can fix this, lol</p>\n</blockquote>\n<p>I think this code is also UB in <code>strict_provenance</code></p>",
        "id": 277316081,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315906\">said</a>:</p>\n<blockquote>\n<p>I mean, you could have a just-rust implementation.</p>\n</blockquote>\n<p>I don't think it's possible to have a just-rust implementation of OS primitives.</p>",
        "id": 277316406,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748739
    },
    {
        "content": "<p>1) Not on current systems, no.<br>\n2) I'm referring to something that will never see non-Rust code as anything other than a pure black_box.</p>",
        "id": 277316545,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315906\">said</a>:</p>\n<blockquote>\n<p>I mean, you could have a just-rust implementation.</p>\n</blockquote>\n<p>I feel like something like this is an instance where you could have this as an extension to the Rust standard.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316406\">said</a>:</p>\n<blockquote>\n<p>I don't think it's possible to have a just-rust implementation of OS primitives.</p>\n</blockquote>\n<p>Mustang and relibc/redox beg to differ.</p>",
        "id": 277316570,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648748816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316041\">said</a>:</p>\n<blockquote>\n<p>Also, still supporting PNVI-ae means we rule out CHERI.</p>\n</blockquote>\n<p>That's not my understanding. IIUC CHERI can be made to support PNVI-ae, but any pointer that may come from <code>pvni_ae_int2ptr</code> must be dereferenced in an incredibly slow way</p>",
        "id": 277316618,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748848
    },
    {
        "content": "<p>Which means if you <em>don't</em> use <code>pvni_ae_int2ptr</code>, then everything is fast as normal on CHERI</p>",
        "id": 277316674,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648748877
    },
    {
        "content": "<p>I think there's value in teaching and simplicity for pure Rust crates to have strict provenance even if the implementation might be using platform provenance semantics.</p>",
        "id": 277316749,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648748894
    },
    {
        "content": "<p>I thought that one of the features of CHERI is the fact that one a pointer goes invalid, it doesn't get restored.</p>",
        "id": 277316803,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648748922
    },
    {
        "content": "<p>For example, one could maybe polyfill inttoptr casts in CHERI with broadcast semantics, a <code>TreeMap</code>, and a bit of luck/pain/effort. Now of course no sane implementation would do that, but it might be possible.</p>",
        "id": 277317047,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648749026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316570\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't think it's possible to have a just-rust implementation of OS primitives.</p>\n</blockquote>\n<p>Mustang and relibc/redox beg to differ.</p>\n</blockquote>\n<p>Let me rephrase. Then we could only support OSes whose kernel interface is specified on the binary level. Not a generix Unix OS.</p>",
        "id": 277317060,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648749033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277316803\">said</a>:</p>\n<blockquote>\n<p>I thought that one of the features of CHERI is the fact that one a pointer goes invalid, it doesn't get restored.</p>\n</blockquote>\n<p>In this scheme, the result of <code>int2ptr</code> would be an integer, which is then compared to any number of reference pointers, and provenance is restored in a complicated way just before dereferencing.</p>",
        "id": 277317212,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648749107
    },
    {
        "content": "<p>Mustang makes syscalls with inline asm, and I'm in the process of converting it to preserve provenance all the way up to the inline asm operand. Unless compilers are going to peek inside inline asm, that seems like it should be sufficient.</p>",
        "id": 277317287,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648749124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404395\">Dan Gohman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317287\">said</a>:</p>\n<blockquote>\n<p>Mustang makes syscalls with inline asm, and I'm in the process of converting it to preserve provenance all the way up to the inline asm operand. Unless compilers are going to peek inside inline asm, that seems like it should be sufficient.</p>\n</blockquote>\n<p>And compilers are not allowed to rely on the content of an asm invocation,</p>",
        "id": 277317383,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648749174
    },
    {
        "content": "<p>(To my somewhat dismay at wanting to be smart)</p>",
        "id": 277317443,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648749200
    },
    {
        "content": "<p>And by rust-only impl I mean an implementation that sees only rust code. Everything else is just non-analyzed (no cross-lang LTO to worry about), thus it only has to worry about rust semantics, and not C, C++, FORTRAN, or w/e other semantics.</p>",
        "id": 277317573,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648749255
    },
    {
        "content": "<p>So, uh... rustc itself (MIR opts).</p>",
        "id": 277317634,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648749295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404395\">Dan Gohman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317287\">said</a>:</p>\n<blockquote>\n<p>Mustang makes syscalls with inline asm, and I'm in the process of converting it to preserve provenance all the way up to the inline asm operand. Unless compilers are going to peek inside inline asm, that seems like it should be sufficient.</p>\n</blockquote>\n<p><a href=\"https://developer.apple.com/library/archive/qa/qa1118/_index.html\">macOS does not support static binaries</a>. So Rust-only binaries are possible for a version of macOS, but they would break on different versions.</p>",
        "id": 277317797,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648749371
    },
    {
        "content": "<p>Oh hi Dan I didn't know you were here :P. Also, <code>extern \"C\"</code> functions might be in for a fun time too... I suppose a lot of this comes down to C being quite bad at being a platform type definition, due to the mixing of like XXX different C dialects.</p>",
        "id": 277317827,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648749394
    },
    {
        "content": "<p>Maybe we could still do it just with FFI ‚Äî only linking to a C ABI. But that wouldn't help us execute in a strict-provenance memory model</p>",
        "id": 277317890,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648749433
    },
    {
        "content": "<p>Also, not every implementation needs to be rust-only.</p>",
        "id": 277317918,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648749449
    },
    {
        "content": "<p>And certainly not every implemenation needs to only support (transitively) only calling rust code.</p>",
        "id": 277317949,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648749471
    },
    {
        "content": "<p>I think most of this comes down to what exact optimizations we're talking about. If Rust assumes that any function pointer argument is a strict-provenance pointer, you're in for some fun times. If you merely optimize the body of a function, via reordering or loop elimination or hoisting or w/e, that would be a lot less problematic.</p>",
        "id": 277318236,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648749610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277313622\">said</a>:</p>\n<blockquote>\n<p>And while you could have a separate flag, I was imaging something possibly tied to edition, so eg. we bring in strict provenance with edition 2025, and then if any crates are on prior editions we only run optimizations that are compatible with the weaker memory model.</p>\n</blockquote>\n<p>libc is still in the 2015 edition. libc is used by libstd, so that would mean basically every crate would only run optimizations compatible with the weaker memory model.</p>",
        "id": 277319485,
        "sender_full_name": "bjorn3",
        "timestamp": 1648750226
    },
    {
        "content": "<p>On rustc at least.</p>",
        "id": 277319538,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648750263
    },
    {
        "content": "<p>True, although many crates directly or indirectly depend on libc from <a href=\"http://crates.io\">crates.io</a> too.</p>",
        "id": 277319619,
        "sender_full_name": "bjorn3",
        "timestamp": 1648750319
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 277319674,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648750332
    },
    {
        "content": "<p>I mean, implementation-wise you can have separate crates with (these two) different provenance rules by treating them as FFI boundaries, as sorta implied, for any implementation which supports C FFI</p>",
        "id": 277320183,
        "sender_full_name": "Talchas",
        "timestamp": 1648750633
    },
    {
        "content": "<p>and \"does not support platforms that don't support C\" is not exactly a particularly restrictive position</p>",
        "id": 277320215,
        "sender_full_name": "Talchas",
        "timestamp": 1648750660
    },
    {
        "content": "<p>That's worse.</p>",
        "id": 277320288,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648750688
    },
    {
        "content": "<p>How would you prevent cross-crate inlining in the presence of LTO? And what about generics that get codegened in a crate different from their definition?</p>",
        "id": 277320310,
        "sender_full_name": "bjorn3",
        "timestamp": 1648750701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277315914\">said</a>:</p>\n<blockquote>\n<p>Correct.</p>\n<p>I think <code>rustc</code> cannot ditch PNVI-AE without massive backwards incompatibility*.</p>\n<p>*backwards compatibility can't formally be defined because we don't have a formal spec</p>\n</blockquote>\n<p>I dont see why that would be. \"ditch\" would imply that we would have currently adopted it which we surely don't.<br>\nbut I also repeat my question from before -- do you mean very specifically PNVI-ae-udi as described for C? that model just doesn't make sense for Rust, it is designed with C (and its strict aliasing) in mind.<br>\nor do you mean \"any kind of model that has provenance but not via integers but allows ptr2int2ptr roundtrips\"? <em>that</em> we probably need for backwards compatibility, indeed.</p>",
        "id": 277320337,
        "sender_full_name": "RalfJ",
        "timestamp": 1648750716
    },
    {
        "content": "<p>I mean any pnvi-ae-* model that allows for reasonable backwards compatibility guarantees. I don't care what they are in particular.</p>",
        "id": 277320451,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648750786
    },
    {
        "content": "<p>there is a <em>huge</em> space of such models, and I dont think we should pick the one C picked. (not that that statement would even be well-typed since a C model inherently cannot answer Rust questions like which of our reference and raw ptr operations do what with the provenance.)</p>",
        "id": 277320521,
        "sender_full_name": "RalfJ",
        "timestamp": 1648750804
    },
    {
        "content": "<p>like even the \"ae-\" terminology is already not applicable for a Rust aliasing model, whee \"exposed\" can't just be a <code>bool</code> but needs to be more tightly integrated</p>",
        "id": 277320591,
        "sender_full_name": "RalfJ",
        "timestamp": 1648750842
    },
    {
        "content": "<p>(as it would have to be for <code>restrict</code> as well)</p>",
        "id": 277320608,
        "sender_full_name": "RalfJ",
        "timestamp": 1648750851
    },
    {
        "content": "<blockquote>\n<p>or do you mean \"any kind of model that has provenance but not via integers but allows ptr2int2ptr roundtrips\"? that we probably need for backwards compatibility, indeed.</p>\n</blockquote>\n<p>I'm really just glad that this is being agreed on. I think a lot of the, erm, \"heat\" in the last discussion was from it seeming like there was disagreement here.</p>",
        "id": 277320622,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648750861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320310\">said</a>:</p>\n<blockquote>\n<p>How would you prevent cross-crate inlining in the presence of LTO? And what about generics that get codegened in a crate different from their definition?</p>\n</blockquote>\n<p>I mean, all of that is absolutely easily describable/implementable via ugliness - it's an ABI parameter that is part of the mangled name and gets codegenned separately for each. And LTO has to treat this as a boundary in the same way that any theoretical/experimental cross-lang LTO would, probably at least to start with via being separate compiler invocations.</p>",
        "id": 277320686,
        "sender_full_name": "Talchas",
        "timestamp": 1648750898
    },
    {
        "content": "<p>My view is it's easiest if</p>\n<ul>\n<li>Rust adopts some pnvi-ae memory model, and we separate <code>{pnvi_ae,strict}_ptr2int</code> and<code>{pnvi_ae,strict}_int2ptr</code></li>\n<li>We make a formal specification for the sublanguage that forbids <code>pnvi_ae_*</code></li>\n<li>In MIR, we e.g. color allocations green when we know for sure  <code>pnvi_ae_ptr2int</code> won't be called on it. Function arguments can't be green.</li>\n<li>On MIR, we may do stronger alias analysis on green allocations</li>\n<li>On MIR, we optimize read and write to <code>pnvi_ae_int2ptr(..)</code> to UB. This handles <span class=\"user-mention\" data-user-id=\"295632\">@Diggsey</span>'s <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717\">example</a></li>\n<li>LTO now keeps working as usual</li>\n</ul>\n<p>But <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> , you think it's not possible to do any reasonable handwavey definition of Rust including this <code>pnvi_ae_*</code>? It doesn't have to be more formal than C imo</p>",
        "id": 277320814,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648750960
    },
    {
        "content": "<p>I haven't seen anyone very interested in a formal spec for a Rust that allows for any ptr2int2ptr</p>",
        "id": 277320914,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648751026
    },
    {
        "content": "<p>(p.s. I don't actually know MIR)</p>",
        "id": 277321009,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648751057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320622\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>or do you mean \"any kind of model that has provenance but not via integers but allows ptr2int2ptr roundtrips\"? that we probably need for backwards compatibility, indeed.</p>\n</blockquote>\n<p>I'm really just glad that this is being agreed on. I think a lot of the, erm, \"heat\" in the last discussion was from it seeming like there was disagreement here.</p>\n</blockquote>\n<p>well, to be frank I would <em>love</em> to disallow these roundtrips, and I expect some (a lot?) of the formal Rust work will.<br>\nbut I also doubt the lang team would let me get away with that 'for real' so I am not sure what my play for \"full Rust\" and Miri should be.<br>\nlike, there actually is kind of a generic recipe to turn any strict provenance model into a model that supports roundtrips, but it makes Miri basically impossible. (and I am not sure what it does with optimizations.) so</p>\n<ul>\n<li>we could follow that recipe and say that code that does roundtrips will just not be accepted by Miri because doing so is impractical and plase fix your code</li>\n<li>we could try to find an alternative way that supports roundtrips while still making miri feasible (the suffering is real)</li>\n<li>we could disallow roundtrips entirely (I doubt people will let me get away with this one)</li>\n</ul>",
        "id": 277321043,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751087
    },
    {
        "content": "<p>I'd personally be fine with # 1</p>",
        "id": 277321115,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648751131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> I dont think pnvi-ae is a useful stepping stone for Rust because of our aliasing model</p>",
        "id": 277321252,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751191
    },
    {
        "content": "<p>if you look at Stacked Borrows careful enough it <em>does</em> have 'exposed' flags, they are called \"untagged\" and live in the borrow stack</p>",
        "id": 277321304,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751213
    },
    {
        "content": "<p>if you call such a model pnvi-ae then I guess I agree but I think that is rather bad terminology^^</p>",
        "id": 277321342,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751234
    },
    {
        "content": "<p>I'm okay you needing to not do roundtrips in order for miri to work. That would produce gentle pressure for people to update their code to the newer model (so that they can work under miri), without breaking large swaths of unsafe code in the wild.</p>",
        "id": 277321481,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648751294
    },
    {
        "content": "<p>I have no idea what it would mean to \"forbid pnvi-ae\". what does it mean to forbid a model? do you mean \"forbid roundtrips\", aka strict provenance?</p>",
        "id": 277321484,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751296
    },
    {
        "content": "<p>given how vague the sketches for models that support roundtrips are, I dont think it is worth discussing hybrid models that combine those with strict provenance</p>",
        "id": 277321567,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751347
    },
    {
        "content": "<p>also I dont think those would actually be any different</p>",
        "id": 277321584,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751355
    },
    {
        "content": "<p>like, any model that supports roundtrips should accept all programs that follow strict provenance (otherwise the model is just broken)</p>",
        "id": 277321615,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751377
    },
    {
        "content": "<p>so, the search for a hybrid model <em>is</em> the search for a model that supports roundtrips</p>",
        "id": 277321637,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751387
    },
    {
        "content": "<p>no need to think explicitly about \"two different worlds interacting\" or anything like that</p>",
        "id": 277321701,
        "sender_full_name": "RalfJ",
        "timestamp": 1648751408
    },
    {
        "content": "<p><code>pub fn this_makes_miri_sad(addr: usize) -&gt; *mut c_void { ... }</code></p>",
        "id": 277323005,
        "sender_full_name": "Lokathor",
        "timestamp": 1648752084
    },
    {
        "content": "<p>I think we should call it <code>make_miri_sad</code>. force programmers to explicitly state their intent here. ;)</p>",
        "id": 277323478,
        "sender_full_name": "RalfJ",
        "timestamp": 1648752255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> </p>\n<blockquote>\n<p>Bram Geron: Really? What kind of optimization are you thinking about?<br>\nFor example: [...]<br>\nLet's assume this results through inlining or something - obviously you wouldn't write this code by hand. With strict provenance you can optimize this to just multiplying <code>arg</code> by 1000000. Under weaker models you can't because <code>arg</code> may have originated from <code>ptr2int</code> to a large enough array.</p>\n</blockquote>\n</blockquote>\n<p>Wait, under strict provenance your <code>int2ptr</code> function could just be doing a wrapping index into a global array it can access and everything would be fine. So you can't optimize the function to that without peeking into <code>int2ptr</code> and declaring its contents as UB.</p>",
        "id": 277324069,
        "sender_full_name": "riking",
        "timestamp": 1648752548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"264702\">@riking</span> int2ptr is just a cast - it's not UB on its own under any proposed model, because integers are allowed to be cast to pointers as long as you don't try to dereference the pointer</p>",
        "id": 277324919,
        "sender_full_name": "Diggsey",
        "timestamp": 1648752921
    },
    {
        "content": "<p>But you did dereference the pointer. Sorry, \"declaring its contents as returning an always-invalid pointer\"</p>",
        "id": 277325274,
        "sender_full_name": "riking",
        "timestamp": 1648753050
    },
    {
        "content": "<p>right, but that code path only happens if <code>cond</code> is false, therefore the compiler knows that (for this particular inlining) <code>cond</code> must be true</p>",
        "id": 277325406,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753105
    },
    {
        "content": "<p>I'm talking the same as the stuff above where <code>int2ptr</code> has external linkage and we swap it out for the TreeMap polyfill</p>",
        "id": 277325501,
        "sender_full_name": "riking",
        "timestamp": 1648753167
    },
    {
        "content": "<p>it returns a valid pointer if it finds one</p>",
        "id": 277325555,
        "sender_full_name": "riking",
        "timestamp": 1648753197
    },
    {
        "content": "<p>Basically, under the non-strict models that function could be valid on both branches. Under the strict model, it's only collapsed to a single branch if we know the other branch does Guaranteed Evil. If <code>int2ptr</code> is an opaque function instead of a builtin, it's not guaranteed evil. If <code>int2ptr</code> is a builtin that does Guaranteed Evil, why was it provided.</p>",
        "id": 277325961,
        "sender_full_name": "riking",
        "timestamp": 1648753352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321252\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> I dont think pnvi-ae is a useful stepping stone for Rust because of our aliasing model</p>\n</blockquote>\n<p>Hmmz. I forgot that Stacked Borrows isn't just for Miri, it's also how we think about Mir. This complicates matters indeed</p>",
        "id": 277325992,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648753370
    },
    {
        "content": "<p>We have <code>unreachable_unchecked()</code> already, or just <code>pointer::invalid_mut(1)</code>, for when you want Guaranteed Evil</p>",
        "id": 277326032,
        "sender_full_name": "riking",
        "timestamp": 1648753393
    },
    {
        "content": "<p>Also for that example a) the compiler can still optimize it to <code>if cond { total += lots * arg; } else { do the actual loop }</code> so you're really not gaining much, and b) yes, it can't \"optimize\" away a perfectly valid and plausible operation, that's a feature</p>",
        "id": 277326084,
        "sender_full_name": "Talchas",
        "timestamp": 1648753437
    },
    {
        "content": "<p>(yes, it's not /likely/ if max is huge, but it is entirely plausible for smaller max, or a passed in one, or whatever, and the optimization does not depend on that in the slightest)</p>",
        "id": 277326302,
        "sender_full_name": "Talchas",
        "timestamp": 1648753550
    },
    {
        "content": "<blockquote>\n<p>If int2ptr is a builtin that does Guaranteed Evil, why was it provided</p>\n</blockquote>\n<p>I don't know what you mean by Guaranteed Evil. It's provided because often you want to store an integer in a pointer - it's how <code>ptr::invalid_mut</code> would be implemented. There's nothing wrong with that operation?</p>",
        "id": 277326321,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753560
    },
    {
        "content": "<p>Sorry, yeah, I meant guaranteed evil once dereferenced</p>",
        "id": 277326403,
        "sender_full_name": "riking",
        "timestamp": 1648753601
    },
    {
        "content": "<p>also at the moment like 50% of time when you have a union of integer and pointer you put it in usize/uintptr_t rather than <code>*const ()</code></p>",
        "id": 277326468,
        "sender_full_name": "Talchas",
        "timestamp": 1648753633
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> <br>\na) Sure there may be other ways to optimize it, it was just supposed to be one example.<br>\nb) It's not valid and plausible under strict provenance, which is why it can be optimized away.</p>",
        "id": 277326521,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753670
    },
    {
        "content": "<p>yes, but this is supposed to be something you /gain/ from strict provenance</p>",
        "id": 277326605,
        "sender_full_name": "Talchas",
        "timestamp": 1648753697
    },
    {
        "content": "<p>so it should be an optimization you'd /like/ to have happen under weaker provenance, but can't prove</p>",
        "id": 277326627,
        "sender_full_name": "Talchas",
        "timestamp": 1648753710
    },
    {
        "content": "<p>and this is not a removal you want to have happen</p>",
        "id": 277326657,
        "sender_full_name": "Talchas",
        "timestamp": 1648753733
    },
    {
        "content": "<p>you don't know that? The point is this code results from other optimizations (such as inlining) that the compiler has done - I would definitely want it to remove a branch if that branch can't happen?</p>",
        "id": 277326723,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753776
    },
    {
        "content": "<p>for example, the <code>int2ptr</code> part may be inlined from something else</p>",
        "id": 277326769,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753801
    },
    {
        "content": "<p>it is a branch, which as a human, looks like it should be able to happen unless cond's value is known</p>",
        "id": 277326839,
        "sender_full_name": "Talchas",
        "timestamp": 1648753819
    },
    {
        "content": "<p>this is not the code that a human wrote though</p>",
        "id": 277326867,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753837
    },
    {
        "content": "<p>this is the result of previous optimization passes</p>",
        "id": 277326884,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753845
    },
    {
        "content": "<p>and there is nothing in there that says that branch probably can't happen other than that 1000000 is large</p>",
        "id": 277326940,
        "sender_full_name": "Talchas",
        "timestamp": 1648753871
    },
    {
        "content": "<p>in this case everywhere I pass <code>cond = false</code>, some other expression may have been used there instead of <code>int2ptr</code></p>",
        "id": 277326949,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753873
    },
    {
        "content": "<p>the number 1000000 has nothing to do with it? It's just there to show that this optimization may be valuable</p>",
        "id": 277327045,
        "sender_full_name": "Diggsey",
        "timestamp": 1648753915
    },
    {
        "content": "<p>yes, and if the compiler /knows/ cond = false, whether from inlining this function or deciding to specialize it on arg values or exhaustive knowledge of a local function, then it can do this without strict provenance</p>",
        "id": 277327193,
        "sender_full_name": "Talchas",
        "timestamp": 1648753974
    },
    {
        "content": "<p>but in this case it can only infer it from the fact that the alternative is UB</p>",
        "id": 277327241,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754000
    },
    {
        "content": "<p>even if the programmer \"knows\" it to be true due to eg. the type system</p>",
        "id": 277327271,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754024
    },
    {
        "content": "<p>if it doesn't then you're saying \"this int2ptr deref isn't what the programmer ever wants because it's UB, and it should be UB because of this example\"</p>",
        "id": 277327279,
        "sender_full_name": "Talchas",
        "timestamp": 1648754028
    },
    {
        "content": "<p><em>for this inlining</em> it's never what they want</p>",
        "id": 277327339,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754045
    },
    {
        "content": "<p>the function may be generic over that expression</p>",
        "id": 277327349,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754054
    },
    {
        "content": "<p>and this whole thing isn't an argument for strict provenance at all?</p>",
        "id": 277327404,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754091
    },
    {
        "content": "<p>the reason for the example is to show that you can't just mix and match strict provenance with a weaker provenance model</p>",
        "id": 277327445,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754115
    },
    {
        "content": "<p>whether an optimization is valid is a global thing that can't just look at whether \"special ptr2int is used nearby\"</p>",
        "id": 277327577,
        "sender_full_name": "Diggsey",
        "timestamp": 1648754163
    },
    {
        "content": "<p>ok, I was understanding it as an argument for optimizations you in general would want to get from strict provenance, which looking back on it probably wasn't quite what riking was saying</p>",
        "id": 277327701,
        "sender_full_name": "Talchas",
        "timestamp": 1648754242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304\">said</a>:</p>\n<blockquote>\n<p>if you look at Stacked Borrows careful enough it <em>does</em> have 'exposed' flags, they are called \"untagged\" and live in the borrow stack</p>\n</blockquote>\n<p>Yes, from a cursory reading, SB-untagged matches my intuition. So <code>sb_untagged_{ptr2int,int2ptr}</code>.</p>\n<p>I guess for the purpose of defining the language, we don't need to distinguish between <code>sb_untagged_*</code> and <code>strict_*</code>, but distinguishing would unlock more optimizations.</p>",
        "id": 277327864,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648754323
    },
    {
        "content": "<p>but inlining a <code>int2ptr</code> from a pnvi function and then later treating it as <code>strict_int2ptr</code> and not <code>pnvi_int2ptr</code> is just wrong</p>",
        "id": 277327866,
        "sender_full_name": "Talchas",
        "timestamp": 1648754325
    },
    {
        "content": "<p>and not an unavoidable wrong</p>",
        "id": 277327877,
        "sender_full_name": "Talchas",
        "timestamp": 1648754333
    },
    {
        "content": "<p>you could still do pnvi-satisfying optimizations separately (whatever those are, maybe it's too close to \"nothing\") and then on substitution you treat it as an unknown <code>fn(usize)-&gt;*const T</code></p>",
        "id": 277327983,
        "sender_full_name": "Talchas",
        "timestamp": 1648754402
    },
    {
        "content": "<p>We definitely need to distinguish between <code>{strict,sb_untagged}_x2y</code> to make CHERI feasible.</p>",
        "id": 277328935,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648754977
    },
    {
        "content": "<p>And I think <span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> 's <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317047\">polyfill</a> (though horrible) could be an acceptable polyfill for <code>sb_untagged_{ptr2int,int2ptr}</code>. We could add some SB-inspired counting to prune garbage in the TreeMap.</p>",
        "id": 277329499,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648755262
    },
    {
        "content": "<p>I mean it's ok if you don't care about silent absolutely massive performance degredation on code that someone thought was performance-relevant</p>",
        "id": 277329731,
        "sender_full_name": "Talchas",
        "timestamp": 1648755405
    },
    {
        "content": "<p>(now, programmers are fairly often /wrong/ about what is performance-relevant, but still)</p>",
        "id": 277329758,
        "sender_full_name": "Talchas",
        "timestamp": 1648755426
    },
    {
        "content": "<p>If you need CHERI, then better avoid crates that use <code>sb_untagged_*</code> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>üèªü§∑üèª I don‚Äôt really think there‚Äôs a reason around it</p>",
        "id": 277329920,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648755501
    },
    {
        "content": "<p>CHERI comes with implications</p>",
        "id": 277329937,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648755512
    },
    {
        "content": "<p>It‚Äôs not a maximum performance architecture</p>",
        "id": 277329966,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648755529
    },
    {
        "content": "<p>Hi, I'm catching up on this thread</p>",
        "id": 277334151,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648757698
    },
    {
        "content": "<p>To restart what I was talking about on the thread in a way that will hopefully come through better:<br>\nWhy are we doing this work? Is it (a) to unblock MIR- and/or LLVM-level optimizations that depend on being able to reason about provenance we would like to do in the future? Is it (b) to support real deployments of architectures based on CHERI that we have reason to think will be practical requirements for domains we care about? Or (c) to provide a more formal grounding for proofs we would like to make about the soundness of unsafe code in the academic literature? Other reasons?</p>",
        "id": 277334598,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648757927
    },
    {
        "content": "<p>Yes.</p>",
        "id": 277334660,
        "sender_full_name": "Jubilee",
        "timestamp": 1648757975
    },
    {
        "content": "<p>(d) All of the above.</p>",
        "id": 277334844,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648758064
    },
    {
        "content": "<p>I would argue that we need to be clear about what the concrete goals are, because that's the only way we can make decisions about the tradeoffs.</p>",
        "id": 277334869,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758081
    },
    {
        "content": "<p>I have concerns with all of the reasons above.</p>",
        "id": 277335005,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758143
    },
    {
        "content": "<p>Clear to who, exactly? We can never be fully clear to those who do not invest enough time to read the extensive discussions and documentation. Who, concretely, must we be clear to? Because that is also a tradeoff.</p>",
        "id": 277335007,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758143
    },
    {
        "content": "<p>Also (c part 2) to provide more formal grounding for proofs we would like to make about the soundness of unsafe code in the context of libraries trying to provide sound APIs</p>",
        "id": 277335088,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648758187
    },
    {
        "content": "<p>It's not about me not investing enough time to read discussions and documentation. I'm coming at this from the point of view of someone who has to maintain a lot of code that has to stay working when we upgrade Rust.</p>",
        "id": 277335162,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758239
    },
    {
        "content": "<p>That is precisely the problem. We would like to make it easier to make it possible to maintain code so it remains stable across upgrades. We cannot do so when our model is fundamentally Vibes, because subtle changes in the Vibes will miscompile things. Yes, this may mean an up-front cost.</p>",
        "id": 277335297,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758295
    },
    {
        "content": "<p>The point of this work is to start making it possible to pay that cost down at all.</p>",
        "id": 277335359,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758324
    },
    {
        "content": "<p>My concern is that this \"up-front cost\" is actually far too high for many users of Rust, including me.</p>",
        "id": 277335387,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758340
    },
    {
        "content": "<p>This conversation began with the very conversation to pick usize, and the cost is only as high as it is because people shrugged off the concerns then.</p>",
        "id": 277335512,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758393
    },
    {
        "content": "<p>I'm concerned that the reaction to people who bring this up is (in this case) snarky dismissal.</p>",
        "id": 277335531,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758403
    },
    {
        "content": "<p>I'm concerned that you are offering snarky dismissal also?</p>",
        "id": 277335565,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758423
    },
    {
        "content": "<p>I'm not being snarky. I'm just the messenger. I don't have the choice to pay the up-front cost you want me to pay.</p>",
        "id": 277335638,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758465
    },
    {
        "content": "<p>From my perspective, we'd pick <code>ptr as usize</code> and <code>usize as ptr</code> to be <code>sb_untagged_{ptr2int,int2ptr}</code> above by default, at least in this edition, and then we get very reasonable optimizations, all code keeps working, and we just get a bit of a shit compilation under CHERI</p>",
        "id": 277335651,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648758471
    },
    {
        "content": "<p>I don't think there would be a downside to you</p>",
        "id": 277335661,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648758479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277335651\">said</a>:</p>\n<blockquote>\n<p>From my perspective, we'd pick <code>ptr as usize</code> and <code>usize as ptr</code> to be <code>sb_untagged_{ptr2int,int2ptr}</code> above by default, at least in this edition, and then we get very reasonable optimizations, all code keeps working, and we just get a bit of a shit compilation under CHERI</p>\n</blockquote>\n<p>From a glance, this sounds like a great solution.</p>",
        "id": 277335741,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277335651\">said</a>:</p>\n<blockquote>\n<p>From my perspective, we'd pick <code>ptr as usize</code> and <code>usize as ptr</code> to be <code>sb_untagged_{ptr2int,int2ptr}</code> above by default, at least in this edition, and then we get very reasonable optimizations, all code keeps working, and we just get a bit of a shit compilation under CHERI</p>\n</blockquote>\n<p>I mean, I'm not clear that this is actually an option - SB without raw pointer tagging is broken in some pretty bad ways, and I wouldn't really want to see it land. Probably Ralf knows thigns that I don't here, but I'm not sure how to migrate this to a model with raw pointer tagging</p>",
        "id": 277335842,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648758565
    },
    {
        "content": "<p>Maybe we can even strike through <code>by default</code> and just make a lint against legacy <code>ptr as usize</code>, <code>usize as ptr</code>. The lint would be <code>allow</code> by default in the current edition</p>",
        "id": 277335843,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648758566
    },
    {
        "content": "<p>To be concrete, with some of the proposals going around here, <em>if</em> Rust starts shipping optimizations that depend on some form of strict pointer provenance, then my options are (1) don't upgrade Rust and pin ourselves to an earlier version; (2) fork the compiler to remove those optimizations.</p>",
        "id": 277335884,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758598
    },
    {
        "content": "<p>If you are saying that you are a messenger then you are speaking for Facebook, Walton, and your threats to fork are Facebook's threats to fork, and your threats to disinvest are Facebook's threats to disinvest.</p>",
        "id": 277335936,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758606
    },
    {
        "content": "<p>I would like to read more about how SB without tagging is broken. From how I understand the paper, there are no tags for <code>*T</code></p>",
        "id": 277335957,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648758618
    },
    {
        "content": "<p>Let me open a new thread for that</p>",
        "id": 277335992,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648758635
    },
    {
        "content": "<p>I'm not making any sort of threat, and in particular I'm not threatening any sort of disinvestment.</p>",
        "id": 277336014,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758648
    },
    {
        "content": "<p>I'm <em>already</em> maintaining a private fork of Rust.</p>",
        "id": 277336027,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758657
    },
    {
        "content": "<p>Because Rust dropped support for old versions of LLVM that we need to maintain interoperability with our C++ LTO toolchain, I have to maintain that internally.</p>",
        "id": 277336079,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758689
    },
    {
        "content": "<p>Then there is nothing to be gained by serving Facebook's interests, not even for Facebook.</p>",
        "id": 277336084,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758692
    },
    {
        "content": "<p>That's not true. The farther we drift from upstream, the harder it is to stay up to date.</p>",
        "id": 277336224,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758754
    },
    {
        "content": "<p>I do think that there was a tone of snarky dismissal in past discussions. But from what I've seen today, nobody is seriously considering breaking legacy code</p>",
        "id": 277336230,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648758758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336230\">said</a>:</p>\n<blockquote>\n<p>I do think that there was a tone of snarky dismissal in past discussions. But from what I've seen today, nobody is seriously considering breaking legacy code</p>\n</blockquote>\n<p>I hope that's the case, but it seems otherwise based on this conversation.</p>",
        "id": 277336255,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758772
    },
    {
        "content": "<p>\"Yes, this may mean an up-front cost\" sounds like breaking code.</p>",
        "id": 277336285,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758790
    },
    {
        "content": "<p>I have absolutely no problem with experiments for cleaner models in the future as long as we aren't going to break existing code.</p>",
        "id": 277336356,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758836
    },
    {
        "content": "<p>IMO all the \"up-front cost\" can be done away with by just putting the strict provenance stuff in new functions. And nobody seems to see a problem with this (any more)</p>",
        "id": 277336448,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648758873
    },
    {
        "content": "<p>It is in new functions already.</p>",
        "id": 277336462,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758882
    },
    {
        "content": "<p>How does that interoperate with existing code? Is it a case in which any use of non-strict provenance anywhere in the crate graph globally disables all optimizations based on strict provenance?</p>",
        "id": 277336596,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648758962
    },
    {
        "content": "<p>Currently, it doesn't.</p>",
        "id": 277336660,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758978
    },
    {
        "content": "<p>That is in the thread.</p>",
        "id": 277336669,
        "sender_full_name": "Jubilee",
        "timestamp": 1648758985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336448\">said</a>:</p>\n<blockquote>\n<p>IMO all the \"up-front cost\" can be done away with by just putting the strict provenance stuff in new functions. And nobody seems to see a problem with this (any more)</p>\n</blockquote>\n<p>I don't think this is the case - the question of \"what, then, is the memory model for non-strict provenance\" is entirely unanswered</p>",
        "id": 277336723,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648759028
    },
    {
        "content": "<p>You have to understand, the C code you are talking about cross-lang LTO with is already at risk of spontaneously beginning to miscompile. The transition cost for an upgrade is high, but if we can make something coherent in Rust, then the projection of C into Rust can be made coherent also, and not a source of other spontaneous miscompiling.</p>",
        "id": 277336970,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759177
    },
    {
        "content": "<p>That would increase, not decrease, the ability to upgrade clang.</p>",
        "id": 277337108,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759247
    },
    {
        "content": "<p>For some definition of \"risk\" that pretty much only applies to pathological code written to demonstrate the problem.</p>",
        "id": 277337142,
        "sender_full_name": "comex",
        "timestamp": 1648759268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277337142\">said</a>:</p>\n<blockquote>\n<p>For some definition of \"risk\" that pretty much only applies to pathological code written to demonstrate the problem.</p>\n</blockquote>\n<p>That's exactly what I'm getting at.</p>",
        "id": 277337158,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759277
    },
    {
        "content": "<p>The way everyone talks about it, that pathological code is everywhere.</p>",
        "id": 277337171,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759290
    },
    {
        "content": "<p>Code that violates strict_provenance is everywhere.  Code that \"what LLVM currently does\" breaks is almost nowhere.</p>",
        "id": 277337199,
        "sender_full_name": "comex",
        "timestamp": 1648759312
    },
    {
        "content": "<p>In practice, the cost of the spontaneous miscompiles for all upgrades of Clang that we might possibly do in the future is far lower than the cost of rewriting all our unsafe Rust code to conform to stacked borrows + strict provenance.</p>",
        "id": 277337200,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277337199\">said</a>:</p>\n<blockquote>\n<p>Code that violates strict_provenance is everywhere.  Code that \"what LLVM currently does\" breaks is almost nowhere.</p>\n</blockquote>\n<p>Exactly this.</p>",
        "id": 277337216,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759320
    },
    {
        "content": "<p>Despite the fact that \"what LLVM currently does\" is unsound in some cases.</p>",
        "id": 277337263,
        "sender_full_name": "comex",
        "timestamp": 1648759329
    },
    {
        "content": "<p>\"what LLVM does\" is subject to change without notice.</p>",
        "id": 277337265,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759330
    },
    {
        "content": "<p>This fact does in fact break real codebases.</p>",
        "id": 277337297,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759349
    },
    {
        "content": "<p>In practice it is not. Because if LLVM breaks us, we can raise objections and revert it upstream.</p>",
        "id": 277337311,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759355
    },
    {
        "content": "<p>This is regularly done in LLVM without pushback, because LLVM understands that you can't break real working code.</p>",
        "id": 277337342,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759380
    },
    {
        "content": "<p>Beyond that, LLVM needs to support form of unrestricted ptr2int2ptr in order to support C, and that is not going to change.</p>",
        "id": 277337388,
        "sender_full_name": "comex",
        "timestamp": 1648759410
    },
    {
        "content": "<p>(Including C with <code>-fno-strict-aliasing</code>, because some important codebases use that and also have a ton of pointer&lt;-&gt;int casts!)</p>",
        "id": 277337423,
        "sender_full_name": "comex",
        "timestamp": 1648759436
    },
    {
        "content": "<p>Based on everything I have seen, the Rust project gets a lot of pushback, even just on preserving currently-stable behaviors, so that is not really an option for us and if Facebook does not see it as important to make sure Rust has an easy time of things, that is fine, but that is not the reality the rest of the world lives in.</p>",
        "id": 277337473,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759449
    },
    {
        "content": "<p>Again, this is the same behavior that people rely on in C.</p>",
        "id": 277337559,
        "sender_full_name": "comex",
        "timestamp": 1648759507
    },
    {
        "content": "<p>This sounds like an explicit statement that Rust has decided to break one of its largest customers' codebases.</p>",
        "id": 277337561,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759508
    },
    {
        "content": "<p>Merely an observation, Walton.</p>",
        "id": 277337612,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759549
    },
    {
        "content": "<p>Unless you are also no longer \"merely a messenger\".</p>",
        "id": 277337677,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759574
    },
    {
        "content": "<p>Please calm down everyone.</p>",
        "id": 277337913,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336462\">said</a>:</p>\n<blockquote>\n<p>It is in new functions already.</p>\n</blockquote>\n<p>There are new functions, but my proposal is different from the current <code>sptr</code> / nightly <code>std::ptr</code>:</p>\n<p>I propose that </p>\n<ul>\n<li>\n<p><code>usize as ptr</code> remains permissive as is, and is defined as something like Stacked Borrows untagged. On CHERI, it would do something horribly expensive (the TreeSet approach)</p>\n</li>\n<li>\n<p><code>ptr.addr()</code> / <code>ptr as usize</code> remain permissive as is. On CHERI, they would do something horribly expensive.</p>\n</li>\n<li>\n<p>we introduce <code>ptr.addr_strict()</code> which is fast on CHERI -- but <code>ptr.addr_strict() as ptr</code> may not work.</p>\n</li>\n<li>\n<p>we keep <code>std::ptr::invalid</code> as in nightly</p>\n</li>\n</ul>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277336660\">said</a>:</p>\n<blockquote>\n<p>Currently, it doesn't.</p>\n</blockquote>\n<p>Incorrect, my proposal would interoperate perfectly fine with legacy code. Nothing changes for that.</p>",
        "id": 277337915,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759698
    },
    {
        "content": "<p>I'm not in any official position so take my statements however you will, but I don't think we're going to planning to break any Rust code until possibly far in the future.</p>",
        "id": 277337970,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648759744
    },
    {
        "content": "<p>I would really like to avoid breaking existing code. Let's not jump to \"we must break existing code\" please.</p>",
        "id": 277337981,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759749
    },
    {
        "content": "<p>I don't know what that means. All I've been saying is that the only option that I can see if Rust starts being aggressive with optimizations that require strict provenance is to revert it internally. So I'm arguing in favor of not breaking existing code, so that I don't have to do that. I don't see what's wrong with advocating for the thing that will make our life easier, but maybe the Rust community sees it differently.</p>",
        "id": 277338011,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759771
    },
    {
        "content": "<p>No additional optimizations would apply to legacy code.</p>",
        "id": 277338029,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759789
    },
    {
        "content": "<p>My point is that it might actually be convenient if Facebook saw aligning how LLVM views things with Rust's needs more important.<br>\nBut saying \"Facebook can use power to get its way\" is not the same as \"Rust can use power to get its way\".</p>",
        "id": 277338040,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759794
    },
    {
        "content": "<p>That's great to hear then.</p>",
        "id": 277338041,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759796
    },
    {
        "content": "<p>From what I understand, the translation to LLVM is still a bit shaky, but that's because LLVM is just not so well documented.</p>",
        "id": 277338047,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759800
    },
    {
        "content": "<p>From my perspective, the relationship between Facebook and LLVM is off topic</p>",
        "id": 277338122,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759830
    },
    {
        "content": "<p>Stating Facebook and everyone else live in two different universes is merely a fact.</p>",
        "id": 277338125,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759833
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338122\">said</a>:</p>\n<blockquote>\n<p>From my perspective, the relationship between Facebook and LLVM is off topic</p>\n</blockquote>\n<p>I agree.</p>",
        "id": 277338134,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759839
    },
    {
        "content": "<p>Apparently Walton believes it is immediately material.</p>",
        "id": 277338142,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759842
    },
    {
        "content": "<p>And I don't have any power :)</p>",
        "id": 277338145,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759844
    },
    {
        "content": "<p>It seems what you say does have power, since you speak for Facebook, and Facebook can get its way.</p>",
        "id": 277338205,
        "sender_full_name": "Jubilee",
        "timestamp": 1648759870
    },
    {
        "content": "<p>Please let's stop talking about Facebook‚ÄîLLVM</p>",
        "id": 277338267,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648759897
    },
    {
        "content": "<p>I don't know how we got here at all</p>",
        "id": 277338271,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648759900
    },
    {
        "content": "<p>Again, the point is moot.  The ptr&lt;-&gt;int behavior Rust is currently relying on is the same behavior that /most major C codebases/ rely on.  LLVM is not going to randomly break it, regardless of who has power or who doesn't.</p>",
        "id": 277338428,
        "sender_full_name": "comex",
        "timestamp": 1648759973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338428\">said</a>:</p>\n<blockquote>\n<p>Again, the point is moot.  The ptr&lt;-&gt;int behavior Rust is currently relying on is the same behavior that /most major C codebases/ rely on.  LLVM is not going to randomly break it, regardless of who has power or who doesn't.</p>\n</blockquote>\n<p>Yeah, in practice I'm more worried about MIR optimizations.</p>",
        "id": 277338506,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648760031
    },
    {
        "content": "<p>(One of which I wrote, and in fact hasn't landed because it's unsound) :)</p>",
        "id": 277338591,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648760060
    },
    {
        "content": "<p><a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814\">here</a> I proposed an approach to MIR optimizations that optimizes one strict-provenance function in a nice way, and which is a noop on legacy code</p>",
        "id": 277338715,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760142
    },
    {
        "content": "<p>(<code>pnvi_ae</code> should be read as the existing stuff; <code>strict_ptr2int(ptr)</code> = <code>ptr.addr_strict()</code>, <code>strict_int2ptr</code> = <code>ptr::invalid</code>)</p>",
        "id": 277338879,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338715\">said</a>:</p>\n<blockquote>\n<p><a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814\">here</a> I proposed an approach to MIR optimizations that optimizes one strict-provenance function in a nice way, and which is a noop on legacy code</p>\n</blockquote>\n<p>This looks good to me</p>",
        "id": 277338937,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648760277
    },
    {
        "content": "<p>To be clear I would love to be able to do these optimizations too</p>",
        "id": 277338993,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648760292
    },
    {
        "content": "<p>I just also have to keep our legacy code working.</p>",
        "id": 277339033,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648760324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277338715\">said</a>:</p>\n<blockquote>\n<p><a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814\">here</a> I proposed an approach to MIR optimizations that optimizes one strict-provenance function in a nice way, and which is a noop on legacy code</p>\n</blockquote>\n<p>I don't see how that approach works. You're restricted to doing these optimizations on allocations that never leave the current function, and alias analysis is not that hard on those</p>",
        "id": 277339079,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648760354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> noted that <code>pnvi-ae-*</code> doesn't make sense in the Rust story, so instead we'd presumably use the Stacked Borrows untagged model, as we do now</p>",
        "id": 277339092,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760360
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> I cant really make sense of your various <code>*_int2ptr</code>. Stacked borrows with/without untagged, the various forms of PNVI, strict provenance are all <em>different memory models</em>. they are not functions you can all.<br>\nit makes sense to ask \"what does this code do when executed under model X\".<br>\nit makes no sense to ask \"what does this operation from model X do when we are executing the rest of the code under model Y\". the result is the same as running a Linux binary on Windows -- nothing happens as the model X operation is simply not defined in the universe created by model Y.</p>",
        "id": 277339128,
        "sender_full_name": "RalfJ",
        "timestamp": 1648760381
    },
    {
        "content": "<p>has there even been a single proposal of an optimization that we might want to add that would break real code that does ptr2int2ptr roundtrips? (not the crazy code I write to demonstrate how broken everything is, but realistic code.)</p>",
        "id": 277339379,
        "sender_full_name": "RalfJ",
        "timestamp": 1648760473
    },
    {
        "content": "<p>I mean</p>\n<ul>\n<li><code>sb_untagged_int2ptr</code> is as it is now</li>\n<li><code>strict_int2ptr</code> = <code>std::ptr::invalid</code> constructs an invalid pointer. So ‚Äî we need to loosen up Stacked Borrows a bit so that <code>ptr</code>-sized things can also be invalid pointers, which will UB when dereferenced</li>\n</ul>",
        "id": 277339521,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760531
    },
    {
        "content": "<p>so basically the memory model is SB with untagged pointers but there exists a form of int2ptr cast that deliberately puts an 'invalid' provenance on the ptr? okay that makes sense.</p>",
        "id": 277339593,
        "sender_full_name": "RalfJ",
        "timestamp": 1648760577
    },
    {
        "content": "<p>'invalid' provenance is easy to add to any model</p>",
        "id": 277339609,
        "sender_full_name": "RalfJ",
        "timestamp": 1648760588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277339379\">said</a>:</p>\n<blockquote>\n<p>has there even been a single proposal of an optimization that we might want to add that would break real code that does ptr2int2ptr roundtrips? (not the crazy code I write to demonstrate how broken everything is, but realistic code.)</p>\n</blockquote>\n<p>I think not really. But it's important for CHERI to have a separate <code>ptr.addr_strict()</code> method, which is able to be quick</p>",
        "id": 277339647,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760616
    },
    {
        "content": "<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>",
        "id": 277340272,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760776
    },
    {
        "content": "<p>you basically want a \"broadcasting\" and a \"non-broadcasting\" ptr2int cast?<br>\nwell <code>ptr as usize</code> might just be the broadcasting version then. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277340519,
        "sender_full_name": "RalfJ",
        "timestamp": 1648760902
    },
    {
        "content": "<p>Indeed :D</p>",
        "id": 277340532,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648760915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> I can't speak for anyone else, but for me the point of this experiment is to figure out how much of the Rust ecosystem we can get into the nice well-behaved room that is \"strict provenance\". Since I never expected to actually be able to eliminate ptr2int2ptr roundtrips (and the reactions here confirmed that), I think the worst case scenario here is that when you write <code>ptr as usize</code> or <code>usize as ptr</code> you \"opt-out\" of the fragment of Rust that can be checked by Miri, compiled to CHERI, or be understood with a precise spec. You opt-in to a vague memory model that we can't reason formally about. That's basically the status quo for all of Rust today. So like today: if you show us real code that is 'reasonable' (whatever that means) and gets miscompiled it will be considered a bug (in particular if it is a regression, i.e., code that worked before).</p>",
        "id": 277340540,
        "sender_full_name": "RalfJ",
        "timestamp": 1648760922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I think that's pretty reasonable.</p>",
        "id": 277340572,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648760960
    },
    {
        "content": "<p>Personally, I'm unsure how much actual real-world relevance CHERI is going to have, but if it makes our memory model simpler in general then that's fine.</p>",
        "id": 277340695,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648761022
    },
    {
        "content": "<p>yeah CHERI is just one item in the list here</p>",
        "id": 277340715,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761038
    },
    {
        "content": "<p>this doesn't just affect Miri either, it affects all formal tools for checking Rust (model checkers, etc.)</p>",
        "id": 277340749,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340272\">said</a>:</p>\n<blockquote>\n<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>\n</blockquote>\n<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf(\"%p\")</code> and <code>sscanf(\"%p\")</code>) but never as something anyone would actually implement.</p>",
        "id": 277340798,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648761098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340519\">said</a>:</p>\n<blockquote>\n<p>you basically want a \"broadcasting\" and a \"non-broadcasting\" ptr2int cast?<br>\nwell <code>ptr as usize</code> might just be the broadcasting version then. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</blockquote>\n<p>Basically. But for runtime would be reeeeally nice to know when to \"undo\" the broadcast. I imagine the protectors might be trigger points for this</p>",
        "id": 277340801,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648761099
    },
    {
        "content": "<p>It would be nice to be able to localize the effects of ptr-&gt;int-&gt;ptr conversions to at least the \"FFI\" level. i.e. at the very least, if you cross from strict provenance Rust to non-strict-provenance Rust, then it's like calling an extern C function from the perspective of the API. It doesn't turn off all optimizations based on strict provenance for the entire compilation graph.</p>",
        "id": 277340882,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648761123
    },
    {
        "content": "<p>if the experiment goes really well and strict provenance is sufficiently expressive we might be able to deprecate <code>usize as ptr</code> and <code>ptr as usize</code>, which would help ensure new code is within \"strict Rust\". but the experiment also might show that there are some things we can't do inside \"struct Rust\" even if people rewrote everything and then deprecation wouldn't make a ton of sense. we'll see.</p>",
        "id": 277340913,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"490906\">Brooks Davis</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340798\">said</a>:</p>\n<blockquote>\n<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf(\"%p\")</code> and <code>sscanf(\"%p\")</code>) but never as something anyone would actually implement.</p>\n</blockquote>\n<p>Unfortunately there's no silver bullet! We can't keep all existing code working _and_ find all the bugs at the same time. But a lint as described above would help massively</p>",
        "id": 277340957,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648761168
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> well see above, I literally dont know of any optimization this would even affect</p>",
        "id": 277340974,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761174
    },
    {
        "content": "<p>the current vague memory model means \"lets just do optimizations it'll be fine\"</p>",
        "id": 277341005,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761193
    },
    {
        "content": "<p>and that seems to work for you... I dont see how that would become any worse if we can actually say \"oh btw, for strict Rust programs these optimizations are actually definitely correct\"</p>",
        "id": 277341038,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761219
    },
    {
        "content": "<p>Isn't the current memory model Stacked Borrows?</p>",
        "id": 277341049,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648761225
    },
    {
        "content": "<p>Stacked Borrows is a proposed memory model, not official. unclear relationship to LLVM (mostly because LLVM's model is -- surprise -- unclear)</p>",
        "id": 277341129,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761258
    },
    {
        "content": "<p>Right, and there's Polonius as well. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Does it have a similar notion of untagged?</p>",
        "id": 277341165,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648761295
    },
    {
        "content": "<p>Interesting. Sounds like it'd be valuable to enumerate the specific optimizations we'd like to be able to do and what requirements they place on the memory model.</p>",
        "id": 277341212,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648761326
    },
    {
        "content": "<p>Also, note that there are at least two variants of SB (with or without raw pointer tagging) and that there will likely be more in the future</p>",
        "id": 277341222,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648761336
    },
    {
        "content": "<p>Even if just scoped to the MIR level so we can avoid the thorny questions about what LLVM plans to do.</p>",
        "id": 277341293,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648761366
    },
    {
        "content": "<p>I imagine the rules for ptr2int2ptr might be that</p>\n<ul>\n<li><code>ptr as usize</code> \"broadcasts\" that pointer's provenance</li>\n<li><code>usize as ptr</code> picks <em>some</em> 'broadcast' provenance, namely the one that works. (basically: speculatively execute the program with each possible choice, pick the one that is not UB. formally: angelic non-determinism.)</li>\n</ul>\n<p>under these rules, if we can get the compiler to honor that \"broadcasting\" (treat ptr2int as having a sort of side-effect), I don't see how we could misoptimize. it's just a hideous model to check a program against (in miri, CHERI, a model checker, really any context), so it'd be great if we could avoid using it except for 'legacy' applications. :D</p>",
        "id": 277341328,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277341165\">said</a>:</p>\n<blockquote>\n<p>Right, and there's Polonius as well. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Does it have a similar notion of untagged?</p>\n</blockquote>\n<p>polonious is just an analysis, not affecting optimizations or UB</p>",
        "id": 277341370,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761424
    },
    {
        "content": "<p>Stacked borrows is particularly notable because it's the only proposed model that we have a checker for. I would not mind seeing some kind of checker for rustc's use of LLVM <code>noalias</code>, because I've once or twice found code that doesn't pass Miri and I really wasn't sure if it was UB with respect to <code>noalias</code>.</p>",
        "id": 277341496,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648761494
    },
    {
        "content": "<p>yeah well that would mean someone has to first define noalias precisely enough that a checker can even theoretically be implemented :D</p>",
        "id": 277341533,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277341328\">said</a>:</p>\n<blockquote>\n<p>I imagine the rules for ptr2int2ptr might be that</p>\n<ul>\n<li><code>ptr as usize</code> \"broadcasts\" that pointer's provenance</li>\n<li><code>usize as ptr</code> picks <em>some</em> 'broadcast' provenance, namely the one that works. (basically: speculatively execute the program with each possible choice, pick the one that is not UB. formally: angelic non-determinism.)</li>\n</ul>\n<p>under these rules, if we can get the compiler to honor that \"broadcasting\" (treat ptr2int as having a sort of side-effect), I don't see how we could misoptimize. it's just a hideous model to check a program against (in miri, CHERI, a model checker, really any context), so it'd be great if we could avoid using it except for 'legacy' applications. :D</p>\n</blockquote>\n<p>so <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> regarding this model there is a possible surprise left... what this would not let you do is <em>transmute</em> a pointer to an integer and then cast that back and do anything with it. transmutes rather than casts are their own can of worms... but that seems even less common that doing the casts?<br>\n(note that by transmute I mean any form of type punning, via <code>mem::transmute</code>, via unions, or via pointer type punning).</p>",
        "id": 277343658,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762772
    },
    {
        "content": "<p>that is because <code>ptr as usize</code> is required to do the \"broadcast\"; a transmute doesn't do that</p>",
        "id": 277343766,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762820
    },
    {
        "content": "<p>Does \"broadcasting\" here mean something other than \"escaping\" in PNVI-ae?</p>",
        "id": 277343938,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648762951
    },
    {
        "content": "<p>they're the same</p>",
        "id": 277344062,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763055
    },
    {
        "content": "<p>I'm still not sure if we need an address-exposure model in Rust. Even PNVI-plain is sufficient to compile most C code without miscompilation, and I can understand needing to allow some fast and loose stuff, but PNVI-plain genuinely seems sufficient because er, well</p>\n<p>as mentioned, most code is simply not actually that pathological.</p>",
        "id": 277344487,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763343
    },
    {
        "content": "<p>I'm open to <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  telling me it can't work like that tho'.</p>",
        "id": 277344676,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763452
    },
    {
        "content": "<p>hm I'll have to check what PNVI-plain does on int2ptr...</p>",
        "id": 277344705,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763479
    },
    {
        "content": "<p>wait, ISTR that PNVI-plain is even more permissive than -ae, it allows magicking up any provenance more or less</p>",
        "id": 277344841,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648763569
    },
    {
        "content": "<p>Sortof. :D</p>",
        "id": 277344908,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763610
    },
    {
        "content": "<p>oh that's broken</p>",
        "id": 277345035,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763664
    },
    {
        "content": "<p>So... it makes a bunch of optimizations illegal that we want to do?</p>",
        "id": 277345052,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648763673
    },
    {
        "content": "<p>all of the optimization arguments for Stacked Borrows proceed by \"I generated this provenance and it is wholly impossible for any other part of the program to have a pointer with that same provenance\"</p>",
        "id": 277345076,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277345052\">said</a>:</p>\n<blockquote>\n<p>So... it makes a bunch of optimizations illegal that we want to do?</p>\n</blockquote>\n<p>yes. where \"a bunch\" = all of them.^^</p>",
        "id": 277345093,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763703
    },
    {
        "content": "<p>Ah okay. :D</p>",
        "id": 277345096,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763705
    },
    {
        "content": "<p>Nevermind then. :D</p>",
        "id": 277345107,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763711
    },
    {
        "content": "<p>We can try making CPUs faster instead :D</p>",
        "id": 277345134,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648763735
    },
    {
        "content": "<p>you'll see me out here with an FPGA working on a new CPU design, mark my words</p>",
        "id": 277345232,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763778
    },
    {
        "content": "<p>there might be super complicated ways to avoid having an explicit 'expose' (that's what <a href=\"https://www.ralfj.de/research/twinsem/twinsem.pdf\">https://www.ralfj.de/research/twinsem/twinsem.pdf</a> does). but honestly, if strict provenance works out sufficiently well that means we'll not have many 'expose' so making those expensive (for optimizations) seems fine...</p>",
        "id": 277345275,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763808
    },
    {
        "content": "<blockquote>\n<p>checks whether the pointer points into a live object and if so, recreates the appropriate provenance</p>\n</blockquote>\n<p>yes, that allows address guessing, I think it's out</p>",
        "id": 277345278,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648763813
    },
    {
        "content": "<p>got-cha.</p>",
        "id": 277345308,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763830
    },
    {
        "content": "<p>\"portable assembly\", some people would be very happy with this</p>",
        "id": 277345328,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648763843
    },
    {
        "content": "<p>of the named PNVI variants, I believe -ae is actually the strictest</p>",
        "id": 277345345,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648763853
    },
    {
        "content": "<p>I actually full-on believe that \"C is bad\" (insofar as I believe that... it's more like \"eh, kinda\") mostly because it is not as good a portable assembler as it could be.</p>",
        "id": 277345462,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763915
    },
    {
        "content": "<p>in one of the papers they had PNVI-wildcard which is like -plain except the pointer gets superpowers and you can now even offset (without any further casts) OOB and into another live object then use it</p>",
        "id": 277345515,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648763954
    },
    {
        "content": "<p>yeah that one seemed mostly just funny.</p>",
        "id": 277345538,
        "sender_full_name": "Jubilee",
        "timestamp": 1648763980
    },
    {
        "content": "<p>the main concerns with 'expose' are</p>\n<ul>\n<li>do people think that anything else (besides ptr2int <em>casts</em>) does expose? like, does a ptr2int <em>transmute</em> (or a load of a ptr value at int type) expose? if the answer is yes then it's broken again because basically every load could be type-punning and thus expose. [This is the very problem PNVI-ae-udi does not have since they can rule this out via C's strict alias.]</li>\n<li>also, LLVM treats ptr2int as not having a side-effect, which is incompatible with 'expose'.</li>\n</ul>\n<p>so, my thinking on this right now is</p>\n<ul>\n<li>no transmutes dont expose, transmutes are just UB.</li>\n<li>LLVM is broken but that's okay since code that does expose is 'outside of strict Rust' and is supported on a \"Vibes Memory Model best effort\" kind of basis. meanwhile I can have my beautiful formal garden next door where 'expose' doesn't exist and so LLVM's lack of it does not concern me. ;)</li>\n</ul>",
        "id": 277345548,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763990
    },
    {
        "content": "<p>But also is why I mentioned \"please do not conflate PNVI-{x} with PNVI-{y}.\"</p>",
        "id": 277345648,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764019
    },
    {
        "content": "<p>\"PNVI-roll-a-die breaks your intuitions. What, you say no one is discussing it? Well, now I am! cope.\"</p>",
        "id": 277345789,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764083
    },
    {
        "content": "<p>yeah but nobody can remember PNVI-ae-udi^^</p>",
        "id": 277345826,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764107
    },
    {
        "content": "<p>I'll accept PNVI-C, tbh.</p>",
        "id": 277345853,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764119
    },
    {
        "content": "<p>strict provenance could reasonably be called PNVI-UB.<br>\nunder strict provenance, integers also have no provenance</p>",
        "id": 277345854,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648764120
    },
    {
        "content": "<p>right.</p>",
        "id": 277345896,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764126
    },
    {
        "content": "<p>PNVI-strict</p>",
        "id": 277345904,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764133
    },
    {
        "content": "<p>but then SB would be PNVI-SB</p>",
        "id": 277345918,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277345853\">said</a>:</p>\n<blockquote>\n<p>I'll accept PNVI-C, tbh.</p>\n</blockquote>\n<p>maybe \"PNVI-gcc\"</p>",
        "id": 277345921,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764147
    },
    {
        "content": "<p>I mean we arent even considering giving provenance to integers</p>",
        "id": 277345937,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764157
    },
    {
        "content": "<p>so the PNVI prefix isnt even conveying any information</p>",
        "id": 277345951,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764164
    },
    {
        "content": "<p>right.</p>",
        "id": 277345952,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764165
    },
    {
        "content": "<p>Well, sorta.</p>",
        "id": 277345971,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764174
    },
    {
        "content": "<p>I think it's important that we all agree that integers do not have provenance, even if we believe that somehow provenance can jump the gap where a pointer briefly roleplays as an integer.</p>",
        "id": 277346047,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764224
    },
    {
        "content": "<p>Thus even though it conveys no additional information I would like that people continue using it, because it signals that we are on an initial page.</p>",
        "id": 277346127,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764258
    },
    {
        "content": "<p>We can probably, with more or less effort, find somewhere we agree on in this page.<br>\nBut that initial agreement step matters, and is not actually trivial, for realsies.</p>",
        "id": 277346270,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764361
    },
    {
        "content": "<p>doesn't C still have a bunch of type punning to contend with if it wants PNVI-ae? or does it really stop at memcpy?</p>",
        "id": 277346346,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648764390
    },
    {
        "content": "<p>it has unions too</p>",
        "id": 277346417,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648764439
    },
    {
        "content": "<p>but only in some cases</p>",
        "id": 277346427,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648764447
    },
    {
        "content": "<p>PNVIplain doesn't allow address guessing, but it does this by introducing allocation address nondeterminism... Yeah.</p>",
        "id": 277346442,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648764465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277346442\">said</a>:</p>\n<blockquote>\n<p>PNVIplain doesn't allow address guessing, but it does this by introducing allocation address nondeterminism... Yeah.</p>\n</blockquote>\n<p>oh hm.</p>",
        "id": 277346578,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277346346\">said</a>:</p>\n<blockquote>\n<p>doesn't C still have a bunch of type punning to contend with if it wants PNVI-ae? or does it really stop at memcpy?</p>\n</blockquote>\n<p>right, there is C out there that is basically just broken according to the rules of C and miscompiles if pointed at the wrong architecture (and it's not always \"weird arches like CHERI\" doing the breaking, mind)</p>",
        "id": 277346674,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764589
    },
    {
        "content": "<p>like it's not even \"under optimizations\" broken, it's just \"lol it doesn't work\"<br>\nthis is not necessarily an issue ofc for C on a typical x86-64 machine, I can cheerfully acknowledge that.</p>",
        "id": 277346851,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764670
    },
    {
        "content": "<p>Right, but I was under the impression that at least certain forms of union punning were legal.</p>",
        "id": 277346880,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648764687
    },
    {
        "content": "<p>plain pointer casting to an incompatible type (followed by an access) is UB, that much I know</p>",
        "id": 277347004,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648764750
    },
    {
        "content": "<p>I think talking about platform provenance or PNVI-ae-udi is probably the most clear. In C, union type punning is legal in C proper, so union reads are implicit expose points. Under Cereberus (the checker for PNVI), it allows no strict aliasing semantics, and redundant loads and stores cannot be removed.</p>",
        "id": 277347086,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648764816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277346880\">said</a>:</p>\n<blockquote>\n<p>Right, but I was under the impression that at least certain forms of union punning were legal.</p>\n</blockquote>\n<p><a href=\"https://trofi.github.io/posts/191-ghc-on-m68k.html\">https://trofi.github.io/posts/191-ghc-on-m68k.html</a><br>\nonly darkness now <em>gazes into the distance</em></p>",
        "id": 277347228,
        "sender_full_name": "Jubilee",
        "timestamp": 1648764906
    },
    {
        "content": "<p>That's not a union pun, it's a function-pointer pun.</p>",
        "id": 277347731,
        "sender_full_name": "comex",
        "timestamp": 1648765257
    },
    {
        "content": "<p>by which I mean calling a function pointer with the wrong function type.</p>",
        "id": 277347816,
        "sender_full_name": "comex",
        "timestamp": 1648765309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277343658\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277341328\">said</a>:</p>\n<blockquote>\n<p>I imagine the rules for ptr2int2ptr might be that</p>\n<ul>\n<li><code>ptr as usize</code> \"broadcasts\" that pointer's provenance</li>\n<li><code>usize as ptr</code> picks <em>some</em> 'broadcast' provenance, namely the one that works. (basically: speculatively execute the program with each possible choice, pick the one that is not UB. formally: angelic non-determinism.)</li>\n</ul>\n<p>under these rules, if we can get the compiler to honor that \"broadcasting\" (treat ptr2int as having a sort of side-effect), I don't see how we could misoptimize. it's just a hideous model to check a program against (in miri, CHERI, a model checker, really any context), so it'd be great if we could avoid using it except for 'legacy' applications. :D</p>\n</blockquote>\n<p>so <span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> regarding this model there is a possible surprise left... what this would not let you do is <em>transmute</em> a pointer to an integer and then cast that back and do anything with it. transmutes rather than casts are their own can of worms... but that seems even less common that doing the casts?<br>\n(note that by transmute I mean any form of type punning, via <code>mem::transmute</code>, via unions, or via pointer type punning).</p>\n</blockquote>\n<p>This might work. Another possibility would be special case the function <code>mem::transmute</code> and make it an intrinsic</p>",
        "id": 277347901,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765346
    },
    {
        "content": "<p>It could be that 99% of ptr-to-int casts are either through <code>as</code> or through <code>mem::transmute</code>.</p>",
        "id": 277347941,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765385
    },
    {
        "content": "<p>Then we could declare other ways UB and only have a couple of stragglers to fix up. I don't love this solution but it could work in practice.</p>",
        "id": 277347979,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765421
    },
    {
        "content": "<p>What about <code>ptr::cast</code>?</p>",
        "id": 277347993,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765431
    },
    {
        "content": "<p>Is that an <code>as</code> internally?</p>",
        "id": 277348062,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347993\">said</a>:</p>\n<blockquote>\n<p>What about <code>ptr::cast</code>?</p>\n</blockquote>\n<p>That too. Basically I mean just allowlist a special set of commonly-used \"cast-like\" functions</p>",
        "id": 277348067,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765457
    },
    {
        "content": "<p>This is like what C ended up doing with strict-aliasing. <code>char</code> becomes the allowlisted \"magic type punny type\" because that's what people were doing in practice.</p>",
        "id": 277348139,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347993\">said</a>:</p>\n<blockquote>\n<p>What about <code>ptr::cast</code>?</p>\n</blockquote>\n<p>It's an <code>as</code>, but it's <a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\">only ptr-to-ptr</a>, not ptr-to-int.</p>",
        "id": 277348144,
        "sender_full_name": "scottmcm",
        "timestamp": 1648765517
    },
    {
        "content": "<p>We could probably analyze which functions people cast with in the wild.</p>",
        "id": 277348191,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765549
    },
    {
        "content": "<p>right, but you can use it for ptr-ptr to int-ptr</p>",
        "id": 277348192,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765549
    },
    {
        "content": "<p><code>mem::transmute</code> is actually the one that pretty much has to be UB to do the ptr-&gt;int conversion</p>",
        "id": 277348193,
        "sender_full_name": "Jubilee",
        "timestamp": 1648765549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'm a bit confused what exactly you're proposing.  Are you saying we would generate more-conservative LLVM IR, or are you talking about hypothetical changes to LLVM optimizations?  In the former case I don't see why transmutes would be any /more/ broken than they are today.</p>",
        "id": 277348196,
        "sender_full_name": "comex",
        "timestamp": 1648765550
    },
    {
        "content": "<p>It's easier to preserve <code>ptr as int</code> than <code>transmute(ptr) -&gt; int</code></p>",
        "id": 277348287,
        "sender_full_name": "Jubilee",
        "timestamp": 1648765588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348287\">said</a>:</p>\n<blockquote>\n<p>It's easier to preserve <code>ptr as int</code> than <code>transmute(ptr) -&gt; int</code></p>\n</blockquote>\n<p>Why?</p>",
        "id": 277348296,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347901\">said</a>:</p>\n<blockquote>\n<p>This might work. Another possibility would be special case the function <code>mem::transmute</code> and make it an intrinsic</p>\n</blockquote>\n<p>Seems a potential can of worms. How about transmute to <code>[*T]</code>? Could be &gt; O(n) on CHERI</p>",
        "id": 277348323,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765619
    },
    {
        "content": "<p>If you make transmute an intrinsic then the compiler is free to optimize <code>transmute(ptr) -&gt; int</code> identically to <code>ptr as int</code></p>",
        "id": 277348341,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765633
    },
    {
        "content": "<p>transmute and its moral equivalents would have to expose any addresses converted arbitrarily deep into the hierarchy, right?</p>",
        "id": 277348351,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765640
    },
    {
        "content": "<p>(It would just be that avoiding transmutes would put you in the \"known-good formalizable subset\", but not avoiding them would still put you in today's safe-other-than-pathological-examples subset‚Ä¶?)</p>",
        "id": 277348372,
        "sender_full_name": "comex",
        "timestamp": 1648765653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348323\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277347901\">said</a>:</p>\n<blockquote>\n<p>This might work. Another possibility would be special case the function <code>mem::transmute</code> and make it an intrinsic</p>\n</blockquote>\n<p>Seems a potential can of worms. How about transmute to <code>[*T]</code>? Could be &gt; O(n) on CHERI</p>\n</blockquote>\n<p>In general, I'm not sure we should hold back our semantics because of O(n) behavior on CHERI, unless we know there is some concrete use case that needs CHERI (e.g. if Google says \"all Android apps must be CHERI compliant\").</p>",
        "id": 277348466,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765715
    },
    {
        "content": "<p>you can transmute [&amp;*const (); 15] to [&usize; 15] or something</p>",
        "id": 277348476,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765722
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218745\">@Wanja Hentze</span> Nah - it's just that if you write a pointer to some memory and then read it from a pointer-to-integer, that has to count as a provenance broadcast (or else converting the integer back to a pointer would be UB).</p>",
        "id": 277348479,
        "sender_full_name": "comex",
        "timestamp": 1648765725
    },
    {
        "content": "<p>if the exposure happens on the read, not the cast, doesn't that mean we kinda have typed memory then?</p>",
        "id": 277348520,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765771
    },
    {
        "content": "<p>But in any case, you could imagine something like semantics that say transmute of a raw pointer <em>only</em> is defined (e.g. <code>*T -&gt; usize</code> is OK, <code>(*T, *T) -&gt; (usize, usize)</code> is not). You can be as messy as you want.</p>",
        "id": 277348525,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765777
    },
    {
        "content": "<p>The point is to keep currently-working code working.</p>",
        "id": 277348551,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765793
    },
    {
        "content": "<p>are direct ptr/int transmutes that common? they really serve no good purpose as far as I can tell</p>",
        "id": 277348702,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765915
    },
    {
        "content": "<blockquote>\n<p>This might work. Another possibility would be special case the function mem::transmute and make it an intrinsic</p>\n</blockquote>\n<p><code>transmute</code> works on <em>all</em> types though, so it's somewhat hard to define such an exception.<br>\nalso, if we allow them we very quickly see that things just <em>obviously</em> don't work: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431</a>. like, ptr2int2ptr roundtrips with explicit casts can be salvaged with some work, but the transmutes are a lost cause I think.<br>\nEDIT: well I guess we'd have to <em>also</em> special-case int2ptr transmutes. that could work. but... ugh.</p>",
        "id": 277348765,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765942
    },
    {
        "content": "<blockquote>\n<p>But in any case, you could imagine something like semantics that say transmute of a raw pointer <em>only</em> is defined (e.g. <code>*T -&gt; usize</code> is OK, <code>(*T, *T) -&gt; (usize, usize)</code> is not). You can be as messy as you want.</p>\n</blockquote>\n<p>That seems very hard to learn</p>",
        "id": 277348768,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765946
    },
    {
        "content": "<p>the cases where the cast happens behind some indirection are much more interesting imo because those are not served by <code>as</code></p>",
        "id": 277348770,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648765947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348372\">said</a>:</p>\n<blockquote>\n<p>(It would just be that avoiding transmutes would put you in the \"known-good formalizable subset\", but not avoiding them would still put you in today's safe-other-than-pathological-examples subset‚Ä¶?)</p>\n</blockquote>\n<p>This is an important point. I think it would be helpful to be clear about whether we're talking about using this memory model to introduce aggressive optimizations that may break existing code. Because if it's \"just formalizability\", then we can break things.</p>",
        "id": 277348775,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648765953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I'm a bit confused what exactly you're proposing.  Are you saying we would generate more-conservative LLVM IR, or are you talking about hypothetical changes to LLVM optimizations?  In the former case I don't see why transmutes would be any /more/ broken than they are today.</p>\n</blockquote>\n<p>sorry, which proposal are you referring to?</p>",
        "id": 277348798,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218745\">@Wanja Hentze</span> Well, I should say, @RalfJ was just advocating for having it be UB not to do the *read itself, but to convert the resulting integer back to a pointer.  But if you want this to not be UB, then the broadcast has to happen at the time of the read.</p>",
        "id": 277348828,
        "sender_full_name": "comex",
        "timestamp": 1648765985
    },
    {
        "content": "<p>Note that IIUC, in C with PNVI, transmute of an array pointer also doesn't work</p>",
        "id": 277348838,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765992
    },
    {
        "content": "<p>right.</p>",
        "id": 277348843,
        "sender_full_name": "Jubilee",
        "timestamp": 1648765994
    },
    {
        "content": "<p>We don't necessarily have to be holier than C</p>",
        "id": 277348867,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766009
    },
    {
        "content": "<p>transmute basically works because it does a bit-copy and asserts this is the new type.</p>",
        "id": 277348868,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766009
    },
    {
        "content": "<p>as opposed to a potentially lossy Magic Conversion Operation</p>",
        "id": 277348881,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348768\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But in any case, you could imagine something like semantics that say transmute of a raw pointer <em>only</em> is defined (e.g. <code>*T -&gt; usize</code> is OK, <code>(*T, *T) -&gt; (usize, usize)</code> is not). You can be as messy as you want.</p>\n</blockquote>\n<p>That seems very hard to learn</p>\n</blockquote>\n<p>Not breaking code is more important than learnability, if we're talking about doing optimizations. (If it's just formalizability, then that might not be the case)</p>",
        "id": 277348885,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766032
    },
    {
        "content": "<p><code>as</code> is, in a sense, our Magic Conversion, as opposed to Transmute.</p>",
        "id": 277348937,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766053
    },
    {
        "content": "<p>I guess we should investigate how much <code>transmute</code> is being used to a pointer</p>",
        "id": 277348943,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348798\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I'm a bit confused what exactly you're proposing.  Are you saying we would generate more-conservative LLVM IR, or are you talking about hypothetical changes to LLVM optimizations?  In the former case I don't see why transmutes would be any /more/ broken than they are today.</p>\n</blockquote>\n<p>sorry, which proposal are you referring to?</p>\n</blockquote>\n<p>The regime you're talking about where ptr2int2ptr is okay, but doing the same with transmutes loses provenance.</p>",
        "id": 277348967,
        "sender_full_name": "comex",
        "timestamp": 1648766086
    },
    {
        "content": "<p>my point was: direct int/ptr transmute is silly, you can immediately replace it with <code>as</code> in 100% of cases so if it isn't already, it should be a default clippy lint</p>",
        "id": 277348990,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766103
    },
    {
        "content": "<p>Right.</p>",
        "id": 277349016,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> Definitely worthwhile. I can look into doing a crater run if people think this is worthwhile</p>",
        "id": 277349017,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348296\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348287\">said</a>:</p>\n<blockquote>\n<p>It's easier to preserve <code>ptr as int</code> than <code>transmute(ptr) -&gt; int</code></p>\n</blockquote>\n<p>Why?</p>\n</blockquote>\n<p><code>as</code> is a very targeted primitive that it is easy to ascribe special rules for, that only works with certain very specific types.<br>\n<code>transmutes</code> works for arbitrary input output types, so we'd have to either make wild lists of exceptions or find some generic rule that makes any sense.</p>",
        "id": 277349020,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348990\">said</a>:</p>\n<blockquote>\n<p>my point was: direct int/ptr transmute is silly, you can immediately replace it with <code>as</code> in 100% of cases so if it isn't already, it should be a default clippy lint</p>\n</blockquote>\n<p>ah yes that is also a very good argument :)</p>",
        "id": 277349041,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766151
    },
    {
        "content": "<p><em>if</em> transmute that turns ptrs to ints is to be supported, then it only makes sense if the nontrivial cases work</p>",
        "id": 277349046,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277348990\">said</a>:</p>\n<blockquote>\n<p>my point was: direct int/ptr transmute is silly, you can immediately replace it with <code>as</code> in 100% of cases so if it isn't already, it should be a default clippy lint</p>\n</blockquote>\n<p>Be that as it may, if people are using <code>mem::transmute</code> instead of <code>as</code>, we should continue supporting it if we don't want to break code.</p>",
        "id": 277349047,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766157
    },
    {
        "content": "<p>I think \"not breaking code\" is a two-way conversation, for code like this that lives \"on the edge\"</p>",
        "id": 277349115,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766193
    },
    {
        "content": "<p>Still unclear to me what concrete change we're talking about that would cause this to break.</p>",
        "id": 277349133,
        "sender_full_name": "comex",
        "timestamp": 1648766220
    },
    {
        "content": "<p>IMO, if we tell you \"here's an easy change you can apply basically automatically to avoid breaking your code\". that's a reasonable ask from our side</p>",
        "id": 277349142,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766225
    },
    {
        "content": "<p>I would really like to not break code, but for me it's not a 100% absolute.</p>",
        "id": 277349148,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349142\">said</a>:</p>\n<blockquote>\n<p>IMO, if we tell you \"here's an easy change you can apply basically automatically to avoid breaking your code\". that's a reasonable ask from our side</p>\n</blockquote>\n<p>I strongly disagree.</p>",
        "id": 277349151,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766237
    },
    {
        "content": "<p>FWIW <a href=\"https://github.com/rust-lang/rust/pull/95516\">https://github.com/rust-lang/rust/pull/95516</a> fixes one of those transmutes, and it's not <code>*const</code> to <code>usize</code>, it is some opaque assoc type top <code>usize</code>.</p>",
        "id": 277349182,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766265
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> strict provenance breaks both this and <code>int as ptr</code>. PNVI-ae with special casing for <code>as</code> breaks the transmute</p>",
        "id": 277349190,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349133\">said</a>:</p>\n<blockquote>\n<p>Still unclear to me what concrete change we're talking about that would cause this to break.</p>\n</blockquote>\n<p>I think <code>transmute</code> from a ptr (with provenance) to an int is UB (as in, it is already broken as of today and we might just get lucky that LLVM hasn't broken anything yet). also see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431for\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431for</a> why.</p>",
        "id": 277349257,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766297
    },
    {
        "content": "<p>The spirit of the Rust 1.0 compatibility promise is that Rust will not make changes that will break code, outside of a specifically delineated set of exceptions. In particular, there's no \"it's an easy fix\" exception.</p>",
        "id": 277349293,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766321
    },
    {
        "content": "<p>I know that unsafe code is one of those specifically-delimited set of exceptions.</p>",
        "id": 277349309,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766335
    },
    {
        "content": "<p>And transmute is <code>unsafe fn</code>.</p>",
        "id": 277349324,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766349
    },
    {
        "content": "<p>But the reasoning behind that decision applies to unsafe code at this point too, whether we explicitly acknowledge it or not.</p>",
        "id": 277349377,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766389
    },
    {
        "content": "<p>I mean we certainly won't be able to preserve all code that is UB but 'happens to work'.<br>\nwe also have no precise spec for UB. so we're going to have to break <em>some</em> code that people think doesn't have UB (but actually does), that is just inevitable.</p>",
        "id": 277349380,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766393
    },
    {
        "content": "<p>this has nothing to do with strict provenance</p>",
        "id": 277349447,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766419
    },
    {
        "content": "<p>We're having this whole discussion because we want to provide (at least _some_) backwards compatibility for Unsafe Rust.</p>",
        "id": 277349466,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766432
    },
    {
        "content": "<p>each LLVM update will break some code with UB, whether or not the author agrees that the code has UB or not</p>",
        "id": 277349475,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766440
    },
    {
        "content": "<p>I don't want to start this point again ‚Äî we all want to keep some/most/all backwards compatibility here</p>",
        "id": 277349507,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766461
    },
    {
        "content": "<p>Okay.  But if you're just saying 'LLVM might break this in the future', rather than 'let's go ahead and add Rust-specific optimizations that break this', then pcwalton has nothing to be afraid of from this effort in particular.</p>",
        "id": 277349513,
        "sender_full_name": "comex",
        "timestamp": 1648766464
    },
    {
        "content": "<p>well, I should say -</p>",
        "id": 277349545,
        "sender_full_name": "comex",
        "timestamp": 1648766489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> what does miri currently do with ptr-to-int transmute?</p>",
        "id": 277349570,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766504
    },
    {
        "content": "<p>'LLVM might break this in less-pathological code than it currently does, and/or someone might write code that LLVM currently breaks'</p>",
        "id": 277349579,
        "sender_full_name": "comex",
        "timestamp": 1648766507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349475\">said</a>:</p>\n<blockquote>\n<p>each LLVM update will break some code with UB, whether or not the author agrees that the code has UB or not</p>\n</blockquote>\n<p>Correct. But that's not a license for LLVM to break code willy-nilly. For LLVM it ends up being a subjective judgment call depending on whether there's a lot of important code that will break.</p>",
        "id": 277349583,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766509
    },
    {
        "content": "<p>I think it's the same for us</p>",
        "id": 277349597,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766520
    },
    {
        "content": "<p>Agreed.</p>",
        "id": 277349640,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766524
    },
    {
        "content": "<p>well, whether or not you transmute directly from pointer to int is a statically checkable property of a rust program, right? can we count how often people do that to put some data to this discussion?</p>",
        "id": 277349657,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766536
    },
    {
        "content": "<p>crater runs are often used in the case of technically-but-maybe-not-morally-breaking changes</p>",
        "id": 277349707,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Your new example makes me more convinced that what we actually need is PVI :)</p>",
        "id": 277349711,
        "sender_full_name": "comex",
        "timestamp": 1648766578
    },
    {
        "content": "<p>yeah totally. but I think this kind of working with each other to move the langue towards a better understanding of UB has to be a two-way street.  when a certain coding pattern is clearly cursed and not supportable, I dont think it is reasonable for programmers to refuse to move by even an inch and expect the compiler to do all the heavy lifting.</p>",
        "id": 277349714,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766582
    },
    {
        "content": "<p>And yes, I know that has its own problems.</p>",
        "id": 277349747,
        "sender_full_name": "comex",
        "timestamp": 1648766606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349714\">said</a>:</p>\n<blockquote>\n<p>yeah totally. but I think this kind of working with each other to move the langue towards a better understanding of UB has to be a two-way street.  when a certain coding pattern is clearly cursed and not supportable, I dont think it is reasonable for programmers to refuse to move bt even an inch and expect the compiler to do all the heavy lifting.</p>\n</blockquote>\n<p>Yeah. To be clear: my position isn't \"if there's a single line of code internally that breaks I'll stand in the way\". It's \"we have too much code to feasibly make <em>large</em> breaking changes\".</p>",
        "id": 277349766,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766625
    },
    {
        "content": "<p>like, I dont have synmpathy for compiler and lang devs that ignore programmer concerns and just say \"the law says its UB so not-a-bug\".<br>\nI also dont have sympathy for developers that ignore compiler and language devs and just say \"but this happened to work in the past and I insist it keeps working no matter what\".</p>",
        "id": 277349842,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766654
    },
    {
        "content": "<p>We have and consistently do work to remove UB from our code.</p>",
        "id": 277349851,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766662
    },
    {
        "content": "<p>I just think there has to be a limit.</p>",
        "id": 277349872,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766678
    },
    {
        "content": "<p>I agree with what Ralf said.</p>",
        "id": 277349876,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766681
    },
    {
        "content": "<p>FWIW, I know for a fact that people also transmute (directly and via pointer cast) byte arrays to structs-with-pointers-in-them</p>",
        "id": 277349893,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766691
    },
    {
        "content": "<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>",
        "id": 277349924,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766705
    },
    {
        "content": "<p>I can't imagine that ptr int transmutes are more common than that...</p>",
        "id": 277349939,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766715
    },
    {
        "content": "<p>which is why the solution to special case only the trivial ptr/int transmutes feels off to me</p>",
        "id": 277349959,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648766727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349924\">said</a>:</p>\n<blockquote>\n<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>\n</blockquote>\n<p>Do you have a link to more details here? I'd be very interested. Sounds like an important data point.</p>",
        "id": 277349973,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766745
    },
    {
        "content": "<p>What does miri currently do with ptr-to-int transmute?</p>",
        "id": 277349988,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648766757
    },
    {
        "content": "<p>The reason in particular I think people may <code>mem::transmute</code> pointer to int is that it lets you avoid double-<code>as</code> in some cases.</p>",
        "id": 277350064,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349973\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349924\">said</a>:</p>\n<blockquote>\n<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>\n</blockquote>\n<p>Do you have a link to more details here? I'd be very interested. Sounds like an important data point.</p>\n</blockquote>\n<p>this was years ago...<br>\n<a href=\"https://github.com/rust-lang/rust/issues/66151\">https://github.com/rust-lang/rust/issues/66151</a><br>\n<a href=\"https://gankra.github.io/blah/initialize-me-maybe/\">https://gankra.github.io/blah/initialize-me-maybe/</a></p>",
        "id": 277350068,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349988\">said</a>:</p>\n<blockquote>\n<p>What does miri currently do with ptr-to-int transmute?</p>\n</blockquote>\n<p>by default, it creates an integer with provenance.<br>\nwith <code>-Zmiri-check-number-validity</code>, it says this is UB.</p>",
        "id": 277350088,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350064\">said</a>:</p>\n<blockquote>\n<p>The reason in particular I think people may <code>mem::transmute</code> pointer to int is that it lets you avoid double-<code>as</code> in some cases.</p>\n</blockquote>\n<p>that sounds like a really bad reason to use the bazooka that is <code>transmute</code> :(</p>",
        "id": 277350111,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766835
    },
    {
        "content": "<p>From my perspective, the goal should be essentially to make the changes necessary to establish a model that we can establish, yes, as formally as possible, is not something LLVM should ever break, and then demand they support us. They seem inclined to wave off anything less, and they do wibble a lot on what is sound and unsound. I want us to be able to preempt LLVM's attempts to figure out their own stuff and \"outbid\" them: to present so compelling an argument that it should always win.</p>",
        "id": 277350119,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350068\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349973\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349924\">said</a>:</p>\n<blockquote>\n<p>we basically broke <code>mem::uninitialized</code> and (to my great surprise) got away with that</p>\n</blockquote>\n<p>Do you have a link to more details here? I'd be very interested. Sounds like an important data point.</p>\n</blockquote>\n<p>this was years ago...<br>\n<a href=\"https://github.com/rust-lang/rust/issues/66151\">https://github.com/rust-lang/rust/issues/66151</a><br>\n<a href=\"https://gankra.github.io/blah/initialize-me-maybe/\">https://gankra.github.io/blah/initialize-me-maybe/</a></p>\n</blockquote>\n<p>Ah yes. As I recall this required a not insignificant amount of work from our side.</p>",
        "id": 277350142,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766863
    },
    {
        "content": "<p>Right up to the limit of what was feasible.</p>",
        "id": 277350168,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766879
    },
    {
        "content": "<p>it required a lot of work from many people. <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> for being part of the effort. :)</p>",
        "id": 277350236,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350111\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350064\">said</a>:</p>\n<blockquote>\n<p>The reason in particular I think people may <code>mem::transmute</code> pointer to int is that it lets you avoid double-<code>as</code> in some cases.</p>\n</blockquote>\n<p>that sounds like a really bad reason to use the bazooka that is <code>transmute</code> :(</p>\n</blockquote>\n<p>Good or bad, it's what people do. I know I've done it.</p>",
        "id": 277350241,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766908
    },
    {
        "content": "<p>After all, we haven't told people <em>not</em> to.</p>",
        "id": 277350256,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766921
    },
    {
        "content": "<p>yeah</p>",
        "id": 277350272,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349711\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Your new example makes me more convinced that what we actually need is PVI :)</p>\n</blockquote>\n<p>lol I thought we were over that ;)</p>",
        "id": 277350289,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766945
    },
    {
        "content": "<p>And we've given people syntactic salt with double-<code>as</code>, so people will pick the sugary thing. Which is <code>mem::transmute</code> in this case.</p>",
        "id": 277350291,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648766945
    },
    {
        "content": "<p>double-<code>as</code> is safe though</p>",
        "id": 277350311,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766961
    },
    {
        "content": "<p>so I am surprised people would reach for the unsafe thing</p>",
        "id": 277350324,
        "sender_full_name": "RalfJ",
        "timestamp": 1648766971
    },
    {
        "content": "<p>And also, I believe that relying on Vibes does incredible damage to learnability, to a point that people really, really underestimate.</p>",
        "id": 277350329,
        "sender_full_name": "Jubilee",
        "timestamp": 1648766973
    },
    {
        "content": "<p>but yeah I mean I cant argue with the reality of people doing it, I can just say it's a bad surprise to me</p>",
        "id": 277350406,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767007
    },
    {
        "content": "<p>we could have lints to start moving people away from that, the cases where it's literally usize ‚Üí ptr or vice versa should be easy to detect</p>",
        "id": 277350427,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350119\">said</a>:</p>\n<blockquote>\n<p>From my perspective, the goal should be essentially to make the changes necessary to establish a model that we can establish, yes, as formally as possible, is not something LLVM should ever break, and then demand they support us. They seem inclined to wave off anything less, and they do wibble a lot on what is sound and unsound. I want us to be able to preempt LLVM's attempts to figure out their own stuff and \"outbid\" them: to present so compelling an argument that it should always win.</p>\n</blockquote>\n<p>Sounds good to me.  But if establishing a subset is <em>all</em> we're doing ‚Äì that is, we're not actively changing anything (e.g. adding MIR optimizations) in a way that breaks code that currently works outside of the model, it's just that <em>LLVM</em> might break it ‚Äì then we should make that clear.  Because there is a big difference between 'what LLVM might do' and 'what LLVM is likely to do', especially when it comes to potentially breaking legacy code.</p>",
        "id": 277350451,
        "sender_full_name": "comex",
        "timestamp": 1648767035
    },
    {
        "content": "<p>clippy might already do that...</p>",
        "id": 277350454,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767039
    },
    {
        "content": "<p>true, but from my experience people start out with a very naive mental model</p>",
        "id": 277350464,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648767045
    },
    {
        "content": "<p>like, I have trouble teaching people that unaligned references are UB</p>",
        "id": 277350493,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648767073
    },
    {
        "content": "<p>I just want to avoid ending up in a Python 3 situation, where Python 3 was simpler in all aspects but there was too much code in Python 2 that it ended up making things worse in practice for a very long time.</p>",
        "id": 277350509,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648767083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span>  Just out of curiosity, what if it turns out there needs to be a performance regression in order to make \"stuff we think is UB but is too commonly used to break\" continue to work in all cases? At what point is the performance regression itself a breaking change?</p>",
        "id": 277350515,
        "sender_full_name": "Diggsey",
        "timestamp": 1648767087
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> well I'd really love to at least have an idea for a model that also accounts for the remaining language outside the 'strict' subset. something that gives a chance of evaluating whether an optimization is correct, even if the details are somewhat fuzzy and LLVM won't tell us enough to be sure we use their IR correctly.</p>",
        "id": 277350524,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> But code that uses raw pointers is likely to already have unsafe blocks in it, and newbies may not be aware that the double cast is even possible.  (As in, they try to do a single cast, see the compiler error, and fall back to transmute.)</p>",
        "id": 277350532,
        "sender_full_name": "comex",
        "timestamp": 1648767109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350464\">said</a>:</p>\n<blockquote>\n<p>true, but from my experience people start out with a very naive mental model</p>\n</blockquote>\n<p>true dat</p>",
        "id": 277350534,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767112
    },
    {
        "content": "<p>So if at all possible, I would love something that not only breaks little existing code, but doesn't break the naive mental model <em>too much</em> (yes, that is a very big ask I realize)</p>",
        "id": 277350654,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648767175
    },
    {
        "content": "<p>but with <code>transmute</code> that's... very tricky to say the last? if we ignore LLVM I guess we can go wild and just say \"okay all provenancnes in the transmuted data are exposed\". but then no MIR opt may remove a <code>transmute</code> whose result is unused...</p>",
        "id": 277350676,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350451\">said</a>:</p>\n<blockquote>\n<p>Sounds good to me.  But if establishing a subset is <em>all</em> we're doing ‚Äì that is, we're not actively changing anything (e.g. adding MIR optimizations) in a way that breaks code that currently works outside of the model, it's just that <em>LLVM</em> might break it ‚Äì then we should make that clear.  Because there is a big difference between 'what LLVM might do' and 'what LLVM is likely to do', especially when it comes to potentially breaking legacy code.</p>\n</blockquote>\n<p>I suppose. I am fine with admitting I basically have what other people might consider an unrealistically cynical position on LLVM in many cases.</p>",
        "id": 277350706,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350515\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span>  Just out of curiosity, what if it turns out there needs to be a performance regression in order to make \"stuff we think is UB but is too commonly used to break\" continue to work in all cases? At what point is the performance regression itself a breaking change?</p>\n</blockquote>\n<p>There are no hard and fast rules here. In practice it's \"if it's big and important enough of a regression, LLVM reverts it\".</p>",
        "id": 277350737,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648767230
    },
    {
        "content": "<p>also what about pinter-based or union-based type punning? should that be legal too? (I can easily replace the example to use that instead of <code>transmute</code>)</p>",
        "id": 277350744,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767237
    },
    {
        "content": "<p>But again, I speak from the PoV of someone who sees LLVM devs tending to fight rather than accept requests from the Rust project.</p>",
        "id": 277350804,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350676\">said</a>:</p>\n<blockquote>\n<p>but with <code>transmute</code> that's... very tricky to say the last? if we ignore LLVM I guess we can go wild and just say \"okay all provenancnes in the transmuted data are exposed\". but then no MIR opt may remove a <code>transmute</code> whose result is unused...</p>\n</blockquote>\n<p>Well, not just a transmute, but /any/ read at integer type of some memory that might possibly have pointers in it.  But I'm definitely not objecting to being able to remove those‚Ä¶</p>",
        "id": 277350817,
        "sender_full_name": "comex",
        "timestamp": 1648767266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> well, if the source type has no pointers, you can still optimize out the unused transmute, no?</p>",
        "id": 277350841,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648767276
    },
    {
        "content": "<p>well, no MIR opt may remove an unused <code>transmute</code> <em>when it is pointer vs integer</em></p>",
        "id": 277350847,
        "sender_full_name": "Talchas",
        "timestamp": 1648767285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350841\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> well, if the source type has no pointers, you can still optimize out the unused transmute, no?</p>\n</blockquote>\n<p>only if you know that the source <em>value</em> will also indeed have no provenance</p>",
        "id": 277350855,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767294
    },
    {
        "content": "<p>you can't <code>mem::transmute</code> T and U generically</p>",
        "id": 277350860,
        "sender_full_name": "Talchas",
        "timestamp": 1648767298
    },
    {
        "content": "<p>which under these fast-and-loose rules I dont think you can conclude from the type</p>",
        "id": 277350871,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767304
    },
    {
        "content": "<p>welll</p>",
        "id": 277350874,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767305
    },
    {
        "content": "<p><code>mem::transmute::&lt;T, U&gt;</code> kinda... does... work?</p>",
        "id": 277350895,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767323
    },
    {
        "content": "<p>like IIRC that's literally how the function is defined?</p>",
        "id": 277350914,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767344
    },
    {
        "content": "<p>I may be missing something here.</p>",
        "id": 277350925,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767353
    },
    {
        "content": "<p>no, it gives you an error saying \"T and U aren't known to be the same size\"</p>",
        "id": 277350930,
        "sender_full_name": "Talchas",
        "timestamp": 1648767356
    },
    {
        "content": "<p>under PNVI-ae-alikes, isn't it exactly pointer types who can have provenance?</p>",
        "id": 277350935,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648767359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350847\">said</a>:</p>\n<blockquote>\n<p>well, no MIR opt may remove an unused <code>transmute</code> <em>when it is pointer vs integer</em></p>\n</blockquote>\n<p>it's super hard to say what could still be allowed because there is no precise model. that's the entire point though.^^</p>",
        "id": 277350936,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767361
    },
    {
        "content": "<p>Ahhh.</p>",
        "id": 277350938,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767361
    },
    {
        "content": "<p>all of this applies for transmute_copy/literal memcpy/pointer pun/union pun</p>",
        "id": 277350987,
        "sender_full_name": "Talchas",
        "timestamp": 1648767374
    },
    {
        "content": "<p>it does not apply for literally just <code>mem::transmute</code></p>",
        "id": 277350998,
        "sender_full_name": "Talchas",
        "timestamp": 1648767387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350987\">said</a>:</p>\n<blockquote>\n<p>all of this applies for transmute_copy/literal memcpy/pointer pun/union pun</p>\n</blockquote>\n<p>or maybe <code>mem::transmute</code> is special to support legacy code</p>",
        "id": 277351003,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767389
    },
    {
        "content": "<p>so you're saying the implicit <code>where</code></p>",
        "id": 277351006,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767392
    },
    {
        "content": "<p>At least, as long as LLVM keeps removing those.  I think there may be a possible future where LLVM implements PNVI by removing unused loads/stores but keeping around some kind of marker, and in that case perhaps Rust should follow its lead and use the same aprpoach in MIR optimizations, but that's far off.</p>",
        "id": 277351008,
        "sender_full_name": "comex",
        "timestamp": 1648767397
    },
    {
        "content": "<p>(at least until/unless we get <code>where size_of::&lt;T&gt;() == size_of::&lt;U&gt;()</code> permitting transmute!)</p>",
        "id": 277351027,
        "sender_full_name": "Talchas",
        "timestamp": 1648767417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277350935\">said</a>:</p>\n<blockquote>\n<p>under PNVI-ae-alikes, isn't it exactly pointer types who can have provenance?</p>\n</blockquote>\n<p>we're talking about code that does not follow any precise rules we know, so... not sure?</p>",
        "id": 277351045,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767429
    },
    {
        "content": "<p>C has strict aliasing so we can't apply its rules either</p>",
        "id": 277351054,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767438
    },
    {
        "content": "<p>Right, half of our trouble is Rust is <code>-fno-strict-aliasing</code></p>",
        "id": 277351139,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767488
    },
    {
        "content": "<p>I mean C does have the strict aliasing exception for bytes anyway, which still has to work somehow...</p>",
        "id": 277351169,
        "sender_full_name": "Diggsey",
        "timestamp": 1648767524
    },
    {
        "content": "<p>I don't want to overfocus on <code>mem::transmute</code> in particular ‚Äî I mostly used special-casing it as an example of where some targeted inelegant/messy things we could do might go a long way toward bringing us to a better model while avoiding breaking most code.</p>",
        "id": 277351175,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648767532
    },
    {
        "content": "<p>the current proposal's section for bytes is \"handwave\"</p>",
        "id": 277351184,
        "sender_full_name": "Talchas",
        "timestamp": 1648767540
    },
    {
        "content": "<p>like, if you let it be an expose it's trivial as far as a model goes</p>",
        "id": 277351209,
        "sender_full_name": "Talchas",
        "timestamp": 1648767565
    },
    {
        "content": "<p>I actually love that rust has no TBAA, C's rules are quite weird</p>",
        "id": 277351220,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648767573
    },
    {
        "content": "<p>but they very much want memcpy(pointer, pointer) to not be an expose</p>",
        "id": 277351230,
        "sender_full_name": "Talchas",
        "timestamp": 1648767583
    },
    {
        "content": "<p>and also would like some way to implement memcpy in C</p>",
        "id": 277351240,
        "sender_full_name": "Talchas",
        "timestamp": 1648767592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351220\">said</a>:</p>\n<blockquote>\n<p>I actually love that rust has no TBAA, C's rules are quite weird</p>\n</blockquote>\n<p>to be fair we do have TBAA it's just not on that kind.</p>",
        "id": 277351325,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767619
    },
    {
        "content": "<p>(JavaScript for example managed to get true lexical scoping by special-casing the identifier <code>eval</code>, which is hilariously ugly, but the only alternative would be no lexical scoping, as Web browsers wouldn't ship anything that broke Web pages, so it ended up being a great solution all around.)</p>",
        "id": 277351370,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648767635
    },
    {
        "content": "<p>and doing that without a magic flag on memcpy, or provenance in integers, or provenance in this integer type in particular, is ???</p>",
        "id": 277351378,
        "sender_full_name": "Talchas",
        "timestamp": 1648767649
    },
    {
        "content": "<p>(Similar story with C <code>strict-aliasing</code> and the <code>char</code> special case.)</p>",
        "id": 277351382,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648767656
    },
    {
        "content": "<p>it turns out every other kind of TBAA is easier to understand. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277351388,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349872\">said</a>:</p>\n<blockquote>\n<p>I just think there has to be a limit.</p>\n</blockquote>\n<p>In case you haven't seen it, there's a t-lang topic discussing stability gurantees of unsafe code <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code</a></p>",
        "id": 277351441,
        "sender_full_name": "Nick12",
        "timestamp": 1648767689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351382\">said</a>:</p>\n<blockquote>\n<p>(Similar story with C <code>strict-aliasing</code> and the <code>char</code> special case.)</p>\n</blockquote>\n<p>well, I'd say strict aliasing is actually breaking tons of previously working code. just nobody noticed yet as optimizers didnt get there yet.</p>",
        "id": 277351644,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767865
    },
    {
        "content": "<p>if there was Miri for strict aliasing it'd be red all over the place</p>",
        "id": 277351672,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767904
    },
    {
        "content": "<p>the <code>char</code> special case was meant to fix this but didnt</p>",
        "id": 277351678,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767910
    },
    {
        "content": "<p>there's a reason many big projects just <code>-fno-strict-aliasing</code></p>",
        "id": 277351689,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767926
    },
    {
        "content": "<p>so I wouldnt use strict aliasing as a successful example ;)</p>",
        "id": 277351699,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767934
    },
    {
        "content": "<p>So, scapegoat idea: <code>rustc -fno-strict-provenance</code></p>",
        "id": 277351850,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768048
    },
    {
        "content": "<p>Probably very gnarly to tease out which LLVM opts exactly to disable then</p>",
        "id": 277351939,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768089
    },
    {
        "content": "<p>That would be as underspecified as <code>-fno-strict-aliasing</code> right? Just a best-effort extension</p>",
        "id": 277352007,
        "sender_full_name": "Nick12",
        "timestamp": 1648768163
    },
    {
        "content": "<p>Yes</p>",
        "id": 277352019,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768175
    },
    {
        "content": "<p>But with miri and such you actually have a fighting chance to figure out when exactly you're compliant with the strict model and get to ditch that flag</p>",
        "id": 277352122,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768237
    },
    {
        "content": "<p>with strict aliasing, nobody would dare suggesting turning that loose on e.g. Linux. who knows what would happen</p>",
        "id": 277352274,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768338
    },
    {
        "content": "<p>If you're going to have that flag, why make the user guess whether to pass it - why not track which crates actually require it to ensure it can't be accidentally missed. In which case we're back to my original proposal which started this whole discussion :P</p>",
        "id": 277352295,
        "sender_full_name": "Diggsey",
        "timestamp": 1648768365
    },
    {
        "content": "<p>also we dont want to have flags that split the language</p>",
        "id": 277352325,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768392
    },
    {
        "content": "<p>Nobody wants that, but also nobody wants UB nor perf regresions. To me it is a question of the lesser evil</p>",
        "id": 277352477,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768513
    },
    {
        "content": "<p>(to which I have no answer)</p>",
        "id": 277352524,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768560
    },
    {
        "content": "<p>We have editions that already kind of split the language, so it's not like it's a complete non-starter</p>",
        "id": 277352625,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768666
    },
    {
        "content": "<p>yeah, I think splitting is... acceptable as long as there is a strict subset/superset relationship</p>",
        "id": 277352686,
        "sender_full_name": "Diggsey",
        "timestamp": 1648768701
    },
    {
        "content": "<p>You can't always get what you want<br>\n<a href=\"https://www.youtube.com/watch?v=Ef9QnZVpVd8\">https://www.youtube.com/watch?v=Ef9QnZVpVd8</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Ef9QnZVpVd8\" href=\"https://www.youtube.com/watch?v=Ef9QnZVpVd8\"><img src=\"https://uploads.zulipusercontent.net/8acfd845a89c1819414ed41aef86a46afdc77a19/68747470733a2f2f692e7974696d672e636f6d2f76692f456639516e5a56705664382f64656661756c742e6a7067\"></a></div>",
        "id": 277352706,
        "sender_full_name": "Jubilee",
        "timestamp": 1648768722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352686\">said</a>:</p>\n<blockquote>\n<p>yeah, I think splitting is... acceptable as long as there is a strict subset/superset relationship</p>\n</blockquote>\n<p>I fairly strongly disagree, because then we will end up in the world where there are libraries that document \"requires <code>-fno-strict-provenance</code>\"</p>",
        "id": 277352726,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768754
    },
    {
        "content": "<p>we already have that in effect though</p>",
        "id": 277352749,
        "sender_full_name": "Diggsey",
        "timestamp": 1648768780
    },
    {
        "content": "<p>as in, there's already code that requires this that we don't want to break</p>",
        "id": 277352763,
        "sender_full_name": "Diggsey",
        "timestamp": 1648768801
    },
    {
        "content": "<p>it could be an actual crate option rather than just docs</p>",
        "id": 277352814,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768814
    },
    {
        "content": "<p>Yes, but that's not the same thing</p>",
        "id": 277352815,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352814\">said</a>:</p>\n<blockquote>\n<p>it could be an actual crate option rather than just docs</p>\n</blockquote>\n<p>That's worse imo, not better</p>",
        "id": 277352823,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768826
    },
    {
        "content": "<p>well, it would fit in with editions</p>",
        "id": 277352839,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768847
    },
    {
        "content": "<p>Like \"let's keep this already written code from miscompiling as long as it's not too crazy\" is a far ways off from actually trying to <em>support</em> the broken thing</p>",
        "id": 277352850,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768860
    },
    {
        "content": "<p>and you could write a tool that crawls your dependency graph to show you who's naughty so you can haunt their issue trackers</p>",
        "id": 277352865,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768878
    },
    {
        "content": "<p>what is the difference? If someone says it broke a load of their code, and we don't want to do that, then we are supporting it</p>",
        "id": 277352882,
        "sender_full_name": "Diggsey",
        "timestamp": 1648768918
    },
    {
        "content": "<p>No one should ever be putting <code>no-strict-provenance</code> into their cargo.toml - if they are doing maintenance on their repo, they should fix the code, not mark it permanently broken</p>",
        "id": 277352926,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768930
    },
    {
        "content": "<p>yes, these kinds of things must always work the other way around, the default is the broken thing</p>",
        "id": 277352946,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648768961
    },
    {
        "content": "<p>Well to refer to my original proposal, we'd have the older edition be the opt-in for effectively <code>no-strict-provenance</code></p>",
        "id": 277352968,
        "sender_full_name": "Diggsey",
        "timestamp": 1648768994
    },
    {
        "content": "<p>in the extreme, you end up like Perl, where the base language is throughly broken but after 20 or so lines of boilerplate you can get sane semantics</p>",
        "id": 277352972,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351850\">said</a>:</p>\n<blockquote>\n<p>So, scapegoat idea: <code>rustc -fno-strict-provenance</code></p>\n</blockquote>\n<p>Consensus seems to be that we can just introduce <code>ptr.addr_strict()</code> ‚Äî you can't use the result to convert back into a pointer. And then there's no reason to add a compiler flag. Much simpler.</p>",
        "id": 277352976,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"295632\">@Diggsey</span> right, piggybacking on the edition mechanism doesn't seem so bad at face value</p>",
        "id": 277353032,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769053
    },
    {
        "content": "<p>Perhaps this doesn't address every use case but then let's talk about it. Let's only propose a compiler flag please if it fixes something that <code>.addr_strict()</code> doesn't fix</p>",
        "id": 277353058,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769087
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> That's not consensus, I think it satisfies neither the desire to avoid breaking existing code, nor does it actually allow us to do anything with strict provenance</p>",
        "id": 277353072,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769098
    },
    {
        "content": "<p>It's not about defaults, it's about having the option at all. People may need to be able to \"opt in\" to the broken thing, but the procedure for this should be <em>precisely nothing</em>. Having old unsafe code that does stuff like <code>as</code> casts gets you special treatment in the form of \"I'll do my best to not miscompile\"</p>",
        "id": 277353118,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648769106
    },
    {
        "content": "<p>also, telling people \"if your entire dep graph is on edition 2024+, you'll get crazy provenance opts\" is a nicer story to tell than \"we're breaking your stuff, fix it or suffer\"</p>",
        "id": 277353151,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769130
    },
    {
        "content": "<p>I'm proposing to keep <code>ptr as usize</code> and <code>usize as ptr</code> intact, so yes it doesn't break existing code</p>",
        "id": 277353168,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769145
    },
    {
        "content": "<p>To be clear, what I very much would like to avoid is to give people writing <em>new</em> code the impression that they have an option to go \"I'll just write against the old broken thing and flip the compiler flag\"</p>",
        "id": 277353232,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648769174
    },
    {
        "content": "<p>How is the old thing broken please?</p>",
        "id": 277353242,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769185
    },
    {
        "content": "<p>because we say so</p>",
        "id": 277353282,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769205
    },
    {
        "content": "<p>not helpful</p>",
        "id": 277353289,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769214
    },
    {
        "content": "<p>sorry that was a bit too laconic.</p>",
        "id": 277353330,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769247
    },
    {
        "content": "<p>We have no memory model against which to determine that something is sound, that is the definition of broken</p>",
        "id": 277353335,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648769251
    },
    {
        "content": "<p>It's okay</p>",
        "id": 277353338,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769253
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> yes, that's not license to introduce arbitrary amounts of UB into unsafe code</p>",
        "id": 277353401,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769287
    },
    {
        "content": "<p>I never suggested that</p>",
        "id": 277353417,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648769298
    },
    {
        "content": "<p>if being underspecified is enough to be broken, all unsafe code is broken</p>",
        "id": 277353447,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769328
    },
    {
        "content": "<p>there's more to it than that</p>",
        "id": 277353470,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769347
    },
    {
        "content": "<p>Above, I propose the thing that miri is doing with Stacked Borrows. This is more permissive than strict-provenance. But strict-provenance seems to fit in well w.r.t. compiler optimizations.</p>\n<p>In <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging\">#t-lang/wg-unsafe-code-guidelines &gt; SB Without Raw Pointer Tagging</a> , we've been talking about which specific variant of Stacked Borrows this should be.</p>",
        "id": 277353472,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353470\">said</a>:</p>\n<blockquote>\n<p>there's more to it than that</p>\n</blockquote>\n<p>I never claimed that there wasn't, but I do stand by the claim that the lack of a sound memory model is indeed fundamentally broken and needs to be fixed</p>",
        "id": 277353504,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648769378
    },
    {
        "content": "<p>As far as I understand, this has a good shot at formalizing how raw pointers work, in a way that fits into Rust (because pnvi-* doesn't fit)</p>",
        "id": 277353509,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769384
    },
    {
        "content": "<p>yes, it does</p>",
        "id": 277353517,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353401\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> yes, that's not license to introduce arbitrary amounts of UB into unsafe code</p>\n</blockquote>\n<p>The UB basically already exists, we're just stating it.</p>",
        "id": 277353518,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> SB already breaks plenty of existing code - don't get me wrong, it's amazing how much it does work on, but it's not a panacea</p>",
        "id": 277353527,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> what code exactly already has UB is exactly the point of discussion</p>",
        "id": 277353594,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353517\">said</a>:</p>\n<blockquote>\n<p>yes, it does</p>\n</blockquote>\n<p>It doesn't. PNVI-ae actually has problems in rust.</p>",
        "id": 277353646,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353646\">said</a>:</p>\n<blockquote>\n<p>It doesn't. PNVI-ae actually has problems in rust.</p>\n</blockquote>\n<p>We mean Stacked Borrows</p>",
        "id": 277353675,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769498
    },
    {
        "content": "<p>I would like this topic to be about how we integrate strict-provenance with non-strict-provenance Rust.</p>\n<p>If we want to discuss formal semantics of non-strict-provenance Rust, let's create a new topic for that.</p>",
        "id": 277353683,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769507
    },
    {
        "content": "<p>If we want to switch to something other than Stacked Borrows, I mean</p>",
        "id": 277353749,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648769536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353646\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353517\">said</a>:</p>\n<blockquote>\n<p>yes, it does</p>\n</blockquote>\n<p>It doesn't. PNVI-ae actually has problems in rust.</p>\n</blockquote>\n<p>sorry I'm bad at zulip, that was in response to \"the lack of a model needs to be fixed\"</p>",
        "id": 277353769,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769553
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353470\">said</a>:</p>\n<blockquote>\n<p>there's more to it than that</p>\n</blockquote>\n<p>Is \"No one knows a coherent model in which all the things some people want to be sound are actually sound that does not introduce regressions by making optimizations done today invalid\" an accurate description?</p>",
        "id": 277353776,
        "sender_full_name": "Nick12",
        "timestamp": 1648769574
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span>  To be clear: every known formal model short of \"no provenance\" breaks some amount of existing code, because existing code was written without a formal model. The only way to guarantee no breakage would be to basically freeze all current optimization passes as they are for eternity.</p>",
        "id": 277353786,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219940\">Nick12</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353776\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353470\">said</a>:</p>\n<blockquote>\n<p>there's more to it than that</p>\n</blockquote>\n<p>Is \"No one knows a coherent model in which the things some people want to be sound are actually sound that does not introduce regressions by making optimizations done today invalid\" an accurate description?</p>\n</blockquote>\n<p>yeah, but I'd add the additional concern that other people want to build tools that verify the rules dynamically and that also clashes with the others</p>",
        "id": 277353873,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353683\">said</a>:</p>\n<blockquote>\n<p>I would like this topic to be about how we integrate strict-provenance with non-strict-provenance Rust.</p>\n<p>If we want to discuss formal semantics of non-strict-provenance Rust, let's create a new topic for that.</p>\n</blockquote>\n<p>Integrating strict-provenance with non-strict-provenance is the same as not having strict-provenance.</p>",
        "id": 277353890,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769674
    },
    {
        "content": "<blockquote>\n<p>Integrating strict-provenance with non-strict-provenance is the same as not having strict-provenance.</p>\n</blockquote>\n<p>Within a compiled program yes you can only have one. You could in principle have both in the language.</p>",
        "id": 277353928,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769726
    },
    {
        "content": "<p>but you would have to choose when compiling</p>",
        "id": 277353943,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769742
    },
    {
        "content": "<p>And you could choose differently between crates.</p>",
        "id": 277354014,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769787
    },
    {
        "content": "<p>uh.. not so sure about that</p>",
        "id": 277354021,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769799
    },
    {
        "content": "<p>Which becomes a problem.</p>",
        "id": 277354024,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769803
    },
    {
        "content": "<p>You could forbid that</p>",
        "id": 277354026,
        "sender_full_name": "Nick12",
        "timestamp": 1648769804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277354021\">said</a>:</p>\n<blockquote>\n<p>uh.. not so sure about that</p>\n</blockquote>\n<p>Sure, just compile one crate with the flag off, and one crate with it on.</p>",
        "id": 277354035,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769820
    },
    {
        "content": "<p>sorry I thought you were saying it <em>could</em> be different between crates - as in that would be allowed, I'm agreeing that may not be possible</p>",
        "id": 277354054,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277353890\">said</a>:</p>\n<blockquote>\n<p>Integrating strict-provenance with non-strict-provenance is the same as not having strict-provenance.</p>\n</blockquote>\n<p>Then ~every actual non-CHERI compilation target does not have strict-provenance, because of FFI.</p>",
        "id": 277354059,
        "sender_full_name": "Talchas",
        "timestamp": 1648769853
    },
    {
        "content": "<p>you can already shoot your whole leg off in a myriad ways if you start messing with compiler flags for individual crates</p>",
        "id": 277354122,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769893
    },
    {
        "content": "<p>(if you then link them together that is)</p>",
        "id": 277354146,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648769920
    },
    {
        "content": "<blockquote>\n<p>Then ~every actual non-CHERI compilation target does not have strict-provenance, because of FFI.</p>\n</blockquote>\n<p>I don't think that follows. As long as the FFI <em>interface</em> is compatible with strict-provenance then it can work fine. Obviously if the FFI code materializes an address to your local variable, then it will be UB</p>",
        "id": 277354192,
        "sender_full_name": "Diggsey",
        "timestamp": 1648769972
    },
    {
        "content": "<p>FFI can do whatever it wanns.</p>",
        "id": 277354251,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770003
    },
    {
        "content": "<p>FFI interfaces with things outside the Abstract Machine, that says nothing about what happens inside the Abstract Machine</p>",
        "id": 277354261,
        "sender_full_name": "RalfJ",
        "timestamp": 1648770019
    },
    {
        "content": "<p>If it's doing stupid stuff, then I can observe that that stupid stuff isn't possible and ignore that case.</p>",
        "id": 277354275,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770042
    },
    {
        "content": "<p>The issue is that, functionally, it's impossible to treat code in a different rust crate that is linked as an rlib/dylib as being a total blackbox.</p>",
        "id": 277354303,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770081
    },
    {
        "content": "<p>provenance isn't the only \"weird stuff\" that the Abstract Machine has that the underlying hardware does not; uninit memory is another example. no problem with FFI there either.<br>\nsee <a href=\"https://www.ralfj.de/blog/2019/07/14/uninit.html\">https://www.ralfj.de/blog/2019/07/14/uninit.html</a> for details.</p>",
        "id": 277354305,
        "sender_full_name": "RalfJ",
        "timestamp": 1648770089
    },
    {
        "content": "<p>I mean, some hardware has uninit.</p>",
        "id": 277354317,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770110
    },
    {
        "content": "<p>you must place limits on what FFI can soundly do, otherwise there are no rules at all (every program does FFI)</p>",
        "id": 277354327,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770119
    },
    {
        "content": "<p>(For example, when you mode-switch upwards in x86, the high bits of each register are uninit in the same sense llvm uses)</p>",
        "id": 277354389,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770152
    },
    {
        "content": "<p>individual counterexamples dont affect my point at all, it remains true in general</p>",
        "id": 277354426,
        "sender_full_name": "RalfJ",
        "timestamp": 1648770197
    },
    {
        "content": "<p>so they dont really help the discussion :D</p>",
        "id": 277354432,
        "sender_full_name": "RalfJ",
        "timestamp": 1648770206
    },
    {
        "content": "<p>does passing memory to FFI \"freeze\" it? I'd think not.</p>",
        "id": 277354500,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770253
    },
    {
        "content": "<p>right, \"hardware UB\" or at least \"hardware poison\" and \"hardware undef\" are real.</p>",
        "id": 277354515,
        "sender_full_name": "Jubilee",
        "timestamp": 1648770285
    },
    {
        "content": "<p>Hardware UB is also real in some cases.</p>",
        "id": 277354541,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770319
    },
    {
        "content": "<p>I'm happy with saying \"this happens outside of the AM so we don't care\" w.r.t. FFI but you still need to decide where that actually starts</p>",
        "id": 277354562,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770348
    },
    {
        "content": "<p>I think that the idea of an FFI call has been discussed before, but I would just call it an unspecified operation on the abstract machine, or the behaviour is undefined.</p>",
        "id": 277354639,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770409
    },
    {
        "content": "<p>If the behavior is undefined, there exists almost no rust program with defined behavior</p>",
        "id": 277354668,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277354668\">said</a>:</p>\n<blockquote>\n<p>If the behavior is undefined, there exists almost no rust program with defined behavior</p>\n</blockquote>\n<p>I can LD_PRELOAD a library that replaces every libc function with <code>_Noreturn void foo(void){}</code></p>",
        "id": 277354761,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770531
    },
    {
        "content": "<p>and all the handwaving doesn't help you if you start miscompiling code that passes pointers into and out of FFI</p>",
        "id": 277354772,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770543
    },
    {
        "content": "<p>My headcanon is that an FFI call <em>synchronizes</em>, to a certain extent, the abstract machine with the concrete machine.</p>",
        "id": 277354787,
        "sender_full_name": "comex",
        "timestamp": 1648770564
    },
    {
        "content": "<p>Well, as concrete as a process's state is.  Somewhat concrete.</p>",
        "id": 277354800,
        "sender_full_name": "comex",
        "timestamp": 1648770585
    },
    {
        "content": "<p>Define \"synchronizes\"?</p>",
        "id": 277354881,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770642
    },
    {
        "content": "<p>That sounds like a gigantic optimization barrier</p>",
        "id": 277354884,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770649
    },
    {
        "content": "<p>Well, that's the hard part. ;)</p>",
        "id": 277354889,
        "sender_full_name": "comex",
        "timestamp": 1648770654
    },
    {
        "content": "<p>And yeah.</p>",
        "id": 277354891,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770658
    },
    {
        "content": "<p>It basically says \"LTO doesn't exist\".</p>",
        "id": 277354897,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770666
    },
    {
        "content": "<p>Well, I would say LTO is an exception.</p>",
        "id": 277354906,
        "sender_full_name": "comex",
        "timestamp": 1648770676
    },
    {
        "content": "<p>Which is, uh, definately not true.</p>",
        "id": 277354919,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770687
    },
    {
        "content": "<p>And I hope it <em>remains</em> not true, because all of lccc's runtime libraries will be compiled with mixed LTO.</p>",
        "id": 277354933,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770713
    },
    {
        "content": "<p>But, for example, if you write a value to some address in the abstract machine, that address may not correspond to any actual concrete-machine address, or it may correspond to multiple different concrete-machine addresses, etc.</p>",
        "id": 277354940,
        "sender_full_name": "comex",
        "timestamp": 1648770722
    },
    {
        "content": "<p>Cross-lang LTO can happen if a language exists that rationalizes the interactions.</p>",
        "id": 277354990,
        "sender_full_name": "Jubilee",
        "timestamp": 1648770749
    },
    {
        "content": "<p>In effect, this is what LLVM, GIMPLE, etc. <strong>are</strong></p>",
        "id": 277355002,
        "sender_full_name": "Jubilee",
        "timestamp": 1648770777
    },
    {
        "content": "<p>However, once you enter an FFI call ‚Äì I'm excluding LTO in this ‚Äì you have to have a concrete address and concrete bytes written there.</p>",
        "id": 277355013,
        "sender_full_name": "comex",
        "timestamp": 1648770789
    },
    {
        "content": "<p>Indeed, same with XIR.</p>",
        "id": 277355019,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355013\">said</a>:</p>\n<blockquote>\n<p>However, once you enter an FFI call ‚Äì I'm excluding LTO in this ‚Äì you have to have a concrete address and concrete bytes written there.</p>\n</blockquote>\n<p>That still seems like a a huge optimization barrier.</p>",
        "id": 277355042,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770834
    },
    {
        "content": "<p>LTO is functionality of the backend, ie. LLVM - AIUI you can't do LTO between two things that use a different compiler backend. Therefore the only difference from non-LTO FFI is that you are synchronizing the Rust abstract machine to the LLVM abstract machine, instead of to the concrete machine</p>",
        "id": 277355046,
        "sender_full_name": "Diggsey",
        "timestamp": 1648770840
    },
    {
        "content": "<p>The job of Rust should be to \"get our own house in order\" as much as possible such that cross-lang LTO has an easy time of rationalizing the interactions and that it is not order-dependent.</p>",
        "id": 277355087,
        "sender_full_name": "Jubilee",
        "timestamp": 1648770850
    },
    {
        "content": "<p>BTW, this is much more obviously true in weird implementations like concolic execution</p>",
        "id": 277355092,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770858
    },
    {
        "content": "<p>I mean, this is rather my point - C is pretty much absolutely definitely not going to be using strict provenance</p>",
        "id": 277355103,
        "sender_full_name": "Talchas",
        "timestamp": 1648770873
    },
    {
        "content": "<p>You really need to physically cough up actual bytes before each FFI call</p>",
        "id": 277355121,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648770892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Sorry, I should also say - it only needs to be in concrete memory to the extent it's been exposed to the FFI call, directly or indirectly.  This is, of course, what compilers already do.</p>",
        "id": 277355133,
        "sender_full_name": "comex",
        "timestamp": 1648770906
    },
    {
        "content": "<p>so if you can FFI call to C which does things like <code>uintptr_t ptr2int(void *x) { return (uintptr_t)x; }</code> you could interface two different rust crates with different rules in the same way</p>",
        "id": 277355150,
        "sender_full_name": "Talchas",
        "timestamp": 1648770927
    },
    {
        "content": "<p>whatever that actually looks like in the backend</p>",
        "id": 277355165,
        "sender_full_name": "Talchas",
        "timestamp": 1648770942
    },
    {
        "content": "<p>(which yes, means no LTO between those crate sets unless you have a cross-lang LTO that can handle that somehow)</p>",
        "id": 277355216,
        "sender_full_name": "Talchas",
        "timestamp": 1648770965
    },
    {
        "content": "<p>Having \"synchronized only if exposed\" as a normative rule, as opposed to the normal case where the notion of escaping is purely a compiler concept and has no place to the spec, may sound unmotivated.</p>",
        "id": 277355263,
        "sender_full_name": "comex",
        "timestamp": 1648771023
    },
    {
        "content": "<p>the C FFI is much simpler than the interface a Rust crate can expose, and compiler backends generally have knowledge of the C interface, whereas they wouldn't have particular knowledge about all the things you can do in Rust</p>",
        "id": 277355273,
        "sender_full_name": "Diggsey",
        "timestamp": 1648771039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355133\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> Sorry, I should also say - it only needs to be in concrete memory to the extent it's been exposed to the FFI call, directly or indirectly.  This is, of course, what compilers already do.</p>\n</blockquote>\n<p>Yes, and to do this, they need rules about what exactly a foreign function could possibly see/touch</p>",
        "id": 277355279,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648771044
    },
    {
        "content": "<p>so you can still have both <code>strict-provenance=yes</code> and <code>no</code> crates in the same executable to the exact same extent you could have <code>strict-provenance=yes</code> and C in the same executable</p>",
        "id": 277355284,
        "sender_full_name": "Talchas",
        "timestamp": 1648771050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355284\">said</a>:</p>\n<blockquote>\n<p>so you can still have both <code>strict-provenance=yes</code> and <code>no</code> crates in the same executable to the exact same extent you could have <code>strict-provenance=yes</code> and C in the same executable</p>\n</blockquote>\n<p>The issue is what happens if you inline strict-provenance=no into strict-provenacne=yes.</p>",
        "id": 277355299,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648771074
    },
    {
        "content": "<p>yes, that is what you cannot do without cross-lang LTO equivalents</p>",
        "id": 277355356,
        "sender_full_name": "Talchas",
        "timestamp": 1648771094
    },
    {
        "content": "<p>Ok, so you can't instantiate any generics either.</p>",
        "id": 277355367,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648771109
    },
    {
        "content": "<p>you can compile them with separate settings</p>",
        "id": 277355376,
        "sender_full_name": "Talchas",
        "timestamp": 1648771122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355299\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355284\">said</a>:</p>\n<blockquote>\n<p>so you can still have both <code>strict-provenance=yes</code> and <code>no</code> crates in the same executable to the exact same extent you could have <code>strict-provenance=yes</code> and C in the same executable</p>\n</blockquote>\n<p>The issue is what happens if you inline strict-provenance=no into strict-provenacne=yes.</p>\n</blockquote>\n<p>Doesn't it suffice to pass pointers between the two?</p>",
        "id": 277355380,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648771124
    },
    {
        "content": "<p>Or call an <code>#[inline]</code> function.</p>",
        "id": 277355381,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648771125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> that definitely seems possible if the two crates only communicate via C API, but I feel like native Rust interop makes that more complicated</p>",
        "id": 277355396,
        "sender_full_name": "Diggsey",
        "timestamp": 1648771146
    },
    {
        "content": "<p>Also, compiling them separately has <em>fun</em> times.</p>",
        "id": 277355405,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648771157
    },
    {
        "content": "<p>right.</p>",
        "id": 277355406,
        "sender_full_name": "Jubilee",
        "timestamp": 1648771157
    },
    {
        "content": "<p>...But I think it's important to allow FFI to perform the full range of operations that people expect it to support.  For example, the FFI call might actually pause the process, at which point you might, say, inspect values in a debugger (this should be guaranteed to work for stuff that has been exposed to FFI), or send it to another machine with checkpoint-restore, etc‚Ä¶</p>",
        "id": 277355407,
        "sender_full_name": "comex",
        "timestamp": 1648771158
    },
    {
        "content": "<p>I think that Connor has the right of things, \"that's actually way more \"\"\"fun\"\"\" than you imagine.\"</p>",
        "id": 277355433,
        "sender_full_name": "Jubilee",
        "timestamp": 1648771191
    },
    {
        "content": "<p>The alternative is to either not model FFI at all (unsatisfying), or model FFI by trying to translate the FFI code itself into the abstract machine, which causes a lot of problems.</p>",
        "id": 277355439,
        "sender_full_name": "comex",
        "timestamp": 1648771196
    },
    {
        "content": "<p>like, you need to be able to somehow compile separate functions with separate optimization settings, which is maybe a little bit of effort to do /fast/, but is not any real effort to do in general</p>",
        "id": 277355443,
        "sender_full_name": "Talchas",
        "timestamp": 1648771201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> but unless you have <em>some</em> model of what forein code can do to memory (e.g. it can't guess your locals' addresses), you lose all your fancy provenance optimizations</p>",
        "id": 277355624,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648771285
    },
    {
        "content": "<p>inline(always) already does not actually mean really truly always, so even that's fine</p>",
        "id": 277355638,
        "sender_full_name": "Talchas",
        "timestamp": 1648771303
    },
    {
        "content": "<p>In lccc, it's guaranteed that an <code>#[inline]</code> function is instantiated in every crate that contains an instantiated call to it, then all instantiations are merged into a single copy per final link target ({c,}dylib/exec).</p>",
        "id": 277355642,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648771311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355443\">said</a>:</p>\n<blockquote>\n<p>like, you need to be able to somehow compile separate functions with separate optimization settings, which is maybe a little bit of effort to do /fast/, but is not any real effort to do in general</p>\n</blockquote>\n<p>Sure, unless you have a limited-by-design compilation pipeline.</p>",
        "id": 277355742,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648771389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218745\">@Wanja Hentze</span> Agreed.  Though, I think it's important to clarify what it means that it can't guess your locals' addresses.  Rust 'owns' some subset of concrete machine memory, like its stack frames and whatever heap memory it allocates.  Except for whatever subset of that it properly exposes to FFI, that memory is not guaranteed to contain anything sensible, and you get UB if you modify it and pass execution back to Rust.</p>",
        "id": 277355911,
        "sender_full_name": "comex",
        "timestamp": 1648771550
    },
    {
        "content": "<p>like the simple model is that every rust crate compilation separates all visible (ie current crate / generics / #[inline]) code into \"strict\" and \"nostrict\" compilations each with the functions from the other one only provided as <code>extern fn</code>s</p>",
        "id": 277355912,
        "sender_full_name": "Talchas",
        "timestamp": 1648771552
    },
    {
        "content": "<p>this does mean that inline(always) will be more like inline(never) if it's called from something with the wrong provenance setting</p>",
        "id": 277355966,
        "sender_full_name": "Talchas",
        "timestamp": 1648771571
    },
    {
        "content": "<p>But it's important to not just say things like \"it's UB even to read it\", which can fly in the abstract machine but not the concrete one.  Since it's a valid use case to dump all the memory in the process, e.g. to checkpoint the process or do a core dump.</p>",
        "id": 277356019,
        "sender_full_name": "comex",
        "timestamp": 1648771638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355911\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> Agreed.  Though, I think it's important to clarify what it means that it can't guess your locals' addresses.  Rust 'owns' some subset of concrete machine memory, like its stack frames and whatever heap memory it allocates.  Except for whatever subset of that it properly exposes to FFI, that memory is not guaranteed to contain anything sensible, and you get UB if you modify it and pass execution back to Rust.</p>\n</blockquote>\n<p>formalizing what \"you can't guess pointers\" means is exactly what provenance is meant to do <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> it feels natural to apply it here too</p>",
        "id": 277356022,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648771641
    },
    {
        "content": "<p>IoW, if you assume foreign code plays by some rules but not by strict provenance rules, what optimizations do you still get to keep?</p>",
        "id": 277356130,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648771732
    },
    {
        "content": "<p>In theory, all of them.  Provenance can affect whether or not some memory is considered exposed to FFI.  It's just that if it is exposed, FFI is allowed to work at the lower level where pointers are integers.  Because that's really a matter of what the FFI code does internally, and none of Rust's business.</p>",
        "id": 277356284,
        "sender_full_name": "comex",
        "timestamp": 1648771856
    },
    {
        "content": "<p>Like, in theory, the only optimizations that should be excluded are hypothetical ones involving actually inspecting the FFI machine code and checking what it does.</p>",
        "id": 277356311,
        "sender_full_name": "comex",
        "timestamp": 1648771910
    },
    {
        "content": "<p>that supposes Rust can consider addresses \"exposed\" but strict provenance wants to do away with that</p>",
        "id": 277356319,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648771918
    },
    {
        "content": "<p>if all of FFI is one big black box, Rust code can hand arbitrary pointers to it and receive them back at any time. that looks and acts exactly like a ptr2intr2ptr round trip</p>",
        "id": 277356423,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277355966\">said</a>:</p>\n<blockquote>\n<p>this does mean that inline(always) will be more like inline(never) if it's called from something with the wrong provenance setting</p>\n</blockquote>\n<p>You can't make an FFI call to an <code>#[inline]</code> function.</p>",
        "id": 277356482,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772085
    },
    {
        "content": "<p>yes you can, you generate the code for the inline function, compile it on the other side of the strict/no-strict barrier, and then FFI call that</p>",
        "id": 277356501,
        "sender_full_name": "Talchas",
        "timestamp": 1648772114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352274\">said</a>:</p>\n<blockquote>\n<p>with strict aliasing, nobody would dare suggesting turning that loose on e.g. Linux. who knows what would happen</p>\n</blockquote>\n<p>It looks like the TySan work has been active recently, so I wouldn't be too sure.</p>",
        "id": 277356504,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648772122
    },
    {
        "content": "<p>there is no guarantee ever that it is actually inlined</p>",
        "id": 277356507,
        "sender_full_name": "Talchas",
        "timestamp": 1648772125
    },
    {
        "content": "<p>No, but the machine code is generated <em>in</em> the translation unit itself.</p>",
        "id": 277356525,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> TIL about TySan</p>",
        "id": 277356577,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772187
    },
    {
        "content": "<p>Same with Generic Functions, Generic Impls, VTables for Generic Impls, destructors (when generic or no <code>Drop</code> impl), etc.</p>",
        "id": 277356581,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772193
    },
    {
        "content": "<p>Why? It certainly doesn't /need/ to be</p>",
        "id": 277356590,
        "sender_full_name": "Talchas",
        "timestamp": 1648772210
    },
    {
        "content": "<p>like rust in particular makes no guarantees or talk about translation unit at all</p>",
        "id": 277356615,
        "sender_full_name": "Talchas",
        "timestamp": 1648772248
    },
    {
        "content": "<p>Well, partly because that's how I've chosen to specify it, partly because it's easy, partly because it works when you can only generate one ir output?</p>",
        "id": 277356622,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772254
    },
    {
        "content": "<p>For what it's worth, we basically LTO everything between Rust and C++ today on enormous binaries and I maintain a backport of Rust to LLVM 9 to enable us to do so. So we're pretty reliant on things that work today in cross-language LTO continuing to work. (I'm not implying that anything under discussion right now is going to break us, just putting that out there)</p>",
        "id": 277356624,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648772255
    },
    {
        "content": "<p>heck, clang and gcc have the whole per-function optimization settings thing even</p>",
        "id": 277356679,
        "sender_full_name": "Talchas",
        "timestamp": 1648772285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218745\">@Wanja Hentze</span>  Yep, but this is unavoidable.  If you pass some memory containing pointers to FFI (assuming it is mutable memory), if you imagine that provenance exists over FFI, then the FFI code could replace the provenances without changing the pointers ‚Äì but there is no way to know whether it did that or not, so your side of the FFI call must be optimized assuming it might have done that.</p>",
        "id": 277356693,
        "sender_full_name": "comex",
        "timestamp": 1648772303
    },
    {
        "content": "<p>Yeah, that won't work well for lccc.</p>",
        "id": 277356695,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772309
    },
    {
        "content": "<p>which depending on how that's actually implemented, might let you do better than \"call into LLVM with two completely separate setups\"</p>",
        "id": 277356696,
        "sender_full_name": "Talchas",
        "timestamp": 1648772311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> exactly</p>",
        "id": 277356707,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772334
    },
    {
        "content": "<p>Optimization level determines what optimization plugins are run on the IR the frontend generates.</p>",
        "id": 277356709,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772337
    },
    {
        "content": "<p>*without changing the addresses</p>",
        "id": 277356812,
        "sender_full_name": "comex",
        "timestamp": 1648772423
    },
    {
        "content": "<p>so any implementation must already be able to cope with pointers escaping into a big black box pools of provenances</p>",
        "id": 277356836,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772494
    },
    {
        "content": "<p>Sounds like we're in violent agreement...</p>",
        "id": 277356845,
        "sender_full_name": "comex",
        "timestamp": 1648772504
    },
    {
        "content": "<p>to me, that makes <em>something like</em> PNVI-ae inescapable</p>",
        "id": 277356899,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772539
    },
    {
        "content": "<p>troubles with formalizing that notwithstanding</p>",
        "id": 277356906,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772556
    },
    {
        "content": "<p>An implementation could also just not support FFI.</p>",
        "id": 277356911,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772563
    },
    {
        "content": "<p>Or only support a subset.</p>",
        "id": 277356920,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772572
    },
    {
        "content": "<p>miri is such an implementation.</p>",
        "id": 277356921,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277356899\">said</a>:</p>\n<blockquote>\n<p>to me, that makes <em>something like</em> PNVI-ae inescapable</p>\n</blockquote>\n<p>Exactly my conclusion too.</p>",
        "id": 277356947,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648772607
    },
    {
        "content": "<p>sure, but we will always need implementations that support FFI, the vast majority of production Rust code uses FFI</p>",
        "id": 277356999,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772643
    },
    {
        "content": "<p>FFI is necessary for I/O, so any program that doesn't use FFI can be trivially optimized away to nothing :)</p>",
        "id": 277357043,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648772674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357043\">said</a>:</p>\n<blockquote>\n<p>FFI is necessary for I/O, so any program that doesn't use FFI can be trivially optimized away to nothing :)</p>\n</blockquote>\n<p>Well, volatile operations can be done in the AM directly.</p>",
        "id": 277357055,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772695
    },
    {
        "content": "<p>if you want to support FFI but also have strict provenance in miri, isn't that splitting the language?</p>",
        "id": 277357059,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772699
    },
    {
        "content": "<p>I mean, miri is functionally broken with PNVI-ae.</p>",
        "id": 277357082,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772729
    },
    {
        "content": "<p>There is code that is guaranteed to be valid that miri doesn't support because it's basically impossible to support using PNVI-ae.</p>",
        "id": 277357146,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772769
    },
    {
        "content": "<p>is there more to it for miri than having a global hash set or so of escaped provenances?</p>",
        "id": 277357180,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772831
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/*guess allocation of x, this is actually trivial with miri*/</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277357191,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772845
    },
    {
        "content": "<p>and perhaps merging overlapping ones</p>",
        "id": 277357197,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772852
    },
    {
        "content": "<p>If you properly guess the address of <code>x</code>, IIRC, miri reports UB here.</p>",
        "id": 277357215,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772869
    },
    {
        "content": "<p>However</p>\n<blockquote>\n<p>An nonzero literal cast to a pointer will allways be valid for accesses of size 0.</p>\n</blockquote>",
        "id": 277357270,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772907
    },
    {
        "content": "<p>and this is impossible to support?</p>",
        "id": 277357271,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772908
    },
    {
        "content": "<p>Without making miri even more complex, slow, and memory hungry? I'd assume so.</p>",
        "id": 277357294,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772946
    },
    {
        "content": "<p>If miri is reporting UB for a dereference of a ZST, then I think that is just a bug in miri.</p>",
        "id": 277357298,
        "sender_full_name": "comex",
        "timestamp": 1648772949
    },
    {
        "content": "<p>oh, access of size zero. let us not have this discussion again</p>",
        "id": 277357300,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648772958
    },
    {
        "content": "<p>Dereferencing a deallocated ZST pointer is still UB.</p>",
        "id": 277357312,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648772973
    },
    {
        "content": "<p>Why?</p>",
        "id": 277357318,
        "sender_full_name": "comex",
        "timestamp": 1648772982
    },
    {
        "content": "<p>That is news to me.</p>",
        "id": 277357320,
        "sender_full_name": "comex",
        "timestamp": 1648772987
    },
    {
        "content": "<p>Read <code>core::ptr</code> # Safety in the stdlib docs.</p>",
        "id": 277357331,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773000
    },
    {
        "content": "<blockquote>\n<p>Even for accesses of size zero, <code>p</code> must not be null or pointing to deallocated memory.</p>\n</blockquote>",
        "id": 277357384,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773025
    },
    {
        "content": "<p>Okay, but why? (<span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>)</p>",
        "id": 277357393,
        "sender_full_name": "comex",
        "timestamp": 1648773036
    },
    {
        "content": "<p>It makes the model far more consistent, especially pre-mono.</p>",
        "id": 277357403,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773056
    },
    {
        "content": "<p>there is no pre-mono memory model</p>",
        "id": 277357442,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648773105
    },
    {
        "content": "<p>I, for one, would like to be able to reason about pointers in xir without having to write something 500 times the length of stacked borrows.</p>",
        "id": 277357443,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773107
    },
    {
        "content": "<p>If you make some optimization pre-mono based on a no-aliasing assumption that would be valid for non-ZSTs but isn't valid for ZSTs because (hypothetically) dereferencing 0 bytes is always valid‚Ä¶ then as a result of that optimization, you might assume the ZST has the wrong value‚Ä¶ and it doesn't matter because ZSTs have only one value.</p>",
        "id": 277357500,
        "sender_full_name": "comex",
        "timestamp": 1648773145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357442\">said</a>:</p>\n<blockquote>\n<p>there is no pre-mono memory model</p>\n</blockquote>\n<p>And this is news to me. So basically, I can't genreate <code>indirect</code> instructions in generic code. Good to know. IDK how else to dereference a pointer in xir.</p>",
        "id": 277357516,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357500\">said</a>:</p>\n<blockquote>\n<p>If you make some optimization pre-mono based on a no-aliasing assumption that would be valid for non-ZSTs but isn't valid for ZSTs because (hypothetically) dereferencing 0 bytes is always valid‚Ä¶ then as a result of that optimization, you might assume the ZST has the wrong value‚Ä¶ and it doesn't matter because ZSTs have only one value.</p>\n</blockquote>\n<p>Well, unless it folds <code>undef invalid</code> as that value.</p>",
        "id": 277357528,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773197
    },
    {
        "content": "<p>Do you have a concrete example of a case where this makes a difference?</p>",
        "id": 277357532,
        "sender_full_name": "comex",
        "timestamp": 1648773203
    },
    {
        "content": "<p>I don't know what <code>undef invalid</code> means, but zero bytes of <code>undef</code> should be a perfectly fine value.</p>",
        "id": 277357549,
        "sender_full_name": "comex",
        "timestamp": 1648773236
    },
    {
        "content": "<p>Not a specific example, other than the length of the xir spec.</p>",
        "id": 277357552,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773238
    },
    {
        "content": "<p>I mean, LLVM <code>undef</code>.</p>",
        "id": 277357592,
        "sender_full_name": "comex",
        "timestamp": 1648773249
    },
    {
        "content": "<p>Even LLVM <code>poison</code>.</p>",
        "id": 277357597,
        "sender_full_name": "comex",
        "timestamp": 1648773263
    },
    {
        "content": "<p>Well, I don't think LLVM has zero-size values.</p>",
        "id": 277357609,
        "sender_full_name": "comex",
        "timestamp": 1648773280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357549\">said</a>:</p>\n<blockquote>\n<p>I don't know what <code>undef invalid</code> means, but zero bytes of <code>undef</code> should be a perfectly fine value.</p>\n</blockquote>\n<p><code>undef</code> is a class of values in xir, which has two members: <code>undef uninit</code> which is the \"cannonical\" uninitialized value of some type (equivalent to llvm <code>poison</code>), and <code>undef invalid</code> which is the \"cannonical\" invalid value of some type.<br>\nThe easiest explanation is that <code>undef invalid</code> is <em>the</em> value of type <code>!</code> - it's production is immediate undefined behaviour.</p>",
        "id": 277357641,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773315
    },
    {
        "content": "<p>Well, ZSTs have no invalid values.</p>",
        "id": 277357696,
        "sender_full_name": "comex",
        "timestamp": 1648773368
    },
    {
        "content": "<p>In xir, every type has at least one invalid value - <code>undef invalid</code>.</p>",
        "id": 277357707,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773389
    },
    {
        "content": "<p>Then xir is wrong :)</p>",
        "id": 277357712,
        "sender_full_name": "comex",
        "timestamp": 1648773394
    },
    {
        "content": "<p><code>const undef invalid T</code> is the same as producing a value of type <code>!</code>, then coercing it to <code>T</code>.</p>",
        "id": 277357735,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357712\">said</a>:</p>\n<blockquote>\n<p>Then xir is wrong :)</p>\n</blockquote>\n<p>I mean, is it? You can't reach it in rust w/o UB.</p>",
        "id": 277357763,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773463
    },
    {
        "content": "<p>Well, maybe I'm overstating my case.  If you have something which is nominally a value, but is really just a representation of the fact that being at this point in the code is UB, then there's nothing inherently invalid about that.</p>",
        "id": 277357831,
        "sender_full_name": "comex",
        "timestamp": 1648773513
    },
    {
        "content": "<p>But again, need a more concrete example where this matters.</p>",
        "id": 277357837,
        "sender_full_name": "comex",
        "timestamp": 1648773527
    },
    {
        "content": "<p>My concrete example is the xir pointer spec. That becomes far too overcomplicated if I have to special case every single pointer operation on zero-sized types.</p>",
        "id": 277357874,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773586
    },
    {
        "content": "<p>I guess if you want to optimize <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { dealloc(ptr); *ptr }</code> into <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { abort() }</code>...</p>",
        "id": 277357937,
        "sender_full_name": "comex",
        "timestamp": 1648773623
    },
    {
        "content": "<p>Like rust, I want a model that makes sense, and that doesn't take an essay to say what it currently says in one sentance.</p>",
        "id": 277357939,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357937\">said</a>:</p>\n<blockquote>\n<p>I guess if you want to optimize <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { dealloc(ptr); *ptr }</code> into <code>fn foo&lt;T&gt;(ptr: *mut T) -&gt; T { abort() }</code>...</p>\n</blockquote>\n<p>This would be a case of \"folding invalid\".</p>",
        "id": 277357956,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773656
    },
    {
        "content": "<p>Okay, fine.  So the real problem is that you're being too aggressive about optimizations done pre-mono :)</p>",
        "id": 277357963,
        "sender_full_name": "comex",
        "timestamp": 1648773670
    },
    {
        "content": "<p>(Also, the backend currently checks certain kinds of validity w/o checking sizes - because size checking every single instruction would be garbage).</p>",
        "id": 277357976,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773699
    },
    {
        "content": "<p>(Size checking potentially involves computing aggregate layout)</p>",
        "id": 277358029,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648773742
    },
    {
        "content": "<p>Before I log off, I would like to summarize the position that I arrived at after interesting discussions here. So that it can be linked to.</p>",
        "id": 277358073,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648773841
    },
    {
        "content": "<p>Inspired by <a href=\"https://gankra.github.io/blah/fix-rust-pointers/\">(1)</a> <a href=\"https://github.com/rust-lang/rust/issues/95228\">(2)</a> We would like</p>\n<ul>\n<li>a pathway to a formally-defined execution model</li>\n<li>compilation to fast code ‚Äî meaning that powerful alias analysis applies to common Rust code</li>\n<li>to support CHERI</li>\n<li>that a lot of existing unsafe code keeps working</li>\n<li>to keep supporting <code>inttoptr</code> for some niche use cases, like pointer compression</li>\n<li>to avoid weird miscompilations like <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> </li>\n</ul>\n<p>I think the following approach gets us everything or 99% of what we want.</p>\n<ul>\n<li>\n<p>We keep <code>usize as ptr</code> permissive as is, and we discourage its use. We don't change its meaning, so perhaps it's defined as something like Stacked Borrows (~ the Rust analog of pnvi-ae). What the semantics is exactly of <code>usize as ptr</code> is outside the scope of this topic ‚Äî but it is <em>not</em> strict.</p>\n</li>\n<li>\n<p>On CHERI, <code>usize as ptr</code> compiles to something horribly expensive (like the <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277317047\">TreeMap</a> approach)</p>\n</li>\n<li>\n<p>We keep <code>ptr.addr()</code> / <code>ptr as usize</code> permissive as is, and we discourage their use. On CHERI, they compile to something horribly expensive.</p>\n</li>\n<li>\n<p>We introduce <code>ptr.addr_strict()</code> which is fast on CHERI -- but <code>ptr.addr_strict() as ptr</code> is principally UB.</p>\n</li>\n<li>\n<p>With the new <code>#[feature(strict_provenance)]</code> functions in <code>std::ptr</code>, we can convert <code>ptr.addr_strict()</code>-based addresses back into real pointers, even on CHERI. </p>\n</li>\n<li>\n<p>We keep <code>std::ptr::invalid</code> as in nightly. This corresponds to \"strict\" <code>inttoptr</code>. It is UB to dereference these.</p>\n</li>\n<li>\n<p>We introduce a lint against <code>usize as ptr</code> and <code>ptr as usize</code> ‚Äî because they are horribly slow on some platforms and merely slower on most others.</p>\n</li>\n<li>\n<p>All other ways to create a pointer (in particular various transmutes) are UB. </p>\n</li>\n<li>\n<p>For our future \"abstract machine\", we keep aiming for something like Stacked Borrows. </p>\n</li>\n</ul>\n<p>Then</p>\n<ul>\n<li>We don't need no compiler flag, no opt-in, no opt-out</li>\n<li>We break pretty much nothing (presumably, to be <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277349017\">investigated</a>)</li>\n<li>This doesn't create new questions around FFI</li>\n<li>We make CHERI work</li>\n<li>We plan to rewrite crates so <code>usize as ptr</code> and <code>ptr as usize</code> is no longer used. This is only a performance improvement ‚Äî the original still works.</li>\n<li>CHERI is fast after the ecosystem transitions over</li>\n<li>Compressed pointers keep working as they do now ‚Äî and pretty fast on x64.</li>\n<li>Our relation with LLVM stays principally the same. </li>\n<li>Transmuting / memory semantics <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">needs to be refined further</a>.</li>\n</ul>",
        "id": 277358112,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648773846
    },
    {
        "content": "<p>That's it, please carry on</p>",
        "id": 277358115,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648773853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357393\">said</a>:</p>\n<blockquote>\n<p>Okay, but why? (<span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>)</p>\n</blockquote>\n<p>originally, because LLVM</p>",
        "id": 277358233,
        "sender_full_name": "RalfJ",
        "timestamp": 1648773975
    },
    {
        "content": "<p>nothing in the langref permits us to GEPi by 0 on a dangling pointer after it got deallocated. in C this would be UB (because pointers to deallocated locations become indeterminate). when I asked on the llvm-dev list I think they didn't really understand the question but the general vibe was \"better dont do that\".<br>\nalso it is indeed more consistent under strict aliasing -- when an allocation is <code>free</code>d, its provenance is killed, and any interaction with that provenance now is UB. in Miri we would need a special case to allow this.</p>",
        "id": 277358410,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357963\">said</a>:</p>\n<blockquote>\n<p>Okay, fine.  So the real problem is that you're being too aggressive about optimizations done pre-mono :)</p>\n</blockquote>\n<p>One of the benefits to xir is supposed to be that you can run all opts pre-mono instead of post-mono and it's still correct.</p>",
        "id": 277358456,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648774168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277357442\">said</a>:</p>\n<blockquote>\n<p>there is no pre-mono memory model</p>\n</blockquote>\n<p>FWIW, I agree. the semantics of pre-mono code is defined by \"pick a monomorphization, and then run it with that\".<br>\npre-mono optimizations are correct if they are correct for each possible monomorphization.</p>",
        "id": 277358541,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774214
    },
    {
        "content": "<p>Part of that involves specifying the IR far better than LLVM has done.</p>",
        "id": 277358552,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648774222
    },
    {
        "content": "<p>Rust doesn't have a uniform representation or so, so I dont see how pre-mono execution even makes sense.</p>",
        "id": 277358580,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774268
    },
    {
        "content": "<p>like, it has to return <em>something</em> for queries like \"what is the size of this\" or \"what is the offset of that\"</p>",
        "id": 277358688,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774365
    },
    {
        "content": "<p>that all only makes sense post-mono</p>",
        "id": 277358692,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774370
    },
    {
        "content": "<p><code>size_of %0</code>is good enough for optimizations.</p>",
        "id": 277358716,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648774406
    },
    {
        "content": "<p>sure but that doesnt need a pre-mono memory model or anything like that</p>",
        "id": 277358906,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774569
    },
    {
        "content": "<p>In any case, I'm less concerned about the loss of pre-mono opts then I am of the spec work underlying that. I rely heavily on being able to not insert properties of types into most pointer operations (and talking mostly about properties of objects) to be able to write anything at all. There's currently one special case for ZSTs.</p>",
        "id": 277358913,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648774575
    },
    {
        "content": "<p>that's equivalent to saying \"optimizations need to be correct for all possible mono\"</p>",
        "id": 277358918,
        "sender_full_name": "RalfJ",
        "timestamp": 1648774583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358906\">said</a>:</p>\n<blockquote>\n<p>sure but that doesnt need a pre-mono memory model or anything like that</p>\n</blockquote>\n<p>Right, what I need is a coherent memory model that I can express, preferably in less text that comprises the entire lccc codebase.</p>",
        "id": 277359222,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648774855
    },
    {
        "content": "<p>Having ZSTs not be special cased wrt. deallocated pointers makes that job a heck of a lot easier.</p>",
        "id": 277359277,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648774905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"490906\">Brooks Davis</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340798\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340272\">said</a>:</p>\n<blockquote>\n<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>\n</blockquote>\n<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf(\"%p\")</code> and <code>sscanf(\"%p\")</code>) but never as something anyone would actually implement.</p>\n</blockquote>\n<p>It's also genuinely impossible to make work. You can have two pointers with the same address but different bounds, permissions, whatever. How then do you know which of the pointers with that address to use? You can't. So this just isn't productive to talk about, even aside from the atrocious performance and security consequences of it.</p>",
        "id": 277361400,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648777237
    },
    {
        "content": "<p>If you want concrete examples:</p>\n<ol>\n<li>A pointer to the array and a pointer to just the first element alias but have different bounds</li>\n<li>A JIT could have RW and RX pointers to the same memory (you don't need W^X in your page tables any more, just map RWX and only give out disjoint capabilities)</li>\n</ol>",
        "id": 277361456,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648777320
    },
    {
        "content": "<p>Magicking up capabilities from some mysterious hidden set of leaked addresses only works in the simple cases, it doesn't work in the general case, so it's not worth viewing as a serious proposal IMO.</p>",
        "id": 277361515,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648777377
    },
    {
        "content": "<p>Oh or another even more fun example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%p %p</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">\"%p\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If <code>p == a + 1 == b</code>, what bounds does p have? a's or b's?</p>",
        "id": 277361750,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648777632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439664\">Jessica Clarke</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277361400\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"490906\">Brooks Davis</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340798\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277340272\">said</a>:</p>\n<blockquote>\n<p>I propose (only 5% my own proposal) that CHERI <code>ptr.addr()</code> would insert the pointer into a TreeMap. Or something more complicated that allows for pruning when the Stacked Borrows protector is popped / something like that</p>\n</blockquote>\n<p>From a CHERI and exploit mitigation perspective I'm horrified. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> We've talked about such things to support awful C idioms (e.g., round tripping a pointer through <code>sprintf(\"%p\")</code> and <code>sscanf(\"%p\")</code>) but never as something anyone would actually implement.</p>\n</blockquote>\n<p>It's also genuinely impossible to make work. You can have two pointers with the same address but different bounds, permissions, whatever. How then do you know which of the pointers with that address to use? You can't. So this just isn't productive to talk about, even aside from the atrocious performance and security consequences of it.</p>\n</blockquote>\n<p>But in practice round tripping a pointer through sprintf/sscanf works today in most C++ environments. (Programs do the moral equivalent of that when they load binaries from disk into memory.) So I don't see why it's not productive to talk about how we're going to support it.</p>",
        "id": 277361866,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648777772
    },
    {
        "content": "<p>I know that you can come up with some examples that LLVM miscompiles. But in practice hiding pointers in ints works, and there's code out there that relies on it.</p>",
        "id": 277361953,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648777830
    },
    {
        "content": "<p>If CHERI is unable to support idioms that hide pointers in integers, then I would argue that that is a practicality issue that needs to be addressed in CHERI, and not something we need to break code in service of. Not to take this too far off topic, but there are real concerns inside the Android team that CHERI is too restrictive for them.</p>",
        "id": 277362264,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648778246
    },
    {
        "content": "<p>This is not to bash CHERI, just to say that it may not be best to treat CHERI's current semantics as sacrosanct.</p>",
        "id": 277362327,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648778322
    },
    {
        "content": "<p>CHERI has done pretty well at modifying its semantics to be, in practice, looser than what the majority of C or C++ code really needs, while still being reasonably strict. They have one of the BSDs, Postgres, and WebKit working, last I checked. I find it hard to believe an Android app, or even Android itself, does anything so exotic that it is actually infeasible.</p>",
        "id": 277363757,
        "sender_full_name": "Jubilee",
        "timestamp": 1648779882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277362264\">said</a>:</p>\n<blockquote>\n<p>If CHERI is unable to support idioms that hide pointers in integers, then I would argue that that is a practicality issue that needs to be addressed in CHERI, and not something we need to break code in service of. Not to take this too far off topic, but there are real concerns inside the Android team that CHERI is too restrictive for them.</p>\n</blockquote>\n<p>I mean, CHERI works, so clearly they support it well enough to at least get a program loader of sorts working. :D</p>\n<p>In the context of Rust I think it is fine if CHERI does not support software that does not comply with 'strict provenance'. a new architecture like CHERI is a great time to admit that some decisions made in the past were a mistake. we can use legacy code on legacy platforms and make sure it works there, but maybe we can do better for new ones. They actually managed to do way more than that for C (though that involves things that would be harder to do in Rust, like a 128bit uintptr_t).</p>",
        "id": 277363771,
        "sender_full_name": "RalfJ",
        "timestamp": 1648779896
    },
    {
        "content": "<p>okay \"legacy\" is too strong here but you see what I mean.</p>",
        "id": 277363872,
        "sender_full_name": "RalfJ",
        "timestamp": 1648780022
    },
    {
        "content": "<p>I strongly believe the way pointers are treated in C is a horrible mistake. we barely keep it working kinda but if you look close enough it's all sorts of broken (as my many examples show). sure, we have to keep this old stuff running along somehow and we'll keep adding crutches to prevent it from falling over, but that shouldn't stop us from figuring out how to do this <em>properly</em>.</p>\n<p>this is not to bash C, just to say that it may not be best to treat the mess that is pointers in C as sacrosanct.</p>",
        "id": 277364080,
        "sender_full_name": "RalfJ",
        "timestamp": 1648780243
    },
    {
        "content": "<blockquote>\n<p>I find it hard to believe an Android app, or even Android itself, does anything so exotic that it is actually infeasible.</p>\n</blockquote>\n<p>you, uh, may be underestimating the sketchy things games do.</p>",
        "id": 277364105,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648780313
    },
    {
        "content": "<p>I am aware of the monstrosities games perpetrate, actually!</p>",
        "id": 277364168,
        "sender_full_name": "Jubilee",
        "timestamp": 1648780363
    },
    {
        "content": "<p>i have little hope for them on cheri</p>",
        "id": 277364186,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648780385
    },
    {
        "content": "<p>doesn't mean cheri is bad, though. especially since iirc it has a model for software that completely disregards the rules</p>",
        "id": 277364200,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648780425
    },
    {
        "content": "<p>Yes, it allows sandboxing essentially an entire process away from Da Rules.</p>",
        "id": 277364252,
        "sender_full_name": "Jubilee",
        "timestamp": 1648780466
    },
    {
        "content": "<p>Which is actually why I think games will be mmmostly fine on CHERI since usually they're just perpetrating their crimes against <strong>themselves</strong>.</p>",
        "id": 277364270,
        "sender_full_name": "Jubilee",
        "timestamp": 1648780497
    },
    {
        "content": "<p>Or using a lot of arenas.</p>",
        "id": 277364286,
        "sender_full_name": "Jubilee",
        "timestamp": 1648780526
    },
    {
        "content": "<p>( and, functionally, the CHERI model for Mischievous Software that does Pointer Crimes is... hard to distinguish from \"so we drop all this into an arena and create a valid capability for the entire arena\". )</p>",
        "id": 277364372,
        "sender_full_name": "Jubilee",
        "timestamp": 1648780652
    },
    {
        "content": "<p>I mean, the CHERI model for \"basically not using CHERI for this app\" is mostly irrelevant to a discussion about provenance, because then CHERI is a non-factor</p>",
        "id": 277364561,
        "sender_full_name": "Talchas",
        "timestamp": 1648780889
    },
    {
        "content": "<p>like rust could say it supports CHERI in a PNVI-like provenance world, where it only supports it when all capabilities are the maximum-for-address-space one or whatever</p>",
        "id": 277364662,
        "sender_full_name": "Talchas",
        "timestamp": 1648781007
    },
    {
        "content": "<p>That is indeed true. Unlike CHERI, programming languages tend to actually assign responsibility to programmers. They actually have less options than hardware like CHERI does for... condescension to programs that refuse responsibility.</p>",
        "id": 277364838,
        "sender_full_name": "Jubilee",
        "timestamp": 1648781204
    },
    {
        "content": "<p>I mean, -fno-strict-aliasing/-fwrapv/etc for prior examples of programming languages doing that</p>",
        "id": 277364950,
        "sender_full_name": "Talchas",
        "timestamp": 1648781371
    },
    {
        "content": "<p>Ah, yes.<br>\nBut at extreme cost to self, by comparison.</p>",
        "id": 277365018,
        "sender_full_name": "Jubilee",
        "timestamp": 1648781442
    },
    {
        "content": "<p>A CHERI architecture agreeing to carve out a zone wherein all pointers are interpreted as having a capability entitling them to dereference anywhere in that zone maintains the integrity of the rule, \"under CHERI, all pointers obey these boundary conditions\". That code cannot then wander outside and cause mischief, even if it is very mischievous within those bounds.</p>\n<p>But the examples you cite are not \"integrity preserving\" in the same way, and so cause considerably more issues.</p>",
        "id": 277365489,
        "sender_full_name": "Jubilee",
        "timestamp": 1648782061
    },
    {
        "content": "<p>Not all escape hatches are created equal, unfortunately.</p>",
        "id": 277365507,
        "sender_full_name": "Jubilee",
        "timestamp": 1648782091
    },
    {
        "content": "<p>-fwrapv is, but it's also super trivial; I believe strict-aliasing code can still call into -fno-strict-aliasing code? (the reverse requires being more careful around the boundary, but that's also true for nesting CHERI capabilities)</p>",
        "id": 277366560,
        "sender_full_name": "Talchas",
        "timestamp": 1648783513
    },
    {
        "content": "<p>unless you just mean that CHERI capabilities are a stronger statement than strict-aliasing, sure, but that doesn't seem like what you mean?</p>",
        "id": 277366641,
        "sender_full_name": "Talchas",
        "timestamp": 1648783588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277364080\">said</a>:</p>\n<blockquote>\n<p>I strongly believe the way pointers are treated in C is a horrible mistake. we barely keep it working kinda but if you look close enough it's all sorts of broken (as my many examples show). sure, we have to keep this old stuff running along somehow and we'll keep adding crutches to prevent it from falling over, but that shouldn't stop us from figuring out how to do this <em>properly</em>.</p>\n<p>this is not to bash C, just to say that it may not be best to treat the mess that is pointers in C as sacrosanct.</p>\n</blockquote>\n<p>The difference, of course, is that nobody is using CHERI while everyone is using C.</p>",
        "id": 277369011,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648786300
    },
    {
        "content": "<p>And orders of magnitude more people are using unsafe Rust than are using CHERI.</p>",
        "id": 277369027,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648786321
    },
    {
        "content": "<p>And we have a Rust 1.0 compatibility promise for currently-working code. We have made no promise that we are going to make Rust compatible with CHERI. Given that Rust has far more users than CHERI, I could reasonably argue that it's CHERI's responsibility to be compatible with <em>us</em>.</p>",
        "id": 277369106,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648786426
    },
    {
        "content": "<p>I also disagree that it's important to figure out how to do pointers properly, if \"properly\" means \"incompatible with existing Rust code\". Rust isn't a research project.</p>",
        "id": 277369398,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648786804
    },
    {
        "content": "<p>I'm all for improvements that we can make to the status quo given the compatibility constraint, though.</p>",
        "id": 277369506,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648786977
    },
    {
        "content": "<p>(which, again, doesn't mean \"no code at all breaks\" -- it means \"the vast majority of reasonable unsafe code keeps working\", with the acknowledgment that \"vast majority\" and \"reasonable\" are subjective terms).</p>",
        "id": 277369524,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648787036
    },
    {
        "content": "<p>It's worth noting there's an ongoing discussion about what stability guarantees unsafe code has in <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code</a>, which may be a better place for some of this discussion</p>",
        "id": 277369793,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648787469
    },
    {
        "content": "<p>Good point, I'll continue the discussion there.</p>",
        "id": 277370025,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648787857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> I called you out on the GH issue on this before and I‚Äòll call you out again: being dismissive of CHERI is not getting us anywhere. I understand that support is hard, but it isn‚Äòt as niche as you make it to me and we should avoid arguments that boil down to grandeur.</p>",
        "id": 277372760,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1648791485
    },
    {
        "content": "<p>Please drop your tone a little bit, you are literally a person of social discussion currently and I know you can do better then that.</p>",
        "id": 277372783,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1648791550
    },
    {
        "content": "<p>I understand your issue, but just to be clear: there‚Äòs currently an initiative about Rust out there by MISRA and the _other_ danger is a MISRA-Rust dialect.</p>",
        "id": 277372874,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1648791634
    },
    {
        "content": "<p>Also, your statement on the size of Rust is overstated and CHERI is literally the model for all new arm based automotive-platforms. Which is not a loud community, but a surprisingly big one and one currently adopting Rust.</p>",
        "id": 277373029,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1648791790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> curious: why should <code>ptr.addr()</code> be the permissive? I would think it should be the strict one, and e.g. <code>ptr.broadcast()</code> be the weak one (and <code>ptr as usize</code> disallowed in edition 203X)</p>",
        "id": 277374710,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648793674
    },
    {
        "content": "<p>Yes, <code>ptr.addr()</code> was just added in the strict-provenance PR so it would be weird to immediately deprecate it and replace it with <code>ptr.addr_strict()</code></p>",
        "id": 277377967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648797052
    },
    {
        "content": "<p>Good point. Yeah, might as well spell it addr. <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span>üèª</p>",
        "id": 277380820,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648799298
    },
    {
        "content": "<p>That was hardly dismissive given the general arguments in favor of breaking things to support CHERI (as opposed to some of the other arguments)</p>",
        "id": 277381358,
        "sender_full_name": "Talchas",
        "timestamp": 1648799679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277352976\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277351850\">said</a>:</p>\n<blockquote>\n<p>So, scapegoat idea: <code>rustc -fno-strict-provenance</code></p>\n</blockquote>\n<p>Consensus seems to be that we can just introduce <code>ptr.addr_strict()</code> ‚Äî you can't use the result to convert back into a pointer. And then there's no reason to add a compiler flag. Much simpler.</p>\n</blockquote>\n<p>We should probably just make <code>.addr()</code>, the _new thing we're adding_, be strict.</p>",
        "id": 277384483,
        "sender_full_name": "riking",
        "timestamp": 1648801777
    },
    {
        "content": "<blockquote>\n<p>Yes, <code>ptr.addr()</code> was just added in the strict-provenance PR so it would be weird to immediately deprecate it and replace it with <code>ptr.addr_strict()</code></p>\n</blockquote>\n<p>Actually, with Aria's arguments (and I agree) there should be <em>two</em> methods on pointers ‚Äî one permissive and one strict. The permissive method replaces <code>ptr as usize</code>. Because you can put documentation &amp; caveats on docstrings, and <em>both methods</em> need explanation. One is UB in more cases, one is super slow on some platforms.</p>\n<p>We can bikeshed about the names.</p>",
        "id": 277384584,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648801825
    },
    {
        "content": "<p><code>ptr.addr() as *mut T</code> is not something that someone should be writing, if you're using <code>.addr()</code> then you need to use <code>.with_addr()</code></p>",
        "id": 277384594,
        "sender_full_name": "riking",
        "timestamp": 1648801832
    },
    {
        "content": "<p>That makes visual sense</p>",
        "id": 277384636,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648801870
    },
    {
        "content": "<p>So ‚Äî <code>addr</code> and <code>addr_permissive</code>?</p>",
        "id": 277384647,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648801882
    },
    {
        "content": "<p><code>addr</code> and <code>addr_for_pointer_crimes</code>?</p>",
        "id": 277384949,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802073
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> I'm not being dismissive of CHERI. I'm saying that we should not break existing code in order to support CHERI.</p>",
        "id": 277385405,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802315
    },
    {
        "content": "<p>And I wish I could say just how much Rust code we have, but I'm not allowed to. It is not at all correct to characterize it as small.</p>",
        "id": 277385453,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802348
    },
    {
        "content": "<p>I am fine if there is a MISRA-Rust dialect. The number of people who will write in it is so small that it won't matter.</p>",
        "id": 277385507,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802380
    },
    {
        "content": "<p>I'm confused as to why arguing that existing code is more important than CHERI support has anything to do with \"grandeur\".</p>",
        "id": 277385617,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802429
    },
    {
        "content": "<p>Honestly, as I said before, just judging by number of users, CHERI should be catering to us, not the other way around.</p>",
        "id": 277385793,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802546
    },
    {
        "content": "<p>Sorry, but I completely fail to see how I should interpret your messages as anything but dismissive of all concerns that aren't the ones favoring your desired outcome</p>",
        "id": 277386070,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648802718
    },
    {
        "content": "<p>I'm arguing a point of view, I'm not being dismissive.</p>",
        "id": 277386188,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802777
    },
    {
        "content": "<blockquote>\n<p>Honestly, as I said before, just judging by number of users, CHERI should be catering to us, not the other way around.</p>\n</blockquote>\n<p>This could change rapidly</p>",
        "id": 277386240,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386240\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Honestly, as I said before, just judging by number of users, CHERI should be catering to us, not the other way around.</p>\n</blockquote>\n<p>This could change rapidly</p>\n</blockquote>\n<p>Given the track record of academic research projects in this space, it will probably not.</p>",
        "id": 277386264,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802833
    },
    {
        "content": "<p>And I see more future in CHERI than in amd64, for instance</p>",
        "id": 277386272,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802846
    },
    {
        "content": "<blockquote>\n<p>Given the track record of academic research projects in this space, it will probably not.</p>\n</blockquote>\n<p>You don't know. Automotive is not small. And ‚Äî this is exactly dismissing what you're doing =)</p>",
        "id": 277386328,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386272\">said</a>:</p>\n<blockquote>\n<p>And I see more future in CHERI than in amd64, for instance</p>\n</blockquote>\n<p>I'm not sure how to respond to this other than to say that this is way, way, way off from the industry consensus.</p>",
        "id": 277386376,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802892
    },
    {
        "content": "<p>So you are okay with us dismissing AMD64 when it stops being the industry consensus?</p>",
        "id": 277386430,
        "sender_full_name": "Jubilee",
        "timestamp": 1648802920
    },
    {
        "content": "<p>You're making it sound like \"industry consensus\" is the purpose of Rust</p>",
        "id": 277386483,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802953
    },
    {
        "content": "<p>Being useful to industry <em>is</em> the purpose of Rust.</p>",
        "id": 277386498,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802964
    },
    {
        "content": "<p>I strongly disagree</p>",
        "id": 277386509,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802972
    },
    {
        "content": "<p>That's why it was created.</p>",
        "id": 277386510,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802972
    },
    {
        "content": "<p>Open source is also a thing</p>",
        "id": 277386518,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802977
    },
    {
        "content": "<p>Industry including open source.</p>",
        "id": 277386538,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648802986
    },
    {
        "content": "<p>I thought it was letting people write software that was safe and correct but sure I guess sucking up to capitalism is a good purpose too</p>",
        "id": 277386539,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648802987
    },
    {
        "content": "<p>And a very different sphere</p>",
        "id": 277386545,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648802988
    },
    {
        "content": "<p>I'm very concerned with the direction of Rust if the consensus is that AMD64 support is not a concern going forward.</p>",
        "id": 277386670,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803047
    },
    {
        "content": "<p>I would like to put the \"heated\" discussion yesterday in context ‚Äî there was intense arguing from one side to break compatibility as a first attempt, and from another to keep compatibility to a large extent where compatible with other goals. </p>\n<p>I think we've now realized that <em>probably</em> we don't need to break compatibility very much at all</p>",
        "id": 277386682,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803055
    },
    {
        "content": "<p>Yes, that is a very good outcome.</p>",
        "id": 277386702,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803068
    },
    {
        "content": "<p>amd64 support will always stay relevant. Surely tier1 for decades.</p>",
        "id": 277386803,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803118
    },
    {
        "content": "<p>Yeah, uh. Insofar as I am concerned, the purpose of Rust is to be functional.<br>\nAn elevator didn't work and that was too pathetic to let stand.<br>\nAnd that was the \"industry consensus\" not long ago.</p>",
        "id": 277386855,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803124
    },
    {
        "content": "<p>Really, basically still is.</p>",
        "id": 277386917,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386855\">said</a>:</p>\n<blockquote>\n<p>Yeah, uh. Insofar as I am concerned, the purpose of Rust is to be functional.<br>\nAn elevator didn't work and that was too pathetic to let stand.<br>\nAnd that was the \"industry consensus\" not long ago.</p>\n</blockquote>\n<p>The purpose of Rust is to be a useful language for programmers, not to be a research language.</p>",
        "id": 277386963,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803183
    },
    {
        "content": "<p>By your choice of words, computers nowadays are pathetic and don't work..?</p>",
        "id": 277386970,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803185
    },
    {
        "content": "<p>i would definitely describe computers that way</p>",
        "id": 277386996,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648803202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277386963\">said</a>:</p>\n<blockquote>\n<p>The purpose of Rust is to be a useful language for programmers, not to be a research language.</p>\n</blockquote>\n<p>And Florian's point is that CHERI is rapidly exiting the research sphere</p>",
        "id": 277387007,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803208
    },
    {
        "content": "<p>I would say that computers currently work by accident. We want to make them work on purpose. But (even with strict provenance) we're veeerrry far off from that, although the direction is desirable and brings real gains</p>",
        "id": 277387147,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803258
    },
    {
        "content": "<p>Oh, I see Mario beat me to it</p>",
        "id": 277387148,
        "sender_full_name": "riking",
        "timestamp": 1648803258
    },
    {
        "content": "<p>Let's be concrete: I see the chances that CHERI support will be useful to more people in the next 5 years than keeping existing unsafe code working to be basically zero.</p>",
        "id": 277387150,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803260
    },
    {
        "content": "<p>I think it's unhelpful to phrase it as an either/or</p>",
        "id": 277387174,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803275
    },
    {
        "content": "<p>But that is the dichotomy we're discussing.</p>",
        "id": 277387187,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803284
    },
    {
        "content": "<p>I have no idea how you've come to that conclusion</p>",
        "id": 277387205,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648803298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277387147\">said</a>:</p>\n<blockquote>\n<p>I would say that computers currently work by accident. We want to make them work on purpose.</p>\n</blockquote>\n<p>I would accept this, yes.</p>",
        "id": 277387212,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803299
    },
    {
        "content": "<p>That's the dichotomy we keep coming back to ‚Äî but I think now the burden of proof is on showing that we can't reasonably have both</p>",
        "id": 277387237,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648803315
    },
    {
        "content": "<p>As like... mission statement-y and description of reality.</p>",
        "id": 277387243,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803320
    },
    {
        "content": "<p>Compilers work and are useful because problems that occur from issues like the lack of strict provenance are very rare in practice.</p>",
        "id": 277387298,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803359
    },
    {
        "content": "<p>I have stared into the abyssal horror of the System V AMD64 ABI and I am Forever Scarred by that knowledge.</p>",
        "id": 277387304,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803361
    },
    {
        "content": "<p>I would also like to state that I have some issues with the [tone / rhetoric strategy / choose a name for it] you have been using, Patrick.<br>\nExpanding on this is not a productive use of this channel, DM me if you want the long version.</p>",
        "id": 277387420,
        "sender_full_name": "riking",
        "timestamp": 1648803416
    },
    {
        "content": "<p>every even mildly \"accelerated\" program is a breath away from abstract-seeming \"ABI Problems\" utterly annihilating it.</p>",
        "id": 277387438,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803428
    },
    {
        "content": "<p>Pure assembler is actually better off.</p>",
        "id": 277387481,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277387438\">said</a>:</p>\n<blockquote>\n<p>every even mildly \"accelerated\" program is a breath away from abstract-seeming \"ABI Problems\" utterly annihilating it.</p>\n</blockquote>\n<p>This is not true.</p>",
        "id": 277387503,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803473
    },
    {
        "content": "<p>In practice, optimizations work very well.</p>",
        "id": 277387547,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803484
    },
    {
        "content": "<p>I am not talking about optimizations.</p>",
        "id": 277387562,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803495
    },
    {
        "content": "<p>I am talking about what optimizations cannot give you. And I am talking about linkage.</p>",
        "id": 277387598,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803517
    },
    {
        "content": "<p>Anyway, I know that nobody wants to hear \"I'm opposed to this change because it breaks code\". Nobody ever wants to hear that. It's intensely frustrating when you've worked on something a long time, I get it. But we've decided as a project that we care about not breaking people's code, so it's a thing that should be brought up.</p>",
        "id": 277387769,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803617
    },
    {
        "content": "<p>Believe me, I used to hear proposed JavaScript features get shot down practically every week because of backwards compatibility concerns (often related to small things like automatic semicolon insertion).</p>",
        "id": 277387944,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803713
    },
    {
        "content": "<p>But aggressively maintaining backwards compatibility is the only way such features would ever ship.</p>",
        "id": 277388016,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803741
    },
    {
        "content": "<p>Frankly, not a lot of stuff has actually been worked on for a long time because every time someone tries to advance anything a step forward on this matter, hundreds of people step forth to tear them down.</p>",
        "id": 277388021,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803743
    },
    {
        "content": "<p>Often without even getting so far as seeing what is possible.</p>",
        "id": 277388057,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803763
    },
    {
        "content": "<p>I've been assuming for this entire discussion that people have been aware of the Rust 1.0 compatibility promise, which relevantly says Rust reserves the right to break code that never worked, and the only real room for philosophical argument is around the definition of \"never worked\".</p>",
        "id": 277388089,
        "sender_full_name": "riking",
        "timestamp": 1648803791
    },
    {
        "content": "<p>So don't worry, it's just another Rust dev being burnt out and ripped apart, nothing of real concern like features shipping.</p>",
        "id": 277388100,
        "sender_full_name": "Jubilee",
        "timestamp": 1648803797
    },
    {
        "content": "<p>I'm not \"hundreds of people\". In fact, Gankra and the others have done such a great job eloquently explaining the benefits of strict pointer provenance and similar proposals that they've generated a lot of excitement in the community.</p>",
        "id": 277388305,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803906
    },
    {
        "content": "<p>And in fact that's great!</p>",
        "id": 277388319,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648803916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"264702\">riking</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277388089\">said</a>:</p>\n<blockquote>\n<p>I've been assuming for this entire discussion that people have been aware of the Rust 1.0 compatibility promise, which relevantly says Rust reserves the right to break code that never worked, and the only real room for philosophical argument is around the definition of \"never worked\".</p>\n</blockquote>\n<p>Yes, that's why I talked about the \"spirit\" of the promise. Strictly interpreted, the text of the Rust 1.0 promise would allow any sort of change to unsafe code, even if it breaks every piece of unsafe code in the world, because there wasn't a memory model at all.</p>",
        "id": 277388518,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804014
    },
    {
        "content": "<p>I don't think that's a defensible interpretation.</p>",
        "id": 277388624,
        "sender_full_name": "riking",
        "timestamp": 1648804069
    },
    {
        "content": "<p>Right.</p>",
        "id": 277388633,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804074
    },
    {
        "content": "<p>The actual text of the promise isn't what's relevant here. What I'm more focused on is the reasoning behind the Rust 1.0 promise. Rust has such a compatibility guarantee because it's necessary for Rust's customers to have the confidence to adopt Rust that there be a promise that code won't break.</p>",
        "id": 277388700,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804095
    },
    {
        "content": "<p>Practically, how that has turned out has been extensive linting and automatic fix tools being provided for potentially breaking changes and future incompatibilities.</p>",
        "id": 277388782,
        "sender_full_name": "riking",
        "timestamp": 1648804155
    },
    {
        "content": "<p>That's only part of it. The other part is just not making changes that break people's code.</p>",
        "id": 277388900,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804204
    },
    {
        "content": "<p>This is, notably, why editions exist.</p>",
        "id": 277388926,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804220
    },
    {
        "content": "<p>Crater gets run to get statistics like Chrome's UsageCounters to get a sense of \"how much\" a proposed change would break</p>",
        "id": 277388956,
        "sender_full_name": "riking",
        "timestamp": 1648804238
    },
    {
        "content": "<p>Yes, and that's what I'm arguing for here.</p>",
        "id": 277388987,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804262
    },
    {
        "content": "<p>I've never argued that unsafe code semantics changes that we make should never break any code ever.</p>",
        "id": 277389047,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804296
    },
    {
        "content": "<p>I think that a productive path forward would be a design for a version of Crater that can be run in a secrecy-preserving way on private codebases</p>",
        "id": 277389072,
        "sender_full_name": "riking",
        "timestamp": 1648804313
    },
    {
        "content": "<p>It doesn't even need to be based on crater as long as it's something that we can check. I'm more than happy to figure out how to hook tools up to our build system, I don't expect the community to do that.</p>",
        "id": 277389190,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804376
    },
    {
        "content": "<p>that way, the language developers get visibility into how bad the change would be, without the whole world getting visibility into Business Sensitive Numbers</p>",
        "id": 277389206,
        "sender_full_name": "riking",
        "timestamp": 1648804387
    },
    {
        "content": "<p>Yes, that's exactly what I'm advocating :)</p>",
        "id": 277389239,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277389190\">said</a>:</p>\n<blockquote>\n<p>It doesn't even need to be based on crater as long as it's something that we can check. I'm more than happy to figure out how to hook tools up to our build system, I don't expect the community to do that.</p>\n</blockquote>\n<p>Ah, I was thinking of something that could be built once and deployed at N organizations, rather than per-org per-issue efforts.</p>",
        "id": 277389365,
        "sender_full_name": "riking",
        "timestamp": 1648804461
    },
    {
        "content": "<p>In practice that might be hard because of organization-specific build systems, but it could be helpful to have Google, etc. at the table to figure out what the best UI of a build-system-agnostic Crater would look like.</p>",
        "id": 277389477,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804553
    },
    {
        "content": "<p>I'd be happy to start this conversation.</p>",
        "id": 277389524,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648804564
    },
    {
        "content": "<p>(Per-org + Per-issue) must be the goal if it's going to be tractable</p>",
        "id": 277389549,
        "sender_full_name": "riking",
        "timestamp": 1648804583
    },
    {
        "content": "<p>half of the point of this exercise is to make code miri-checkable</p>",
        "id": 277389639,
        "sender_full_name": "Jubilee",
        "timestamp": 1648804662
    },
    {
        "content": "<p>miri can't do FFI, or can it?</p>",
        "id": 277389905,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648804811
    },
    {
        "content": "<p>It actually sorta can, it often has to be taught specifically what some code means.</p>",
        "id": 277389934,
        "sender_full_name": "Jubilee",
        "timestamp": 1648804834
    },
    {
        "content": "<p>One of the advantages of a recent glibc update that is proposed is that it will move our thread spawn call off something... less comprehensible to Miri.</p>",
        "id": 277389988,
        "sender_full_name": "Jubilee",
        "timestamp": 1648804870
    },
    {
        "content": "<p>I think characterizing this effort as being solely to support Cheri is a red herring. As far as I can foresee I have no intention of ever writing code that targets Cheri. What I want is to be able to teach Rust to a new user and when we get to <code>unsafe</code>, I want to be able to convey to them the following:</p>\n<ol>\n<li>What are the rules of unsafe code?</li>\n<li>How do the Rust developers, who claim to care rigorously about memory safety, know that these rules are sufficient to enforce memory safety?</li>\n</ol>\n<p>Currently we don't have either of these, and I see that as a problem. If this effort gets us closer to that world, then I'm for it.</p>",
        "id": 277397717,
        "sender_full_name": "bstrie",
        "timestamp": 1648809408
    },
    {
        "content": "<p>And as <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> notes Rust does have a compatibility promise. The problem is that Rust <em>also</em> has another promise, perhaps less explicit but still completely tangible and arguably even more important: the promise to be memory-safe. The fact that this promise supersedes the stability promise is precisely why the latter carves out exceptions for soundness bugs. Obviously nobody <em>wants</em> to break code spuriously. I want as much code to continue working as possible, and I see that as important for Rust's adoption, which is important for moving us towards a memory-safe world. But if fundamentally Rust doesn't <em>work</em>, then frankly I don't care if it gets adopted, and if we can't write down the rules of unsafe code then arguably Rust does not work.</p>",
        "id": 277398243,
        "sender_full_name": "bstrie",
        "timestamp": 1648809730
    },
    {
        "content": "<p>I am optimistic about <span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span>'s proposals and I would like to see them pursued. In the meantime I see nothing wrong with continuing to push on and expand the proposed APIs for std that will hopefully make it easy for some people to someday say that they can know with confidence that their unsafe code is actually correct. I also am extremely wary of forking the language, but if we <em>must</em> fork the language in order to have any sort of version of Rust that actually keeps its memory-safety promise, then I will tolerate that.</p>",
        "id": 277398440,
        "sender_full_name": "bstrie",
        "timestamp": 1648809869
    },
    {
        "content": "<p>Indeed - Rust being broken gives rust a license to break code relying on the broken parts.<br>\nI'd similarily assume that if Rust is impossible to correctly implement, it has license to break the parts that cannot be correctly implemented. <br>\nAlso, the promise isn't \"as works today\", it's \"as stable\", which mostly overlaps, but they aren't the same thing. For example, if you rely in unsafe code on a repr(Rust) structure being layed out in a particular way, it's not a violation of the stability promise for rustc or for any other implementation to lay it out in an entirely different way in an update. Where the guarantee isn't stable, it isn't a guarantee. In stablizing a proper guarantee, it may be considered where people are relying on \"what works today\" but it's not required.</p>",
        "id": 277401054,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648811544
    },
    {
        "content": "<p>Unsafe code is &lt;1% of Rust code according to <a href=\"http://crates.io\">crates.io</a>. Of that, even <em>strict</em> provenance probably makes &lt;1% of it UB. Given that CHERI has managed to get such large projects working, a weaker provenance model would probably make only 0.1% of unsafe code UB. Of that, actual breakage (miscompilation due to new optimization passes) is likely to be even smaller, let's say 1/10th of that. If we made such a change it would take <em>at least</em> two editions (6 years) of incremental deprecations/warnings. That would mean a single programmer who only fixed 10 lines of broken unsafe code a year, could keep a 60 million line Rust project working.</p>\n<p>These numbers are somewhat arbitrary, but the main point is that due to the separation of unsafe/safe code, we're already 100x better off than if similar breakage were going to happen in C, which will happen even if they don't manage to adopt a formal provenance model, simply as new optimizations get added to LLVM which individually don't quite break enough code to justify rolling back.</p>",
        "id": 277410720,
        "sender_full_name": "Diggsey",
        "timestamp": 1648816784
    },
    {
        "content": "<p>I suspect if we redefine <code>ptr as usize</code>, <code>usize as ptr</code> to be strict, then &gt;10% of unsafe crates on <a href=\"http://crates.io\">crates.io</a> become UB. Not &lt;1%</p>",
        "id": 277411170,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648816994
    },
    {
        "content": "<p>But I like your idea of a back-of-the-envelope calculation</p>",
        "id": 277411240,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648817036
    },
    {
        "content": "<p>I don't feel good about redefining the operations. As soon as possible, provide a comprehensive set of fixed and stable alternatives, then deprecate the casts. Propose removing the casts in the 2024 edition. But let them continue to operate as they currently do, and if at all possible let them \"infect\" a codebase with the current underspecified model, even if it means pessimizing certain optimizations for the entire crate graph; avoid the UB outcome. Maybe that means that you only get great optimization if every single crate in your graph is on the 2024 edition. Maybe that means somehow updating the libc crate to a modern MSRV. Maybe that means it takes 20 years for the majority of Rust code in the wild to benefit from this. That's acceptable, if it also means that people who <em>do</em> actually care about having a sound and understood model of unsafe code can use that to properly guarantee memory safety in their codebase, even if it takes a great deal of effort on their part.</p>",
        "id": 277413063,
        "sender_full_name": "bstrie",
        "timestamp": 1648817856
    },
    {
        "content": "<p>+1 on removing the cast syntax in a future edition. </p>\n<p>To get The Good Speed, we just need as much code as possible to avoid <code>ptr as usize</code> and its alias <code>ptr.addr_permissive()</code>. But IIUC the speed benefits are gradual ‚Äî a bit of non-strict provenance doesn't \"poison\" performance for the rest of the program.</p>\n<p>IMO editions are unrelated to performance, here. They just help to deprecate syntax in favor of a different spelling.</p>",
        "id": 277413969,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648818198
    },
    {
        "content": "<p>As far as I understand, \"old\"/\"permissive\" provenance isn't an issue in particular for having a good model of unsafe code.</p>",
        "id": 277414209,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648818311
    },
    {
        "content": "<p>Well, it isn't for Stacked Borrows, which seems the best we have now.</p>",
        "id": 277414280,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648818347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277410720\">said</a>:</p>\n<blockquote>\n<p>These numbers are somewhat arbitrary...</p>\n</blockquote>\n<p>We don't need to pull numbers out of thin air here. I've written a little crater-like system that runs existing Miri with a bunch of strict checks on published crates. At present 1% of crates encounter something that Miri (before Ralf patched up the ptr-int transmute check) thinks is UB, based on the strict checking of <code>-Zmiri-tag-raw-pointers -Zmiri-check-number-validity</code>. That number may be higher, because about half of crates encounter an error in execution but also do not encounter any UB (per this very picky definition). The leading cause of UB reports is int-to-ptr casts. So far I'm only running the top 10,000 crates. Of those, 1,034 crates report UB, 310 crates encounter an int-to-ptr cast.<br>\nThis is all still very WIP, but you can browse the results at <a href=\"https://miri.saethlin.dev/\">https://miri.saethlin.dev/</a> or just the crates where Miri reports UB at <a href=\"https://miri.saethlin.dev/ub\">https://miri.saethlin.dev/ub</a> the site subject to change because I'm bad at this, etc. etc.</p>",
        "id": 277422742,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648821790
    },
    {
        "content": "<p>Oh also the Miri errors you see in the site are from a prototype branch of Miri that I'm working on, so if you try to repro locally you won't get exactly the same output</p>",
        "id": 277422833,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648821829
    },
    {
        "content": "<p>And the source for the tool is here: <a href=\"https://github.com/saethlin/miri-tools/\">https://github.com/saethlin/miri-tools/</a><br>\nOli is helping me improve it a bit. I wouldn't mind such a thing being used to assess internal codebases.</p>",
        "id": 277423123,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648821947
    },
    {
        "content": "<p>This means that ~1% of crates have UB respective to <em>permissive</em> provenance (as it is now).</p>\n<p>If we aim for strict provenance in the ecosystem, then <em>every</em> int-to-ptr cast has to be rewritten.</p>\n<p>Can you see how many crates use an int-to-ptr cast?</p>",
        "id": 277423900,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648822284
    },
    {
        "content": "<p>(Not every cast has to be rewritten per se. But that's what \"strict provenance\" proposes ‚Äî to minimize any use of permissive provenance)</p>",
        "id": 277424198,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648822418
    },
    {
        "content": "<p>No, that is not what that means. Miri with <code>-Zmiri-tag-raw-pointers</code> is checking a far stricter model of provenance than the strict-provenance feature.</p>\n<p>I cannot see for sure how many crates use an int-to-ptr cast. I can see that 310 crates <em>execute</em> one, then try to deref the pointer. Of those cases, it can only be attributed to a dependency about half of the time, but 112 of those 310 cases can be attributed to <code>bytes</code>. In 124 cases I can't attribute the error to a dependency.</p>",
        "id": 277424765,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648822663
    },
    {
        "content": "<p>There's no rocket science here, I'm just doing ctrl+f on the pages I linked</p>",
        "id": 277424952,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648822738
    },
    {
        "content": "<p>Oh, that‚Äôs pretty approachable actually</p>",
        "id": 277424975,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648822748
    },
    {
        "content": "<p>Miri has some pretty steep biases though, so you should be wary in interpreting these results too much. For example, it's basically useless at assessing platform interface code, which is where Gankra found a lot of squirrely casts in the standard library. There's no reason to believe that we can extrapolate from the crates where we do have results to the crates where we don't.</p>",
        "id": 277425540,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648822983
    },
    {
        "content": "<p>Yeah, Miri has to be taught what given actually-a-syscall APIs mean.</p>",
        "id": 277430636,
        "sender_full_name": "Jubilee",
        "timestamp": 1648825058
    },
    {
        "content": "<p>And yeah, a lot of crates probably actually get fixed if we can push a patch to one major dependency, since Rust is... er... the language that encapsulates unsafe code in safe abstractions</p>",
        "id": 277432029,
        "sender_full_name": "Jubilee",
        "timestamp": 1648825609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277424765\">said</a>:</p>\n<blockquote>\n<p>No, that is not what that means. Miri with <code>-Zmiri-tag-raw-pointers</code> is checking a far stricter model of provenance than the strict-provenance feature.</p>\n</blockquote>\n<p>I disagree. It seems that under <code>-Zmiri-tag-raw-pointers</code>, some ptr-to-int-to-ptr conversions can still be fine. Whereas with strict provenance, <code>*(ptr as usize as ptr)</code> is always illegal.</p>\n<p>So the problem is bigger than it seemed.</p>",
        "id": 277439127,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648828528
    },
    {
        "content": "<p>Note that <code>#[feature(strict_provenance)]</code> itself just <em>provides</em> strict provenance operations, it does not <em>enforce</em> strict provenance</p>",
        "id": 277439313,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648828607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277439127\">said</a>:</p>\n<blockquote>\n<p>It seems that under <code>-Zmiri-tag-raw-pointers</code>, some ptr-to-int-to-ptr conversions can still be fine.</p>\n</blockquote>\n<p>Can you come up with a program that dereferences a pointer from an int-to-ptr cast which passes <code>-Zmiri-tag-raw-pointers</code>?</p>",
        "id": 277440193,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648828935
    },
    {
        "content": "<p>I agree that a few patches may have large impact on the ecosystem, but the tail is very long here, and the rate at which major dependencies take patches like this varies massively.</p>",
        "id": 277440729,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648829160
    },
    {
        "content": "<p>Doesn't something like <code>*(&amp;42 as *const i8 as usize as *const i8)</code> pass Miri?</p>",
        "id": 277440871,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829200
    },
    {
        "content": "<p>Because that would be UB in strict provenance</p>",
        "id": 277440889,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829206
    },
    {
        "content": "<p>I don't think it passes unless an allocation covering address 42 previously had their address leaked.</p>",
        "id": 277440984,
        "sender_full_name": "bjorn3",
        "timestamp": 1648829243
    },
    {
        "content": "<p>Well, that's what I mean. In strict provenance, it's not possible to (usefully) leak an address.</p>",
        "id": 277441062,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829274
    },
    {
        "content": "<p>That code passes Miri <em>without</em> <code>-Zmiri-tag-raw-pointers</code>. With that flag, you get this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">Undefined</span><span class=\"w\"> </span><span class=\"n\">Behavior</span>: <span class=\"nc\">attempting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">untagged</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc954</span><span class=\"p\">[</span><span class=\"mh\">0x0</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">exist</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">borrow</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">location</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">src</span><span class=\"o\">/</span><span class=\"n\">main</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">3</span>:<span class=\"mi\">18</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">42</span><span class=\"k\">i8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                  </span><span class=\"o\">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                  </span><span class=\"n\">attempting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">untagged</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc954</span><span class=\"p\">[</span><span class=\"mh\">0x0</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">exist</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">borrow</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">location</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                  </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">occurs</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc954</span><span class=\"p\">[</span><span class=\"mh\">0x0</span><span class=\"o\">..</span><span class=\"mh\">0x1</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277441158,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648829297
    },
    {
        "content": "<p>How about if <code>42</code> goes in a variable?</p>",
        "id": 277441202,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829317
    },
    {
        "content": "<p>You should try this out for yourself ;)</p>",
        "id": 277441249,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648829342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Are you thinking of PNVI-ae? I don't think Miri has any particular notion of leaking an address.</p>",
        "id": 277441448,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648829415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277440984\">said</a>:</p>\n<blockquote>\n<p>I don't think it passes unless an allocation covering address 42 previously had their address leaked.</p>\n</blockquote>\n<p>I missed the <code>&amp;</code>in <code>&amp;42i8</code>. I thought I saw the address 42 being dereferenced and not a pointer to the value 42.</p>",
        "id": 277441464,
        "sender_full_name": "bjorn3",
        "timestamp": 1648829425
    },
    {
        "content": "<p>ah probably I misunderstood <code>-Zmiri-tag-raw-pointers</code></p>",
        "id": 277442120,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829721
    },
    {
        "content": "<p>Nice. Yes, I support your finding</p>",
        "id": 277442521,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> Is <code>MIRIFLAGS=-Zmiri-tag-raw-pointers cargo miri run</code> something you can run on your codebase?</p>",
        "id": 277445581,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648831200
    },
    {
        "content": "<p>If we just want to locate int-ptr casts I'm sure there is a more effective way than running Miri</p>",
        "id": 277446005,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648831396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277398243\">said</a>:</p>\n<blockquote>\n<p>But if fundamentally Rust doesn't <em>work</em>, then frankly I don't care if it gets adopted, and if we can't write down the rules of unsafe code then arguably Rust does not work.</p>\n</blockquote>\n<p>I don't understand this at all. Rust empirically does work! It massively reduces memory safety problems in the wild.</p>",
        "id": 277446148,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648831454
    },
    {
        "content": "<p>Rust's unsafe code semantics are currently inconsistent (as they're based on LLVM's, which are likewise inconsistent), but that doesn't mean Rust doesn't \"work\". That would imply that nobody should care if Rust as of today gets adopted, because we haven't fixed the problem yet.</p>",
        "id": 277446511,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648831643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277413063\">said</a>:</p>\n<blockquote>\n<p>I don't feel good about redefining the operations. As soon as possible, provide a comprehensive set of fixed and stable alternatives, then deprecate the casts. Propose removing the casts in the 2024 edition. But let them continue to operate as they currently do, and if at all possible let them \"infect\" a codebase with the current underspecified model, even if it means pessimizing certain optimizations for the entire crate graph; avoid the UB outcome.</p>\n</blockquote>\n<p>I'd be fine with this idea.</p>",
        "id": 277447025,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648831873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277446148\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277398243\">said</a>:<br>\nI don't understand this at all. Rust empirically does work! It massively reduces memory safety problems in the wild.</p>\n</blockquote>\n<ol>\n<li>\n<p>It's a hypothetical. No need to be alarmed.</p>\n</li>\n<li>\n<p>People's definitions of \"works\" vary. I think industry's definition of \"works\" is often a lot looser than the definition for people who want to keep improving a language. Some people would say that <code>std::mem::uninitialized</code> \"works\" (under <code>-O0</code>), but we still got rid of it</p>\n</li>\n</ol>",
        "id": 277447506,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648832048
    },
    {
        "content": "<p>Personally I'm in the camp that thinks <code>std::mem::uninitialized</code> didn't work</p>",
        "id": 277447621,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648832104
    },
    {
        "content": "<p>And I think future optimizations were more important than keeping the Rust 1 \"guarantee\" working for <code>std::mem::uninitialized</code></p>",
        "id": 277447804,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648832179
    },
    {
        "content": "<p>To be clear, I'm not proposing compromising memory safety. It would be painful to lose optimizations that LLVM can currently do based on unsound provenance, by adopting something like PNVI-ae-udi without strict aliasing, but if that's what we have to do to remain memory safe then so be it</p>",
        "id": 277447856,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648832200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277446005\">said</a>:</p>\n<blockquote>\n<p>If we just want to locate int-ptr casts I'm sure there is a more effective way than running Miri</p>\n</blockquote>\n<p>Good point, we could just make a trivial lint against that syntax and run <code>crater</code> with that lint forbidden</p>",
        "id": 277449194,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648832801
    },
    {
        "content": "<p>I looked through our internal code for usize-to-pointer casts just now and there are a lot of them.</p>",
        "id": 277449272,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648832841
    },
    {
        "content": "<p>One issue I realized is that it's not just how many there are: it's how hard they are to update. Looking through the strict-provenance APIs, it doesn't seem to be possible to adopt a very localized fix in the same way <code>mem::uninitialized</code> was. You have to know the domain of the program to figure out where provenance comes from, and in the worst case even store the provenance in some kind of data structure so you can use the <code>with_</code> APIs.</p>",
        "id": 277449540,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648832945
    },
    {
        "content": "<p>Thanks! That's important data</p>",
        "id": 277450084,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833194
    },
    {
        "content": "<p>It might be helpful to look at <span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> 's std update PR. My understanding is that most of the updates were local-ish, but you do need to have some understanding of what is going on in the bit of code you are modifying, it's not totally automatic</p>",
        "id": 277450109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833203
    },
    {
        "content": "<p>I think the \"normal\" fix would be to replace the integer type with either a pointer or a union of pointer/integer, but obv. I can't tell how easy/applicable that would be in these contexts. This is also assuming that these casted pointers are actually later dereferenced - if not then nothing really needs to change.</p>",
        "id": 277450121,
        "sender_full_name": "Diggsey",
        "timestamp": 1648833207
    },
    {
        "content": "<p>This sounds like <code>PVI</code> (the opposite of <code>PNVI</code>). My understanding is nobody thinks it can really work in practice</p>",
        "id": 277450318,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833301
    },
    {
        "content": "<p>In large organizations you can have the teams that are responsible for upgrading the compiler, and keeping code running with newer versions, be at some distance from the actual teams maintaining the code.</p>",
        "id": 277450381,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648833331
    },
    {
        "content": "<p>I think Aria said that 80% of uses were only ptr2int with no need for a roundtrip</p>",
        "id": 277450416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833344
    },
    {
        "content": "<p>In the worst case the teams maintaining the code might not even exist anymore‚Ä¶</p>",
        "id": 277450484,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648833363
    },
    {
        "content": "<p>the fact that all of std was converted (or at least triaged) in a few days gives me hope that this can be scaled up, but I don't know your code of course</p>",
        "id": 277450582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833406
    },
    {
        "content": "<p>well that was for strict provenance - a weaker provenance model should require fewer changes</p>",
        "id": 277450644,
        "sender_full_name": "Diggsey",
        "timestamp": 1648833442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277449540\">said</a>:</p>\n<blockquote>\n<p>One issue I realized is that it's not just how many there are: it's how hard they are to update.</p>\n</blockquote>\n<p>Also</p>\n<ul>\n<li>not every Rust programmer is able to tackle this kind of work</li>\n<li>something like pointer compression can't really work with strict-only provenance (but I <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">repeat myself</a>)</li>\n</ul>",
        "id": 277450673,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833464
    },
    {
        "content": "<p>there is a cop-out in strict-only provenance where everything points into one arena. This is how CHERI supports code that can't conform to the capability rules</p>",
        "id": 277450849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833538
    },
    {
        "content": "<p>I echo Patrick that this is very application-dependent, this may not realistically be feasible for some applications. Like something big and hairy like Firefox.</p>",
        "id": 277450854,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450644\">said</a>:</p>\n<blockquote>\n<p>well that was for strict provenance - a weaker provenance model should require fewer changes</p>\n</blockquote>\n<p>Just to be clear, I'm <em>very</em> open to some sort of weaker provenance model that requires few changes. I don't want to sound like I'm opposed to all progress :)</p>",
        "id": 277450874,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648833550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450849\">said</a>:</p>\n<blockquote>\n<p>there is a cop-out in strict-only provenance where everything points into one arena. This is how CHERI supports code that can't conform to the capability rules</p>\n</blockquote>\n<p>Making this easy to use would go a long way toward making it easy to update code.</p>",
        "id": 277450915,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648833584
    },
    {
        "content": "<p>The view <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">in my summary</a> indeed proposes translating the existing primitives to horribly-slow-but-working code for CHERI</p>",
        "id": 277451136,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833685
    },
    {
        "content": "<p>I don't know how that would work for rust, but I believe CHERI has something like this already that allows them to basically plug and play old stuff. But I am no expert on CHERI</p>",
        "id": 277451152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833693
    },
    {
        "content": "<p>My understanding is it's something that would live in the language runtime</p>",
        "id": 277451187,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450915\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277450849\">said</a>:</p>\n<blockquote>\n<p>there is a cop-out in strict-only provenance where everything points into one arena. This is how CHERI supports code that can't conform to the capability rules</p>\n</blockquote>\n<p>Making this easy to use would go a long way toward making it easy to update code.</p>\n</blockquote>\n<p>oh okay.</p>",
        "id": 277451252,
        "sender_full_name": "Jubilee",
        "timestamp": 1648833731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> I'm pretty sure the horribly-slow option is actually unviable (not just slow but actually impossible)</p>",
        "id": 277451255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833733
    },
    {
        "content": "<p>Why?</p>",
        "id": 277451278,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833745
    },
    {
        "content": "<p>so you're saying your price is std::arena, then.</p>",
        "id": 277451304,
        "sender_full_name": "Jubilee",
        "timestamp": 1648833757
    },
    {
        "content": "<p>can do.</p>",
        "id": 277451318,
        "sender_full_name": "Jubilee",
        "timestamp": 1648833764
    },
    {
        "content": "<p>it was brought up <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277361400\">in that thread</a>, it requires you to execute with angelic nondeterminism</p>",
        "id": 277451332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648833773
    },
    {
        "content": "<p>It sounds like we can approach this from both sides:</p>\n<ul>\n<li>have everything disallowed by the weaker provenance model be \"definitely unsupported\"</li>\n<li>have everything allowed by strict provenance be \"definitely supported\"<br>\nAnd then try to keep everything in the middle (that previously worked) working (at least for the foreseeable future)</li>\n</ul>",
        "id": 277451352,
        "sender_full_name": "Diggsey",
        "timestamp": 1648833781
    },
    {
        "content": "<p>I would like to move from \"break&amp;fix the ecosystem\" to \"probably we don't have to break anything in the ecosystem\"</p>",
        "id": 277451596,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648833893
    },
    {
        "content": "<p>I don't think it's necessary to make old code work on CHERI without changes</p>",
        "id": 277451659,
        "sender_full_name": "Diggsey",
        "timestamp": 1648833923
    },
    {
        "content": "<p>unless it's safe code</p>",
        "id": 277451680,
        "sender_full_name": "Diggsey",
        "timestamp": 1648833937
    },
    {
        "content": "<p>and even then some changes may be ok</p>",
        "id": 277451706,
        "sender_full_name": "Diggsey",
        "timestamp": 1648833950
    },
    {
        "content": "<p>oh lol I just realized that's the same thread as this one. keeping up with these threads is becoming a full time job</p>",
        "id": 277451943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451659\">said</a>:</p>\n<blockquote>\n<p>I don't think it's necessary to make old code work on CHERI without changes</p>\n</blockquote>\n<p>I think it's _really preferable_, otherwise either (1) we don't support CHERI fully, or (2) we're dealing with a language fork / compiler option</p>",
        "id": 277452079,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451706\">said</a>:</p>\n<blockquote>\n<p>and even then some changes may be ok</p>\n</blockquote>\n<p>For safe code, doesn't that violate the Rust 1.0 compatibility promise?</p>",
        "id": 277452139,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834116
    },
    {
        "content": "<p>not if there is no old code running on cheri</p>",
        "id": 277452179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834134
    },
    {
        "content": "<p>yeah it's a new platform</p>",
        "id": 277452194,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834140
    },
    {
        "content": "<p>There is no \"if needed to work on CHERI\" exception to the Rust 1.0 compatibility promise.</p>",
        "id": 277452196,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834140
    },
    {
        "content": "<p>That's fair.</p>",
        "id": 277452222,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451304\">said</a>:</p>\n<blockquote>\n<p>so you're saying your price is std::arena, then.</p>\n</blockquote>\n<p>I think it can be a lot better ‚Äî only pointers have to be tracked that had their address exposed with <code>ptr as usize</code>.  Not your average <code>Box</code>.</p>",
        "id": 277452227,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834150
    },
    {
        "content": "<p>right the spirit of the promise is to not break existing code</p>",
        "id": 277452254,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834169
    },
    {
        "content": "<p>And ideally we don't have to fork <code>split</code> into a part that works everywhere and a part that doesn't work on CHERI</p>",
        "id": 277452387,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834214
    },
    {
        "content": "<p>That does mean that we won't be able to do optimizations that assume that code is \"CHERI-clean\".</p>",
        "id": 277452391,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834216
    },
    {
        "content": "<p>right, that would require some kind of split</p>",
        "id": 277452430,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834232
    },
    {
        "content": "<p>I don't think those optimizations are likely to ever happen though</p>",
        "id": 277452496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834257
    },
    {
        "content": "<p>I don't really agree with that tbh...</p>",
        "id": 277452555,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834283
    },
    {
        "content": "<p>even if all rust code went full strict-provenance there is still FFI to consider</p>",
        "id": 277452563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834286
    },
    {
        "content": "<p>but I don't think it's a question we need to answer yet</p>",
        "id": 277452584,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834303
    },
    {
        "content": "<p>maybe we can do the optimizations in restricted circumstances but anything involving \"unknown functions\" will have to be pessimistic regarding strictness</p>",
        "id": 277452743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277451332\">said</a>:</p>\n<blockquote>\n<p>it was brought up <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277361400\">in that thread</a>, it requires you to execute with angelic nondeterminism</p>\n</blockquote>\n<p>Interesting, thanks. If I understand correctly, the conflict is that we can't decide if we need the read-only CHERI ptr for a big chunk of memory, or the read-write ptr for less memory.</p>\n<p>We still have multiple pathways. We could support CHERI but not support read-only pointers. That would get rid of the conflict.</p>",
        "id": 277452882,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277452743\">said</a>:</p>\n<blockquote>\n<p>maybe we can do the optimizations in restricted circumstances but anything involving \"unknown functions\" will have to be pessimistic regarding strictness</p>\n</blockquote>\n<p>Yeah, as I mentioned yesterday this could be a model for interactions between non-strict-provenance Rust functions and strict-provenance Rust functions</p>",
        "id": 277452886,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834426
    },
    {
        "content": "<p>I guess there's always the possibility that we do strict-provenance-based optimizations only on CHERI architectures and leave x86-64 and current ARM/AArch64 alone.</p>",
        "id": 277453026,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834487
    },
    {
        "content": "<p>I don't think anyone loves that possibility, but it is an option.</p>",
        "id": 277453047,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> It's more than that. You can have a whole collection of mutually incomparable valid provenances to access a given location, and no obvious way to pick between them but potential spurious UB later if you pick the wrong one</p>",
        "id": 277453083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> no, it's not to do with whether it's read/write that's just an example. Your solution requires on being able to map an address to a single provenance value, and that is in general impossible, since there may be multiple possible provenances for a given address</p>",
        "id": 277453122,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834543
    },
    {
        "content": "<p>and there isn't a subset/superset relationship on provenances that would allow you to just pick the \"most general\" one</p>",
        "id": 277453247,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834591
    },
    {
        "content": "<p>What could be a conflicting pair?</p>",
        "id": 277453281,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834612
    },
    {
        "content": "<p>at best you can make it so that all pointers have the same provenance, and can read/write anywhere in the exposed address space</p>",
        "id": 277453284,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834613
    },
    {
        "content": "<p>We could also do something horrible on CHERI like make <code>usize as ptr</code> do <code>std::ptr::invalid</code>, and resolve when casting to a reference or when using <code>std::ptr::{read,write}</code></p>",
        "id": 277453513,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834708
    },
    {
        "content": "<p>well, you could have two provenances for address 0x10 that either allow writing to 0x10-0x20 or 0x20-0x30</p>",
        "id": 277453554,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834730
    },
    {
        "content": "<p>I guess you could have one for <code>0x10-0x30</code> and one for <code>0x20-0x40</code>, then <code>0x25</code> is ambiguous so the obvious solution doesn't work indeed</p>",
        "id": 277453692,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834796
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ref1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ref2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ref1</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ref2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>p1</code> and <code>p2</code> have equal value, and if they are exposed then a matching int2ptr could match with either one</p>",
        "id": 277453693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834796
    },
    {
        "content": "<p>To be honest I don't have any objections to even extreme breakage of existing code on CHERI architectures. My compatibility concerns are about existing architectures only.</p>",
        "id": 277453778,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834822
    },
    {
        "content": "<p>well you can't have breakage if there's no existing code</p>",
        "id": 277453807,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834838
    },
    {
        "content": "<p>Right. :)</p>",
        "id": 277453819,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648834849
    },
    {
        "content": "<p>By the way, wouldn't CHERI support merging <code>ref1</code> with <code>ref2</code>?</p>",
        "id": 277453830,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648834856
    },
    {
        "content": "<p>no</p>",
        "id": 277453844,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834863
    },
    {
        "content": "<p>those operations actually decrease the capability</p>",
        "id": 277453877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834876
    },
    {
        "content": "<p><code>ref1</code> only has access to <code>[1, 2]</code></p>",
        "id": 277453902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834886
    },
    {
        "content": "<p>on CHERI you can only reduce the accessible area</p>",
        "id": 277453943,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834913
    },
    {
        "content": "<p>you can't make it bigger</p>",
        "id": 277453953,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834918
    },
    {
        "content": "<p>in stacked borrows it is <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/256\">still under discussion</a> whether this behavior is desirable, but in cheri it's a fact</p>",
        "id": 277454001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648834925
    },
    {
        "content": "<p>so, either you defer mapping until you actually need to read/write the memory (which would make <em>all</em> code prohibitively slow) or you do the arena approach</p>",
        "id": 277454098,
        "sender_full_name": "Diggsey",
        "timestamp": 1648834974
    },
    {
        "content": "<p>I think you're right.</p>\n<p>A third option may be to make <code>ptr</code> contain _two_ machine pointers, one \"current\" one and one \"maximal\" one which represents the whole allocation. Then still only \"permissively exposed\" <code>ptr</code>s need to be tracked.</p>",
        "id": 277454590,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835210
    },
    {
        "content": "<p>Anyway, I'm not sure why strict-provenance optimizations keep getting brought up since they are not in the current proposal and I don't think there has even been any design work on such optimizations</p>",
        "id": 277454594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835212
    },
    {
        "content": "<p>Yeah, half of the point is to be able to just lay the groundwork for making code that is truly coherent under any sane model.<br>\nSorry, but even in the most permissive case, <code>ptr as usize</code> is a sketch operation.</p>",
        "id": 277454697,
        "sender_full_name": "Jubilee",
        "timestamp": 1648835266
    },
    {
        "content": "<p>I think because the original proposal didn't want to exclude any options on principle. IMO it's how <a href=\"https://github.com/rust-lang/rust/issues/95228\">https://github.com/rust-lang/rust/issues/95228</a> was formulated, a bit aggressively</p>",
        "id": 277454763,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835287
    },
    {
        "content": "<p>for now it's just a bunch of \"say what you mean\" library APIs, which can only be a good thing. Maybe someday when these percolate we will be in a better position to propose optimizations, but we can't deprecate a thing until we have an alternative</p>",
        "id": 277454825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835323
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span>, you think we should not support pointer compression in Rust?</p>",
        "id": 277454853,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835340
    },
    {
        "content": "<blockquote>\n<p>A third option may</p>\n</blockquote>\n<p>That is just the arena approach but using more memory for pointers :P You only need to allocate things from the arena if their address is exposed.</p>",
        "id": 277454911,
        "sender_full_name": "Diggsey",
        "timestamp": 1648835367
    },
    {
        "content": "<p>Ah, I thought the arena approach was to keep every live allocation in an arena</p>",
        "id": 277454976,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> I mean that \"as\" is a pretty sketch operation.</p>",
        "id": 277455047,
        "sender_full_name": "Jubilee",
        "timestamp": 1648835414
    },
    {
        "content": "<p>Ah, I agree</p>",
        "id": 277455083,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835430
    },
    {
        "content": "<p><code>ptr.addr()</code> says the correct thing, which is basically<br>\n<code>ptr.get(addr)</code></p>",
        "id": 277455136,
        "sender_full_name": "Jubilee",
        "timestamp": 1648835455
    },
    {
        "content": "<p>I think 100% the _syntax_ <code>ptr as usize</code> and <code>usize as ptr</code> will be deprecated in a version, and we should use a different spelling</p>",
        "id": 277455164,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835469
    },
    {
        "content": "<p>people don't think of pointers as containers but they really basically are.</p>",
        "id": 277455170,
        "sender_full_name": "Jubilee",
        "timestamp": 1648835471
    },
    {
        "content": "<p>Maybe the spelling should be <code>ptr.addr_permissive()</code></p>",
        "id": 277455188,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835481
    },
    {
        "content": "<p>eh.</p>",
        "id": 277455252,
        "sender_full_name": "Jubilee",
        "timestamp": 1648835503
    },
    {
        "content": "<p>I don't really see the problem with pointer compression under any model. In pointer compression you are storing an offset (ie. an integer) instead of a pointer. You just need to make sure that the provenance on your \"base\" pointer has access to the whole space.</p>",
        "id": 277455259,
        "sender_full_name": "Diggsey",
        "timestamp": 1648835504
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 277455287,
        "sender_full_name": "Jubilee",
        "timestamp": 1648835515
    },
    {
        "content": "<p>regarding the bikeshed on that one, I thought about <code>ptr.expose{_addr}()</code> or <code>ptr.broadcast{_addr}()</code></p>",
        "id": 277455397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835548
    },
    {
        "content": "<p><code>expose</code> is probably better since it matches PVNI-a<strong>e</strong> terminology</p>",
        "id": 277455530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835604
    },
    {
        "content": "<p>but it's jargon no matter how you slice it</p>",
        "id": 277455573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835623
    },
    {
        "content": "<p>I guess I mean the model of pointer compression where you don't keep a magic base pointer. Minimal-overhead pointer compression.</p>",
        "id": 277455936,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835775
    },
    {
        "content": "<p>Perhaps everyone uses a base pointer in practice</p>",
        "id": 277455985,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835806
    },
    {
        "content": "<p>the magic base pointer doesn't cause any storage overhead, it's a global resource</p>",
        "id": 277456012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835825
    },
    {
        "content": "<p>I don't know what it would mean to not have a base pointer?</p>",
        "id": 277456024,
        "sender_full_name": "Diggsey",
        "timestamp": 1648835833
    },
    {
        "content": "<p>Basically <code>*((compressed_ptr &lt;&lt; 3) as *T)</code> for reading</p>",
        "id": 277456076,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835856
    },
    {
        "content": "<p>besides, 99% of the time the compression savings come from <em>having</em> a base pointer, since all your pointers are close to each other on the heap</p>",
        "id": 277456103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648835875
    },
    {
        "content": "<p>what type is <code>compressed_ptr</code> htere?</p>",
        "id": 277456201,
        "sender_full_name": "Diggsey",
        "timestamp": 1648835902
    },
    {
        "content": "<p>u32</p>",
        "id": 277456217,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835910
    },
    {
        "content": "<p>And it only works if you can decide which part of the address space is allocated</p>",
        "id": 277456285,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835935
    },
    {
        "content": "<p>Ok, so you are assuming that your whole address space is 0...32GB?</p>",
        "id": 277456325,
        "sender_full_name": "Diggsey",
        "timestamp": 1648835949
    },
    {
        "content": "<p>Yep</p>",
        "id": 277456333,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835956
    },
    {
        "content": "<p>(Maybe nobody does it like this in practice. But it seems <em>slightly</em> more efficient than having a base pointer)</p>",
        "id": 277456373,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648835979
    },
    {
        "content": "<p>In that case I think it is possible for current or near future apis to store the provenance in the compressed pointer itself</p>",
        "id": 277456674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648836059
    },
    {
        "content": "<p>yeah on non-CHERI it can still work fine, but you'd need a 32-bit type with provenance</p>",
        "id": 277456775,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836097
    },
    {
        "content": "<p>You think integers with provenance can work, Mario?</p>",
        "id": 277456781,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836102
    },
    {
        "content": "<p>My understanding is it'd horrible to optimize</p>",
        "id": 277456891,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836127
    },
    {
        "content": "<p>you can store anything in <code>MaybeUninit</code>, the only thing that is missing is a function to smash provenance into a smaller box</p>",
        "id": 277456938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648836157
    },
    {
        "content": "<p>yeah you'd need a special type - in <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> 's current model I believe each byte has it's own provenance, so that wouldn't be an issue</p>",
        "id": 277456956,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836168
    },
    {
        "content": "<p>but it's a bit academic unless you're aware of this actually being used in practice - I don't think most programs have this level of control over their address space</p>",
        "id": 277457103,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836233
    },
    {
        "content": "<p>see <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276733244\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/XorLinkedList.20and.20union.20provenance/near/276733244</a></p>",
        "id": 277457197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648836257
    },
    {
        "content": "<p>on CHERI this wouldn't work without just using an arena, since the area a pointer can access needs to be sufficiently \"near\" to its address AIUI</p>",
        "id": 277457333,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836328
    },
    {
        "content": "<p>You could go even more nuts with this and have a function <code>fn pair(Provenance, Provenance) -&gt; Provenance</code> where <code>Provenance</code> is a one byte type, so that you can construct hyper-pointers with arbitrarily many provenances in a single byte</p>",
        "id": 277457400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648836361
    },
    {
        "content": "<p>but at that point you are just literally programming the AM, the code will look extremely weird for a regular machine</p>",
        "id": 277457607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648836436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277457103\">said</a>:</p>\n<blockquote>\n<p>but it's a bit academic unless you're aware of this actually being used in practice - I don't think most programs have this level of control over their address space</p>\n</blockquote>\n<p>Looks like <a href=\"https://users.rust-lang.org/t/32-bit-pointers-to-the-heap/58255/4\">https://users.rust-lang.org/t/32-bit-pointers-to-the-heap/58255/4</a> is using this exactly (but without compression)</p>",
        "id": 277457697,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836478
    },
    {
        "content": "<p>Found it via <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr\">#t-lang/wg-unsafe-code-guidelines &gt; Use-cases for unrestricted ptr2int2ptr</a> at the top</p>",
        "id": 277457777,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836498
    },
    {
        "content": "<p>yeah, if they're using the \"real address\", then they just need the special 32-bit type with provenance and everything else should just work fine even on CHERI</p>",
        "id": 277457866,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836532
    },
    {
        "content": "<p>ok, maybe not CHERI actually since you can't make pointers shorter</p>",
        "id": 277457902,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836546
    },
    {
        "content": "<p>for what it's worth, CHERI 32-bit exists</p>",
        "id": 277457914,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836550
    },
    {
        "content": "<blockquote>\n<p>It seems to work so far.</p>\n</blockquote>\n<p>It's the C national anthem</p>",
        "id": 277457924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648836555
    },
    {
        "content": "<p>or rather, CHERI with a compression to 64, thus a 32-bit address space.</p>",
        "id": 277457952,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836568
    },
    {
        "content": "<p>Can we fork pointer compression into its own thread, though?</p>",
        "id": 277458002,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836586
    },
    {
        "content": "<p>right, but then you're just using normal pointers :P</p>",
        "id": 277458003,
        "sender_full_name": "Diggsey",
        "timestamp": 1648836586
    },
    {
        "content": "<p>sure but maybe CHERI would support compressed caps on aarch64? idk.</p>",
        "id": 277458109,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836614
    },
    {
        "content": "<p>I only brought up pointer compression to argue that we shouldn't lose permissive provenance</p>",
        "id": 277458136,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836627
    },
    {
        "content": "<p>(as per <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my standpoint/summary</a>)</p>",
        "id": 277458210,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836663
    },
    {
        "content": "<p>I wasn't aware programs actually could control their address space enough to use 32 bits without an \"origin pointer\"</p>",
        "id": 277458219,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836666
    },
    {
        "content": "<p>I think this makes a lot of sense on e.g. microcontrollers where there's only 1 program, but only a small part of the address space is used</p>",
        "id": 277458418,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836748
    },
    {
        "content": "<p>Note that ARM's implementation of CHERI does have a 'default data capability' for backwards compatibility with existing ARM code.</p>",
        "id": 277458458,
        "sender_full_name": "comex",
        "timestamp": 1648836772
    },
    {
        "content": "<p>yeah.</p>",
        "id": 277458486,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836784
    },
    {
        "content": "<p>that's what we've been alluding to as \"basically an arena\"</p>",
        "id": 277458517,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277458418\">said</a>:</p>\n<blockquote>\n<p>I think this makes a lot of sense on e.g. microcontrollers where there's only 1 program, but only a small part of the address space is used</p>\n</blockquote>\n<p>well you get a lot more permission re: provenance if you are also the allocator</p>",
        "id": 277458579,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836826
    },
    {
        "content": "<p>It seems there are multiple viable uses of the word \"arena\" for CHERI</p>",
        "id": 277458603,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836839
    },
    {
        "content": "<p>ish.</p>",
        "id": 277458674,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836858
    },
    {
        "content": "<p>the DDC lets you use \"normal\" load/store within the bounds of the DDC.</p>",
        "id": 277458743,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836894
    },
    {
        "content": "<p>Hmyeah the \"default data capability\" is a pretty sweet concept</p>",
        "id": 277458751,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836896
    },
    {
        "content": "<p>But I can also imagine that automotive wants something safer than that</p>",
        "id": 277458832,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836924
    },
    {
        "content": "<p>Right, you can typically just use pure capabilities.</p>",
        "id": 277458869,
        "sender_full_name": "Jubilee",
        "timestamp": 1648836948
    },
    {
        "content": "<p>(the \"TreeMap\" approach where you only expose individual allocations)</p>",
        "id": 277458883,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648836954
    },
    {
        "content": "<p>If you want to use \"global\" pointer compression with CHERI you'll have to rely on DDC. But I would assume that you'd generally have a base region (e.g. the JavaScript heap)</p>",
        "id": 277458951,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648836972
    },
    {
        "content": "<p>TreeMap breaks security properties though and you can't guess which element is correct.</p>",
        "id": 277459048,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648837029
    },
    {
        "content": "<p>FWIW  for CHERI C, our philosophy is roughly:</p>\n<ul>\n<li>Most code should Just Work<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> (this is true to a somewhat shocking degree)</li>\n<li>Most required modifications should be about clarifying the programmer's intent so provenance can be preserved (hence <code>__builtin_align_down()</code> and <code>ptraddr_t</code>) or removing incorrect assumptions (<code>sizeof size_t == size_of void *</code>)</li>\n<li>It should be possible for programmers without access to CHERI to write code that works on CHERI (perhaps with the aid of warnings and static analysis)</li>\n<li>We're ok with a few idioms breaking completely (e.g., XOR linked lists, round tripping pointers though <code>printf</code>/<code>scanf</code>)<br>\nOne the whole we want to transition to pure-capability code is be no worse that 32-bit -&gt; 64-bit. Ideally we'll make it better.</li>\n</ul>",
        "id": 277459116,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648837062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"473929\">Alexander Richardson</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277459048\">said</a>:</p>\n<blockquote>\n<p>TreeMap breaks security properties though and you can't guess which element is correct.</p>\n</blockquote>\n<p>I don't necessarily agree (yet), but we're also veering from the topic. I think we agree that we want to keep supporting permissive provenance, also on CHERI.</p>",
        "id": 277459541,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648837220
    },
    {
        "content": "<p>I'd be happier with just disabling the permissive casts for CHERI. There isn't really a sane way of implementing them safely.</p>",
        "id": 277459764,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648837317
    },
    {
        "content": "<p>This would fork the language</p>",
        "id": 277459890,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648837361
    },
    {
        "content": "<p>I think it's better as an (allow-by-default) lint</p>",
        "id": 277459969,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648837386
    },
    {
        "content": "<p>I would like there to be Rust, not Normal Rust vs. CHERI Rust</p>",
        "id": 277460238,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648837487
    },
    {
        "content": "<p>And I think the ecosystem will move so that only <em>very</em> niche crates will use permissive provenance any more</p>",
        "id": 277460310,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648837526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277458458\">said</a>:</p>\n<blockquote>\n<p>Note that ARM's implementation of CHERI does have a 'default data capability' for backwards compatibility with existing ARM code.</p>\n</blockquote>\n<p>The compatibility that comes from DDC is fundamental to the CHERI design. We're quite aware that no one would ever adopt this (at least on general purpose CPUs)  if they had to move 100% of their code to pure-capability CHERI from day one so we aim for complete compatibility with aarch64/riscv64 until you start using capabilities.<br>\nOn we support two C environments: hybrid C where DDC covers the address space and pointers are integers unless annotated otherwise and pure-capability  (CheriABI) where DDC is NULL and all pointers have strict provenance. In the latter case, initial capabilities come from the kernel via the initial register set and transitively though the ELF auxargs vector to <code>argv</code> and <code>envv</code>. Additional capabilities come from <code>mmap</code> and <code>shmat</code>.</p>",
        "id": 277460761,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648837737
    },
    {
        "content": "<p>And the DDC is, in terms of \"provenance alone\", without recourse to CHERI's physical manifestation of provenance, almost exactly analogous to creating an arena, holding a pointer to it, and then regenerating provenance from it.</p>",
        "id": 277460839,
        "sender_full_name": "Jubilee",
        "timestamp": 1648837781
    },
    {
        "content": "<p>Yes, I think there have been some uses to DDC specifically for that purpose in an otherwise pure-capability environment (maybe in the webkit port).</p>",
        "id": 277461011,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648837851
    },
    {
        "content": "<p>...you know, we could allow overriding the global allocator in a way that follows that logic.</p>",
        "id": 277461070,
        "sender_full_name": "Jubilee",
        "timestamp": 1648837873
    },
    {
        "content": "<p>Or well, not quite overriding.</p>",
        "id": 277461127,
        "sender_full_name": "Jubilee",
        "timestamp": 1648837897
    },
    {
        "content": "<p>I think there's a big difference.</p>\n<ul>\n<li>DDC negates the use of strict-provenance casts; there is <del>no</del> hardly any extra CHERI safety</li>\n<li>With a big arena pointer <em>outside of DDC</em>, strict-provenance makes a lot of sense. But you could also still use that one weird crate that refuses to update to strict-provenance</li>\n</ul>",
        "id": 277461315,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648837961
    },
    {
        "content": "<p>Yeah one of the ideas I floated at the start of this was an allocator that was capable of ptr-to-int shenanigans. But that interacts weirdly with provenance so not too sure how fun it is.</p>",
        "id": 277461340,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648837974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277459890\">said</a>:</p>\n<blockquote>\n<p>This would fork the language</p>\n</blockquote>\n<p>Strict Provenance doesn't fork the language. It's not like we have two incompatible variants here, it's a subset: you can have high standards or low standards and you can freely choose which one you find appropriate. CHERI can only run code with high standards</p>",
        "id": 277461606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838099
    },
    {
        "content": "<p>We already have plenty of this with e.g. clippy lints and rustfmt</p>",
        "id": 277461686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838148
    },
    {
        "content": "<p>How is this better than making all code work on CHERI?</p>",
        "id": 277461697,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648838155
    },
    {
        "content": "<p>We don't have to use DDC for that.</p>",
        "id": 277461744,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648838164
    },
    {
        "content": "<p>\"Strict Provenance\" has multiple meanings. I'm against the \"break the world\" interpretation of <a href=\"https://github.com/rust-lang/rust/issues/95228\">https://github.com/rust-lang/rust/issues/95228</a>, but for adding all the benefits as per <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my standpoint</a> and migrating the ecosystem over voluntarily</p>",
        "id": 277462120,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648838343
    },
    {
        "content": "<p>I did not see \"break the world\" anywhere on that PR</p>",
        "id": 277462189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838380
    },
    {
        "content": "<p>Nothing was actively broken by that effort.<br>\nWhat was done was something that unfortunately was doomed to get hilarious pushback, <strong>no matter how mildly phrased</strong>, because people catastrophize in response to the very idea.</p>",
        "id": 277462406,
        "sender_full_name": "Jubilee",
        "timestamp": 1648838485
    },
    {
        "content": "<p>Making the permissive casts an error for Cheri targets would make it extremely easy to find all lines of code that need adjustments at compile time. This is an infinite improvement over C/C++ where we sometimes only notice the problems at runtime.</p>",
        "id": 277462454,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648838520
    },
    {
        "content": "<p>strict provenance casts are useful even with DDC, because pointers are still 128 bits (I think) so <code>with_addr</code> is needed to copy the other bits</p>",
        "id": 277462502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838529
    },
    {
        "content": "<blockquote>\n<p>This is an unofficial experiment to see How Bad it would be if Rust had <strong>extremely strict pointer provenance rules that require you to always dynamically preserve provenance information.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>I'm reading this, and I think multiple people are reading this as \"we modify the provenance rules to be more strict\". It doesn't say \"what if we had more operations\"</p>",
        "id": 277462532,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648838552
    },
    {
        "content": "<p>I realize that.</p>",
        "id": 277462556,
        "sender_full_name": "Jubilee",
        "timestamp": 1648838568
    },
    {
        "content": "<p>I believe the actual process was that they implemented a lint to point out such uses and fixed them</p>",
        "id": 277462619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838605
    },
    {
        "content": "<p>Correct.</p>",
        "id": 277462634,
        "sender_full_name": "Jubilee",
        "timestamp": 1648838615
    },
    {
        "content": "<p>The original PR included a lint, the API was separated out when it became clear we wanted to carry through with the experiment.</p>",
        "id": 277462668,
        "sender_full_name": "Jubilee",
        "timestamp": 1648838641
    },
    {
        "content": "<p>so it's not \"breakage\" so much as \"warnage\"</p>",
        "id": 277462724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838653
    },
    {
        "content": "<p>and it would probably be allow-by-default in any possible future where this lands, at least for the current edition</p>",
        "id": 277462757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838680
    },
    {
        "content": "<p>There's no reason to not warn by default for such a lint. If you're using it so much it matters just disable it at the crate level (and code readers will see you disabled the lint and know what's up).</p>",
        "id": 277463065,
        "sender_full_name": "Lokathor",
        "timestamp": 1648838875
    },
    {
        "content": "<p>I realize you may be more new-ish to this conversation, but many programmers who are following the Rust unsafe conversation and are deeply interested in writing correct code, are also aware of the <strong>many</strong> issues with <code>ptr as usize</code> and such, and aware of how... poor it is, as a model. And they really, really want to be able to write code that doesn't have this \"well, I GUESS it works\" standard underlying it.</p>",
        "id": 277463223,
        "sender_full_name": "Jubilee",
        "timestamp": 1648838956
    },
    {
        "content": "<p>I would put this under future-incompatibility and make it warn by default only after we are committed to deprecating it</p>",
        "id": 277463269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648838993
    },
    {
        "content": "<p>getting this experiment merged in nightly is not such a commitment AFAIK</p>",
        "id": 277463346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648839029
    },
    {
        "content": "<p>this would need an RFC</p>",
        "id": 277463365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648839039
    },
    {
        "content": "<p>But people conflate making new, Actually Sound code possible with Instantly Miscompiling Old Code.</p>",
        "id": 277463378,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839048
    },
    {
        "content": "<p>And then you suddenly have to argue why the current standard isn't good enough.</p>",
        "id": 277463414,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839065
    },
    {
        "content": "<p>And this whole thing started because <span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> actually <a href=\"https://gankra.github.io/blah/fix-rust-pointers/\">did that</a></p>",
        "id": 277463623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648839161
    },
    {
        "content": "<p>it's very helpful to have a coherent document to point to to explain these things</p>",
        "id": 277463688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648839200
    },
    {
        "content": "<p>And yes,<br>\nit would be nice to be able to use a new, actually sound standard for a few opts!</p>",
        "id": 277463920,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839306
    },
    {
        "content": "<p>And it's exhausting to have people tell you that such must definitely be off the table, when you're thinking about like<br>\nRust 2030<br>\nRust 2060</p>",
        "id": 277464004,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839362
    },
    {
        "content": "<p>Yes, I am thinking about Rust 2060. No joke. Not an exaggeration.</p>",
        "id": 277464077,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839393
    },
    {
        "content": "<p>Not about \"when to implement an opt or a lint\", but \"what should we care about when designing new stuff for Rust?\"</p>",
        "id": 277464203,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839478
    },
    {
        "content": "<p>I am thinking about the next 1 billion programmers. Not just Rust programmers, but the ecosystem we can create for everyone else.</p>",
        "id": 277464676,
        "sender_full_name": "Jubilee",
        "timestamp": 1648839692
    },
    {
        "content": "<p>I updated my <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">summary post</a>.</p>\n<blockquote>\n<p>Clarify the TreeMap/collection approach (\"option 1\"); add possibility for an arena pointer on CHERI (\"option 2\"). Additionally, propose aliases for ptr as usize and usize as ptr that don't use the as keyword, and deprecating the spelling with as. Mention the \"pointer in u32\" use case.</p>\n</blockquote>",
        "id": 277466599,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648840755
    },
    {
        "content": "<p>And it's important, I think, to note:</p>\n<p>People in 2015, back around 1.0, were aware of a lot of the decisions they were about to make were going to make were perhaps... not the best, and these issues were raised. The entire story of why we have <code>usize</code> and <code>isize</code> instead of, say, <code>uptr</code> and <code>iptr</code> is that. A decision was made to do exactly what is happening now: pick a model, indeed, arguably the simplest model, over simplistic, and try to make it happen and carve out an exception in the stability promise <strong>precisely so</strong> for if they got it wrong.</p>\n<p>Now the verdict is in.</p>",
        "id": 277467019,
        "sender_full_name": "Jubilee",
        "timestamp": 1648840999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277464676\">said</a>:</p>\n<blockquote>\n<p>I am thinking about the next 1 billion programmers. Not just Rust programmers, but the ecosystem we can create for everyone else.</p>\n</blockquote>\n<p>^^ this. And in a similar vein, I would like to point out that for the purpose of this conversation, LLVM is not always that relevant a point. It is of course important that we can lower MIR to LLVM IR soundly (to the extent that is well-defined), but I don't think we should ever be using \"well LLVM is already broken\" or \"LLVM can't do these opts anyway\" as a reason. If Rust is (or becomes) as awesome as we're all trying to make it, I think we have to realize that we will eventually eg have significant influence in what LLVM supports, or have powerful optimization frameworks that are tailored specifically to Rust. Wasting the amazing things that could come from that would be quite unfortunate</p>",
        "id": 277467148,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648841064
    },
    {
        "content": "<p>And it's worth adding that we're already at a point where both the cranelift and gccjit backends are functional enough to compile real code, so even today we're not exclusively tied to the LLVM backend</p>",
        "id": 277468380,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648841858
    },
    {
        "content": "<p>My perspective is different: if not for CHERI, I would think strict provenance is a compromise, an unnecessarily restrictive ruleset used because the Rust project doesn't have enough bandwidth to have someone spend enough time hacking on compiler optimizations to figure out how hard it would be to do a less restrictive one soundly.</p>",
        "id": 277470312,
        "sender_full_name": "comex",
        "timestamp": 1648843053
    },
    {
        "content": "<p>CHERI does make me more sympathetic to strict provenance though.</p>",
        "id": 277470393,
        "sender_full_name": "comex",
        "timestamp": 1648843100
    },
    {
        "content": "<p>But yeah, I see it less as \"getting it right\" and more as \"giving up\".</p>",
        "id": 277470472,
        "sender_full_name": "comex",
        "timestamp": 1648843145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277470312\">said</a>:</p>\n<blockquote>\n<p>My perspective is different: if not for CHERI, I would think strict provenance is a compromise, an unnecessarily restrictive ruleset used because the Rust project doesn't have enough bandwidth to have someone spend enough time hacking on compiler optimizations to figure out how hard it would be to do a less restrictive one soundly.</p>\n</blockquote>\n<p>It's not an optimization problem; before we can even begin to talk about those, we need a memory model to write them against, and Ralf - the one person who definitely has done a huge amount of work on trying to find a memory model that works for Rust - says that he doesn't see how it's possible.</p>",
        "id": 277470772,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648843280
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> What's wrong with Stacked Borrows as is? Do you have a pointer/link?</p>",
        "id": 277470901,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648843346
    },
    {
        "content": "<p>Sorry, I meant that it is my impression that <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> said that he can't figure out how to do non-strict provenance with stacked borrows</p>",
        "id": 277471071,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648843448
    },
    {
        "content": "<p>My understanding was that there's simply a bunch still to be defined. For instance, transmutes from ptr (which should probably be UB, it seems now).</p>\n<p>But if he said it that directly, then fair enough</p>",
        "id": 277471171,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648843517
    },
    {
        "content": "<p>Ralf says it's not possible without being unable to remove dead stores and dead loads.  Which is a very valid point.  But it's also overly simplistic, because even if you can't literally remove them at the IR level, you can still turn them into some kind of marker which doesn't produce any machine code but constrains future optimizations.  Now, if it constrains future optimizations too much, then that's still a non-workable outcome.  But it may be possible to keep most of the optimization potential by carefully taking these markers into account.  I don't know.</p>",
        "id": 277471382,
        "sender_full_name": "comex",
        "timestamp": 1648843628
    },
    {
        "content": "<p>Alternately, it may be possible to make a model work where integers do have provenance (PVI), which removes most of the hard parts of PNVI at the cost of making other things hard.</p>",
        "id": 277471452,
        "sender_full_name": "comex",
        "timestamp": 1648843672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471171\">said</a>:</p>\n<blockquote>\n<p>My understanding was that there's simply a bunch still to be defined. For instance, transmutes from ptr (which should probably be UB, it seems now).</p>\n<p>But if he said it that directly, then fair enough</p>\n</blockquote>\n<p>So 1) that's not exactly a SB issue, but a more general memory model issue. 2) \"Still to be defined\" is one way of putting it - as I understand it, the reason that things like integer to pointer casts are not defined is because we have no idea how to define them in a workable way. I'll try and let Ralf speak for himself though when he gets back</p>",
        "id": 277471622,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648843742
    },
    {
        "content": "<p>(In particular, the biggest obstacles to PVI I've seen are: 1. You can't do global value numbering ‚Äî but really, it's only certain types of GVN-ish optimizations you can't do, and even those can still be performed on any integer you are sure doesn't come from a pointer.  2. Issues with things like <code>x - x</code> not being optimizable to <code>0</code> because they still carry provenance ‚Äî 'just' say that mangling the value drops the provenance.)</p>",
        "id": 277471945,
        "sender_full_name": "comex",
        "timestamp": 1648843911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471382\">said</a>:</p>\n<blockquote>\n<p>Ralf says it's not possible without being unable to remove dead stores and dead loads.</p>\n</blockquote>\n<p>You mean something like <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> ?</p>\n<p>In my understanding, we can do such optimizations fine in Stacked Borrows + strict provenance functions, just not anywhere near <code>ptr as usize</code> / <code>broadcasting_ptr2int</code> . Details: <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277320814</a></p>",
        "id": 277472532,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648844239
    },
    {
        "content": "<p>No, I don't think those are related. Not being able to remove dead stores is an issue that comes up if you allow ptr to int transmutes to implicitly broadcast</p>",
        "id": 277472697,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844335
    },
    {
        "content": "<p>And, because Rust does not have typed memory/strict aliasing, every store to a type that is not a pointer is potentially such a store. So basically this means we can eliminate no dead stores except if the type is a pointer</p>",
        "id": 277472765,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471945\">said</a>:</p>\n<blockquote>\n<p>(In particular, the biggest obstacles to PVI I've seen are: 1. You can't do global value numbering ‚Äî but really, it's only certain types of GVN-ish optimizations you can't do, and even those can still be performed on any integer you are sure doesn't come from a pointer.  2. Issues with things like <code>x - x</code> not being optimizable to <code>0</code> because they still carry provenance ‚Äî 'just' say that mangling the value drops the provenance.)</p>\n</blockquote>\n<p>Let's open a new thread for this actually</p>",
        "id": 277472829,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844413
    },
    {
        "content": "<p>I believe there is consensus that pointer-to-int <strong>transmute</strong> cannot work and has to break. Even though pointer-to-int <em>conversions</em> like <code>ptr as usize</code> would still work. And we believe that very little code in practice uses such transmutes</p>",
        "id": 277472874,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648844449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277472874\">said</a>:</p>\n<blockquote>\n<p>I believe there is consensus that pointer-to-int <strong>transmute</strong> cannot work and has to break. Even though pointer-to-int <em>conversions</em> like <code>ptr as usize</code> would still work. And we believe that very little code in practice uses such transmutes</p>\n</blockquote>\n<p>I think there's no such consensus. I pointed out a way that the transmutes could actually work (just not broadcast), and someone on the issue said they believed that the transmutes are actually common enough to be a problem</p>",
        "id": 277473168,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844591
    },
    {
        "content": "<p>currently there's things like tearor/bytemuck (where bytemuck removed Pod impls for pointers because of the discussion iirc)</p>",
        "id": 277473217,
        "sender_full_name": "Talchas",
        "timestamp": 1648844622
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> I think there are other reasons to prefer strict provenance: namely simplicity. In that respect, it's the other models that are compromises between something that won't break too much code, vs what will allow us to keep most of our optimizations. If we were starting from scratch with no existing code, then IMO strict provenance is clearly the better model.</p>",
        "id": 277473296,
        "sender_full_name": "Diggsey",
        "timestamp": 1648844650
    },
    {
        "content": "<p>(though tearor/atomiccell/etc could certainly certainly just use AtomicPtr for anything pointer sized)</p>",
        "id": 277473300,
        "sender_full_name": "Talchas",
        "timestamp": 1648844652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473217\">said</a>:</p>\n<blockquote>\n<p>currently there's things like tearor/bytemuck (where bytemuck removed Pod impls for pointers because of the discussion iirc)</p>\n</blockquote>\n<p>Yes; it would be interesting to see what code actually made use of that</p>",
        "id": 277473331,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844674
    },
    {
        "content": "<p>but if it's not better for users and maybe not better for compilers (given FFI exists), what benefit is the nicer model</p>",
        "id": 277473375,
        "sender_full_name": "Talchas",
        "timestamp": 1648844694
    },
    {
        "content": "<p>Given that bytemuck's pod impl is not really \"using\" ptr to int transmutes so much as letting other people use them</p>",
        "id": 277473386,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473375\">said</a>:</p>\n<blockquote>\n<p>but if it's not better for users and maybe not better for compilers (given FFI exists), what benefit is the nicer model</p>\n</blockquote>\n<p>I think model simplicity is necessarily a benefit to users. Whether this benefit is a worthwhile tradeoff with the additional DB that you get from other models is of course more complicated</p>",
        "id": 277473484,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844761
    },
    {
        "content": "<blockquote>\n<p>I believe there is consensus that pointer-to-int transmute cannot work and has to break. </p>\n</blockquote>\n<p>Well, the outcome I'm thinking of is one where it broadcasts.  This is (at least in part) what creates the problems with dead loads and dead stores.  Though, Ralf had another test case which is supposed to show another problem with pointer-to-int transmute, but I don't really understand what it's meant to demonstrate.</p>",
        "id": 277473539,
        "sender_full_name": "comex",
        "timestamp": 1648844774
    },
    {
        "content": "<p>(having strict variants of <code>ptrtoint</code> is likely valuable, but it seems unlikely for compilers to be able to take advantage of a global lack of them, because FFI/extern code still exists)</p>",
        "id": 277473556,
        "sender_full_name": "Talchas",
        "timestamp": 1648844783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473539\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I believe there is consensus that pointer-to-int transmute cannot work and has to break. </p>\n</blockquote>\n<p>Well, the outcome I'm thinking of is one where it broadcasts.  This is (at least in part) what creates the problems with dead loads and dead stores.  Though, Ralf had another test case which is supposed to show another problem with pointer-to-int transmute, but I don't really understand what it's meant to demonstrate.</p>\n</blockquote>\n<p>I mean, pointer to int transmutes broadcasting means that it is unsound for an optimization to remove any move/copy that is not of a pointer type</p>",
        "id": 277473680,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844848
    },
    {
        "content": "<p>That seems very bad</p>",
        "id": 277473699,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844856
    },
    {
        "content": "<p>Does it make the model simpler to reason about than the non-strict model when you are never doing a ptrtoint, or is the complexity entirely/nearly entirely in the ptrtoint/inttoptr operations?</p>",
        "id": 277473813,
        "sender_full_name": "Talchas",
        "timestamp": 1648844903
    },
    {
        "content": "<p>And it's not really recoverable by inserting <code>broadcast_value(...);</code> statements either, for reasons that I can explain (if no one else has) once I am back from this scheduled break</p>",
        "id": 277473818,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844906
    },
    {
        "content": "<p>Sure, explain it.</p>",
        "id": 277473854,
        "sender_full_name": "comex",
        "timestamp": 1648844925
    },
    {
        "content": "<p>because it certainly is my impression that the english description of the model is about the same</p>",
        "id": 277473857,
        "sender_full_name": "Talchas",
        "timestamp": 1648844927
    },
    {
        "content": "<p>(the math model I'm sure winds up with more boilerplate because you can't say \"if every possible choice of provenance will cause UB, then this is UB\", you have to actually write that out)</p>",
        "id": 277474038,
        "sender_full_name": "Talchas",
        "timestamp": 1648845020
    },
    {
        "content": "<p>but if it means you can throw out entire possible states in the borrow stack or something, then you are actually gaining some simplicity</p>",
        "id": 277474087,
        "sender_full_name": "Talchas",
        "timestamp": 1648845062
    },
    {
        "content": "<p>(you regardless gain some simplicity in the sense that \"library code you need to understand has fewer operations available to it\" but that is a very different thing)</p>",
        "id": 277474143,
        "sender_full_name": "Talchas",
        "timestamp": 1648845103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473296\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> I think there are other reasons to prefer strict provenance: namely simplicity. In that respect, it's the other models that are compromises between something that won't break too much code, vs what will allow us to keep most of our optimizations. If we were starting from scratch with no existing code, then IMO strict provenance is clearly the better model.</p>\n</blockquote>\n<p>Maybe.  I think there is a concern that we don't have a good story for things like memory allocators and garbage collectors.  I thought this was more of a Stacked Borrows problem, but really it is a strict provenance problem to some extent, since strict provenance special-cases the allocator as handing out freshly-provenanced chunks of memory (otherwise you can't use provenance to justify noalias), and then it's unclear what rules the allocator itself has to follow.</p>",
        "id": 277474412,
        "sender_full_name": "comex",
        "timestamp": 1648845269
    },
    {
        "content": "<p>Really. My hunch is allocators fit into Stacked Borrows. But <code>free</code> would need to be defined obviously.</p>",
        "id": 277475064,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648845611
    },
    {
        "content": "<p>I tweaked <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my standpoint</a> to forbid pointer-to-int transmutes.</p>\n<p>But if there really are important places where people have to use pointer-to-int transmutes, we can consider it. It seems we have a choice of that, or keeping backwards compatibility with a lot of permissive-provenance code, but not both.</p>",
        "id": 277475203,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648845708
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> I agree there are some unresolved questions, but they do seem quite solvable. For example: what would an allocator look like in CHERI? Well, you'd take a pointer with access to a large slab of memory, and then you create smaller pointers from that, and give them out to the application. In \"free\" you'll again be starting from your pointer to the slab of memory, and use the offset within that of the pointer you're given to modify some data structures. I think a similar layered approach works for the provenance model itself.</p>",
        "id": 277475464,
        "sender_full_name": "Diggsey",
        "timestamp": 1648845858
    },
    {
        "content": "<p>So the malloc implementation follows exactly the same provenance rules, it just lives at a different layer.</p>",
        "id": 277475572,
        "sender_full_name": "Diggsey",
        "timestamp": 1648845943
    },
    {
        "content": "<p>If we're searching for a clear / easy-to-understand execution model, then between Stacked Borrows (allows permissive provenance) and something that allows ptr-to-int transmute, I think actually both would be very complicated.</p>\n<p>(For the second one: <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F\">#t-lang/wg-unsafe-code-guidelines &gt; Problems with PVI - What optimizations does it break?</a> )</p>",
        "id": 277476531,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648846541
    },
    {
        "content": "<p>yeah, SB's baseline complexity is high, and as far as I've heard strict provenance wouldn't let you rip out any of the complexity of the raw pointer handling parts</p>",
        "id": 277477720,
        "sender_full_name": "Talchas",
        "timestamp": 1648847237
    },
    {
        "content": "<p>(ptrtoint transmutes shouldn't have much addition to the model or programmer difficulty; compiler difficulty is the problem there)</p>",
        "id": 277477899,
        "sender_full_name": "Talchas",
        "timestamp": 1648847321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"295632\">@Diggsey</span> You might be right, but there is a problem with layering it: What is stopping the allocator from keeping a backup pointer of literally all the memory it hands out, and then accessing the memory whenever it wants?  From a CHERI perspective, nothing; it's fine (but not very secure) to do that.  But from a compiler perspective, that's like allowing unrestricted <code>int2ptr</code> without even having to do a <code>ptr2int</code> first.  So it must be disallowed.  Makes sense - the allocator shouldn't be mucking with memory it handed out.  But what about things like metadata, or what about garbage collectors that actually do want to access the contents of allocations sometimes?  You could say these questions are all in the Stacked Borrows category rather than the strict-provenance category, but they're not truly that separate: from a compiler perspective, the whole point of provenance is to make aliasing assumptions.</p>",
        "id": 277477948,
        "sender_full_name": "comex",
        "timestamp": 1648847352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473296\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> I think there are other reasons to prefer strict provenance: namely simplicity. In that respect, it's the other models that are compromises between something that won't break too much code, vs what will allow us to keep most of our optimizations. If we were starting from scratch with no existing code, then IMO strict provenance is clearly the better model.</p>\n</blockquote>\n<p>This is something I'm unsure about. The advantage of a weak provenance model is that programmers don't have to think about it as much and things generally work when you pretend that memory is just a bag of bytes with integer addresses. Yes, I know there are lots of test cases in which this assumption breaks, but in general it works. That's why C++ has been so successful.</p>",
        "id": 277477958,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847359
    },
    {
        "content": "<ul>\n<li>Though, to be fair, provenance-based aliasing assumptions are mostly (not entirely) for stack memory, while garbage collectors mostly (not entirely) care about the heap.  But the stack does have to be allocated somewhere.</li>\n</ul>",
        "id": 277478129,
        "sender_full_name": "comex",
        "timestamp": 1648847476
    },
    {
        "content": "<p>Now if you introduce strict provenance, then programmers have to keep provenance at the top of their mind all the time, or risk UB (or outright breakage on CHERI). This allows the programmers who have mastered the idea of provenance to use that to write correct code, which is great. But it also adds complexity to the <em>mental</em> model (though not the underlying formalism).</p>",
        "id": 277478130,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847476
    },
    {
        "content": "<p>Note that I'm genuinely conflicted here! I see the advantages of both sides.</p>",
        "id": 277478165,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> I guess the difference is that the compiler is relying on the contract of malloc, and it's up to the implementation to fulfill that contract. This leaves a gap in what a tool like MIRI could check, so to check this, you'd need additional rules in MIRI to check that the implementation does in fact fulfill its contract, and these would be specific rules for malloc/free.</p>",
        "id": 277478235,
        "sender_full_name": "Diggsey",
        "timestamp": 1648847528
    },
    {
        "content": "<p>IOW I don't have the right answer here. But I do think that explicit provenance is a tradeoff even without the constraint of backwards compatibility with existing code.</p>",
        "id": 277478274,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847555
    },
    {
        "content": "<p>ie. that the implementation doesn't randomly write to areas which it has handed out</p>",
        "id": 277478292,
        "sender_full_name": "Diggsey",
        "timestamp": 1648847561
    },
    {
        "content": "<p>no one actually \"pretends that memory is just a bag of bytes with integer addresses\" tho' because if they do their programs segfault. they tend to act in a fairly well-behaved manner, even when they're committing crimes.</p>",
        "id": 277478358,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> Having provenance is certainly more complicated to the programmer than not having it, but I do think that strict provenance is easier to understand <em>if you're going to have provenance at all</em></p>",
        "id": 277478365,
        "sender_full_name": "Diggsey",
        "timestamp": 1648847620
    },
    {
        "content": "<p>And the reason that a stricter model is simpler is because the pretense that provenance doesn't exist is a very leaky abstraction.</p>",
        "id": 277478431,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478358\">said</a>:</p>\n<blockquote>\n<p>no one actually \"pretends that memory is just a bag of bytes with integer addresses\" tho' because if they do their programs segfault. they tend to act in a fairly well-behaved manner, even when they're committing crimes.</p>\n</blockquote>\n<p>Most C++ programmers do and their programs work.</p>",
        "id": 277478459,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478431\">said</a>:</p>\n<blockquote>\n<p>And the reason that a stricter model is simpler is because the pretense that provenance doesn't exist is a very leaky abstraction.</p>\n</blockquote>\n<p>It's not really a leaky abstraction in practice.</p>",
        "id": 277478475,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847691
    },
    {
        "content": "<p>They don't, lol.</p>",
        "id": 277478478,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847696
    },
    {
        "content": "<p>If you truly try to write to random addresses, you die on virtual memory.</p>",
        "id": 277478526,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847739
    },
    {
        "content": "<p>There are a lot of provenance-derived rules that C++ programmers follow so that they don't need to understand that provenance exists, and if they follow those rules, then things mostly work...</p>",
        "id": 277478601,
        "sender_full_name": "Diggsey",
        "timestamp": 1648847765
    },
    {
        "content": "<p>I'm not talking about writing to memory you didn't allocate. I'm talking about treating pointers and integers as interchangeable.</p>",
        "id": 277478604,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847766
    },
    {
        "content": "<p>Writing to memory you didn't allocate versus not is in fact what we are talking about tho'</p>",
        "id": 277478632,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847786
    },
    {
        "content": "<p>that is literally the property that differentiates those integers</p>",
        "id": 277478637,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847795
    },
    {
        "content": "<p>Yeah allocators and provenance has been an issue for as long as time itself. Rust's allocator API (the unstable one) I don't think actually deals with provenance at all iirc.</p>",
        "id": 277478666,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648847813
    },
    {
        "content": "<p>but even wrote learning those rules is much more complicated than strict provenance, and it still doesn't protect you completely</p>",
        "id": 277478674,
        "sender_full_name": "Diggsey",
        "timestamp": 1648847820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277475464\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> I agree there are some unresolved questions, but they do seem quite solvable. For example: what would an allocator look like in CHERI? Well, you'd take a pointer with access to a large slab of memory, and then you create smaller pointers from that, and give them out to the application. In \"free\" you'll again be starting from your pointer to the slab of memory, and use the offset within that of the pointer you're given to modify some data structures. I think a similar layered approach works for the provenance model itself.</p>\n</blockquote>\n<p>The basic list of things a CHERI-aware allocator does are:</p>\n<ul>\n<li>Round up the size of allocations so they are representable given compressed bounds</li>\n<li>Allocate from some sort of slab of memory (in practice on Unix allocated by <code>mmap</code>) and set bounds appropriately</li>\n<li>Provide a mechanism to get from the pointer passed to \"free\" back to the allocator's internal data structures without relying on anything but the address (some malloc's already do this, some like dlmalloc provide no efficient mechanism)</li>\n</ul>",
        "id": 277478685,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648847825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478235\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> I guess the difference is that the compiler is relying on the contract of malloc, and it's up to the implementation to fulfill that contract. This leaves a gap in what a tool like MIRI could check, so to check this, you'd need additional rules in MIRI to check that the implementation does in fact fulfill its contract, and these would be specific rules for malloc/free.</p>\n</blockquote>\n<p>Sure, but there are questions that are more subtle than \"don't randomly write to allocations\", and my point is: if you want to reason about what the allocator is allowed to do, it's more complicated than just handing out chunks of provenance.  Maybe this is orthogonal to random integer-pointer casts.  Except not really, since allocators tend to do a lot of integer-pointer casts :)</p>",
        "id": 277478720,
        "sender_full_name": "comex",
        "timestamp": 1648847850
    },
    {
        "content": "<p>As a program evolves over time, allocating and deallocating memory, the same integer, cast to a pointer, can be a legal or an illegal pointer to use.</p>",
        "id": 277478721,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847850
    },
    {
        "content": "<p>And it is that extra bit of knowledge, that exists in actual fact even on systems without CHERI or whatnot, that means Provenance Is Real.</p>",
        "id": 277478858,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847906
    },
    {
        "content": "<p>In particular, keeping one big \"backup\" provenance works for CHERI but doesn't really help under a compiler-optimization model.</p>",
        "id": 277478862,
        "sender_full_name": "comex",
        "timestamp": 1648847910
    },
    {
        "content": "<p>No, learning <br>\n<span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478637\">said</a>:</p>\n<blockquote>\n<p>that is literally the property that differentiates those integers</p>\n</blockquote>\n<p>No, we're talking about whether an address that you read or write to is derived from (as the compiler, or runtime architecture in the case of CHERI) a pointer that came from the allocation.</p>",
        "id": 277478886,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648847926
    },
    {
        "content": "<p><strong>very weakly</strong>, perhaps.</p>",
        "id": 277478889,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847928
    },
    {
        "content": "<p>All pointers that a program ever sees are just allocations by the OS. <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span></p>",
        "id": 277478962,
        "sender_full_name": "Jubilee",
        "timestamp": 1648847977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478721\">said</a>:</p>\n<blockquote>\n<p>As a program evolves over time, allocating and deallocating memory, the same integer, cast to a pointer, can be a legal or an illegal pointer to use.</p>\n</blockquote>\n<p>Validity changing over time doesn't require provenance.  What requires provenance is when you have two pointers /with the same integer value/ where one is legal and the other is illegal.  Which can happen in any reasonable optimizing-compiler model, but not in e.g. WebAssembly.</p>",
        "id": 277479036,
        "sender_full_name": "comex",
        "timestamp": 1648848005
    },
    {
        "content": "<p>I mean, one is legal and the other is illegal, at the same time.</p>",
        "id": 277479073,
        "sender_full_name": "comex",
        "timestamp": 1648848026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478889\">said</a>:</p>\n<blockquote>\n<p><strong>very weakly</strong>, perhaps.</p>\n</blockquote>\n<p>I suppose there's a way in which a program's memory mappings can be viewed as a form of provenance, but that isn't the provenance we're talking about here. When I say \"a bag of bits\" I mean one in which there are a set of memory mappings that you see from <code>cat /proc/self/maps</code> that have integer ranges and protections and it's legal to forge a pointer from an integer in any way you want and access memory, so long as you land in one of those address ranges and you don't violate the permissions.</p>",
        "id": 277479195,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848099
    },
    {
        "content": "<blockquote>\n<p>if you want to reason about what the allocator is allowed to do, it's more complicated than just handing out chunks of provenance</p>\n</blockquote>\n<p>Well, there are some additional constraints when writing an allocator, but you still have the normal provenance rules as a foundation. It's not like there's a completely different model, it's that logic errors in the allocator layer can make programs in the layer below unsound. And I don't think the rules an allocator has to follow are actually that complicated...</p>",
        "id": 277479213,
        "sender_full_name": "Diggsey",
        "timestamp": 1648848106
    },
    {
        "content": "<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>",
        "id": 277479339,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479339\">said</a>:</p>\n<blockquote>\n<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>\n</blockquote>\n<p>To be quite frank, I - and presumably many other rust programmers - am hoping for a higher bar than what C++ programs consider to \"generally work\"</p>",
        "id": 277479423,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648848199
    },
    {
        "content": "<p>Honestly I rarely encounter programmers who truly reason from the same God's eye view of the Operating System, but I am willing to believe you.</p>",
        "id": 277479429,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478674\">said</a>:</p>\n<blockquote>\n<p>but even wrote learning those rules is much more complicated than strict provenance, and it still doesn't protect you completely</p>\n</blockquote>\n<p>Yes, it's simpler because you've removed the ability to do that. Removing any features makes any language simpler at a first approximation. The question is if it makes things simpler <em>even if you weren't using that feature</em>. (And in the other direction, if working around the lack of feature winds up making the code more complex than you gained)</p>",
        "id": 277479443,
        "sender_full_name": "Talchas",
        "timestamp": 1648848216
    },
    {
        "content": "<p>I would actually suggest that most programmers tend to manipulate objects they believe it is safe to manipulate.</p>",
        "id": 277479452,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848224
    },
    {
        "content": "<p>Rust doesn't have any <code>malloc</code> attribute currently so no user-space (non-GlobalAlloc) allocators currently deal with provenance issues.</p>",
        "id": 277479474,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648848240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478604\">said</a>:</p>\n<blockquote>\n<p>I'm not talking about writing to memory you didn't allocate. I'm talking about treating pointers and integers as interchangeable.</p>\n</blockquote>\n<p>Porting work C/C++ code to CHERI suggests most programmer don't treat pointers and integers as interchangeable. Programmers use the expected methods of allocating language objects (global objects, stack allocations, malloc/new) and try not to get it wrong. There are of course  notable exceptions like the Linux kernel's rampant use of casts via <code>long</code>, but most code doesn't do that sort of thing except perhaps in allocators.</p>",
        "id": 277479525,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648848251
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 277479542,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479213\">said</a>:</p>\n<blockquote>\n<p>And I don't think the rules an allocator has to follow are actually that complicated...</p>\n</blockquote>\n<p>You may be right.  I am not sure.</p>",
        "id": 277479576,
        "sender_full_name": "comex",
        "timestamp": 1648848279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479452\">said</a>:</p>\n<blockquote>\n<p>I would actually suggest that most programmers tend to manipulate objects they believe it is safe to manipulate.</p>\n</blockquote>\n<p>they may have more sophisticated goals, like \"making concurrency work\"</p>",
        "id": 277479650,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848316
    },
    {
        "content": "<p>Which can go pretty badly if you don't respect \"who is allowed to go now\" and instead contend forever on a resource.</p>",
        "id": 277479678,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848341
    },
    {
        "content": "<p>I worry that reasoning like \"C++ programs tend to work\" is circular, because C++ compilers are deliberately conservative with what aliasing optimizations they implement to avoid the implicit standard-extending contract that's been forged by legacy code written in the absence of any kind of checker.</p>",
        "id": 277479690,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648848350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479339\">said</a>:</p>\n<blockquote>\n<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>\n</blockquote>\n<p>To be quite frank, I - and presumably many other rust programmers - am hoping for a higher bar than what C++ programs consider to \"generally work\"</p>\n</blockquote>\n<p>Me too, and that's why I'm conflicted. The practical advantage of the status quo in C++ is a simple mental model for the programmer, which allows them to write working code with less effort <em>most</em> of the time. The practical disadvantage is that, sometimes (rarely, to be honest) there are bugs that arise from the fact that the programmer's mental model doesn't match the formal model that the optimizer is optimizing under.</p>",
        "id": 277479748,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848370
    },
    {
        "content": "<blockquote>\n<p>Yes, it's simpler because you've removed the ability to do that.</p>\n</blockquote>\n<p>I don't know what you mean by that. I'm saying that as a C++ programmer I had to learn a bunch of \"things not to do\" to avoid falling into optimization pitfalls indirectly due to provenance (which I didn't understand at the time). Those rules served as a proxy for the \"real provenance rules\" which are still not well defined in C/C++ that prevented most miscompilations. Under strict provenance, the <em>actual</em> provenance rules are even simpler than those \"simply proxy rules\" that I had to learn for C++.</p>",
        "id": 277479751,
        "sender_full_name": "Diggsey",
        "timestamp": 1648848371
    },
    {
        "content": "<p>Also most programs execute on x86's TSO memory model.</p>",
        "id": 277479762,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848377
    },
    {
        "content": "<p>Of course, it's completely valid to pick one side or the other of the tradeoff, but there is a tradeoff.</p>",
        "id": 277479811,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848421
    },
    {
        "content": "<p>I think most \"know\" that pointers are integers, but on the whole only rely on that when solving a difficult problem or just being overly clever (e.g., Solaris devs storing pointers XORd to a key to hide them from a leak checker.)</p>",
        "id": 277479829,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1648848438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"490906\">Brooks Davis</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479829\">said</a>:</p>\n<blockquote>\n<p>I think most \"know\" that pointers are integers, but on the whole only rely on that when solving a difficult problem or just being overly clever (e.g., Solaris devs storing pointers XORd to a key to hide them from a leak checker.)</p>\n</blockquote>\n<p>Right, that's why LLVM/GCC does optimizations based on provenance in the first place.</p>",
        "id": 277479884,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848478
    },
    {
        "content": "<p>Okay, so can we at least admit there's a lot of asterisks on \"programmers treating integers as pointers\"?</p>",
        "id": 277479953,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848501
    },
    {
        "content": "<p>like five?</p>",
        "id": 277479957,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848505
    },
    {
        "content": "<p>I guess allocators don't really /need/ to convert integers to pointers most of the time.  When I write allocators in C I tend to do that a lot, in an attempt to limit UB in C, but this is not C‚Ä¶  I guess allocators need a different way to guarantee that they can do things like 'do pointer arithmetic on allocations to walk out of bounds to where the metadata is stored', which really shouldn't have anything to do with integers.  Therefore this issue is orthogonal to strict provenance versus integer broadcasting.  Maybe.</p>",
        "id": 277480022,
        "sender_full_name": "comex",
        "timestamp": 1648848554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479953\">said</a>:</p>\n<blockquote>\n<p>Okay, so can we at least admit there's a lot of asterisks on \"programmers treating integers as pointers\"?</p>\n</blockquote>\n<p>it really depends on the type of code. :p</p>",
        "id": 277480058,
        "sender_full_name": "comex",
        "timestamp": 1648848581
    },
    {
        "content": "<p>I mean yes.</p>",
        "id": 277480078,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479751\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Yes, it's simpler because you've removed the ability to do that.</p>\n</blockquote>\n<p>I don't know what you mean by that. I'm saying that as a C++ programmer I had to learn a bunch of \"things not to do\" to avoid falling into optimization pitfalls indirectly due to provenance (which I didn't understand at the time). Those rules served as a proxy for the \"real provenance rules\" which are still not well defined in C/C++ that prevented most miscompilations. Under strict provenance, the <em>actual</em> provenance rules are even simpler than those \"simply proxy rules\" that I had to learn for C++.</p>\n</blockquote>\n<p>I mean that the \"things not to do\" that strict provenance does is \"<code>(void*)integer</code> no longer exists, so you can't get it wrong\"</p>",
        "id": 277480166,
        "sender_full_name": "Talchas",
        "timestamp": 1648848625
    },
    {
        "content": "<p>I mean, yes, in most cases programmers don't think about the integer-ness of their pointers, but also there are a lot of pointer-to-int and int-to-pointer casts in our codebase. Not sure what else to say.</p>",
        "id": 277480177,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848633
    },
    {
        "content": "<p>and this is... true, but not really what people mean by simpler</p>",
        "id": 277480183,
        "sender_full_name": "Talchas",
        "timestamp": 1648848636
    },
    {
        "content": "<p>I hear and understand your concern.</p>",
        "id": 277480204,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848656
    },
    {
        "content": "<p>But half of the point is that if we don't even add methods like <code>pointer::addr</code> then we are stuck with your codebase having <code>ptr as usize</code></p>",
        "id": 277480245,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848688
    },
    {
        "content": "<p>forever.</p>",
        "id": 277480254,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848690
    },
    {
        "content": "<blockquote>\n<p>I mean that the \"things not to do\" that strict provenance does is \"(void*)integer no longer exists, so you can't get it wrong\"</p>\n</blockquote>\n<p>Well... It does, it's <code>ptr::invalid_mut</code>, but yes if you lose provenance then you can't dereference anymore.</p>",
        "id": 277480271,
        "sender_full_name": "Diggsey",
        "timestamp": 1648848697
    },
    {
        "content": "<p>and we are not allowed to upgrade them.</p>",
        "id": 277480274,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848698
    },
    {
        "content": "<p>because adding new APIs that would not have any questions about how to interpret them would be...</p>",
        "id": 277480291,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848713
    },
    {
        "content": "<p>...breaking that code somehow?</p>",
        "id": 277480341,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848724
    },
    {
        "content": "<p>I'm arguing that <code>ptr as usize</code> is something that should not ever be broken until Rust 2.0, yes.</p>",
        "id": 277480363,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848741
    },
    {
        "content": "<p>Thus you can never pay down the technical debt.</p>",
        "id": 277480373,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848745
    },
    {
        "content": "<p>Whatever, there are a lot of people who aren't happy with the status quo.</p>",
        "id": 277480408,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848768
    },
    {
        "content": "<p><code>ptr as usize</code> is safe and stable, squarely within the stability promise</p>",
        "id": 277480430,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648848786
    },
    {
        "content": "<p>Yeah, it seems like Rust 2.0 would be the prime place for most of these changes.</p>",
        "id": 277480440,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648848792
    },
    {
        "content": "<p>I intend to  outlive Facebook's codebase anyways.</p>",
        "id": 277480459,
        "sender_full_name": "Jubilee",
        "timestamp": 1648848803
    },
    {
        "content": "<p>And I think it's fine for us to talk about the future, without having to be bound by stability guarantees of today, as long as we recognize those still exist.</p>",
        "id": 277480471,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648848813
    },
    {
        "content": "<p>and yes, there are design mistakes in Rust that we can never fix, this is a fact of life</p>",
        "id": 277480476,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648848815
    },
    {
        "content": "<p>That's what the spirit of the compatibility promise is: there are changes we'd like to make, but we won't for the sake of backwards compatibility, and we hate it but we promised to do that.</p>",
        "id": 277480561,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648848853
    },
    {
        "content": "<p>this is the ancient story of immovable object (backwards compat) vs unstoppable force (design evolution)</p>",
        "id": 277480588,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648848868
    },
    {
        "content": "<p>Also re simplicity, you still have all the narrowing and borrow error things that tend to be the actual hard parts (ie, why split_at_mut's impl was wrong (twice iirc?), why <code>(&amp;vec[0] as *const T).add(5)</code> is wrong, etc)</p>",
        "id": 277480626,
        "sender_full_name": "Talchas",
        "timestamp": 1648848897
    },
    {
        "content": "<p>I have several crates that, if strict provenance becomes normative, I'm just gonna yank forever. I don't even know in how many ways they'd break</p>",
        "id": 277480710,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648848944
    },
    {
        "content": "<p>To be clear, I don't think there is any plan to break <code>(&amp;vec[0] as *const T).add(5)</code>, I just personally really want it to be wrong</p>",
        "id": 277480788,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648848974
    },
    {
        "content": "<p>isn't that already broken?</p>",
        "id": 277480876,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849022
    },
    {
        "content": "<p>(personally, I want it to be wrong, but I /also/ want an opt-out for the equivalent on struct fields, on a per-struct or per-field basis, so that I can use container_of)</p>",
        "id": 277480914,
        "sender_full_name": "comex",
        "timestamp": 1648849037
    },
    {
        "content": "<p>It is only broken under SB with raw pointer tagging</p>",
        "id": 277480916,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648849037
    },
    {
        "content": "<p>\"already broken\" is a tired trope</p>",
        "id": 277480928,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849043
    },
    {
        "content": "<p>As an asterisk, I think that just refusing to compile <code>ptr as usize</code> under CHERI wouldn't violate the compatibility promise.</p>",
        "id": 277480939,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849048
    },
    {
        "content": "<p>That's what I thought.</p>",
        "id": 277480946,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849051
    },
    {
        "content": "<p>You're borrowing a place, which gives only provenance to that place.</p>",
        "id": 277480980,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849067
    },
    {
        "content": "<p>refusing to compile <code>ptr as usize</code> also isnt a violation if its done over an edition boundary <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277480993,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648849072
    },
    {
        "content": "<p>Rust 1.x can not drop the 2015 edition</p>",
        "id": 277481094,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849102
    },
    {
        "content": "<p>(yeah I should clarify that all of those were \"wrong according to SB\")</p>",
        "id": 277481097,
        "sender_full_name": "Talchas",
        "timestamp": 1648849105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277480993\">said</a>:</p>\n<blockquote>\n<p>refusing to compile <code>ptr as usize</code> also isnt a violation if its done over an edition boundary <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</blockquote>\n<p>Yeah, I was going to bring that up too. There's a possibility of fixing it in an edition here. Though, if you fix it in an edition, you still need to support it.</p>",
        "id": 277481106,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277480928\">said</a>:</p>\n<blockquote>\n<p>\"already broken\" is a tired trope</p>\n</blockquote>\n<p>I mean \"already broken\" here as in \"already known to be incorrect\" at least under the current SB rules.</p>",
        "id": 277481208,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849162
    },
    {
        "content": "<p>And because provenance optimizations are all about global reasoning from local facts, as long as you must assume <em>any</em> code doesn't play by the strict rules, you can't rely on the strict rules</p>",
        "id": 277481219,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481208\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277480928\">said</a>:</p>\n<blockquote>\n<p>\"already broken\" is a tired trope</p>\n</blockquote>\n<p>I mean \"already broken\" here as in \"already known to be incorrect\" at least under the current SB rules.</p>\n</blockquote>\n<p>Stacked borrows aren't normative yet, per my understanding.</p>",
        "id": 277481249,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849187
    },
    {
        "content": "<p>, thus this whole topic</p>",
        "id": 277481339,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648849212
    },
    {
        "content": "<p>It's not, but it's also (close to) what is implemented by rustc, so...</p>",
        "id": 277481348,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849216
    },
    {
        "content": "<p>I couldn't land an optimization that assumes SB right now. If it broke existing code I'd have to back it out, no?</p>",
        "id": 277481388,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849237
    },
    {
        "content": "<p>The main thing is that if you still have to complicate your compiler/model/optimizations with <code>ptr as usize</code> and the inverse, edition-gating it doesn't gain you much. And sufficiently clever people will just smuggle code under a <code>2015</code> crate, which makes your life even more fun.</p>",
        "id": 277481389,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648849237
    },
    {
        "content": "<p><code>noalias</code> on <code>&amp;mut</code> and <code>Box</code> basically requires SB</p>",
        "id": 277481442,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648849269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481388\">said</a>:</p>\n<blockquote>\n<p>I couldn't land an optimization that assumes SB right now. If it broke existing code I'd have to back it out, no?</p>\n</blockquote>\n<p>I think <code>noalias</code> optimizations are \"proven\" by SB, so SB is de facto if not de jure normative.</p>",
        "id": 277481445,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648849273
    },
    {
        "content": "<p>As is <code>dereferenceable</code>.</p>",
        "id": 277481453,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481219\">said</a>:</p>\n<blockquote>\n<p>And because provenance optimizations are all about global reasoning from local facts, as long as you must assume <em>any</em> code doesn't play by the strict rules, you can't rely on the strict rules</p>\n</blockquote>\n<p>I don't believe this is actually true for ptrtoint/inttoptr <em>as long as no optimizations are performed across the boundary</em> (and maybe LLVM can even do better than that if people actually wanted to put in work for this setup)</p>",
        "id": 277481468,
        "sender_full_name": "Talchas",
        "timestamp": 1648849296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481468\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481219\">said</a>:</p>\n<blockquote>\n<p>And because provenance optimizations are all about global reasoning from local facts, as long as you must assume <em>any</em> code doesn't play by the strict rules, you can't rely on the strict rules</p>\n</blockquote>\n<p>I don't believe this is actually true for ptrtoint/inttoptr <em>as long as no optimizations are performed across the boundary</em> (and maybe LLVM can even do better than that)</p>\n</blockquote>\n<p>Which I noted yesterday is <em>hard</em>.</p>",
        "id": 277481533,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481348\">said</a>:</p>\n<blockquote>\n<p>It's not, but it's also (close to) what is implemented by rustc, so...</p>\n</blockquote>\n<p>what rustc implements is a couple conservative MIR opts and then LLVM. LLVM does not care about provenance narrower than an allocated object</p>",
        "id": 277481538,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849330
    },
    {
        "content": "<p>yeah, we can probably build a slightly more permissive model than SB, but uhhh</p>",
        "id": 277481542,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849332
    },
    {
        "content": "<p>My understanding, which could be wrong, is that SB is one model that soundly allows the optimizations that rustc does today, but it's not the only such imaginable model.</p>",
        "id": 277481546,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849333
    },
    {
        "content": "<p>As such SB is not normative yet.</p>",
        "id": 277481580,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849352
    },
    {
        "content": "<p>Yes, that seems correct</p>",
        "id": 277481602,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849364
    },
    {
        "content": "<p>And with respect to \"breaking existing code\", that's kind of already done at every new LLVM release, and those aren't backed out</p>",
        "id": 277481603,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648849364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481603\">said</a>:</p>\n<blockquote>\n<p>And with respect to \"breaking existing code\", that's kind of already done at every new LLVM release, and those aren't backed out</p>\n</blockquote>\n<p>It's really not.</p>",
        "id": 277481623,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849373
    },
    {
        "content": "<p>Yes it is.</p>",
        "id": 277481635,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849381
    },
    {
        "content": "<p>My employer suffered huge issues with the last 2 LLVM releases<br>\nWe couldn't take the new toolchains.</p>",
        "id": 277481653,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648849392
    },
    {
        "content": "<p>we've backed out of noalias because it broke stuff how many times now?</p>",
        "id": 277481676,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849407
    },
    {
        "content": "<p>Generally, LLVM optimizations that break lots of existing code are backed out.</p>",
        "id": 277481679,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481676\">said</a>:</p>\n<blockquote>\n<p>we've backed out of noalias because it broke stuff how many times now?</p>\n</blockquote>\n<p>IIRC, noalias still is applied today, continous since rustc 1.56 in october.</p>",
        "id": 277481715,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849436
    },
    {
        "content": "<p>Although I would point out that when you say \"it's not the only such imaginable model,\" this is probably true in theory, but it is the only model we <em>have</em> that has these properties</p>",
        "id": 277481718,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849437
    },
    {
        "content": "<p>It is very frustrating to see what appears to be deliberate dismissal and downplaying of the rather large amount of work that it takes to keep up with LLVM's nonsense.</p>",
        "id": 277481779,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849451
    },
    {
        "content": "<p>It was backed out several times because it miscompiled well-defined code.</p>",
        "id": 277481785,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849453
    },
    {
        "content": "<p>I want to believe it is not deliberate.</p>",
        "id": 277481807,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849465
    },
    {
        "content": "<p>And I want to acknowledge that LLVM is not always Shenanigans.</p>",
        "id": 277481843,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849488
    },
    {
        "content": "<p>But that's a LOT OF SHENANIGANS people are glossing over.</p>",
        "id": 277481864,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> maybe the thing to consider is that given the size and importance of your employer, your experience with LLVM's... compliance, has been much better than everyone else's</p>",
        "id": 277481911,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849538
    },
    {
        "content": "<p>And there's no guarantees that the shenangigans end after we ban int2ptr. LLVM will continue to ship new bugs, shenanigans will continue to be necesssary</p>",
        "id": 277481992,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849572
    },
    {
        "content": "<p>That is true, but that does not mean we cannot improve things.</p>",
        "id": 277482023,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849593
    },
    {
        "content": "<p>FWIW, I've only had terrible experiences with LLVM (albeit not in rustc, I haven't touched codegen)</p>",
        "id": 277482032,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648849604
    },
    {
        "content": "<p>And one of the ways people improve things w/r/t LLVM is formalizations.</p>",
        "id": 277482040,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849609
    },
    {
        "content": "<p>It is absolutely not true that everyone's code breaks all the time when upgrading LLVM. Linux distros regularly upgrade Clang and they work. Yes, there are pains, but in general the LLVM project does a great job of considering stakeholders, which is why it's been as successful as it has been.</p>",
        "id": 277482064,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849630
    },
    {
        "content": "<p>Not everyone's code does break.</p>",
        "id": 277482098,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849656
    },
    {
        "content": "<p>There are too many stakeholders at this point for LLVM to actually hear or care about them all.</p>",
        "id": 277482099,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849656
    },
    {
        "content": "<p>But code relying on undefined behaviour is very susceptable to breakage in an LLVM update.</p>",
        "id": 277482127,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849676
    },
    {
        "content": "<p>Yes, I realize that's like<br>\nan embarrassment of success.</p>",
        "id": 277482133,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> that statement is not incompatible with a small number of people having a large amount of code break on every release</p>",
        "id": 277482179,
        "sender_full_name": "Diggsey",
        "timestamp": 1648849689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482127\">said</a>:</p>\n<blockquote>\n<p>But code relying on undefined behaviour is very susceptable to breakage in an LLVM update.</p>\n</blockquote>\n<p>Honestly, not really. Pretty much every C++ codebase relies on UB in various ways and in general they continue to work.</p>",
        "id": 277482237,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481992\">said</a>:</p>\n<blockquote>\n<p>And there's no guarantees that the shenangigans end after we ban int2ptr. LLVM will continue to ship new bugs, shenanigans will continue to be necesssary</p>\n</blockquote>\n<p>Absolutely, but no one is trying to argue that adopting strict provenance will fix all our LLVM problems. We're trying to argue that the hand-wavey nature of LLVM's current approach is not actually a feasible solution</p>",
        "id": 277482255,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482127\">said</a>:</p>\n<blockquote>\n<p>But code relying on undefined behaviour is very susceptable to breakage in an LLVM update.</p>\n</blockquote>\n<p>And this is the nature of relying on undefined behaviour: Just because it works today does not mean a compiler won't be smarter tomorrow.</p>",
        "id": 277482285,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478365\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> Having provenance is certainly more complicated to the programmer than not having it, but I do think that strict provenance is easier to understand <em>if you're going to have provenance at all</em></p>\n</blockquote>\n<p>The great thing here is: some programmers can just pretend that Rust has only strict provenance. Even if Rust in reality <em>also</em> permits more permissive provenance</p>",
        "id": 277482299,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648849765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482299\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277478365\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> Having provenance is certainly more complicated to the programmer than not having it, but I do think that strict provenance is easier to understand <em>if you're going to have provenance at all</em></p>\n</blockquote>\n<p>The great thing here is: some programmers can just pretend that Rust has only strict provenance. Even if Rust in reality <em>also</em> permits more permissive provenance</p>\n</blockquote>\n<p>That doesn't help implementors, though.</p>",
        "id": 277482357,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849796
    },
    {
        "content": "<p>My belief is that the presence of a Rust model for proving certain things sound would allow strengthening LLVM's own models.</p>",
        "id": 277482474,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482255\">said</a>:<br>\nAbsolutely, but no one is trying to argue that adopting strict provenance will fix all our LLVM problems. We're trying to argue that the hand-wavey nature of LLVM's current approach is not actually a feasible solution</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">mean</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">clear</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">nothing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">affairs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">Rust</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">fantastic</span><span class=\"w\"> </span><span class=\"n\">tool</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">massively</span><span class=\"w\"> </span><span class=\"n\">reducing</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">safety</span><span class=\"w\"> </span><span class=\"n\">problems</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">plague</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">++</span><span class=\"w\"> </span><span class=\"n\">without</span><span class=\"w\"> </span><span class=\"n\">sacrificing</span><span class=\"w\"> </span><span class=\"n\">performance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"k\">continue</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277482483,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849868
    },
    {
        "content": "<p>of which it does have some.</p>",
        "id": 277482487,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849871
    },
    {
        "content": "<p>I frankly do not see Rust as merely a better C++, sorry.</p>",
        "id": 277482529,
        "sender_full_name": "Jubilee",
        "timestamp": 1648849899
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482064\">said</a>:</p>\n<blockquote>\n<p>It is absolutely not true that everyone's code breaks all the time when upgrading LLVM. Linux distros regularly upgrade Clang and they work. Yes, there are pains, but in general the LLVM project does a great job of considering stakeholders, which is why it's been as successful as it has been.</p>\n</blockquote>\n<p>The problems that do arise are not unique to LLVM either. Watch a Fedora mass rebuild sometime and see all the pain a new GCC can cause...</p>",
        "id": 277482600,
        "sender_full_name": "cuviper",
        "timestamp": 1648849923
    },
    {
        "content": "<p>the current state of affairs is a complete disaster where it is not _generally_ possible to write correct code ther are of course some cases where it is but so much is not specified..</p>",
        "id": 277482624,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648849933
    },
    {
        "content": "<p>I also would like a well-specified rust model that doesn't handwave away important details that affect soundness, that I need to implement properly.</p>",
        "id": 277482669,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849956
    },
    {
        "content": "<p>The current state of affairs is not a complete disaster. It works well, which is why Rust has been so successful in the first place.</p>",
        "id": 277482670,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849956
    },
    {
        "content": "<p>the status quo isnt \"fine\" the status quo is horrifiyng and completely undermines the entire \"safety\" promise of rust</p>",
        "id": 277482682,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648849965
    },
    {
        "content": "<p>I can't implement \"Things may be valid sometimes\" properly.</p>",
        "id": 277482691,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648849970
    },
    {
        "content": "<p>It's not horrifying. It's a huge improvement over C++.</p>",
        "id": 277482719,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648849987
    },
    {
        "content": "<p>if you are okay with relying on UB all the time and just rolling the dice that your stuff wont get miscompiled then enjoy that I guess but I would like to actually be writing correct code :/</p>",
        "id": 277482723,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648849989
    },
    {
        "content": "<p>I'm OK with rolling the dice that my code won't be miscompiled. I have to do that anyway, because LLVM can have bugs.</p>",
        "id": 277482773,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482723\">said</a>:</p>\n<blockquote>\n<p>if you are okay with relying on UB all the time and just rolling the dice that your stuff wont get miscompiled then enjoy that I guess but I would like to actually be writing correct code :/</p>\n</blockquote>\n<p>Especially true in the (possibly quite near) future.</p>",
        "id": 277482836,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850045
    },
    {
        "content": "<p>Ok great then why are you in this conversation <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span></p>",
        "id": 277482856,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648850061
    },
    {
        "content": "<p>like</p>",
        "id": 277482859,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648850063
    },
    {
        "content": "<p>just let us declare stuff UB?</p>",
        "id": 277482860,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648850066
    },
    {
        "content": "<p>hope things dont get miscompiled!</p>",
        "id": 277482873,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648850073
    },
    {
        "content": "<p>In fact, miscompilations due to LLVM bugs are empirically significantly more common than miscompilations due to soundness issues in the LLVM model.</p>",
        "id": 277482874,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850074
    },
    {
        "content": "<p>seems to be the status quo then</p>",
        "id": 277482880,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648850081
    },
    {
        "content": "<p>When the semantics under discussion aren't just implemented by rustc-&gt;llvm</p>",
        "id": 277482890,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850086
    },
    {
        "content": "<p>Oh yeah, how does <code>gccrs</code>'s like backend compare with LLVM? Iirc it has many of the same issues.</p>",
        "id": 277482973,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648850147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482670\">said</a>:</p>\n<blockquote>\n<p>The current state of affairs is not a complete disaster. It works well, which is why Rust has been so successful in the first place.</p>\n</blockquote>\n<p>Like, I can promise you that I will do my best to not miscompile your code. But at the same time, I see having a sound memory model as essentially a hard requirement for Rust, and I am not willing to give it up for anything else. We can certainly talk about the degree to which we try and work with people that don't adhere by it (for whatever reason), but I don't think this is relevant for this conversation</p>",
        "id": 277482979,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850150
    },
    {
        "content": "<p>I agree.</p>",
        "id": 277483044,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482860\">said</a>:</p>\n<blockquote>\n<p>just let us declare stuff UB?</p>\n</blockquote>\n<p>Because one of the main effects of declaring things UB historically has been, and I believe would be in the future, to justify the implementation of MIR optimizations that would not be implementable today. Then a lot of code that used to work will no longer work.</p>",
        "id": 277483087,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850203
    },
    {
        "content": "<p>I've been pushing to see a spec for rust for the past year and a half, and a well-defined and well-behaved memory model is probably half of that.</p>",
        "id": 277483095,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850211
    },
    {
        "content": "<p>Here is the thing: there is still no formal (or even informal) spec for what's UB in Rust.<br>\nThere will still not be one once we ban int2ptr.<br>\nAs long as this is the case, there will be some uncertainty involved in writing unsafe Rust.</p>",
        "id": 277483111,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648850224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483087\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482860\">said</a>:</p>\n<blockquote>\n<p>just let us declare stuff UB?</p>\n</blockquote>\n<p>Because one of the main effects of declaring things UB historically has been, and I believe would be in the future, to justify the implementation of MIR optimizations that would not be implementable today. Then a lot of code that used to work will no longer work.</p>\n</blockquote>\n<p>We can work on how much code this breaks. There are a huge amount of halfway solutions that can cover the vast majority of the problems</p>",
        "id": 277483125,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850248
    },
    {
        "content": "<p>But it is a total non-statement, in the context of <em>trying to come up with such a spec</em> to declare something \"broken all along\"</p>",
        "id": 277483135,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648850255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483087\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482860\">said</a>:</p>\n<blockquote>\n<p>just let us declare stuff UB?</p>\n</blockquote>\n<p>Because one of the main effects of declaring things UB historically has been, and I believe would be in the future, to justify the implementation of MIR optimizations that would not be implementable today. Then a lot of code that used to work will no longer work.</p>\n</blockquote>\n<p>The effect of declaring things UB here is that we can define a better-specified memory model.</p>",
        "id": 277483136,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482979\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277482670\">said</a>:</p>\n<blockquote>\n<p>The current state of affairs is not a complete disaster. It works well, which is why Rust has been so successful in the first place.</p>\n</blockquote>\n<p>Like, I can promise you that I will do my best to not miscompile your code. But at the same time, I see having a sound memory model as essentially a hard requirement for Rust, and I am not willing to give it up for anything else. We can certainly talk about the degree to which we try and work with people that don't adhere by it (for whatever reason), but I don't think this is relevant for this conversation</p>\n</blockquote>\n<p>I never said I didn't want a sound memory model. There are many ways to have a sound memory model that involve, for example, more permissive, weaker forms of provenance. Those ways don't involve breaking existing code.</p>",
        "id": 277483150,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850264
    },
    {
        "content": "<p>And there are plenty of explanations why they don't work.</p>",
        "id": 277483218,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483111\">said</a>:</p>\n<blockquote>\n<p>Here is the thing: there is still no formal (or even informal) spec for what's UB in Rust.<br>\nThere will still not be one once we ban int2ptr.<br>\nAs long as this is the case, there will be some uncertainty involved in writing unsafe Rust.</p>\n</blockquote>\n<p>FWIW I would not want to normatively ban int2ptr without a very good understanding of the memory model that we will adopt</p>",
        "id": 277483241,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648850317
    },
    {
        "content": "<p>PNVI-ae is the most practical one for rust, but it has some issues with rust.</p>",
        "id": 277483310,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483218\">said</a>:</p>\n<blockquote>\n<p>And there are plenty of explanations why they don't work.</p>\n</blockquote>\n<p>Strict provenance isn't required for soundness. You could easily imagine something like Wasm's model, where pointers have no provenance at all, and we do no optimizations based on aliasing, and we don't work on CHERI. I'm not arguing for such a model, but clearly it could exist and be sound.</p>",
        "id": 277483418,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850416
    },
    {
        "content": "<p>It could exist.</p>",
        "id": 277483467,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850433
    },
    {
        "content": "<p>And compilers could simply take the garbage input code that takes forever to run, and produce slow af binary that also takes forever to run, and have users complain the the compiled code is too slow.</p>",
        "id": 277483520,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483520\">said</a>:</p>\n<blockquote>\n<p>And compilers could simply take the garbage input code that takes forever to run, and produce slow af binary that also takes forever to run, and have users complain the the compiled code is too slow.</p>\n</blockquote>\n<p>Yes. But the implications of this aren't what you think they are.</p>",
        "id": 277483537,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850485
    },
    {
        "content": "<p>The implication of this is that the <em>unsound</em> model we have today is <em>practically</em> superior to either stacked borrows or the Wasm model.</p>",
        "id": 277483573,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850507
    },
    {
        "content": "<p>PNVI-ae however, has major buy-in with GCC and LLVM. It has a decent chance of becoming <em>the</em> provenance model</p>",
        "id": 277483581,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648850514
    },
    {
        "content": "<p>Not superior in theory. But in practice, it's better.</p>",
        "id": 277483632,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850528
    },
    {
        "content": "<p>PNVI-ae w/o union provenance in rust is invalid.</p>",
        "id": 277483638,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483573\">said</a>:</p>\n<blockquote>\n<p>The implication of this is that the <em>unsound</em> model we have today is <em>practically</em> superior to either stacked borrows or the Wasm model.</p>\n</blockquote>\n<p>Until a compiler exploits the unsound model.</p>",
        "id": 277483652,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850550
    },
    {
        "content": "<p>Now I don't want us to be unsound any more than anyone else, but I think we need to be clear about the tradeoffs here.</p>",
        "id": 277483658,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483652\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483573\">said</a>:</p>\n<blockquote>\n<p>The implication of this is that the <em>unsound</em> model we have today is <em>practically</em> superior to either stacked borrows or the Wasm model.</p>\n</blockquote>\n<p>Until a compiler exploits the unsound model.</p>\n</blockquote>\n<p>And the solution is for compilers to not do that.</p>",
        "id": 277483665,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850561
    },
    {
        "content": "<p>Ok, then tell me precisely what I cannot do.</p>",
        "id": 277483693,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850579
    },
    {
        "content": "<p>I cannot!</p>",
        "id": 277483697,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850583
    },
    {
        "content": "<p>That's what I'm trying to get across here.</p>",
        "id": 277483707,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850589
    },
    {
        "content": "<p>Then how do I know what optimizations not to apply?</p>",
        "id": 277483729,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850604
    },
    {
        "content": "<p>All of the things you can't do across (even an LTO) C call.</p>",
        "id": 277483743,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648850613
    },
    {
        "content": "<p>The status quo is that adding optimizations to LLVM involves subjective judgement calls about what code we deem acceptable to break.</p>",
        "id": 277483760,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850628
    },
    {
        "content": "<p>How do I know what optimizations not to make architectural to xir?</p>",
        "id": 277483764,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483729\">said</a>:</p>\n<blockquote>\n<p>Then how do I know what optimizations not to apply?</p>\n</blockquote>\n<p>You don't that's the problem we're trying to solve</p>",
        "id": 277483769,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648850638
    },
    {
        "content": "<p>This is bad! But I want to make sure that the cure that we propose is not worse than the disease.</p>",
        "id": 277483843,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483760\">said</a>:</p>\n<blockquote>\n<p>The status quo is that adding optimizations to LLVM involves subjective judgement calls about what code we deem acceptable to break.</p>\n</blockquote>\n<p>This isn't llvm, which is part of the problem.</p>",
        "id": 277483848,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483310\">said</a>:</p>\n<blockquote>\n<p>PNVI-ae is the most practical one for rust, but it has some issues with rust.</p>\n</blockquote>\n<p>We <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304\">talked about this with Ralf yesterday</a>. \"pvni-ae\" doesn't make any sense in the Rust context, but Stacked Borrows seems a pretty similar substitute that makes sense for Rust.</p>",
        "id": 277483854,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850675
    },
    {
        "content": "<p>Replace LLVM with MIR in this case.</p>",
        "id": 277483871,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850687
    },
    {
        "content": "<p>Nor MIR.</p>",
        "id": 277483888,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850698
    },
    {
        "content": "<p>I'm not working on rustc or it's tree at all, I have &lt;<a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a>&gt;</p>",
        "id": 277483923,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483418\">said</a>:</p>\n<blockquote>\n<p>You could easily imagine something like Wasm's model, where pointers have no provenance at all</p>\n</blockquote>\n<p>Please. I think we're all on the same page that no provenance means a really shitty compiler. For those who are not on this page, please read the FAQ here <a href=\"https://github.com/rust-lang/rust/issues/95228\">https://github.com/rust-lang/rust/issues/95228</a></p>",
        "id": 277483956,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850736
    },
    {
        "content": "<p>We need provenance.</p>",
        "id": 277484000,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483854\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483310\">said</a>:</p>\n<blockquote>\n<p>PNVI-ae is the most practical one for rust, but it has some issues with rust.</p>\n</blockquote>\n<p>We <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277321304\">talked about this with Ralf yesterday</a>. \"pvni-ae\" doesn't make any sense in the Rust context, but Stacked Borrows seems a pretty similar substitute that makes sense for Rust.</p>\n</blockquote>\n<p>SB doesn't do anything with int2ptr casts, other than defining what happens when you do restore the provenance, IIRC.</p>",
        "id": 277484074,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277483956\">said</a>:</p>\n<blockquote>\n<p>Please. I think we're all on the same page that no provenance means a really shitty compiler. For those who are not on this page, please read the FAQ here <a href=\"https://github.com/rust-lang/rust/issues/95228\">https://github.com/rust-lang/rust/issues/95228</a></p>\n</blockquote>\n<p>I offered that only by way of argument, to illustrate that strict provenance isn't the only imaginable semantics that's sound.</p>",
        "id": 277484095,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850796
    },
    {
        "content": "<p>Yes, but I think it's not helpful for the discussion to mention unviable options</p>",
        "id": 277484134,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850823
    },
    {
        "content": "<p>Because then we start talking about unviable options</p>",
        "id": 277484146,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850830
    },
    {
        "content": "<p>Again, even with strict provenance this has to be valid (on non-CHERI) or Rust as a systems language breaks down:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">ptrtoint</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">ptrtoint</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So I don't think problems with backwards compatibility will be anywhere as bad as you think Patrick. There has to be an out for code that needs it/can't be ported.</p>",
        "id": 277484148,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648850831
    },
    {
        "content": "<p>Also, miri's impl of PNVI-ae is unsound wrt. zero sized accesses.</p>",
        "id": 277484189,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850860
    },
    {
        "content": "<p>An \"out\" is what I've been arguing for this whole time :)</p>",
        "id": 277484192,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850862
    },
    {
        "content": "<p>It violates an actual documented rule of rust.</p>",
        "id": 277484216,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850874
    },
    {
        "content": "<p>(And it's a rule that is fairly integral to the soundness of pretty much all rust code)</p>",
        "id": 277484295,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484134\">said</a>:</p>\n<blockquote>\n<p>Yes, but I think it's not helpful for the discussion to mention unviable options</p>\n</blockquote>\n<p>My point is simply that it doesn't have to be a binary \"strict provenance\" vs \"unsound\". At least, right now I don't see any reason why it does.</p>",
        "id": 277484302,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484074\">said</a>:</p>\n<blockquote>\n<p>SB doesn't do anything with int2ptr casts, other than defining what happens when you do restore the provenance, IIRC.</p>\n</blockquote>\n<p>Not sure what you mean. SB is a definition for when int2ptr results in a valid pointer, and when it results in an invalid pointer.</p>",
        "id": 277484333,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648850929
    },
    {
        "content": "<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>",
        "id": 277484335,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648850931
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> strong disagree - we only need to support that for backwards compatibility, there's no need for that construct to exist <em>if we were starting from a blank slate</em></p>",
        "id": 277484366,
        "sender_full_name": "Diggsey",
        "timestamp": 1648850963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484333\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484074\">said</a>:</p>\n<blockquote>\n<p>SB doesn't do anything with int2ptr casts, other than defining what happens when you do restore the provenance, IIRC.</p>\n</blockquote>\n<p>Not sure what you mean. SB is a definition for when int2ptr results in a valid pointer, and when it results in an invalid pointer.</p>\n</blockquote>\n<p>SB talks about what accesses a valid pointer can perform on certain memory.</p>",
        "id": 277484375,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648850977
    },
    {
        "content": "<p>I have basically no objections against anything that isn't going to be used for MIR or LLVM optimizations.</p>",
        "id": 277484396,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648850994
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"295632\">@Diggsey</span> Correct, but the whole point here is we are not - Rust interops with C, and as much as I would love a Rust-only userland/libc/platofrm libraries (looks at Mustang), that is not the world we live in.</p>",
        "id": 277484471,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335\">said</a>:</p>\n<blockquote>\n<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>\n</blockquote>\n<p>The important question is \"what form\" - the compiler is aware of them and tries not to break that code? <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> they become officially supported for any meaningful definition of \"officially supported\"? Ehhhh....</p>",
        "id": 277484474,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851031
    },
    {
        "content": "<p>If changes to declare things UB are just a formalism that means the vast majority of existing code, compiled on newer versions of rustc on x86-64, continues to work, then hey, no problem.</p>",
        "id": 277484479,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484396\">said</a>:</p>\n<blockquote>\n<p>I have basically no objections against anything that isn't going to be used for MIR or LLVM optimizations.</p>\n</blockquote>\n<p>What about optimizations from other implementations.</p>",
        "id": 277484502,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484396\">said</a>:</p>\n<blockquote>\n<p>I have basically no objections against anything that isn't going to be used for MIR or LLVM optimizations.</p>\n</blockquote>\n<p>On the other hand... you keep talking about how awesome the status quo of Rust is. No one is forcing you to update rustc</p>",
        "id": 277484507,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335\">said</a>:</p>\n<blockquote>\n<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>\n</blockquote>\n<p>The important question is \"what form\" - the compiler is aware of them and tries not to break that code? <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> they become officially supported for any meaningful definition of \"officially supported\"? Ehhhh....</p>\n</blockquote>\n<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>",
        "id": 277484520,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> you said the absence of that would make Rust a non-starter for systems programming, which I disagree with. I want to continue to support that for backwards compatibility, but systems programming works just fine without ptr2int2ptr</p>",
        "id": 277484535,
        "sender_full_name": "Diggsey",
        "timestamp": 1648851085
    },
    {
        "content": "<p>See <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Use-cases.20for.20unrestricted.20ptr2int2ptr\">#t-lang/wg-unsafe-code-guidelines &gt; Use-cases for unrestricted ptr2int2ptr</a></p>",
        "id": 277484566,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648851113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335\">said</a>:</p>\n<blockquote>\n<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>\n</blockquote>\n<p>The important question is \"what form\" - the compiler is aware of them and tries not to break that code? <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> they become officially supported for any meaningful definition of \"officially supported\"? Ehhhh....</p>\n</blockquote>\n<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>\n</blockquote>\n<p>Sure it is, but the semantics of it aren't necessarily fixed, wrt. to casting back and then using to access the memory.</p>",
        "id": 277484577,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851117
    },
    {
        "content": "<p>claiming to be a systems language and not having ptr2int2ptr is at best stretching the definition</p>",
        "id": 277484623,
        "sender_full_name": "Talchas",
        "timestamp": 1648851130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335\">said</a>:</p>\n<blockquote>\n<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>\n</blockquote>\n<p>The important question is \"what form\" - the compiler is aware of them and tries not to break that code? <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> they become officially supported for any meaningful definition of \"officially supported\"? Ehhhh....</p>\n</blockquote>\n<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>\n</blockquote>\n<p>I mean... sure. But there is no obligation for the pointer to be dereferenceable</p>",
        "id": 277484640,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484577\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335\">said</a>:</p>\n<blockquote>\n<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>\n</blockquote>\n<p>The important question is \"what form\" - the compiler is aware of them and tries not to break that code? <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> they become officially supported for any meaningful definition of \"officially supported\"? Ehhhh....</p>\n</blockquote>\n<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>\n</blockquote>\n<p>Sure it is, but the semantics of it aren't necessarily fixed, wrt. to casting back and then using to access the memory.</p>\n</blockquote>\n<p>That is a ridiculously disingenuous abuse of the wording of any guarantee</p>",
        "id": 277484655,
        "sender_full_name": "Talchas",
        "timestamp": 1648851162
    },
    {
        "content": "<p>@Diggsey Sorry, I was little less than clear than I wanted to be on that statement. I'm basically saying that supporting it in <em>the exact form</em> I showed above has to happen, or else you can't interop with C, ergo, I wouldn't consider that a systems language.</p>",
        "id": 277484661,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484623\">said</a>:</p>\n<blockquote>\n<p>claiming to be a systems language and not having ptr2int2ptr is at best stretching the definition</p>\n</blockquote>\n<p>At the same time, I'm definately getting close to agreeing that the semantics of \"Restores the provenance of <code>ptr</code> from... uh... somewhere\" is too handwavy to be sound fundamentally.</p>",
        "id": 277484688,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484655\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484577\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484520\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484335\">said</a>:</p>\n<blockquote>\n<p>I think this thread has gotten so long, we've missed the point :P. But I don't think anyone is in disagreement that there will be some way to have int2ptr casts in some form, even if it's just because \"we have to\" and not because we want to.</p>\n</blockquote>\n<p>The important question is \"what form\" - the compiler is aware of them and tries not to break that code? <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> they become officially supported for any meaningful definition of \"officially supported\"? Ehhhh....</p>\n</blockquote>\n<p>I should reiterate that <code>ptr as usize</code> is officially supported under the 1.0 compatibility promise, as it's a safe operation.</p>\n</blockquote>\n<p>Sure it is, but the semantics of it aren't necessarily fixed, wrt. to casting back and then using to access the memory.</p>\n</blockquote>\n<p>That is a ridiculously disingenuous abuse of the wording of any guarantee</p>\n</blockquote>\n<p>So is the \"<code>ptr as usize</code> is safe code\" thing. Presumably you're going to dereference that pointer later...</p>",
        "id": 277484695,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851211
    },
    {
        "content": "<p>Therefore, if you want to kill all optimizations, you could desugar casts to those function calls, and it would have to work / be an out for codebases.</p>",
        "id": 277484719,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851239
    },
    {
        "content": "<p>Oh wait, <code>ptr as usize</code>, not <code>usize as ptr</code>, I misread that</p>",
        "id": 277484761,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484507\">said</a>:</p>\n<blockquote>\n<p>On the other hand... you keep talking about how awesome the status quo of Rust is. No one is forcing you to update rustc</p>\n</blockquote>\n<p>The problem with not updating rustc is that you get stranded on earlier versions of the crate ecosystem, as newer versions of crates tend to require newer compiler versions. That's why, for example, I maintain an internal backport of rustc to LLVM 9, which we need for LTO, rather than just freezing our version of rustc at the last supported version that was compatible with LLVM 9.</p>",
        "id": 277484762,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851246
    },
    {
        "content": "<p>IIRC, there is no documentation anywhere that says what <code>p  as usize as *mut ()</code> yields a pointer that has the same validity as <code>p</code>.</p>",
        "id": 277484791,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851275
    },
    {
        "content": "<p>I mean, there's no problem with continuing to support all the safe uses of <code>ptr as usize</code>. We can just give it <code>.addr()</code> semantics and deprecate it in some edition</p>",
        "id": 277484793,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851280
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> why, did LLVM 10 break something? <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 277484831,
        "sender_full_name": "Diggsey",
        "timestamp": 1648851312
    },
    {
        "content": "<p>There isn't<br>\n<span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484791\">said</a>:</p>\n<blockquote>\n<p>IIRC, there is no documentation anywhere that says what <code>p  as usize as *mut ()</code> yields a pointer that has the same validity as <code>p</code>.</p>\n</blockquote>\n<p>There isn't, but in practice it tends to work and I think that \"in practice it tends to work\" should be considered in any decisions that we make.</p>",
        "id": 277484837,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851315
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 277484838,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851316
    },
    {
        "content": "<p>See: <code>c-unwind</code></p>",
        "id": 277484865,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277481779\">said</a>:</p>\n<blockquote>\n<p>It is very frustrating to see what appears to be deliberate dismissal and downplaying of the rather large amount of work that it takes to keep up with LLVM's nonsense.</p>\n</blockquote>\n<p>I (and I think many others) recognize this. It's important to have some formal model, even if it doesn't reach all the way through FFI.</p>\n<p>Which is why <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">my standpoint</a> proposes adopting something like (plain) Stacked Borrows.</p>\n<p>Question: would this help on the compiler side? Or does it actually help the compiler to outlaw permissive provenance?</p>",
        "id": 277484866,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648851339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484831\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> why, did LLVM 10 break something? <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>\n</blockquote>\n<p>The concerns about LLVM 10 weren't miscompilation but performance.</p>",
        "id": 277484869,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484837\">said</a>:</p>\n<blockquote>\n<p>There isn't<br>\n<span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484791\">said</a>:</p>\n<blockquote>\n<p>IIRC, there is no documentation anywhere that says what <code>p  as usize as *mut ()</code> yields a pointer that has the same validity as <code>p</code>.</p>\n</blockquote>\n<p>There isn't, but in practice it tends to work and I think that \"in practice it tends to work\" should be considered in any decisions that we make.</p>\n</blockquote>\n<p>It shouldn't be taken as an absolute, though.</p>",
        "id": 277484879,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851355
    },
    {
        "content": "<p>interesting</p>",
        "id": 277484883,
        "sender_full_name": "Diggsey",
        "timestamp": 1648851357
    },
    {
        "content": "<p>I think that there shows that the Rust lang/lib team is more than willing  to understand that code that is currently working should not just be unilaterally broken.</p>",
        "id": 277484937,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851377
    },
    {
        "content": "<p>I can write some code that \"in practice tends to work\" right now, that involves relying on the layout of a repr(Rust) structure.</p>",
        "id": 277484946,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484762\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484507\">said</a>:</p>\n<blockquote>\n<p>On the other hand... you keep talking about how awesome the status quo of Rust is. No one is forcing you to update rustc</p>\n</blockquote>\n<p>The problem with not updating rustc is that you get stranded on earlier versions of the crate ecosystem, as newer versions of crates tend to require newer compiler versions. That's why, for example, I maintain an internal backport of rustc to LLVM 9, which we need for LTO, rather than just freezing our version of rustc at the last supported version that was compatible with LLVM 9.</p>\n</blockquote>\n<p>I mean... libraries are just as capable of exploiting UB as the compiler is. Are you going to fight all the library authors over their adoption of the Rust memory model too?</p>",
        "id": 277484959,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851402
    },
    {
        "content": "<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>",
        "id": 277484973,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851418
    },
    {
        "content": "<p>In particular for something as simple as <code>p  as usize as *mut ()</code> there is no legitimate argument that it wasn't intended to work, and any lack of docs is \"1.0 rust didn't have docs for tons and tons of things\"</p>",
        "id": 277484978,
        "sender_full_name": "Talchas",
        "timestamp": 1648851422
    },
    {
        "content": "<p>(rust right now doesn't have docs for plenty of language things)</p>",
        "id": 277484999,
        "sender_full_name": "Talchas",
        "timestamp": 1648851447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973\">said</a>:</p>\n<blockquote>\n<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>\n</blockquote>\n<p>YOu would hope not but in practice yes, did you see that we backed out on icnreasing the size of <code>TypeId</code> because people were doing a nice little bit of UB despite it being so clearly UB <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 277485006,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648851451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484959\">said</a>:</p>\n<blockquote>\n<p>I mean... libraries are just as capable of exploiting UB as the compiler is. Are you going to fight all the library authors over their adoption of the Rust memory model too?</p>\n</blockquote>\n<p>It's perfectly valid to raise concerns about upstream library changes that in practice break code, yes.</p>",
        "id": 277485009,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973\">said</a>:</p>\n<blockquote>\n<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>\n</blockquote>\n<p>Honestly? It might be, in at least some circumstances.</p>",
        "id": 277485018,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648851465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973\">said</a>:</p>\n<blockquote>\n<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>\n</blockquote>\n<p>We've given a ~2-year deprecation period for crates assuming the internals of <code>IpAddr</code>.</p>",
        "id": 277485024,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485006\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973\">said</a>:</p>\n<blockquote>\n<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>\n</blockquote>\n<p>YOu would hope not but in practice yes, did you see that we backed out on icnreasing the size of <code>TypeId</code> because people were doing a nice little bit of UB despite it being so clearly UB <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>\n</blockquote>\n<p>Oh joy. I can't wait to make TypeId sound.</p>",
        "id": 277485033,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484973\">said</a>:</p>\n<blockquote>\n<p>Does that mean that the layout of repr(Rust) is <em>de facto</em> stable forever?</p>\n</blockquote>\n<p>That is at least explicitly spelled out to break arbitrarily, which considerably weakens the \"happens to work\" aspect of it.</p>",
        "id": 277485080,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648851493
    },
    {
        "content": "<p>And have everyone that ever uses lccc complain that I broke their code relying on TypeId's layout.</p>",
        "id": 277485111,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851517
    },
    {
        "content": "<p>No snark: How many people are using lccc?</p>",
        "id": 277485137,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485009\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277484959\">said</a>:</p>\n<blockquote>\n<p>I mean... libraries are just as capable of exploiting UB as the compiler is. Are you going to fight all the library authors over their adoption of the Rust memory model too?</p>\n</blockquote>\n<p>It's perfectly valid to raise concerns about upstream library changes that in practice break code, yes.</p>\n</blockquote>\n<p>To be clear, if someone filed such an issue on my repo I would close it with a brief remark about not supporting UB</p>",
        "id": 277485138,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648851549
    },
    {
        "content": "<p>Those kind of problems are the long tail of problems.</p>",
        "id": 277485153,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485137\">said</a>:</p>\n<blockquote>\n<p>No snark: How many people are using lccc?</p>\n</blockquote>\n<p>None yet (unless you count myself and the others working on it running the test suite), it's not yet complete.</p>",
        "id": 277485197,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851590
    },
    {
        "content": "<p>There are a bunch of specific areas where Rust has explicitly carved out forward-compat niches for itself, and repr(rust) is one of these.<br>\nThe provenance stuff is different because we never told people that ptr-int-ptr wouldn't work.</p>",
        "id": 277485254,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648851622
    },
    {
        "content": "<p>Makes sense.</p>",
        "id": 277485269,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648851641
    },
    {
        "content": "<p>And the \"oral tradition\" (which is the best you have in the face of an absent spec) of Rust's raw pointers has been that they work like they do in C</p>",
        "id": 277485308,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648851681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218745\">Wanja Hentze</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277485254\">said</a>:</p>\n<blockquote>\n<p>There are a bunch of specific areas where Rust has explicitly carved out forward-compat niches for itself, and repr(rust) is one of these.<br>\nThe provenance stuff is different because we never told people that ptr-int-ptr wouldn't work.</p>\n</blockquote>\n<p>It's also carved out a soundness exemption.</p>",
        "id": 277485317,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851691
    },
    {
        "content": "<p>Where it can even break explicit guarantees to fix soundness issues.</p>",
        "id": 277485331,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851704
    },
    {
        "content": "<p>In the face of an absent spec, what is a soundness issue? That is not at all an easy question</p>",
        "id": 277485442,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648851754
    },
    {
        "content": "<p>A soundness issue is an issue where code that has all preconditions satisified has undefined behaviour (this is an extension of what rust calls a soundness issue, \"safe code causing UB\", as safe code has all preconditions vacuously satisfied).</p>",
        "id": 277485619,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851855
    },
    {
        "content": "<p>You can break soundness issues into Implementation Soundness (miscompilation) and Fundmental Soundness.</p>",
        "id": 277485653,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648851878
    },
    {
        "content": "<p>I would define a Fundmental Soundness issue as one that cannot be specified in a way that is sound.</p>",
        "id": 277485869,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648852041
    },
    {
        "content": "<p>(And I'm leaning towards the current state of ptr2int2ptr falling into that category)</p>",
        "id": 277485903,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648852070
    },
    {
        "content": "<p>At the very least, it's close to \"Impossible to implement in a way that is sound\", which is just as bad, if not worse.</p>",
        "id": 277485994,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648852119
    },
    {
        "content": "<p>I agree that the formal text of the 1.0 compatibility promise allows us to break ptr to int to ptr as much as we want, but I believe that actually doing that (for example, by declaring that all ptr to int to ptr casts are UB and doing MIR optimizations that break code relying on it) violates its spirit, because it causes a lot of practical problems for Rust's users of the kind that motivated the 1.0 compatibility promise to begin with.</p>",
        "id": 277486145,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648852233
    },
    {
        "content": "<p>Breaking some uses of ptr-&gt;int-&gt;ptr would be fine as long as they don't impact too much code and/or can be done with a deprecation period. I know that's fuzzy and subjective, but, well, it's engineering.</p>",
        "id": 277486304,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648852360
    },
    {
        "content": "<p>Also I don't think anyone cares if ptr-&gt;int-&gt;ptr is completely banned on CHERI architectures, since there's no legacy to worry about on them.</p>",
        "id": 277486365,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648852419
    },
    {
        "content": "<p>I'm still waiting for any reason to make Rust strict-provenance-<strong>only</strong>.</p>",
        "id": 277486499,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648852538
    },
    {
        "content": "<p>The main problem with discussing this tradeoff perf-wise is that what optimizations we gain by memory model X compared to memory model Y cannot assume all else equal. For example, we knowing going looser than C kills a bunch of optimizations that we would really rather have, but how strict do we have to go for a good strict/perf ratio is not really answerable. Even if we have strict provenance, I'm fairly confident that there will still be more work on making PNVI-ae-udi better and more optimizable simply due to the resources involved.</p>",
        "id": 277487044,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648852929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473168\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277472874\">said</a>:</p>\n<blockquote>\n<p>I believe there is consensus that pointer-to-int <strong>transmute</strong> cannot work and has to break. Even though pointer-to-int <em>conversions</em> like <code>ptr as usize</code> would still work. And we believe that very little code in practice uses such transmutes</p>\n</blockquote>\n<p>I think there's no such consensus. I pointed out a way that the transmutes could actually work (just not broadcast), and someone on the issue said they believed that the transmutes are actually common enough to be a problem</p>\n</blockquote>\n<p>I don't know of a way to salvage that common code I am afraid. Your proposal does not help with that since that code assumes it can transmute the ptrs to ints and back 'unharmed', whereas your proposal produces pointers with invalid provenance.<br>\nThere <em>is</em> an alternative though that code can migrate to, transmute to <code>MaybeUninit&lt;int&gt;</code>. if you dont know whether your data contains pointers, you probably also dont know whether it contains padding, and then you should use MaybeUninit anyway.</p>",
        "id": 277487256,
        "sender_full_name": "RalfJ",
        "timestamp": 1648853142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277477720\">said</a>:</p>\n<blockquote>\n<p>yeah, SB's baseline complexity is high, and as far as I've heard strict provenance wouldn't let you rip out any of the complexity of the raw pointer handling parts</p>\n</blockquote>\n<p>it lets us rip out <code>Untagged</code>. That's quite a big win IMO.</p>",
        "id": 277487329,
        "sender_full_name": "RalfJ",
        "timestamp": 1648853190
    },
    {
        "content": "<p>Is it? I thought in a different place you said we hardly get additional optimizations without <code>Untagged</code></p>",
        "id": 277487503,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648853343
    },
    {
        "content": "<p>But maybe that was someone else's understanding</p>",
        "id": 277487530,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648853362
    },
    {
        "content": "<p>I had an idea for a set of guidelines to avoid future optimizations breaking code.</p>",
        "id": 277487996,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648853647
    },
    {
        "content": "<p>Strawperson proposal: Any new MIR optimization that relies on strict provenance to be sound must be (1) intraprocedural; (2) disable itself if the function it's optimizing uses <code>ptr as usize</code> or <code>usize as ptr</code>.</p>",
        "id": 277488069,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648853708
    },
    {
        "content": "<p>Intraprocedural requirement is there to ensure that a function-local check for int-to-ptr or ptr-to-int is sufficient, because an intraprocedural optimization by definition only looks at a single function and has to be sound regardless of what the rest of the program does.</p>",
        "id": 277488191,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648853788
    },
    {
        "content": "<p>Of course, inlining converts intraprocedural optimizations to interprocedural ones. This is fine, because the conservative check for int-to-ptr and ptr-to-int casts remains sound if performed after inlining.</p>",
        "id": 277488269,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648853870
    },
    {
        "content": "<p>This assumes that ptr2int and int2ptr transmutes become UB. If this is a problem in practice we could allowlist direct calls to <code>mem::transmute</code> or do some other sort of hack, but hopefully it won't be an issue.</p>",
        "id": 277488401,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648853999
    },
    {
        "content": "<p>I think that's a bit of a conservative check, but \"vibes-wise\" it makes sense</p>",
        "id": 277488448,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277479339\">said</a>:</p>\n<blockquote>\n<p>For the most part, this is the model that C++ programmers have in their head when writing code and it generally works.</p>\n</blockquote>\n<p>I have to admit I am surprised how well it works, yes. the fact that computers do anything at all is astounding.<br>\nBut to my knowledge, there is no rigorous reason for why it works. it's being held together by sweat, blood and tears (of many compiler devs) and it's impossible to say if any change you want to make breaks the world because there is not even a coherent contract that 'the world' relies on.<br>\nI think we can do better. I think we can actually have a coherent contract on which we can build a real-world systems programming language. I think Rust can do that. I hope programmers consider this sufficiently valuable that they are willing to adjust how they write programs -- e.g., using arrays of <code>MaybeUninit&lt;u8&gt;</code> (instead of <code>u8</code>) to hold arbitrary data. Rust makes me hopeful because Rust already asks a lot from programmers (fighting the borrow checker is a meme!) and yet people go with it because it brings them value. I think there is value in knowing that there is a rigorous contract that underpins Rust and if you follow that contract you dont have to enter the twilight zone that is \"just hoping that the compiler doesn't see my crimes and break my code\", and I hope programmers agree.<br>\nincluding ptr-int-ptr roundtrips in that contract is very feasible I think <em>if</em> it is okay that programs using them are not going to get the full benefits of tools like Miri (or they might not run at all). I hope large swaths of the ecosystem will not have to resort to this as otherwise Miri would become a lot less useful. including ptr-to-int transmutes is a lot harder and I don't have good ideas here.</p>\n<p>but maybe that is a pipe dream, and maybe parts of Rust will never have a rigorous contract and we'll have to continue using sweat, blood, and tears to hold those parts together. but then we can at least have a safe heaven called 'strict provenance' and know that <em>that part</em> is safe from the daemons.</p>",
        "id": 277488454,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488448\">said</a>:</p>\n<blockquote>\n<p>I think that's a bit of a conservative check, but \"vibes-wise\" it makes sense</p>\n</blockquote>\n<p>Yeah, this is a baseline known-good proposal.</p>",
        "id": 277488522,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854034
    },
    {
        "content": "<p>We could loosen it over time.</p>",
        "id": 277488531,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854039
    },
    {
        "content": "<p>Also, such optimizations are free to always run on CHERI (though ptr-to-int/int-to-ptr might not even be supported at all there).</p>",
        "id": 277488571,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854087
    },
    {
        "content": "<p>I don't think we're in any position to set red lines right now, even though I understand that you would like peace of mind</p>",
        "id": 277488575,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277487503\">said</a>:</p>\n<blockquote>\n<p>Is it? I thought in a different place you said we hardly get additional optimizations without <code>Untagged</code></p>\n</blockquote>\n<p>it's a big win in complexity and coherence. e.g. a masters student tried to develop a reasonable logic to verify correctness of programs written against stacked borrows and <code>untagged</code> kind of broke everything.</p>",
        "id": 277488592,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854106
    },
    {
        "content": "<p>IMO one of the most important things to get right now, _the_ most important thing to get right now, is closer to a formal model</p>",
        "id": 277488607,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488191\">said</a>:</p>\n<blockquote>\n<p>Intraprocedural requirement is there to ensure that a function-local check for int-to-ptr or ptr-to-int is sufficient, because an intraprocedural optimization by definition only looks at a single function and has to be sound regardless of what the rest of the program does.</p>\n</blockquote>\n<p>intraprocedural gets fuzzy when you deal with inlining.</p>",
        "id": 277488649,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648854127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488649\">said</a>:</p>\n<blockquote>\n<p>intraprocedural gets fuzzy when you deal with inlining.</p>\n</blockquote>\n<p>Note my comment about inlining -- if the check is done post-inlining then it should be sound by construction.</p>",
        "id": 277488685,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854170
    },
    {
        "content": "<p>Yes. Besides \"makes sense vibes-wise\" I'm not convinced that it's <em>a useful red line</em></p>",
        "id": 277488692,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854183
    },
    {
        "content": "<p>It'd be extremely useful for me to have at least loose consensus that this is the way forward.</p>",
        "id": 277488737,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854217
    },
    {
        "content": "<p>In practice these sorts of optimizations are all intraprocedural anyway because of compile time concerns.</p>",
        "id": 277488802,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> I dont even know of a useful MIR optimization that relies on strict provenance being sound.^^<br>\nOTOH, I would <em>not</em> put my hand in the fire to promise that the LLVM we create is sound without strict provenance... compatibility with LLVM is certainly a lot easier under strict provenance. (though some issue remain open, like carrying provenance through iN types but also doing GVN on iN types...)</p>",
        "id": 277488810,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488810\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> I dont even know of a useful MIR optimization that relies on strict provenance being sound.^^</p>\n</blockquote>\n<p>Dead load/dead store elimination? GVN?</p>",
        "id": 277488842,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854306
    },
    {
        "content": "<p>GVN on pointers is cursed and never okay, not even under strict provenance. GVN on integers should be fine under any model, it's other things that are broken.</p>",
        "id": 277488882,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854361
    },
    {
        "content": "<p>dead load/store elimination is only a problem if you want to allow code like <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431</a></p>",
        "id": 277488960,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854396
    },
    {
        "content": "<p>IOW, if you accept that ptr2int transmutes are UB, dead load/store elim is fine</p>",
        "id": 277489017,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277488737\">said</a>:</p>\n<blockquote>\n<p>It'd be extremely useful for me to have at least loose consensus that this is the way forward.</p>\n</blockquote>\n<p>In my view you can feel safe that Rust (the language + compiler) will continue to support permissive provenance for a very long time ‚Äî with probably slightly better codegen when all code is strict-provenance. But it's not helpful to formalize this as constraints of the code of rustc at this point, that's just too low-level.</p>\n<p>It's not just your employer that wants permissive provenance for legacy code, it reduces the applicability of Rust in general IMO</p>",
        "id": 277489129,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854513
    },
    {
        "content": "<p>you also have to accept that ptr2int casts <em>do</em> have side-effects. LLVM doesn't accept that so until it does we might get weird breakage there. but I no longer think we should let that affect our Rust model. rather we should lobby for LLVM to accept this. this might only happen after actual code breaks in the wild, but that's at least no worse than how we currently do things...</p>",
        "id": 277489161,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854542
    },
    {
        "content": "<p><em>sigh at LLVM</em></p>",
        "id": 277489181,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489129\">said</a>:</p>\n<blockquote>\n<p>It's not just your employer that wants permissive provenance for legacy code, it reduces the applicability of Rust in general IMO</p>\n</blockquote>\n<p>Yep. I'm very aware that I'm probably speaking for many others here, but I can only say <em>for sure</em> about the code I work with, so I've limited to that to avoid saying anything that I don't know to be true.</p>",
        "id": 277489194,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854569
    },
    {
        "content": "<p>How is LLVM intending to support pnvi-ae, then?</p>",
        "id": 277489201,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854576
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489201\">said</a>:</p>\n<blockquote>\n<p>How is LLVM intending to support pnvi-ae, then?</p>\n</blockquote>\n<p>I dont know. I might not be up-to-date on that.</p>",
        "id": 277489220,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854592
    },
    {
        "content": "<p>also, PNVI-ae <em>might</em>  be soundly compilable to twinsem, which <em>does</em> make ptr2int side-effect-free</p>",
        "id": 277489282,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854613
    },
    {
        "content": "<p>just because PNVI-ae says casts have side-effects, doesnt mean the IR needs to do that. the IR just needs to have less UB than PNVI-ae.</p>",
        "id": 277489303,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854643
    },
    {
        "content": "<p>and since PNVI-ae ignores <code>restrict</code>, this <em>might</em> work</p>",
        "id": 277489310,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854653
    },
    {
        "content": "<p>it all falls apart with <code>restrict</code> though</p>",
        "id": 277489324,
        "sender_full_name": "RalfJ",
        "timestamp": 1648854671
    },
    {
        "content": "<p>Patrick, I explicitly call out \"pointer in u32\" in <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view\">my position</a> as an example of <del>something I want to keep supporting</del> why I want to keep supporting permissive provenance. Because it's documented that people actually do this</p>",
        "id": 277489331,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854677
    },
    {
        "content": "<p>Ooh. Twinsem could be a very interesting paper to read ‚Äî another time, though</p>",
        "id": 277489375,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854710
    },
    {
        "content": "<p>It feels like the LLVM people are simply still in denial of reality.</p>",
        "id": 277489457,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648854778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489331\">said</a>:</p>\n<blockquote>\n<p>Patrick, I explicitly call out \"pointer in u32\" in <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view\">my position</a> as an example of <del>something I want to keep supporting</del> why I want to keep supporting permissive provenance. Because it's documented that people actually do this</p>\n</blockquote>\n<p>Yeah, I certainly won't complain if y'all end up going with a weaker provenance model even for new code :)</p>",
        "id": 277489485,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648854829
    },
    {
        "content": "<p>so I think we have 3 layers here:</p>\n<ul>\n<li>strict provenance:  no ptr2int2ptr casts nor ptr2int transmutes. coherent models are fairly easy to define (as in, the fact that we have integer casts puts zero additional burden on the memory model -- it's 'only' the actual complexity of handling the aliasing contraints), Miri can run your code, CHERI is happy. we also avoid some of the incoherence of LLVM. <span aria-label=\"sunny\" class=\"emoji emoji-2600\" role=\"img\" title=\"sunny\">:sunny:</span> </li>\n<li>permissive provenance: ptr2int2ptr is allowed, but no ptr2int transmutes. ptr2int casts <em>do</em> have a side-effect, which LLVM fails to acknowledge so that's \"fun\" but whatever. (int2ptr casts also might be impure in other ways.) the memory model becomes more complicated but I think this is always possible in a generic way (\"guess a suitable exposed provenance at int2ptr time, if any guess can work your program is fine\"). this model is not realistically implementable in Miri though. seems very reasonable to guarantee that we will not miscompile these programs but we won't be held liable for LLVM's bugs ;) . <span aria-label=\"rainy\" class=\"emoji emoji-1f327\" role=\"img\" title=\"rainy\">:rainy:</span> </li>\n<li>yolo provenance: ptr2int transmutes allowed. I dont know what's going on. I wouldnt be willing to guarantee anything about these programs, though I guess we can still do a best effort thing to not break them too much maybe? it's hard to say. <span aria-label=\"thunderstorm\" class=\"emoji emoji-26c8\" role=\"img\" title=\"thunderstorm\">:thunderstorm:</span> <span aria-label=\"explosion\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"explosion\">:explosion:</span> <span aria-label=\"fire\" class=\"emoji emoji-1f525\" role=\"img\" title=\"fire\">:fire:</span></li>\n</ul>",
        "id": 277489704,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855028
    },
    {
        "content": "<blockquote>\n<p>this model is not realistically implementable in Miri though</p>\n</blockquote>\n<p>Can you elaborate? I was under the impression that plain Stacked Borrows is permissive provenance</p>",
        "id": 277489812,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648855123
    },
    {
        "content": "<p>\"this model\" refers specifically to \"guess a suitable exposed provenance at int2ptr time, if any guess can work your program is fine\". that's not what Stacked Borrows with <code>untagged</code> does.</p>",
        "id": 277489836,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855167
    },
    {
        "content": "<p>this is a <em>generic</em> way to turn any strict provenance model into a permissive provenance model. (I think.) it relies on angelic non-determinism so it might confuse people a lot...<br>\nthere are other ways to achieve permissive provenance models, like what plain SB does. but what plain SB does here has issues that I don't know how to fix so I am not hopeful about that avenue.</p>",
        "id": 277489927,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855252
    },
    {
        "content": "<p>Thanks Ralf, that's very helpful!</p>",
        "id": 277489949,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855276
    },
    {
        "content": "<p>I think it's still worth thinking about keeping hacks like \"special case direct calls to <code>mem::transmute</code> that really just <code>ptr as int</code> written in a different way\" in our back pocket. I'm definitely not advocating using those hacks without data showing that they will bring benefit, but they're worth thinking about if adding some targeted hacks like this would make more existing code strict-provenance-compatible.</p>",
        "id": 277490064,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855369
    },
    {
        "content": "<p>yeah such hacks are always an option. we could literally say that on old editions, such a <code>transmute</code> generates the cast during MIR building...</p>",
        "id": 277490125,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855420
    },
    {
        "content": "<p>Yep</p>",
        "id": 277490132,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855425
    },
    {
        "content": "<p>if we keep this in the frontend before MIR then our optimizations and backends wouldnt even have to be aware of them so I could live with that rather well</p>",
        "id": 277490200,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855459
    },
    {
        "content": "<p>but that wont help for code that transmutes large structs that contain pointers, into arrays of integers</p>",
        "id": 277490216,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>",
        "id": 277490249,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855517
    },
    {
        "content": "<p>Yeah, definitely not a comprehensive solution, but if we can do little targeted things then it could go a long way toward easing the pain.</p>",
        "id": 277490255,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855528
    },
    {
        "content": "<p>sounds plausible</p>",
        "id": 277490275,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855561
    },
    {
        "content": "<p>I keep thinking about how JavaScript clawed lexical scoping out by observing that people never rename the function <code>eval</code> and special casing functions that are spelled e-v-a-l in the semantics.</p>",
        "id": 277490314,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855565
    },
    {
        "content": "<p>Truly evil, but saved JS from a world of hurt.</p>",
        "id": 277490323,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855577
    },
    {
        "content": "<p>So, what Ralf wrote looks good to me, the one thing I am worried about is this:</p>\n<blockquote>\n<p>seems very reasonable to guarantee that we will not miscompile these programs</p>\n</blockquote>\n<p>Depending on what you mean by <em>guarantee</em> that might be just a little too strong for me. For example, I would like to have a spec that declares such code UB, because I think future implementations should make use of that. That being said, if this means \"we consider miscompilations of this form that we introduce bugs in rustc,\" I would be perfectly content with that - maybe under the additional condition that they affect real world code and not just pathological examples</p>",
        "id": 277490345,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648855618
    },
    {
        "content": "<p>I should emphasize how stoked I am about strict provenance because that is what (for me) made it possible to seriously consider the \"guess a suitable exposed provenance at int2ptr time, if any guess can work your program is fine\" angelic-nondeterminism kind of model for ptr2int2ptr. previously I ruled that out because of Miri, but if we can actually get almost all (new) Rust code to not need ptr2int2ptr roundtrips, this becomes much less of a concern.</p>",
        "id": 277490358,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490345\">said</a>:</p>\n<blockquote>\n<p>So, what Ralf wrote looks good to me, the one thing I am worried about is this:</p>\n<blockquote>\n<p>seems very reasonable to guarantee that we will not miscompile these programs</p>\n</blockquote>\n<p>Depending on what you mean by <em>guarantee</em> that might be just a little too strong for me. For example, I would like to have a spec that declares such code UB, because I think future implementations should make use of that. That being said, if this means \"we consider miscompilations of this form that we introduce bugs in rustc,\" I would be perfectly content with that - maybe under the additional condition that they affect real world code and not just pathological examples</p>\n</blockquote>\n<p>I explicitly do <em>not</em> want to declare such code UB because if I do Patrick will hire some assassins to come get me ;)</p>",
        "id": 277490430,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855703
    },
    {
        "content": "<p>lmao</p>",
        "id": 277490437,
        "sender_full_name": "Jubilee",
        "timestamp": 1648855718
    },
    {
        "content": "<p>and because I am not convinced that there is much benefit to declaring them UB</p>",
        "id": 277490451,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855742
    },
    {
        "content": "<p>Will he? I assumed his concern was mostly with keeping existing code working, and if that's something we can do...</p>",
        "id": 277490457,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648855749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490451\">said</a>:</p>\n<blockquote>\n<p>and because I am not convinced that there is much benefit to declaring them UB</p>\n</blockquote>\n<p>This is a fair separate issue. This would need to be investigated, and if indeed it doesn't get us anything than I don't mind either</p>",
        "id": 277490470,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648855778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>\n</blockquote>\n<p>In principle yes, but I would much much rather have that Rust adopts a formal model that <em>includes</em> permissive provenance. Perhaps a supermodel of a strict-provenance model, with fewer optimizations, and conditions for those \"missing optimizations\" so that we can just shut off the optimizations when they don't apply (as Patrick has attempted to suggest)</p>",
        "id": 277490476,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648855794
    },
    {
        "content": "<p>well so far I think zero examples have been brought up of such optimizations :)</p>",
        "id": 277490479,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855798
    },
    {
        "content": "<p>Well, yes, but there is also an imbalance here - we have tested a lot of code under MIRI to find problems with writing code against the model, there is not one SB specific optimizations to figure out what kind of problems <em>that</em> runs into</p>",
        "id": 277490551,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648855844
    },
    {
        "content": "<p>If no good model for permissive-provenance exists, then I would like to understand the details of that more before I make it my position</p>",
        "id": 277490555,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648855851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490476\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>\n</blockquote>\n<p>In principle yes, but I would much much rather have that Rust adopts a formal model that <em>includes</em> permissive provenance. Perhaps a supermodel of a strict-provenance model, with fewer optimizations, and conditions for those \"missing optimizations\" so that we can just shut off the optimizations when they don't apply (as Patrick has attempted to suggest)</p>\n</blockquote>\n<p>yes that's what I said I think? I suggested we guarantee that rustc does not miscompile permissive provenance programs. that means that this is our ultimate formal model, our spec. we might just spec the strict provenance subset first as that's easier.</p>",
        "id": 277490572,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855868
    },
    {
        "content": "<p>But I have a constraint ‚Äî which is my eyelid are slowly starting to fall shut</p>",
        "id": 277490575,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648855871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490572\">said</a>:</p>\n<blockquote>\n<p>I suggested we guarantee that rustc does not miscompile permissive provenance programs. that means that this is our ultimate formal model, our spec. we might just spec the strict provenance subset first as that's easier.</p>\n</blockquote>\n<p>Ah! <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span> <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span> <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span></p>",
        "id": 277490594,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648855902
    },
    {
        "content": "<p>so, not even fewer optimizations or so</p>",
        "id": 277490600,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855913
    },
    {
        "content": "<p>In general I definitely like this approach, kudos to Ralf for putting it forward</p>",
        "id": 277490601,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648855913
    },
    {
        "content": "<p>in this vision, strict provenance exists as a sublanguage that is useful for miri and cheri and friends (and easier specs), but absolutely irrelevant for rustc</p>",
        "id": 277490651,
        "sender_full_name": "RalfJ",
        "timestamp": 1648855935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490601\">said</a>:</p>\n<blockquote>\n<p>In general I definitely like this approach, kudos to Ralf for putting it forward</p>\n</blockquote>\n<p>okay that is good to hear. :) I am still very worried about the ptr2int transmute ban. even if we add frontend hacks like you suggested.</p>",
        "id": 277490699,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856014
    },
    {
        "content": "<p>Works for me. We can always reopen the discussion if we come up with MIR optzns we'd like to do that require some stricter level of provenance.</p>",
        "id": 277490710,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648856040
    },
    {
        "content": "<p>so you'd sign off on <a href=\"https://github.com/rust-lang/rust/pull/95547\">https://github.com/rust-lang/rust/pull/95547</a> ? ;)</p>",
        "id": 277490769,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856074
    },
    {
        "content": "<p>(I know its not your decision)</p>",
        "id": 277490780,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856089
    },
    {
        "content": "<p>hm looking at it again, I will add a sentence asking people to use <code>MaybeUninit</code> instead</p>",
        "id": 277490798,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856115
    },
    {
        "content": "<p>Hmm, generally seems fine to me, though \"should always be done\" maybe overstates how final these decisions are right now</p>",
        "id": 277490815,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648856145
    },
    {
        "content": "<p>is this a guarantee that we can use an array of <code>MaybeUninit&lt;u8&gt;</code> to losslessly store pointers</p>",
        "id": 277490821,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648856161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490821\">said</a>:</p>\n<blockquote>\n<p>is this a guarantee that we can use an array of <code>MaybeUninit&lt;u8&gt;</code> to losslessly store pointers</p>\n</blockquote>\n<p>I think we should guarantee that, yes. not sure if t-lang thinks we already do guarantee that.</p>",
        "id": 277490880,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856194
    },
    {
        "content": "<p>MaybeUninit&lt;u8&gt; == a byte in the abstract machine, so I would expect so</p>",
        "id": 277490900,
        "sender_full_name": "Diggsey",
        "timestamp": 1648856221
    },
    {
        "content": "<p>it's kind of a hack as calling <code>assume_init</code> might be UB even though the array is <em>initialized</em> (just to pointer values, which is wrong)</p>",
        "id": 277490906,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>\n</blockquote>\n<p>On it.</p>",
        "id": 277490909,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648856225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490906\">said</a>:</p>\n<blockquote>\n<p>it's kind of a hack as calling <code>assume_init</code> might be UB even though the array is <em>initialized</em> (just to pointer values, which is wrong)</p>\n</blockquote>\n<p>but that is not very different from how calling <code>assume_init</code> on <code>MaybeUninit&lt;bool&gt;</code> can be UB even if the thing is initialized (but to the wrong value)</p>",
        "id": 277490947,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856261
    },
    {
        "content": "<p>Maybe <code>assume_valid</code> would have been a better name, but too late for that <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 277491002,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648856292
    },
    {
        "content": "<p>then the type should have been <code>MaybeValid</code></p>",
        "id": 277491015,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856306
    },
    {
        "content": "<p>something like this was discussed pre-stabilization</p>",
        "id": 277491028,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856313
    },
    {
        "content": "<p>but \"valid\" can mean many different things...</p>",
        "id": 277491041,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856322
    },
    {
        "content": "<p>Yeah</p>",
        "id": 277491055,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648856336
    },
    {
        "content": "<p>Oh well, can't have everything</p>",
        "id": 277491058,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648856341
    },
    {
        "content": "<p>does validity for an integer mean that it <em>doesn't</em> have provenance, or does it just mean that provenance is ignored for all operations like copy/move/etc?</p>",
        "id": 277491081,
        "sender_full_name": "Diggsey",
        "timestamp": 1648856365
    },
    {
        "content": "<p>It does not have provenance</p>",
        "id": 277491096,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648856379
    },
    {
        "content": "<p>so a pointer to int transmute is UB even if you don't attempt to cast it back?</p>",
        "id": 277491164,
        "sender_full_name": "Diggsey",
        "timestamp": 1648856409
    },
    {
        "content": "<p>Yes</p>",
        "id": 277491170,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648856417
    },
    {
        "content": "<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say \"you only get this if you start using strict provenance\"</p>",
        "id": 277491212,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648856485
    },
    {
        "content": "<p>Fixing code is always more exciting when there's better performance to be had :)</p>",
        "id": 277491225,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648856518
    },
    {
        "content": "<p>but transmuting an \"invalid_mut\" ptr to an int is fine?</p>",
        "id": 277491264,
        "sender_full_name": "Diggsey",
        "timestamp": 1648856530
    },
    {
        "content": "<p>(I like Ralf's proposal either way, it's just a wishlist thing)</p>",
        "id": 277491273,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648856543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> the carrot for strict provenance is Miri, CHERI, and hopefully more formals methods tools in the future ;)</p>",
        "id": 277491306,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856597
    },
    {
        "content": "<p>and no more threat of the compiler trashing your code :)</p>",
        "id": 277491318,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648856615
    },
    {
        "content": "<p>well, modulo compiler bugs. of which there are many.</p>",
        "id": 277491329,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856630
    },
    {
        "content": "<p>true, not much users can do about that though ^^'</p>",
        "id": 277491375,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648856644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491264\">said</a>:</p>\n<blockquote>\n<p>but transmuting an \"invalid_mut\" ptr to an int is fine?</p>\n</blockquote>\n<p>yes</p>",
        "id": 277491382,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491164\">said</a>:</p>\n<blockquote>\n<p>so a pointer to int transmute is UB even if you don't attempt to cast it back?</p>\n</blockquote>\n<p>there is a more permissible alternative by <span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> where it's not UB and you can even transmute it back but then you have a ptr with 'invalid' provenance. I doubt that will help a lot of real-world code though so I think it's better to have UB early, so we can have Miri error early.</p>",
        "id": 277491447,
        "sender_full_name": "RalfJ",
        "timestamp": 1648856731
    },
    {
        "content": "<p>I think it's quite surprising that's all</p>",
        "id": 277491535,
        "sender_full_name": "Diggsey",
        "timestamp": 1648856844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491212\">said</a>:</p>\n<blockquote>\n<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say \"you only get this if you start using strict provenance\"</p>\n</blockquote>\n<p>Yeah, I've brought this up, and definitely agree. I'm slowly working towards that goal, but there are a lot of things that need to be done before MIR opts can be at that point</p>",
        "id": 277491603,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648856905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491535\">said</a>:</p>\n<blockquote>\n<p>I think it's quite surprising that's all</p>\n</blockquote>\n<p>yes I know. :( I wish I knew a way to avoid it. but <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">this example</a> does not give us a lot of wiggle room.</p>",
        "id": 277491821,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857126
    },
    {
        "content": "<p>well I don't have an issue with round-trips being UB</p>",
        "id": 277491852,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857151
    },
    {
        "content": "<p>that is not too surprising to me, but even the initial ptr-to-int transmute being immediately UB is quite surprising</p>",
        "id": 277491891,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491212\">said</a>:</p>\n<blockquote>\n<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say \"you only get this if you start using strict provenance\"</p>\n</blockquote>\n<p>that's funny, I actually thought we should explicitly <em>not</em> have optimizations that require strict provenance and I expected you to be very happy about that.^^<br>\nfor permissive vs yolo provenance OTOH, it's hard to even say since yolo provenance is just entirely incoherent...</p>",
        "id": 277491908,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491891\">said</a>:</p>\n<blockquote>\n<p>that is not too surprising to me, but even the initial ptr-to-int transmute being immediately UB is quite surprising</p>\n</blockquote>\n<p>so you think it would be less surprising if the roundtrip is allowed but produces an 'invalid' pointer?</p>",
        "id": 277491938,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857238
    },
    {
        "content": "<p>I don't care what round-trip does - even if transmuting it back was immediately UB that would be less surprising to me</p>",
        "id": 277491999,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857262
    },
    {
        "content": "<p>making the transmute back UB is quite hard, not sure how to achieve that ;)</p>",
        "id": 277492011,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857281
    },
    {
        "content": "<p>I mean I'm not saying I <em>want</em> that</p>",
        "id": 277492025,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857290
    },
    {
        "content": "<p>yeah I understand</p>",
        "id": 277492030,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857296
    },
    {
        "content": "<p>now, this is surprising to me -- isn't the entire point of transmuting a ptr to int that you'd want to transmute it back later?</p>",
        "id": 277492047,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857315
    },
    {
        "content": "<p>like, the typical usecase I imagine is someone implementing <code>memcpy</code> by copying data one <code>u8</code> at a time (maybe with some <code>u64</code> in the middle for extra efficiency)</p>",
        "id": 277492068,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857344
    },
    {
        "content": "<p>you might just be writing stuff to a file (some kind of crash dump say) and you don't care if pointer values get in there</p>",
        "id": 277492265,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857526
    },
    {
        "content": "<p>but yeah, I'm not saying this is super useful, just that this aspect of the model was surprising</p>",
        "id": 277492321,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490249\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> could I get you to include something like what I wrote above into the summary? :D not sure how coherent it is with your understanding</p>\n</blockquote>\n<p>I gave it a go! <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view\">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view</a></p>\n<p><a href=\"/user_uploads/4715/MhqzXrC_xs_tuQnbxAqOtkB6/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/MhqzXrC_xs_tuQnbxAqOtkB6/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/MhqzXrC_xs_tuQnbxAqOtkB6/image.png\"></a></div>",
        "id": 277494118,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648859416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277492265\">said</a>:</p>\n<blockquote>\n<p>you might just be writing stuff to a file (some kind of crash dump say) and you don't care if pointer values get in there</p>\n</blockquote>\n<p>Perhaps here it make sense to have a kind of raw pointer that's semantically limited to reading data (non-pointers). Because if you can only read, then you can't randomly put a pointer where one wasn't expected ‚Äî avoiding this example <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286</a></p>",
        "id": 277494547,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648859956
    },
    {
        "content": "<p>I mean as far as I am aware, reading 16 bytes in an aligned condition works on every 64-bit platform on the planet.</p>",
        "id": 277495114,
        "sender_full_name": "Jubilee",
        "timestamp": 1648860702
    },
    {
        "content": "<p>this might be mostly historical accident.</p>",
        "id": 277495172,
        "sender_full_name": "Jubilee",
        "timestamp": 1648860729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490947\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277490906\">said</a>:</p>\n<blockquote>\n<p>it's kind of a hack as calling <code>assume_init</code> might be UB even though the array is <em>initialized</em> (just to pointer values, which is wrong)</p>\n</blockquote>\n<p>but that is not very different from how calling <code>assume_init</code> on <code>MaybeUninit&lt;bool&gt;</code> can be UB even if the thing is initialized (but to the wrong value)</p>\n</blockquote>\n<p>Just to comment on this: I don't think we need to declare ptr&lt;-&gt;int transmutes UB directly at all. We can just have ptr-&gt;int transmute be <code>.addr()</code> (non-broadcast), and int-&gt;ptr transmute be <code>invalid{_mut}()</code>. As far as I know there are no modeling issues with this interpretation, although it's still basically useless for the programmer, but the transmute itself, even reading the new bytes, is not UB.</p>\n<p>... of course I keep reading and this has been brought up. Anyway I think we should not do UB upfront here, it will limit some Pod-like implementations</p>",
        "id": 277506974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648875810
    },
    {
        "content": "<p>I know Flags aren't great, but...<br>\nHow would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>",
        "id": 277508761,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648878627
    },
    {
        "content": "<p>Miri could even enable this by default</p>",
        "id": 277508783,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648878688
    },
    {
        "content": "<p>If the considered alternative is banning such transmutes outright, then Good Citizen Miri Runners will be avoiding the transmute anyway</p>",
        "id": 277508793,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648878706
    },
    {
        "content": "<p>But if we're only forbidding it so Miri can check it, and just having it strip provenance is an O(1) addition to the formal model, then, why not <em>just</em> have Miri check it, and allow the treatment as Pod</p>",
        "id": 277508894,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648878798
    },
    {
        "content": "<p>(I guess I should <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> so this has a chance to be seen. Low priority what-if about Miri + ptr2int diagnosis flag.)</p>",
        "id": 277509056,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648878986
    },
    {
        "content": "<p>Which direction specifically are you talking about? Just ptr2int, or the other way too?</p>",
        "id": 277509348,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648879365
    },
    {
        "content": "<p>I think it is possible to support the weak-provenance model in Miri if we are okay with some false negatives. The result of a int2ptr is a \"wildcard\" pointer, which tracks no provenance like <code>invalid_mut</code>, but if you use it to dereference memory then it only flags UB if the borrow stack is such that no possible raw pointer could access this location, otherwise it just accepts it (maybe logs?) and moves on</p>",
        "id": 277509804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648880038
    },
    {
        "content": "<p>this works because the actual value being read or written does not depend on the borrow stack; the only effect is possible popping of the borrow stack (more popping means more UB), so if we don't pop the stack or only pop things we know to be invalidated by any raw pointer write, then we know we are not spuriously rejecting good programs</p>",
        "id": 277509920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648880207
    },
    {
        "content": "<p>(Note that these \"wildcard\" pointers are not part of the formal model, they are an underapproximation of the model so that miri doesn't just completely fall over on ptr2int2ptr.)</p>",
        "id": 277509980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648880309
    },
    {
        "content": "<p>You can handle ptr&lt;-&gt;int transmutes in exactly the same way, although I would put it under a different flag since the current leading proposal here would make <code>*(ptr as int as ptr)</code> defined but <code>*(transmute&lt;ptr, int&gt;(_) as ptr)</code> UB</p>",
        "id": 277510203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648880618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277508761\">said</a>:</p>\n<blockquote>\n<p>I know Flags aren't great, but...<br>\nHow would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>\n</blockquote>\n<p>This is implied by <code>-Zmiri-strict-provenance</code> (just landed). It also makes ptr2int2ptr <em>casts</em> return invalid pointers. Does that flag work for you?</p>",
        "id": 277522327,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648896919
    },
    {
        "content": "<p>I added a section on proposed memory models to my position document <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view\">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view</a> .</p>\n<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> , you may be interested in this phrase:</p>\n<blockquote>\n<p>The advantage of [the proposed memory for Rust] is that ptr2int2ptr is still allowed as it is today. (...) <strong>Developers are allowed to ‚Äúpretend‚Äù that ptr and usize are the same and that integers have provenance.</strong></p>\n</blockquote>\n<p>(Perhaps there are errors, this shit is hard. :) Ralf, you have permission to fix such things in the document if you feel like it)</p>",
        "id": 277524840,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648900144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277454590\">said</a>:</p>\n<blockquote>\n<p>I think you're right.</p>\n<p>A third option may be to make <code>ptr</code> contain _two_ machine pointers, one \"current\" one and one \"maximal\" one which represents the whole allocation. Then still only \"permissively exposed\" <code>ptr</code>s need to be tracked.</p>\n</blockquote>\n<p>This doesn't work with one-past-the-end pointers, never mind the privilege amplification it provides.</p>",
        "id": 277526648,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648902516
    },
    {
        "content": "<p>I don't know that Rust supports those, but you're right. Another case which Rust definitely supports and which someone else mentioned, is that this doesn't work when you have pointers to overlapping slices [10..30] and [20..40]; you can't take the union of pointers in CHERI</p>",
        "id": 277526904,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648902911
    },
    {
        "content": "<p>Which is why I propose the \"double pointer\" approach in my position document linked just above.</p>\n<p>Privilege amplification... if you want maximally secure Rust on CHERI then you need strict provenance</p>",
        "id": 277526928,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648902961
    },
    {
        "content": "<p>I've been refining my position document as I learn more</p>",
        "id": 277527206,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648903249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277522327\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277508761\">said</a>:</p>\n<blockquote>\n<p>I know Flags aren't great, but...<br>\nHow would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>\n</blockquote>\n<p>This is implied by <code>-Zmiri-strict-provenance</code> (just landed). It also makes ptr2int2ptr <em>casts</em> return invalid pointers. Does that flag work for you?</p>\n</blockquote>\n<p>no it is not implied by that. miri-strict-provenance only affects <em>casts</em>, not <em>transmutes</em>.</p>",
        "id": 277528799,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277524840\">said</a>:</p>\n<blockquote>\n<p>I added a section on proposed memory models to my position document <a href=\"https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view\">https://hackmd.io/I-zHe9bZTJOY78orP1aYIA?view</a> .</p>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> , you may be interested in this phrase:</p>\n<blockquote>\n<p>The advantage of [the proposed memory for Rust] is that ptr2int2ptr is still allowed as it is today. (...) <strong>Developers are allowed to ‚Äúpretend‚Äù that ptr and usize are the same and that integers have provenance.</strong></p>\n</blockquote>\n<p>(Perhaps there are errors, this shit is hard. :) Ralf, you have permission to fix such things in the document if you feel like it)</p>\n</blockquote>\n<p>oh no integers definitely do not have provenance I don't think we should say things like that^^</p>",
        "id": 277528820,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905093
    },
    {
        "content": "<blockquote>\n<p>no it is not implied by that. miri-strict-provenance only affects <em>casts</em>, not <em>transmutes</em>.</p>\n</blockquote>\n<p>Oops yeah. I keep not reading the word <code>transmute</code></p>",
        "id": 277528870,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277528820\">said</a>:</p>\n<blockquote>\n<p>oh no integers definitely do not have provenance I don't think we should say things like that^^</p>\n</blockquote>\n<p>I agree with you from a compiler / machine model perspective. But is there any code that can break by doing ptr2int2ptr too often, in the nondeterminism model?</p>",
        "id": 277528901,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905178
    },
    {
        "content": "<p>If not, then I think we can put some people at ease who now understand why their existing code won't break</p>",
        "id": 277528922,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277509804\">said</a>:</p>\n<blockquote>\n<p>I think it is possible to support the weak-provenance model in Miri if we are okay with some false negatives. The result of a int2ptr is a \"wildcard\" pointer, which tracks no provenance like <code>invalid_mut</code>, but if you use it to dereference memory then it only flags UB if the borrow stack is such that no possible raw pointer could access this location, otherwise it just accepts it (maybe logs?) and moves on</p>\n</blockquote>\n<p>well, there's basically always going to be <em>some</em> pointer that is allowed to make an access, so this would basically mean -- just allow all accesses from 'wildcard' pointers. sure that would be possible.<br>\nnote that restricting this to \"raw ptr provenance\" (whatever that even might be, there might not be such a distinction) is not necessarily correct -- someone could transmute a reference to a raw ptr and then int-roundtrip that.</p>",
        "id": 277528973,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905251
    },
    {
        "content": "<p>Of course from the efficiency and CHERI-security point of view there is a difference between ptr and int. From the compiler side there is a \"side-effect\", as you say. But AFAICT there is no observable side effect for devs</p>",
        "id": 277529012,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277508761\">said</a>:</p>\n<blockquote>\n<p>I know Flags aren't great, but...<br>\nHow would a world where formally, ptr2int2ptr transmutes give invalid_ptr, <em>but</em> Miri has a <code>-Zmiri-warn-me-about-ptr-tranamutes</code> which immediately errors (or maybe warns and continues?) for diagnostic purposes be?</p>\n</blockquote>\n<p>I mean yes that would work. I just feel like allowing the transmutes in a way that they 'lose' data is more surprising/confusing than outright disallowing them via validity invariants.</p>",
        "id": 277529027,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277528922\">said</a>:</p>\n<blockquote>\n<p>If not, then I think we can put some people at ease who now understand why their existing code won't break</p>\n</blockquote>\n<p>saying integers have provenance puts me on the edge, not at ease at all. I strongly oppose saying anything like that.^^<br>\nwe shouldn't say <strong>wrong</strong> things in the name of making things simpler. that's just bad communication.</p>",
        "id": 277529113,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905397
    },
    {
        "content": "<p>there are observable effects of integers not having provenance, e.g. the issue with transmutes</p>",
        "id": 277529137,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905426
    },
    {
        "content": "<blockquote>\n<p>we shouldn't say <strong>wrong</strong> things in the name of making things simpler. </p>\n</blockquote>\n<p>Fair point</p>",
        "id": 277529168,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905482
    },
    {
        "content": "<blockquote>\n<p>there are observable effects of integers not having provenance, e.g. the issue with transmutes</p>\n</blockquote>\n<p>Is that still an issue if transmute between ptr and int is UB?</p>",
        "id": 277529241,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905534
    },
    {
        "content": "<p>I would like to arrive at a <del>wording</del> guideline that tells devs when they can legally do <code>*(usize to ptr)</code>, and when that is UB. For instance, \"you can dereference <code>usize to ptr</code> if the original cast from ref to <code>ptr</code> isn't hidden behind the creation of <code>&amp;mut</code>\"</p>",
        "id": 277529312,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905629
    },
    {
        "content": "<p>So that they can still understand their code to some degree, even if they don't understand nondeterministically-tagged-SB itself</p>",
        "id": 277529333,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648905683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277529241\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>there are observable effects of integers not having provenance, e.g. the issue with transmutes</p>\n</blockquote>\n<p>Is that still an issue if transmute between ptr and int is UB?</p>\n</blockquote>\n<p>well you have to explain that it is UB. it is UB because integers cannot -- must not -- carry provenance.</p>",
        "id": 277529647,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905970
    },
    {
        "content": "<p>you can dereference <code>usize to ptr</code> if there <em>exists</em> some provenance that was previously 'exposed' (i.e. fed to a <code>ptr to usize</code>) that allows this access. or more precisely, with <code>let p = usize to ptr</code>, there has to exist an exposed provenance that allows <em>all</em> accesses done with <code>p</code> (i.e., you dont get to say \"on the first access <code>p</code> has this provenance and on the second it has that\").</p>",
        "id": 277529749,
        "sender_full_name": "RalfJ",
        "timestamp": 1648906113
    },
    {
        "content": "<p>basically, imagine that when <code>usize to ptr</code> is executed, a previously exposed provenance is being <em>guessed</em>, but the guess is magic and always works maximally in your favor</p>",
        "id": 277529768,
        "sender_full_name": "RalfJ",
        "timestamp": 1648906152
    },
    {
        "content": "<p>FWIW this is literally what the 'udi' part in PNVI-ae-udi does, except they have an explicit algorithm that you could implement in miri that tracks this 'guessing'. this is possible because their provenance is very simple. for SB, that algorithm is basically -- duplicate the entire state of everything for every possible guess and run them all in parallel and see which one survives. not very pretty. ;)</p>",
        "id": 277529850,
        "sender_full_name": "RalfJ",
        "timestamp": 1648906271
    },
    {
        "content": "<p>I think we can treat nondeterministically-tagged-SB as not-machine-checkable. Because it's hard. Perhaps we'll find a way to check it in the future but probably not.</p>",
        "id": 277530031,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648906552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277526904\">said</a>:</p>\n<blockquote>\n<p>I don't know that Rust supports those, but you're right. Another case which Rust definitely supports and which someone else mentioned, is that this doesn't work when you have pointers to overlapping slices [10..30] and [20..40]; you can't take the union of pointers in CHERI</p>\n</blockquote>\n<p>I would hope it does given C often does that and you want to be able to wrap C APIs with (unsafe) Rust FFI bindings.</p>",
        "id": 277530237,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648906762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277526928\">said</a>:</p>\n<blockquote>\n<p>Which is why I propose the \"double pointer\" approach in my position document linked just above.</p>\n<p>Privilege amplification... if you want maximally secure Rust on CHERI then you need strict provenance</p>\n</blockquote>\n<p>I don't understand what the 'double pointer' approach achieves?</p>",
        "id": 277530559,
        "sender_full_name": "RalfJ",
        "timestamp": 1648907173
    },
    {
        "content": "<p>Jessica, I checked, CHERI cannot take the union of machine integers</p>",
        "id": 277530892,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648907603
    },
    {
        "content": "<p>There‚Äôs no instruction</p>",
        "id": 277531092,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648907872
    },
    {
        "content": "<p>Ralf, besides CHERI option (2) which uses a global pointer for int2ptr (and thus allows int2ptr even when ptr2int didn‚Äôt happen), I would like a more secure option which prevents accidental int2ptr of memory that‚Äôs only touched by strict provenance code</p>",
        "id": 277531249,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908024
    },
    {
        "content": "<p>A ‚Äúkeep your fingers off my allocations‚Äù approach so that strict provenance crates actually become safer</p>",
        "id": 277531287,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908065
    },
    {
        "content": "<p>my proposals all disallow int2ptr on memory that was only touched by strict provenance</p>",
        "id": 277531294,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908077
    },
    {
        "content": "<p>int2ptr guesses an <em>exposed</em> provenance</p>",
        "id": 277531296,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908085
    },
    {
        "content": "<p>strict provenance conforming code never exposes any provenance</p>",
        "id": 277531299,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908092
    },
    {
        "content": "<p>done</p>",
        "id": 277531300,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277530892\">said</a>:</p>\n<blockquote>\n<p>Jessica, I checked, CHERI cannot take the union of machine integers</p>\n</blockquote>\n<p>Yes that's correct (and required in order to be able to implement heap temporal safety on top of CHERI)</p>",
        "id": 277531302,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908096
    },
    {
        "content": "<p>How would you prevent it at runtime though, Ralf</p>",
        "id": 277531306,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908103
    },
    {
        "content": "<p>We want a crash</p>",
        "id": 277531315,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908120
    },
    {
        "content": "<p>since when is that a goal? we dont prevent unsafe code bugs at runtime</p>",
        "id": 277531355,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908126
    },
    {
        "content": "<p>Implement a sanitiser?</p>",
        "id": 277531361,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908135
    },
    {
        "content": "<p>The goal of CHERI is to catch such things at runtime</p>",
        "id": 277531363,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908147
    },
    {
        "content": "<p>I wouldnt spend energy on making permissive provenance code work on CHERI</p>",
        "id": 277531374,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908167
    },
    {
        "content": "<p>I would like not only to compile to CHERI, but to help prevent car hacking</p>",
        "id": 277531375,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908170
    },
    {
        "content": "<p>Well it's not <em>the</em> goal of CHERI</p>",
        "id": 277531377,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908173
    },
    {
        "content": "<p>if you want CHERI, follow strict provenance</p>",
        "id": 277531380,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908178
    },
    {
        "content": "<p>That‚Äôs a radical approach</p>",
        "id": 277531385,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908189
    },
    {
        "content": "<p>it's what I have been saying for days <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277531390,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908203
    },
    {
        "content": "<p>It's what memory safety requires</p>",
        "id": 277531392,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908208
    },
    {
        "content": "<p>like it's literally <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277489704\">in my overview here</a></p>",
        "id": 277531396,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908222
    },
    {
        "content": "<p>If you don't want memory safety you can do something else, but then that goes against what CHERI stands for</p>",
        "id": 277531397,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908223
    },
    {
        "content": "<p>in Miri we can implement permissive provenance with false negatives in a way that accessing never-exposed memory with 'wildcard' provenance is still flagged</p>",
        "id": 277531464,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908311
    },
    {
        "content": "<p>so, it'd still have some false negatives but those cases it would catch</p>",
        "id": 277531479,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908338
    },
    {
        "content": "<p>I think we can do better than a binary choice between ‚Äúall permissive‚Äù and ‚Äúall strict‚Äù, and I think there will be industry demand for this</p>",
        "id": 277531480,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908340
    },
    {
        "content": "<p>But let‚Äôs not focus on option 1 then if you don‚Äôt like it</p>",
        "id": 277531482,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908353
    },
    {
        "content": "<p>It‚Äôs optional</p>",
        "id": 277531483,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908358
    },
    {
        "content": "<p>on CHERI I dont think I agree</p>",
        "id": 277531485,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908358
    },
    {
        "content": "<p>Option 1 is unimplementable on CHERI, so if your goal is CHERI compatibility it's not productive to talk about</p>",
        "id": 277531528,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908384
    },
    {
        "content": "<p>in C they did something like this by making intptr_t 128bits. but that's not an option for Rust. strict provenance is literally the proposal that was designed as the alternative to that.</p>",
        "id": 277531529,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908395
    },
    {
        "content": "<p>Jessica, I think it‚Äôs an unnecessarily radical approach. Why is it unimplementable?</p>",
        "id": 277531531,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908398
    },
    {
        "content": "<p>so, CHERI on permissive provenance is basically -- forget everything we did the last 2 weeks and reset from the start. please do that some other time. ;)</p>",
        "id": 277531540,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908418
    },
    {
        "content": "<p>I am strongly in the camp of ‚Äúlets keep all code working‚Äù, like <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> is. Even for CHERI.</p>",
        "id": 277531586,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531480\">said</a>:</p>\n<blockquote>\n<p>I think we can do better than a binary choice between ‚Äúall permissive‚Äù and ‚Äúall strict‚Äù, and I think there will be industry demand for this</p>\n</blockquote>\n<p>some sanitizers can have okay-ish support for 'mixed mode'. Miri, for example. I just dont think CHERI is one of them.</p>",
        "id": 277531596,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908480
    },
    {
        "content": "<p>I think the idea of forking the language (even just for CHERI) is leading to unnecessary conflict</p>",
        "id": 277531654,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531586\">said</a>:</p>\n<blockquote>\n<p>I am strongly in the camp of ‚Äúlets keep all code working‚Äù, like <span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> is. Even for CHERI.</p>\n</blockquote>\n<p>fair but please keep that strictly separate from the general strict provenance effort where I think this is a non-goal.<br>\nlike, literally if you solve that problem you made strict provenance unnecessary.</p>",
        "id": 277531661,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531654\">said</a>:</p>\n<blockquote>\n<p>I think the idea of forking the language (even just for CHERI) is leading to unnecessary conflict</p>\n</blockquote>\n<p>it's more like, some platforms only support a subset of the language. it's not a fork.</p>",
        "id": 277531685,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908537
    },
    {
        "content": "<p>some platforms also only have liballoc but not libstd.</p>",
        "id": 277531695,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908544
    },
    {
        "content": "<p>so while I certainly applaud your goal of superseding strict provenance, I think that is a discussion strictly separate from fleshing out the story of strict provenance itself. :)</p>",
        "id": 277531769,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908604
    },
    {
        "content": "<p>From my perspective it‚Äôs not set in stone what this ‚Äústrict provenance effort‚Äù is, sorry</p>",
        "id": 277531775,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908613
    },
    {
        "content": "<p>But I understand a desire to focus effort</p>",
        "id": 277531782,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908627
    },
    {
        "content": "<p>But I also think it‚Äôs valuable to point out potential future extensions</p>",
        "id": 277531797,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908655
    },
    {
        "content": "<p>I can add an option 3 in the document later, which is fast+secure when the whole world is strict.</p>",
        "id": 277531807,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908680
    },
    {
        "content": "<p>That seems to be what you want</p>",
        "id": 277531812,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908690
    },
    {
        "content": "<p>yeah, I think I'd like to treat permissive provenance on CHERI as more of a future extension than a part of strict provenance</p>",
        "id": 277531862,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908737
    },
    {
        "content": "<p><code>ptr as usize as u32 as usize as ptr</code> works on some architectures but not others, in a way this is just a case like that I guess</p>",
        "id": 277531867,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648908746
    },
    {
        "content": "<p>though ofc feel free to start a separate zulip thread hear that discusses this</p>",
        "id": 277531870,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908748
    },
    {
        "content": "<p>but this thread here is already a monster without expanding its scope even more like that^^</p>",
        "id": 277531878,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908768
    },
    {
        "content": "<p>and it's also confusing to have so many different things disucssed all in this thread</p>",
        "id": 277531891,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908783
    },
    {
        "content": "<p>For me, the high-prio thing is to define the language, and to enable the ecosystem to migrate</p>",
        "id": 277531896,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908793
    },
    {
        "content": "<p>well for strict provenance that is done, right? or do you think the PR landing the APIs leaves something insufficiently defined?</p>",
        "id": 277531948,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908843
    },
    {
        "content": "<p>the next step would be things like clippy lints that help ensure conformance with strict provenance (by flagging ptr2int and int2ptr casts)</p>",
        "id": 277531960,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908867
    },
    {
        "content": "<p>I think we should have alias ptr as usize and usize as ptr to specific functions for permissive provenance.</p>",
        "id": 277531984,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908915
    },
    {
        "content": "<p>As per my position</p>",
        "id": 277531994,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908933
    },
    {
        "content": "<p>sure. but as you said, that's for permissive provenance, so no effect on strict provenance conforming code.</p>",
        "id": 277532001,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908952
    },
    {
        "content": "<p>True</p>",
        "id": 277532043,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648908972
    },
    {
        "content": "<p>that's why I described this in layers in my summary</p>",
        "id": 277532045,
        "sender_full_name": "RalfJ",
        "timestamp": 1648908988
    },
    {
        "content": "<p>each layer down includes more code and is harder to spec</p>",
        "id": 277532049,
        "sender_full_name": "RalfJ",
        "timestamp": 1648909003
    },
    {
        "content": "<p>I was thinking of opening an issue and labeling it <code>A-strict provenance</code> since I actually have a valid use case that would break strict provenance, it's an intersection of embedded, LLVM buggy support for ROPI, and function pointers... But since I only have a rough understanding, I'd like to get some more minds on it first  to maybe iron out the details or discard it as non-issue, or even label it properly.<br>\n<span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531878\">said</a>:</p>\n<blockquote>\n<p>but this thread here is already a monster without expanding its scope even more like that^^</p>\n</blockquote>\n<p>should I open a separate thread then?</p>",
        "id": 277532053,
        "sender_full_name": "Francesco Dainese",
        "timestamp": 1648909021
    },
    {
        "content": "<p>I also think we should change the spec of pointer::addr because now it says that ‚Äúptr as usize‚Äù is strict. I think ‚Äúptr as usize‚Äù should remain permissive</p>",
        "id": 277532059,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648909036
    },
    {
        "content": "<p>this topic is called 'strict provenance' so one would assume it is only concerned with strict provenance conforming code. though the thread has long become a monster that talks about everything. ;) so maybe it's time to fork of some new subthreads for reamining topics. whatever those might be?</p>",
        "id": 277532063,
        "sender_full_name": "RalfJ",
        "timestamp": 1648909044
    },
    {
        "content": "<p>And I think that documentation is harmful</p>",
        "id": 277532067,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648909056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230304\">Francesco Dainese</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277532053\">said</a>:</p>\n<blockquote>\n<p>I was thinking of opening an issue and labeling it <code>A-strict provenance</code> since I actually have a valid use case that would break strict provenance, it's an intersection of embedded, LLVM buggy support for ROPI, and function pointers... But since I only have a rough understanding, I'd like to get some more minds on it first  to maybe iron out the details or discard it as non-issue, or even label it properly.<br>\n<span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277531878\">said</a>:</p>\n<blockquote>\n<p>but this thread here is already a monster without expanding its scope even more like that^^</p>\n</blockquote>\n<p>should I open a separate thread then?</p>\n</blockquote>\n<p>yes please :)</p>",
        "id": 277532068,
        "sender_full_name": "RalfJ",
        "timestamp": 1648909064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277532059\">said</a>:</p>\n<blockquote>\n<p>I also think we should change the spec of pointer::addr because now it says that ‚Äúptr as usize‚Äù is strict. I think ‚Äúptr as usize‚Äù should remain permissive</p>\n</blockquote>\n<p>hm yeah that could probably be worded better</p>",
        "id": 277532112,
        "sender_full_name": "RalfJ",
        "timestamp": 1648909107
    },
    {
        "content": "<p>Thanks :)</p>",
        "id": 277532115,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648909118
    },
    {
        "content": "<p>opened <a href=\"https://github.com/rust-lang/rust/pull/95588\">https://github.com/rust-lang/rust/pull/95588</a> to fix that</p>",
        "id": 277532761,
        "sender_full_name": "RalfJ",
        "timestamp": 1648909924
    },
    {
        "content": "<p>Does container_of-based code which casts a pointer-to-field to pointer-to-container (pipewire, maybe linux kernel) work on CHERI?</p>",
        "id": 277548526,
        "sender_full_name": "nyanpasu64",
        "timestamp": 1648929493
    },
    {
        "content": "<p>If you restrict the metadata provenance when making the inner pointer then no, so it all depends on how compilers do it. You might need to explicitly mark such areas as capable of container of operations.</p>",
        "id": 277548552,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648929583
    },
    {
        "content": "<p>But given the kernel does run on CHERI, I'd imagine they've already done the work needed.</p>",
        "id": 277548616,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648929612
    },
    {
        "content": "<p>the linux or bsd kernel?</p>",
        "id": 277548640,
        "sender_full_name": "nyanpasu64",
        "timestamp": 1648929625
    },
    {
        "content": "<p>i only hear news about the bsd kernel running on CHERI, and I do hear BSD is less keen on container_of trickery</p>",
        "id": 277548668,
        "sender_full_name": "nyanpasu64",
        "timestamp": 1648929647
    },
    {
        "content": "<p>Yeah BSD kernel, should have specified. But capability compression means that <code>container_of</code> of a few bytes isn't really a thing the architecture can stop.</p>",
        "id": 277548821,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648929848
    },
    {
        "content": "<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively \"reborrow\" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>",
        "id": 277548920,
        "sender_full_name": "nyanpasu64",
        "timestamp": 1648930007
    },
    {
        "content": "<p>Yes container_of works by default with CHERI. However we have a more strict compilation mode (using a -cheri-bounds compiler flag) to narrow the bounds for subobjects. If you use that mode (we enable it for the FreeBSD kernel), you have to annotate fields that are used with container_of to opt-out of the bounds narrowing</p>",
        "id": 277550491,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648932035
    },
    {
        "content": "<p>It doesn't break too much code enabling that flag by default but it is an additional porting cost so we don't do it by default. Chapter 5 of <a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf\">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf</a> has a lot more details on it</p>",
        "id": 277550599,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648932188
    },
    {
        "content": "<p>There is definitely quite a lot of container_of  in the FreeBSD kernel but since you only have to annotate the structures rather than each call site the number of changes is very small</p>",
        "id": 277550677,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648932303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257532\">nyanpasu64</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277548920\">said</a>:</p>\n<blockquote>\n<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively \"reborrow\" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>\n</blockquote>\n<p>I think that would be too permissive. the proposal I have been floating around means int-to-ptr can generate pointers that can do <em>anything that a pointer that was previously cast to an int can do</em>. specifically, each int-to-ptr cast has to pick a <em>specific</em> other pointer that it gets the provenance from. you don't get to say \"it's like pointer X here and like pointer Y there\". yes this means that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>are <em>not equivalent</em>. FWIW this is also the case in PNVI-ae-udi.</p>",
        "id": 277633331,
        "sender_full_name": "RalfJ",
        "timestamp": 1648994979
    },
    {
        "content": "<p>Another thing regarding subobject provenance: it looks like LLVM will get intrinsics to restrict the accessible range for  subobjects in the near future: <a href=\"https://reviews.llvm.org/D115274\">https://reviews.llvm.org/D115274</a>, so if rust wants to go down that route upcoming versions of llvm may give better optimizations</p>",
        "id": 277640785,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648999072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277633331\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257532\">nyanpasu64</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277548920\">said</a>:</p>\n<blockquote>\n<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively \"reborrow\" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>\n</blockquote>\n<p>I think that would be too permissive. the proposal I have been floating around means int-to-ptr can generate pointers that can do <em>anything that a pointer that was previously cast to an int can do</em>. specifically, each int-to-ptr cast has to pick a <em>specific</em> other pointer that it gets the provenance from. you don't get to say \"it's like pointer X here and like pointer Y there\". yes this means that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>are <em>not equivalent</em>. FWIW this is also the case in PNVI-ae-udi.</p>\n</blockquote>\n<p>That would mean that \"slice-merging\" still can not be done, right?</p>",
        "id": 277651507,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1649007538
    },
    {
        "content": "<p>Doesn't that mean you could expose the original provenance of the slice, then when merging do a ptr-int-ptr cast and select the provenance of the original slice?<br>\nI suppose my question is if you can just pull the provenance out of ethereal AM state, or if you need to carry around a pointer to transmit the original provenance, which is what you need to do currently to merge slices.</p>",
        "id": 277652660,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649008949
    },
    {
        "content": "<blockquote>\n<p>That would mean that \"slice-merging\" still can not be done, right?</p>\n</blockquote>\n<p>correct.</p>",
        "id": 277653485,
        "sender_full_name": "RalfJ",
        "timestamp": 1649010089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277652660\">said</a>:</p>\n<blockquote>\n<p>Doesn't that mean you could expose the original provenance of the slice, then when merging do a ptr-int-ptr cast and select the provenance of the original slice?<br>\nI suppose my question is if you can just pull the provenance out of ethereal AM state, or if you need to carry around a pointer to transmit the original provenance, which is what you need to do currently to merge slices.</p>\n</blockquote>\n<p>you currently cannot merge slices so I am confused^^</p>",
        "id": 277653492,
        "sender_full_name": "RalfJ",
        "timestamp": 1649010118
    },
    {
        "content": "<p>but I hope the docs I just added in <a href=\"https://github.com/rust-lang/rust/issues/95588\">#95588</a> answer your question. :)</p>",
        "id": 277653534,
        "sender_full_name": "RalfJ",
        "timestamp": 1649010139
    },
    {
        "content": "<p>Yes, they do :)<br>\nI was basically referring to using a manual <code>with_addr</code>, which I did a few times before the strict provenance features appeared</p>",
        "id": 277655510,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649012737
    },
    {
        "content": "<p>Realistically most code sites will be possible to fix by a MachineApplicable rustfix.</p>",
        "id": 277662338,
        "sender_full_name": "Jubilee",
        "timestamp": 1649021817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277633331\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257532\">nyanpasu64</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277548920\">said</a>:</p>\n<blockquote>\n<p>Also was thinking about ways to (on non-CHERI architectures) preserve current Rust int-to-ptr semantics, and perform <em>most</em> optimizations soundly, without requiring alias analysis or provenance to implement safely. Perhaps int-to-ptr casts can generate pointers allowed to immutably alias all &amp; or <code>*const/*mut</code> types, and write through all <code>*const/*mut</code> and also &amp;T with interior mutability? And additionally &amp;mut-to-int casts effectively \"reborrow\" the &amp;mut, producing an integer which is legal to cast to pointer and use until the &amp;mut is next accessed (at which point the &amp;mut's user is required to reload the backing memory since it might've been modified)?</p>\n</blockquote>\n<p>I think that would be too permissive. the proposal I have been floating around means int-to-ptr can generate pointers that can do <em>anything that a pointer that was previously cast to an int can do</em>. specifically, each int-to-ptr cast has to pick a <em>specific</em> other pointer that it gets the provenance from. you don't get to say \"it's like pointer X here and like pointer Y there\". yes this means that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr1</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>are <em>not equivalent</em>. FWIW this is also the case in PNVI-ae-udi.</p>\n</blockquote>\n<p>Why do you consider my idea too permissive, and what negative effects do you consider unacceptable? (Though both this idea and my dream language are closer to being a \"portable assembly\", and Rust is explicitly not setting out to be one.)</p>",
        "id": 277839883,
        "sender_full_name": "nyanpasu64",
        "timestamp": 1649145281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257532\">@nyanpasu64</span> <br>\nyour idea means that we can no longer pretend that <code>ptr2int</code> and <code>int2ptr</code> are just FFI calls that the compiler cannot 'look into'. this is a valid compilation strategy for my proposal: pretend that int2ptr casts <em>do not exist</em> and justify all your optimizations without even taking those into account, and then add support for <code>ptr2int</code> (aka <code>expose_addr</code>) and <code>int2ptr</code> (aka <code>from_exposed_addr</code>) by just making them \"opaque foreign functions\" to the compiler. this has the great benefit that code which does not use these operations can be aggressively optimized as if the operations did not exist (which is basically how LLVM compiles code today!). in other words, supporting these casts has a <em>purely local</em> cost, that is paid only by code that uses them.</p>\n<p>with your proposal, this no longer works, so I am fairly sure that your proposal puts a <em>global</em> cost on all code by making it harder to optimize even code that does not use them.</p>",
        "id": 277918439,
        "sender_full_name": "RalfJ",
        "timestamp": 1649181242
    },
    {
        "content": "<p>Gankra has published a blog post: <a href=\"https://gankra.github.io/blah/tower-of-weakenings/\">https://gankra.github.io/blah/tower-of-weakenings/</a></p>",
        "id": 277957414,
        "sender_full_name": "bstrie",
        "timestamp": 1649200991
    },
    {
        "content": "<p>I‚Äôm reading through all the strict provenance docs and I can‚Äôt see how we‚Äôre supposed to create pointers out of thin air under it. Example of why I want/need to do this: on an embedded microcontroller there will be a peripheral located at some address X. I don‚Äôt have a preexisting pointer with the provenance of that peripheral. So I cant use <code>with_addr</code>. What is the solution for this class of issue?</p>",
        "id": 278210028,
        "sender_full_name": "Zoey",
        "timestamp": 1649357725
    },
    {
        "content": "<p>The answer might just be you're at the <a href=\"https://gankra.github.io/blah/tower-of-weakenings/\">bottom of the tower</a> in those cases, using some target-specific magic.  And you just <strong>can't</strong> use the <em>strict</em> version of all this for that use case.</p>\n<p>To get a few floors above the ground (albeit still not to the top), it might be possible to make a model like \"your target has implicitly <em>exposed</em> a few addresses as part of starting your executable\", and thus you can use <code>ptr::from_exposed_addr</code> on those pre-exposed addresses.</p>\n<p>But I think the best solution is change your model so that you don't think \"I have a peripheral at a know address\" at any point when writing rust code.  To me, that seems like artificial specificity.  <em>To your Rust code</em>, you <em>could</em> be strict about the provenance if, say, you wrote everything against an <code>extern \"magic\" { static FOO: Foo; }</code>.  Then the \"it's at a specific address\" part would be dealt with not in Rust at all, but at a ground-floor-of-the-tower thing like a linker script to force that <code>static</code> to be in a particular place for the concrete machine.</p>",
        "id": 278214050,
        "sender_full_name": "scottmcm",
        "timestamp": 1649359406
    },
    {
        "content": "<p>Hmm. I guess that makes sense. I‚Äôll play around with linkers to see if I can create statics to <code>*mut Foo</code> of the peripherals I need</p>",
        "id": 278214473,
        "sender_full_name": "Zoey",
        "timestamp": 1649359628
    },
    {
        "content": "<p>My mind is pretty warped on what UB is by all the embedded magic that happens on microcontrollers.</p>",
        "id": 278214549,
        "sender_full_name": "Zoey",
        "timestamp": 1649359679
    },
    {
        "content": "<p>Strict provenance is not so much about UB. It's about seeing if we can ruthlessly cut things away so that we can have a simple model. In reality, to ship all the software we want to, we probably can't make the simple model be The Model.</p>\n<p>The messy model has a carve-out for magicking up a pointer to any memory that you are absolutely certain will never be part of your normal memory. This is of course difficult/impossible to validate. Thus, the desire to write code against a simpler one.</p>",
        "id": 278218354,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649361561
    },
    {
        "content": "<p>So if you can't do the magic static, you can still be free from UB, you'll just be much more on your own with that.</p>",
        "id": 278218543,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649361620
    },
    {
        "content": "<blockquote>\n<p>Strict provenance is not so much about UB. It's about seeing if we can ruthlessly cut things away so that we can have a simple model. In reality, to ship all the software we want to, we probably can't make the simple model be The Model.</p>\n</blockquote>\n<p>Not alone, especially not now because we already have non-conforming code, but the strictness of <code>addr()</code>/<code>with_addr()</code> <em>can</em> be exploited for optimizations.</p>",
        "id": 278235082,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649370741
    },
    {
        "content": "<p><em>can</em> be, but I do not think it will be</p>",
        "id": 278235276,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649370873
    },
    {
        "content": "<p>Why not? Provenance is a nightmare for compiler developers, they'll be happy to get rid of it as much as they can.</p>",
        "id": 278237857,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649372782
    },
    {
        "content": "<p>Anyway, it is clearly stated that breaking the rules is UB:</p>\n<p><code>ptr::addr()</code>:</p>\n<blockquote>\n<p>However, unlike self as usize, casting the returned address back to a pointer yields <code>invalid</code>, which is undefined behavior to dereference.</p>\n</blockquote>\n<p><code>ptr::with_addr()</code>(though I think we need to be more clear):</p>\n<blockquote>\n<p>This is equivalent to using <code>wrapping_offset</code> to offset self to the given address, and therefore has all the same capabilities and restrictions.</p>\n</blockquote>\n<p>And in the <code>wrapping_offset()</code> docs:</p>\n<blockquote>\n<p>The resulting pointer ‚Äúremembers‚Äù the allocated object that <code>self</code> points to; it must not be used to read or write other allocated objects.</p>\n</blockquote>",
        "id": 278238124,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649373014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"491181\">Zoey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/278210028\">said</a>:</p>\n<blockquote>\n<p>What is the solution for this class of issue?</p>\n</blockquote>\n<p>I wouldn't be worried. Provenance etc. is about making it illegal to guess the address of a local variable. Nobody wants to take your ability to use memory-mapped I/O.</p>\n<p>In due time, we should complete the narrative though so that this is <em>documented</em>.</p>",
        "id": 278238472,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649373292
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"340138\">@Chayim Refael Friedman</span> Strict Provenance is an experiment, and none of it is normative over the language. If we taught the compiler backend about the library contracts, sure, it could be exploited for optimizations. But it won't be baked into the language because even Stacked Borrows all on its own declares so much code UB that I do not think that a vastly stricter model has a chance of being used by an optimizer.</p>\n<p>The reason it <em>won't</em> be has been discussed to death in this very topic. There is a lot of code that does not conform to strict provenance, and there is no known way to draw boundaries for an optimizer to prevent non-strict-provenance code from being miscompiled. If nothing else, LTO and particularly cross-language LTO destroy even crate boundaries.</p>",
        "id": 278239976,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649374549
    },
    {
        "content": "<p>I think the precise behavior should be well-documented though. Because I suspect <code>int as ptr</code> will be redefined as <code>from_exposed_addr</code>, and MMIO addresses were never explicitly exposed from Rust</p>",
        "id": 278240175,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649374693
    },
    {
        "content": "<blockquote>\n<p>Strict Provenance is an experiment, and none of it is normative over the language.</p>\n</blockquote>\n<p>Of course I was talking only about the case we'll decide we want it as part of the language.</p>\n<blockquote>\n<p>But it won't be baked into the language because even Stacked Borrows all on its own declares so much code UB that I do not think that a vastly stricter model has a chance of being used by an optimizer.</p>\n</blockquote>\n<p>But this is not just a model: this is a library API. This is something SB cannot handle alone, because it doesn't have the required information to restore provenance and has to assume things like PNVI.</p>\n<blockquote>\n<p>There is a lot of code that does not conform to strict provenance</p>\n</blockquote>\n<p>This is why we have <code>expose_addr()</code> and <code>from_exposed_addr()</code> (or <code>as</code> casts which are less clear about the intention but do the same). Do you think optimizing solely based on <code>addr()</code>/<code>with_addr()</code> calls will break existing code?</p>",
        "id": 278240460,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649374953
    },
    {
        "content": "<p>Optimizing just based on those function calls would be fine, but I do not think it is likely to ever optimize based on those function calls.</p>",
        "id": 278243542,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649377591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"491181\">Zoey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/278210028\">said</a>:</p>\n<blockquote>\n<p>I‚Äôm reading through all the strict provenance docs and I can‚Äôt see how we‚Äôre supposed to create pointers out of thin air under it. Example of why I want/need to do this: on an embedded microcontroller there will be a peripheral located at some address X. I don‚Äôt have a preexisting pointer with the provenance of that peripheral. So I cant use <code>with_addr</code>. What is the solution for this class of issue?</p>\n</blockquote>\n<p>In the world of CHERI, there's always a capability covering the whole address space at CPU reset (currently it's in both the default data capability (DDC) and program counter capability (PCC) registers). In early startup, the kernel will save (and probably subdivide) that capability for later use for things like creating a pointer to MMIO regions.<br>\nFor example, in CheriBSD we carve it into user space, kernel, device space, etc in <code>cheri_init_capabilities()</code> which is called from <code>_start()</code> <a href=\"https://github.com/CTSRD-CHERI/cheribsd/blob/2681a143af26941d54997cfd47e645dcdfbdf3ea/sys/arm64/cheri/cheri_machdep.c#L49\">https://github.com/CTSRD-CHERI/cheribsd/blob/2681a143af26941d54997cfd47e645dcdfbdf3ea/sys/arm64/cheri/cheri_machdep.c#L49</a><br>\nI'd expect that if strict provenance became the default you'd expose this mechanism as a bit of (effectively no-op) magic at the bottom of the target implementations.</p>",
        "id": 278324929,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649433621
    },
    {
        "content": "<p>There was some discussion towards the beginning about an API that acts like <code>malloc</code> but claims some memory with a specified address that is not otherwise used by rust, which would be usable by things like MMIO. I think it was called <code>fake_alloc</code>? It got dropped from the version of strict provenance that made it to nightly, but I would like to see it come back in some form, because I do think we need a better story for these kinds of allocations in strict provenance</p>",
        "id": 278330140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649435936
    }
]