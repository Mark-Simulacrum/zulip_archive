[
    {
        "content": "<p>Some people think we are worse than C when it comes to unions :(<br>\n<a href=\"https://www.reddit.com/r/rust/comments/c5w36i/brave_browser_from_the_inventor_of_javascript/es6vpdd/\" target=\"_blank\" title=\"https://www.reddit.com/r/rust/comments/c5w36i/brave_browser_from_the_inventor_of_javascript/es6vpdd/\">https://www.reddit.com/r/rust/comments/c5w36i/brave_browser_from_the_inventor_of_javascript/es6vpdd/</a></p>",
        "id": 169291602,
        "sender_full_name": "RalfJ",
        "timestamp": 1561803889
    },
    {
        "content": "<p>they cite in particular <a href=\"https://rust-lang.github.io/rfcs/1444-union.html#unions-and-undefined-behavior\" target=\"_blank\" title=\"https://rust-lang.github.io/rfcs/1444-union.html#unions-and-undefined-behavior\">https://rust-lang.github.io/rfcs/1444-union.html#unions-and-undefined-behavior</a> as evidence for Rust tracking an \"active field\" of a union. may ewe could improve the wording there?</p>",
        "id": 169291612,
        "sender_full_name": "RalfJ",
        "timestamp": 1561803912
    },
    {
        "content": "<p>what does the nomicon say ?</p>",
        "id": 169294014,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561808918
    },
    {
        "content": "<p>AFAICT it's not worth it to update those RFCs, they are historic documents</p>",
        "id": 169294017,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561808936
    },
    {
        "content": "<p>the RFCs get merged into the reference, and that's maintained, so if anything, update the reference / nomicon</p>",
        "id": 169294029,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561808954
    },
    {
        "content": "<blockquote>\n<p>AFAICT it's not worth it to update those RFCs, they are historic documents</p>\n</blockquote>\n<p>I am not sure if that is really clear to everyone</p>",
        "id": 169294308,
        "sender_full_name": "RalfJ",
        "timestamp": 1561809467
    },
    {
        "content": "<p>also the RFC there is not outdated, just badly worded</p>",
        "id": 169294310,
        "sender_full_name": "RalfJ",
        "timestamp": 1561809476
    },
    {
        "content": "<p>the nomicon does not have a section on unions</p>",
        "id": 169294354,
        "sender_full_name": "RalfJ",
        "timestamp": 1561809496
    },
    {
        "content": "<p>we have updated RFCs in the past</p>",
        "id": 169294581,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561809925
    },
    {
        "content": "<p>but bandwidth-wise if the feature is already in the reference / nomicon it's often most worth it to update it there</p>",
        "id": 169294589,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561809960
    },
    {
        "content": "<p>Most people just check the RFCs. It needs to be communicated better that the Reference is the actual authority.</p>",
        "id": 169300389,
        "sender_full_name": "Lokathor",
        "timestamp": 1561819704
    },
    {
        "content": "<p>we <em>did</em> put this into the reference though: <a href=\"https://doc.rust-lang.org/stable/reference/items/unions.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/stable/reference/items/unions.html\">https://doc.rust-lang.org/stable/reference/items/unions.html</a></p>",
        "id": 169302230,
        "sender_full_name": "RalfJ",
        "timestamp": 1561823015
    },
    {
        "content": "<blockquote>\n<p>Unions have no notion of an \"active field\".</p>\n</blockquote>",
        "id": 169302235,
        "sender_full_name": "RalfJ",
        "timestamp": 1561823026
    },
    {
        "content": "<blockquote>\n<p>Most people just check the RFCs. It needs to be communicated better that the Reference is the actual authority.</p>\n</blockquote>\n<p>I don't think we have any data about what most people check. But if I had to guess, I'd guess that most people check the book, then the libstd API docs, then nomicon, then reference, and only few people check RFCs (this group might still be hundreds of people though).</p>",
        "id": 169303835,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561825942
    },
    {
        "content": "<blockquote>\n<p>we did put this into the reference </p>\n</blockquote>\n<p>So the main unanswered question IMO is \"why do some users go to the union RFC to learn the feature instead of going to the reference?\".</p>",
        "id": 169303852,
        "sender_full_name": "gnzlbg",
        "timestamp": 1561826013
    },
    {
        "content": "<p>Hot take: people check whatever comes up as the first result on google.</p>",
        "id": 169305063,
        "sender_full_name": "Shnatsel",
        "timestamp": 1561828169
    },
    {
        "content": "<p>Which may be any of these resources depending on the query.</p>",
        "id": 169305115,
        "sender_full_name": "Shnatsel",
        "timestamp": 1561828217
    },
    {
        "content": "<p>the reference has a disclaimer: \"this is all WIP\" etc. maybe the rendered RFCs should have similar disclaimer?</p>",
        "id": 169305199,
        "sender_full_name": "RalfJ",
        "timestamp": 1561828390
    },
    {
        "content": "<p>the way it looks now, I'd rather trust the RFC than the ref, as the RFC does not come with any kind of disclaimer^^</p>",
        "id": 169305212,
        "sender_full_name": "RalfJ",
        "timestamp": 1561828427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I know you put it in the Reference, my point is that people don't <em>read</em> the reference much so they won't know what you put in it.</p>\n<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> my data is anecdotal at best, but I've generally seen people in Discord cite <a href=\"http://docs.rs\" target=\"_blank\" title=\"http://docs.rs\">docs.rs</a> and RFCs, but I've honestly never seen people cite the Reference.</p>\n<blockquote>\n<p>why don't users go to the reference?</p>\n</blockquote>\n<p>I would also guess that it's because of the big red disclaimer. I have never trusted the reference and basically immediately close the tab if a page sends me there.</p>\n<p>That disclaimer needs to go, and as soon as possible, if you want people to trust the Reference. That's my take</p>",
        "id": 169308536,
        "sender_full_name": "Lokathor",
        "timestamp": 1561835085
    },
    {
        "content": "<p>funny enough, the nomicon does not have such a disclaimer^^</p>",
        "id": 169308842,
        "sender_full_name": "RalfJ",
        "timestamp": 1561835681
    },
    {
        "content": "<p>so I tend to agree, the reference disclaimer is a bit over-the-top, at least compared to what we do in other \"books\"</p>",
        "id": 169308851,
        "sender_full_name": "RalfJ",
        "timestamp": 1561835708
    },
    {
        "content": "<blockquote>\n<p>That disclaimer needs to go, and as soon as possible, if you want people to trust the Reference. That's my take</p>\n</blockquote>\n<p>But we don't want people to trust the reference because it is not normative</p>",
        "id": 169337879,
        "sender_full_name": "centril",
        "timestamp": 1561897108
    },
    {
        "content": "<p>The problem with people not trusting the Reference is that people end up not trusting the Reference</p>",
        "id": 169344086,
        "sender_full_name": "Lokathor",
        "timestamp": 1561908880
    },
    {
        "content": "<p>well the problem is that they trust something else, something that's not really any more normative or up-to-date or accurate than the reference</p>",
        "id": 169344147,
        "sender_full_name": "RalfJ",
        "timestamp": 1561909012
    },
    {
        "content": "<p>I don't think most people want documents that are normative now <em>and forever</em>. I think they usually want best effort descriptions of how things currently work even if it changes later.</p>",
        "id": 169344282,
        "sender_full_name": "Lokathor",
        "timestamp": 1561909303
    },
    {
        "content": "<p>Being set in stone forever is nice and all, but it takes a while to get there (and that's okay).</p>",
        "id": 169344332,
        "sender_full_name": "Lokathor",
        "timestamp": 1561909356
    },
    {
        "content": "<p>I emphatically do not want people to rely on whatever best effort non-normative things we say in the reference, in the UCG, or anywhere else. This ties our hands because eventually someone says \"there's too much code to break\".</p>",
        "id": 169362754,
        "sender_full_name": "centril",
        "timestamp": 1561946049
    },
    {
        "content": "<p>Explicit non-guarantees are a good thing tho</p>",
        "id": 169362757,
        "sender_full_name": "centril",
        "timestamp": 1561946085
    },
    {
        "content": "<p>as well as the compiler aggressively taking advantage of unspecified behavior as if it were UB</p>",
        "id": 169362769,
        "sender_full_name": "centril",
        "timestamp": 1561946114
    },
    {
        "content": "<blockquote>\n<p>as well as the compiler aggressively taking advantage of unspecified behavior as if it were UB</p>\n</blockquote>\n<p>that's not at all easy</p>",
        "id": 169413628,
        "sender_full_name": "RalfJ",
        "timestamp": 1562001751
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  note that C does not have the notion of an active field - only C++ has that</p>",
        "id": 169413678,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562001804
    },
    {
        "content": "<p>are you sure? C also needs to rule out type-punning through unions unless the compiler can \"see\" that there is a union involved</p>",
        "id": 169413805,
        "sender_full_name": "RalfJ",
        "timestamp": 1562001897
    },
    {
        "content": "<p>there's that weird clause about only doing union-based type punning if the union is \"in scope\" or so. doesnt that require tracking the \"active field\" to define precisely?</p>",
        "id": 169414122,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002178
    },
    {
        "content": "<p>C allows type punning through unions</p>",
        "id": 169414233,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002249
    },
    {
        "content": "<p>only in very specific ways</p>",
        "id": 169414259,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002276
    },
    {
        "content": "<p>just wrote this up the other day so I still have the example :D</p>",
        "id": 169414280,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002298
    },
    {
        "content": "<p>this is UB in C:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">float</span> <span class=\"nf\">transmute_int_to_float_inner</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">float</span> <span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// In a different file</span>\n\n<span class=\"k\">union</span> <span class=\"n\">TypePun</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"kt\">float</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">float</span> <span class=\"nf\">transmute_int_to_float</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">union</span> <span class=\"n\">TypePun</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">transmute_int_to_float_inner</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 169414285,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002306
    },
    {
        "content": "<p>it has to be UB, or else type-based alias analysis does not work</p>",
        "id": 169414287,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002313
    },
    {
        "content": "<p><a href=\"https://port70.net/~nsz/c/c11/n1570.html#note95\" target=\"_blank\" title=\"https://port70.net/~nsz/c/c11/n1570.html#note95\">https://port70.net/~nsz/c/c11/n1570.html#note95</a></p>",
        "id": 169414335,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002330
    },
    {
        "content": "<p>\"Warning: Potential Security Risk Ahead\"</p>",
        "id": 169414343,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002338
    },
    {
        "content": "<p>looks like they are still using GeoTrust certs</p>",
        "id": 169414371,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002370
    },
    {
        "content": "<p>which means their admin hasnt checked their setup for many months. <em>that's</em> the real security risk^^</p>",
        "id": 169414383,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002382
    },
    {
        "content": "<p>C does not have type-based alias analysis</p>",
        "id": 169414389,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002385
    },
    {
        "content": "<p>uh. what? yes it does.</p>",
        "id": 169414400,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002394
    },
    {
        "content": "<p>only C++ has that</p>",
        "id": 169414401,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002395
    },
    {
        "content": "<p>that's what all the effective type stuff is for</p>",
        "id": 169414411,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002405
    },
    {
        "content": "<p>I am very sure that GCC and clang both to TBAA in C</p>",
        "id": 169414432,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002429
    },
    {
        "content": "<p>ah yes, you are right, i'm misremembering</p>",
        "id": 169414436,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002431
    },
    {
        "content": "<p>so yes, that code is UB in C</p>",
        "id": 169414495,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002449
    },
    {
        "content": "<p>those two pointers can be assumed not to alias</p>",
        "id": 169414503,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002458
    },
    {
        "content": "<p>but that is kind of unrelated to type punning - C does support type punning, but your example has a TBAA violation</p>",
        "id": 169414545,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002497
    },
    {
        "content": "<p>TBAA works by forbidding type punning :D</p>",
        "id": 169414575,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002525
    },
    {
        "content": "<p>see see <a href=\"https://stackoverflow.com/questions/34616086/union-punning-structs-w-common-initial-sequence-why-does-c-99-but-not/34641113\" target=\"_blank\" title=\"https://stackoverflow.com/questions/34616086/union-punning-structs-w-common-initial-sequence-why-does-c-99-but-not/34641113\">https://stackoverflow.com/questions/34616086/union-punning-structs-w-common-initial-sequence-why-does-c-99-but-not/34641113</a></p>",
        "id": 169414582,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002530
    },
    {
        "content": "<p>In repr(Rust) union that doesn't work either, because creating a reference to a field would be an error - and you need to do that to figure the field offsets</p>",
        "id": 169414590,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002544
    },
    {
        "content": "<p>the standard basically says that type punning through unions only works if the union is \"visible\"</p>",
        "id": 169414593,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002549
    },
    {
        "content": "<p>nobody knows what that means</p>",
        "id": 169414599,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002552
    },
    {
        "content": "<p>so repr(Rust) unions don't support type punning at all</p>",
        "id": 169414606,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002557
    },
    {
        "content": "<p>that's entirely off-topic as the reasons are unrelated</p>",
        "id": 169414659,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002574
    },
    {
        "content": "<p>C supports type punning by using the union as a transmute</p>",
        "id": 169414663,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002580
    },
    {
        "content": "<p><code>union U { t }.v </code></p>",
        "id": 169414673,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002597
    },
    {
        "content": "<p>the common interpretation of the \"visible\" thing is that you need to do something like <code>u.f</code> or so for the type-changing access -- the place needs to be computed \"through\" the union type</p>",
        "id": 169414687,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002613
    },
    {
        "content": "<p>exactly</p>",
        "id": 169414699,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002624
    },
    {
        "content": "<p>but that's a very restricted form of union-based type punning</p>",
        "id": 169414709,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002631
    },
    {
        "content": "<p>the moment you take a pointer, you're out</p>",
        "id": 169414714,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002640
    },
    {
        "content": "<p>not always</p>",
        "id": 169414733,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002656
    },
    {
        "content": "<p>if there would be an agreed-upon operational semantics for C, that could be made precise; the standard weasels its way around that with this \"visible\" rule</p>",
        "id": 169414740,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002662
    },
    {
        "content": "<p>but saying \"TBAA violation\" is the wrong way around. you have to <em>prove TBAA correct</em> by deriving it from what the standard says about effective types.</p>",
        "id": 169414791,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002683
    },
    {
        "content": "<p>and effective types are not enough with unions, because of that clause that says that unions re-interpret the storage at the type used for reading. so this needs to be restricted to enable TBAA.</p>",
        "id": 169414827,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002716
    },
    {
        "content": "<p>Let's make your example a bit worse:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">float</span> <span class=\"nf\">transmute_int_to_float_inner</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"k\">union</span> <span class=\"n\">TypePun</span><span class=\"o\">*</span> <span class=\"n\">u</span><span class=\"p\">,</span>  <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">float</span> <span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Can the compiler assume that <code>u</code> and e.g. <code>x</code> do not alias?</p>",
        "id": 169414861,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002749
    },
    {
        "content": "<p>I'd say so, because they have different types.</p>",
        "id": 169414885,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002772
    },
    {
        "content": "<p>C++ does it with active fields. C does it with a \"visible\" rule that is imprecise. a strict reading of the standard would make my code above okay if its all in one file as the union <em>type</em> is \"visible\" everywhere.</p>",
        "id": 169414895,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002778
    },
    {
        "content": "<p>i'm much more familiar with the C++ standard than with the C standard</p>",
        "id": 169414983,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562002806
    },
    {
        "content": "<p>I mean this discussion is not really interesting for Rust anyway^^ Rust doesnt need any of this mess of a \"visible\" rule or an active field because we dont want TBAA</p>",
        "id": 169415039,
        "sender_full_name": "RalfJ",
        "timestamp": 1562002852
    },
    {
        "content": "<p>Not having TBAA removes many headaches</p>",
        "id": 169415220,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003006
    },
    {
        "content": "<p>But not all of them</p>",
        "id": 169415306,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003048
    },
    {
        "content": "<p>For example, given:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">union</span> <span class=\"nc\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">SmallType</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">LargeType</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">LargeType</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">SmallType</span><span class=\"o\">&gt;</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">u</span>: <span class=\"nc\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">SmallType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">LargeType</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Is that ok ? I mean, technically the storage is there, but <code>*mut u8</code> was derived from a <code>&amp;mut SmallType</code>, and its accessing memory OOB of <code>SmallType</code>. Do we want to optimize based on that not happening?</p>",
        "id": 169415382,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003129
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 169415399,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003152
    },
    {
        "content": "<p>Stacked Borrows says this is NOT okay because when casting a mutable ref to a raw ptr, only the bytes that this ref actually points to become \"raw-accessible\"</p>",
        "id": 169415676,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003337
    },
    {
        "content": "<p>In C++ this is not ok either.</p>",
        "id": 169415698,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003353
    },
    {
        "content": "<p>this is tracked at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a></p>",
        "id": 169415723,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003368
    },
    {
        "content": "<p>I dont know yet if this is practical, but relaxing it has to be done very carefully or else it will destroy optimizations</p>",
        "id": 169415741,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003385
    },
    {
        "content": "<p>There I had to cast it to an <code>u8</code>, but I can make <code>SmallType == u8</code>, and then it's kind of a bit less obvious.</p>",
        "id": 169415744,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003389
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">union</span> <span class=\"nc\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">LargeType</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">LargeType</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">u</span>: <span class=\"nc\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">SmallType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">LargeType</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169415806,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003410
    },
    {
        "content": "<p>no, you should cast the <em>union ptr</em> to raw</p>",
        "id": 169415827,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003428
    },
    {
        "content": "<p>then you can use that for either field</p>",
        "id": 169415831,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003432
    },
    {
        "content": "<p>Yeah, I know, but it looks like an easy error to make.</p>",
        "id": 169415835,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003445
    },
    {
        "content": "<p>And then you get UB.</p>",
        "id": 169415837,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003449
    },
    {
        "content": "<p>indeed, that's why I opened that issue</p>",
        "id": 169415947,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003525
    },
    {
        "content": "<p>If we want to be able to use <code>getelementptr</code> with <code>inbounds</code> I don't see how to avoid being strict there.</p>",
        "id": 169416220,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003751
    },
    {
        "content": "<p>hu?  dont see the connection</p>",
        "id": 169416278,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003764
    },
    {
        "content": "<p>we could just say \"it makes the entire allocation accessible to raw ptr\"</p>",
        "id": 169416304,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003776
    },
    {
        "content": "<p>the hard part is not destroying reference-based reorderings</p>",
        "id": 169416315,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003785
    },
    {
        "content": "<p>I mean, the reason this rule exists in C++ is to allow using <code>getelementptr</code> with <code>inbounds</code></p>",
        "id": 169416340,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003807
    },
    {
        "content": "<p>I thought that was the optimization that you had in mind. Was it something else?</p>",
        "id": 169416380,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003828
    },
    {
        "content": "<blockquote>\n<p>I mean, the reason this rule exists in C++ is to allow using <code>getelementptr</code> with <code>inbounds</code></p>\n</blockquote>\n<p>which rule?</p>",
        "id": 169416397,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003844
    },
    {
        "content": "<p>That a pointer to an object (or sub-object) can only point to the addresses in range of <code>[object_addr, object_addr + size + 1]</code>.</p>",
        "id": 169416503,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003885
    },
    {
        "content": "<blockquote>\n<p>I thought that was the optimization that you had in mind. Was it something else?</p>\n</blockquote>\n<p>something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">))</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// lots of code, using raw, but not using x.</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// can be optimized to: return 14;</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 169416550,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003911
    },
    {
        "content": "<blockquote>\n<p>That a pointer to an object (or sub-object) can only point to the addresses in range of <code>[object_addr, object_addr + size + 1]</code>.</p>\n</blockquote>\n<p>if they would allow it to \"snap\" to a surrounding union, that would still permit <code>inbounds</code></p>",
        "id": 169416613,
        "sender_full_name": "RalfJ",
        "timestamp": 1562003950
    },
    {
        "content": "<p>I mean, that optimization is doable because you assume that <code>raw</code> cannot be used to access x.0</p>",
        "id": 169416624,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003957
    },
    {
        "content": "<p>typically this is done by assuming that raw can only be used to access <code>x.1</code></p>",
        "id": 169416658,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562003976
    },
    {
        "content": "<p>C++ just forbids all pointer arithmetic that results in a pointer address that's not inbounds of x.1</p>",
        "id": 169416721,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004003
    },
    {
        "content": "<p>I wasnt aware C++ forbids this. LLVM allows it.</p>",
        "id": 169416771,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004024
    },
    {
        "content": "<p>it supports the one-past-end rule, so that you can write `for (; ptr != one_past_end; ++ptr)</p>",
        "id": 169416781,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004028
    },
    {
        "content": "<p>I think de-facto-C++ will have to allow it too</p>",
        "id": 169416806,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004044
    },
    {
        "content": "<p>LLVM allows it, unless you use <code>getlementptr inbounds</code></p>",
        "id": 169416807,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004044
    },
    {
        "content": "<p>I would expect many people will do something like \"take address of first element of an array / vector / whatever, and use that to access other elements\"</p>",
        "id": 169416832,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004064
    },
    {
        "content": "<blockquote>\n<p>LLVM allows it, unless you use <code>getlementptr inbounds</code></p>\n</blockquote>\n<p>that is incorrect</p>",
        "id": 169416854,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004075
    },
    {
        "content": "<p><code>inbounds</code> referes to the bounds <em>of the allocation</em></p>",
        "id": 169416863,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004081
    },
    {
        "content": "<p>not of the subobject that you are indexing into</p>",
        "id": 169416884,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004094
    },
    {
        "content": "<p>LLVM allows this <em>with <code>inbounds</code></em></p>",
        "id": 169416891,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004104
    },
    {
        "content": "<p>hmmm, am i misremembereing again ?</p>",
        "id": 169417008,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004191
    },
    {
        "content": "<p>does <code>inbounds</code> allow passing a size ? one option does not, but another option does, let me look</p>",
        "id": 169417032,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <code>inrange &lt;ty&gt; idx</code></p>",
        "id": 169417132,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004284
    },
    {
        "content": "<blockquote>\n<p>If the inrange keyword is present before any index, loading from or storing to any pointer derived from the getelementptr has undefined behavior if the load or store would access memory outside of the bounds of the element selected by the index marked as inrange.</p>\n</blockquote>",
        "id": 169417168,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004313
    },
    {
        "content": "<p><code>inrange</code>... never seen that</p>",
        "id": 169417169,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004317
    },
    {
        "content": "<p>interesting. I dont think we emit it anywhere currently?</p>",
        "id": 169417196,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004354
    },
    {
        "content": "<p>and TBH this entire subobject thing is <em>really complicated</em> when you try to do it formally. so I am very happy we don't do it.</p>",
        "id": 169417253,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004373
    },
    {
        "content": "<p>so with <code>getelementptr inbounds ... inrange &lt;ty&gt; idx</code> you say that at the idx within the allocation there is a <code>&lt;ty&gt;</code>, and that the resulting pointer cannot be used to access the allocation out of that type storage</p>",
        "id": 169417254,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004374
    },
    {
        "content": "<p>so if we say that in <code>let a [0, 1, 2, 3]; let p = &amp;a[0];</code> the <code>p</code> and pointers derived from it can only be used to access the first i32, we can emit an <code>inrange i32 0</code>.</p>",
        "id": 169417366,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004457
    },
    {
        "content": "<blockquote>\n<p>The result of a pointer comparison or ptrtoint (including ptrtoint-like operations involving memory) involving a pointer derived from a getelementptr with the inrange keyword is undefined, with the exception of comparisons in the case where both operands are in the range of the element selected by the inrange keyword, inclusive of the address one past the end of that element. Note that the inrange keyword is currently only allowed in constant getelementptr expressions.</p>\n</blockquote>",
        "id": 169417461,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004507
    },
    {
        "content": "<p>the one past the end there allows the <code>for (; ptr != one_past_end; ++ptr)</code> case</p>",
        "id": 169417513,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562004562
    },
    {
        "content": "<blockquote>\n<p>so if we say that in <code>let a [0, 1, 2, 3]; let p = &amp;a[0];</code> the <code>p</code> and pointers derived from it can only be used to access the first i32, we can emit an <code>inrange i32 0</code>.</p>\n</blockquote>\n<p>I agree... interesting how Stacked Borrows \"replaces\" an explicit model of subobjects here</p>",
        "id": 169417680,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004711
    },
    {
        "content": "<p>I wonder if we can similarly use Stacked Borrows to justify <code>inbounds</code>. I mean we already basically do for references. just not for raw pointers.</p>",
        "id": 169417785,
        "sender_full_name": "RalfJ",
        "timestamp": 1562004741
    },
    {
        "content": "<p>I think that would be really cool</p>",
        "id": 169418572,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562005204
    },
    {
        "content": "<p>I suggested for this reason that we dont do <code>inbounds</code> when a raw ptr is used</p>",
        "id": 169418653,
        "sender_full_name": "RalfJ",
        "timestamp": 1562005287
    },
    {
        "content": "<p>but <span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> didnt like the idea ;)</p>",
        "id": 169418661,
        "sender_full_name": "RalfJ",
        "timestamp": 1562005292
    },
    {
        "content": "<p>I do like getting rid of the part that corresponds to \"stay in the same (sub)object\" part. I just don't want to lose the other aspect, that the offset is less than isize::MAX.</p>",
        "id": 169418868,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1562005454
    },
    {
        "content": "<p>ah right you were mostly worried about overflows</p>",
        "id": 169418935,
        "sender_full_name": "RalfJ",
        "timestamp": 1562005501
    },
    {
        "content": "<p>making overflows for field accesses UB is fairly easy I think, Miri probably already does that</p>",
        "id": 169418983,
        "sender_full_name": "RalfJ",
        "timestamp": 1562005532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> does <code>inrange</code> allow any interesting optimizations ?</p>",
        "id": 169418988,
        "sender_full_name": "gnzlbg",
        "timestamp": 1562005536
    },
    {
        "content": "<p>but note the part I am worried about is not \"stay in the same (sub)object\", it's \"stay in the same allocation\"</p>",
        "id": 169419021,
        "sender_full_name": "RalfJ",
        "timestamp": 1562005558
    },
    {
        "content": "<p>I parenthesized the \"sub\" part for a reason! And object/allocation is tomayto, tomahto</p>",
        "id": 169419439,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1562005823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> I don't know.</p>",
        "id": 169419464,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1562005848
    },
    {
        "content": "<blockquote>\n<p>I parenthesized the \"sub\" part for a reason! And object/allocation is tomayto, tomahto</p>\n</blockquote>\n<p>oh. not sure if that's how everyone uses the word. ;)</p>",
        "id": 169419955,
        "sender_full_name": "RalfJ",
        "timestamp": 1562006205
    }
]