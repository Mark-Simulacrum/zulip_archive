[
    {
        "content": "<p>(moved everything to a new thread since I totally derailed the original topic)</p>",
        "id": 277882315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649167055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277881872\">said</a>:</p>\n<blockquote>\n<p>you are right, the one in the best position to handle it would be <code>FunctionCodegen</code> itself since you want to call <code>call_fn</code>. If you can get the <code>Path</code> of lang items somehow you can call that</p>\n</blockquote>\n<p>That still doesn't solve \"how\". lang items are a frontend concept. The rust lang items have already ceased to exist as far back as irgen in frontend_rust.</p>",
        "id": 277886821,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649168824
    },
    {
        "content": "<p>I've also noted that the only times function calls are generated by the backend in lccc are when there is no other option (non-lock free atomics, for example, or software floating-point arithmetic) or when explicitly done by the user (the xir <code>call</code> instruction). Introducing additional calls has <em>fun</em> implications.</p>",
        "id": 277887706,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649169187
    },
    {
        "content": "<p>perhaps lang item isn't the right word. This would be a cross language / compiler specific \"lang item\", like your non-lock free atomic functions</p>",
        "id": 277895708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649172273
    },
    {
        "content": "<p>Poor <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span>, you constantly have to defend your compiler design against people who don't understand it and haven't thought as much about it (including me the other day)...</p>",
        "id": 277896037,
        "sender_full_name": "comex",
        "timestamp": 1649172382
    },
    {
        "content": "<p>Uh, maybe that was a little harsh.</p>",
        "id": 277896122,
        "sender_full_name": "comex",
        "timestamp": 1649172416
    },
    {
        "content": "<p>I'm generally unsympathetic to arguments of the form \"this isn't a good feature because my backend architecture doesn't support it easily\"</p>",
        "id": 277896215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649172451
    },
    {
        "content": "<p>because that sounds like a problem with your backend architecture, not with the features</p>",
        "id": 277896282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649172474
    },
    {
        "content": "<p>It's true, but we readily accept such arguments when it comes to rustc and LLVM.</p>",
        "id": 277896415,
        "sender_full_name": "comex",
        "timestamp": 1649172518
    },
    {
        "content": "<p>that might be an argument for \"this is a low priority / is not likely to happen in the next year\", but it doesn't refute the idea itself, and maybe someone will come along later and do the hard work of plumbing the feature where it needs to go</p>",
        "id": 277896592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649172601
    },
    {
        "content": "<p>also you can imagine this as being part of the runtime as a SIGILL handler, and if you want you could force different <code>ud2</code> generations to remain separate and not be merged, so that you can still get separate backtraces or direct source info<br>\nOf course, keeping separate unreachables from being merged means you now lose some of the optimizations they're intended to give</p>",
        "id": 277896722,
        "sender_full_name": "Talchas",
        "timestamp": 1649172648
    },
    {
        "content": "<p>(all of this is precisely what BUG() does in the linux kernel)</p>",
        "id": 277896772,
        "sender_full_name": "Talchas",
        "timestamp": 1649172672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277896415\">said</a>:</p>\n<blockquote>\n<p>It's true, but we readily accept such arguments when it comes to rustc and LLVM.</p>\n</blockquote>\n<p>the difference there is that llvm is actually used by rustc and we're stuck with it for now wheras the lccc stuff is irrelevent to rust discussions and is just some random persons pet project</p>",
        "id": 277896774,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649172675
    },
    {
        "content": "<p>(and being in a SIGILL handler means that ones done early in loading won't have set the handler yet, so you can dodge all those issues)</p>",
        "id": 277896951,
        "sender_full_name": "Talchas",
        "timestamp": 1649172742
    },
    {
        "content": "<p>ouch... I think that discussions about lccc have been helpful in isolating how Rust and rustc differ, especially as regards specification efforts</p>",
        "id": 277896991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649172759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> That's true, and if you become overly deferential to N different implementations and each one's pet implementation choices, then you end up hamstrung like the C++ committee often is.  But there's a balance to be struck.</p>",
        "id": 277897130,
        "sender_full_name": "comex",
        "timestamp": 1649172815
    },
    {
        "content": "<p>I think that bringing up lccc is more useful in discussions here than say, on a \"normal\" language feature. If lccc can't support a language feature, then you basically have the issues with the C/C++ where everything takes years to get consensus. On the other hand, stuff like provenance is highly theoretical, and having some proposed optimizations/realities from an implementation helps  more than it hurts imo.</p>",
        "id": 277897762,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649173048
    },
    {
        "content": "<p>Anyway, I guess this particular choice between ud2 and calling a function is essentially orthogonal to any specification efforts.  Reporting UB is always best-effort at most.  Even if rustc hypothetically ends up turning unconditional UB into function calls, that would not be guaranteed by the Rust spec.  So if lccc doesn't want to call a function, that doesn't prevent the Rust spec from providing any guarantees or features it would otherwise provide.</p>",
        "id": 277898355,
        "sender_full_name": "comex",
        "timestamp": 1649173247
    },
    {
        "content": "<p>(personally I think a SIGILL handler is fine)</p>",
        "id": 277898886,
        "sender_full_name": "comex",
        "timestamp": 1649173418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277896282\">said</a>:</p>\n<blockquote>\n<p>because that sounds like a problem with your backend architecture, not with the features</p>\n</blockquote>\n<p>The issue is that this is a design feature of the architecture. It's designed not to know the optimization level. It's designed to be discouraged from inspecting the target beyond what it's given in TargetProperties. One of my issues with having <code>puts</code> in TargetProperties is \"Where does it end\" - what functions do I not need to put in the TargetProperties.</p>",
        "id": 277902549,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649174679
    },
    {
        "content": "<p>I have the same issue with having a \"This target does/doesn't exist on Rust\" property.<br>\nWhere does that end? If it never ends, then it's an ABI problem. If it does end with Rust, then why is Rust special in this regard. </p>\n<p>Same thing here, where does \"Magic symbol that may/may not exist that the target knows about\" end. Does it end with <code>puts</code>? What's special about <code>puts</code>.</p>",
        "id": 277903235,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649174900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277903235\">said</a>:</p>\n<blockquote>\n<p>Same thing here, where does \"Magic symbol that may/may not exist that the target knows about\" end. Does it end with <code>puts</code>? What's special about <code>puts</code>.</p>\n</blockquote>\n<p>It's special in the same way that <code>core::panicking::panic</code> is special. The compiler chooses to produce calls to an output function for diagnostic purposes, it is not obligated to do so because it is in UB land and can do whatever it wants, but this function is built into the compiler as an intrinsic.</p>",
        "id": 277904992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649175634
    },
    {
        "content": "<p>I would probably not call puts but rather <code>lccc::intrinsics::abort_with_msg</code> or whatever you want to call it, which delegates to <code>puts</code> or does a syscall or whatever is appropriate for the target</p>",
        "id": 277905130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649175710
    },
    {
        "content": "<p>As mentioned <code>core::panicking::panic</code> is special only to the frontend. Everything below the frontend just sees <code>std::panicking::panic</code> (yes <code>std::</code>, lccc mangles all of <code>core</code>, <code>alloc</code>, and <code>std</code> as just <code>std</code> to benefit from Itanium's <code>St</code> compression).</p>",
        "id": 277905221,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175738
    },
    {
        "content": "<p>What makes <code>puts</code> special for the entire architecture that it has to live in <code>TargetProperties</code>.</p>",
        "id": 277905289,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175767
    },
    {
        "content": "<p>I assume you have other target-specific intrinsics as well, for stuff like memcpy</p>",
        "id": 277905353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649175800
    },
    {
        "content": "<p>Fair enough.</p>",
        "id": 277905475,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175845
    },
    {
        "content": "<p>Though memcpy checks <code>preferred_vector_size</code> and does a bunch of those or smaller moves.</p>",
        "id": 277905535,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175876
    },
    {
        "content": "<p>sure, it's intrinsically tied in to the IR generation because you want to optimize it to register moves and such</p>",
        "id": 277905596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649175905
    },
    {
        "content": "<p>but that means that it's not just a <code>Call</code> in the IR, even though for some types it might need to be compiled to a literal function call</p>",
        "id": 277905688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649175944
    },
    {
        "content": "<p>this abort with message thing is pretty similar in that regard. In the IR it might be represented as a specific IR instruction like <code>Unreachable(msg)</code> and you decide later whether you want to produce a function call or a <code>ud2</code> or remove it entirely</p>",
        "id": 277905902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649176045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277905688\">said</a>:</p>\n<blockquote>\n<p>but that means that it's not just a <code>Call</code> in the IR, even though for some types it might need to be compiled to a literal function call</p>\n</blockquote>\n<p>It is (still) a call. It just doesn't codegen to one (usually).</p>",
        "id": 277906347,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649176219
    },
    {
        "content": "<p>if you store it as a <code>Call</code>, it still needs to be one where the function's name/behavior is known to the optimizer, since I assume you aren't just inlining it since it probably has a weird assembly definition</p>",
        "id": 277907917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649176844
    },
    {
        "content": "<p>So I've only read like... half of this, but skimmed the rest. One option that we always have is to warn on functions that are unconditional UB and have a body that is not <code>unreachable_unchecked()</code>. That should at least cover a lot of the potential cases. We can try extending this to more general parts of the CFG that we prove are UB, but tracking that information is hard and also it's not clear how we can avoid getting false positives there</p>",
        "id": 277914456,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649179542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277873331\">said</a>:</p>\n<blockquote>\n<p>(It also again comes down to \"The backend doesn't know what <code>printf</code> is\")</p>\n</blockquote>\n<p>FWIW some backends do. the rustc LLVM backend emits panics in a few places. it even has to have that knowledge to codegen array bounds checks.<br>\nother backends can be structured differently, of course. but just because some backends cant do it doesnt mean no backend should do it. ;)<br>\n(EDIT: and it looks like the same arguments were already rehashed above so never mind.^^)</p>",
        "id": 277925417,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277878254\">said</a>:</p>\n<blockquote>\n<p>I just remember LLVM has an option to turn the unreachable instruction into ud2. It was enabled by default for a while to mitigate loop {} being UB in LLVM in the past. I believe it has since been disabled though.</p>\n</blockquote>\n<p>hm, I thought it is still enabled?</p>\n<p>there are also some places in the LLVM backend that could codegen <code>unreachable</code> but emit <code>abort</code> instead.<br>\nsee e.g. <a href=\"https://github.com/rust-lang/rust/issues/59793\">https://github.com/rust-lang/rust/issues/59793</a></p>",
        "id": 277925744,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184075
    },
    {
        "content": "<blockquote>\n<p>hm, I thought it is still enabled?</p>\n</blockquote>\n<p>Indeed: <a href=\"https://github.com/rust-lang/rust/blob/6af09d2505f38e4f1df291df56d497fb2ad935ed/compiler/rustc_target/src/spec/mod.rs#L1532\">https://github.com/rust-lang/rust/blob/6af09d2505f38e4f1df291df56d497fb2ad935ed/compiler/rustc_target/src/spec/mod.rs#L1532</a> Maybe I was thinking of a PR that didn't end up getting merged?</p>",
        "id": 277926265,
        "sender_full_name": "bjorn3",
        "timestamp": 1649184255
    },
    {
        "content": "<p>besides the <code>loop {}</code> issue, another argument was that we don't want LLVM to codegen an unreachable function into a label that just \"falls through\" to the next function</p>",
        "id": 277926787,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184504
    },
    {
        "content": "<p>like, \"UB calling random code\" should be scoped to 'inside the same function' where possible (not possible with indirect calls, obviously)</p>",
        "id": 277926843,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> do you know where in the LLVM pipeline <code>trap_unreachable</code> applies? like, could fixing <a href=\"https://github.com/rust-lang/rust/issues/59793\">https://github.com/rust-lang/rust/issues/59793</a> make any difference at all as long as that flag is set (because some optimizations <em>will</em> use <code>unreachable</code> as a useful hint, and the flag only applies when lowering LLVM IR to assembly later)?</p>",
        "id": 277927034,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184612
    },
    {
        "content": "<p>I suspect it is during lowering from llvm ir to whatever machine specific ir is used. In any case we pass the option to LLVM at <a href=\"https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp#L510-L516\">https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp#L510-L516</a></p>",
        "id": 277927193,
        "sender_full_name": "bjorn3",
        "timestamp": 1649184693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277925417\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Compiling.20unconditional.20UB.20to.20assert.20messages/near/277873331\">said</a>:</p>\n<blockquote>\n<p>(It also again comes down to \"The backend doesn't know what <code>printf</code> is\")</p>\n</blockquote>\n<p>FWIW some backends do. the rustc LLVM backend emits panics in a few places. it even has to have that knowledge to codegen array bounds checks.<br>\nother backends can be structured differently, of course. but just because some backends cant do it doesnt mean no backend should do it. ;)<br>\n(EDIT: and it looks like the same arguments were already rehashed above so never mind.^^)</p>\n</blockquote>\n<p>Yeah, different backends do different things. rustc backends are more involved than xlang backends, since rustc backends are (usually) stepping down to another IR, and running stuff on the IR, whereas xlang backends are there to go right into machine code, so they see less and know less. xlang backends are more equivalent to LLVM backends, in this respect.</p>",
        "id": 277932638,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649187259
    },
    {
        "content": "<p>And this is not to say that an xlang backend could know about a few specific symbols either - it's just that I'd rather not have the in-tree ones rely on that, because of how the entire compilation pipeline is architectured - you could indeed write a <code>codegen-debugx86</code>that emits diagnostics when it traps unreachable code if you had cause to.</p>",
        "id": 277932851,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649187379
    }
]