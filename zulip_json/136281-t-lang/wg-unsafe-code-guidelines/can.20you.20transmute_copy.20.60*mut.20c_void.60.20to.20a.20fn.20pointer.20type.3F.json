[
    {
        "content": "<p>The question is as per the title: can you <code>transmute_copy(&amp;p)</code> where <code>p</code> is a <code>*mut c_void</code> and the output type is some function pointer type.</p>",
        "id": 258905291,
        "sender_full_name": "Lokathor",
        "timestamp": 1635119951
    },
    {
        "content": "<p>(and to be clear, I know that the rust type system allows it to happen, but I'm also aware of the pointer/integer transmute problems, and so I'm wondering if those apply to pointer to fn pointer transmutes)</p>",
        "id": 258905605,
        "sender_full_name": "Lokathor",
        "timestamp": 1635120378
    },
    {
        "content": "<p>it would be a very big problem if that didn't work, since then dlsym/GetProcAddress doesn't work anymore.</p>",
        "id": 258905891,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635120855
    },
    {
        "content": "<p>there's no non-transmute way to do that conversion, so transmute has to be acceptable</p>",
        "id": 258905917,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635120920
    },
    {
        "content": "<p>I've used transmute before, and in fact that's how i'm currently using it now for this project, but is there any difference when using transmute_copy (i hope not, it would simplify my code a lot)</p>",
        "id": 258906048,
        "sender_full_name": "Lokathor",
        "timestamp": 1635121093
    },
    {
        "content": "<p>For reference, C standard does permit this, POSIX allows the conversion between <code>void*</code> to/from function pointer as an extension to the C language.</p>",
        "id": 258906776,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635122274
    },
    {
        "content": "<p>There might be platforms that have distinct data and function pointrers (if they have no intention to ever support POSIX)</p>",
        "id": 258906835,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635122310
    },
    {
        "content": "<p>well, as Thom said, <code>transmute</code> between <code>*mut c_void</code> and function pointer must be allowed or like... all of dynamic function loading is just broken. So I trust that much to work.</p>\n<p>However, in this case, I've got many (about 200) function pointers to load, and I'd like to conceptually compress it a bit by using a helper function that takes in the <code>*mut c_void</code>, checks for known-bad values, and then if things are fine it does a <code>transmute_copy</code> to <code>Option&lt;my_fn_ptr&gt;</code>. Since each function pointer is a distinct type, this helper must be generic, and since it's generic i have to use <code>transmute_copy</code> rather than <code>transmute</code>.</p>\n<p>I'm vaguely of the understanding that <code>transmute</code> works \"like a union read\" and <code>transmute_copy</code> works \"like a pointer read\". And this usually isn't meaningfully different, but I just want to be extra sure because of the other ptr/int situation.</p>",
        "id": 258907097,
        "sender_full_name": "Lokathor",
        "timestamp": 1635122731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/can.20you.20transmute_copy.20.60*mut.20c_void.60.20to.20a.20fn.20pointer.20type.3F/near/258907097\">said</a>:</p>\n<blockquote>\n<p>well, as Thom said, <code>transmute</code> between <code>*mut c_void</code> and function pointer must be allowed or like... all of dynamic function loading is just broken. So I trust that much to work.</p>\n</blockquote>\n<p>Only if the platform supports dynamic function.</p>",
        "id": 258907146,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635122795
    },
    {
        "content": "<p>let me rephrase: if the platform doesn't support loading functions as <code>*mut c_void</code> it's just so far outside of what this GL loader library is equipped to handle that the library can't possibly compensate, in fact the platform likely doesn't support dynamic GL loading to begin with, because GL loaders are specified to use the normal \"load a function address from a dynamic library\" style.</p>",
        "id": 258907161,
        "sender_full_name": "Lokathor",
        "timestamp": 1635122864
    },
    {
        "content": "<p>Well, there are no contexts beforehand..</p>",
        "id": 258907218,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635122934
    },
    {
        "content": "<p>right, i should have given more context at the start of the thread</p>",
        "id": 258907226,
        "sender_full_name": "Lokathor",
        "timestamp": 1635122962
    },
    {
        "content": "<p>For your particular context I would think it shall be okay.</p>",
        "id": 258907227,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635122964
    },
    {
        "content": "<p>but right now i've got this nonsense going on, which i'd prefer to simplify a bit<br>\n<a href=\"/user_uploads/4715/VW6MG8LntcUFf4x6lKsdV6HB/Screenshot-2021-10-24-18.37.35.png\">Screenshot-2021-10-24-18.37.35.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/VW6MG8LntcUFf4x6lKsdV6HB/Screenshot-2021-10-24-18.37.35.png\" title=\"Screenshot-2021-10-24-18.37.35.png\"><img src=\"/user_uploads/4715/VW6MG8LntcUFf4x6lKsdV6HB/Screenshot-2021-10-24-18.37.35.png\"></a></div>",
        "id": 258907228,
        "sender_full_name": "Lokathor",
        "timestamp": 1635122965
    },
    {
        "content": "<p>You can safe guard your <code>transmute_copy</code> with an <code>assert_eq!</code></p>",
        "id": 258907273,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123006
    },
    {
        "content": "<p>i do assume that it gives a bitwise identical value, but transmuting a ptr/int with that is UB because it goes through the wrong IR, even if the value is bitwise identical.</p>",
        "id": 258907297,
        "sender_full_name": "Lokathor",
        "timestamp": 1635123080
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html\">https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html</a></p>",
        "id": 258907374,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123188
    },
    {
        "content": "<blockquote>\n<p>The ABI and layout of (unsafe)? (extern \"ABI\")? fn(Args...) -&gt; Ret is exactly that of the corresponding C type -- the lack of a null value does not change this. On common platforms, this means that *const () and fn(Args...) -&gt; Ret have the same ABI and layout. This is, in fact, guaranteed by POSIX and Windows.</p>\n</blockquote>",
        "id": 258907377,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123195
    },
    {
        "content": "<p>So I would say it's safe for your use case.</p>",
        "id": 258907380,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123213
    },
    {
        "content": "<p>Use <code>transmute_copy</code> instead of <code>transmute</code> shouldn't be a problem if the size is the same.</p>",
        "id": 258907428,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123283
    },
    {
        "content": "<p>well it's not a layout issue. <code>usize</code> and <code>*mut u8</code> have the same layout, but transmuting one to the other is UB, even though using <code>as</code> to convert one to the other is defined, because there's separate IR involved.</p>",
        "id": 258907433,
        "sender_full_name": "Lokathor",
        "timestamp": 1635123303
    },
    {
        "content": "<p>so i just don't want that same int/ptr transmutation problem to hit me when going from data ptr to fn ptr</p>\n<p>but if transmute and transmute_copy are identical for these purposes, that's cool</p>",
        "id": 258907450,
        "sender_full_name": "Lokathor",
        "timestamp": 1635123351
    },
    {
        "content": "<p>The page does give an example of transmute and saying it's perfectly safe though.</p>",
        "id": 258907492,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123383
    },
    {
        "content": "<p>convincing enough for me</p>",
        "id": 258907500,
        "sender_full_name": "Lokathor",
        "timestamp": 1635123408
    },
    {
        "content": "<p>I presume it's platform-specific,</p>",
        "id": 258907665,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635123631
    },
    {
        "content": "<p>While I agree that transmuting a \"data pointer\" to a \"function pointer\" ought to be fine for the sake of everyone's sanity, I'd also like to mention that using <code>unsafe extern \"ABI\" fn()</code> can be a nicer default for an \"untyped function pointer\" (for instance, it already mentions the desired ABI).<br>\nEven better if using a technically hidden parameter; <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> maybe something like <code>unsafe extern \"ABI\" fn(c_void)</code>?</p>",
        "id": 258937639,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635155807
    },
    {
        "content": "<p>Libloading uses pointer cast approach for this but that is ultimately still a transmute.</p>",
        "id": 258941276,
        "sender_full_name": "nagisa",
        "timestamp": 1635158234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/can.20you.20transmute_copy.20.60*mut.20c_void.60.20to.20a.20fn.20pointer.20type.3F/near/258906048\">said</a>:</p>\n<blockquote>\n<p>I've used transmute before, and in fact that's how i'm currently using it now for this project, but is there any difference when using transmute_copy (i hope not, it would simplify my code a lot)</p>\n</blockquote>\n<p>no I think that would be horrible^^ <code>transmute</code> is just slightly safer because it checks size equality</p>",
        "id": 259030730,
        "sender_full_name": "RalfJ",
        "timestamp": 1635201974
    },
    {
        "content": "<p>I assume the ptr here is actually a proper function pointer that was just disguised as <code>void*</code>? If so I see no way this could go wrong. The interesting questions are usually those that involve transmuting a value to some type where the value doesn't really fit that type (e.g. transmuting a ptr, which has provenance, to an integer, which does not).</p>",
        "id": 259030863,
        "sender_full_name": "RalfJ",
        "timestamp": 1635202093
    },
    {
        "content": "<p>also you probably know that but obligatory reminder than <code>fn</code> is non-null</p>",
        "id": 259030894,
        "sender_full_name": "RalfJ",
        "timestamp": 1635202119
    },
    {
        "content": "<p>whether transmuting <code>1usize</code> to fn is okay or not I dont think we can officially answer right now... <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/pull/197\">https://github.com/rust-lang/unsafe-code-guidelines/pull/197</a> wanted to say yes that is okay but then I got cold feet about guaranteeing any kind of \"interesting\" transmute^^</p>",
        "id": 259030947,
        "sender_full_name": "RalfJ",
        "timestamp": 1635202177
    },
    {
        "content": "<p>The main issue would be when <code>size_of::&lt;*mut ()&gt;()!=size_of::&lt;fn()&gt;()</code>, but that would be ruled out by <code>transmute</code> (but not pointer casts or transmute_copy)</p>",
        "id": 259034878,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635205393
    },
    {
        "content": "<p>(and of course, encountering a platform where that's the case is likely going to be rare, even infinitely extending into theoretical future supported platforms)</p>",
        "id": 259034975,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635205474
    },
    {
        "content": "<p>we will need some way to convert integers to function pointers for things like calling functions at well-known potentially dynamically computed addresses, where linker symbols aren't sufficient</p>",
        "id": 259062439,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1635234561
    },
    {
        "content": "<p>I could imagine a platform where function pointers and data pointers have differing sizes, but at least on current windows/mac/linux the C functions used to get the function pointers at runtime are specified as returning <code>void*</code>.</p>\n<p>Of course the headers could be updated when adding a new platform, blah blah blah, but the point is that the current C headers are the reason the function loader is written with <code>*mut c_void</code> as the standard \"pointer to a function of an unknown signature\" type.</p>\n<p>Also, I would hesitate to make <code>unsafe extern \"C\" fn()</code> be the default data type instead, because that's immediately usable on accident. I think there's value in having to write down an additional operation to convert the <code>*mut c_void</code> to being definitely the correct type, instead of accidentally forgetting the additional conversion and using it with the wrong signature.</p>",
        "id": 259136617,
        "sender_full_name": "Lokathor",
        "timestamp": 1635271232
    },
    {
        "content": "<blockquote>\n<p>I could imagine a platform where function pointers and data pointers have differing sizes</p>\n</blockquote>\n<p>In practice these platforms just have the function pointer be a pointer to the static (possibly multi-word) data</p>",
        "id": 259140762,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635273124
    },
    {
        "content": "<p>itanium did this. the \"function pointer\" was actually a pointer to the function descriptor which was 128 bits</p>",
        "id": 259140811,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635273142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/can.20you.20transmute_copy.20.60*mut.20c_void.60.20to.20a.20fn.20pointer.20type.3F/near/259140762\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I could imagine a platform where function pointers and data pointers have differing sizes</p>\n</blockquote>\n<p>In practice these platforms just have the function pointer be a pointer to the static (possibly multi-word) data</p>\n</blockquote>\n<p>That seems potentially inefficient if function pointers are smaller</p>",
        "id": 259164371,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635283853
    },
    {
        "content": "<p>the perf can go either way, its a bit like a vtable call (saving the space in structures has a benefit). on the itanium it had some amount of architectural support too</p>",
        "id": 259164753,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635284078
    },
    {
        "content": "<p>i'd be surprised if anything took a different approach in the future though. POSIX/windows compat is very important</p>",
        "id": 259164772,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635284092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/can.20you.20transmute_copy.20.60*mut.20c_void.60.20to.20a.20fn.20pointer.20type.3F/near/259140811\">said</a>:</p>\n<blockquote>\n<p>itanium did this. the \"function pointer\" was actually a pointer to the function descriptor which was 128 bits</p>\n</blockquote>\n<p>iirc VAX does that too...</p>",
        "id": 259164809,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1635284113
    },
    {
        "content": "<p>16-bit x86 can have function pointers be 16/32-bits independently of data pointers being 16/32-bits</p>",
        "id": 259164954,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1635284184
    }
]