[
    {
        "content": "<p>Hey All,</p>\n<p>I'm writing some code which requires the use of unsafe and I'm trying to wrap my head around the miri error <code>no item granting read access to tag</code> What I'm doing is creating an array of 32bit ints and then getting a u8 pointer to that same array. The issue I'm hitting is that I create the array and pointer as</p>\n<div class=\"codehilite\"><pre><span></span>    let mut state: [u32; 12] = [0; 12];\n    let state_8 = unsafe {\n        std::slice::from_raw_parts_mut(\n            state.as_mut_ptr() as *mut u8,\n            48)\n    };\n</pre></div>\n\n\n<p>Then go into a loop of the form</p>\n<div class=\"codehilite\"><pre><span></span>while input_byte_len &gt; 0 {\n        block_size = min(input_byte_len, 16);\n        for i in 0..block_size {\n            let b = input.next().unwrap().expect(&quot;Read error on input&quot;);\n            state_8[i as usize] ^= b;\n        }\n        ...\n    }\n</pre></div>\n\n\n<p>The line that gets flagged is <code>state_8[i as usize] ^= b;</code>. I've tried to make a minimal example of this which can be seen here<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=589490937b36480799043d790f5d0d4e\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=589490937b36480799043d790f5d0d4e\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=589490937b36480799043d790f5d0d4e</a><br>\nbut it passes <code>cargo miri test</code> without issue. Also, I've tried moving the pointer creation into the loop and that seems to resolve the issue. <br>\nex.</p>\n<div class=\"codehilite\"><pre><span></span>while input_byte_len &gt; 0 {\n        block_size = min(input_byte_len, 16);\n        for i in 0..block_size {\n        let state_8 = unsafe {std::slice::from_raw_parts_mut(state.as_mut_ptr() as *mut u8,48)};\n            let b = input.next().unwrap().expect(&quot;Read error on input&quot;);\n            state_8[i as usize] ^= b;\n        }\n        ...\n    }\n</pre></div>\n\n\n<p>I'm not really sure where to go from here and could really use some guidance. For context my full set of code with branch adding a miri CI check can be found here<br>\n<a href=\"https://github.com/darakian/gimli/tree/add-miri-ci\" target=\"_blank\" title=\"https://github.com/darakian/gimli/tree/add-miri-ci\">https://github.com/darakian/gimli/tree/add-miri-ci</a></p>\n<p>The full cli output of the miri error is </p>\n<div class=\"codehilite\"><pre><span></span>error[E0080]: Miri evaluation error: no item granting read access to tag &lt;87365&gt; found in borrow stack\n   --&gt; src/lib.rs:70:13\n    |\n70  |             state_8[i as usize] ^= b;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ Miri evaluation error: no item granting read access to tag &lt;87365&gt; found in borrow stack\n    |\n</pre></div>",
        "id": 189524928,
        "sender_full_name": "Darakian",
        "timestamp": 1583176305
    },
    {
        "content": "<p>Are you sure your version of Miri matches the one in the playground?</p>",
        "id": 189529889,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583178941
    },
    {
        "content": "<p>And have you seen <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut\" target=\"_blank\" title=\"https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut\">https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut</a> ?</p>",
        "id": 189529990,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583178992
    },
    {
        "content": "<p>Your playground has</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">block_size</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"n\">block_size</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>The loop will never run.</p>",
        "id": 189530459,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583179315
    },
    {
        "content": "<p>Oh, that's being strangely mutable, I see.</p>",
        "id": 189530577,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583179386
    },
    {
        "content": "<p>No, it seems that there's a mismatch in versions. <br>\nI have <code>miri 0.1.0 (07ac1027 2019-09-29)</code> locally. It seems like the playground is using <code>0.1.0 (2020-02-23 3c444bf)</code>. <br>\nIn my CI I have <code>miri 0.1.0 (3c444bf 2020-02-23)</code></p>\n<p>On the blocksize, ya that number should be 16 for each loop until the input iterator has fewer than 16 bytes in it. The playground initially had <code>block_size = min(input_byte_len, 64);</code> which was a type. I've updated it to <code>block_size = min(input_byte_len, 16);</code>.</p>\n<p>The strangest bit of this to me is that by moving the pointer creation into the innermost loop resolves the issue. This makes me think that there's something preventing the inner scope from reading the outerscope, but this is also my understanding at the rust source level rather than at the MIR level.</p>",
        "id": 189533910,
        "sender_full_name": "Darakian",
        "timestamp": 1583181681
    },
    {
        "content": "<p>Actually. Is it possible that a scope could be taking ownership of the pointer at the MIR level?</p>",
        "id": 189535131,
        "sender_full_name": "Darakian",
        "timestamp": 1583182386
    },
    {
        "content": "<p>What happens if you replace it with the <code>bytemuck</code> crate and use the <code>cast_slice</code> function to do the conversion?</p>",
        "id": 189535395,
        "sender_full_name": "Lokathor",
        "timestamp": 1583182524
    },
    {
        "content": "<p>Replacing</p>\n<div class=\"codehilite\"><pre><span></span>    let state_8 = unsafe {\n        std::slice::from_raw_parts_mut(\n            state.as_mut_ptr() as *mut u8,\n            48)\n    };\n</pre></div>\n\n\n<p>with <code>let state_8 = cast_slice_mut(&amp;mut state);</code> which I'm not sure is the correct syntax. My code no longer compiles due to multiple mutable borrows. Using <code>cast_slice</code> I have similar errors but around the <code>state_8</code> variable not being mutable. However, I've never used the <code>bytemuck</code> crate before and I'm not sure if this is correct usage. Their docs leave a lot to be desired.</p>",
        "id": 189536681,
        "sender_full_name": "Darakian",
        "timestamp": 1583183244
    },
    {
        "content": "<p>Well, if I understand the rest of your situation correctly then that usage is accurate and your code's borrow errors are the source of the miri failures.</p>",
        "id": 189539932,
        "sender_full_name": "Lokathor",
        "timestamp": 1583185153
    },
    {
        "content": "<p>However, I apologise for the docs situation! If you have ideas on how to improve them please send in an issue. Or even just send in an issue about the problem without a solution and I'll do my best to fix it up.</p>",
        "id": 189540052,
        "sender_full_name": "Lokathor",
        "timestamp": 1583185246
    },
    {
        "content": "<p>A simple example would be nice for the docs. My confusion at the moment around the <code>cast_slice(_mut)</code> functions are how <code>U</code> and <code>T</code> are derived. For instance it's unclear to me if <code>let state_8 = cast_slice_mut(&amp;mut state);</code> will return a &amp;[u8] in my case. I'm not sure if that information can be inferred or not.</p>\n<p>Anyway, yes my borrow errors most certainly are coming from having two mutable pointers to the same data structure. These two pointers are a requirement at least for now and hence the unsafe usage :)<br>\nI suppose this may just be an anti-pattern that miri doesn't deal with, but I was hoping that this would be a case which was covered.</p>\n<p>Edit:<br>\nHere's a minimal failing playground example<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a903cf056ab3d95514cd28acd4a405fc\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a903cf056ab3d95514cd28acd4a405fc\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a903cf056ab3d95514cd28acd4a405fc</a></p>\n<p>It seems like miri only fails when the use of the <code>gimli</code> function is present.<br>\nRemoving line 75; <code>gimli(&amp;mut state);</code> on the playground above resolves the miri issues.</p>",
        "id": 189542890,
        "sender_full_name": "Darakian",
        "timestamp": 1583186806
    },
    {
        "content": "<p>Often the output type of a cast cannot be inferred because rust has kinda weak inference and there's so many possible outputs. It is a mild weakness of the library</p>",
        "id": 189544842,
        "sender_full_name": "Lokathor",
        "timestamp": 1583188294
    },
    {
        "content": "<p>as to the aliasing issue: raw pointers actually can alias, but unique references cannot</p>",
        "id": 189545095,
        "sender_full_name": "Lokathor",
        "timestamp": 1583188491
    },
    {
        "content": "<p>so you could maybe to what you want if you never make a &amp;mut T pointing at the stuff</p>",
        "id": 189545130,
        "sender_full_name": "Lokathor",
        "timestamp": 1583188516
    },
    {
        "content": "<p>but that means a lot of rust can't be used, sadly</p>",
        "id": 189545139,
        "sender_full_name": "Lokathor",
        "timestamp": 1583188530
    },
    {
        "content": "<p>Sadly the algorithm I'm porting requires two mutable views of the same array. I believe this requires two mutable pointers, but I would be happy to be wrong there.</p>",
        "id": 189545383,
        "sender_full_name": "Darakian",
        "timestamp": 1583188786
    },
    {
        "content": "<p>could maybe go by index instead of by pointer</p>",
        "id": 189547800,
        "sender_full_name": "Lokathor",
        "timestamp": 1583190888
    },
    {
        "content": "<p>Perhaps, I'll have to investigate it. Thanks for the help and for letting me think out loud a bit :)</p>",
        "id": 189549333,
        "sender_full_name": "Darakian",
        "timestamp": 1583192328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266754\">Yogurt</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189545383\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189545383\">said</a>:</p>\n<blockquote>\n<p>Sadly the algorithm I'm porting requires two mutable views of the same array. I believe this requires two mutable pointers, but I would be happy to be wrong there.</p>\n</blockquote>\n<p>given that the entire point of mutable referneces is not to alias, this sadly will mean that you have to use raw pointers (or indices) throughout</p>",
        "id": 189617682,
        "sender_full_name": "RalfJ",
        "timestamp": 1583258518
    },
    {
        "content": "<p>(the code is still a bit long for me to understand the issue at a glance, and it seems y'all got some idea about where the problem is, so I take it its not worth for me to dig into it right now)</p>",
        "id": 189617774,
        "sender_full_name": "RalfJ",
        "timestamp": 1583258566
    },
    {
        "content": "<p>Also without fully grokking the code, I feel like many algorithms can be restated in a way that doesn't require double mutable references.</p>",
        "id": 189619404,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583259648
    },
    {
        "content": "<p>To <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span>  point; I think I can rewrite the algorithm to avoid the usage of two pointers. This is on my radar, but that's an exploration down the road.  <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  Here's an even more minimal example of the issue with a fake function.<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=11f0edd22e7950f23155c6f8e6a2364e\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=11f0edd22e7950f23155c6f8e6a2364e\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=11f0edd22e7950f23155c6f8e6a2364e</a></p>\n<p>The crux seems to be that in the loop</p>\n<div class=\"codehilite\"><pre><span></span>while input_len &gt; 0 {\n...\n}\n</pre></div>\n\n\n<p>the call to the <code>gimli</code> function seems to take ownership or otherwise makes referencing <code>state_8[i]</code> invalid. I would love to know the rational there because as I understand it I am simply borrowing the pointer (rather than taking ownership) with the <code>gimli</code> function. Moving the gimli call out of the while loop allows miri to pass without complaint. Similarly if the input vector is under 16 elements long miri passes, so I can only assume that the access error occurs only after the first call to <code>gimli</code>.<br>\nex.<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=34c4abd62f3043495aa421026ce65219\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=34c4abd62f3043495aa421026ce65219\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=34c4abd62f3043495aa421026ce65219</a></p>",
        "id": 189622534,
        "sender_full_name": "Darakian",
        "timestamp": 1583261702
    },
    {
        "content": "<p><code>state</code> and <code>state8</code> alias each other, don't they?</p>",
        "id": 189623363,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583262284
    },
    {
        "content": "<p>So when you call <code>gimli</code> passing in <code>state</code>, <code>state8</code> needs to be invalidated</p>",
        "id": 189623409,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583262326
    },
    {
        "content": "<p>e.g. I think this is the same:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">state</span>: <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state_8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts_mut</span><span class=\"p\">(</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">_i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">state_8</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 189623576,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583262449
    },
    {
        "content": "<p>Which is why putting the call to <code>from_raw_parts</code> inside the loop fixes it — you are retaking the single mutable reference</p>",
        "id": 189623710,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583262536
    },
    {
        "content": "<p>Yes that's my understanding as well, but I suppose I don't understand why.  If the state8 pointer needs to be invalidated doesn't that somewhat defeat the point of having two mutable references?</p>",
        "id": 189624036,
        "sender_full_name": "Darakian",
        "timestamp": 1583262730
    },
    {
        "content": "<p>Or simpler</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// let _z = *b; // Causes Miri failure</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 189624245,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583262872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266754\">Yogurt</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189624036\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189624036\">said</a>:</p>\n<blockquote>\n<p>Yes that's my understanding as well, but I suppose I don't understand why.  If the state8 pointer needs to be invalidated doesn't that somewhat defeat the point of having two mutable references?</p>\n</blockquote>\n<p>well you are not supposed to have two mutable references, that is the entire point. mutable references must be unique, only one can point to any memory at any given point in time (and be currently \"usable\").</p>",
        "id": 189625077,
        "sender_full_name": "RalfJ",
        "timestamp": 1583263419
    },
    {
        "content": "<p>IOW, \"you can have aliasing or mutation, but never both at the same time\" -- the fundamental principle of ownership and borrowing in Rust</p>",
        "id": 189625137,
        "sender_full_name": "RalfJ",
        "timestamp": 1583263447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189625137\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189625137\">said</a>:</p>\n<blockquote>\n<p>IOW, \"you can have aliasing or mutation, but never both at the same time\" -- the fundamental principle of ownership and borrowing in Rust</p>\n</blockquote>\n<p>I thought this is a fundamental principle of safe rust though. I understand that I am breaking that principle with my use of unsafe and as such I'm trying to add Miri to my workflow so that I can have a better assurance of my usage of unsafe. If that's not a use case for miri then I'm simply out of luck until I can refactor my pointer usage. Thanks again for the help :)</p>",
        "id": 189627861,
        "sender_full_name": "Darakian",
        "timestamp": 1583265252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> another way of approaching this problem is \"I want to interleave treating <code>state</code> as <code>&amp;mut [u32]</code> and <code>&amp;mut [u8]</code>, but never both at the same time\". </p>\n<p>Is there some way of doing some kind of union or reborrowing here?</p>",
        "id": 189628360,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583265564
    },
    {
        "content": "<p>this is a fundamental principle of <em>all of</em> Rust, not just safe Rust. I <a href=\"https://www.youtube.com/watch?v=h9Fh4jRDGLo\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=h9Fh4jRDGLo\">recently gave a talk</a> explaining why. :)<br>\nonly raw pointers (and to a lesser extend <code>UnsafeCell</code>) are allowed to get around this, and alias each other during mutation. So indeed you need unsafe code to get around this, but just adding unsafe is not enough -- the reason you need unsafe is that you need raw pointers to get around the principle, and raw pointers only work in unsafe code.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"h9Fh4jRDGLo\" href=\"https://www.youtube.com/watch?v=h9Fh4jRDGLo\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=h9Fh4jRDGLo\"><img src=\"https://i.ytimg.com/vi/h9Fh4jRDGLo/default.jpg\"></a></div>",
        "id": 189628893,
        "sender_full_name": "RalfJ",
        "timestamp": 1583265870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> you cannot interleave the use of two different mutable refs, no exceptions. That is the entire point of Stacked Borrows.^^<br>\nWhat you could be able to do is construct <code>&amp;[Cell&lt;u32&gt;]</code> and <code>&amp;[Cell&lt;u8&gt;]</code> appropriately and interleave those (<a href=\"https://doc.rust-lang.org/nightly/std/cell/struct.Cell.html#method.from_mut\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/std/cell/struct.Cell.html#method.from_mut\"><code>from_mut</code></a> is useful here).</p>",
        "id": 189629192,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266027
    },
    {
        "content": "<p>You can make the sugar sweeter and do the transforms more transparently, but still Miri-clean: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4790f42b00be9e979cc9bd394eaa3d3b\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4790f42b00be9e979cc9bd394eaa3d3b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4790f42b00be9e979cc9bd394eaa3d3b</a></p>",
        "id": 189629310,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266087
    },
    {
        "content": "<p>I wonder how well <code>from_parts</code> optimizes away.</p>",
        "id": 189629403,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266164
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  well, it's a stack, right? Just add a method that does <code>stack::swap_top(N)</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 189629428,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266194
    },
    {
        "content": "<p>I mean sure if you re-cosntruct a new slice from the origin reference each time, of course that also works</p>",
        "id": 189629431,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266196
    },
    {
        "content": "<p>yes, I'm just showing a way to reconstruct it each time so that that doesn't get in the way of the algorithm. Also why I muse about the optimizer.</p>",
        "id": 189629524,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189629428\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189629428\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>  well, it's a stack, right? Just add a method that does <code>stack::swap_top(N)</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>sure we could do that, and then we'll just not be able to do any of the optimizations that motivate SB in the first place ;)</p>",
        "id": 189629548,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266275
    },
    {
        "content": "<p><code>stack::shuffle</code></p>",
        "id": 189629565,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266289
    },
    {
        "content": "<p>For my case I certainly can reconstruct the reference each time. It's a bit ugly and my C friends will probably cock their eyebrows at me, but <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 189629583,
        "sender_full_name": "Darakian",
        "timestamp": 1583266306
    },
    {
        "content": "<p>the alternative if you want to use references \"on the inside\" is to work with interior mutabulity -- i.e, <code>Cell</code>. those types \"know\" that there can be aliasing so optimziations are suspended around them.</p>",
        "id": 189629684,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266356
    },
    {
        "content": "<p>well the end goal is to get away from aliasing so.... I'll avoid that, but thanks :)</p>",
        "id": 189629725,
        "sender_full_name": "Darakian",
        "timestamp": 1583266396
    },
    {
        "content": "<p>your original code had aliasing though, that is the entire problem ;) and the C version of this has aliasing, too.</p>",
        "id": 189629756,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266425
    },
    {
        "content": "<p>one way or another, you need to tell the compiler about the aliasing. I'm afraid that is the price we have to pay if we want the compiler to optimize our code based on aliasing assumptions.</p>",
        "id": 189629761,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266754\">@Yogurt</span> that is why I showed the prettier way of reconstructing it</p>",
        "id": 189629765,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266432
    },
    {
        "content": "<p>yeah, <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> 's approach is the one that avoids aliasing</p>",
        "id": 189629821,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266451
    },
    {
        "content": "<p>Also, if you change <code>gimli</code> to take in <code>&amp;[u8]</code> then you'd also succeed, I think</p>",
        "id": 189629848,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> wow you didn't even hard-code the factor of <code>4</code> for the size like I would have^^</p>",
        "id": 189629854,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266498
    },
    {
        "content": "<p>I do <em>not</em> believe in my ability to do basic math like that always</p>",
        "id": 189629925,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266538
    },
    {
        "content": "<p>ah but I think there's a mistake... you are using the slice <code>self.0</code> after creating the raw ptr</p>",
        "id": 189629934,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Yes, but the 8bit pointer is a convenience. The same math can be done with 32bit pointers and masks  </p>\n<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> This code block?</p>\n<div class=\"codehilite\"><pre><span></span>fn main() {\n    let mut v: i32 = 0;\n    let a: &amp;mut i32 = &amp;mut v;\n    let b: &amp;mut i32 = unsafe { &amp;mut *(a as *mut _) };\n\n    let _x = *b;\n    let _y = *a;\n    // let _z = *b; // Causes Miri failure\n}\n</pre></div>\n\n\n<p>Isn't that still aliased?</p>",
        "id": 189629938,
        "sender_full_name": "Darakian",
        "timestamp": 1583266550
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>        unsafe {\n            let p = self.0.as_mut_ptr();\n            let u8_len = self.0.len() / mem::size_of::&lt;u8&gt;() * mem::size_of::&lt;u32&gt;();\n            slice::from_raw_parts_mut(p as *mut u8, u8_len)\n        }\n</pre></div>\n\n\n<p>this is exactly like the mistake I recently <a href=\"https://github.com/rust-lang/rust/pull/69581\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/69581\">fixed in <code>align_to_mut</code></a></p>",
        "id": 189630011,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> you should take that up with the maintainers of Miri — it says it's alllllll good</p>",
        "id": 189630041,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189630041\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189630041\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> you should take that up with the maintainers of Miri — it says it's alllllll good</p>\n</blockquote>\n<p>yeah I am wondering why that is</p>",
        "id": 189630097,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> After creating the raw pointer, but before creating the second <em>reference</em> — now just having the raw pointer is an issue?</p>",
        "id": 189630117,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266754\">@Yogurt</span> your code block without <code>_z</code> can be written in safe code. this is the kind of \"well-nested\" aliasing that rust permits -- only one reference being \"active\" at any point in time</p>",
        "id": 189630176,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189630117\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189630117\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> After creating the raw pointer, but before creating the second <em>reference</em> — now just having the raw pointer is an issue?</p>\n</blockquote>\n<p>no the issue is that <code>self.0.len()</code> is <code>slice::len(&amp;*self.0)</code>. you are creating a new shared ref.</p>",
        "id": 189630212,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266754\">@Yogurt</span> this one specifically - <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4790f42b00be9e979cc9bd394eaa3d3b\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4790f42b00be9e979cc9bd394eaa3d3b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4790f42b00be9e979cc9bd394eaa3d3b</a></p>",
        "id": 189630222,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266739
    },
    {
        "content": "<p>ah but unlike in the <code>align_to_mut</code> case you didnt create a mutable ref <em>before</em> that</p>",
        "id": 189630229,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266745
    },
    {
        "content": "<p>so you are fine actually, Miri was right^^</p>",
        "id": 189630250,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266757
    },
    {
        "content": "<p>right. The ref is the last thing. I'm surprised the align_to_mut wasnt</p>",
        "id": 189630278,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266778
    },
    {
        "content": "<p>calling <code>self.0.len()</code> invalidates any mutable refs you might have created since <code>self.0.as_mut_ptr()</code>. which I hope makes sense?</p>",
        "id": 189630282,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266785
    },
    {
        "content": "<p>you are creating a shared ref, that invalidates mutable refs derived before as they dont allow aliasing</p>",
        "id": 189630347,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266806
    },
    {
        "content": "<p>Oh, because it created the middle / aligned reference first</p>",
        "id": 189630352,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266808
    },
    {
        "content": "<p>exactly</p>",
        "id": 189630375,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266830
    },
    {
        "content": "<p>The creation was still in (semi-)tail-position, which is where it belongs, just that it was in that tuple.</p>",
        "id": 189630424,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583266867
    },
    {
        "content": "<p>yeah it was created late but not quite late enough</p>",
        "id": 189630460,
        "sender_full_name": "RalfJ",
        "timestamp": 1583266898
    },
    {
        "content": "<p>I kinda wanna see what happens with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">union</span> <span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">]),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"p\">([</span><span class=\"kt\">u32</span><span class=\"p\">]),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">//convert &amp;mut[u32] -&gt; &amp;mut X</span>\n</pre></div>\n\n\n<p>but I'm lazy.</p>",
        "id": 189630970,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1583267310
    },
    {
        "content": "<p>well that certainly wont help avoid unsafe code^^</p>",
        "id": 189632744,
        "sender_full_name": "RalfJ",
        "timestamp": 1583268639
    },
    {
        "content": "<p>One more question on this thread. When aliasing a piece of data why is it that calling a helper function invalidates the aliased pointer?<br>\nex.<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55371cda2bcd02fc79e7aa25ff385f79\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55371cda2bcd02fc79e7aa25ff385f79\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55371cda2bcd02fc79e7aa25ff385f79</a></p>",
        "id": 189724945,
        "sender_full_name": "Darakian",
        "timestamp": 1583349487
    },
    {
        "content": "<p>Just <em>as an approximation</em>, anything that would cause a borrow check error with only references will probably invalidate a pointer when you mix references and pointers. Usually once you start using pointers you should stay with only pointers until you're done with all pointer work, and then go back to using references.</p>\n<p>This is part of why bytemuck is useful, because since it's a dedicated function it has lifetime annotations on how the inputs and outputs are linked, so the compiler realizes what's going on.</p>",
        "id": 189734620,
        "sender_full_name": "Lokathor",
        "timestamp": 1583355801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266754\">Yogurt</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189724945\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/no.20item.20granting.20read.20acces.20to.20tag/near/189724945\">said</a>:</p>\n<blockquote>\n<p>One more question on this thread. When aliasing a piece of data why is it that calling a helper function invalidates the aliased pointer?<br>\nex.<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55371cda2bcd02fc79e7aa25ff385f79\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55371cda2bcd02fc79e7aa25ff385f79\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55371cda2bcd02fc79e7aa25ff385f79</a></p>\n</blockquote>\n<p>to get the optimizations we want, calling that helper function (even though it does nothing) basically has the same effect as actually writing to that memory using the reference passed to the function</p>",
        "id": 189919889,
        "sender_full_name": "RalfJ",
        "timestamp": 1583518910
    }
]