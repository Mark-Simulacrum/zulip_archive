[
    {
        "content": "<blockquote>\n<p>However remember that a type containing a <code>MaybeUninit&lt;T&gt;</code> is not necessarily the same layout;</p>\n</blockquote>\n<p>Though as far as I understand there is are exceptions to it as a implicit consequence of the guarantees it gives.</p>\n<p>We probably should document that, as far as I know it holds for following types (<code>MT</code> = <code>T</code> or <code>MaybeUninit&lt;T&gt;</code>):</p>\n<ul>\n<li>allocation, mainly <code>Box&lt;MT&gt;</code> (only if <code>T: Sized</code>??)</li>\n<li><code>[MT; N]</code> and as consequence <code>[MT]</code> and <code>Vec&lt;MT&gt;</code> used for vecs unstable uninit apis</li>\n</ul>\n<p>Is that correct? Did I miss anything?</p>",
        "id": 271556535,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644575245
    },
    {
        "content": "<p>Also is the assumtion correct that this also upholds for types containing the listed types, e.g. <code>Box&lt;[T]&gt;</code> having guaranteed same layout as <code>Box&lt;[MyabeUninit&lt;T&gt;]&gt;</code>?</p>",
        "id": 271558784,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644576569
    },
    {
        "content": "<p>MaybeUninit&lt;T&gt; must be the same layout as T because of repr(transparent), yes.</p>\n<p>If the quote meant that a generic type with repr(rust) could somehow have separate layouts for TheStruct&lt;T&gt; compared to TheStruct&lt;MaybeUninit&lt;T&gt;&gt;, that part is also true.</p>",
        "id": 271583721,
        "sender_full_name": "Lokathor",
        "timestamp": 1644589520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209646\">Philipp Korber</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/repr.28transparent.29.20and.20types.20containing.20it/near/271558784\">said</a>:</p>\n<blockquote>\n<p>Also is the assumtion correct that this also upholds for types containing the listed types, e.g. <code>Box&lt;[T]&gt;</code> having guaranteed same layout as <code>Box&lt;[MyabeUninit&lt;T&gt;]&gt;</code>?</p>\n</blockquote>\n<p>No. It really doesn't. Likewise, it doesn't guarantee it for <code>Vec&lt;MT&gt;</code>. The layout of <code>[MaybeUninit&lt;T&gt;]</code> and <code>[T]</code> are the same (matches the underlying array), but this doesn't extend to pointers to such types. You can't transmute between <code>&amp;[MaybeUninit&lt;T&gt;]</code> and <code>&amp;[T]</code> or the other way arround,  but you can decompose the slice using <code>as_ptr()</code> and <code>len()</code> or <code>&lt;*const [T]&gt;::into_raw_parts</code> (unstable), then perform the pointer cast, and reconstruct into the appropriate type using <code>core::slice::from_raw_parts</code> or <code>core::ptr::slice_from_raw_parts</code> (or <code>core::ptr::from_raw_parts</code>).<br>\nLikewise for <code>Vec</code>: You can't just blindly transmute, but you can deconstruct it into raw parts, then reconstruct a new one.</p>",
        "id": 271586663,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644590882
    },
    {
        "content": "<p>Also note that just because the standard library relies on some layout detail, does not mean that user code can. The standard library is directly intertwined with the compiler, and can rely on said compiler doing what it wants.</p>",
        "id": 271587104,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644591097
    },
    {
        "content": "<p>(note that current rustc does work in practice with a direct transmute between slice types of a repr(transparent) type and the inner type, it just isn't <strong>guaranteed</strong> to always work properly in future rustc versions)</p>",
        "id": 271593728,
        "sender_full_name": "Lokathor",
        "timestamp": 1644593995
    },
    {
        "content": "<p>For example Option&lt;&amp;T&gt; and Option&lt;MaybeUninit&lt;&amp;T&gt;&gt; can't have the same layout due to an uninit value potentially being the niche used for None.</p>",
        "id": 271597075,
        "sender_full_name": "bjorn3",
        "timestamp": 1644595322
    },
    {
        "content": "<p>Then is <code>Box::new(MaybeUninit::&lt;T&gt;::unit())</code> which is not transmuted but ptr-cast and then later dropped as an <code>Box&lt;T&gt;</code> sound?</p>\n<p>Because that is way more ergonomic then directly interacting with the allocation API.</p>",
        "id": 271597236,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644595376
    },
    {
        "content": "<p>if you don't initialize it, no. if you do I would expect it to be sound. not sure about what we guarantee though.</p>",
        "id": 271597497,
        "sender_full_name": "bjorn3",
        "timestamp": 1644595471
    },
    {
        "content": "<p>yes, initialized <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  Else that would be an problem.</p>",
        "id": 271597616,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644595522
    },
    {
        "content": "<p>If <code>[T;1]</code> is guaranteed to have the same layout as <code>T</code> (at least in absence of things like <code>packed</code>) and  if <code>[MaybeUninit&lt;T&gt;]</code> is guaranteed to have the same layout as <code>[T]</code> then I guess it needs to be sound <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Not sure about the first part though.</p>",
        "id": 271598189,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644595755
    },
    {
        "content": "<p>thanks btw.</p>",
        "id": 271598258,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644595795
    },
    {
        "content": "<p>Also, in general <code>Foo&lt;T&gt;</code> can hold a <code>&lt;T as SomeTrait&gt;::AssocType</code>, so <code>Foo&lt;T&gt;</code> and <code>Foo&lt;U&gt;</code> can be arbitrarily different regardless of any similarities between <code>T</code> and <code>U</code>.</p>\n<p>For arrays, though, <code>[T; 1]</code> is definitely the same as <code>T</code> in layout.  There's a couple of ways to see that -- one is via <a href=\"https://doc.rust-lang.org/nightly/std/slice/fn.from_ref.html\">https://doc.rust-lang.org/nightly/std/slice/fn.from_ref.html</a> + <code>TryInto&lt;&amp;[T;1]&gt;</code>.</p>",
        "id": 271608612,
        "sender_full_name": "scottmcm",
        "timestamp": 1644600197
    }
]