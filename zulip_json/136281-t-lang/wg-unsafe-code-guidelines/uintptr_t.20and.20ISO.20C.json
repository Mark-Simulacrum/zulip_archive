[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr-.3Eint-.3Eptr.20as.20side.20effect.20destroys.20modular.20reasoning/near/276106464\">said</a>:</p>\n<blockquote>\n<p>This is (effectively) not true, you are missing the (placed later, lol C standard) statement:</p>\n<blockquote>\n<p>The following type designates an unsigned integer type with the property that any valid pointer to void can be converted to this type, then converted back to pointer to void, and the result will compare equal to the original pointer. <code>uintptr_t</code></p>\n</blockquote>\n<p>So that's only true in the sense that uintptr_t is optional, and thus is irrelevant to these arguments.</p>\n</blockquote>\n<p>So my understanding is that if Rust is lowered to C (for the sake of argument here!) and <code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE) does the appropriate motions on </code>uintptr_t`, even if the resulting integer is the same, I think it was altered and thus not required to actually return the original pointer.</p>",
        "id": 276107170,
        "sender_full_name": "Jubilee",
        "timestamp": 1647893561
    },
    {
        "content": "<p>certainly it's well defined in any of actually-formal provenance proposals, but technically on the current version of the standard it would depend if you claim that integers are not substitutable (for purposes other than restrict, which has extremely broad wording that definitely permits this through its gate)</p>",
        "id": 276108222,
        "sender_full_name": "Talchas",
        "timestamp": 1647894123
    },
    {
        "content": "<p>Right, it basically depends on optimization things, which aren't what the Standard specifies, essentially.</p>",
        "id": 276108307,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894173
    },
    {
        "content": "<p>I mean, a sane language spec might say that integers are substitutable (and then CHERI is right out with uintptr_t definitely not being an integer by spec as well as in practice)</p>",
        "id": 276108540,
        "sender_full_name": "Talchas",
        "timestamp": 1647894299
    },
    {
        "content": "<p>Ah, yes. I agree, I just insist that ISO C is not a sane language spec.</p>",
        "id": 276108592,
        "sender_full_name": "Jubilee",
        "timestamp": 1647894330
    },
    {
        "content": "<p>\"I totally want my max function to maybe have to care about which integer it returns on ==\"</p>",
        "id": 276108673,
        "sender_full_name": "Talchas",
        "timestamp": 1647894364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/uintptr_t.20and.20ISO.20C/near/276108307\">said</a>:</p>\n<blockquote>\n<p>Right, it basically depends on optimization things, which aren't what the Standard specifies, essentially.</p>\n</blockquote>\n<p>If the C standard adopts the PNVI-ae proposal wouldn't it be fine?</p>",
        "id": 276108729,
        "sender_full_name": "Nick12",
        "timestamp": 1647894393
    },
    {
        "content": "<p>yes, all of the proposals, even PVI permit it currently</p>",
        "id": 276108755,
        "sender_full_name": "Talchas",
        "timestamp": 1647894410
    },
    {
        "content": "<p>(though PVI is particularly not fleshed out in the copy I read, and left tons of the int provenance stuff as \"TBD given that we aren't suggesting PVI anyways\")</p>",
        "id": 276108815,
        "sender_full_name": "Talchas",
        "timestamp": 1647894456
    },
    {
        "content": "<p>Right.</p>",
        "id": 276110519,
        "sender_full_name": "Jubilee",
        "timestamp": 1647895362
    }
]