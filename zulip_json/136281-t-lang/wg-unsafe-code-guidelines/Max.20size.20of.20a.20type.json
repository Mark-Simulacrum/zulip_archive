[
    {
        "content": "<p>So while preparing <a href=\"https://github.com/rust-lang/miri/pull/2039\">https://github.com/rust-lang/miri/pull/2039</a> I realized that the actual check Miri is doing for the \"maximal size of a type\" is different from what we all expect... Cc <span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> <span class=\"user-mention\" data-user-id=\"132829\">@Christopher Durham</span> <br>\nSpecifically, Miri uses <code>tcx.data_layout.obj_size_bound()</code>, which on 64bit systems is 2^47-1, not isize::MAX.</p>",
        "id": 276730543,
        "sender_full_name": "RalfJ",
        "timestamp": 1648307558
    },
    {
        "content": "<p>I am not sure of the exact role of <code>obj_size_bound</code>, but -- we probably want to stick to isize::MAX, I assume?</p>",
        "id": 276730564,
        "sender_full_name": "RalfJ",
        "timestamp": 1648307618
    },
    {
        "content": "<p>being consistent is safe yeah. i think it could vaguely be coherent to allow an implementation to not allow some smaller types \"as an implementation detail\" but that it's probably a more consistent/usable system if that is just handled by the part where you actually try to allocate memory for it and oom/fault</p>",
        "id": 276730853,
        "sender_full_name": "Gankra",
        "timestamp": 1648308030
    },
    {
        "content": "<p>anything bigger than a few MB is presumably \"I believe you have made a mistake\" so once you're up into GB nothing really matters anyway and you might as well pretend it works until they try to allocate</p>",
        "id": 276730932,
        "sender_full_name": "Gankra",
        "timestamp": 1648308140
    },
    {
        "content": "<p>*mut T where you're only accessing a prefix or something is the only plausible place where you can get far with such a type</p>",
        "id": 276730977,
        "sender_full_name": "Gankra",
        "timestamp": 1648308241
    },
    {
        "content": "<p>normal brain: use a private field so that this type can't be constructed by external code<br>\nexpanding brain: use an empty enum so no one can construct it<br>\ngalaxy brain: make the type contain [u8; isize::MAX] to make it impossible for a variable to even gesture at the possibility of its runtime existence (i.e. with Option&lt;T&gt;)</p>",
        "id": 276731267,
        "sender_full_name": "Gankra",
        "timestamp": 1648308680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Max.20size.20of.20a.20type/near/276730853\">said</a>:</p>\n<blockquote>\n<p>being consistent is safe yeah. i think it could vaguely be coherent to allow an implementation to not allow some smaller types \"as an implementation detail\" but that it's probably a more consistent/usable system if that is just handled by the part where you actually try to allocate memory for it and oom/fault</p>\n</blockquote>\n<p>yeah but presumably we shouldnt let implementations make that UB^^</p>",
        "id": 276731615,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309204
    },
    {
        "content": "<p>Indeed. This seems like something that would be fairly easy to enforce via static checks (for static/stack/thread allocations) or OOM (for dynamic allocations).</p>",
        "id": 276731719,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648309357
    },
    {
        "content": "<p>well my only concern is that something somewhere might actually assume <code>obj_size_bound</code> is useful for optimizations</p>",
        "id": 276731806,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309483
    },
    {
        "content": "<p>but it seems we generally agree that would be a bug we should fix? and the only bound allowable for optimizations is <code>isize::MAX</code>?</p>",
        "id": 276731812,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309492
    },
    {
        "content": "<p>Well, there are some implicit ways that an implementation-specific limit on object sizes could be used for optimization, most notably that <code>p.offset(n)</code> will produce a canonical address on something like x86_64.</p>",
        "id": 276731892,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648309613
    },
    {
        "content": "<p>But if it's being enforced statically/dynamically (rather than merely assumed), then it shouldn't be a problem to assume in that case.</p>",
        "id": 276731917,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648309658
    },
    {
        "content": "<p>I do think it's reasonable to assume that an object that could not possible exist in memory does not, in fact, exist in memory.</p>",
        "id": 276731985,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648309747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Max.20size.20of.20a.20type/near/276731892\">said</a>:</p>\n<blockquote>\n<p>Well, there are some implicit ways that an implementation-specific limit on object sizes could be used for optimization, most notably that <code>p.offset(n)</code> will produce a canonical address on something like x86_64.</p>\n</blockquote>\n<p>yes and what I am saying is it would be a bug to assume obj_size_bound when optimizing <code>offset</code></p>",
        "id": 276731986,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309750
    },
    {
        "content": "<p>unless we have some other way of knowing that no allocation that large can exist</p>",
        "id": 276731993,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309776
    },
    {
        "content": "<p>but the burden of proof for that is on the compiler, not the programmer</p>",
        "id": 276731998,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309793
    },
    {
        "content": "<p>The easiest example would be on w65, if <code>{u,i}size</code> has to be 32-bits like pointers. It's fairly clear that a 2^31 byte object cannot exist on a platform with a 24-bit address bus.</p>",
        "id": 276732061,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648309826
    },
    {
        "content": "<p>the compiler can always do whatever it wants when it can prove it correct. :) the only part we have to talk about is the part that it expects <em>the programmer</em> to prove.</p>",
        "id": 276732063,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Max.20size.20of.20a.20type/near/276731993\">said</a>:</p>\n<blockquote>\n<p>unless we have some other way of knowing that no allocation that large can exist</p>\n</blockquote>\n<p>We'll I'd just assume that <code>max_obj_size</code> would be the provably maxmimum size for objects on the platform.</p>",
        "id": 276732090,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648309879
    },
    {
        "content": "<p>sure, as long as you as compiler author take responsibility for that and never blame your users if it turns out wrong :)</p>",
        "id": 276732199,
        "sender_full_name": "RalfJ",
        "timestamp": 1648310018
    },
    {
        "content": "<p>hm, there is an odd comment in the <code>Size</code> type that makes me unsure if we can use it to represent isize::MAX on 64bit targets...</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Size</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The top 3 bits are ALWAYS zero.</span>\n<span class=\"w\">    </span><span class=\"n\">raw</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> any idea what that is about?</p>",
        "id": 276808574,
        "sender_full_name": "RalfJ",
        "timestamp": 1648416167
    },
    {
        "content": "<p>looks like it was added in this PR <a href=\"https://github.com/rust-lang/rust/pull/80042\">https://github.com/rust-lang/rust/pull/80042</a></p>",
        "id": 276808659,
        "sender_full_name": "RalfJ",
        "timestamp": 1648416250
    },
    {
        "content": "<p>this has big llvm energy</p>",
        "id": 276809774,
        "sender_full_name": "Gankra",
        "timestamp": 1648417709
    },
    {
        "content": "<p>extremely practical but also fuuuuck consistency</p>",
        "id": 276809779,
        "sender_full_name": "Gankra",
        "timestamp": 1648417725
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/95388\">https://github.com/rust-lang/rust/pull/95388</a></p>",
        "id": 276814555,
        "sender_full_name": "RalfJ",
        "timestamp": 1648425344
    }
]