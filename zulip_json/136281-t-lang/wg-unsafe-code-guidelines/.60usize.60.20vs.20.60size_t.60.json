[
    {
        "content": "<p>Is <code>usize</code> guaranteed to be the same as C's <code>size_t</code>? Even on weirder platforms? I've always thought \"yes\" (and I believe it's currently true on all supported platforms), but I've also always mostly ignored the discussions around potential future w65-support.</p>\n<p>If it's not, we should probably have a <code>std::os::raw::c_size_t</code> (or maybe something in libcore)</p>",
        "id": 250655201,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629913808
    },
    {
        "content": "<p><code>usize</code> is <code>uintptr_t</code>.<code>size_t</code> and <code>uintptr_t</code> may not be the same for all platforms.</p>",
        "id": 250656111,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629914216
    },
    {
        "content": "<p>It's the same for all currently supported platforms though.</p>",
        "id": 250656170,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629914244
    },
    {
        "content": "<p>nards. I expect that will break some people.</p>",
        "id": 250658781,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629915386
    },
    {
        "content": "<p>i filed <a href=\"https://github.com/rust-lang/rust/pull/88340\">https://github.com/rust-lang/rust/pull/88340</a> for this.</p>",
        "id": 250660762,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629916231
    },
    {
        "content": "<p>this will absolutely break some people because bindgen has a flag to just plain convert size_t to usize in generated code.</p>",
        "id": 250661276,
        "sender_full_name": "Lokathor",
        "timestamp": 1629916453
    },
    {
        "content": "<p>It's not on by default, although TBH it should be, since I see way more libraries that pregenerate incorrectly as a result of this. (for example, <a href=\"https://github.com/Rust-SDL2/rust-sdl2/blob/master/sdl2-sys/sdl_bindings.rs#L951\">https://github.com/Rust-SDL2/rust-sdl2/blob/master/sdl2-sys/sdl_bindings.rs#L951</a> is definitely not a thing that works on win64, where ulong is 32 bits but size_t is 64)</p>",
        "id": 250661706,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629916656
    },
    {
        "content": "<p>TBH I am not particularly worried about <code>usize</code> and <code>size_t</code> not being the same. Many other things will break as well :)</p>",
        "id": 250663470,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629917366
    },
    {
        "content": "<p>There are a lot C code in the wild assuming <code>size_t</code> and <code>uintptr_t</code> equivalence</p>",
        "id": 250663525,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629917391
    },
    {
        "content": "<p>In Linux world pretty much everything assume <code>long</code> being the same as these as well, and kernel also makes that assumption. For that reason I believe a new architecture would choose an ABI that makes these all the same to aid portability.</p>",
        "id": 250664026,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629917588
    },
    {
        "content": "<p>I agree new architectures will, but people are working on getting rust on less-new architectures that don't: <a href=\"https://internals.rust-lang.org/t/abi-discussion-for-w65/15092\">https://internals.rust-lang.org/t/abi-discussion-for-w65/15092</a></p>",
        "id": 250666014,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629918329
    },
    {
        "content": "<p>Indeed - I specified the abi mentioned in that post, and chose to differ size_t and uintptr_t for a particular reason, which I believe I noted in a post (particularily, it significantly penalizes codegen, especially of the commonly used memcpy).</p>",
        "id": 250672401,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629920848
    },
    {
        "content": "<p>I'm not, at this time, going to say non-viably so, but I would <em>strongly prefer</em> the separation exist.</p>",
        "id": 250673581,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629921362
    },
    {
        "content": "<p>I mean, i'm not really a fan of repeating C's complexities here, especially given that most C code gets this wrong. I think its better to have worse codegen (or even fail to support) very niche platforms, if it makes things simpler and safer for 99.99% of users.</p>",
        "id": 250673966,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629921521
    },
    {
        "content": "<p>Well, in this case, I'm talking potentially 20+ cycles per iteration of memcpy extra.</p>",
        "id": 250674275,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629921630
    },
    {
        "content": "<p>cant you just implement a better memcpy by hand (even if it takes doing it in asm)?</p>",
        "id": 250674486,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629921735
    },
    {
        "content": "<p>Depends really, if the allocation size is also extended (otherwise, it could be fine). One thing that can't be fixed is the abi of usize, which costs an extra 15 cycles to load (though it is only a one time cost), since it has to copy the value into a memory location, then if it's generating code for the non-extended ptrdiff_t, it has to load the value into a hardware register (whereas current would just already be passed in that hardware register).</p>",
        "id": 250675742,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629922290
    },
    {
        "content": "<p>I think it's technically possible to have <code>usize</code> and <code>size_t</code> differ. I do think that doing so invites a world of incompatibilities with C FFI. I don't think <em>Rust</em> will break, in general, just C FFI. So a platform that's prepared to not care very much about interoperability with some C code (which seems likely to be true anyway for an unusual constrained platform) can do that, and we should just document \"this is allowed but unusual and may cause issues such as ...\".</p>",
        "id": 250677582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1629923185
    },
    {
        "content": "<p>Or, in the case of such platforms, you'd likely not be mapping to portable C code anyways, so ensuring to map the types correctly (usize=&gt;uintptr_t, size_t=&gt;u16 in the case of w65). <br>\nAnother possibility is a separation of freestanding/hosted targets (where freestanding isn't guaranteed or likely to have libstd support), and guarantee they are equivalent on hosted.</p>",
        "id": 250678314,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629923530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.60usize.60.20vs.20.60size_t.60/near/250677582\">said</a>:</p>\n<blockquote>\n<p>I think it's technically possible to have <code>usize</code> and <code>size_t</code> differ. I do think that doing so invites a world of incompatibilities with C FFI. I don't think <em>Rust</em> will break, in general, just C FFI. So a platform that's prepared to not care very much about interoperability with some C code (which seems likely to be true anyway for an unusual constrained platform) can do that, and we should just document \"this is allowed but unusual and may cause issues such as ...\".</p>\n</blockquote>\n<p>I guess, although this puts library code in a somewhat awkward place, unfortunately â€” both in the case of c-to-rust and rust-to-c.</p>\n<p>For example, it motivates bindgen not defaulting to --size_t-is-usize, which causes problems like the one I linked above (on very real/common platforms like win64).</p>",
        "id": 250678819,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629923799
    },
    {
        "content": "<p>Bindgen may just not be useful in generating code targetting w65 and similar platforms with the distinction, I'd honestly be fine with that, as I do most of my C binding by hand anyways.</p>",
        "id": 250679308,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629924010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.60usize.60.20vs.20.60size_t.60/near/250678819\">said</a>:</p>\n<blockquote>\n<p>For example, it motivates bindgen not defaulting to --size_t-is-usize, which causes problems like the one I linked above (on very real/common platforms like win64).</p>\n</blockquote>\n<p>I think the bindings generated by bindgen are only valid for the particular platform. Bindings generated for Linux won't work for Windows, and <code>size_t</code> isn't the only problem here.</p>",
        "id": 250679628,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629924175
    },
    {
        "content": "<p>I agree, but build-time bindgen is particularly painful on windows, and that's why very few people do it. Also, bindgen being a CLI application somewhat disagrees with you.</p>\n<p>Not to mention, there are other non-bindgen problems here, for sure. It's just an example.</p>",
        "id": 250679854,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629924304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.60usize.60.20vs.20.60size_t.60/near/250678819\">said</a>:</p>\n<blockquote>\n<p>For example, it motivates bindgen not defaulting to --size_t-is-usize, which causes problems like the one I linked above (on very real/common platforms like win64).</p>\n</blockquote>\n<p>I think it'd be perfectly reasonable for bindgen to default to supporting <code>usize</code>, and then people on unusual platforms can pass a non-default option to generate bindings.</p>",
        "id": 250723381,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1629955049
    },
    {
        "content": "<p>As people already stated, <code>usize</code> and <code>size_t</code> are not the same everywhere, <br>\nSee also: <a href=\"https://github.com/rust-lang/rust-bindgen/issues/1671\">https://github.com/rust-lang/rust-bindgen/issues/1671</a> for relevant discussion</p>",
        "id": 250752533,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1629974366
    },
    {
        "content": "<p>Yes, I'm aware. I linked that discussion in <a href=\"https://github.com/rust-lang/rust/issues/88345\">https://github.com/rust-lang/rust/issues/88345</a>, which is probably relevant to anybody interested here.</p>",
        "id": 250787153,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629990323
    },
    {
        "content": "<p>Sorry, missed that :)</p>",
        "id": 250981139,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1630091672
    },
    {
        "content": "<p>AFAIK CHERI (a very new, unusual, but also interesting architecture) has uintptr_t != size_t</p>",
        "id": 252033475,
        "sender_full_name": "RalfJ",
        "timestamp": 1630797718
    },
    {
        "content": "<p>Yes, from our lab</p>",
        "id": 252033531,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630797755
    },
    {
        "content": "<p>ah nice :)</p>",
        "id": 252033543,
        "sender_full_name": "RalfJ",
        "timestamp": 1630797783
    },
    {
        "content": "<p>It has wider uintptr_t because the pointers also have all bound information encoded</p>",
        "id": 252033562,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630797814
    },
    {
        "content": "<p>I am not personally involved with CHERI, so I could be wrong, but IIRC pointer arithmetic is complex with CHERI</p>",
        "id": 252033690,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630797952
    },
    {
        "content": "<p>If you cast pointer to integer and do some arithmetic, you might not be able to cast it back while retaining all the permission</p>",
        "id": 252033765,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630798017
    },
    {
        "content": "<p>Hence, in CHERI C/C++, <code>uintptr_t</code> and <code>size_t</code> are very different types. The former holds a full capability and can do normal pointer arithmetic (more-or-less), preserving capability provenance, whilst <code>size_t</code> is just a 64-bit integer, and suffers from the problem you describe. A problem for CHERI in Rust is that we have only <code>usize</code>, but no <code>uptr</code> or similar.<br>\nThere's an <a href=\"#narrow/stream/242906-t-compiler.2Farm/topic/CHERI.2FMorello.20capability.20support\">old thread</a> on CHERI in particular. Notably: <a href=\"https://github.com/rust-lang/rust/issues/65473\">https://github.com/rust-lang/rust/issues/65473</a><br>\nI'm not aware of any fundamental changes in any of the topics discussed there, but it's quite possible that I've missed something. I'm hoping to do some work in the area but I'm not sure exactly what, or when, or with whom!</p>",
        "id": 252451202,
        "sender_full_name": "Jacob Bramley",
        "timestamp": 1631104322
    },
    {
        "content": "<p>I'd be willing to help with that, depending on what it entails. Resolving this is basically a prerequesite to supporting w65 in rust.</p>",
        "id": 252459888,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631108070
    },
    {
        "content": "<p>Would saying this is not the required to be the case require an RFC? Or would it just be a T-lang MCP? I would typically assume not since it's really just affirming what is already the case, but given that some stuff does rely on it, perhaps a full RFC may be warranted.</p>",
        "id": 253623632,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631815292
    },
    {
        "content": "<p>There should be an RFC about any change here because 99% of the rust world doesn't follow lang MCP stuff.</p>",
        "id": 253625615,
        "sender_full_name": "Lokathor",
        "timestamp": 1631815985
    },
    {
        "content": "<p>One reason I could think of that it wouldn't be is because we aren't really changing anything, it's just a clarification, since  this is (presumably) already the case. The second point is fair, though.</p>",
        "id": 253653454,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631827435
    },
    {
        "content": "<p>I'm going to write up a Pre-RFC on IRLO soon-ish. <br>\nTo be honest, I'm not even sure how this would be structured, since typically RFCs define something, and the thing we are defining is that something isn't necessarily guaranteed.</p>",
        "id": 254304510,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632275989
    },
    {
        "content": "<p>Posted: <a href=\"https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369\">https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369</a></p>",
        "id": 254461034,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632356797
    }
]