[
    {
        "content": "<p>I have a question about partially initialized values related to the <code>exhaustive_patterns</code> feature. This feature allows omitting match branches when the pattern is for an uninhabited type. We worry that might introduce unsoundness.</p>",
        "id": 218791869,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054240
    },
    {
        "content": "<p>Specifically, it allows the following code:</p>",
        "id": 218791876,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054254
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">union</span> <span class=\"nc\">Uninit</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">value</span>: <span class=\"nc\">ManuallyDrop</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">uninit</span>: <span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">Uninit</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Uninit</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">uninit</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">).</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Initialize first part of the tuple</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218791878,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054256
    },
    {
        "content": "<p>This seems bad. Would matching on a partially-initialized value otherwise be ok (i.e. not UB)?</p>",
        "id": 218791888,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054271
    },
    {
        "content": "<p>Cf <a href=\"https://github.com/rust-lang/rust/issues/51085\">https://github.com/rust-lang/rust/issues/51085</a> for context about the feature</p>",
        "id": 218791929,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054289
    },
    {
        "content": "<p>Currently if I add a <code>(v, _) =&gt; println!(\"{}\", v);</code> branch to the match, it executes nicely, even in MIRI (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8426097da3441798bc5b4e580d9fb077\">playground</a>). If this would be ok and not UB, then the feature is unsound</p>",
        "id": 218791968,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054401
    },
    {
        "content": "<p>My reading of the nomicon seems to indicate that a partially-initialized tuple is invalid, and I guess matching an invalid value is UB, but I'm not very sure I'm understanding right</p>",
        "id": 218792057,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054485
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>, I've been told you would know</p>",
        "id": 218792218,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607054681
    },
    {
        "content": "<p>At the very least, producing (IE. performing a typed copy) or operating on an invalid value is undefined behaviour (as to whether or not it is even permitted to exist, I believe this goes into <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">https://github.com/rust-lang/unsafe-code-guidelines/issues/84</a> territory). I would assume this extends to matching or using a pattern guard on an invalid value. And <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/69\">https://github.com/rust-lang/unsafe-code-guidelines/issues/69</a> seems to say that, yes, an aggregate containing an invalid field is itself invalid.</p>",
        "id": 218793701,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607056689
    },
    {
        "content": "<p>I would expect you to need <code>match *x.value.0</code> for this to be valid</p>",
        "id": 218796183,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607060370
    },
    {
        "content": "<p>otherwise like you said, you have a value of an uninhabited type</p>",
        "id": 218796189,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607060393
    },
    {
        "content": "<p>maybe we could make <code>match *x.value</code> a compiler warning that's deny-by-default?</p>",
        "id": 218796244,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607060434
    },
    {
        "content": "<p>Does an uninitialized value count as an invalid value?</p>",
        "id": 218844910,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607094844
    },
    {
        "content": "<p>Also something else that <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> pointed out <a href=\"https://github.com/rust-lang/rust/issues/78123#issuecomment-737746503\">here</a>: even if the current rules disallow matching on partially-uninitialized values, might that ever be relaxed in the future? If yes then the compiler should not rely on it being illegal</p>",
        "id": 218845305,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607095007
    },
    {
        "content": "<p>I think it is appropriate to allow the match compiler to access whatever it needs to of the scrutinee, which would support the interpretation that the argument to a <code>match</code> must be fully initialized (counts as a use)</p>",
        "id": 218845741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095188
    },
    {
        "content": "<p>an uninitialized value is different from an invalid value - the type system treats them very differently because initialization requires an initial data flow analysis that has to be mostly syntactic because programmers have to reason about it</p>",
        "id": 218846044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095301
    },
    {
        "content": "<p>Actually looking at your code you mean uninitialized at runtime, not statically as in <code>let x: (u32, !); x.0 = 22;</code>. I agree that the rules about what a match actually \"uses\" on its input are not entirely clear, I think Ralf has a post about that somewhere</p>",
        "id": 218846687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095577
    },
    {
        "content": "<p>Ah, that would be quite helpful if it's been written down somewhere</p>",
        "id": 218846829,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607095638
    },
    {
        "content": "<p>I've scrolled through Ralf's blog but couldn't see something that looked like that</p>",
        "id": 218854355,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607098551
    },
    {
        "content": "<p>I was worried that the following code might have compiled:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(never_type)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// initialize first part of the tuple</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// access only first part of the tuple</span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Luckily <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7ba16bde94fe18f61160def362bfe001\">it does fail</a> with:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error[E0381]: assign to part of possibly-uninitialized variable: `x`\n --&gt; src/main.rs:6:5\n  |\n6 |     x.0 = 22; // initialize first part of the tuple\n  |     ^^^^^^^^ use of possibly-uninitialized `x`\n\nerror: aborting due to previous error\n</code></pre></div>\n<p>which does show that partial initialization of aggregates is non-trivial, even in statically guaranteed cases.</p>\n<p>To me, a very simple model (<em>i.e.</em>, a <em>safer</em> model, since for these things subtlety leads to footguns and things being error-prone) is to require that for a <code>union</code> (ideally, all <code>union</code>s, at worst, only <code>#[repr(Rust)]</code> <code>union</code>s), whenever a place in a variant is <em>read</em> / used as a value, then that the whole variant in the <code>union</code> be<em>valid</em> (this remains more lenient than the <em>active variant</em> rule from C++): if people need more fine-grained initialization, all they have to do is wrap each field of the variant in a <code>MaybeUninit</code>!</p>\n<p>So the main point here would be to justify why/when the above model, especially when each field (within a variant) can be <code>MaybeUninit</code>-wrapped, would not be expressive / flexible enough (thinking of some very shady C-isms, here), so as to justify that the language consider supporting these weird \"partially inhabited/valid types/values\".</p>",
        "id": 218862456,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607102078
    },
    {
        "content": "<p>Hm, yet if I can write <code>let y = x.0</code> it's surprising that I can't also write <code>let (y, _) = x</code> or the equivalent match statement</p>",
        "id": 218877921,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607108878
    },
    {
        "content": "<p>I mean, if <code>x.0</code> does not count as reading the whole of <code>x</code> as a value, I would like <code>let (y, _) = x</code> to also not count as reading the whole of <code>x</code> as a value. So we'd be back to square one, unless <code>x.0</code> also requires the whole variant to be valid</p>",
        "id": 218878123,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607108980
    },
    {
        "content": "<p>Actually maybe that's what you meant</p>",
        "id": 218878419,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607109125
    },
    {
        "content": "<p>Hm, there is a difference between <code>match</code> and destructuring <code>let</code> on partially-moved values. I imagine that similarly destructuring <code>let</code> on a partially initialized value could be ok, but not a <code>match</code> on that same value</p>",
        "id": 218878965,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607109391
    },
    {
        "content": "<p>I'm actually thinking of a UCG issue about whether <code>&amp;!</code> is uninhabited</p>",
        "id": 218888885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607114684
    },
    {
        "content": "<p>or maybe it was a rust issue? I can't remember</p>",
        "id": 218888924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607114703
    },
    {
        "content": "<p><a href=\"https://internals.rust-lang.org/t/blog-post-never-patterns-exhaustive-matching-and-uninhabited-types/8197\">this</a> looks nearest to my recollection</p>",
        "id": 218890733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607115687
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/77\">UCG#77</a> mentions <code>&amp;!</code></p>",
        "id": 218892017,
        "sender_full_name": "cuviper",
        "timestamp": 1607116421
    },
    {
        "content": "<p>niko's never patterns blog post is indeed what triggered my question. <code>&amp;!</code> is not a problem for soundness currently because exhaustiveness checking errs on the side of treating all references as inhabited</p>",
        "id": 218895058,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607118267
    },
    {
        "content": "<p>Huh, that irlo thread is full of good info actually, thx for that</p>",
        "id": 218896151,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607118930
    },
    {
        "content": "<p>The discussion there and here answers my question: it seems that we don't want to commit to forbidding matching on a partially initialized value right now</p>",
        "id": 218897977,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607119955
    },
    {
        "content": "<p>Thanks for the pointers everyone!</p>",
        "id": 218897988,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607119965
    },
    {
        "content": "<p>pointers <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 218911795,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607132952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218844910\">said</a>:</p>\n<blockquote>\n<p>Does an uninitialized value count as an invalid value?</p>\n</blockquote>\n<p>there is no such thing as an \"uninitialized value\" so I am not sure how to answer this question.<br>\nthe way values work is that there is a <em>representation</em> of the value stored in memory, and when you access memory at some type, the bytes there are interpreted according to the type to reconstruct the value of the given type. if the memory is uninitialized, then most of the time that is not a representation of any value, and thus UB. \"invalid value\" is short-hand for \"some sequence of bytes that is not a valid representation of any value of the given type\".</p>\n<p>(We are often a bit sloppy about these things when it is not worth going into all the detauls, but here I felt like there's so much confusion around that being sloppy wouldn't help.^^)</p>",
        "id": 218935052,
        "sender_full_name": "RalfJ",
        "timestamp": 1607174633
    },
    {
        "content": "<p>Oh I see, thanks for the precision</p>",
        "id": 218936169,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607176458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'm even more confused by your replies on the tracking issue <a href=\"https://github.com/rust-lang/rust/issues/51085\">https://github.com/rust-lang/rust/issues/51085</a> now &gt;&lt;</p>",
        "id": 218936872,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607177733
    },
    {
        "content": "<p>I seem to understand that having a value of an uninhabited type like (u32, !) is UB today, and therefore match checking can safely assume that there will be no such value around even in the presence of unsafe code. Therefore writing <code>match x {}</code> for <code>x: (u32, !)</code> is not UB.</p>",
        "id": 218937055,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607178029
    },
    {
        "content": "<p>But you also <a href=\"https://github.com/rust-lang/rust/issues/51085#issuecomment-739250270\">said</a> that reading the initialized part of a partially-initialized value is ok, so if I create a partially-initialized value of type <code>(u32, !)</code> using unsafe then I should be allowed to read the u32 using <code>match x { (v, _) =&gt; ... }</code>. Or am I misunderstanding sth?</p>",
        "id": 218937190,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607178309
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> so here's the thing -- if you show me some MIR code, I have a very good model for telling you whether it is UB or not. But there is no <code>match</code> in MIR. That's one of the reasons I like doing such work on MIR. :D<br>\nAll questions around <code>match</code> thus involve not only MIR semantics, but also the desugaring/lowering of Rust into MIR. (a) I am not very familiar with that lowering, and (b) that lowering is not governed by any guarantees or RFCs or so, so it might change.</p>",
        "id": 218937520,
        "sender_full_name": "RalfJ",
        "timestamp": 1607178959
    },
    {
        "content": "<p>That's what makes any match-related question basically impossible to answer conclusively, I am afraid.</p>",
        "id": 218937561,
        "sender_full_name": "RalfJ",
        "timestamp": 1607178975
    },
    {
        "content": "<p>Ah</p>",
        "id": 218937572,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179043
    },
    {
        "content": "<blockquote>\n<p>Therefore writing match x {} for x: (u32, !) is not UB.</p>\n</blockquote>\n<p>Eh, what? I don't follow you here. \"it's invalid therefore it is not UB\"?<br>\nalso, <em>writing</em> code is never UB, <em>executing</em> it is. And executing <code>match x {}</code> is UB for any <code>x</code>, since this is clearly unreachable code, otherwise the compiler would never accept the empty match.</p>",
        "id": 218937574,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179057
    },
    {
        "content": "<p>Ah right, it appears I use those words without a good understanding of them</p>",
        "id": 218937617,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179091
    },
    {
        "content": "<p>yeah, empty types can break your mind if you are not used to them.^^ even more so in a language with unsafe operations such as Rust...</p>",
        "id": 218937624,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179135
    },
    {
        "content": "<p>Then without going into those details I clearly don't understand, my question is: can you confidently tell me whether allowing users to write <code>match x {}</code> on <code>x: (u32, !)</code> is a good idea?</p>",
        "id": 218937638,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179194
    },
    {
        "content": "<p>the simplest case is <code>x: !</code>. given that, <code>match x {}</code> is safe to write. However, if this code ever gets <em>executed</em>, that's UB. How can it be safe? Well, <code>x: !</code> can never exist, so this code can never be reached in the first place, so what happens when we reach it is a moot point.</p>\n<p>that's the story without unsafe code, anyway. with unsafe code however, creating an <code>x: !</code> e.g. via <code>transmute</code> is UB in the first place, so we are still good.</p>",
        "id": 218937691,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179256
    },
    {
        "content": "<p>Ok, I follow so far</p>",
        "id": 218937700,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218937638\">said</a>:</p>\n<blockquote>\n<p>Then without going into those details I clearly don't understand, my question is: can you confidently tell me whether allowing users to write <code>match x {}</code> on <code>x: (u32, !)</code> is a good idea?</p>\n</blockquote>\n<p>I personally would rather have people write <code>match x { ! }</code>. That's why I proposed the <code>!</code> pattern to Niko, which you read about I think.</p>",
        "id": 218937705,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179287
    },
    {
        "content": "<p>but that's my own opinion, not any kind of consensus</p>",
        "id": 218937708,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179317
    },
    {
        "content": "<p>I prefer being explicit over being ergonomic</p>",
        "id": 218937745,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179329
    },
    {
        "content": "<p>I know other people disagree and they have good arguments</p>",
        "id": 218937747,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179336
    },
    {
        "content": "<p>Ok, I understand that too.</p>",
        "id": 218937777,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179392
    },
    {
        "content": "<p>actually <code>match x { (_, !) }</code> would be even better^^</p>",
        "id": 218937778,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179393
    },
    {
        "content": "<p>that makes it fully explicit that you are taking apart the tuple to reach a proof that this is unreachable code</p>",
        "id": 218937783,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179408
    },
    {
        "content": "<p>Yeah, that's the really cool bit about never patterns indeed</p>",
        "id": 218937792,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179441
    },
    {
        "content": "<p>Follow-up question: should <code>match x { _ =&gt; ... }</code> on <code>x: (u32, !)</code> lint that the branch is unreachable?</p>",
        "id": 218937835,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179468
    },
    {
        "content": "<p>but of course people want to use <code>!</code> to make more patterns exhaustive, like making <code>Ok(_)</code> exhaustive for <code>Result&lt;_, !&gt;</code>. That is in conflict with being fully explicit.</p>",
        "id": 218937840,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218937835\">said</a>:</p>\n<blockquote>\n<p>Follow-up question: should <code>match x { _ =&gt; ... }</code> on <code>x: (u32, !)</code> lint that the branch is unreachable?</p>\n</blockquote>\n<p>this boils down to whether this code \"produces\"/\"uses\" <code>x</code> or not. which is something the lang team will have to decide at some point.</p>",
        "id": 218937929,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179647
    },
    {
        "content": "<p>a related question is whether <code>let _ = *foo;</code> actually dereferences <code>foo</code> to \"produce\" the value or not.</p>",
        "id": 218937975,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179688
    },
    {
        "content": "<p>Ok, so to be conservative I should not lint that the branch is unreachable</p>",
        "id": 218937978,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179701
    },
    {
        "content": "<p>currently this does not even require <code>unsafe</code> oO</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">foo</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218937990,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179752
    },
    {
        "content": "<p><code>_</code> patterns are weird^^</p>",
        "id": 218937997,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179770
    },
    {
        "content": "<p>huh indeed</p>",
        "id": 218937998,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179776
    },
    {
        "content": "<p>and this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">foo</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles effectively to <code>let x = (*foo).0</code>, so the second field never gets loaded, so there is no UB when it is uninitialized</p>",
        "id": 218938056,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179847
    },
    {
        "content": "<p>but that might just be what happens to happen; this does not mean there is a guarantee that things will stay that way</p>",
        "id": 218938063,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218937929\">said</a>:</p>\n<div class=\"codehilite\"><pre><span></span><code>this boils down to whether this code &quot;produces&quot;/&quot;uses&quot; `x` or not. which is something the lang team will have to decide at some point.\n</code></pre></div>\n<p>Oh I see why I keep being confused: using a value asserts its validity. It feels kinda backwards causality</p>",
        "id": 218938069,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179868
    },
    {
        "content": "<p>it's all about precisely defining the verb \"using\"</p>",
        "id": 218938075,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179900
    },
    {
        "content": "<p>which it turns out is hard^^</p>",
        "id": 218938077,
        "sender_full_name": "RalfJ",
        "timestamp": 1607179905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218938063\">said</a>:</p>\n<blockquote>\n<p>but that might just be what happens to happen; this does not mean there is a guarantee that things will stay that way</p>\n</blockquote>\n<p>Right now you are allowed to write <code>let (y, _) = x</code> if we moved out <code>x.1</code> already. The corresponding match is not allowed tho</p>",
        "id": 218938129,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607179959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218938075\">said</a>:</p>\n<blockquote>\n<p>it's all about precisely defining the verb \"using\"</p>\n</blockquote>\n<p>Ohh and that's where never patterns come in: they make it crystal clear that the value is being read</p>",
        "id": 218938154,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607180033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218938154\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218938075\">said</a>:</p>\n<blockquote>\n<p>it's all about precisely defining the verb \"using\"</p>\n</blockquote>\n<p>Ohh and that's where never patterns come in: they make it crystal clear that the value is being read</p>\n</blockquote>\n<p>yes exactly :)</p>",
        "id": 218938866,
        "sender_full_name": "RalfJ",
        "timestamp": 1607181054
    },
    {
        "content": "<p>well this prompted me to look at bit deeper and I found something concerning^^ <a href=\"https://github.com/rust-lang/rust/issues/79735\">https://github.com/rust-lang/rust/issues/79735</a></p>",
        "id": 218938877,
        "sender_full_name": "RalfJ",
        "timestamp": 1607181100
    },
    {
        "content": "<p>I also opened <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/261\">https://github.com/rust-lang/unsafe-code-guidelines/issues/261</a> for the \"_\" pattern weirdness in general.</p>",
        "id": 218938880,
        "sender_full_name": "RalfJ",
        "timestamp": 1607181114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218938877\">said</a>:</p>\n<blockquote>\n<p>well this prompted me to look at bit deeper and I found something concerning^^ <a href=\"https://github.com/rust-lang/rust/issues/79735\">https://github.com/rust-lang/rust/issues/79735</a></p>\n</blockquote>\n<p><code>!</code> and <code>enum Void {}</code> behaving differently is concerning</p>\n<p>It also means that somebody doing <code>let _ = *::core::ptr::null::&lt;::core::convert::Infallible&gt;();</code> will see its code breaking the moment <code>Infallible</code> is defined as an alias for <code>!</code> <span aria-label=\"cold sweat\" class=\"emoji emoji-1f630\" role=\"img\" title=\"cold sweat\">:cold_sweat:</span></p>",
        "id": 218944645,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607189676
    },
    {
        "content": "<p>I think that code is already broken, heh</p>",
        "id": 218944665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607189717
    },
    {
        "content": "<p>(and if it happens to take place within <code>unsafe</code> \"hygiene\", UB-inducing rather than compile-time breaking)</p>",
        "id": 218944670,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607189734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Soundness.20of.20.60exhaustive_patterns.60/near/218937990\">said</a>:</p>\n<blockquote>\n<p>currently this does not even require <code>unsafe</code> oO</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">foo</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 218977903,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1607246704
    },
    {
        "content": "<p>I have no idea how to feel about this. On the one hand this notation is used often to denote an operation with discarded result, so it should actually do the dereference and be UB, but on the other hand match statements have this weird syntax where you don't so much access the scrutinee as construct a place that is accessed in the patterns, so if your pattern says nothing is accessed then nothing should happen.</p>",
        "id": 218980756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607251375
    },
    {
        "content": "<p>Here's some <em>safe</em> code that dereferences a reference without moving the referent:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">bar</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">bar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is the idea that this function can emit a no-op load for the <code>let</code> statement?</p>",
        "id": 218998394,
        "sender_full_name": "matt1992",
        "timestamp": 1607279977
    },
    {
        "content": "<p>I think the point that is coming to light is that this does nothing at all</p>",
        "id": 218998534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607280222
    },
    {
        "content": "<p>it has 0 lines of code in MIR</p>",
        "id": 218998537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607280234
    },
    {
        "content": "<p>so it doesn't \"dereference a reference\", it constructs a place and does nothing with it</p>",
        "id": 218998586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607280277
    },
    {
        "content": "<p>well, it does nothing at all <em>under the current MIR lowering</em></p>",
        "id": 219000025,
        "sender_full_name": "RalfJ",
        "timestamp": 1607282290
    },
    {
        "content": "<p>to what extend this is the result of an intentional design process, and to what extend this is meant to be or not be UB, I cannot say</p>",
        "id": 219000034,
        "sender_full_name": "RalfJ",
        "timestamp": 1607282317
    },
    {
        "content": "<p>earlier versions of Rust <em>did</em> require <code>unsafe</code> here</p>",
        "id": 219000037,
        "sender_full_name": "RalfJ",
        "timestamp": 1607282324
    },
    {
        "content": "<p>(before unsafety checking was moved to MIR)</p>",
        "id": 219000040,
        "sender_full_name": "RalfJ",
        "timestamp": 1607282329
    },
    {
        "content": "<p>I'd note that <code>*ptr</code> on it's own requires unsafe, so I think that should be considered.</p>",
        "id": 219007028,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607285193
    },
    {
        "content": "<p>It seems like this is a conflict of reasonable rules, and as a result rust's implementation is not consistent. (We poke fun at LLVM for this but it can happen to us too.)</p>",
        "id": 219014610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607287651
    },
    {
        "content": "<p>A spec is supposed to solve these problems, although really it just front loads the issue if we don't know which approach to take</p>",
        "id": 219015199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607287833
    },
    {
        "content": "<p>Does <code>(*ptr).0</code> desugar to an access through a reference like <code>(*(&amp;mut *ptr)).0</code>?</p>",
        "id": 219015698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607287991
    },
    {
        "content": "<p>if so then there might be a way out such that the MIR contains the ptr-to-reference operation but not the subsequent field access</p>",
        "id": 219015880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607288044
    }
]