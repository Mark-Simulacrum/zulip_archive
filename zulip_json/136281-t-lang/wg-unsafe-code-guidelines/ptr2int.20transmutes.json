[
    {
        "content": "<p>I have a new nasty example for why ptr2int transmutes are evil, and unlike my others it doesn't involve any int2ptr casts so it is somewhat orthogonal to strict aliasing: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431</a>.<br>\nwe have to disallow this <em>somehow</em>, not everyone agrees with the 'how' though. :D</p>",
        "id": 277345000,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763643
    },
    {
        "content": "<p>I think this relates to discussions I had with <span class=\"user-mention\" data-user-id=\"143798\">@Talchas</span> a few days ago</p>",
        "id": 277345024,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763656
    },
    {
        "content": "<p>Would it be allowed to transmute a pointer to an int if it doesnt have any provenance? i.e. <code>transmute::&lt;*mut u8, usize&gt;(std::ptr::null())</code></p>",
        "id": 277345775,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648764071
    },
    {
        "content": "<p>So why isn't this fixed by a definition something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Byte</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Uninit</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Init</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Provenance</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We then define ints to never have provenance, and so writing an int to memory always yields bytes of the form <code>Init(val, None)</code>. Furthermore, this does not break <code>x = x;</code> being a nop, because we can claim that giving bytes in memory strictly more provenance than they had before is a refinement of the previous behavior</p>",
        "id": 277345960,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277345775\">said</a>:</p>\n<blockquote>\n<p>Would it be allowed to transmute a pointer to an int if it doesnt have any provenance? i.e. <code>transmute::&lt;*mut u8, usize&gt;(std::ptr::null())</code></p>\n</blockquote>\n<p>yes</p>",
        "id": 277346351,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> so you are saying loading data with provenance at int type just strips that provenance (but does <em>not</em> expose, I hope, under models that have that)?</p>",
        "id": 277346439,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764464
    },
    {
        "content": "<p>Yes</p>",
        "id": 277346452,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764473
    },
    {
        "content": "<p>that violates what I considered an axiom of data representation, that when you start with a bunch of bytes, convert them to a value, and convert them back to bytes, then the original representation is still an allowable representation</p>",
        "id": 277346542,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764513
    },
    {
        "content": "<p>hm not sure how to best put this into words</p>",
        "id": 277346552,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764523
    },
    {
        "content": "<p>basically I am not sure it truly is a refinement. it isn't in the obvious way.</p>",
        "id": 277346574,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764533
    },
    {
        "content": "<p>I see what you're saying</p>",
        "id": 277346601,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764549
    },
    {
        "content": "<p>Actually, hmm</p>",
        "id": 277346676,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764590
    },
    {
        "content": "<p>like, with padding (the only other example we have where byte/value conversion 'changes' anything), we have that the value <code>(0u16, 2u8)</code> can be represented by <em>any</em> byte sequence matching <code>[0x00, 0x00, 0x08, _]</code></p>",
        "id": 277346684,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764596
    },
    {
        "content": "<p>so when you convert the pair into its low-level representation you pick <em>any</em> value for the padding byte</p>",
        "id": 277346796,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764636
    },
    {
        "content": "<p>(including possibly <code>Uninit</code>)</p>",
        "id": 277346803,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764645
    },
    {
        "content": "<p>this means that if you start with some array of 4 bytes, turn it into that pair, and turn it back to the low-level rep, it is always <em>possible</em> to get exactly the original sequence (assuming no UB)</p>",
        "id": 277346866,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764680
    },
    {
        "content": "<p>however, for data with provenance that is loaded into an integer type and put back into bytes, your proposal violates that property</p>",
        "id": 277346902,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764702
    },
    {
        "content": "<p>and intuitively that seems bad...</p>",
        "id": 277346906,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277346542\">said</a>:</p>\n<blockquote>\n<p>that violates what I considered an axiom of data representation, that when you start with a bunch of bytes, convert them to a value, and convert them back to bytes, then the original representation is still an allowable representation</p>\n</blockquote>\n<p>I mean, what this does it it makes the representation relation asymmetric - in other words, the set of input bytes for which the representation relation is defined is not the same as the set of output bytes that its inverse might yield</p>",
        "id": 277346910,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277346906\">said</a>:</p>\n<blockquote>\n<p>and intuitively that seems bad...</p>\n</blockquote>\n<p>I just don't share this intuition. Maybe there is some enlightening example here that I just don't know about though</p>",
        "id": 277346997,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764744
    },
    {
        "content": "<p>in particular it means <code>x=x;</code> cannot <em>obviously</em> be removed</p>",
        "id": 277347005,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764750
    },
    {
        "content": "<p>the program with <code>x=x</code> will strip provenance, after removing the assignment provenance is preserved in those bytes</p>",
        "id": 277347034,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764771
    },
    {
        "content": "<p><code>x=x</code> is more like <code>transmute::&lt;T, T&gt;</code> isnt it?</p>",
        "id": 277347055,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648764790
    },
    {
        "content": "<p>yeah those are the same</p>",
        "id": 277347066,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764801
    },
    {
        "content": "<p>rather than <code>transmute::&lt;ThignWithPRovenance, NoProvenance&gt;()</code></p>",
        "id": 277347071,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648764803
    },
    {
        "content": "<p>so we'd need a general theorem that says: adding provenance to any byte without provenance will never change program behavior or introduce UB</p>",
        "id": 277347081,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764815
    },
    {
        "content": "<p>that <em>might</em> be a correct theorem but it does not seem trivial either</p>",
        "id": 277347091,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764824
    },
    {
        "content": "<p>Yes, agreed. This is essentially what I was counting on when I said</p>\n<blockquote>\n<p>we can claim that giving bytes in memory strictly more provenance than they had before is a refinement of the previous behavior</p>\n</blockquote>",
        "id": 277347176,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764866
    },
    {
        "content": "<p>If such a theorem is problematic, I would love to investigate more why</p>",
        "id": 277347221,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764901
    },
    {
        "content": "<p>Even if \"problematic\" is just \"this is hard to prove\" or \"this is incompatible with <em>insert weird thing we probably don't want</em>\" or whatever</p>",
        "id": 277347346,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648764976
    },
    {
        "content": "<p>yeah I agree</p>",
        "id": 277347405,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765025
    },
    {
        "content": "<p>we already have a similar theorem we want but that one just seems a lot more obvious:<br>\nreplacing any <code>uninit</code> byte by anything else will never change program behavior or introduce UB</p>",
        "id": 277347447,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765055
    },
    {
        "content": "<p>whats you GH handle so I can credit you in the GH issue?^^</p>",
        "id": 277347543,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765106
    },
    {
        "content": "<p><code>@JakobDegen</code></p>",
        "id": 277347558,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648765117
    },
    {
        "content": "<p>okay so I think agree this might work</p>",
        "id": 277347945,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765390
    },
    {
        "content": "<p>the next question then is, do we want it? it's still 'odd': doing a transmute roundtrip irrecoverably uses provenance!</p>",
        "id": 277347968,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765411
    },
    {
        "content": "<p>presumably, code that transmutes pointers to integers does that because it uses an integer type as a \"universal container\" that can hold any kind of data, including pointers with provenance</p>",
        "id": 277348010,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765440
    },
    {
        "content": "<p>such code would still be broken</p>",
        "id": 277348056,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765449
    },
    {
        "content": "<p>so it might be easier to just say \"this is UB\", instead of saying \"this is allowed but doesn't do what you think it does\". (also easier then for tools like Miri to flag the error immediately, rather than flagging waaaay later that a pointer somehow lost its provenance.)</p>",
        "id": 277348146,
        "sender_full_name": "RalfJ",
        "timestamp": 1648765518
    },
    {
        "content": "<p>Yeah, I'm not sure. It might be interesting to add a flag to miri that allows what I propose (after ptr to int transmutes are UB) and try and get some usage reports from people for whom that flag fixed things</p>",
        "id": 277348788,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648765959
    },
    {
        "content": "<p>If those people don't exist, I agree that this is not very useful</p>",
        "id": 277348810,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648765973
    },
    {
        "content": "<p>implementing \"value changes on copy\" in Miri is non-trivial so dont expect such a flag any time soon</p>",
        "id": 277351170,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767525
    },
    {
        "content": "<p>that's why Miri currently doesnt even reset padding on copy...</p>",
        "id": 277351176,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767532
    },
    {
        "content": "<p>I mean, \"on copy\" is overstating the case; \"cannot optimize out memcpy/transmute containing pointers to be language level copies\" is bad but not as bad as that</p>",
        "id": 277351513,
        "sender_full_name": "Talchas",
        "timestamp": 1648767731
    },
    {
        "content": "<p>?</p>",
        "id": 277351566,
        "sender_full_name": "RalfJ",
        "timestamp": 1648767801
    },
    {
        "content": "<p>not being able to optimize the chain <code>transmute_to_ptr(transmute_to_usize(ptr))</code>down to <code>ptr</code> because it is a side effect does not imply <code>x=x</code> is a side effect</p>",
        "id": 277351670,
        "sender_full_name": "Talchas",
        "timestamp": 1648767903
    },
    {
        "content": "<p>it does, under some light assumnptions about how the semantics is structured</p>",
        "id": 277351804,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768005
    },
    {
        "content": "<p>also that's not even the relevant optimization here</p>",
        "id": 277351829,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768035
    },
    {
        "content": "<p>(like, \"any <code>ptr::copy_memory</code> at all is a side effect\" does not imply \"<code>x=x</code> is a side effect\")</p>",
        "id": 277351843,
        "sender_full_name": "Talchas",
        "timestamp": 1648768042
    },
    {
        "content": "<p>no side-effects have been proposed here</p>",
        "id": 277351870,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768062
    },
    {
        "content": "<p>just non-identity transformations as part of the value representation relating values to bytes</p>",
        "id": 277351887,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768078
    },
    {
        "content": "<p>the optimization you mention wasnt even mentioned</p>",
        "id": 277351940,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768091
    },
    {
        "content": "<p>by \"is a side effect\" I mean \"strips provenance\"</p>",
        "id": 277351945,
        "sender_full_name": "Talchas",
        "timestamp": 1648768094
    },
    {
        "content": "<p>IOW, I cant relate what you say to the previous discussion^^</p>",
        "id": 277351949,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768097
    },
    {
        "content": "<p>also we concluded that removing <code>x=x;</code> was probably still possible under some reasonable assumption about the semantics as a whole</p>",
        "id": 277351984,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768134
    },
    {
        "content": "<p>so... <em>Ralf is confused</em></p>",
        "id": 277351991,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277351945\">said</a>:</p>\n<blockquote>\n<p>by \"is a side effect\" I mean \"strips provenance\"</p>\n</blockquote>\n<p>the proposed way to fix this is to strip provenance every time an integer is loaded from anywhere. you cant know if the old value had provenance. so this is not about syntactic <code>transmute</code> calls or so.<br>\n<code>x=x;</code> loads an integer from the place <code>x</code> and then stores it back. thus, <code>x=x;</code> is affected by what we are discussing here.</p>",
        "id": 277352167,
        "sender_full_name": "RalfJ",
        "timestamp": 1648768282
    },
    {
        "content": "<p>to be fair, it looks like it was either Jake who started the <code>x=x</code> thing or it was carryover from some previous thread</p>",
        "id": 277352199,
        "sender_full_name": "Talchas",
        "timestamp": 1648768304
    },
    {
        "content": "<p>oh, I see, this is all starting at more <code>*x = *x;</code> in a rust representation of optimizations in progress, because <code>x=x</code> is the MIR syntax assuming everything is in a memory location or something like that?</p>",
        "id": 277352438,
        "sender_full_name": "Talchas",
        "timestamp": 1648768483
    },
    {
        "content": "<p>Yes</p>",
        "id": 277352522,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768558
    },
    {
        "content": "<p>Afaik no version of the Rust memory model proposes a location for bytes to be that isn't memory or a way to access memory that isn't through a pointer</p>",
        "id": 277352587,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768607
    },
    {
        "content": "<p>Locals are just pointers that are dereferenced implicitly</p>",
        "id": 277352593,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648768619
    },
    {
        "content": "<p>well it could be <code>x=x;</code> in Rust syntax as well</p>",
        "id": 277353936,
        "sender_full_name": "RalfJ",
        "timestamp": 1648769736
    },
    {
        "content": "<p><code>x</code> might still store pointer bytes when someone did something nasty like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// the load of the RHS here loads a value with provenance</span>\n</code></pre></div>",
        "id": 277354009,
        "sender_full_name": "RalfJ",
        "timestamp": 1648769782
    },
    {
        "content": "<p>Question about the <code>deref</code> example in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">Ralf's GitHub comment</a>:</p>\n<p>While (I think) I can understand why the ptr-to-int transmute is UB here, I'm having trouble seeing why a cast would be different. We'd still end up with <code>left_int</code> having the same value, which is still equal to <code>right_int</code> in that branch, and should still be replaceable (?) with <code>right_int</code>.</p>\n<p>I think I'm missing some compiler magic around how ptr-to-int <em>casts</em> are treated.</p>",
        "id": 277557653,
        "sender_full_name": "Vince Mutolo",
        "timestamp": 1648941704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"251214\">Vince Mutolo</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277557653\">said</a>:</p>\n<blockquote>\n<p>Question about the <code>deref</code> example in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">Ralf's GitHub comment</a>:</p>\n<p>While (I think) I can understand why the ptr-to-int transmute is UB here, I'm having trouble seeing why a cast would be different. We'd still end up with <code>left_int</code> having the same value, which is still equal to <code>right_int</code> in that branch, and should still be replaceable (?) with <code>right_int</code>.</p>\n<p>I think I'm missing some compiler magic around how ptr-to-int <em>casts</em> are treated.</p>\n</blockquote>\n<p>In a model in which we have some kind of \"provenance escaping,\" the compiler cannot conclude that <code>(ptr_val as usize) as ptr</code> is a nop</p>",
        "id": 277558439,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648942728
    },
    {
        "content": "<p>Ok, that makes sense. So the new pointer would be marked as something like \"unclear provenance\" and would prevent optimizations. </p>\n<p>And I guess the way to get those optimizations back would be to use something like <code>left.with_addr(left_int)</code> to explicitly give the new pointer provenance.</p>",
        "id": 277558726,
        "sender_full_name": "Vince Mutolo",
        "timestamp": 1648943121
    },
    {
        "content": "<p>Yes</p>",
        "id": 277558777,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648943180
    },
    {
        "content": "<p>Actually, I think there's still something a little fuzzy here. Your example was ((ptr as int) as ptr), whereas I think I was asking about (ptr as int) transmuted back to ptr. Would that be ok?</p>\n<p>The thing I'm stumbling over is how the compiler differentiates between a pointer cast to an int and a pointer transmuted into an int. Either way we end up with an int, and AFAIK ints are untracked for provenance.</p>",
        "id": 277558868,
        "sender_full_name": "Vince Mutolo",
        "timestamp": 1648943373
    },
    {
        "content": "<p>So, to make this more explicit: In a weak provenance model (as it is being proposed here, there may be alternatives), when a pointer is <em>cast</em> to an int, it's provenance is \"exposed\" and added to a global pool of \"exposed\" provenances. Transmuting is just UB.</p>\n<p>When an int is <em>cast</em> to a pointer, the pointer gets provenance from this global pool of provenances - there may be many possible choices, the requirement is that there exist at least one choice of provenance that makes the program have defined behavior. When an int is transmuted to a pointer, the provenance of the resulting pointer is the \"null\" provenance. In other words, the transmute is defined behavior of its own, but the pointer does not have valid provenance for any memory.</p>\n<p>That means that this example with a ptr2int cast and int2ptr transmute would still be UB when the pointer is dereferenced (because of the null provenance)</p>",
        "id": 277559157,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648943824
    },
    {
        "content": "<p>That makes total sense. Thanks. What I was missing is that the pointer-to-int cast changes the tracking of the pointer that we're casting <em>from</em> and not of the integer we're casting <em>to</em>.</p>",
        "id": 277559870,
        "sender_full_name": "Vince Mutolo",
        "timestamp": 1648944826
    },
    {
        "content": "<p>Technically speaking, it doesn't change the tracking of the <em>pointer</em>, but of the <em>provenance</em>. This is a bit of a pedantic distinction, but it's also an important one, because it means there's no such thing as special pointers (or integers)</p>",
        "id": 277560203,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648945340
    },
    {
        "content": "<p>The dead-simplest way to make these transmutes work is to pretend that every transmute goes in and exposes (and eliminates provenance for) every reachable pointer in whatever you're transmuting, Of course, you'd pretty much make transmutes no longer NOPs, and make a lot of people very sad. I <em>think</em> this would isolate any weird behaviors to only the function that calls transmute, which means stuff like redundant store eliminations work, at the cost of making these transmutes be a massive optimization barrier.</p>",
        "id": 277560738,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648946181
    },
    {
        "content": "<p>It does not isolate to functions that call transmute</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The last statement there is a potential transmute, because <code>foo</code> may have written pointer data to <code>x</code></p>",
        "id": 277561091,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648946702
    },
    {
        "content": "<p>By \"transmute,\" we don't mean \"calls to <code>std::mem::transmute</code>\" but rather \"any type punning through memory\"</p>",
        "id": 277561154,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648946810
    },
    {
        "content": "<p>This isn't the first time I've seen the word \"pun\" or \"punning\" come up in over the last few days of this discussion. How is it being used in this context?</p>",
        "id": 277561232,
        "sender_full_name": "Vince Mutolo",
        "timestamp": 1648947000
    },
    {
        "content": "<p>It's used for any mechanism that writes data to memory as one type and reads it from memory as a different type</p>",
        "id": 277561298,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648947094
    },
    {
        "content": "<p>No idea of it's origin - I suppose it could be vaguely related to the use of \"pun\" as in the type of joke, since there it's the words instead of the memory that have a double meaning?</p>",
        "id": 277561357,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648947137
    },
    {
        "content": "<p>the same memory has two different meanings at different types, so it's like a pun where the same word has two different meanings in different context</p>",
        "id": 277561358,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1648947137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277560738\">said</a>:</p>\n<blockquote>\n<p>The dead-simplest way to make these transmutes work is to pretend that every transmute goes in and exposes (and eliminates provenance for) every reachable pointer in whatever you're transmuting, Of course, you'd pretty much make transmutes no longer NOPs, and make a lot of people very sad. I <em>think</em> this would isolate any weird behaviors to only the function that calls transmute, which means stuff like redundant store eliminations work, at the cost of making these transmutes be a massive optimization barrier.</p>\n</blockquote>\n<p>note that <code>transmute</code> here means <code>mem::trasnmute</code> but also every time you read a pointer -- you dont know how the memory the pointer points to was written (it might have been at a different type). so this means a lot of exposing is happening all the time everywhere even in code that is really disciplined with pointers.</p>",
        "id": 277628692,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992437
    },
    {
        "content": "<p>disallowing transmutes (of all sorts) has the <em>huge</em> advantage that we can still support sloppy provenance via casts, <em>and only the code using them pays for that</em> (in terms of lost optimizations)</p>",
        "id": 277628732,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992467
    },
    {
        "content": "<p>I think we need another primitive to express this use case though; let's call it <code>expose_all&lt;T&gt;(p: *const T)</code> which interprets the bytes at <code>*p</code> at type <code>T</code> and exposes all pointers indicated by type <code>T</code>. For example if memory contains two pointers <code>[p1, p2]</code> and I pass a pointer to this to <code>expose_all::&lt;(usize, *const ())&gt;</code> then <code>p2</code> will be exposed.</p>\n<p>Importantly, this is also \"type-driven exposing\" just like <code>ptr as usize</code>, there is no accidental exposing due to types not matching when you read some data. It's also clearly a machine-level no-op, which makes it easier to reason about in the IR. This can be used prior to any explicit <code>mem::transmute</code> (we might even include it as part of the desugaring of the operation) which would at least solve the problem of ptr2int2ptr transmutes done explicitly through <code>transmute</code> rather than type punning.</p>",
        "id": 277678240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649043575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277678240\">said</a>:</p>\n<blockquote>\n<p>which would at least solve the problem of ptr2int2ptr transmutes done explicitly through <code>transmute</code> rather than type punning.</p>\n</blockquote>\n<p>It's not obvious to me that this would be good.  Being able to say \"transmutes, unions, and type punning all have the same rules\" is nice, even if it means fewer things work than if some of them special cased some things.</p>",
        "id": 277678584,
        "sender_full_name": "scottmcm",
        "timestamp": 1649043966
    },
    {
        "content": "<p>that's fair, I'm not sure I want to push for that myself. I just think it might help address some of <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> 's concerns about backwards compatible support for <code>mem::transmute</code></p>",
        "id": 277678611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649044039
    },
    {
        "content": "<p>The more principled approach would be to introduce this as a new function and teach people to use it as the \"right\" way to do abomonation type stuff</p>",
        "id": 277678666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649044115
    },
    {
        "content": "<p>There are also lots of places people use <code>transmute</code> without wanting any ptr2int or exposing stuff at all. I know I have written <code>transmute&lt;&amp;T, &amp;T&gt;</code> before when I'm feeling smarter than the borrow checker, and in that case there is really no need for any side effects at all</p>",
        "id": 277678842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649044344
    },
    {
        "content": "<p>Catching up on this. Let me see if I can hack the compiler and run it through our internal code to find ptr-to-int transmutes.</p>",
        "id": 277776026,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649097548
    },
    {
        "content": "<p>I have no idea off the top of my head how common they might or might not be.</p>",
        "id": 277776094,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649097586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277628692\">said</a>:</p>\n<blockquote>\n<p>note that transmute here means mem::trasnmute but also every time you read a pointer -- you dont know how the memory the pointer points to was written (it might have been at a different type). so this means a lot of exposing is happening all the time everywhere even in code that is really disciplined with pointers.</p>\n</blockquote>\n<p>I've advocated for the int2ptr as FFI calls, and I'm wondering if the same thing could work for transmutes. The following is defined in C.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"n\">int</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Iff FFI calls can do any operation in the Rust AM, how we represent this if we make these transmutes UB? (Yes, in the absence of LTO, any Rust call to this function will not miscompile, simply because the compiler isn't smart enough)</p>",
        "id": 277903287,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649174923
    },
    {
        "content": "<blockquote>\n<p>I've advocated for the int2ptr as FFI calls, and I'm wondering if the same thing could work for transmutes. The following is defined in C.</p>\n</blockquote>\n<p>The issue is that a transmute is just caused by <code>core::mem::transmute</code>.</p>",
        "id": 277903604,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175050
    },
    {
        "content": "<p>\"Transmutes\" can be caused by mere memory accesses.</p>",
        "id": 277903802,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175130
    },
    {
        "content": "<p>Imagine the following trivial function:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is the compiler allowed to optimize away the <code>x.read()</code>?</p>",
        "id": 277903934,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649175188
    },
    {
        "content": "<p>The issue is that int2ptr is a one-time escape that is entirely contained in the call; a pointer pun is an ongoing escape that can occur at every pointer write + integer read that might be aliased to each other. And there's definite issues if the compiler wants to do optimizations to a function f, then inline it, then do more optimizations with different alias knowledge</p>",
        "id": 277906052,
        "sender_full_name": "Talchas",
        "timestamp": 1649176106
    },
    {
        "content": "<p>(and PNVI being in the source language rather than something more restrictive like PVI or handwave means you can't really say \"<code>x.read();</code> is unused so it doesn't count as an escape even if it read pointer bytes\")</p>",
        "id": 277906434,
        "sender_full_name": "Talchas",
        "timestamp": 1649176254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277678240\">said</a>:</p>\n<blockquote>\n<p>I think we need another primitive to express this use case though; let's call it <code>expose_all&lt;T&gt;(p: *const T)</code> which interprets the bytes at <code>*p</code> at type <code>T</code> and exposes all pointers indicated by type <code>T</code>. For example if memory contains two pointers <code>[p1, p2]</code> and I pass a pointer to this to <code>expose_all::&lt;(usize, *const ())&gt;</code> then <code>p2</code> will be exposed.</p>\n<p>Importantly, this is also \"type-driven exposing\" just like <code>ptr as usize</code>, there is no accidental exposing due to types not matching when you read some data. It's also clearly a machine-level no-op, which makes it easier to reason about in the IR. This can be used prior to any explicit <code>mem::transmute</code> (we might even include it as part of the desugaring of the operation) which would at least solve the problem of ptr2int2ptr transmutes done explicitly through <code>transmute</code> rather than type punning.</p>\n</blockquote>\n<p>this doesn't help fix <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431\">this example</a> though. even if all transmutes expose, if the compiler can assume that <code>transmute_int2ptr(transmute_ptr2int(ptr))</code> returns <code>ptr</code> (and exposes an arbitrary set of locations), that is already enough to break everything. it's not the loss of 'expose' that is the primary problem with optimizing away ptr-int-ptr roundtrips, it's the (wrong) assumption about which provenance the final pointer will pick up.</p>\n<p>I don't think that's enough because you also need to do something on the 'int2ptr transmute' side. as you said yourself on GH, it's really the cast <em>back</em> that is the tricky one.</p>",
        "id": 277919141,
        "sender_full_name": "RalfJ",
        "timestamp": 1649181521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277903287\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277628692\">said</a>:</p>\n<blockquote>\n<p>note that transmute here means mem::trasnmute but also every time you read a pointer -- you dont know how the memory the pointer points to was written (it might have been at a different type). so this means a lot of exposing is happening all the time everywhere even in code that is really disciplined with pointers.</p>\n</blockquote>\n<p>I've advocated for the int2ptr as FFI calls, and I'm wondering if the same thing could work for transmutes. The following is defined in C.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"n\">int</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Iff FFI calls can do any operation in the Rust AM, how we represent this if we make these transmutes UB? (Yes, in the absence of LTO, any Rust call to this function will not miscompile, simply because the compiler isn't smart enough)</p>\n</blockquote>\n<p>when you call FFI code, the relevant property is that there is <em>some</em> way to express its effect on the AM through a Rust program. but that way doesn't have to be an algorithm or so, the only relevant property is that it exists at all.<br>\nso if we call C code that does transmutes, we can just pretend they did casts, as far as the Rust AM is concerned.</p>",
        "id": 277920082,
        "sender_full_name": "RalfJ",
        "timestamp": 1649181893
    },
    {
        "content": "<blockquote>\n<p>when you call FFI code, the relevant property is that there is some way to express its effect on the AM through a Rust program. but that way doesn't have to be an algorithm or so, the only relevant property is that it exists at all.<br>\nso if we call C code that does transmutes, we can just pretend they did casts, as far as the Rust AM is concerned.</p>\n</blockquote>\n<p>Right, but these are proper transmutes, which infect everything.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">cast</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">u64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a_ptr_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">a_ptr_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277946469,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649194422
    },
    {
        "content": "<p>oh <code>cast</code> is just doing a pointer cast? you can write that in Rust. no sure why you'd expect this to be legal just because you did it in C?</p>",
        "id": 277954932,
        "sender_full_name": "RalfJ",
        "timestamp": 1649199375
    },
    {
        "content": "<p>the actual transmute is still happening in Rust</p>",
        "id": 277954944,
        "sender_full_name": "RalfJ",
        "timestamp": 1649199389
    },
    {
        "content": "<p>so Rust rules apply there for sure</p>",
        "id": 277954950,
        "sender_full_name": "RalfJ",
        "timestamp": 1649199395
    },
    {
        "content": "<p>I think the compiler can't rule out the possibility that this is defined behavior, e.g. if <code>cast</code> followed the pointer and replaced the memory there with a pointer value</p>",
        "id": 277956200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649200056
    },
    {
        "content": "<p>I mean, UB in Rust should never happen, but in C... Well, <em>in theory</em> it shouldn't.</p>",
        "id": 277956430,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649200239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277956200\">said</a>:</p>\n<blockquote>\n<p>I think the compiler can't rule out the possibility that this is defined behavior, e.g. if <code>cast</code> followed the pointer and replaced the memory there with a pointer value</p>\n</blockquote>\n<p>basically, if you can implement <code>cast</code> in Rust in a way that this code becomes allowed then that's fine</p>",
        "id": 277959408,
        "sender_full_name": "RalfJ",
        "timestamp": 1649202705
    },
    {
        "content": "<p>not sure if that is possible here</p>",
        "id": 277959419,
        "sender_full_name": "RalfJ",
        "timestamp": 1649202716
    },
    {
        "content": "<p>with cross-lang LTO it's definitely not fine as then LLVM sees what you are (not) doing</p>",
        "id": 277959465,
        "sender_full_name": "RalfJ",
        "timestamp": 1649202740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277954932\">said</a>:</p>\n<blockquote>\n<p>oh <code>cast</code> is just doing a pointer cast? you can write that in Rust. no sure why you'd expect this to be legal just because you did it in C?</p>\n</blockquote>\n<p>Yes, but what justifies the fact that this is UB? The cast is defined with no-strict-aliasing, or if you just write raw assembly. You'd also need some sort of TBAA to forbid this, where it is UB for a pointer to pointer to alias with a pointer to not-pointer.</p>",
        "id": 277965454,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649208771
    },
    {
        "content": "<p>no TBAA needed. it's UB for the same reason that this is UB, which Miri can detect with <code>-Zmiri-check-number-validity</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">cast</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">u64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a_ptr_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">a_ptr_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277968593,
        "sender_full_name": "RalfJ",
        "timestamp": 1649212420
    },
    {
        "content": "<blockquote>\n<p>where it is UB for a pointer to pointer to alias with a pointer to not-pointer.</p>\n</blockquote>\n<p>no alias reasoning is involved here. rather, at the <code>a=a</code>, when the load from <code>a</code> is evaluated, we require that the data stored at <code>a</code> is indeed valid for the given type (<code>u64</code>). in this execution the data has provenance, making it not valid.<br>\nthis is entirely the same as what happens when you store <code>0xff</code> into a <code>bool</code>.</p>",
        "id": 277968666,
        "sender_full_name": "RalfJ",
        "timestamp": 1649212509
    },
    {
        "content": "<p>that argument is extraordinarily unsatisfying when provenance does not actually exist in actual bytes on platforms other than CHERI (and miri if you call that a platform rather than a checker). The uninit analogy is better but still not great</p>",
        "id": 277970090,
        "sender_full_name": "Talchas",
        "timestamp": 1649214108
    },
    {
        "content": "<p>(and CHERI actually supports it for -&gt; uintptr_t)</p>",
        "id": 277970142,
        "sender_full_name": "Talchas",
        "timestamp": 1649214141
    },
    {
        "content": "<p>and said nonexistence means that as a matter of spec/principle it's totally reasonable to say it just counts as an escape; the problem there is only in practice what it means for optimizations</p>",
        "id": 277970238,
        "sender_full_name": "Talchas",
        "timestamp": 1649214267
    },
    {
        "content": "<p>(and <em>that</em> is like 90% a TBAA-like issue)</p>",
        "id": 277970254,
        "sender_full_name": "Talchas",
        "timestamp": 1649214302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277970090\">said</a>:</p>\n<blockquote>\n<p>that argument is extraordinarily unsatisfying when provenance does not actually exist in actual bytes on platforms other than CHERI (and miri if you call that a platform rather than a checker). The uninit analogy is better but still not great</p>\n</blockquote>\n<p>Provenance does exist in actual bytes in the Abstract Machine, though.</p>",
        "id": 277970379,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649214431
    },
    {
        "content": "<p>that doesn't matter when it very definitely doesn't on the physical machine, when the analogy is bool rather than uninit</p>",
        "id": 277970453,
        "sender_full_name": "Talchas",
        "timestamp": 1649214514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277970238\">said</a>:</p>\n<blockquote>\n<p>and said nonexistence means that as a matter of spec/principle it's totally reasonable to say it just counts as an escape; the problem there is only in practice what it means for optimizations</p>\n</blockquote>\n<p>Yeah, and in practice it means that many operations that are pure by definition are now side-effectful.</p>",
        "id": 277970455,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649214519
    },
    {
        "content": "<p><code>p.read()</code> is pure, and Reading a pointer as an integer escapes the pointer are two fundamentally incompatible provisions.</p>",
        "id": 277970501,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649214587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277970453\">said</a>:</p>\n<blockquote>\n<p>that doesn't matter when it very definitely doesn't on the physical machine, when the analogy is bool rather than uninit</p>\n</blockquote>\n<p>The physical machine is an implementation detail.</p>",
        "id": 277970549,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649214624
    },
    {
        "content": "<p>Specifications don't talk about \"The effects on the physical machine\".</p>",
        "id": 277970556,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649214651
    },
    {
        "content": "<p>I can store my bools in the physical machine as potatoes and carrots for all rust cares.</p>",
        "id": 277970569,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649214670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277970453\">said</a>:</p>\n<blockquote>\n<p>that doesn't matter when it very definitely doesn't on the physical machine, when the analogy is bool rather than uninit</p>\n</blockquote>\n<p>it matters a lot unless you are okay with only doing optimizations that are correct on the physical machine</p>",
        "id": 278031318,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255228
    },
    {
        "content": "<p>like, either you say \"physical machine first\" and accept what what means for optimizations, or you say \"yeah there is an abstract machine\" because you want extra optimizations but then you have to accept the AM as a 'real' thing</p>",
        "id": 278031394,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255260
    },
    {
        "content": "<p>I dont think it is a reasonable position to ask for the benefits of both and not pay the costs of either</p>",
        "id": 278031430,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277970254\">said</a>:</p>\n<blockquote>\n<p>(and <em>that</em> is like 90% a TBAA-like issue)</p>\n</blockquote>\n<p>you must be using \"TBAA-like\" in a very broad sense. I maintain that Rust does not have TBAA and hence this is not a TBAA-like issue at all.</p>",
        "id": 278031609,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/277970238\">said</a>:</p>\n<blockquote>\n<p>and said nonexistence means that as a matter of spec/principle it's totally reasonable to say it just counts as an escape; the problem there is only in practice what it means for optimizations</p>\n</blockquote>\n<p>oh yes it is totally reasonable. if you ware okay with also paying the price this carries for optimizations. but that is <em>not</em> how Rust and C are currently being optimized.<br>\nit is <em>not</em> reasonable to say everything counts as an escape but also we totally ignore that when optimizing the program.</p>",
        "id": 278031734,
        "sender_full_name": "RalfJ",
        "timestamp": 1649255400
    },
    {
        "content": "<p>I've been looking through our internal code and we have several ptr2int transmutes. We also have at least one case in which we use the low bit of an <code>&amp;'static</code> as a flag.</p>",
        "id": 278087792,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649280113
    },
    {
        "content": "<p>That one is probably fixable to use a raw pointer instead</p>",
        "id": 278087855,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649280136
    },
    {
        "content": "<p>(I guess that one is already UB?)</p>",
        "id": 278088131,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649280237
    },
    {
        "content": "<p>There's actually a <em>lot</em> of code that does ptr2int transmutes in order to use the bottom few bits as flags.</p>",
        "id": 278088514,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649280394
    },
    {
        "content": "<p>It's worth thinking about how we're going to support using pointer bits as flags, since this is a thing people do.</p>",
        "id": 278088606,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649280451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/278088131\">said</a>:</p>\n<blockquote>\n<p>(I guess that one is already UB?)</p>\n</blockquote>\n<p>if this is <code>&amp;'static u32</code> (for example), then yes because setting the flag violates alignment</p>",
        "id": 278089251,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/278088606\">said</a>:</p>\n<blockquote>\n<p>It's worth thinking about how we're going to support using pointer bits as flags, since this is a thing people do.</p>\n</blockquote>\n<p>well, we do support that, Gankra even wrote demo code using the strict provenance APIs.<br>\nthe hard question is what to do about code that is already written not using those APIs.^^</p>",
        "id": 278089289,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280841
    },
    {
        "content": "<p>Yeah</p>",
        "id": 278089567,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649280991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> With respect to shoving stuff into pointers, you could draw some inspiration from ecosystem crates: <a href=\"https://crates.io/crates/stuff\">https://crates.io/crates/stuff</a> which was written by <span class=\"user-mention\" data-user-id=\"444933\">@nilstrieb</span> (I think that's you?) directly inspired by how <code>semver</code> packs short strings into pointers, and also <a href=\"https://crates.io/crates/tagged-pointer\">https://crates.io/crates/tagged-pointer</a> (whose implementation I am not particularly excited about, but it does pass <code>-Zmiri-strict-provenance</code>).</p>",
        "id": 278089595,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281006
    },
    {
        "content": "<p>To be clear, I do not think that any of this pointer munging is particularly graceful at the moment, but it can definitely be done, and this all should probably serve as inspiration for standard library APIs</p>",
        "id": 278089698,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281064
    },
    {
        "content": "<p>Oh also some of it optimizes strangely if you do the CHERI-friendly stuff, as was mentioned in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance.20in.20the.20bytes.20crate\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance.20in.20the.20bytes.20crate</a></p>",
        "id": 278089854,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <br>\nYeah, I guess the practical consequence of that is that it'd be legal to write a MIR optimization pass that deletes the code that sets and tests those bits. e.g. optimizing <code>(p as usize &amp; 1) == 1</code> with <code>p: &amp;i32</code> to <code>false</code>, which AFAICT is a legal optimization today and might actually make code faster, but would break that pattern.</p>",
        "id": 278093006,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649282904
    },
    {
        "content": "<p>It was pointed out to me that LLVM already does this <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 278093418,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649283194
    },
    {
        "content": "<p>well, we give LLVM the information that it could do it</p>",
        "id": 278094094,
        "sender_full_name": "RalfJ",
        "timestamp": 1649283658
    },
    {
        "content": "<p>are there examples of it actually doing that in the wild?</p>",
        "id": 278094104,
        "sender_full_name": "RalfJ",
        "timestamp": 1649283664
    },
    {
        "content": "<p>it only breaks the pattern when implemented incorrectly with references rather than raw pointers. I feel like the fact that references have to be aligned was always fairly uncontroversial? I suppose one could think this means \"aligned only when dereferenced\", but we have been talking about validity invariants for years now.<br>\nthough to be fair the reference only explicitly documents this since <a href=\"https://doc.rust-lang.org/1.39.0/reference/behavior-considered-undefined.html\">https://doc.rust-lang.org/1.39.0/reference/behavior-considered-undefined.html</a> (released Nov 2019)</p>",
        "id": 278094335,
        "sender_full_name": "RalfJ",
        "timestamp": 1649283835
    },
    {
        "content": "<p>FWIW, I haven't seen anyone in <a href=\"https://github.com/rust-lang/rfcs/pull/3204\">https://github.com/rust-lang/rfcs/pull/3204</a> say \"no you can't add a niche here because I use unaligned references\".  It seems like everyone's pretty much internalized the \"it's a validity invariant that references are aligned\" idea.</p>",
        "id": 278095277,
        "sender_full_name": "scottmcm",
        "timestamp": 1649284460
    },
    {
        "content": "<p>Is alignment implied by <code>dereferencable</code>? How long has rustc told LLVM that references are aligned?</p>",
        "id": 278095347,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649284525
    },
    {
        "content": "<p>To be clear I'm fine with fixing our code here</p>",
        "id": 278095636,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649284727
    },
    {
        "content": "<p>Not objecting to that one.</p>",
        "id": 278095643,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649284731
    },
    {
        "content": "<p>Alignment is on loads, so <code>dereferencable</code> probably doesn't imply any particular alignment.</p>\n<p>We've apparently been saying <code>dereferenceable(4)</code> all the way back to 1.0.0: <a href=\"https://rust.godbolt.org/z/4evhvKP6M\">https://rust.godbolt.org/z/4evhvKP6M</a></p>\n<p>And we've been explicitly marking the <code>load</code> as <code>align 4</code> (for an <code>i32</code>) since 1.1.0: <a href=\"https://rust.godbolt.org/z/djqbPY65c\">https://rust.godbolt.org/z/djqbPY65c</a></p>",
        "id": 278095758,
        "sender_full_name": "scottmcm",
        "timestamp": 1649284803
    },
    {
        "content": "<p><code>dereferenceable(4)</code> determines the size though, not the alignment</p>",
        "id": 278096085,
        "sender_full_name": "RalfJ",
        "timestamp": 1649285076
    },
    {
        "content": "<p>we've been adding <code>align 4</code> as an argument attribute since 1.33.0: <a href=\"https://rust.godbolt.org/z/T1W3evWhr\">https://rust.godbolt.org/z/T1W3evWhr</a></p>",
        "id": 278096229,
        "sender_full_name": "RalfJ",
        "timestamp": 1649285175
    },
    {
        "content": "<p>Langref does say this though (I know we're deep in the weeds here)</p>\n<blockquote>\n<p>A pointer that is dereferenceable can be loaded from speculatively without a risk of trapping.</p>\n</blockquote>",
        "id": 278098292,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649286491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/ptr2int.20transmutes/near/278094104\">said</a>:</p>\n<blockquote>\n<p>are there examples of it actually doing that in the wild?</p>\n</blockquote>\n<p><a href=\"https://godbolt.org/z/zvG1YfjvK\">https://godbolt.org/z/zvG1YfjvK</a> is a small example that was pointed out to me</p>",
        "id": 278104751,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649291797
    }
]