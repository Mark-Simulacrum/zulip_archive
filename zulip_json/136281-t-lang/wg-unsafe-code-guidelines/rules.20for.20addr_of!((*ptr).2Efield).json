[
    {
        "content": "<p>yeah that has nothing to do with the previous topic so I split it :)</p>",
        "id": 272968114,
        "sender_full_name": "RalfJ",
        "timestamp": 1645631828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span>  I am of the strong opinion that the behavior of a compound expression should be fully determined by its constituent expressions. in this case, given a value expression <code>ptr</code>, we have 3 pieces:</p>\n<ul>\n<li>the place expression <code>*ptr</code></li>\n<li>the (place) field projection <code>_ .field</code></li>\n<li>the (value) expression <code>addr_of!(_)</code></li>\n</ul>\n<p>the current rule for the first step, <code>*ptr</code>, says that when a place is constructed from a value by means of the <code>*</code> operator, the pointer needs to be aligned and dereferencable as determined by the pointee type. we cannot know, at this point, which field will be projected to (if any) and if a load/store actually happens, so I dont see a good way to only require things \"up to the point thats read\".<br>\nwe could simply entirely remove this rule (or say that it only applies when using <code>*</code> on reference-typed values, not raw-ptr-typed values), and I would be very happy with that outcome. but then we have to change the LLVM IR that we generate.</p>",
        "id": 272969741,
        "sender_full_name": "RalfJ",
        "timestamp": 1645632369
    },
    {
        "content": "<p>Yeah, I don't think the <code>inbounds</code> helps very much there anyway. More broadly, I think this is a large footgun that many people keep runnign into, even experienced rust users.</p>",
        "id": 272969972,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645632468
    },
    {
        "content": "<p>It feels like we should do something about it.</p>",
        "id": 272969995,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645632478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/rules.20for.20addr_of!.28.28*ptr.29.2Efield.29/near/272969741\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span>  I am of the strong opinion that the behavior of a compound expression should be fully determined by its constituent expressions. in this case, given a value expression <code>ptr</code>, we have 3 pieces:</p>\n<ul>\n<li>the place expression <code>*ptr</code></li>\n<li>the (place) field projection <code>_ .field</code></li>\n<li>the (value) expression <code>addr_of!(_)</code></li>\n</ul>\n<p>the current rule for the first step, <code>*ptr</code>, says that when a place is constructed from a value by means of the <code>*</code> operator, the pointer needs to be aligned and dereferencable as determined by the pointee type. we cannot know, at this point, which field will be projected to (if any) and if a load/store actually happens, so I dont see a good way to only require things \"up to the point thats read\".<br>\nwe could simply entirely remove this rule (or say that it only applies when using <code>*</code> on reference-typed values, not raw-ptr-typed values), and I would be very happy with that outcome. but then we have to change the LLVM IR that we generate: <code>addr_of!((*ptr).field)</code> can no longer use <code>getelementptr inbounds</code>.</p>\n</blockquote>\n<p>Yeah, it also seems fairly easy to re-introduce the relevant rules on a <code>move</code>/<code>copy</code> out of the place. This way we can still keep emitting <code>aligned</code> and such on loads/stores to LLVM</p>",
        "id": 272972326,
        "sender_full_name": "Jake",
        "timestamp": 1645633515
    },
    {
        "content": "<p>I think the specific case of <code>addr_of!</code> <em>could</em> be justified as just taking something that \"looks like\" an expression, but that is not an actual expression.</p>\n<p>In other words, for the specific case of <code>addr_of!</code> we make it \"even more magic\" and skip the <code>inbounds</code> attribute as you say, while not changing the rules for any expression that's not within the macro.</p>",
        "id": 272978860,
        "sender_full_name": "Lokathor",
        "timestamp": 1645636144
    },
    {
        "content": "<p>Because what people want is, as always, a way to offset from an arbitrary base pointer to a field pointer. And any answer that we come up with that doesn't just do that is a wrong answer.</p>",
        "id": 272979242,
        "sender_full_name": "Lokathor",
        "timestamp": 1645636294
    },
    {
        "content": "<blockquote>\n<p>Yeah, it also seems fairly easy to re-introduce the relevant rules on a move/copy out of the place. This way we can still keep emitting aligned and such on loads/stores to LLVM</p>\n</blockquote>\n<p>yes, definitely</p>",
        "id": 272990534,
        "sender_full_name": "RalfJ",
        "timestamp": 1645640372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I really dont like magic, and I think it will be more confusing than helpful</p>",
        "id": 272990641,
        "sender_full_name": "RalfJ",
        "timestamp": 1645640410
    },
    {
        "content": "<p>I think in practice people are more often confused that it doesn't do the thing they need it for, not that some very precise rules written down in a book they've never read have arguably been broken a bit. (but not really because the input to the macro could just <em>not actually</em> be interpreted as a real expression).</p>",
        "id": 272991069,
        "sender_full_name": "Lokathor",
        "timestamp": 1645640616
    },
    {
        "content": "<p>I think that's a different set of people than the set we would confuse with magic :) so I think that's a bad tradeoff</p>",
        "id": 272991223,
        "sender_full_name": "RalfJ",
        "timestamp": 1645640683
    },
    {
        "content": "<p>I'd rather make sure this behaves as expected without introducing magic</p>",
        "id": 272991251,
        "sender_full_name": "RalfJ",
        "timestamp": 1645640695
    },
    {
        "content": "<p>That's fine too. As long as it behaves as expected in the end then I don't have any strong opinion on how it gets there.</p>",
        "id": 272991508,
        "sender_full_name": "Lokathor",
        "timestamp": 1645640792
    },
    {
        "content": "<p>I created an issue for centralizing discussion, and to be referenced when this is encountered again in the wild: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/319\">https://github.com/rust-lang/unsafe-code-guidelines/issues/319</a></p>",
        "id": 272997374,
        "sender_full_name": "RalfJ",
        "timestamp": 1645643530
    }
]