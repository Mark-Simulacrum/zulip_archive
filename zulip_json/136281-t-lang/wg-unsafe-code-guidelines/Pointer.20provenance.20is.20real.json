[
    {
        "content": "<p>I wrote a <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">blog post</a> about what does wrong when one pretends that pointers do not have provenance. It might be interesting to the people in this stream. :)</p>",
        "id": 219867203,
        "sender_full_name": "RalfJ",
        "timestamp": 1607963882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> some time ago we spoke about pointer provenance and integer-pointer-roundtrips; this post contains a concrete example of how optimizing away an integer-pointer roundtrip (plus two other common optimizations) introduces a miscompilation.</p>",
        "id": 219867405,
        "sender_full_name": "RalfJ",
        "timestamp": 1607963965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> this is also related to <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/264#issuecomment-744176375\">the LLVM compiler bug you noticed here</a></p>",
        "id": 219867612,
        "sender_full_name": "RalfJ",
        "timestamp": 1607964051
    },
    {
        "content": "<p>Nice post.  Hope it gets some interesting HN discussion.  Some feedback: You say you assume <code>int</code> can store a pointer value for simplicity, but since most people these days write for platforms where <code>int</code> cannot store a pointer value, I think it's just unnecessarily distracting.  If I were you I'd just swap it out for <code>uintptr_t</code>.</p>",
        "id": 219869623,
        "sender_full_name": "comex",
        "timestamp": 1607964933
    },
    {
        "content": "<blockquote>\n<p>You say you assume int can store a pointer value for simplicity, but since most people these days write for platforms where int cannot store a pointer value, I think it's just unnecessarily distracting. If I were you I'd just swap it out for uintptr_t.</p>\n</blockquote>\n<p>Fair... I am just too used to using <code>int</code> here but that's because I learned C on a 32bit machine and didn't write much C since 64bit is commonplace. ;) Fixed that, I hope I didn't screw this up.</p>",
        "id": 219877109,
        "sender_full_name": "RalfJ",
        "timestamp": 1607968224
    },
    {
        "content": "<blockquote>\n<p>Nice post. Hope it gets some interesting HN discussion.</p>\n</blockquote>\n<p>Thanks! Me, too -- I hope someone posts it there (so far that usually happened for my posts but I don't know who did it^^)</p>",
        "id": 219877173,
        "sender_full_name": "RalfJ",
        "timestamp": 1607968252
    },
    {
        "content": "<p>I first meant to make the post just \"here's this funny sequence of examples\" but somehow it turned into something more opinionated than I originally intended. ;) I am curious how people will react to that.</p>",
        "id": 219877277,
        "sender_full_name": "RalfJ",
        "timestamp": 1607968306
    },
    {
        "content": "<p>It has already been posted 1 hour ago: <a href=\"https://news.ycombinator.com/item?id=25419740\">https://news.ycombinator.com/item?id=25419740</a> Currently at 4 points though.</p>",
        "id": 219877687,
        "sender_full_name": "bjorn3",
        "timestamp": 1607968483
    },
    {
        "content": "<p>I see that you briefly touched on \"option 3\" where nothing has provenance. I wish people took that model more seriously; I'm personally convinced that it's possible to get some optimizations with an SB-like setup but without provenance in memory.</p>",
        "id": 219877974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607968634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219877974\">said</a>:</p>\n<blockquote>\n<p>I see that you briefly touched on \"option 3\" where nothing has provenance. I wish people took that model more seriously; I'm personally convinced that it's possible to get some optimizations with an SB-like setup but without provenance in memory.</p>\n</blockquote>\n<p>So that's some kind of middle-ground where provenance exists on the value level but gets lost when the value is put into memory? I personally would be very surprised if that was possible (as you know since this came up in some issue or Zulip thread before), but this is certainly worth exploring. In particular I am worried by the complexities arising from having local variables inside a function not be stored in memory but in some other, non-addressable location. This could mean that local variables follow very different rules depending on whether they have their address taken or not, which seems... odd at least. (By \"possible\" I mean getting a compiler that can compete in terms of performance and has comprehensible rules; defining the model itself of course is very possible.)</p>",
        "id": 219878519,
        "sender_full_name": "RalfJ",
        "timestamp": 1607968835
    },
    {
        "content": "<p>It is possible to do alias analysis without storing alias information \"in\" the values, in the same way that it is possible to do value range analysis without having some special magic value that represents the range. What are the main optimizations we think can't be done without provenance? One that comes to mind is malloc-removal, but I think this can also be handled by saying that it is UB to write to memory owned by the allocator.</p>",
        "id": 219879388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969178
    },
    {
        "content": "<blockquote>\n<p>What are the main optimizations we think can't be done without provenance?</p>\n</blockquote>\n<p>the post lists one as an example -- the third optimization in the chain</p>",
        "id": 219879668,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969326
    },
    {
        "content": "<p>basically, anything based on <code>noalias</code>, <code>restricted</code>, or \"this ptr arithmetic must have stayed in-bounds\" relies on provenance</p>",
        "id": 219879755,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969365
    },
    {
        "content": "<p>From a rustic POV that write to p+1 is bogus anyway</p>",
        "id": 219879799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969389
    },
    {
        "content": "<p>there's no write to p+1 in the original program</p>",
        "id": 219879876,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969407
    },
    {
        "content": "<blockquote>\n<p>It is possible to do alias analysis without storing alias information \"in\" the values, in the same way that it is possible to do value range analysis without having some special magic value that represents the range.</p>\n</blockquote>\n<p>I think you are mixing up two levels here: there's the operational semantics of the language, and there is the static analysis that tries to predict properties that all executions of a certain program will have in common. The latter must be justified against the former. Both alias analysis and range analysis are examples of the latter.<br>\nbut if you define your operational semantics without provenance, then there will be much fewer \"doesn't alias\" results that the alias analysis can correctly return. provenance is about adding more UB to the language so that alias analysis can more often say \"doesn't alias\" without being wrong.</p>",
        "id": 219880080,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969515
    },
    {
        "content": "<p>of course you can do alias analysis on a provenance-free language. that's like doing alias analysis on assembly.</p>",
        "id": 219880180,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969545
    },
    {
        "content": "<p>Not necessarily, because the high level operations can come with annotations that assert inbounds of various kinds</p>",
        "id": 219880262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969597
    },
    {
        "content": "<p>and every compiler engineer I spoke to said that's just not an option if you want your C/C++ compiler to be competitive.</p>",
        "id": 219880280,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969607
    },
    {
        "content": "<p>that doesn't itself require provenance</p>",
        "id": 219880281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969608
    },
    {
        "content": "<p>this depends on the kind of \"inbounds\"</p>",
        "id": 219880320,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969626
    },
    {
        "content": "<p>C/LLVM-style inbounds does require provenance as this post demonstrates</p>",
        "id": 219880368,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969643
    },
    {
        "content": "<p>and Rust inherits that notion</p>",
        "id": 219880415,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969654
    },
    {
        "content": "<p>I don't deny that</p>",
        "id": 219880430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969662
    },
    {
        "content": "<p>I agree that everyone in the space is firmly convinced that provenance is a part of life</p>",
        "id": 219880464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969683
    },
    {
        "content": "<p>except possibly end users</p>",
        "id": 219880510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969711
    },
    {
        "content": "<p>of course one could imagine a completely different approach to all of that. like, a clean-slate redesign of the LLVM memory model with the goal of having no provenance, or only having it in a limited form.</p>",
        "id": 219880539,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969728
    },
    {
        "content": "<p>yeah I realize it's not the sort of thing to hope for in LLVM 12 or what have you</p>",
        "id": 219880669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969778
    },
    {
        "content": "<p>but that's ivry tower theoretical talk at this point; a <em>lot</em> needs to be worked out to make this a concrete proposal that one can even comment on. so it's interesting, but unfortunately unlikely to affect Rust or LLVM meaningfully.</p>",
        "id": 219880670,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969778
    },
    {
        "content": "<p>fair enough. I shall return to my ivory tower then</p>",
        "id": 219880741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969821
    },
    {
        "content": "<p>I love ivory tower theoretical talk, don't get me wrong. :) but I also love making Rust better, and I doubt this kind of redesign is going to help with that, even if it does work out in the end.</p>",
        "id": 219880751,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969825
    },
    {
        "content": "<p>But maybe I am wrong about that and then I will be very happy to ditch provenance at the first opportunity ;)</p>",
        "id": 219880908,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969885
    },
    {
        "content": "<p>I want to make rust better, but I also want to make the best possible language, and I am always a bit sad when it seems like rust can't fill both roles</p>",
        "id": 219881024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607969965
    },
    {
        "content": "<p>yeah I feel you</p>",
        "id": 219881056,
        "sender_full_name": "RalfJ",
        "timestamp": 1607969983
    },
    {
        "content": "<p>but then I remind myself of how much better Rust is than the previous state of the art in this space ;)</p>",
        "id": 219881134,
        "sender_full_name": "RalfJ",
        "timestamp": 1607970005
    },
    {
        "content": "<p>at one of the Rust All Hands, not sure which year, Aaron (I think) gave a great little speech about how Rust has a great mixture of people where some want to make everything absolutely perfect (I consider myself to be in this camp, mostly, even if this discussion might make it seem differently) and others keep pushing for shipping <em>something</em> so we can get things into the hands of users. if you'd let people like us lead Rust there'd never be a 1.0 release and so Rust would never actually improve the world. ;)</p>",
        "id": 219881277,
        "sender_full_name": "RalfJ",
        "timestamp": 1607970106
    },
    {
        "content": "<p>I definitely should write a blog post or a paper about this if only to get my thoughts in order, but my current project that will answer some of these questions is a multi-year endeavor</p>",
        "id": 219881456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607970187
    },
    {
        "content": "<p>yeah</p>",
        "id": 219881525,
        "sender_full_name": "RalfJ",
        "timestamp": 1607970224
    },
    {
        "content": "<p>it turns out writing a language semantics is hard, who knew?</p>",
        "id": 219881655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607970271
    },
    {
        "content": "<p>:D</p>",
        "id": 219881673,
        "sender_full_name": "RalfJ",
        "timestamp": 1607970279
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I appreciate the blog post; it's a clearer explanation of the problem than I've seen anywhere else.</p>",
        "id": 219889131,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973598
    },
    {
        "content": "<p>I do have disagreements with some of the conclusions, but now I have a better framework with which to reason about them.</p>",
        "id": 219889229,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973626
    },
    {
        "content": "<p>My reaction to the C example is that signed overflow being UB was a historical artifact of the standard allowing non-two's-complement representations, and now that C2x mandates the two's complement representation, the standard <em>should</em> define signed overflow as wrapping just as it does for unsigned overflow.</p>",
        "id": 219889537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973748
    },
    {
        "content": "<p>The common argument for not defining signed overflow is that everyone uses <code>int</code> in loop counters and yet <code>int</code> is 4 bytes on modern machines rather than the native size because this would have broken too much code at the beginning of the 64-bit era</p>",
        "id": 219890047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607973860
    },
    {
        "content": "<p>(That's for C. In Rust I'm thankful we have Wrapping for such cases.)</p>",
        "id": 219890056,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  Many people agree with you, but C++20 at least explicitly decided <em>not</em> to define signed overflow, and I doubt C2x will do any different although you may know better.</p>",
        "id": 219890184,
        "sender_full_name": "comex",
        "timestamp": 1607973891
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Why is that an argument for not defining overflow?</p>",
        "id": 219890208,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973902
    },
    {
        "content": "<p>Personally, I'm skeptical that signed overflow being UB for optimization is still justified in a world where loop counters are often size_t anyway.</p>",
        "id": 219890260,
        "sender_full_name": "comex",
        "timestamp": 1607973931
    },
    {
        "content": "<p>By assuming integers don't wrap, compilers are allowed to use native words anyway</p>",
        "id": 219890262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607973932
    },
    {
        "content": "<p>personally I think this is a really dubious way to get this optimization, but it is what it is</p>",
        "id": 219890370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607973970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I don't think that matters in practice unless you're on a platform with no concept of 32-bit values.</p>",
        "id": 219890376,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973975
    },
    {
        "content": "<p>And no instruction for 32-bit arithmetic.</p>",
        "id": 219890406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607973996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Think of things like optimizing array indexing into pointer arithmetic.</p>",
        "id": 219890408,
        "sender_full_name": "comex",
        "timestamp": 1607973997
    },
    {
        "content": "<p>If you use <code>i32</code> as a counter then there is an extra sign extend in the loop</p>",
        "id": 219890452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607974025
    },
    {
        "content": "<p>like <code>for (int i = 0; i &lt; 10; i++) foo(a[i]);</code> --&gt; <code>for (i = 0, ptr = a; i &lt; 10; i++, ptr++) foo(*ptr);</code></p>",
        "id": 219890459,
        "sender_full_name": "comex",
        "timestamp": 1607974028
    },
    {
        "content": "<p>But anyway, this is way off topic.</p>",
        "id": 219890540,
        "sender_full_name": "comex",
        "timestamp": 1607974067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> I'm aware that C2x and C++20 don't define signed overflow. Unfortunately, there are folks in the C and C++ standards who fight for UB because they have optimizations that rely on it, even if the UB itself was not originally motivated by those optimizations.</p>",
        "id": 219890667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974109
    },
    {
        "content": "<p>So C2x also does not?  That's the part I wasn't sure about.</p>",
        "id": 219890762,
        "sender_full_name": "comex",
        "timestamp": 1607974148
    },
    {
        "content": "<p>Yeah, unfortunately not.</p>",
        "id": 219890791,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974163
    },
    {
        "content": "<p>Personally, I don't see that as necessarily unfortunate.  But it is <em>potentially</em> unfortunate if the optimizations are not useful enough.</p>",
        "id": 219890798,
        "sender_full_name": "comex",
        "timestamp": 1607974167
    },
    {
        "content": "<p>If the optimizations are useful, the compiler could still potentially make them if it can prove that they are correct. That puts an additional burden on the compiler before it can do such optimizations, but that doesn't make the optimizations impossible.</p>",
        "id": 219890982,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974241
    },
    {
        "content": "<p>Going back to the blog post: along the same lines, I find it unfortunate that the third possibility is dismissed so strongly.</p>",
        "id": 219891110,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974323
    },
    {
        "content": "<p>See also <a href=\"https://youtu.be/yG1OZ69H_-o?t=2357\">https://youtu.be/yG1OZ69H_-o?t=2357</a> for an example where overflow UB is used for optimization</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"yG1OZ69H_-o\" href=\"https://youtu.be/yG1OZ69H_-o?t=2357\"><img src=\"https://i.ytimg.com/vi/yG1OZ69H_-o/default.jpg\"></a></div>",
        "id": 219891223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607974387
    },
    {
        "content": "<p>Couldn't the C/C++ standard define that it is allowed for the compiler to arbitrarily widen signed integers instead of making it straight up UB to do signed overflow? Signed overflow would then still not be completely defined, but at least the options are much more limited.</p>",
        "id": 219891563,
        "sender_full_name": "bjorn3",
        "timestamp": 1607974544
    },
    {
        "content": "<p>Examples are good, but I think the world needs a lot more hard numbers and research: what is the cost of -fno-strict-overflow, <em>why</em>, how much of that cost can be recovered by improving optimizations...</p>",
        "id": 219891786,
        "sender_full_name": "comex",
        "timestamp": 1607974653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> so, instead of changing the two integer types to be signed, as far as I can tell it would suffice to change them both to be pointer-sized.</p>",
        "id": 219891908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974701
    },
    {
        "content": "<p>And in Rust, it'd be OK to use any non-wrapping integer, or a wrapping integer that's at least pointer-sized.</p>",
        "id": 219892231,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974867
    },
    {
        "content": "<p>In Rust it doesn't matter because approximately nobody uses i32s as array indices.</p>",
        "id": 219892262,
        "sender_full_name": "comex",
        "timestamp": 1607974887
    },
    {
        "content": "<p>Right.</p>",
        "id": 219892285,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974897
    },
    {
        "content": "<p>Though <code>arr[x as usize]</code> is not ridiculously rare. I have code like that.</p>",
        "id": 219892386,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974933
    },
    {
        "content": "<p>(not for i32 though)</p>",
        "id": 219892406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607974945
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I appreciate footnote 4, and I agree that I'd rather have some backing data.</p>",
        "id": 219892522,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607975016
    },
    {
        "content": "<p>So, suppose you don't have provenance.  The first question is whether you allow guessing pointers \"out of thin air\".  Suppose you have</p>\n<div class=\"codehilite\"><pre><span></span><code>int a = 0;\n*(int *)0x1234 = 99;\nreturn a;\n</code></pre></div>\n<p>and the compiler happens to store <code>a</code> on the stack at address <code>0x1234</code>.  Is this program well-defined?</p>",
        "id": 219892906,
        "sender_full_name": "comex",
        "timestamp": 1607975182
    },
    {
        "content": "<p>If the answer is yes, then you sort of can't optimize anything ever.</p>",
        "id": 219892983,
        "sender_full_name": "comex",
        "timestamp": 1607975224
    },
    {
        "content": "<p>At least when variables are involved.</p>",
        "id": 219893008,
        "sender_full_name": "comex",
        "timestamp": 1607975231
    },
    {
        "content": "<p>I discuss another option earlier above, but it could also be implementation defined, as in if you guess right then it's fine, same as layout optimization</p>",
        "id": 219893088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607975270
    },
    {
        "content": "<p>Sure, I'm asking if it's well-defined on an implementation where the choice happens to be right.</p>",
        "id": 219893171,
        "sender_full_name": "comex",
        "timestamp": 1607975292
    },
    {
        "content": "<p>let's say yes</p>",
        "id": 219893206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607975315
    },
    {
        "content": "<p>the compiler can still do the optimization because it can just change what \"implementation defined\" means in this case</p>",
        "id": 219893272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607975358
    },
    {
        "content": "<p>But what exactly is the definition?</p>",
        "id": 219893298,
        "sender_full_name": "comex",
        "timestamp": 1607975375
    },
    {
        "content": "<p>One possibility is to special-case variables that don't have their address taken.</p>",
        "id": 219893312,
        "sender_full_name": "comex",
        "timestamp": 1607975382
    },
    {
        "content": "<p>whatever it happens to do after all optimizations</p>",
        "id": 219893323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607975389
    },
    {
        "content": "<p>I don't know what that means, but I'm going to continue with my monologue for a sec :)</p>",
        "id": 219893419,
        "sender_full_name": "comex",
        "timestamp": 1607975423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219892386\">said</a>:</p>\n<blockquote>\n<p>Though <code>arr[x as usize]</code> is not ridiculously rare. I have code like that.</p>\n</blockquote>\n<p>(I'd personally like it just support indexing with any integer primitive, the same way we support shifting by any integer primitive.  I don't know how often that's using <code>x</code> as a loop counter, though, as opposed to using it more like a lookup table.)</p>",
        "id": 219893732,
        "sender_full_name": "scottmcm",
        "timestamp": 1607975628
    },
    {
        "content": "<p>(me too)</p>",
        "id": 219893746,
        "sender_full_name": "comex",
        "timestamp": 1607975634
    },
    {
        "content": "<p>...Special-casing variables that don't have their address taken is a start, but what if it did have its address taken, but in a trivial way?</p>\n<div class=\"codehilite\"><pre><span></span><code>int a;\n*&amp;a = 1; // maybe this was expanded from a macro or inline function\n*(int *)0x1234 = 99;\nreturn a;\n</code></pre></div>\n<p>If that were allowed to modify <code>a</code>, it would be less bad, but still pretty bad.</p>\n<p>There's still one possible way to make it UB without provenance, which is to basically lie about the address.  After all, the address is unobservable in 'normal' operation.  So even if the assembly code stores <code>a</code> at 0x1234, you can claim for formal purposes it was actually stored at 0x5678 or something.  That's similar to the \"twin allocation\" idea @Ralf Jung worked on.</p>\n<p>But it's also very weird, so I don't know if it's really any better than provenance.</p>",
        "id": 219894019,
        "sender_full_name": "comex",
        "timestamp": 1607975771
    },
    {
        "content": "<p>Now, those examples are in C.  One option is to give up on C and say we only care about Rust, and for Rust we'll use SB instead.  But the current SB formalization depends on at least references having provenance.  I'm curious, <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>, how you would formalize SB without it.</p>",
        "id": 219894684,
        "sender_full_name": "comex",
        "timestamp": 1607976136
    },
    {
        "content": "<p>Well it wouldn't be SB really, that model basically has provenance-in-memory right in the name</p>",
        "id": 219894801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976201
    },
    {
        "content": "<p>but something with equivalent aliasing properties would be the goal</p>",
        "id": 219894830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976225
    },
    {
        "content": "<p>Then what would it be? :) I guess that's a blog-post-sized question.</p>",
        "id": 219894837,
        "sender_full_name": "comex",
        "timestamp": 1607976229
    },
    {
        "content": "<p>I really need to learn how to write a blog</p>",
        "id": 219894997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976296
    },
    {
        "content": "<p>all the cool kids are doing it :)</p>",
        "id": 219895030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976321
    },
    {
        "content": "<p>Can always do the easy version of making a github gist and sending it to TWiR :P</p>",
        "id": 219895068,
        "sender_full_name": "scottmcm",
        "timestamp": 1607976354
    },
    {
        "content": "<p>But to boil it down, in</p>\n<div class=\"codehilite\"><pre><span></span><code>let mut a: i32 = 1;\n*&amp;mut a = 1;\n\n*transmute::&lt;usize, &amp;mut i32&gt;(0x1234) = 2;\n\nreturn a;\n</code></pre></div>\n<p>How do you distinguish <code>&amp;mut a</code> from the result of the transmute such that one is dereferenceable but the other is not?</p>",
        "id": 219895069,
        "sender_full_name": "comex",
        "timestamp": 1607976357
    },
    {
        "content": "<p>Again assuming that <code>a</code> ends up at 0x1234.</p>",
        "id": 219895164,
        "sender_full_name": "comex",
        "timestamp": 1607976402
    },
    {
        "content": "<p>The more radical idea is to say that that code is not accepted in the first place unless you introduce some assertion (or possibly fold this assertion into one of the operations in the example) that says that the transmuted data points to something that does not overlap any existing mut borrow</p>",
        "id": 219895367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976561
    },
    {
        "content": "<p>which would make the code UB in the case where a ends up at 0x1234</p>",
        "id": 219895533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976638
    },
    {
        "content": "<p>Perhaps, but let's say you use a union instead of <code>transmute</code>; where do you put the assertion?</p>",
        "id": 219895715,
        "sender_full_name": "comex",
        "timestamp": 1607976724
    },
    {
        "content": "<p>it is associated to the write</p>",
        "id": 219895749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976746
    },
    {
        "content": "<p>If it's associated to the write,  why doesn't the same assertion trigger with a normal/valid write?</p>",
        "id": 219895805,
        "sender_full_name": "comex",
        "timestamp": 1607976794
    },
    {
        "content": "<p>so immediately before the operation / somewhere the compiler can pick up on it, you have to \"reify\" the pointee as a reference long enough to write to it</p>",
        "id": 219895811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976799
    },
    {
        "content": "<p>The same assertion does trigger on a normal write</p>",
        "id": 219895922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976851
    },
    {
        "content": "<p>So you have an <code>&amp;mut i32</code> with the bit pattern <code>0x1234</code>, what are you asserting about it?</p>",
        "id": 219895973,
        "sender_full_name": "comex",
        "timestamp": 1607976881
    },
    {
        "content": "<p>most of the time it's easy to obtain because you are following borrowing discipline</p>",
        "id": 219895978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976883
    },
    {
        "content": "<p>When you write to the reference, you assert that it does not overlap with any active mut borrows</p>",
        "id": 219896056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976941
    },
    {
        "content": "<p>But in the case of <code>*&amp;mut a = 1;</code>, it does overlap with an active mut borrow, namely that borrow itself.</p>",
        "id": 219896136,
        "sender_full_name": "comex",
        "timestamp": 1607976967
    },
    {
        "content": "<p>obviously that one doesn't count</p>",
        "id": 219896191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607976999
    },
    {
        "content": "<p>disjointness here only wrt other borrows</p>",
        "id": 219896218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977015
    },
    {
        "content": "<p>Sure.  But why not?  Well, putting it all in one statement makes it confusing, but let's say we had <code>let b = &amp;mut a; *b = 1;</code>.  How do you say that it doesn't count for <code>b</code> but does count for <code>transmute::&lt;usize, &amp;mut i32&gt;(0x1234)</code>?  How do you distinguish them, without that being equivalent to provenance?</p>",
        "id": 219896414,
        "sender_full_name": "comex",
        "timestamp": 1607977109
    },
    {
        "content": "<p>I suppose you could say it's based on static properties of the reference, i.e. lifetimes, not dynamic ones.</p>",
        "id": 219896734,
        "sender_full_name": "comex",
        "timestamp": 1607977264
    },
    {
        "content": "<p>But that has its own issues.</p>",
        "id": 219896764,
        "sender_full_name": "comex",
        "timestamp": 1607977283
    },
    {
        "content": "<p>The assertion being made is different. One of them says that we can get a new borrow on <code>0x1234</code> that does not overlap any mut borrows in scope (in particular the one on <code>b</code>), while the other one says we reborrow <code>b</code> so we are promising that <code>b</code>, or at least the part of it in the reborrow, does not overlap any borrows in scope distinct from b</p>",
        "id": 219896777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977289
    },
    {
        "content": "<p>The structure of who borrows who is explicit because this is rust code</p>",
        "id": 219896876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977330
    },
    {
        "content": "<p>When is the assertion made?  Before you said it was triggered on write.  But how does the write \"know\" whether <code>b</code> was derived from a reborrow or a transmute?</p>",
        "id": 219896951,
        "sender_full_name": "comex",
        "timestamp": 1607977369
    },
    {
        "content": "<p>Or perhaps the assertion is made on transmute, but then what do you do with unions?</p>",
        "id": 219896970,
        "sender_full_name": "comex",
        "timestamp": 1607977381
    },
    {
        "content": "<p>It's more like an elaboration of the code, similar to the <code>retag</code> ops in SB</p>",
        "id": 219896992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977399
    },
    {
        "content": "<p>by looking at the input code you determine what assertions to insert, and the assertions provide the information necessary for the compiler to prove safety (unless the assertions are false and then it's UB)</p>",
        "id": 219897106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977450
    },
    {
        "content": "<p>My feeling is that if you try to formalize this it will end up being equivalent to a form of provenance.</p>",
        "id": 219897363,
        "sender_full_name": "comex",
        "timestamp": 1607977590
    },
    {
        "content": "<p>That's possible. It seems clearer to me, although I'm sure I haven't convinced anyone else that anything I'm saying is clear</p>",
        "id": 219897488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977672
    },
    {
        "content": "<p>in particular, I think it is important that a provenance, if you want to call it that, can exist separately from the value, travel along different control flow and get recombined later</p>",
        "id": 219897683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977763
    },
    {
        "content": "<p>I'm pretty sure that this is impossible with LLVM style provenance</p>",
        "id": 219897730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977792
    },
    {
        "content": "<p>FWIW, I don't mean to be discouraging.  I'm just trying to help... sharpen the concept.</p>",
        "id": 219897737,
        "sender_full_name": "comex",
        "timestamp": 1607977796
    },
    {
        "content": "<p>If for no other reason than that, if I'm right that there's a missing piece to the story, it might help you find it.</p>",
        "id": 219897821,
        "sender_full_name": "comex",
        "timestamp": 1607977835
    },
    {
        "content": "<p>The idea of a provenance existing separately from the corresponding value is interesting.  So it would be something like \"permission to access X address\"?</p>",
        "id": 219897894,
        "sender_full_name": "comex",
        "timestamp": 1607977884
    },
    {
        "content": "<p>yes</p>",
        "id": 219897904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977893
    },
    {
        "content": "<p>When you call a function, you pass in the <del>provenances</del> permissions associated based on the types, and that's all the function gets</p>",
        "id": 219898010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977948
    },
    {
        "content": "<p>so a read/write to random memory is UB</p>",
        "id": 219898093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607977999
    },
    {
        "content": "<p>and moreover the compiler isn't going to let you read/write random addresses even if you happen to own them because it can't prove that. You have to add some intrinsic that magics up a permission for you first</p>",
        "id": 219898240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607978077
    },
    {
        "content": "<p>However I think it would be difficult to support all this in rust without passing around a lot of ZSTs</p>",
        "id": 219898424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607978173
    },
    {
        "content": "<p>Well, keep thinking about it.</p>",
        "id": 219898466,
        "sender_full_name": "comex",
        "timestamp": 1607978206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219892906\">said</a>:</p>\n<blockquote>\n<p>So, suppose you don't have provenance.  The first question is whether you allow guessing pointers \"out of thin air\".  Suppose you have</p>\n<div class=\"codehilite\"><pre><span></span><code>int a = 0;\n*(int *)0x1234 = 99;\nreturn a;\n</code></pre></div>\n<p>and the compiler happens to store <code>a</code> on the stack at address <code>0x1234</code>.  Is this program well-defined?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219892983\">said</a>:</p>\n<blockquote>\n<p>If the answer is yes, then you sort of can't optimize anything ever.</p>\n</blockquote>\n<p>Informally speaking: I think this is a case where something like <code>volatile</code> would be useful. I <em>do</em> believe it's reasonable for the compiler to, under normal circumstances, assume that a value won't be changed by random pointer writes, and thus keep it in a register without having to reload it from memory all the time. If you want a value that can be changed out from under you at any time (e.g. a buffer backed by a MMIO device or a shared memory region), you need something like <code>volatile</code> for that.</p>",
        "id": 219912563,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985502
    },
    {
        "content": "<p>In other words, I think it's reasonable to answer your question with \"yes, you can guess a pointer out of thin air\", while simultaneously stating that if you write through such a pointer, it's unspecified (but <em>not</em> UB) whether any given read of the value you wrote to observes that write.</p>",
        "id": 219912652,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985579
    },
    {
        "content": "<p>Which means the compiler would be allowed to optimize the last statement into <code>return 0;</code>, but is not obligated to do so, which means the function may return either 0 or 99 depending on optimization level. And I think that's perfectly OK.</p>",
        "id": 219912750,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985632
    },
    {
        "content": "<p>I'd much rather have more of that kind of unspecified-but-not-undefined behavior, rather than UB.</p>",
        "id": 219912839,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985688
    },
    {
        "content": "<p>It's not immediately clear to me that those two options exhaustively enumerate the possibilities that common compiler optimizations will produce here. At the very least you could also get misaligned / torn reads, and inconsistent reads of the same value seem possible as well</p>",
        "id": 219913170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607985858
    },
    {
        "content": "<p>This is the space I'm comfortable working in. I'd love to see requirements like \"if you access a machine-word-sized, machine-word-aligned value, you will never get a torn read; if you access a value larger than a machine word, or not aligned to a machine-word boundary, you may get a torn read\".</p>",
        "id": 219913285,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607985958
    },
    {
        "content": "<p>but I assume that inconsistent reads would not be acceptable to you</p>",
        "id": 219913384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219913384\">said</a>:</p>\n<blockquote>\n<p>but I assume that inconsistent reads would not be acceptable to you</p>\n</blockquote>\n<p>Why do you assume that? :)</p>",
        "id": 219913407,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986012
    },
    {
        "content": "<p>i.e. you load the value once, observe it twice and see two different things</p>",
        "id": 219913421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986024
    },
    {
        "content": "<p>that's basically LLVM <code>undef</code></p>",
        "id": 219913441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986036
    },
    {
        "content": "<blockquote>\n<p>Which means the compiler would be allowed to optimize the last statement into <code>return 0;</code>, but is not obligated to do so, which means the function may return either 0 or 99 depending on optimization level. And I think that's perfectly OK.</p>\n</blockquote>\n<p>In C and C++ at least, this is actually unspecified. The int-ptr cast has an unspecified result, which is constrained by the round-trip rule.</p>",
        "id": 219913451,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607986045
    },
    {
        "content": "<p>The compiler merely chooses to simply give you an invalid pointer.</p>",
        "id": 219913548,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607986083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Often, especially when writing concurrent code, I found myself in the position of <em>not</em> being able to assume that referencing a value twice will only perform one load.</p>",
        "id": 219913558,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986087
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> The Linux kernel and some other concurrent code has special operations for \"I need you to load this exactly once\".</p>",
        "id": 219913608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986123
    },
    {
        "content": "<p>In the absence of such operations, I have no problem with the idea that <code>*a + *a</code> may give you an odd number, for instance. :)</p>",
        "id": 219913680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986162
    },
    {
        "content": "<p>I'm saying suppose you use that, but get two results anyway because you loaded <code>undef</code></p>",
        "id": 219913687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986166
    },
    {
        "content": "<p>The operations I was referring to <em>can't</em> return <code>undef</code>; they're defined in machine semantics, where undef isn't a thing.</p>",
        "id": 219913774,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986207
    },
    {
        "content": "<p>It seems likely to me that reading a possibly clobbered value after optimization could well have such an effect, if the optimization only triggered at one of the uses</p>",
        "id": 219913876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986272
    },
    {
        "content": "<p>So, there are two separate issues here.</p>",
        "id": 219913901,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986289
    },
    {
        "content": "<p>If I load some value into a local through a volatile pointer, and then use that local, the compiler is by definition not allowed to reload the local value from the pointer. So it has to be the same consistent local value once loaded. That's important for things like MMIO or shared memory. (Similarly, if I load two local values via two loads from a volatile pointer, the compiler is not allowed to assume they loaded the same value.)</p>",
        "id": 219914037,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986385
    },
    {
        "content": "<p>If I <em>don't</em> use a volatile pointer, the compiler may make such assumptions, and it's my fault if those assumptions aren't valid. That doesn't mean it's UB; it means I might get inconsistent results depending on optimizations and similar.</p>",
        "id": 219914245,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986507
    },
    {
        "content": "<p>That's talking about loads through a pointer, however.</p>",
        "id": 219914300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986543
    },
    {
        "content": "<blockquote>\n<p>That doesn't mean it's UB; it means I might get inconsistent results depending on optimizations and similar.</p>\n</blockquote>\n<p>That sounds tricky to define</p>",
        "id": 219914367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986566
    },
    {
        "content": "<p>Especially because \"results\" are not localized to just the load itself but all uses of that load</p>",
        "id": 219914402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986601
    },
    {
        "content": "<blockquote>\n<p>the compiler may make such assumptions, and it's my fault if those assumptions aren't valid.</p>\n</blockquote>\n<p>This is usually called UB</p>",
        "id": 219914435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986634
    },
    {
        "content": "<p>Generally \"the compiler may assume X\" is equivalent to \"not-X is undefined behavior\"</p>",
        "id": 219914550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607986693
    },
    {
        "content": "<p>There's a big difference between \"unspecified valid value\" and \"magic LLVM invoke-nasal-demons value that can't exist in real memory\". :)</p>",
        "id": 219914650,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986759
    },
    {
        "content": "<p>In any case, backing up a step:</p>",
        "id": 219914680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986790
    },
    {
        "content": "<p>I'm not too worried about the case of using a non-volatile pointer to access volatile memory.</p>",
        "id": 219914727,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986803
    },
    {
        "content": "<p>And I don't want to quibble over the semantics of that case, or the definition of UB there.</p>",
        "id": 219914761,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986818
    },
    {
        "content": "<p>The distinction I was trying to make earlier (and didn't get to yet) was that that was all about loads <em>through a pointer</em>.</p>",
        "id": 219914779,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986835
    },
    {
        "content": "<p>If you have a local variable like <code>let a = 0;</code>, and someone makes up a pointer and scribbles through it, and that happens to overwrite <code>a</code>, that's different from making up a pointer and using it to write to a value that I'm referencing from another pointer.</p>",
        "id": 219914939,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607986948
    },
    {
        "content": "<p>The same general premise applies there: if you had a raw volatile pointer to <code>a</code> and loaded through that, you could expect the exactly-one-load behavior. Otherwise, you could get behavior like <code>a + a</code> being odd, and that's OK.</p>",
        "id": 219915136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607987084
    },
    {
        "content": "<p>But compiler optimizations don't obey the laws of causality</p>",
        "id": 219915282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987178
    },
    {
        "content": "<p>so you can't reason about the values in this way</p>",
        "id": 219915299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987188
    },
    {
        "content": "<p>you might be able to use something more constrained than UB but not by much</p>",
        "id": 219915324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219915299\">said</a>:</p>\n<blockquote>\n<p>so you can't reason about the values in this way</p>\n</blockquote>\n<p>I think I'm a little confused by what you mean by \"you can't reason about the values\". You <em>can</em>, you just might be wrong.</p>",
        "id": 219915455,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607987298
    },
    {
        "content": "<p>I guess what I'm trying to figure out is what property you <em>do</em> expect to hold when there is a data race (which is what this is). Because it seems like this would more or less break all the compiler's assumptions</p>",
        "id": 219915664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987457
    },
    {
        "content": "<p>and I have no idea what you can say about the result other than \"it looks kind of like the output of a compiler\"</p>",
        "id": 219915704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987491
    },
    {
        "content": "<p>Thinking about it, let me try stating it in a slightly different way, which I <em>think</em> might be closing in on the distinction I'm trying to make:<br>\nYou're allowed to write through a pointer, and potentially overwrite some other value. That, in itself, shouldn't inherently be UB, because there are legitimate reasons to do so. You're also allowed to rely on the consistency of a value you're reading from a local variable. It's the <em>combination</em> of doing both of those things <em>on the same location</em> that leads to UB. Typically, the former gets defined as UB, because that's easier than saying the combination of the two is UB.</p>",
        "id": 219915745,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607987518
    },
    {
        "content": "<p>(This is meant to be an example of two interacting requirements, not the only two interacting requirements.)</p>",
        "id": 219915856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607987581
    },
    {
        "content": "<p>well, that's a conjunction of an action and an invariant, so the action alone has to be UB</p>",
        "id": 219915887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987605
    },
    {
        "content": "<p>Can you define \"action\" and \"invariant\" here, because that sounds like you're stating a property that seems self-evident to you and it isn't obvious to me.</p>",
        "id": 219915972,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607987650
    },
    {
        "content": "<p>Action meaning operation with operational semantics (i.e. writing to memory modifies the abstract machine state), and invariant meaning a property that the compiler expects to hold across states (in this case the value of a piece of memory in a local variable). An invariant can't itself cause UB because it doesn't <em>do</em> anything, it just is a property that holds</p>",
        "id": 219916128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987746
    },
    {
        "content": "<p>Maybe you can weaken it to say that writing through a pointer is okay unless you happen to overwrite data that the compiler is relying on, but that probably encompasses all allocated memory and stack, so you are limited to unmapped regions and MMIO regions and such (which doesn't seem so bad)</p>",
        "id": 219916257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607987822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219916257\">said</a>:</p>\n<blockquote>\n<p>Maybe you can weaken it to say that writing through a pointer is okay unless you happen to overwrite data that the compiler is relying on, but that probably encompasses all allocated memory and stack, so you are limited to unmapped regions and MMIO regions and such (which doesn't seem so bad)</p>\n</blockquote>\n<p>That's part of it. It definitely <em>shouldn't</em> be UB to write through a pointer to something that other parts of the program reference via either a volatile pointer or a similar mechanism with load-once semantics, even if the write is unsynchronized (or generated by hardware or device or similar).</p>",
        "id": 219916443,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607987949
    },
    {
        "content": "<p>I think as long as you have the concept of \"volatile memory\" and not just volatile access then that can be done; the abstract machine just relinquishes control on that region of memory and makes no promises about anything that comes out</p>",
        "id": 219916612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988070
    },
    {
        "content": "<p>/me shakes his head there.</p>",
        "id": 219916629,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988082
    },
    {
        "content": "<p>but if you volatile access memory that is owned by some other place in the code then expect to crash and burn</p>",
        "id": 219916678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988114
    },
    {
        "content": "<p>In practice, even though C's use of <code>volatile</code> is in the context of a \"volatile pointer\", practical code tends to use it in the form of a \"volatile access\", and a \"volatile pointer\" is just \"a pointer through which all accesses are volatile\".</p>",
        "id": 219916740,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219916678\">said</a>:</p>\n<blockquote>\n<p>but if you volatile access memory that is owned by some other place in the code then expect to crash and burn</p>\n</blockquote>\n<p>There are other cases. Consider, for instance, that you might use non-volatile operations on something before it becomes shared, and only start using volatile operations once you know it to be shared.</p>",
        "id": 219916780,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988190
    },
    {
        "content": "<p>Don't they say not to use volatile for concurrency?</p>",
        "id": 219916823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988222
    },
    {
        "content": "<p>I think that such an operation needs to come with an explicit transfer of control from the rust AM to the volatile memory region</p>",
        "id": 219916941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988284
    },
    {
        "content": "<p>Volatile is critical in non-blocking concurrency (as well as the concurrency between drivers and hardware, and other such things). The advice I've seen is more \"volatile doesn't make your concurrency correct, it just allows you to carefully write correct code\".</p>",
        "id": 219916957,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219916941\">said</a>:</p>\n<blockquote>\n<p>I think that such an operation needs to come with an explicit transfer of control from the rust AM to the volatile memory region</p>\n</blockquote>\n<p>Hardware is not written in the rust abstract machine, so I'm not sure what this would mean.</p>",
        "id": 219917010,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988330
    },
    {
        "content": "<p>You have to signal to rust that it doesn't own the memory anymore. It would be some hardware no op that is like a drop from rust's POV</p>",
        "id": 219917107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988377
    },
    {
        "content": "<p>Ah, \"ownership\", not \"control\". I was assuming that the memory was accessed through a pointer the whole time, not via something that looks like ownership from Rust's perspective, yes.</p>",
        "id": 219917189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988437
    },
    {
        "content": "<p>Otherwise, it could hold on to some non-volatile pointers into the region, access it without volatile because why not, mess up your MMIO, and then wonder why the value isn't still what it expected</p>",
        "id": 219917195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988441
    },
    {
        "content": "<p>I'm suggesting that this is allowed without UB:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">use_non_volatile_ops</span><span class=\"p\">(</span><span class=\"n\">raw_ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">bring_up_other_cpus</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">use_volatile_ops</span><span class=\"p\">(</span><span class=\"n\">raw_ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219917311,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988505
    },
    {
        "content": "<p>Or, for that matter:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">use_non_volatile_ops</span><span class=\"p\">(</span><span class=\"n\">raw_ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">bring_up_device</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">use_volatile_ops</span><span class=\"p\">(</span><span class=\"n\">raw_ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219917368,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988564
    },
    {
        "content": "<p>(Separately, it's worth considering how that could be done safely without unsafe code or raw pointers, but at a minimum, <em>that</em> needs to be allowed with raw pointers and <code>unsafe</code>.)</p>",
        "id": 219917536,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988668
    },
    {
        "content": "<p>is it UB to access that memory as non-volatile in the <code>use_volatile_ops</code> section?</p>",
        "id": 219917649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988760
    },
    {
        "content": "<p>Reasonable question. If it is, that would require very careful definition.</p>\n<p>It should absolutely be possible to, for instance, shut down concurrent accesses and then start using non-volatile accesses again.</p>",
        "id": 219917761,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988835
    },
    {
        "content": "<p>that's why I think there should be explicit allocation/deallocation required to delimit the volatile section</p>",
        "id": 219917852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988880
    },
    {
        "content": "<p>Do you mean \"semantically\" or \"as an operation known to the Rust abstract machine\"? The former seems fine. The latter not so much.</p>",
        "id": 219917895,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607988914
    },
    {
        "content": "<p>I'm not sure I see the difference</p>",
        "id": 219917916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988932
    },
    {
        "content": "<p>it needs to be known to the RAM so that compiler optimizations respect it</p>",
        "id": 219917942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607988949
    },
    {
        "content": "<p>For instance, something like <code>lock_device_buffer(); use_non_volatile_ops_again(raw_ptr); unlock_device_buffer();</code>, where locking the device might involve setting a flag in the hardware to prevent it from making your accesses to <code>raw_ptr</code> inconsistent.</p>",
        "id": 219918082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989023
    },
    {
        "content": "<p>Semantically, you are indeed delimiting your types of operations with those calls.</p>",
        "id": 219918114,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989043
    },
    {
        "content": "<p>The Rust abstract machine has no idea what <code>bring_up_device()</code> does, though.</p>",
        "id": 219918142,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989071
    },
    {
        "content": "<p>it would make sense for those operations to also let the compiler know so that it doesn't do something bad</p>",
        "id": 219918193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989091
    },
    {
        "content": "<p>In a sense, this is what <code>read_volatile</code> itself does - it's as if you have a little volatile section and do your read inside that</p>",
        "id": 219918244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989148
    },
    {
        "content": "<p>Well, if every volatile operation constitutes the kind of delineation you're asking for, then this is certainly trivial to satisfy. :)</p>",
        "id": 219918272,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989186
    },
    {
        "content": "<p>but considering the way the rust memory model works it seems like a region/lifetime based approach is more accurate</p>",
        "id": 219918351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989227
    },
    {
        "content": "<p>If we're trying to define this in <em>safe</em> code I absolutely agree.</p>",
        "id": 219918383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989250
    },
    {
        "content": "<p>For <code>unsafe</code> code, I would hope that isn't necessary.</p>",
        "id": 219918417,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989271
    },
    {
        "content": "<p>well I don't think there is an essential difference between those. One just gets tool support</p>",
        "id": 219918438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989286
    },
    {
        "content": "<p>AFAICT, <code>unsafe</code> code doesn't typically have to <em>tell</em> the Rust compiler such things, it just does things, and then the compiler assumes whatever it did was acceptable.</p>",
        "id": 219918507,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989326
    },
    {
        "content": "<p>well, <code>read</code>/<code>read_volatile</code> wouldn't exist if that were enough</p>",
        "id": 219918542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989354
    },
    {
        "content": "<p>No, I agree that <code>read_volatile</code> is necessary. I'm just not clear on why you don't think it's sufficient, as well.</p>",
        "id": 219918568,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989383
    },
    {
        "content": "<p>Anything <em>beyond</em> <code>read_volatile</code> would be an abstraction to help people more easily write correct code; you don't <em>need</em> that abstraction to write correct code.</p>",
        "id": 219918634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989438
    },
    {
        "content": "<p>I don't expect the underlying semantics of <code>read_volatile</code> in the Rust abstract machine to be \"start some region, read a thing, stop some region\". I expect the underlying semantics to be a single \"load once\" semantic operation, which prevents the abstract machine from doing anything like \"oh, I can just load that from memory again\" that it could normally do with pointer loads.</p>",
        "id": 219919128,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989690
    },
    {
        "content": "<blockquote>\n<p>which prevents the abstract machine from doing anything like \"oh, I can just load that from memory again\" that it could normally do with pointer loads</p>\n</blockquote>\n<p>Why wouldn't it, if it's just regular memory? You might argue that if it does so it will not get the same answer, but I don't see how you disallow performing the read in the first place unless it's considered off limits in some way</p>",
        "id": 219919245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989802
    },
    {
        "content": "<blockquote>\n<p>I expect the underlying semantics to be a single \"load once\" semantic operation</p>\n</blockquote>",
        "id": 219919304,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989829
    },
    {
        "content": "<p>Because it was told not to.</p>",
        "id": 219919312,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989834
    },
    {
        "content": "<p>that is, <code>let x = p.read_volatile();</code> can be \"optimized\" to <code>let x = p.read_volatile(); let y = p.read();</code></p>",
        "id": 219919349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989869
    },
    {
        "content": "<p>which would be bad</p>",
        "id": 219919359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989882
    },
    {
        "content": "<p>I'm assuming you meant for the former code to have some mention of <code>y</code>?</p>",
        "id": 219919381,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989898
    },
    {
        "content": "<p>no</p>",
        "id": 219919385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989902
    },
    {
        "content": "<p>Then what is <code>y</code>?</p>",
        "id": 219919394,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989908
    },
    {
        "content": "<p>it's just a plain invented read</p>",
        "id": 219919398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989910
    },
    {
        "content": "<p>Why is the compiler inventing a read it wasn't told to perform, when it was just told \"load once from this address\"?</p>",
        "id": 219919460,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607989932
    },
    {
        "content": "<p>if p is a raw pointer that seems not allowed</p>",
        "id": 219919461,
        "sender_full_name": "simulacrum",
        "timestamp": 1607989937
    },
    {
        "content": "<p>does the load not imply that <code>p</code> is dereferenceable?</p>",
        "id": 219919486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607989971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219916957\">said</a>:</p>\n<blockquote>\n<p>Volatile is critical in non-blocking concurrency</p>\n</blockquote>\n<p>I mean, you can use it for that, like Linux does, but in general you can accomplish the same thing in a more portable way using atomics.</p>",
        "id": 219919498,
        "sender_full_name": "comex",
        "timestamp": 1607989980
    },
    {
        "content": "<p>but y could be reordered before/after x if it already existed by my understanding</p>",
        "id": 219919531,
        "sender_full_name": "simulacrum",
        "timestamp": 1607990010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> For \"volatile\", feel free to read that as \"something like volatile that provides appropriate load-once and store-once operations\".</p>",
        "id": 219919532,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919486\">said</a>:</p>\n<blockquote>\n<p>does the load not imply that <code>p</code> is dereferenceable?</p>\n</blockquote>\n<p>It implies \"load once from p\".</p>",
        "id": 219919561,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919486\">said</a>:</p>\n<blockquote>\n<p>does the load not imply that <code>p</code> is dereferenceable?</p>\n</blockquote>\n<p>I don't think a <em>volatile</em> load implies that <code>p</code> is dereferenceable.</p>",
        "id": 219919567,
        "sender_full_name": "comex",
        "timestamp": 1607990034
    },
    {
        "content": "<p>so <code>p.read(); p.volatile_read();</code> ~&gt; <code>p.read(); p.volatile_read(); p.read();</code> then</p>",
        "id": 219919648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607990074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919567\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919486\">said</a>:</p>\n<blockquote>\n<p>does the load not imply that <code>p</code> is dereferenceable?</p>\n</blockquote>\n<p>I don't think a <em>volatile</em> load implies that <code>p</code> is dereferenceable.</p>\n</blockquote>\n<p>Especially since, in MMIO, a read may actually have side effects. So you <em>definitely</em> can't invent a read that wasn't there.</p>",
        "id": 219919653,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990077
    },
    {
        "content": "<p>That's the point I'm trying to make</p>",
        "id": 219919673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607990092
    },
    {
        "content": "<p>If p is a raw pointer you definitely can't manufacture reads</p>",
        "id": 219919689,
        "sender_full_name": "simulacrum",
        "timestamp": 1607990102
    },
    {
        "content": "<p>If it's a reference, you probably shouldn't be doing volatile ops on it</p>",
        "id": 219919716,
        "sender_full_name": "simulacrum",
        "timestamp": 1607990119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> In the interests of trying to interpret charitably rather than adversarially: are you trying to get at a case where the compiler reorders an existing non-volatile operation across a volatile operation?</p>",
        "id": 219919768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919648\">said</a>:</p>\n<blockquote>\n<p>so <code>p.read(); p.volatile_read();</code> ~&gt; <code>p.read(); p.volatile_read(); p.read();</code> then</p>\n</blockquote>\n<p>This is still dubious since <code>p.volatile_read()</code> might deallocate <code>p</code>.</p>",
        "id": 219919830,
        "sender_full_name": "comex",
        "timestamp": 1607990176
    },
    {
        "content": "<p>I'm trying to show why the relevant invariant the RAM needs is a region based thing, not a single operation</p>",
        "id": 219919852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607990193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919852\">said</a>:</p>\n<blockquote>\n<p>I'm trying to show why the relevant invariant the RAM needs is a region based thing, not a single operation</p>\n</blockquote>\n<p>I still don't think it's a region. It's a single operation, that also has some ordering-barrier semantics. This gets into semantics of concurrency and barriers, and \"what kind of a barrier does a volatile read/write imply\".</p>",
        "id": 219919904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990235
    },
    {
        "content": "<p>Agreed.  But the barrier is limited to other accesses /to the same pointer/.</p>",
        "id": 219920027,
        "sender_full_name": "comex",
        "timestamp": 1607990289
    },
    {
        "content": "<p>Otherwise reordering is allowed.</p>",
        "id": 219920072,
        "sender_full_name": "comex",
        "timestamp": 1607990340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> I'd say \"through the same pointer\", but yes, in the absence of some other stronger barrier I think that might potentially be reasonable semantics.</p>",
        "id": 219920080,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990344
    },
    {
        "content": "<p>Also, the barrier would cover \"other accesses to the same pointer whether volatile or not\" as well as \"volatile accesses to any pointer\".</p>",
        "id": 219920118,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990365
    },
    {
        "content": "<p>Right.</p>",
        "id": 219920133,
        "sender_full_name": "comex",
        "timestamp": 1607990377
    },
    {
        "content": "<p>If I do <code>p1.read_volatile(); p2.read_volatile()</code>, the compiler is <em>not</em> allowed to reorder those either.</p>",
        "id": 219920142,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990382
    },
    {
        "content": "<p>Is it? I always thought the compiler was free to reorder volatile and non-volatile operations</p>",
        "id": 219920274,
        "sender_full_name": "simulacrum",
        "timestamp": 1607990430
    },
    {
        "content": "<p>Just not two volatile ops</p>",
        "id": 219920292,
        "sender_full_name": "simulacrum",
        "timestamp": 1607990439
    },
    {
        "content": "<p>(Aside: sometimes I wonder if it would help to have a <code>require_state_representable_on_concrete_machine_at_this_point()</code> operation, possibly with annotations for specific exceptions to that \"as-if concrete machine\" representation. That'd be a concrete equivalent to the fabled <code>barrier()</code> operation that some C code uses.)</p>",
        "id": 219920494,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990583
    },
    {
        "content": "<p>That exists, it's called <code>asm!(\"\")</code> :)</p>",
        "id": 219920527,
        "sender_full_name": "comex",
        "timestamp": 1607990602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> It exists in C. I don't yet know if the Rust compiler agrees with you on that point. There's been discussion about using <code>asm!</code> for compiler barriers, and thus far, those of us advocating for <code>asm!</code> have carefully stayed out of that to avoid having potential roadblocks thrown up that might stymie <code>asm!</code>.</p>",
        "id": 219920567,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219920274\">said</a>:</p>\n<blockquote>\n<p>Is it? I always thought the compiler was free to reorder volatile and non-volatile operations</p>\n</blockquote>\n<p>In general it is free to do so.  But even two non-volatile operations can't be reordered with each other if they're accessing the same memory, so at least in practice compilers give the same courtesy to reordering non-volatile with volatile.</p>",
        "id": 219920658,
        "sender_full_name": "comex",
        "timestamp": 1607990672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> (Except on Alpha. Let us never speak of Alpha.)</p>",
        "id": 219920766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990752
    },
    {
        "content": "<p>I mean by the compiler.</p>",
        "id": 219920774,
        "sender_full_name": "comex",
        "timestamp": 1607990759
    },
    {
        "content": "<p>Sorry, reflex from past trauma. ;)</p>",
        "id": 219920861,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Of course, in practice you can't ask for <em>all</em> state to be representable on the concrete machine; if there's some outer function frame, for instance, and it has some pointer variable where the optimized code made some assumption about provenance, you can't magically make that go away.</p>",
        "id": 219920923,
        "sender_full_name": "comex",
        "timestamp": 1607990870
    },
    {
        "content": "<p>Two non-volatile reads from the same memory can be merged by the compiler or reordered? I don't see why not, at least</p>",
        "id": 219920951,
        "sender_full_name": "simulacrum",
        "timestamp": 1607990882
    },
    {
        "content": "<p>Good point, I was thinking about writes</p>",
        "id": 219921000,
        "sender_full_name": "comex",
        "timestamp": 1607990904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219920658\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219920274\">said</a>:</p>\n<blockquote>\n<p>Is it? I always thought the compiler was free to reorder volatile and non-volatile operations</p>\n</blockquote>\n<p>In general it is free to do so.  But even two non-volatile operations can't be reordered with each other if they're accessing the same memory, so at least in practice compilers give the same courtesy to reordering non-volatile with volatile.</p>\n</blockquote>\n<p>I'm not entirely sure that's true. I <em>think</em> the compiler may be allowed to perform optimizations that are the equivalent to reordering non-volatile operations on the same memory.</p>",
        "id": 219921010,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219920923\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> Of course, in practice you can't ask for <em>all</em> state to be representable on the concrete machine; if there's some outer function frame, for instance, and it has some pointer variable where the optimized code made some assumption about provenance, you can't magically make that go away.</p>\n</blockquote>\n<p>In C at least, calling an external function can act as such a barrier, and because of that, you <em>can</em> expect the compiler to not make such assumptions across calls to you.</p>",
        "id": 219921061,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607990963
    },
    {
        "content": "<p>Sure, but if you say, e.g., <code>int x = 0; call_external_function(); return x;</code>, the compiler is still allowed to optimize <code>return x</code> to <code>return 0</code>.</p>",
        "id": 219921154,
        "sender_full_name": "comex",
        "timestamp": 1607991020
    },
    {
        "content": "<p>Also, the as-if rule becomes very relevant here. The compiler need not make some bit of state machine-representable if you have no access to that state.</p>",
        "id": 219921170,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991028
    },
    {
        "content": "<p>Yes, that, exactly.</p>",
        "id": 219921174,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991031
    },
    {
        "content": "<p>That said, I think in practice there are a <em>lot</em> of broken assumptions about what exactly a compiler barrier does, and it just so happens that the ways in which programmers use such barriers are very focused on specific cases that happen to work.</p>",
        "id": 219921189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991049
    },
    {
        "content": "<p>(I didn't mean to introduce a tangent with that aside. Let's go back to volatile reads, rather than general compiler barriers.)</p>",
        "id": 219921253,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219921000\">said</a>:</p>\n<blockquote>\n<p>Good point, I was thinking about writes</p>\n</blockquote>\n<p>Though it doesn't actually matter.  If at least one of the reads is non-volatile, then this must be regular memory not MMIO, <em>and</em> there can't be any concurrent writes to the same memory because that would be a UB data race.  So reordering the non-volatile and volatile read won't make an observable difference.</p>",
        "id": 219921255,
        "sender_full_name": "comex",
        "timestamp": 1607991110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> Earlier in the same conversation, I was observing that it should be possible to switch from non-volatile to volatile or vice versa, if you only do non-volatile operations when you know there can be no concurrent operations (e.g. a device is not active, the system has not brought up other CPUs, etc).</p>",
        "id": 219921370,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991193
    },
    {
        "content": "<p>That's part of the motivation for talking about \"volatile operations\" rather than \"volatile memory\" or \"volatile pointers\".</p>",
        "id": 219921384,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991212
    },
    {
        "content": "<p>I think you need a barrier of some kind in between (wrt to this reordering I'm talking about)</p>",
        "id": 219921467,
        "sender_full_name": "simulacrum",
        "timestamp": 1607991261
    },
    {
        "content": "<p>I'm hoping that <code>read_volatile</code> is such a barrier.</p>",
        "id": 219921517,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991295
    },
    {
        "content": "<p>By the way, even though I believe this is in some sense \"uninteresting\" because you should be using atomics instead, a very similar concept applies to mixed atomic and non-atomic accesses.</p>",
        "id": 219921533,
        "sender_full_name": "comex",
        "timestamp": 1607991303
    },
    {
        "content": "<p>so the analogue would be <code>volatile_fence()</code> then?</p>",
        "id": 219921562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991330
    },
    {
        "content": "<p>My point is that then it's not just a volatile operation - it's more than that</p>",
        "id": 219921568,
        "sender_full_name": "simulacrum",
        "timestamp": 1607991334
    },
    {
        "content": "<p>(that may be reasonable)</p>",
        "id": 219921585,
        "sender_full_name": "simulacrum",
        "timestamp": 1607991347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219921562\">said</a>:</p>\n<blockquote>\n<p>so the analogue would be <code>volatile_fence()</code> then?</p>\n</blockquote>\n<p>What is <code>volatile_fence</code>?</p>",
        "id": 219921586,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991348
    },
    {
        "content": "<p>(Trying not to make assumptions.)</p>",
        "id": 219921658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991379
    },
    {
        "content": "<p>In the atomics case, it's possible to mix non-atomic and atomic accesses with entirely safe code, since you can do a non-atomic access to e.g. an <code>AtomicI8</code> either by copying the entire <code>AtomicI8</code> object or by using <code>get_mut</code>.</p>",
        "id": 219921698,
        "sender_full_name": "comex",
        "timestamp": 1607991412
    },
    {
        "content": "<p>Not really sure, but I suppose it could play the role of starting/stopping a volatile region as I mentioned earlier, with the more local meaning of blocking reordering of a volatile read wrt a non-volatile read</p>",
        "id": 219921706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991422
    },
    {
        "content": "<p>In contrast, in C++, you're not really allowed to do that because <code>atomic&lt;char&gt;</code> and <code>char</code> are not guaranteed to have the same representation.</p>",
        "id": 219921769,
        "sender_full_name": "comex",
        "timestamp": 1607991473
    },
    {
        "content": "<p>Not that people don't do it anyway.</p>",
        "id": 219921777,
        "sender_full_name": "comex",
        "timestamp": 1607991480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> To confirm, by \"non-atomic\", you don't mean \"relaxed\"?</p>",
        "id": 219921833,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> Atomic types in Rust aren't copy so no, you can't copy the whole object - but get_mut you can.</p>",
        "id": 219921835,
        "sender_full_name": "simulacrum",
        "timestamp": 1607991498
    },
    {
        "content": "<p>You mean \"actually bypassing the use of atomic operations\"?</p>",
        "id": 219921846,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607991506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> oh, move then</p>",
        "id": 219921849,
        "sender_full_name": "comex",
        "timestamp": 1607991509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> yes, I mean bypassing.</p>",
        "id": 219921857,
        "sender_full_name": "comex",
        "timestamp": 1607991517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> In what case does reordering of a volatile read wrt a non-volatile read of the same address affect observable behavior, that is not already UB or disallowed for another reason?</p>",
        "id": 219921920,
        "sender_full_name": "comex",
        "timestamp": 1607991562
    },
    {
        "content": "<p>Right, but if you can move you have ownership h so it's not shared, and then no (non-relaxed?) atomic op would matter for the same thread when being reordered afaik, so as-if rule permits it in that case I think.</p>",
        "id": 219921950,
        "sender_full_name": "simulacrum",
        "timestamp": 1607991595
    },
    {
        "content": "<p>eh, I'm not good on atomic fences either. Just substitute the sort of operations you would use an atomic fence for</p>",
        "id": 219922029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991628
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Yeah, sorry if I'm being unclear, performing any non-atomic ops while other threads are accessing the same memory (whether atomically or not) is definitely an UB data race, unless all accesses are reads.</p>",
        "id": 219922108,
        "sender_full_name": "comex",
        "timestamp": 1607991694
    },
    {
        "content": "<p>wait so that's a soundness hole?</p>",
        "id": 219922282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991795
    },
    {
        "content": "<p>No, you can't do that in safe code.</p>",
        "id": 219922304,
        "sender_full_name": "comex",
        "timestamp": 1607991815
    },
    {
        "content": "<p>you can move an atomic in safe code</p>",
        "id": 219922322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991832
    },
    {
        "content": "<p>and you can be writing that same atomic from another thread</p>",
        "id": 219922375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991845
    },
    {
        "content": "<p>You can't, because if another thread has access then you wouldn't be allowed to move in safe code.</p>",
        "id": 219922388,
        "sender_full_name": "comex",
        "timestamp": 1607991860
    },
    {
        "content": "<p>But you can do those things at different times.  That's all I'm saying.</p>",
        "id": 219922408,
        "sender_full_name": "comex",
        "timestamp": 1607991874
    },
    {
        "content": "<p>aha</p>",
        "id": 219922427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607991891
    },
    {
        "content": "<p>Memory has to be able to transition between 'exclusive to one thread, allows non-atomic accesses' and 'shared, requires atomic accesses'.  And I think a similar concept should apply to volatile.</p>",
        "id": 219922488,
        "sender_full_name": "comex",
        "timestamp": 1607991935
    },
    {
        "content": "<p>So, it seems like we're narrowing in on the semantics of volatile accesses, and of the interaction between volatile and non-volatile accesses through the same pointer.</p>",
        "id": 219922649,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992044
    },
    {
        "content": "<blockquote>\n<p>so <code>p.read(); p.volatile_read();</code> ~&gt; <code>p.read(); p.volatile_read(); p.read();</code> then</p>\n</blockquote>\n<p>That's valid, as is reordering <code>p.read()</code> and <code>p.volatile_read()</code>, because volatile accesses are only guaranteed to be in-sequence relative to other volatile accesses, assuming rust follows the C++11 memory model.</p>",
        "id": 219922758,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Are you interpreting \"volatile\" as \"atomic\"?</p>",
        "id": 219922783,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992116
    },
    {
        "content": "<p>Nope. That's how volatile is defined.</p>",
        "id": 219922790,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992126
    },
    {
        "content": "<p>\"Accesses through volatile glvalues may not be reordered relative to any other access through a volatile glvalue\"</p>",
        "id": 219922825,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992153
    },
    {
        "content": "<p>Yeah I agree that this transfer exists without an obvious fence, though from a high level perspective it's \"lifetime of last shared reference ended\" or something along those lines. With volatile it seems harder, because you're probably just using volatile reads on raw pointers - no lifetimes involved</p>",
        "id": 219923024,
        "sender_full_name": "simulacrum",
        "timestamp": 1607992265
    },
    {
        "content": "<p>If we interpret read_volatile and write_volatile as being the same as a read or write through an lvalue of type <code>volatile T</code> and <code>const volatile T</code> respectively, the order of read_volatile and write_volatile operations is guaranteed.</p>",
        "id": 219923058,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992282
    },
    {
        "content": "<p>But surrounding reads from the same can be reordered, unless the volatile op is a write.</p>",
        "id": 219923085,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I think that's wrong, you cannot synthesize reads of raw pointers - you can reorder but not create</p>",
        "id": 219923148,
        "sender_full_name": "simulacrum",
        "timestamp": 1607992331
    },
    {
        "content": "<p>You cannot synthesize them no.</p>",
        "id": 219923170,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992347
    },
    {
        "content": "<p>But I was noting they can be reordered, even with an intervening volatile read.</p>",
        "id": 219923223,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992372
    },
    {
        "content": "<p>Reordering would be sufficient to cause havoc, if the sequence <code>p.read(); start_concurrency(); p.read_volatile()</code> can have the read reordered.</p>",
        "id": 219923225,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992375
    },
    {
        "content": "<p>Right, I agree with reordering being enough to cause problems</p>",
        "id": 219923253,
        "sender_full_name": "simulacrum",
        "timestamp": 1607992394
    },
    {
        "content": "<p><code>start_concurrency()</code> can prevent that by performing a fence operation.</p>",
        "id": 219923272,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992405
    },
    {
        "content": "<p>(In which case, the fence prevents the reordering)</p>",
        "id": 219923306,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992434
    },
    {
        "content": "<p>I know what a fence operation means in the context of GCC or clang. What kind of fence do you mean in the context of Rust <code>read_volatile</code>?</p>",
        "id": 219923373,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992458
    },
    {
        "content": "<p>compiler_fence presumably?</p>",
        "id": 219923455,
        "sender_full_name": "simulacrum",
        "timestamp": 1607992513
    },
    {
        "content": "<p>Either one, depending on hardware guarantees available.</p>",
        "id": 219923483,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992536
    },
    {
        "content": "<p>Oh, we <em>do</em> have <code>compiler_fence</code>.</p>",
        "id": 219923499,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992550
    },
    {
        "content": "<p>At least Release if the p.read_volatile being moved before it is ok, otherwise, AcqRel or SeqCst is needed.</p>",
        "id": 219923559,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992586
    },
    {
        "content": "<p>With all the discussion about trying to emulate a compiler barrier in various ways, I hadn't seen that we actually <em>have</em> one.</p>",
        "id": 219923566,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992590
    },
    {
        "content": "<p><code>core::sync::atomic::compiler_fence</code></p>",
        "id": 219923587,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992614
    },
    {
        "content": "<p>Yeah, found that when <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> mentioned it by name.</p>",
        "id": 219923605,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992627
    },
    {
        "content": "<p>(Aside: insert grumbling about C/C++ using \"acquire\" and \"release\" semantics rather than \"rmb\"/\"wmb\" semantics.)</p>",
        "id": 219923667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607992663
    },
    {
        "content": "<p>I thought it didn't work? I could be misremembering</p>",
        "id": 219923730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607992683
    },
    {
        "content": "<p>(It also has <code>core::sync::atomic::fence</code> which is at least as correct)</p>",
        "id": 219923735,
        "sender_full_name": "Connor Horman",
        "timestamp": 1607992685
    },
    {
        "content": "<p>So, given an underlying mechanism of <code>read_volatile</code>, <code>write_volatile</code>, and <code>compiler_fence</code>, I <em>think</em> it's possible to build a sound <code>Volatile&lt;T&gt;</code> (for word-sized-or-less, naturally-aligned types <code>T</code>, or alternatively <code>VolatileU32</code>/<code>VolatileU8</code>/<code>VolatileUsize</code>/etc).</p>",
        "id": 219924573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607993184
    },
    {
        "content": "<p>And, for that matter, a <code>VolatileMemory</code> abstraction for MMIO or shared memory.</p>",
        "id": 219924658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607993265
    },
    {
        "content": "<p>Assuming we need such an abstraction.</p>",
        "id": 219924768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607993322
    },
    {
        "content": "<p>(And assuming there's value in providing that abstraction rather than just relaxed atomics.)</p>",
        "id": 219924854,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607993384
    },
    {
        "content": "<p>All that said, it doesn't seem <em>unreasonable</em> to potentially have a built-in concept of volatile ordering relative to non-volatile ordering, but it's probably livable to do without that and build it in a higher-level abstraction.</p>",
        "id": 219925229,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607993649
    },
    {
        "content": "<p>(Aside: yes, there is a value to that distinction vs relaxed atomics, because atomic operations are not well-defined on MMIO at the _architectural_ level on at least ARMv7-M. Anyway, this thread is fascinating, do carry on.)</p>",
        "id": 219927153,
        "sender_full_name": "Cliff L. Biffle",
        "timestamp": 1607995432
    },
    {
        "content": "<blockquote>\n<p>others keep pushing for shipping something so we can get things into the hands of users.</p>\n</blockquote>\n<p>I am definitely in this camp <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> I added so many hacks to stabilize intra-doc links <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 219934807,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608003885
    },
    {
        "content": "<p>Given that int-ptr casts already mark the memory as globally accessible, what further optimizations  are prevented by not making them a no-op in the abstract machine?</p>",
        "id": 219938102,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1608008148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"371550\">Cliff L. Biffle</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219927153\">said</a>:</p>\n<blockquote>\n<p>(Aside: yes, there is a value to that distinction vs relaxed atomics, because atomic operations are not well-defined on MMIO at the _architectural_ level on at least ARMv7-M. Anyway, this thread is fascinating, do carry on.)</p>\n</blockquote>\n<p>Can you elaborate on that?</p>",
        "id": 219938164,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608008230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219889537\">said</a>:</p>\n<blockquote>\n<p>My reaction to the C example is that signed overflow being UB was a historical artifact of the standard allowing non-two's-complement representations, and now that C2x mandates the two's complement representation, the standard <em>should</em> define signed overflow as wrapping just as it does for unsigned overflow.</p>\n</blockquote>\n<p>sure, but the example is not really specific to overflow. you can replace it by out-of-bounds pointer arithmetic or any other number of things where C says \"this is immediate UB\" and LLVM instead says \"this produces <code>poison</code>\" -- the point is that sometimes a form of \"delayed UB\" is better for optimizations, and IRs have to carefully document what they do in each case. integer overflow is really just the simplest example to demonstrate this.</p>",
        "id": 219949170,
        "sender_full_name": "RalfJ",
        "timestamp": 1608021269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219892906\">said</a>:</p>\n<blockquote>\n<p>So, suppose you don't have provenance.  The first question is whether you allow guessing pointers \"out of thin air\".  Suppose you have</p>\n<div class=\"codehilite\"><pre><span></span><code>int a = 0;\n*(int *)0x1234 = 99;\nreturn a;\n</code></pre></div>\n<p>and the compiler happens to store <code>a</code> on the stack at address <code>0x1234</code>.  Is this program well-defined?</p>\n</blockquote>\n<p>Allocation is non-deterministic, and the C def.n of UB says it is enough for UB to be possible for it to \"taint\" all the possible branches. At least that is a common interpretation of the \"acausal / backwards-in-time\" nature of UB in C.<br>\nSee <a href=\"https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf\">https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf</a> for a formal argument based on this that prevents guessing out of thin air without relying on provenance. ;) These \"twin allocations\" are my contribution to that paper.</p>",
        "id": 219949383,
        "sender_full_name": "RalfJ",
        "timestamp": 1608021459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219897730\">said</a>:</p>\n<blockquote>\n<p>in particular, I think it is important that a provenance, if you want to call it that, can exist separately from the value, travel along different control flow and get recombined later<br>\nI'm pretty sure that this is impossible with LLVM style provenance</p>\n</blockquote>\n<p>I think it is very possible, we just need to add the right primitives for that.<br>\nThe tricky bit is making it so that you can actually compile these primitives to machine code though. ;)</p>",
        "id": 219949595,
        "sender_full_name": "RalfJ",
        "timestamp": 1608021613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219914245\">said</a>:</p>\n<blockquote>\n<p>That doesn't mean it's UB; it means I might get inconsistent results depending on optimizations and similar.</p>\n</blockquote>\n<p>So what is even the notion of a \"correct optimization\" now if optimizations may change program behavior? How can we tell correct optimizations from broken ones? How can programmers perform arguments showing that their code will execute as intended when compiled by any correct compiler?<br>\nI think my post demonstrates that saying \"here's a list of optimizations you may perform, go wild\" and calling that a spec is a very bad idea. Optimizations can \"work together\" to have very unexpected side-effects.</p>",
        "id": 219950006,
        "sender_full_name": "RalfJ",
        "timestamp": 1608021966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219916957\">said</a>:</p>\n<blockquote>\n<p>Volatile is critical in non-blocking concurrency (as well as the concurrency between drivers and hardware, and other such things). The advice I've seen is more \"volatile doesn't make your concurrency correct, it just allows you to carefully write correct code\".</p>\n</blockquote>\n<p>for drivers&lt;-&gt;hardware (or non-cash-coherent concurrency in general), okay; but for non-blocking concurrency I disagree. the C++11 memory model is all about letting people write non-blocking fine-grained concurrent algorithms, so volatile is certainly not required/critical for that. AFAIK it is only still used by old pre-C++11 code (and the Linux kernel but Linux isn't written in C, it's written in GCC-C with a very loosely specified memory model so it's hard to say anything definite about it).<br>\nEDIT: Ah looks like you included atomics in your notion of \"volatile\"... which is very confusing to me since the way I see it, the two serve very different purposes. atomics are about concurrency within the abstract machine; volatile are about memory-based interactions with the \"outside world\".</p>",
        "id": 219950241,
        "sender_full_name": "RalfJ",
        "timestamp": 1608022180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219919312\">said</a>:</p>\n<blockquote>\n<p>Because it was told not to.</p>\n</blockquote>\n<p>(about duplicating volatile loads in the abstract machine)<br>\nthe tricky bit is figuring out how to tell it. ;) being able to reorder loads in the abstract machine is an easily proven <em>theorem</em>, you can't just say \"I want that theorem not to be true\", you have to find a way to set up the definitions such that indeed it is not true. we don't just get to state our wishes and then they magically become true. ;) The C standard does this a lot (specifically also for volatiles as quoted above), and this is one reason for why it is so ambiguous despite being so extensive.<br>\n(specifically for volatile, I've seen various proposals for how to do this by making volatile accesses \"observable\" and thus the as-if rule says they may not be affected by optimizations, see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/33#issuecomment-429112051\">for example here</a>. but the problem arises in general with these abstract machine discussions -- I find it very hard to have constructive discussions unless someone makes a proposal for a concrete Abstract Machine definition, and then everyone can start analyzing its properties.)</p>",
        "id": 219950584,
        "sender_full_name": "RalfJ",
        "timestamp": 1608022446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219891110\">said</a>:</p>\n<blockquote>\n<p>Going back to the blog post: along the same lines, I find it unfortunate that the third possibility is dismissed so strongly.</p>\n</blockquote>\n<p>the third possibility means giving up all reference-based alias analysis in Rust. it means giving up <code>restrict</code> in C. it means allowing both <code>offset</code> and <code>wrapping_offset</code> to cross object boundaries. basically it means that expect in very controlled circumstances, we have no chance of making any statement about the aliasing of any pointer. (<span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> says they have some ideas for how to avoid this inherent trade-off; I am excited at the thought of that and will remain skeptical until I see a more concrete proposal. ;)<br>\nAs far as I am concerned, the industry has dismissed this option decades ago. I see very little chance that LLVM, GCC, ICC, MSVC are going to make up their mind about this and stop doing optimizations that inherently rely on provenance. I assume cranelift also relies on provenance but don't know enough about it to be sure.</p>",
        "id": 219951716,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023398
    },
    {
        "content": "<p>So I wonder what is the goal of these discussions then. Is it to propose that Rust should adopt a no-provenance model of whatever kind (maybe along the lines of what <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> has in mind), and write a new compiler backend from scratch that implements this model? Or is the entire discussion here just musing about \"what could have been\" but we all agree, for better or worse, that we live in a world where provenance is a thing, there's no point denying that and we have to find a way to live with it?</p>",
        "id": 219951826,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023478
    },
    {
        "content": "<p>Cranelift doesn't have provenance at the moment. Memory operations are essentially considered volatile currently. The only exception is when you specify memflags like aligned, notrap (loading/storing will not cause a signal) or readonly (loaded value is constant within the current function): <a href=\"https://docs.rs/cranelift-codegen/0.66.0/cranelift_codegen/ir/struct.MemFlags.html\">https://docs.rs/cranelift-codegen/0.66.0/cranelift_codegen/ir/struct.MemFlags.html</a></p>",
        "id": 219951920,
        "sender_full_name": "bjorn3",
        "timestamp": 1608023546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219951920\">said</a>:</p>\n<blockquote>\n<p>Cranelift doesn't have provenance at the moment. Memory operations are essentially considered volatile currently. The only exception is when you specify memflags like aligned, notrap (loading/storing will not cause a signal) or readonly (loaded value is constant within the current function): <a href=\"https://docs.rs/cranelift-codegen/0.66.0/cranelift_codegen/ir/struct.MemFlags.html\">https://docs.rs/cranelift-codegen/0.66.0/cranelift_codegen/ir/struct.MemFlags.html</a></p>\n</blockquote>\n<p>volatile is no no way contradicting with provenance</p>",
        "id": 219951941,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023563
    },
    {
        "content": "<p>I mean that in Cranelift memory operations will never be touched except for when memflags are used.</p>",
        "id": 219952008,
        "sender_full_name": "bjorn3",
        "timestamp": 1608023615
    },
    {
        "content": "<p>Cranelift barely has any UB at the moment.</p>",
        "id": 219952056,
        "sender_full_name": "bjorn3",
        "timestamp": 1608023643
    },
    {
        "content": "<p>does craneleft have any rule like \"memory accesses must be in-bounds of the allocation the pointer was originally created for\" or \"pointer arithmetic must not cross allocation boundaries\"?</p>",
        "id": 219952069,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023644
    },
    {
        "content": "<p>No, the only optimizations on memory optimizations it currently does are DCE, GVN and LICM.</p>",
        "id": 219952111,
        "sender_full_name": "bjorn3",
        "timestamp": 1608023683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Will respond further when it isn't 1am. But I did want to express appreciation for your first point: regardless of the specific bit of C UB used to make the point, the explanation for how LLVM uses poison is the first time I've seen value in it. Thank you for that clear explanation.</p>",
        "id": 219952171,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608023729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span>  LICM?</p>",
        "id": 219952208,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023758
    },
    {
        "content": "<p>loop invariant code motion</p>",
        "id": 219952256,
        "sender_full_name": "bjorn3",
        "timestamp": 1608023767
    },
    {
        "content": "<p>ah</p>",
        "id": 219952271,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023775
    },
    {
        "content": "<p>and I guess memory accesses are not being considered loop invariant ever (except maybe for readonly accessible ones)?</p>",
        "id": 219952290,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023789
    },
    {
        "content": "<p>Also, I don't believe we'd have to give up on alias analysis completely. It would just require the compiler to prove more things rather than assuming them.</p>",
        "id": 219952310,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608023806
    },
    {
        "content": "<p>(Plus, it's worth noting that we don't currently <em>have</em> LLVM noalias because bugs, so doing without it is certainly possible...)</p>",
        "id": 219952376,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608023863
    },
    {
        "content": "<p>The basic problem with having the compiler prove things is that it has to know things first</p>",
        "id": 219952381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608023867
    },
    {
        "content": "<p>and it has to get that knowledge from somewhere</p>",
        "id": 219952398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608023879
    },
    {
        "content": "<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/fc4eeae8961c56d2307e4f9ed895f06d3ff43887/cranelift/codegen/src/licm.rs#L139-L158\">https://github.com/bytecodealliance/wasmtime/blob/fc4eeae8961c56d2307e4f9ed895f06d3ff43887/cranelift/codegen/src/licm.rs#L139-L158</a></p>\n<p>it requires notrap and readonly on loads</p>",
        "id": 219952404,
        "sender_full_name": "bjorn3",
        "timestamp": 1608023882
    },
    {
        "content": "<p>The usual mechanism for conveying information to the compiler that it can use in proofs is through operations with UB</p>",
        "id": 219952476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608023914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I'm not suggesting it can't know things, I'm just suggesting reducing what it's worth to assume without proof.</p>",
        "id": 219952477,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608023914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219952310\">said</a>:</p>\n<blockquote>\n<p>Also, I don't believe we'd have to give up on alias analysis completely. It would just require the compiler to prove more things rather than assuming them.</p>\n</blockquote>\n<p>those are the 'controlled circumstances' I talked about. but in what I think are the vast majority of cases, there's no way for the compiler to perform these proofs. this includes in particular everything enabled by Stacked Borrows, and likewise <code>restrict</code>, where the pointers are passed in as arguments and so there's no way to prove anything about them (and indeed there are counterexamples to the optimizations, so only a buggy compiler could ever produce a 'proof').</p>",
        "id": 219952488,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023920
    },
    {
        "content": "<p>So, with restrict, the compiler is being <em>told</em> that it can make an assumption, so it's fine for it to do so.</p>",
        "id": 219952559,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608023970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219952559\">said</a>:</p>\n<blockquote>\n<p>So, with restrict, the compiler is being <em>told</em> that it can make an assumption, so it's fine for it to do so.</p>\n</blockquote>\n<p>to formalize restrict you need to add provenance</p>",
        "id": 219952579,
        "sender_full_name": "RalfJ",
        "timestamp": 1608023985
    },
    {
        "content": "<p><code>restrict</code> introduces a situation similar to the \"one-past-the-end\" that I used in the blog post, where two pointers can point to the same thing but may not be used interchangeably. IOW, there's something that distinguishes these pointers but it's not the address they point to.</p>",
        "id": 219952671,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219952111\">said</a>:</p>\n<blockquote>\n<p>No, the only optimizations on memory optimizations it currently does are DCE, GVN and LICM.</p>\n</blockquote>\n<p>as my blog post shows, GVN is already tricky. LLVM is performing GVN on pointers, including taking <code>if (p == q)</code> as introducing an equivalence that GVN may exploit, and that's wrong in the presence of provenance.<br>\nbut GVN can only enforce the absence of provenance, not its presence, so... yeah maybe cranelift currently truly does not have provenance. that'll be an interesting datapoint!</p>",
        "id": 219952789,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024108
    },
    {
        "content": "<p>Cranelift doesn't even know about the concept of pointers. <code>load</code> and <code>store</code> just accept an pointer sized integer.</p>",
        "id": 219952900,
        "sender_full_name": "bjorn3",
        "timestamp": 1608024160
    },
    {
        "content": "<p>well sure but that could just as well be caused by its designers ignoring provenance issues, as happened in LLVM and GCC ;)</p>",
        "id": 219952948,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024192
    },
    {
        "content": "<p>but this means that right now adding any provenance-based optimizations to cranelift would be wrong and could introduce miscompilations</p>",
        "id": 219952992,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024217
    },
    {
        "content": "<p>(assuming its GVN exploits <code>if (i == j)</code>)</p>",
        "id": 219953018,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024231
    },
    {
        "content": "<p>WASM doesn't have UB or provenance, so Cranelift itself must not either. Any optimizations that require provenance would have to be layered on top of Cranelift.</p>",
        "id": 219953109,
        "sender_full_name": "bjorn3",
        "timestamp": 1608024267
    },
    {
        "content": "<p>For the specific case of off-the-end pointers, one optimization I notice you didn't mention: what about the compiler noticing that the values being compared come from different allocations, so it can optimize away the conditional entirely by assuming the condition is false?</p>",
        "id": 219953133,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024279
    },
    {
        "content": "<p>(even if by a value representation they might be equal)</p>",
        "id": 219953214,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> a different way to put this is to say that the provenance example in the blog post is <em>also</em> about the compiler being <em>told</em> that it can make the non-aliasing assumption. the assumption is just expressed somewhat clumsily by writing <code>p+1</code> vs <code>q</code> -- by using two different \"base pointers\" one implicitly says \"treat these as <code>restrict</code>\"</p>",
        "id": 219953216,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024327
    },
    {
        "content": "<p>making <code>restrict</code> more explicit changes nothing about the fundamental nature of provenance</p>",
        "id": 219953265,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024353
    },
    {
        "content": "<p>It would mean that a frontend can chose to not use provenance though and thus miss on certain optimizations.</p>",
        "id": 219953393,
        "sender_full_name": "bjorn3",
        "timestamp": 1608024402
    },
    {
        "content": "<p>Are you presenting that as a fundamental property of restrict, or just that compilers typically express restrict through provenance?</p>",
        "id": 219953394,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219953133\">said</a>:</p>\n<blockquote>\n<p>For the specific case of off-the-end pointers, one optimization I notice you didn't mention: what about the compiler noticing that the values being compared come from different allocations, so it can optimize away the conditional entirely by assuming the condition is false?</p>\n</blockquote>\n<p>In C that would be incorrect; C says when comparing pointers, their underlying address must be compared.</p>",
        "id": 219953408,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024411
    },
    {
        "content": "<p>C++ says the result is \"indeterminate\"</p>",
        "id": 219953456,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024443
    },
    {
        "content": "<p>Sure. Does Rust say that, though? If we're going to have provenance or something like it, that seems like a natural optimization.</p>",
        "id": 219953496,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219953394\">said</a>:</p>\n<blockquote>\n<p>Are you presenting that as a fundamental property of restrict, or just that compilers typically express restrict through provenance?</p>\n</blockquote>\n<p>I am not saying anything about compilers. Compilers dont explicitly represent anything through provenance, it is only present implicitly.<br>\nMy claim is that specifying an Abstract Machine with <code>restrict</code> will necessarily involve adding provenance to that abstract machine.</p>",
        "id": 219953600,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219953496\">said</a>:</p>\n<blockquote>\n<p>Sure. Does Rust say that, though? If we're going to have provenance or something like it, that seems like a natural optimization.</p>\n</blockquote>\n<p>Rust doesn't say anything but raw ptr comparison is safe. so I think we should make it as well-behaved as possible. In particular, if C++ \"indeterminate\" means <code>undef</code> (which is not clear), then this is not an option for Rust as <code>undef</code> must not be passed to safe code.</p>",
        "id": 219953696,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024560
    },
    {
        "content": "<p>That does not seem at all inherent to me. Couldn't you just have some optimizations you can apply to restrict and not to non-restrict?</p>",
        "id": 219953708,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024571
    },
    {
        "content": "<p>so sure Rust could say \"when comparing two ptrs, if their address is the same but their provenance differs, the result is non-detrministically <code>true</code> or <code>false</code>\". but that will solve none of our problems here.</p>",
        "id": 219953766,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024600
    },
    {
        "content": "<p>That wasn't what I suggested.</p>",
        "id": 219953850,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219953708\">said</a>:</p>\n<blockquote>\n<p>That does not seem at all inherent to me. Couldn't you just have some optimizations you can apply to restrict and not to non-restrict?</p>\n</blockquote>\n<p>sure, but you need to argue for why the optimizations are correct, i.e., are following the as-if rule. that requires defining the abstract machine in a way that the optimizations do not change program behavior. that requires (I claim) making a difference between two pointers that point to the same address. that is provenance.</p>",
        "id": 219953886,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219953850\">said</a>:</p>\n<blockquote>\n<p>That wasn't what I suggested.</p>\n</blockquote>\n<p>then I am not sure what you suggested :)</p>",
        "id": 219953894,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024647
    },
    {
        "content": "<p>And I feel like what I suggested is meaningfully different. I was suggesting that if you have provenance, a comparison of two pointers with different provenance could unconditionally optimize to false.</p>",
        "id": 219953994,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024709
    },
    {
        "content": "<p>I feel we keep talking past each other</p>",
        "id": 219954049,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024726
    },
    {
        "content": "<p>optimizations are not fundmental, the abstract machine is</p>",
        "id": 219954066,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024737
    },
    {
        "content": "<p>each abstract machine definition has consequences for which oprimizations you may perform</p>",
        "id": 219954087,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024749
    },
    {
        "content": "<p>the ptr equality def.n I proposed above (non-det choice) indeed allows the optimization you propose (compiler replace comparison by false)</p>",
        "id": 219954112,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024768
    },
    {
        "content": "<p>that's the nature of non-determinism: the compiler may make a choice for you</p>",
        "id": 219954145,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024786
    },
    {
        "content": "<p>but this also means that if you perform the same equality test many times, you may get different results</p>",
        "id": 219954193,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024812
    },
    {
        "content": "<p>Which is an excellent reason I prefer to avoid non-determinism, when it's possible to give a deterministic answer.</p>",
        "id": 219954213,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024821
    },
    {
        "content": "<p>and indeed that is unavoidable unless you want to say that the compiler <em>must</em> always perform this optimization</p>",
        "id": 219954226,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219953109\">said</a>:</p>\n<blockquote>\n<p>WASM doesn't have UB or provenance, so Cranelift itself must not either. Any optimizations that require provenance would have to be layered on top of Cranelift.</p>\n</blockquote>\n<p>You can say the same thing about most ISAs though. The UB and provenance is all at the compiler IR level, not in the target architecture</p>",
        "id": 219954303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608024853
    },
    {
        "content": "<p>so your statement \"the compiler should be allowed to perform this optimization\" <em>implies</em> non-determinism, I would say</p>",
        "id": 219954306,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024854
    },
    {
        "content": "<p>I definitely feel we we're talking past each other, then, because I wasn't suggesting it would be optional, no.</p>",
        "id": 219954407,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608024920
    },
    {
        "content": "<p>we can of course also define the abstract machine to deterministically say \"if provenance is different, comparison returns false\". I mention this option in my blog post. it is impossible to compile this definiton to assembly since we do not have provenance information at runtime.</p>",
        "id": 219954414,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024925
    },
    {
        "content": "<p>this definition demands that every time two pointers are compared, the compiler must somehow figure out if their provenance is equal. that's impossible.</p>",
        "id": 219954472,
        "sender_full_name": "RalfJ",
        "timestamp": 1608024962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219954407\">said</a>:</p>\n<blockquote>\n<p>I definitely feel we we're talking past each other, then, because I wasn't suggesting it would be optional, no.</p>\n</blockquote>\n<p>If it isn't optional, then codegen backends <strong>must</strong> use provenance, which makes cg_clif an incorrect implementation of the rust spec.</p>",
        "id": 219954518,
        "sender_full_name": "bjorn3",
        "timestamp": 1608024978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219954518\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219954407\">said</a>:</p>\n<blockquote>\n<p>I definitely feel we we're talking past each other, then, because I wasn't suggesting it would be optional, no.</p>\n</blockquote>\n<p>If it isn't optional, then codegen backends <strong>must</strong> use provenance, which makes cg_clif an incorrect implementation of the rust spec.</p>\n</blockquote>\n<p>it also makes LLVM an incorrect implementation since it doesnt have a way to take into account provenance at runtime.</p>",
        "id": 219954557,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think there must be something <em>really</em> fundamental that I'm missing, because at no point did I bring up runtime. At compile time, you do have provenance.</p>",
        "id": 219954616,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219954616\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I think there must be something <em>really</em> fundamental that I'm missing, because at no point did I bring up runtime. At compile time, you do have provenance.</p>\n</blockquote>\n<p>so let me try an example... let's say we move the <code>==</code> into a separate function, i.e., we peform outlining</p>",
        "id": 219954739,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025083
    },
    {
        "content": "<p>What am I missing here?</p>",
        "id": 219954748,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025086
    },
    {
        "content": "<p>now how do you compile that function? it might be called with pointers that differ only in their provenance.</p>",
        "id": 219954778,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025102
    },
    {
        "content": "<p>Doesn't the abstract machine have a notion of pointer provenance?</p>",
        "id": 219954824,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025139
    },
    {
        "content": "<p>yes</p>",
        "id": 219954842,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025146
    },
    {
        "content": "<p>on the abstract machine this is all fine</p>",
        "id": 219954856,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025153
    },
    {
        "content": "<p>Does that notion not get passed with the pointer?</p>",
        "id": 219954865,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025158
    },
    {
        "content": "<p>I asked about how you compile it to assembly</p>",
        "id": 219954887,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025171
    },
    {
        "content": "<p>everything is fine if you only consider the absract machine and never want to run this code on a CPU</p>",
        "id": 219954908,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025189
    },
    {
        "content": "<p>The fact that that seems incredibly obvious (and the fact that normally I would expect our positions about real CPUs vs abstract machines to be reversed from this) suggests that I'm missing something critical here.</p>",
        "id": 219955051,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219955051\">said</a>:</p>\n<blockquote>\n<p>The fact that that seems incredibly obvious (and the fact that normally I would expect our positions about real CPUs vs abstract machines to be reversed from this) suggests that I'm missing something critical here.</p>\n</blockquote>\n<p>yeah that's my thinking, too^^</p>",
        "id": 219955089,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025266
    },
    {
        "content": "<p>maybe you should get some sleep, I dont want to keep you awake ;)</p>",
        "id": 219955102,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025274
    },
    {
        "content": "<p>I am happy to arrange a call if you want to have a higher-bandwidth discussion about this, with you or the entire lang team or whoever</p>",
        "id": 219955130,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025293
    },
    {
        "content": "<p>Provenance is a piece of ghost state associated with a pointer. It isn't something statically attached to each pointer.</p>",
        "id": 219955155,
        "sender_full_name": "bjorn3",
        "timestamp": 1608025311
    },
    {
        "content": "<p>If the abstract machine has a concept of provenance attached to the pointers, compare the provenance, if not equal constant fold to \"false\".</p>",
        "id": 219955167,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025317
    },
    {
        "content": "<p>(ghost state is state that exists only in an abstract machine but is omitted on a real system)</p>",
        "id": 219955241,
        "sender_full_name": "bjorn3",
        "timestamp": 1608025341
    },
    {
        "content": "<p>The provenance isn't necessarily constant</p>",
        "id": 219955254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608025349
    },
    {
        "content": "<p>(in the abstract machine, provenance is as real as any other state)</p>",
        "id": 219955264,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025354
    },
    {
        "content": "<p>the thing is, there's another constraint attached with the abstract machine: we want to be able to compile it to assembly. then we need to prove that every time the assembly program does something, the abstract machine could have done the same thing.</p>",
        "id": 219955315,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025386
    },
    {
        "content": "<p>but in assembly, <em>there is no provenance</em></p>",
        "id": 219955336,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025400
    },
    {
        "content": "<p>this state is erased</p>",
        "id": 219955368,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025423
    },
    {
        "content": "<p>it's like adding an <code>is_init</code> operation to the abstract machine. this is easy to define in the abstract machine because it always knows explicitly which memory has already been initialized</p>",
        "id": 219955441,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025454
    },
    {
        "content": "<p>I expect that state to be erased, much as I would then expect the conditional body to disappear and not be represented in the machine code.</p>",
        "id": 219955458,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025464
    },
    {
        "content": "<blockquote>\n<p>compare the provenance, if not equal constant fold to \"false\".</p>\n</blockquote>\n<p>This implies that the provenance is known at compile time, and it's not (necessarily). It is a \"run time\" thing, even though it is ghost state. It is in the run time of the RAM</p>",
        "id": 219955461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608025466
    },
    {
        "content": "<p>but it is impossible to test if memory was initialized after the program was compiled to assembly</p>",
        "id": 219955475,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025475
    },
    {
        "content": "<p>so <code>is_init</code> can be added to the abstract machine just fine, but it makes it impossible to compile this abstract machine to real code <em>unless we want to add enough instrumentation to the code so that we can test for initializedness at runtime</em></p>",
        "id": 219955532,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> does the <code>is_init</code> example make sense?</p>",
        "id": 219955546,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025533
    },
    {
        "content": "<p>I feel like you're using the term \"runtime\" in a non-standard way.</p>",
        "id": 219955579,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025553
    },
    {
        "content": "<p>I dont think I am</p>",
        "id": 219955636,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025566
    },
    {
        "content": "<p>I am literally thinking of the time the program (turned into a bunch of machine code) is being run</p>",
        "id": 219955649,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025576
    },
    {
        "content": "<p>there's also the \"abstract machine runtime\", whuch you can think of as \"during the execution in Miri\", and there <code>is_init</code> is easy to test, but if I used that notion I do agree it would be non-standard ;)</p>",
        "id": 219955716,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025614
    },
    {
        "content": "<p>How would you compile the following?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">equal</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It is unknown if the provenance of <code>a</code> and <code>b</code> are the same when compiling this and the provenance also isn't passed as real integers or something like that, yet you want it to return false when the provenance is not equal. There is simply no way to do this.</p>",
        "id": 219955764,
        "sender_full_name": "bjorn3",
        "timestamp": 1608025642
    },
    {
        "content": "<p>At runtime, we have whatever machine code we generated. If that generated code doesn't care about some state, that state isn't needed at runtime.</p>",
        "id": 219955775,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219955775\">said</a>:</p>\n<blockquote>\n<p>At runtime, we have whatever machine code we generated. If that generated code doesn't care about some state, that state isn't needed at runtime.</p>\n</blockquote>\n<p>but you defined it to care about that state by saying that ptr comparison acts on provenance</p>",
        "id": 219955810,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> OK, <em>now</em> I get what you're getting at, and I think I understand why it felt like talking past one another.</p>",
        "id": 219955904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025714
    },
    {
        "content": "<p>I think it'd be worth going through the <code>is_init</code> example first since I think uninit memory is easier than provenance</p>",
        "id": 219955908,
        "sender_full_name": "RalfJ",
        "timestamp": 1608025716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> You said we would need some notion of provenance at runtime, which didn't make sense to me. I think that may be because you were reasoning in the opposite direction. I went the other way and assumed that this optimization would mean we'd have to be able to make a proof about the equality of the provenance at compile time, and I was trying to reason from there and see where that led rather than assuming that was impossible.</p>",
        "id": 219956155,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608025862
    },
    {
        "content": "<p>(I'm not assuming it was possible, either, but I was trying to explore that possibility.)</p>",
        "id": 219956430,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219956155\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> You said we would need some notion of provenance at runtime, which didn't make sense to me. I think that may be because you were reasoning in the opposite direction. I went the other way and assumed that this optimization would mean we'd have to be able to make a proof about the equality of the provenance at compile time, and I was trying to reason from there and see where that led rather than assuming that was impossible.</p>\n</blockquote>\n<p>ah, I see.<br>\nI think I have pretty strong intuition that compiler proofs can never be used to <em>guarantee</em> anything. halting problem etc all say this will not work. so the moment you said that provenance <em>determines</em> some runtime observable outcome, I immediately jumped to \"well then provenance must exist at runtime as well\".<br>\nI am clearly too much around people that have these discussions too often. ;)</p>",
        "id": 219956602,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026128
    },
    {
        "content": "<p>It's not at all unreasonable that you did so, it just felt like you skipped a step, from the perspective of someone who understands formal methods and program proofs in the abstract but doesn't work with them personally very often.</p>",
        "id": 219956776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026220
    },
    {
        "content": "<p>hence my suggestion for a higher-bandwidth channel ;) that can help clear up such things much more quickly I think</p>",
        "id": 219956855,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026272
    },
    {
        "content": "<p>I've definitely used the halting problem to do such reasoning, but it isn't immediately clear that that would rule out compile-time pointer provenance.</p>",
        "id": 219956918,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026292
    },
    {
        "content": "<p>Yeah, a high-bandwidth conversation might help in a lot of ways, not least of which getting a feel for what feels like a fundamental difference in how we think about the constraints placed on compilers vs the constraints put on code.</p>",
        "id": 219957028,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026375
    },
    {
        "content": "<p>actually its probably not even a decidability thing but first and foremost a modularity / separate compilation thing. then it becomes inforamtion-theoretical.</p>",
        "id": 219957029,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026377
    },
    {
        "content": "<p>i.e., if you take bjorn's example (which I sketched in words before when I mentioned \"outlining\" but I should have used code), and make that a separate translation unit, then <em>the information simply isn't there</em>, even if you could solve the halting problem.</p>",
        "id": 219957109,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026411
    },
    {
        "content": "<p><em>That</em> is a very different argument, and yeah, things get less fun when you can't assume all code is in one giant LTO reasoning set. :)</p>",
        "id": 219957125,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026427
    },
    {
        "content": "<p>now in a discussion with theorists we might say \"okay we do whole-program compilation only [aka one giant LTO], what about then\", and then we'd probably end up with the halting problem, but I doubt I even need to go so far here ;)</p>",
        "id": 219957164,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026447
    },
    {
        "content": "<p>Thinking about it, I do agree that you're right, the deterministic optimization I was imagining would require the compiler to determine arbitrary program behavior at compile time, so that definitely doesn't work.</p>",
        "id": 219957359,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026562
    },
    {
        "content": "<p>(At least, in the absence of something like CHERI.)</p>",
        "id": 219957615,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219957615\">said</a>:</p>\n<blockquote>\n<p>(At least, in the absence of something like CHERI.)</p>\n</blockquote>\n<p>(which is basically having [some form of] provenance at runtime)</p>",
        "id": 219957921,
        "sender_full_name": "RalfJ",
        "timestamp": 1608026895
    },
    {
        "content": "<p>(<em>nod</em>)</p>",
        "id": 219957952,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026922
    },
    {
        "content": "<p>Definitely going to bed now. :)</p>",
        "id": 219957984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026946
    },
    {
        "content": "<p>And thanks again for taking the time to explain concepts more clearly, here and on your blog.</p>",
        "id": 219958024,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608026973
    },
    {
        "content": "<p>sure, thanks for taking these ideas seriously and attempting to reconcile them with your existing mental model :)</p>",
        "id": 219960020,
        "sender_full_name": "RalfJ",
        "timestamp": 1608028257
    },
    {
        "content": "<p>(Reading through the IRLO, Reddit and HN discussions)<br>\nAt this point I have seen people saying \"for me it is clear that X is the wrong optimization\" for all <code>X  {1,2,3}</code>. It's very amusing to see how people's intuitions contradict each other. This is also exactly what I hoped for: to put into plain sight this lingering contradiction that many weren't really aware of, and to get people to think more deeply about these thorny details of IR semantics. My plan worked out perfectly. :)</p>",
        "id": 219970872,
        "sender_full_name": "RalfJ",
        "timestamp": 1608035213
    },
    {
        "content": "<p>Oh even better, I can see <em>the same person</em> jumping from one value of <code>X</code> to another as their intuition adjusts to new input</p>",
        "id": 219971469,
        "sender_full_name": "RalfJ",
        "timestamp": 1608035588
    },
    {
        "content": "<p>I need to send this to Gil (Chung-Kil Hur), who came up with these examples... that was 2 years ago or more when I first saw them, and I went through the exact same process that I now see everyone else go through. The credit for this great sequence of exampls entirely goes to him. I hope I made that clear enough in the post.</p>",
        "id": 219971654,
        "sender_full_name": "RalfJ",
        "timestamp": 1608035678
    },
    {
        "content": "<blockquote>\n<p>non-cache-coherent concurrency</p>\n</blockquote>\n<p>what does it mean for concurrency not to be cache-coherent?</p>",
        "id": 219979083,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039337
    },
    {
        "content": "<p>I had a question about the example in the blog but answered it myself - the reason the code is valid is because it modifies through <code>iq</code>, not through <code>ip</code>, and <code>iq</code> is valid for reads and writes</p>",
        "id": 219979493,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039543
    },
    {
        "content": "<blockquote>\n<p>The first optimization we will perform is to exploit that if we enter the if body, we have iq == ip, so we can replace all iq by ip. Subsequently the definition of ip is inlined:</p>\n</blockquote>\n<p>my intuition is telling me this is the wrong optimization, because iq and ip have different provenance: <code>iq</code> is valid for writes but <code>ip</code> is not because it's one-past-the-bounds</p>",
        "id": 219979751,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039688
    },
    {
        "content": "<p>Because of the ptr2int casts, provenance is lost, so both <code>ip</code> and <code>iq</code> are valid for the writes.</p>",
        "id": 219979890,
        "sender_full_name": "bjorn3",
        "timestamp": 1608039749
    },
    {
        "content": "<p>this happens <em>before</em> the ptr2int cast</p>",
        "id": 219979915,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039762
    },
    {
        "content": "<p>or hmm it appears to happen simultaneously?</p>",
        "id": 219979965,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039792
    },
    {
        "content": "<p>The program starts with <code>uintptr_t ip = (uintptr_t)(p+1);</code> and <code>uintptr_t iq = (uintptr_t)q;</code> which are ptr2int casts.</p>",
        "id": 219979986,
        "sender_full_name": "bjorn3",
        "timestamp": 1608039805
    },
    {
        "content": "<p>ahhh ok thanks</p>",
        "id": 219980021,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039824
    },
    {
        "content": "<p>then yes I agree with <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> it's unclear which of the optimizations is the bug</p>",
        "id": 219980175,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1608039881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/219889537\">said</a>:</p>\n<blockquote>\n<p>My reaction to the C example is that signed overflow being UB was a historical artifact of the standard allowing non-two's-complement representations, and now that C2x mandates the two's complement representation, the standard <em>should</em> define signed overflow as wrapping just as it does for unsigned overflow.</p>\n</blockquote>\n<p>The reason they won't do this is to preserve the optimization turning <code>for (int i = 0; i &lt; N; ++i)</code> into <code>for (ssize_t i = 0; i &lt; N; ++i)</code> and such  replacing <code>int</code> with a register-width variable. Apparently this optimization applied globally is at least a 5% speedup. Rust gets a lot by (more-or-less) forcing <code>usize</code> as the index variable.</p>",
        "id": 220039887,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1608065150
    },
    {
        "content": "<p>Do you know why they don't just make <code>int</code> 8 bytes?</p>",
        "id": 220040286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608065330
    },
    {
        "content": "<p>Breaks code that assumes it is 4 bytes.</p>",
        "id": 220040393,
        "sender_full_name": "bjorn3",
        "timestamp": 1608065386
    },
    {
        "content": "<p>well, they probably don't want to \"just\" break the C ABI</p>",
        "id": 220040396,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1608065387
    },
    {
        "content": "<p>even though this was the whole point of making these integral types not commit to a length -_-</p>",
        "id": 220040540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608065437
    },
    {
        "content": "<p>The standard does not define a length for int. The System V ABI, etc does.</p>",
        "id": 220040595,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1608065469
    },
    {
        "content": "<p>well that just pushes the question: why doesn't the x86-64 abi use 8 byte int? I'm pretty sure this exists in one of the variants</p>",
        "id": 220040776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608065549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/220040776\">said</a>:</p>\n<blockquote>\n<p>well that just pushes the question: why doesn't the x86-64 abi use 8 byte int? I'm pretty sure this exists in one of the variants</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20provenance.20is.20real/near/220040393\">said</a>:</p>\n<blockquote>\n<p>Breaks code that assumes it is 4 bytes.</p>\n</blockquote>\n<p>this</p>",
        "id": 220040832,
        "sender_full_name": "bjorn3",
        "timestamp": 1608065579
    },
    {
        "content": "<p>so it's not necessarily 4 bytes but it can't be anything else</p>",
        "id": 220041031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608065687
    },
    {
        "content": "<p>what a lovely state of affairs</p>",
        "id": 220041047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608065697
    }
]