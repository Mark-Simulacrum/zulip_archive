[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T/near/276124266\">said</a>:</p>\n<blockquote>\n<p>For MMIO purposes, the assertion that no one else claims that same memory is far too strong. Particularly, any code should, at any time, be able to simply know the address of some particular MMIO thing (as a constant or whatever) and then use it without regard to who else might also use that same MMIO location before or after.</p>\n</blockquote>\n<p>I dislike that for both Rust and objcap reasons, but &lt;sub&gt;these margins are too small to &lt;sub&gt;advocate for objcap&lt;/sub&gt;&lt;/sub&gt;</p>",
        "id": 276125504,
        "sender_full_name": "eddyb",
        "timestamp": 1647904214
    },
    {
        "content": "<p>oh Zulip thou hast failed me</p>",
        "id": 276125517,
        "sender_full_name": "eddyb",
        "timestamp": 1647904226
    },
    {
        "content": "<p>I don't even know what \"objcap\" is</p>",
        "id": 276125578,
        "sender_full_name": "Lokathor",
        "timestamp": 1647904309
    },
    {
        "content": "<p>there, is that enough of an excuse for you to give your spiel?</p>",
        "id": 276125651,
        "sender_full_name": "Lokathor",
        "timestamp": 1647904334
    },
    {
        "content": "<p>not really, since I don't have a spiel. objcap is, roughly speaking, the idea of hermetically isolating (cap)abilities and always requiring derivation, i.e. everything is obtained from something else. windows <code>HANDLE</code> and UNIX fds are sort of the \"bare minimum\", but the presence of \"ambient\" APIs limits their approach to full objcap</p>",
        "id": 276126025,
        "sender_full_name": "eddyb",
        "timestamp": 1647904574
    },
    {
        "content": "<p>microkernels are much closer, and seL4 is the \"golden standard\" in this space</p>",
        "id": 276126050,
        "sender_full_name": "eddyb",
        "timestamp": 1647904592
    },
    {
        "content": "<p>yeah MMIO is basically an entire ambient universe of things you can do out of \"nothing\" :P</p>",
        "id": 276126100,
        "sender_full_name": "Lokathor",
        "timestamp": 1647904647
    },
    {
        "content": "<p>right, so that violates objcap principles. on seL4, a driver (which runs in userspace, mind you) has to get a MMIO block the same way you might, say, <code>mmap</code> a file</p>",
        "id": 276126207,
        "sender_full_name": "eddyb",
        "timestamp": 1647904720
    },
    {
        "content": "<p>it's a \"chain of custody\", just like Rust does with deriving <code>&amp;mut</code> from <code>&amp;mut</code></p>",
        "id": 276126238,
        "sender_full_name": "eddyb",
        "timestamp": 1647904751
    },
    {
        "content": "<p>objcap applied to hardware resources is very much like <code>split_at_mut</code>, heh</p>",
        "id": 276126255,
        "sender_full_name": "eddyb",
        "timestamp": 1647904765
    },
    {
        "content": "<p>you wouldn't want e.g. two drivers to access the same piece of memory without <em>having somehow both agreed</em> to it</p>",
        "id": 276126328,
        "sender_full_name": "eddyb",
        "timestamp": 1647904812
    },
    {
        "content": "<p>CHERI puts some of those objcap ideas into low-level memory access - you can only \"shrink\" a CHERI pointer's bounds/permissions</p>",
        "id": 276126399,
        "sender_full_name": "eddyb",
        "timestamp": 1647904883
    },
    {
        "content": "<p>I've relied on the ability to pull some MMIO pointers out of my hat, knowing full-well that something up the call stack is probably doing the same thing,<br>\nAlbeit my MMIO pointers come from extern <code>static mut</code>s which I <em>hope</em> rustc won't be doing stupid stuff to.</p>",
        "id": 276126523,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647904937
    },
    {
        "content": "<p>Yeah, I think shoving an MMIO pointer into a <code>static</code> is not a problem regardless of platform.</p>",
        "id": 276126630,
        "sender_full_name": "Jubilee",
        "timestamp": 1647905040
    },
    {
        "content": "<p>I mean the MMIO is via a symbol that's pull in by <code>extern{ static mut}</code> and that I <code>addr_of_mut!()</code></p>",
        "id": 276126703,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647905075
    },
    {
        "content": "<p>close enough.</p>",
        "id": 276126720,
        "sender_full_name": "Jubilee",
        "timestamp": 1647905089
    },
    {
        "content": "<p>yeah, that should work even on CHERI because whatever is resolving that (e.g. bootloader relocating the kernel ELF), can compute a valid pointer to place there</p>",
        "id": 276126891,
        "sender_full_name": "eddyb",
        "timestamp": 1647905236
    },
    {
        "content": "<p>Well, I mean, MMIO is non-portable anyways.</p>",
        "id": 276127014,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647905355
    },
    {
        "content": "<p>lmao I forgot about forging ZSTs being legit (still is, CHERI doesn't care if you make up a pointer and never deref if)</p>",
        "id": 276127162,
        "sender_full_name": "Gankra",
        "timestamp": 1647905473
    },
    {
        "content": "<p>gonna add an explicit method for that</p>",
        "id": 276127180,
        "sender_full_name": "Gankra",
        "timestamp": 1647905500
    },
    {
        "content": "<p>make up a guy</p>",
        "id": 276127185,
        "sender_full_name": "Jubilee",
        "timestamp": 1647905501
    },
    {
        "content": "<p>I doubt <code>__counter_enable</code> works well on CHERI.</p>",
        "id": 276127266,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647905560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T/near/276126523\">said</a>:</p>\n<blockquote>\n<p>I've relied on the ability to pull some MMIO pointers out of my hat, knowing full-well that something up the call stack is probably doing the same thing,<br>\nAlbeit my MMIO pointers come from extern <code>static mut</code>s which I <em>hope</em> rustc won't be doing stupid stuff to.</p>\n</blockquote>\n<p>Connor clearly trying to bait eddyb into delivering a screed Ã  la <a href=\"https://github.com/rust-lang/rust/issues/53639\">https://github.com/rust-lang/rust/issues/53639</a> :P</p>",
        "id": 276191631,
        "sender_full_name": "bstrie",
        "timestamp": 1647957313
    },
    {
        "content": "<p>Well, see, I used to use <code>VolatileCell</code> instead of <code>static mut</code>, but then I was told that rustc can read my <code>&amp;VolatileCell&lt;T&gt;</code> without telling me, so...</p>",
        "id": 276200956,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647961048
    },
    {
        "content": "<p>I believe the fix for <code>&amp;VolatileCell&lt;T&gt;was is to replace it with a newtype over </code>*T<code> that provides the read/write methods using </code>{read,write}_volatile<code> methods on the pointer itself - AFAICT there's not really any provenance issues from interacting with an </code>extern { static mut }` directly or putting the pointer into such a newtype, all of that should \"just work\"</p>",
        "id": 276201671,
        "sender_full_name": "eddyb",
        "timestamp": 1647961289
    },
    {
        "content": "<p>Sure, but I still need to represent the symbol, hense the <code>extern {static mut}</code></p>",
        "id": 276204777,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647962344
    },
    {
        "content": "<p>If the symbol is only provided via linker that's quite unfortunate for you ;_;</p>",
        "id": 276207381,
        "sender_full_name": "Lokathor",
        "timestamp": 1647963330
    },
    {
        "content": "<p>Well, yes, I do that instead of casting magic addresses.</p>",
        "id": 276208494,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647963745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T/near/276207381\">said</a>:</p>\n<blockquote>\n<p>If the symbol is only provided via linker that's quite unfortunate for you ;_;</p>\n</blockquote>\n<p>it's actually better in some ways because the linker is then the one responsible for coming up with a valid pointer :P</p>",
        "id": 276209231,
        "sender_full_name": "eddyb",
        "timestamp": 1647964043
    },
    {
        "content": "<p>(and if you get yourself into an unrepresentable situation by accident, you're more likely to discover it at link time than at runtime)</p>",
        "id": 276209306,
        "sender_full_name": "eddyb",
        "timestamp": 1647964073
    },
    {
        "content": "<p>but my lovely lovely const prop. or, more importantly, my lovely lovely register savings</p>",
        "id": 276220235,
        "sender_full_name": "Lokathor",
        "timestamp": 1647968103
    },
    {
        "content": "<p>Either way, I strongly suggest that you give the &lt;<a href=\"https://docs.rs/voladdress\">https://docs.rs/voladdress</a>&gt; crate a look, and see if you can get it to work with your linker &lt;3</p>",
        "id": 276220794,
        "sender_full_name": "Lokathor",
        "timestamp": 1647968335
    },
    {
        "content": "<p><a href=\"https://twitter.com/arichardson___/status/1506427082737340416\">https://twitter.com/arichardson___/status/1506427082737340416</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/arichardson___/status/1506427082737340416\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/01d2ec0d00cc478291d0d76be7347c373bcf1834/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313530363032363830303933333232303335342f66315f7450684a4c5f6e6f726d616c2e706e67\"></a><p><a href=\"https://twitter.com/Gankra_\">@Gankra_</a> Currently our LLVM emits .gcc_except_table targets as capabilities instead of offsets (<a href=\"https://t.co/HaIDj0HvFX\">https://cheri-compiler-explorer.cl.cam.ac.uk/z/n6GhhW</a>). And in some cases libunwind derives provenance from program header capabilities, using dl_iterate_phdrs (RTLD sets them up to span the DSO).</p><span>- Alex Richardson (@arichardson___)</span></div></div>",
        "id": 276273548,
        "sender_full_name": "Gankra",
        "timestamp": 1647995307
    },
    {
        "content": "<p>OH</p>",
        "id": 276274103,
        "sender_full_name": "Gankra",
        "timestamp": 1647995564
    },
    {
        "content": "<p><a href=\"https://cheri-compiler-explorer.cl.cam.ac.uk/z/n6GhhW\">https://cheri-compiler-explorer.cl.cam.ac.uk/z/n6GhhW</a></p>",
        "id": 276274106,
        "sender_full_name": "Gankra",
        "timestamp": 1647995566
    },
    {
        "content": "<p>They have their own godbolt???</p>",
        "id": 276274119,
        "sender_full_name": "Gankra",
        "timestamp": 1647995572
    },
    {
        "content": "<p>niiiice.</p>",
        "id": 276274372,
        "sender_full_name": "Jubilee",
        "timestamp": 1647995693
    },
    {
        "content": "<blockquote>\n<p>0xCAFE as *mut T is still a \"noalias\" promise in the sense that it must not alias with any pointer returned by an Abstract Machine allocation operation (local variables, statics, heap allocations).</p>\n</blockquote>\n<p>Huh, I am not sure I understand the distinction, <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 276529476,
        "sender_full_name": "Jubilee",
        "timestamp": 1648150949
    },
    {
        "content": "<p>Isn't it to be able to say this is UB?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Imagine that &amp;x as usize == 0xCAFE</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mh\">0xCAFE</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Obv. just creating the pointer doesn't assert uniqueness since it's a safe operation</p>",
        "id": 276546541,
        "sender_full_name": "Nick12",
        "timestamp": 1648160118
    },
    {
        "content": "<p>Basically Ralf is describing a model where casting an integer to a pointer doesn't quite create an <em>invalid</em> pointer but a pointer with a fresh provenance, which is morally equivalent to calling <code>malloc</code> which of course returns a guaranteed-unaliased pointer (from within the language). This is also how I rationalize that \"thin-air\" ZSTs cannot be invalidated because a \"real\" allocation they happen to be in the range of got freed.</p>",
        "id": 276547650,
        "sender_full_name": "Gankra",
        "timestamp": 1648160931
    },
    {
        "content": "<p>(For whatever reason my brain likes visualizing this as memory laying in a straight line where unrelated \"seemingly\" collide all the time, but provenance introduces a second dimension that makes unrelated pointers \"obviously\" unable to interact)</p>",
        "id": 276549013,
        "sender_full_name": "Gankra",
        "timestamp": 1648161996
    },
    {
        "content": "<p>But anyway the reason I prefer to think of inttoptr casts as producing an invalid pointer by default is that although we can always generate fresh allocation/provenance ids, it is wholy unclear how to generate the <em>range</em> of the provenance. The only sensible default is \"empty range\" for a unary cast, at which point the pointer is only usable for talking about ZSTs or as a type pun for an integer.</p>",
        "id": 276549219,
        "sender_full_name": "Gankra",
        "timestamp": 1648162130
    },
    {
        "content": "<p>This is why I was messing around with like fake_alloc or whatever as a way to properly specify the <em>range</em> you're claiming a stake on.</p>",
        "id": 276549303,
        "sender_full_name": "Gankra",
        "timestamp": 1648162187
    },
    {
        "content": "<p>you can say \"all non-AM memory\" and that'll likely do fine for the invented pointer use cases if you aren't trying to do <code>&amp;mut *(0xCAFE as *mut Whatever)</code> (and if you are it only has issues in the way that <code>static mut</code> has issues)</p>",
        "id": 276549518,
        "sender_full_name": "Talchas",
        "timestamp": 1648162333
    },
    {
        "content": "<p>AM?</p>",
        "id": 276549581,
        "sender_full_name": "Gankra",
        "timestamp": 1648162387
    },
    {
        "content": "<p>abstract machine, ie all the heap/stack/etc memory (and re the &amp;mut part, probably \"anything being pointed to by a reference\")</p>",
        "id": 276549629,
        "sender_full_name": "Talchas",
        "timestamp": 1648162428
    },
    {
        "content": "<p>I don't think that's the only sensible default :3 I think that \"the span of the element type\" is also a sensible default</p>",
        "id": 276549780,
        "sender_full_name": "Lokathor",
        "timestamp": 1648162537
    },
    {
        "content": "<p>I don't think it's the _only_ sensible default, but I think it is _a_ sensible default</p>",
        "id": 276549814,
        "sender_full_name": "Talchas",
        "timestamp": 1648162558
    },
    {
        "content": "<p>that's fair but will probably make you very sad for *mut u8</p>",
        "id": 276549817,
        "sender_full_name": "Gankra",
        "timestamp": 1648162560
    },
    {
        "content": "<p>and unlikely to make you lose for *mut u8, yeah</p>",
        "id": 276549859,
        "sender_full_name": "Talchas",
        "timestamp": 1648162568
    },
    {
        "content": "<p>i mean i guess it wouldn't be the <em>worst</em> reality to require <code>*mut [u8; N]</code> lol</p>",
        "id": 276549906,
        "sender_full_name": "Gankra",
        "timestamp": 1648162622
    },
    {
        "content": "<p>like this is more permissive than needed, but the uses are likely either <code>global = &amp;mut *(int as *mut T);</code> or <code>*(int as *mut T) = whatever;</code> (and doing <code>global</code> without &amp;mut should be fine as well)</p>",
        "id": 276549914,
        "sender_full_name": "Talchas",
        "timestamp": 1648162629
    },
    {
        "content": "<p>if it is a dynamic span of memory that's just a normal \"heap provenance\" situation it seems like</p>",
        "id": 276550016,
        "sender_full_name": "Lokathor",
        "timestamp": 1648162695
    },
    {
        "content": "<p>just with a heap that happens to live in a fixed address you know about because you're the kernel and you get to Know Things</p>",
        "id": 276550086,
        "sender_full_name": "Lokathor",
        "timestamp": 1648162753
    },
    {
        "content": "<p>like you don't need the compiler to know that <code>0x1000 as *mut X</code> and <code>0x2000 as *mut Y</code> don't alias, because they're generally not being used at the same time and/or are being used via volatile ops that can't be optimized anyways</p>",
        "id": 276550087,
        "sender_full_name": "Talchas",
        "timestamp": 1648162753
    },
    {
        "content": "<p>yeah i punted on this usecase because it's very Not My Thing and someone who is into it needs to tackle it in earnest</p>",
        "id": 276550090,
        "sender_full_name": "Gankra",
        "timestamp": 1648162754
    },
    {
        "content": "<p>if you do need more alias info you're probably gonna upgrade that pointer to a reference anyway</p>",
        "id": 276550370,
        "sender_full_name": "Lokathor",
        "timestamp": 1648162881
    },
    {
        "content": "<p>it's also fine to punt on it because after \"invented pointers must not alias Abstract Machine pointers\" everything else is pretty meh</p>",
        "id": 276550576,
        "sender_full_name": "Talchas",
        "timestamp": 1648162986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T/near/276549219\">said</a>:</p>\n<blockquote>\n<p>But anyway the reason I prefer to think of inttoptr casts as producing an invalid pointer by default is that although we can always generate fresh allocation/provenance ids, it is wholy unclear how to generate the <em>range</em> of the provenance. The only sensible default is \"empty range\" for a unary cast, at which point the pointer is only usable for talking about ZSTs or as a type pun for an integer.</p>\n</blockquote>\n<p>I dont think we need to generate a \"range\" of the provenance.</p>",
        "id": 276728565,
        "sender_full_name": "RalfJ",
        "timestamp": 1648304675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Forging.20*mut.20w.2Fo.20usize.20as.20*mut.20T/near/276529476\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>0xCAFE as *mut T is still a \"noalias\" promise in the sense that it must not alias with any pointer returned by an Abstract Machine allocation operation (local variables, statics, heap allocations).</p>\n</blockquote>\n<p>Huh, I am not sure I understand the distinction, <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span></p>\n</blockquote>\n<p>basically, it is totally okay to do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0xabc0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>as long as you are <em>sure</em> that this will not overwrite any <code>static</code>, local variable, heap allocation, or any other memory that the Rust Abstract Machine \"claims for itself\". (and of course the access must not page fault either.)</p>",
        "id": 276728678,
        "sender_full_name": "RalfJ",
        "timestamp": 1648304862
    },
    {
        "content": "<p>and in this strict model this is true for <em>any</em> pointer obtained via int-to-ptr cast, i.e., including <code>&amp;x as *mut _ as usize as *mut i32</code>. so this breaks ptr-int-ptr roundtrips. but it still permits things embedded platforms need where certain memory regions just happen at fixed addresses.</p>",
        "id": 276728748,
        "sender_full_name": "RalfJ",
        "timestamp": 1648304950
    },
    {
        "content": "<blockquote>\n<p>I dont think we need to generate a \"range\" of the provenance.</p>\n</blockquote>\n<p>well it would be very nice if we could for CHERI's sake</p>",
        "id": 276729356,
        "sender_full_name": "Gankra",
        "timestamp": 1648305893
    },
    {
        "content": "<p>I agree your interpretation is reasonable and useful though</p>",
        "id": 276729450,
        "sender_full_name": "Gankra",
        "timestamp": 1648306079
    },
    {
        "content": "<p>ah yes I keep forgetting CHERI. but the usecase here for people like <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> is typically very platform-specific, so presumably having CHERI bail on that would not be a problem</p>",
        "id": 276731648,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309286
    },
    {
        "content": "<p>I still think it would be more helpful to have a function that expresses \"hello yes i am doing this\" for the purposes of hanging docs off of it and either making it a compile time error in targets/configs that don't make sense (maximally strict userland CHERI) or make it do \"the thing it must do\" on targets where it needs to be more clever (use it as an offset off of the global \"all of the process/all of the address space\" capability that a non-strict process/kernel has)</p>",
        "id": 276731829,
        "sender_full_name": "Gankra",
        "timestamp": 1648309524
    },
    {
        "content": "<p>I agree making it explicit is a lot better than <code>as</code></p>",
        "id": 276731907,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309636
    },
    {
        "content": "<p>I just want to make sure we don't have a crowd with pitchforks that thinks we are taking their crazy embedded things away ;)</p>",
        "id": 276731916,
        "sender_full_name": "RalfJ",
        "timestamp": 1648309655
    },
    {
        "content": "<p>some function like <code>foreign_ptr(usize)-&gt;*mut T</code> would certainly be appropriate</p>",
        "id": 276732205,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310036
    },
    {
        "content": "<p>well Gankra is saying it should be <code>make_alloc_at_fixed_addr(addr: usize, size: usize)</code></p>",
        "id": 276732258,
        "sender_full_name": "RalfJ",
        "timestamp": 1648310066
    },
    {
        "content": "<p>i.e., also be explicit about how big that memory region is (so CHERI or whatever can do its magic on that)</p>",
        "id": 276732270,
        "sender_full_name": "RalfJ",
        "timestamp": 1648310089
    },
    {
        "content": "<p>that's fine, but also very clumsy for single elements, though that can be fixed with some sort of wrapper function i suppose.</p>",
        "id": 276732299,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310144
    },
    {
        "content": "<p>BTW, I have in some cases needed specifically an <code>as</code> cast, since I was in code that cannot have a function call in the assembly (lest my code could possibly become recursive), and I don't necessarily want to rely on <code>$RUSTC</code>doing \"the right thing\" and inlining the code.</p>",
        "id": 276732349,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648310178
    },
    {
        "content": "<p>these functions can be Officially Intrinsics which addresses that, right</p>",
        "id": 276732365,
        "sender_full_name": "Gankra",
        "timestamp": 1648310210
    },
    {
        "content": "<p>Actually that doesn't address it :(</p>",
        "id": 276732376,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310231
    },
    {
        "content": "<p>Perhaps.</p>",
        "id": 276732379,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648310233
    },
    {
        "content": "<p>An intrinsic doesn't <em>necessarily</em> prevent a function call from happening</p>",
        "id": 276732390,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310269
    },
    {
        "content": "<p>i guess you could make it part of the spec</p>",
        "id": 276732430,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310285
    },
    {
        "content": "<p>well i don't think anything in the reference or whatever says <code>foo as usize</code> has a specific impl you can rely on, so an intrinsic is just as solid footing for that?</p>",
        "id": 276732474,
        "sender_full_name": "Gankra",
        "timestamp": 1648310383
    },
    {
        "content": "<p>true enough</p>",
        "id": 276732554,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310412
    },
    {
        "content": "<p>Fair. I find it less likely that an intrinsic operation gets replaced with a function call, then if an implementation simply doesn't inline (despite <code>#[inline(always)]</code> which, albeit strong, is merely still a hint).</p>",
        "id": 276732589,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648310451
    },
    {
        "content": "<p>yeah, if rustc agrees that <em>it</em> will inline and cut out llvm from the process that would be fine</p>",
        "id": 276732669,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310530
    },
    {
        "content": "<p>I'm not just using rustc, though (and, in some cases, inlining is in fact impossible).</p>",
        "id": 276732701,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648310609
    },
    {
        "content": "<p>could you give an example of when it's impossible</p>",
        "id": 276732760,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310647
    },
    {
        "content": "<p>recursion is a classic case</p>",
        "id": 276732794,
        "sender_full_name": "Gankra",
        "timestamp": 1648310727
    },
    {
        "content": "<p>Incompatible target features is one.<br>\nlccc's inliner will refuse to inline when the operand stack depths in the callee or caller exceed a certain limit, or when the combined stack depth exceeds a hard limit of 2^16 (since such stack depths are not required to be supported, and some operations can't reach beyond this limit whatsoever).</p>",
        "id": 276732802,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648310751
    },
    {
        "content": "<p>sorry i didn't mean when inline is impossible in general, i meant specifically for the pointer cast intrinsic only</p>",
        "id": 276732940,
        "sender_full_name": "Lokathor",
        "timestamp": 1648310887
    },
    {
        "content": "<p>If it's implemented as an intrinsic, then it probably will be effectively inlined.<br>\nOf course, if it's wrapped at all, any of the no-inline cases could be hit, and the function just doesn't inline.</p>",
        "id": 276732975,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648310968
    },
    {
        "content": "<p>basically if you are Writing Your Own Compiler and it's an intrinsic you get to Make Sure It Works :)</p>",
        "id": 276733057,
        "sender_full_name": "Gankra",
        "timestamp": 1648311065
    },
    {
        "content": "<p>yeah, as you say, <code>foo as bar</code> might actually also be a function call too, but then the pitchforks show up</p>",
        "id": 276733160,
        "sender_full_name": "Lokathor",
        "timestamp": 1648311219
    },
    {
        "content": "<p>For primitive inlining Swift has (for stdlib use only) <a href=\"https://github.com/apple/swift/blob/main/docs/TransparentAttr.md\"><code>@_transparent</code></a> on functions, which includes the effect \"inline this first, before diagnostics, even at optimization level 0\"</p>",
        "id": 276735105,
        "sender_full_name": "Dante Broggi",
        "timestamp": 1648313880
    },
    {
        "content": "<p>Having an allocation size would be useful for CHERI so we could generate the bounds restriction instruction. In the OS kernel usecase, you have to keep around a capability spanning your MMIO regions somewhere, so we would almost certainly have to change that code to derive from the correct capability (also to get the desired read/write/executr/etc. Permissions). Forcing use of an explicit API would make it much easiert to audit those cases and if needed replace them with target-specific code.</p>",
        "id": 276735170,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648313950
    },
    {
        "content": "<p><code>foo as T</code> can and does already codegen to a function call in some cases (e.g. conversions between 128 bit integers and floats)</p>",
        "id": 276793719,
        "sender_full_name": "nagisa",
        "timestamp": 1648395067
    }
]