[
    {
        "content": "<p>Is this code sound:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"nc\">S</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// s.0 contains a field that has been dropped</span>\n<span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// &amp;mut s.0 creates a ref to dropped field</span>\n</pre></div>\n\n\n<p>?</p>\n<p>In particular, creating a <code>&amp;mut s</code> or <code>&amp;mut s.0</code> after <code>s.0</code> has been dropped, might create an invalid reference ? (EDIT: e.g. the <code>Vec</code> contains a <code>NonNull&lt;u8&gt;</code>, which is a nonnull ptr value, which in this particular case gets dropped, and after the drop we don't guarantee that the pointer is nonnull anymore)</p>",
        "id": 184103427,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577106946
    },
    {
        "content": "<p>Is that meant to be <code>let mut s: S = S(Vec::new())</code> or so?</p>",
        "id": 184103829,
        "sender_full_name": "simulacrum",
        "timestamp": 1577107415
    },
    {
        "content": "<p>as is that doesn't compile since s isn't initialized</p>",
        "id": 184103842,
        "sender_full_name": "simulacrum",
        "timestamp": 1577107431
    },
    {
        "content": "<p>it doesn't matter how its initialized, only that such a binding exists</p>",
        "id": 184104183,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577107747
    },
    {
        "content": "<p>it could be <code>fn foo(mut x: S) { ...code goes here... }</code></p>",
        "id": 184104191,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577107760
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"nc\">S</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// s.0 contains a field that has been dropped</span>\n<span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// &amp;mut s.0 creates a ref to dropped field</span>\n</pre></div>\n\n\n<p>is then more accurate perhaps?</p>",
        "id": 184104385,
        "sender_full_name": "simulacrum",
        "timestamp": 1577107984
    },
    {
        "content": "<p>i.e., actually initializing the field</p>",
        "id": 184104397,
        "sender_full_name": "simulacrum",
        "timestamp": 1577107999
    },
    {
        "content": "<p>sure</p>",
        "id": 184104482,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577108087
    },
    {
        "content": "<p>Yes this is sound as long as you make sure that no panic is possible while the value is \"dropped\".</p>",
        "id": 184105254,
        "sender_full_name": "Amanieu",
        "timestamp": 1577108853
    },
    {
        "content": "<p>So what's the \"value\" of the dropped <code>Vec</code> ?</p>",
        "id": 184105650,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109193
    },
    {
        "content": "<p>Like maybe an even simpler example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"nc\">S</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184105762,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109279
    },
    {
        "content": "<p>The <code>NonNull&lt;u8&gt;</code> has been dropped, yet the validity invariant of <code>NonNull&lt;u8&gt;</code> requires it to be <code>nonnull</code></p>",
        "id": 184105806,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109325
    },
    {
        "content": "<p>AFAICT dropping a value uninitializes its storage?</p>",
        "id": 184105897,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109382
    },
    {
        "content": "<p>So <code>x</code> would be a reference to uninitialized memory, and therefore invalid</p>",
        "id": 184105908,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109397
    },
    {
        "content": "<p>Maybe a different way to phrase it would be whether a valid implementation of <code>ptr::drop_in_place</code> can write <code>mem::uninitialized</code> after dropping the values through the pointer ?</p>",
        "id": 184106225,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109703
    },
    {
        "content": "<p>Or whether after dropping a value its storage becomes uninitialized</p>",
        "id": 184106305,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109763
    },
    {
        "content": "<p>(essentially, creating the <code>&amp;mut s.0</code> after the <code>ptr::drop_in_place</code> is a \"use-after-drop\")</p>",
        "id": 184106457,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577109898
    },
    {
        "content": "<p>Normally dropping a value can uninit the storage because the storage is on a stack frame which you might have just popped away because drops normally only fires when scopes close. However, that's just the stack popping, there's no reason to write uninit if it's dropped as part of <code>drop_in_place</code>.</p>",
        "id": 184108274,
        "sender_full_name": "Lokathor",
        "timestamp": 1577111737
    },
    {
        "content": "<p><code>drop_in_place</code> is unsafe and can trivially lead to a double-free, but I don't see anything that would also allow it to just write uninit and break validity invariants that way. It might be under specified to the point where it's technically allowed to do that, but it should not and if it did start doing that in some new release of rust you'd get torches and pitchforks at the door.</p>",
        "id": 184108809,
        "sender_full_name": "Lokathor",
        "timestamp": 1577112285
    },
    {
        "content": "<p>As far as I can tell, the only potential issue with the first example is that the &amp;mut created in the last line is referring to uninit or otherwise not-safe memory. But this can be trivially side-stepped by using <code>&amp;raw mut s.0</code> (once that syntax is stable) and that's cleaner and more explicit anyway.</p>",
        "id": 184158222,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1577177083
    },
    {
        "content": "<blockquote>\n<p>So what's the \"value\" of the dropped <code>Vec</code> ?</p>\n</blockquote>\n<p>there's no such thing. or do you mean \"what are the contents of the memory where the <code>Vec</code> is stored\"? I don't think there is any general way to tell. It's whatever <code>drop_in_place</code> left behind. It must satisfy the validity invariant, I guess, but that's about it.</p>",
        "id": 184274146,
        "sender_full_name": "RalfJ",
        "timestamp": 1577383064
    },
    {
        "content": "<p>So <code>drop_in_place</code> must satisfy the validity invariant ?</p>",
        "id": 184374602,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577538541
    },
    {
        "content": "<blockquote>\n<p>As far as I can tell, the only potential issue with the first example is that the &amp;mut created in the last line is referring to uninit or otherwise not-safe memory.</p>\n</blockquote>\n<p>That's the main issue I see as well.</p>",
        "id": 184374616,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577538586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> IIUC, for <code>drop_in_place</code> to satisfy the validity invariant, <code>Drop::drop(&amp;mut self)</code> needs to satisfy the validity invariant as well.</p>",
        "id": 184374684,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577538678
    },
    {
        "content": "<p>And by satisfy I mean that <code>Drop::drop</code> is not allowed to leave <code>self</code> in an invalid state.</p>",
        "id": 184374695,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577538707
    },
    {
        "content": "<p>That's something that <code>Drop::drop</code> docs do not spell out though.</p>",
        "id": 184374739,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577538739
    },
    {
        "content": "<p>They shouldn't need to?</p>",
        "id": 184374744,
        "sender_full_name": "simulacrum",
        "timestamp": 1577538764
    },
    {
        "content": "<p>i.e., <code>&amp;mut self</code> means that the <code>Self</code> must be valid throughout the method</p>",
        "id": 184374751,
        "sender_full_name": "simulacrum",
        "timestamp": 1577538782
    },
    {
        "content": "<p>notably, we encounter this in other places too, e.g., <code>AtomicUsize::fetch_sub</code> which ends up dropping the Atomic before the end of the method, while we still have &amp;self in that method</p>",
        "id": 184374764,
        "sender_full_name": "simulacrum",
        "timestamp": 1577538818
    },
    {
        "content": "<p>notice that the content of the <code>Drop</code> impl doesn't matter</p>",
        "id": 184374948,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539167
    },
    {
        "content": "<p>the fields will be dropped  \"after\" the <code>Drop::drop</code> function finishes, as part of dropping the value</p>",
        "id": 184374952,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539193
    },
    {
        "content": "<p>i.e. a call to <code>Drop::drop(s)</code> does not only execute the <code>Drop::drop</code> method, but it then subsequently drops the fields of <code>s</code></p>",
        "id": 184374995,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539220
    },
    {
        "content": "<p>and this subsequent dropping of the fields of <code>s</code> would need to leave <code>s</code> in a \"valid\" state for the example above to not have UB</p>",
        "id": 184374997,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539242
    },
    {
        "content": "<p>In particular, notice that <code>S(Vec&lt;T&gt;)</code> does not implement <code>Drop</code>, its fields do</p>",
        "id": 184375000,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539261
    },
    {
        "content": "<p>the behavior of dropping a field is unspecified</p>",
        "id": 184375058,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539362
    },
    {
        "content": "<p>If I have:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>we don't specify anywhere in which state the memory of <code>x</code> is left in after the <code>i32</code> is dropped</p>",
        "id": 184375112,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539448
    },
    {
        "content": "<p>Does the memory of <code>x</code> is left with a <code>S(42)</code> value? Does it become <code>S(uninit)</code> ?</p>",
        "id": 184375125,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539504
    },
    {
        "content": "<p>If it becomes <code>S(uninit)</code>, then that call to <code>drop_in_place</code> is already UB.</p>",
        "id": 184375173,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577539568
    },
    {
        "content": "<p>my understanding is that it does not become uninit, but becomes unknown -- i.e., you should not do anything that could cause access to it</p>",
        "id": 184376703,
        "sender_full_name": "simulacrum",
        "timestamp": 1577542344
    },
    {
        "content": "<p>(read) access</p>",
        "id": 184376707,
        "sender_full_name": "simulacrum",
        "timestamp": 1577542350
    },
    {
        "content": "<p>Drop isn't specially able to write uninit when other code couldn't. In other words, any place you couldn't write uninit to <code>&amp;mut self</code>, Drop can't do it either.</p>\n<p>Drop can safely put your <em>safety</em> invariants out of place (eg: free some memory, de-init an API, etc), but it has no special <em>validity</em> invariant breaking ability at all.</p>",
        "id": 184381060,
        "sender_full_name": "Lokathor",
        "timestamp": 1577549901
    },
    {
        "content": "<p>Yes, that's my understanding as well. Note that this is somewhat unique to drop -- no other safe function has that property. Arguably, Drop::drop maybe should be an unsafe fn because of this (but since you can't call it directly doesn't matter too much)</p>",
        "id": 184381253,
        "sender_full_name": "simulacrum",
        "timestamp": 1577550304
    },
    {
        "content": "<blockquote>\n<p>So <code>drop_in_place</code> must satisfy the validity invariant ?</p>\n</blockquote>\n<p>I cannot parse this question</p>",
        "id": 184417720,
        "sender_full_name": "RalfJ",
        "timestamp": 1577620455
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> agreed. And <code>Drop::drop</code> de-facto is <code>unsafe</code>... or rather, it's a magic special snowflake. It doesn't actually have the type <code>fn(&amp;mut Self)</code>, clearly.</p>",
        "id": 184417794,
        "sender_full_name": "RalfJ",
        "timestamp": 1577620591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> you stated:</p>\n<blockquote>\n<p>It's whatever drop_in_place left behind. It must satisfy the validity invariant, I guess, but that's about it.</p>\n</blockquote>\n<p>So my question was related to that. What do you mean with the claim that after <code>ptr::drop_in_place(ptr)</code> the memory at <code>ptr</code> must satisfy the validity invariant?</p>",
        "id": 184648974,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577969809
    },
    {
        "content": "<p>Do you literally just mean that? (from the other comments, it appears so)</p>",
        "id": 184649192,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970045
    },
    {
        "content": "<blockquote>\n<p>my understanding is that it does not become uninit, but becomes unknown -- i.e., you should not do anything that could cause access to it</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> We don't have an \"unknown\" state in the abstract machine</p>",
        "id": 184649397,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970247
    },
    {
        "content": "<p>AFAICT, from reading <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> and <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> comments, <code>Drop::drop</code> cannot violate the validity invariant, and that means it cannot write to the memory any value that isn't valid for the type.</p>",
        "id": 184649422,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970295
    },
    {
        "content": "<p>That includes \"uninit\" for some types (for <code>MaybeUninit</code> it would be ok), and probably any kind of \"unknown\"state.</p>",
        "id": 184649445,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970325
    },
    {
        "content": "<p>This means it must be ok to read from a memory location after droping its contents, i.e., a read-after-drop is not UB.</p>",
        "id": 184649504,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970366
    },
    {
        "content": "<p>And since the memory contains a valid value, why wouldn't such a read be ok ?</p>",
        "id": 184649517,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970392
    },
    {
        "content": "<p>However, like <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> mentioned, <code>Drop::drop</code> can break the safety invariants of a type</p>",
        "id": 184649524,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970410
    },
    {
        "content": "<p>so if you have a type for which this is the case, then you need to be extra careful, but none of this is UB per se</p>",
        "id": 184649543,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970442
    },
    {
        "content": "<p>Just because the memory is valid doesn't make using the value there safe; furthermore, e.g. Box or references would not (technically) be safe to read.</p>",
        "id": 184649621,
        "sender_full_name": "simulacrum",
        "timestamp": 1577970534
    },
    {
        "content": "<p>A Box is only valid if it is safe to read</p>",
        "id": 184649631,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970555
    },
    {
        "content": "<p>e.g., because a <code>Box</code> is <code>dereferenceable</code></p>",
        "id": 184649641,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970578
    },
    {
        "content": "<p>It's also true I think that we consider dropping to end the lifetime of the memory (i.e. llvm can reuse the stack slot for example)</p>",
        "id": 184649695,
        "sender_full_name": "simulacrum",
        "timestamp": 1577970604
    },
    {
        "content": "<p>For a type like <code>i32</code>, a double drop is not UB, according to the model being discussed here</p>",
        "id": 184649706,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970629
    },
    {
        "content": "<p>e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42_</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// OK</span>\n</pre></div>",
        "id": 184649717,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970652
    },
    {
        "content": "<blockquote>\n<p>Just because the memory is valid doesn't make using the value there safe;</p>\n</blockquote>\n<p>No, as mentioned, <code>Drop::drop</code> is allowed to leave the memory in a state that does not satisfy the safety invariant of a type. But there are many operations for which that is ok.</p>",
        "id": 184649753,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970719
    },
    {
        "content": "<p>For example, <code>Vec::set_len</code> can be used to leave the <code>Vec</code> in a state that does not satisfy the safety invariant, and that turns out to be a very useful thing</p>",
        "id": 184649807,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970753
    },
    {
        "content": "<blockquote>\n<p>It's also true I think that we consider dropping to end the lifetime of the memory (i.e. llvm can reuse the stack slot for example)</p>\n</blockquote>\n<p>That's something that we would need to document somehow.</p>",
        "id": 184649829,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970786
    },
    {
        "content": "<p>AFAICT we can do that when <code>Drop::drop</code> is called implicitly because then the language makes it impossible for the user to try to access that memory location due to ownership, but we can't do that when the user calls <code>ptr::drop_in_place</code> manually.</p>",
        "id": 184649843,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970823
    },
    {
        "content": "<p>We could just assert that any operation on dropped values is UB</p>",
        "id": 184649896,
        "sender_full_name": "simulacrum",
        "timestamp": 1577970858
    },
    {
        "content": "<p>In general that would require us to add some sort of \"dropped\" state to the abstract machine</p>",
        "id": 184649921,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970910
    },
    {
        "content": "<p>i.e., drop_in_place is <em>not</em> required to satisfy validity invariant, though Drop::drop is</p>",
        "id": 184649930,
        "sender_full_name": "simulacrum",
        "timestamp": 1577970918
    },
    {
        "content": "<p>I don't think so? The value just doesn't exist</p>",
        "id": 184649942,
        "sender_full_name": "simulacrum",
        "timestamp": 1577970943
    },
    {
        "content": "<p>I think the consensus from above was that Drop::drop and drop_in_place are required to satisfy the validity invariant</p>",
        "id": 184649949,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970961
    },
    {
        "content": "<p>(basically as currently defined, violating it is instant UB)</p>",
        "id": 184650001,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577970991
    },
    {
        "content": "<p>I think we have consensus that Drop::drop is. I'm not sure about drop_in_place - it takes *mut T, right?</p>",
        "id": 184650004,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971000
    },
    {
        "content": "<p>Yes, but it drops the memory at the <code>*mut T</code> address</p>",
        "id": 184650012,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971022
    },
    {
        "content": "<p>So there's no &amp;mut to speak of, technically</p>",
        "id": 184650027,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971045
    },
    {
        "content": "<p>Since <code>drop_in_place</code> must call <code>Drop::drop(&amp;mut T)</code></p>",
        "id": 184650039,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971072
    },
    {
        "content": "<p>then that pointer gets dereferenced at some point</p>",
        "id": 184650082,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971084
    },
    {
        "content": "<p>Well, yes, the Drop can't do anything</p>",
        "id": 184650084,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971086
    },
    {
        "content": "<p>But after Drop is called, it could do anything with said memory (e.g. reuse it for some other type, with different validity invariants)</p>",
        "id": 184650127,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971132
    },
    {
        "content": "<p>The difference is that, when <code>Drop::drop</code> is implicitly called, the memory becomes unaccessible for the rest of the program</p>",
        "id": 184650156,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971166
    },
    {
        "content": "<p>when you manually call <code>ptr::drop_in_place(ptr)</code>, the <code>ptr</code> is still accessible</p>",
        "id": 184650167,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971182
    },
    {
        "content": "<p>in general, if memory is unaccessible, LLVM can do whatever it wants with it</p>",
        "id": 184650172,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971192
    },
    {
        "content": "<p>the user can't tell</p>",
        "id": 184650176,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971198
    },
    {
        "content": "<p>However for <code>drop_in_place</code>, were LLVM to use the memory at <code>ptr</code> for something else, the user would be able to tell</p>",
        "id": 184650230,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971223
    },
    {
        "content": "<p>We could say that memory for which <code>drop_in_place</code> is called can only be written to, but not read from, or something like that</p>",
        "id": 184650255,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971262
    },
    {
        "content": "<p>I think the <code>ptr</code> itself is still valid, that can't change (<code>*mut T</code> is Copy, I believe)</p>",
        "id": 184650280,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971306
    },
    {
        "content": "<p>but the memory behind it is not valid to use</p>",
        "id": 184650333,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971326
    },
    {
        "content": "<p>Well, currently, AFAICT, the memory behind the pointer is valid to use</p>",
        "id": 184650341,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971341
    },
    {
        "content": "<p>because if <code>ptr::drop_in_place</code> makes it invalid, the behavior is undefined</p>",
        "id": 184650349,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971352
    },
    {
        "content": "<p>how so?</p>",
        "id": 184650352,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971357
    },
    {
        "content": "<p>an invalid value is undefined behavior</p>",
        "id": 184650362,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971365
    },
    {
        "content": "<p>er, well, I'm confused why <code>ptr::drop_in_place</code> making it invalid is UB</p>",
        "id": 184650384,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971385
    },
    {
        "content": "<p>or, rather, why it would not be acceptable to say that <code>ptr::drop_in_place</code> makes the memory behind <code>*mut T</code> invalid.</p>",
        "id": 184650399,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971411
    },
    {
        "content": "<p>because for <code>ptr::drop_in_place</code> to make the memory at pointer invalid, it would need to do: <code>*ptr = invalid;</code></p>",
        "id": 184650403,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971418
    },
    {
        "content": "<p>and that is UB</p>",
        "id": 184650409,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971423
    },
    {
        "content": "<p>I would disagree</p>",
        "id": 184650462,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971448
    },
    {
        "content": "<p>well, not the literal claim</p>",
        "id": 184650469,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971454
    },
    {
        "content": "<p>I mean, if <code>ptr::drop_in_place(ptr)</code> changes the state of the memory behind <code>ptr</code>, it needs to do so by \"writting\" to that <code>ptr</code> \"somehow\"</p>",
        "id": 184650502,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971496
    },
    {
        "content": "<p>at least, in the abstract machine (the generated code might do nothing, e.g., like writing <code>undef</code> or so)</p>",
        "id": 184650517,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971511
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">drop_in_place</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Drop</span>::<span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">SomeOtherType</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">...);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184650525,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971519
    },
    {
        "content": "<p>ah, so your point is that it would be invalid for <code>T</code>, but not for <code>SomeOtherType</code> ?</p>",
        "id": 184650601,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971565
    },
    {
        "content": "<p>Basically, yeah</p>",
        "id": 184650632,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971604
    },
    {
        "content": "<p>yeah that would work i think</p>",
        "id": 184650645,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971613
    },
    {
        "content": "<p>I'm not sure how many optimizations that allows</p>",
        "id": 184650661,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971626
    },
    {
        "content": "<p>Well, I think the main optimization is that <em>if</em> we know that <code>*mut T</code> points to the stack, LLVM/compiler can reuse it</p>",
        "id": 184650674,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971656
    },
    {
        "content": "<p>(for other types, same type, whatever)</p>",
        "id": 184650682,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971669
    },
    {
        "content": "<p>only if the user does not write to it afterwards</p>",
        "id": 184650683,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971670
    },
    {
        "content": "<p>or at least, in the \"window\" in which the user does not write to it afterwards</p>",
        "id": 184650712,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971683
    },
    {
        "content": "<p>well, I would argue that the user writing to it <em>is</em> UB, which is why we can make that optimization</p>",
        "id": 184650734,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971691
    },
    {
        "content": "<p>hmm</p>",
        "id": 184650741,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971701
    },
    {
        "content": "<p>notice that <code>Vec::pop</code> uses drop in place to drop an element</p>",
        "id": 184650760,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971716
    },
    {
        "content": "<p>and then <code>Vec::push</code> writes to that memory again afterwards</p>",
        "id": 184650768,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971728
    },
    {
        "content": "<p>i.e.,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"> </span><span class=\"c1\">// can be put in the same place as a</span>\n</pre></div>",
        "id": 184650769,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971731
    },
    {
        "content": "<p>For that optimization to happen we don't really need the extra guarantee on <code>drop_in_place</code> I think</p>",
        "id": 184650799,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971761
    },
    {
        "content": "<p>hm, I'm confused</p>",
        "id": 184650806,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971767
    },
    {
        "content": "<p><code>Vec::pop</code> shouldn't be calling drop_in_place?</p>",
        "id": 184650811,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971774
    },
    {
        "content": "<p>Sorry, <code>Vec::truncate(N)</code> for example</p>",
        "id": 184650879,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971827
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/src/alloc/vec.rs.html#729-750\" target=\"_blank\" title=\"https://doc.rust-lang.org/src/alloc/vec.rs.html#729-750\">https://doc.rust-lang.org/src/alloc/vec.rs.html#729-750</a></p>",
        "id": 184650912,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971869
    },
    {
        "content": "<p>yes, I think this is a bit different, because there the memory is on the heap</p>",
        "id": 184650914,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971876
    },
    {
        "content": "<p>yes, I was talking in general about how we would write the <code>ptr::drop_in_place</code> docs</p>",
        "id": 184650923,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971895
    },
    {
        "content": "<p>maybe that's not a meaningful distinction (and I'm not sure that we want to make it in the abstract machine)</p>",
        "id": 184650924,
        "sender_full_name": "simulacrum",
        "timestamp": 1577971896
    },
    {
        "content": "<p>I think that the optimization you want to perform is reasonable</p>",
        "id": 184650936,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971913
    },
    {
        "content": "<p>and doable on the stack, but not as simple  in general on the heap (maybe?)</p>",
        "id": 184650981,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971930
    },
    {
        "content": "<p>I'm not sure we'd need to prevent users from writing to the <code>ptr</code> after a <code>drop_in_place</code> (or even reading) to allow it</p>",
        "id": 184650992,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971952
    },
    {
        "content": "<p>like, right now, we can already perform this optimization as long as the user cannot tell (we can spill values from registers to the stack and back)</p>",
        "id": 184651001,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577971976
    },
    {
        "content": "<p>well, the advantage to making this guarantee is that e.g. generators could use it for layout optimization I think</p>",
        "id": 184651013,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972008
    },
    {
        "content": "<p>which I guess is already true under \"as if\" to an extent, as you say</p>",
        "id": 184651019,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972027
    },
    {
        "content": "<p>e.g. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>here <code>b</code> could be put in the same place as <code>a</code>, and well, it doesn't to be put in the stack at all.</p>",
        "id": 184651086,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972072
    },
    {
        "content": "<p>I guess -- maybe a more reasonable and universal (not dependent on where *mut T points to) definition is that <code>drop_in_place</code> is allowed to leave the value in an invalid state</p>",
        "id": 184651092,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972089
    },
    {
        "content": "<p>but that you are allowed to write to that pointer (e.g., via <code>ptr::write</code>)</p>",
        "id": 184651122,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972119
    },
    {
        "content": "<p>I think it would be just simpler to say that <code>ptr::drop_in_place</code> calls <code>Drop::drop(&amp;mut *ptr)</code> and that's it</p>",
        "id": 184651126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972123
    },
    {
        "content": "<p>Well, that's different, right?</p>",
        "id": 184651132,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972139
    },
    {
        "content": "<p>that means that the value behind the <code>*mut T</code> must be valid, and must be left in a valid state</p>",
        "id": 184651133,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972144
    },
    {
        "content": "<p>Like, that's not \"simpler\", that's a different definition</p>",
        "id": 184651144,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972161
    },
    {
        "content": "<p>not necessarily in a safe state</p>",
        "id": 184651145,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972161
    },
    {
        "content": "<p>well, that's how I understand the current definition, given the feedback that <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> gave above</p>",
        "id": 184651203,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972195
    },
    {
        "content": "<p>I'm not talking about a current definition</p>",
        "id": 184651214,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972214
    },
    {
        "content": "<p>that still allows your optimization</p>",
        "id": 184651219,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972217
    },
    {
        "content": "<p>or maybe put differently, is there an example for which that definition does not allow your optimization ?</p>",
        "id": 184651240,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972243
    },
    {
        "content": "<p>I'm saying that <code>ptr::drop_in_place</code> can leave value in an invalid state is different from <code>ptr::drop_in_place</code> calls <code>Drop::drop(&amp;mut *ptr)</code></p>",
        "id": 184651244,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972248
    },
    {
        "content": "<p>sure, those are different</p>",
        "id": 184651251,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972267
    },
    {
        "content": "<p>I wouldn't say that your definition leaves the value in an invalid state, as that is instant UB because it means an invalid value was created, and then written to some address</p>",
        "id": 184651302,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972289
    },
    {
        "content": "<p>i would say it writes a different value to the memory behind the pointer</p>",
        "id": 184651307,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972299
    },
    {
        "content": "<p>we could maybe change the definition to this one, but I fail to see what it buys us</p>",
        "id": 184651320,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972315
    },
    {
        "content": "<p>I would say that the memory is left invalid, which is <em>not</em> UB, because it is the compiler/language doing it, i.e., conceptually there is no more T at that place</p>",
        "id": 184651341,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972343
    },
    {
        "content": "<p>If there is no more T, there is something else there.</p>",
        "id": 184651414,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972404
    },
    {
        "content": "<p>I'm not sure that it buys us anything, that's true. I think unless we go further and start talking about the stack/heap distinction it probably doesn't</p>",
        "id": 184651423,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972414
    },
    {
        "content": "<p>Even going for the stack / heap distinction, is there an optimization that we can't do without that ?</p>",
        "id": 184651439,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972433
    },
    {
        "content": "<p>You mentioned generators before, but I can't think of one optimization that isn't possible without this.</p>",
        "id": 184651462,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972460
    },
    {
        "content": "<p>reusing the stack slot when the pointer is passed into unknown code (so we can't know what it does with it)</p>",
        "id": 184651467,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972462
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">some_c_function</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"> </span><span class=\"c1\">// can be put in the same place as a</span>\n</pre></div>",
        "id": 184651555,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972526
    },
    {
        "content": "<p>But that code does not use <code>a</code> after <code>some_c_function</code>, so <code>b</code> can always be put in the same place as <code>a</code></p>",
        "id": 184651610,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972589
    },
    {
        "content": "<p>well, per your rules, we can't, no</p>",
        "id": 184651635,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972607
    },
    {
        "content": "<p>because the slot has \"leaked\" through <code>ptr</code>, right?</p>",
        "id": 184651643,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972616
    },
    {
        "content": "<p>Ah, indeed, yes</p>",
        "id": 184651659,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972630
    },
    {
        "content": "<p>So that unknown code can't do anything with the <code>ptr</code> according to your definition right?</p>",
        "id": 184651746,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972696
    },
    {
        "content": "<p>It can't read from it, it can't write to it</p>",
        "id": 184651756,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972710
    },
    {
        "content": "<p>It can just copy it around</p>",
        "id": 184651763,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972720
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 184651767,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972726
    },
    {
        "content": "<p>sure</p>",
        "id": 184651787,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972749
    },
    {
        "content": "<p>it's basically just a <code>usize</code> for that code</p>",
        "id": 184651838,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972764
    },
    {
        "content": "<p>and this optimization is important?</p>",
        "id": 184651853,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972796
    },
    {
        "content": "<p>perhaps for generators to avoid non-local analysis (i.e., without inlining)</p>",
        "id": 184651881,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972829
    },
    {
        "content": "<p>but to be honest, probably no</p>",
        "id": 184651891,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972834
    },
    {
        "content": "<p>maybe it would be worth it to try to come up with a generator example</p>",
        "id": 184651909,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972852
    },
    {
        "content": "<p>well, basically copy/pasting mine, right? With an <code>.await</code> after the C call</p>",
        "id": 184651921,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972873
    },
    {
        "content": "<p>I mean, even with the <code>.await</code>, the example is still not very useful, because the non-local code can't do anything with the <code>ptr</code> in your example</p>",
        "id": 184652006,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972945
    },
    {
        "content": "<p>except for passing it around</p>",
        "id": 184652014,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972954
    },
    {
        "content": "<p>only under my proposal, right?</p>",
        "id": 184652021,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972964
    },
    {
        "content": "<p>right</p>",
        "id": 184652024,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972967
    },
    {
        "content": "<p>with my proposal, the non-local code can read/write to the value, so its stack cannot be reused</p>",
        "id": 184652035,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577972980
    },
    {
        "content": "<p>right, exactly</p>",
        "id": 184652040,
        "sender_full_name": "simulacrum",
        "timestamp": 1577972987
    },
    {
        "content": "<p>but that's useful</p>",
        "id": 184652053,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973001
    },
    {
        "content": "<p>you can at least read or write to the value, and re-initialize it to something else if you want</p>",
        "id": 184652099,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973016
    },
    {
        "content": "<p>I would personally want to say that we should have a model which says that reading from such a value is not defined</p>",
        "id": 184652122,
        "sender_full_name": "simulacrum",
        "timestamp": 1577973049
    },
    {
        "content": "<p>but I would be okay saying that writing to it is</p>",
        "id": 184652134,
        "sender_full_name": "simulacrum",
        "timestamp": 1577973063
    },
    {
        "content": "<p>i'm not opposed to that, but i'd prefer to balance optimizations with specification simplicity</p>",
        "id": 184652158,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973088
    },
    {
        "content": "<p>that basically means that we can reuse the stack slot for other values, without \"cleaning up\" after ourselves, so long as we can see that the code is not using it</p>",
        "id": 184652163,
        "sender_full_name": "simulacrum",
        "timestamp": 1577973097
    },
    {
        "content": "<p>if there are optimizations that are worth performing, then we should try to do so</p>",
        "id": 184652168,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973103
    },
    {
        "content": "<p>I think a model which says <code>ptr::drop_in_place</code> leaves the place in an invalid state, but does not invalidate the place itself (i.e., the pointer points to 'usable' memory) is pretty straightforward</p>",
        "id": 184652245,
        "sender_full_name": "simulacrum",
        "timestamp": 1577973166
    },
    {
        "content": "<p>If <code>ptr::drop_in_place(ptr)</code> \"desugars\" to <code>Drop::drop(&amp;mut *ptr)</code>, then I think reasoning about it is quite simple, because everything else users have to know about <code>Drop::drop</code> and pointers and values just translates to it</p>",
        "id": 184652251,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973180
    },
    {
        "content": "<p>Like, that desugaring implies that the value behind <code>ptr</code> must be valid before the <code>ptr::drop_in_place</code> call, that it is left in a valid state, so reading / writing to it using <code>ptr::{read,write}</code> is ok, etc.</p>",
        "id": 184652291,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973233
    },
    {
        "content": "<p>The only reason <code>drop_in_place</code> is unsafe is because <code>Drop::drop</code> does not necessarily leave the value in a \"safe\" state</p>",
        "id": 184652345,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973253
    },
    {
        "content": "<p>okay, but then I would argue that we should have changed (or should change, if we can) ptr::drop_in_place to take <code>&amp;mut T</code></p>",
        "id": 184652385,
        "sender_full_name": "simulacrum",
        "timestamp": 1577973312
    },
    {
        "content": "<p>It means that we don't have to make <code>drop_in_place</code> a \"special\" primitive, and that we don't have to add a new state for a \"dropped\" value to the abstract machine</p>",
        "id": 184652392,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973318
    },
    {
        "content": "<blockquote>\n<p>okay, but then I would argue that we should have changed (or should change, if we can) ptr::drop_in_place to take &amp;mut T</p>\n</blockquote>\n<p>+1</p>",
        "id": 184652398,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973328
    },
    {
        "content": "<p>Like, I at least have no idea why this isn't the case</p>",
        "id": 184652407,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973339
    },
    {
        "content": "<p>I mean, I guess the only reason might be ergonomics, as in, one typically uses <code>ptr::drop_in_place</code> when working with raw pointers.</p>",
        "id": 184652468,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973367
    },
    {
        "content": "<p>and a reference coerces to one, so the current API works for both cases</p>",
        "id": 184652482,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973388
    },
    {
        "content": "<p>but yeah, I've had the same feeling while thinking about these issues, why doesn't <code>ptr::drop_in_place</code> take a <code>&amp;mut T</code> ?</p>",
        "id": 184652509,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577973431
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/27908\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/27908\">https://github.com/rust-lang/rust/issues/27908</a></p>",
        "id": 184653148,
        "sender_full_name": "simulacrum",
        "timestamp": 1577973966
    },
    {
        "content": "<p>Seems like basically we stabilized without answering the question</p>",
        "id": 184653201,
        "sender_full_name": "simulacrum",
        "timestamp": 1577974028
    },
    {
        "content": "<p>certainly there's some discussion about leaving the value in an invalid state</p>",
        "id": 184653332,
        "sender_full_name": "simulacrum",
        "timestamp": 1577974147
    },
    {
        "content": "<p>Thanks</p>",
        "id": 184654643,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975202
    },
    {
        "content": "<p>When they talk about \"invalidation\", I'm not sure they are using the word with the same meaning that we use now</p>",
        "id": 184654698,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975249
    },
    {
        "content": "<p>yeah, I don't think it was around then as a meaning, or at least certainly less formal</p>",
        "id": 184654708,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975266
    },
    {
        "content": "<p>Looks like they are talking more about violating the safety invariant, than the validity invariant</p>",
        "id": 184654709,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975267
    },
    {
        "content": "<p>I think we don't guarantee that <code>&amp;mut T</code> must satisfy the safety invariant, right?</p>",
        "id": 184654772,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975299
    },
    {
        "content": "<p>(Obviously we can't do anything about safety optimization wise anyway)</p>",
        "id": 184654782,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975315
    },
    {
        "content": "<p>No, I don't think so.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// I woke up today and it is only safe to create an OnlyOne(1) value.</span>\n<span class=\"k\">struct</span> <span class=\"nc\">OnlyOne</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">OnlyOne</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184654795,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975341
    },
    {
        "content": "<p>with that in mind, we could presumably make <code>fn drop_in_place(&amp;mut T)</code> safe, right?</p>",
        "id": 184654796,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975341
    },
    {
        "content": "<p>that would sort of fully answer all the questions</p>",
        "id": 184654820,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975367
    },
    {
        "content": "<p>although, actually, no</p>",
        "id": 184654827,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975385
    },
    {
        "content": "<p>since we want to guarantee it's called just the once, right?</p>",
        "id": 184654838,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975394
    },
    {
        "content": "<p>nono</p>",
        "id": 184654841,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975398
    },
    {
        "content": "<p>Safe code cannot violate the safety invariant</p>",
        "id": 184654891,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975408
    },
    {
        "content": "<p>In unsafe code, you can violate the safety invariant, as long as you restore it at the safe code boundary</p>",
        "id": 184654903,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975423
    },
    {
        "content": "<p>okay, sure, though that boundary is sort of murky I think</p>",
        "id": 184654916,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975441
    },
    {
        "content": "<p>So, e.g., </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">OnlyOne</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Self</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// safe</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Self</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184654931,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975465
    },
    {
        "content": "<p>A concrete proposal for drop_in_place then is:</p>\n<ul>\n<li>should take <code>&amp;mut T</code></li>\n<li>must leave value in a valid, but not necessarily safe, way</li>\n<li>may be UB to call twice (due to safety invariant)</li>\n</ul>",
        "id": 184654976,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975516
    },
    {
        "content": "<p>There, it would be \"ok\" for <code>new_unchecked</code> to look like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">OnlyOne</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// valid but unsafe</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\">  </span><span class=\"c1\">// Ok, returns a potentially unsafe OnlyOne</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184655028,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975537
    },
    {
        "content": "<p>sure, yes</p>",
        "id": 184655039,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975564
    },
    {
        "content": "<p>though that could be a safe function?</p>",
        "id": 184655052,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975587
    },
    {
        "content": "<p>oh, you dropped the assert, okay</p>",
        "id": 184655060,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975603
    },
    {
        "content": "<p>yeah, sorry, the assert was making the unsafe pointless</p>",
        "id": 184655068,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975621
    },
    {
        "content": "<p>In the issue you posted they discuss about adding a <code>mem::drop_in_place(&amp;mut T)</code> API</p>",
        "id": 184655122,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975651
    },
    {
        "content": "<p>We could do that, and maybe deprecate the <code>ptr::</code> one, or at least warn, don't know</p>",
        "id": 184655131,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975671
    },
    {
        "content": "<p>I think there's not much point</p>",
        "id": 184655161,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975712
    },
    {
        "content": "<p>I mean, it is not UB to call it twice</p>",
        "id": 184655173,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975731
    },
    {
        "content": "<p>A concrete proposal for drop_in_place then is:</p>\n<ul>\n<li>should take <code>&amp;mut T</code> (or be documented as such, if we don't decide to change things)</li>\n<li>must leave value in a valid, but not necessarily safe, way</li>\n<li>may be UB to call twice (due to safety invariant)</li>\n</ul>",
        "id": 184655174,
        "sender_full_name": "simulacrum",
        "timestamp": 1577975734
    },
    {
        "content": "<p>Yes, we should expand the docs on why the last point is true</p>",
        "id": 184655233,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577975765
    },
    {
        "content": "<p><code>ptr::drop_in_place</code> calls <code>Drop::drop</code> which is a safe API that is allowed to leave the value in a potentially _unsafe_ state (depending on the particular <code>Drop</code> implementation). All safe Rust APIs, including <code>Drop::drop</code> require their arguments to be in a _safe_ state, and this is why for some <code>Drop</code> implementations, double drops are unsound.</p>",
        "id": 184655513,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976100
    },
    {
        "content": "<p>AFAICT, because <code>Drop::drop</code> is safe, then <code>&amp;mut self</code> must point to a <code>self</code> that's in a safe state, and if it isn't, the program is unsound. Whether you can double drop those types would then depend on whether <code>Drop::drop</code> breaks the safety invariant or not.</p>",
        "id": 184655587,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976174
    },
    {
        "content": "<p><code>Drop::drop</code> being safe doesn't matter</p>",
        "id": 184655635,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976226
    },
    {
        "content": "<p>oh, safe state, then yes</p>",
        "id": 184655693,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976252
    },
    {
        "content": "<p>It kind of does, because safe functions don't have a <code># Safety</code> clause.</p>",
        "id": 184655694,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976252
    },
    {
        "content": "<p>though Drop::drop is notable in being able to violate the safety invariant on exit</p>",
        "id": 184655713,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976276
    },
    {
        "content": "<p>Only if it takes ownership of the value</p>",
        "id": 184655737,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976302
    },
    {
        "content": "<p>If you want to drop a value without taking ownership, then you need to use <code>ptr::drop_in_place</code>, which is unsafe for this reason.</p>",
        "id": 184655749,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976324
    },
    {
        "content": "<p>Typically this would be expressed by making <code>Drop::drop</code> unsafe..</p>",
        "id": 184655756,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976341
    },
    {
        "content": "<p>Drop::drop is special and basically unsafe</p>",
        "id": 184655838,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976414
    },
    {
        "content": "<p>Yeah</p>",
        "id": 184655853,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976429
    },
    {
        "content": "<p>I'm not sure why we need <code>ptr::drop_in_place(ptr)</code> at all</p>",
        "id": 184655888,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976450
    },
    {
        "content": "<p>Where one of the safety constraints is \"don't call me again\" by default, though some Drop::drop are less strict</p>",
        "id": 184655892,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976460
    },
    {
        "content": "<p>can't we just use <code>unsafe { Drop::drop(&amp;mut v) }</code> ?</p>",
        "id": 184655893,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976462
    },
    {
        "content": "<p>hm, well, maybe, but you can't actually call Drop::drop, the compiler won't let you</p>",
        "id": 184655944,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976495
    },
    {
        "content": "<p>(maybe it should)</p>",
        "id": 184655949,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976500
    },
    {
        "content": "<p>yes, maybe</p>",
        "id": 184655990,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976555
    },
    {
        "content": "<p>There are some other parts of the language were <code>unsafe</code> is too \"general\"</p>",
        "id": 184656002,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976570
    },
    {
        "content": "<p>And what we want to express is <code>unsafe(to_call_explicitly) fn drop(&amp;mut self) { ... }</code></p>",
        "id": 184656011,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976596
    },
    {
        "content": "<p>hm, why'd we want that? It's just unsafe period</p>",
        "id": 184656072,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976616
    },
    {
        "content": "<p>you can do unsafe things inside it</p>",
        "id": 184656103,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976664
    },
    {
        "content": "<p>Well because we don't want unsafe code inside them by default</p>",
        "id": 184656113,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976673
    },
    {
        "content": "<p>e.g. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"n\">deref</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184656126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976689
    },
    {
        "content": "<p>sure</p>",
        "id": 184656134,
        "sender_full_name": "simulacrum",
        "timestamp": 1577976708
    },
    {
        "content": "<p>I think there was an issue about requiring explicit unsafe blocks in unsafe fn, I guess for drop that would also solve it</p>",
        "id": 184656187,
        "sender_full_name": "gnzlbg",
        "timestamp": 1577976731
    },
    {
        "content": "<p><code>Drop::drop</code> is not  (primarily) unsafe to call, it's never sensible to call (outside of the compiler-generated drop glue). <code>Drop::drop</code> only handles custom per-type drop logic, not the recursive dropping of fields. So it can't replace <code>ptr::drop_in_place</code> and there's also no other reason to allow calling it manually.</p>",
        "id": 184661097,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1577980590
    },
    {
        "content": "<p>ah, that's a good point</p>",
        "id": 184661136,
        "sender_full_name": "simulacrum",
        "timestamp": 1577980626
    },
    {
        "content": "<p>I forgot about the recursive bit</p>",
        "id": 184661142,
        "sender_full_name": "simulacrum",
        "timestamp": 1577980631
    },
    {
        "content": "<blockquote>\n<p>For a type like <code>i32</code>, a double drop is not UB, according to the model being discussed here</p>\n</blockquote>\n<p>I agree, <em>if</em> we assume that uninit memory is never allowed for <code>i32</code>. But as you like to note yourself, it is not legal for code to rely on something being UB -- we might allow uninit ints in the future.</p>",
        "id": 184664415,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983228
    },
    {
        "content": "<blockquote>\n<p>I mean, if <code>ptr::drop_in_place(ptr)</code> changes the state of the memory behind <code>ptr</code>, it needs to do so by \"writting\" to that <code>ptr</code> \"somehow\"</p>\n</blockquote>\n<p>well it could do <code>*(ptr as *mut u8) = 3</code>, for example, so I don't think there is anything \"automatic\" here</p>",
        "id": 184664548,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983327
    },
    {
        "content": "<p>but IMO the <em>safety</em> contract of <code>drop</code> should prohibit that</p>",
        "id": 184664621,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983390
    },
    {
        "content": "<p>(and that is the only user-defined part of <code>drop_in_place</code>, after all)</p>",
        "id": 184664630,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983405
    },
    {
        "content": "<p>oh, sorry, discussion went on after these things but Zulip failed to load it... never mind then</p>",
        "id": 184664707,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I think <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> and I agreed on this:</p>\n<p>A concrete proposal for drop_in_place then is:</p>\n<ul>\n<li>should take <code>&amp;mut T</code> (or be documented as such, if we don't decide to change things)</li>\n<li>must leave value in a valid, but not necessarily safe, way</li>\n<li>may be UB to call twice (due to safety invariant)</li>\n</ul>",
        "id": 184665035,
        "sender_full_name": "simulacrum",
        "timestamp": 1577983693
    },
    {
        "content": "<p>which I believe is consistent with today's world</p>",
        "id": 184665052,
        "sender_full_name": "simulacrum",
        "timestamp": 1577983718
    },
    {
        "content": "<p>well, <code>drop_in_place</code> is compiler-implemented, so we can't really <em>require</em> anything for it as much as <em>guarantee</em> that it has certain properties</p>",
        "id": 184665587,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984156
    },
    {
        "content": "<p>the only place we have for making requirements is <code>Drop::drop</code></p>",
        "id": 184665637,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984165
    },
    {
        "content": "<p>not sure how I feel about it taking <code>&amp;mut</code>, I guess that could be correct but it seems weird.<br>\nthis reminds me, I think I can remove the <code>real_drop_in_place</code> again that I added a while back as a hack for earlier versions of Stacked Borrows...</p>",
        "id": 184665739,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984270
    },
    {
        "content": "<p>ah, yes, these would be the guarantees, sure</p>",
        "id": 184665849,
        "sender_full_name": "simulacrum",
        "timestamp": 1577984351
    },
    {
        "content": "<p>I think these all apply as requirements to Drop::drop too</p>",
        "id": 184665872,
        "sender_full_name": "simulacrum",
        "timestamp": 1577984370
    },
    {
        "content": "<p>(where we substitute call for \"cause to be called\" or so)</p>",
        "id": 184665890,
        "sender_full_name": "simulacrum",
        "timestamp": 1577984385
    },
    {
        "content": "<p>well the requirements are stronger there I think</p>",
        "id": 184665959,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984410
    },
    {
        "content": "<p>like, it must leave the fields in a \"drop-valid\" state... that's weaker than \"safety invariant\" but stronger than \"validity invariant\", e.g. it is wrong for <code>drop</code> to leave a field of type <code>Vec</code> in a state that is valid but unsafe (and leads to the later <code>Vec::drop</code> failing)</p>",
        "id": 184665990,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984459
    },
    {
        "content": "<p>ah, yes, that's true</p>",
        "id": 184666027,
        "sender_full_name": "simulacrum",
        "timestamp": 1577984492
    },
    {
        "content": "<p>we could approximate this with \"safety invariant of each field\" but maybe there's good use for violating that after dropping</p>",
        "id": 184666095,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984525
    },
    {
        "content": "<p>well -- one could imagine -- e.g., resetting some sort of <code>Once</code> primitive on drop so it can be reused which is technically unsafe (code relies on it being once only), but since you know you're about to drop it it's fine</p>",
        "id": 184666154,
        "sender_full_name": "simulacrum",
        "timestamp": 1577984590
    },
    {
        "content": "<p>hard to come up with examples :)</p>",
        "id": 184666161,
        "sender_full_name": "simulacrum",
        "timestamp": 1577984601
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> agreed with all you said.</p>\n<blockquote>\n<p>I agree, if we assume that uninit memory is never allowed for i32. But as you like to note yourself, it is not legal for code to rely on something being UB -- we might allow uninit ints in the future.</p>\n</blockquote>\n<p>I'm not sure I understand this claim. If we allow <code>i32</code> to become <code>uninit</code>, why wouldn't it be ok to double-drop it?</p>",
        "id": 184734128,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578058975
    },
    {
        "content": "<p>ah I guess dropping <code>uninit</code> would also be fine then... never mind then</p>",
        "id": 184750916,
        "sender_full_name": "RalfJ",
        "timestamp": 1578072172
    },
    {
        "content": "<p>What would be the best place to document this? Should I open an issue in rust-lang/rust to discuss how to add this to the Drop trait docs ?</p>",
        "id": 184761206,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578080197
    },
    {
        "content": "<p>I guess that would be a good place? is there anything drop-related in the reference or the nomicon?</p>",
        "id": 185052834,
        "sender_full_name": "RalfJ",
        "timestamp": 1578429866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> something very related just came up on reddit: <a href=\"https://www.reddit.com/r/rust/comments/eowihi/what_invariants_must_hold_to_access_an_objects/\" target=\"_blank\" title=\"https://www.reddit.com/r/rust/comments/eowihi/what_invariants_must_hold_to_access_an_objects/\">https://www.reddit.com/r/rust/comments/eowihi/what_invariants_must_hold_to_access_an_objects/</a></p>",
        "id": 185691030,
        "sender_full_name": "RalfJ",
        "timestamp": 1579089760
    },
    {
        "content": "<p>is there anywhere that we can point them to, currently?</p>",
        "id": 185691034,
        "sender_full_name": "RalfJ",
        "timestamp": 1579089770
    },
    {
        "content": "<p><del>I think that issue is simpler</del> That does look like the same issue</p>",
        "id": 185695166,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093507
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695269,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093572
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695291,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093602
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695353,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093663
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695437,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093714
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695451,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093730
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695494,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093772
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695566,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093819
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 185695589,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579093836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think we should just document this in the API docs of Drop</p>",
        "id": 185695891,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579094055
    },
    {
        "content": "<p>Document that <code>ptr::drop_in_place(ptr: *mut T)</code>:</p>\n<p>* requires exclusive access to <code>ptr</code> (as if it were an <code>&amp;mut T</code>)<br>\n  * must probably leave the memory behind pointer in a valid state</p>",
        "id": 185695990,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579094161
    },
    {
        "content": "<p>and I say probably because I'm not sure, the validity is only required if you somehow use the value afterwards:</p>",
        "id": 185696040,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579094190
    },
    {
        "content": "<p>e.g. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">GlobalAlloc</span>::<span class=\"n\">alloc</span><span class=\"p\">(..</span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"n\">enough</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">..);</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(...</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">...);</span><span class=\"w\"></span>\n<span class=\"n\">ptr</span>::<span class=\"n\">drop_in_place</span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">field_of_T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// leaked</span>\n</pre></div>",
        "id": 185696159,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579094283
    },
    {
        "content": "<p>There AFAICT it wouldn't matter if <code>drop_in_place</code> leaves a field of <code>T</code> in an invalid state, because there is no reference to that value anywhere after the call returns, only a raw pointer, which gets leaked, meaning nobody can access the memory anymore</p>",
        "id": 185696323,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579094406
    },
    {
        "content": "<p>you don't need to forget the pointer</p>",
        "id": 185713344,
        "sender_full_name": "Lokathor",
        "timestamp": 1579104959
    },
    {
        "content": "<blockquote>\n<p>must probably leave the memory behind pointer in a valid state</p>\n</blockquote>\n<p>\"<em>will</em> leave\", I assume? this is documenting the guarantees libcore provides to the user. any \"must\" clause should be added to <code>Drop::drop</code>.</p>",
        "id": 185713501,
        "sender_full_name": "RalfJ",
        "timestamp": 1579105037
    },
    {
        "content": "<p><code>ptr::drop_in_place</code> calls user-defined <code>Drop</code>s, so I don't see how <code>libcore</code> could make that guarantee, unless we require that all <code>Drop</code> implementations provide it</p>",
        "id": 185713667,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579105114
    },
    {
        "content": "<p>I think the best place to document all this is the <code>Drop</code> trait, the only thing <code>ptr::drop_in_place</code> might want to document is that the raw pointer will be used as a <code>&amp;mut T</code>, and maybe mention potential pitfalls like the one being discussed here, but all of that should also be explained in the <code>Drop</code> trait</p>",
        "id": 185713941,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579105232
    },
    {
        "content": "<blockquote>\n<p><code>ptr::drop_in_place</code> calls user-defined <code>Drop</code>s, so I don't see how <code>libcore</code> could make that guarantee, unless we require that all <code>Drop</code> implementations provide it</p>\n</blockquote>\n<p>indeed, <code>Drop</code> is the place where we will have to require whatever we need to guarantee what we document at <code>drop_in_place</code></p>",
        "id": 185729258,
        "sender_full_name": "RalfJ",
        "timestamp": 1579113518
    },
    {
        "content": "<p>but having requirements at <code>drop_in_place</code> makes no sense -- as little sense as it would for any other stdlib function</p>",
        "id": 185729298,
        "sender_full_name": "RalfJ",
        "timestamp": 1579113544
    },
    {
        "content": "<blockquote>\n<p>I think the best place to document all this is the <code>Drop</code> trait, the only thing <code>ptr::drop_in_place</code> might want to document is that the raw pointer will be used as a <code>&amp;mut T</code>, and maybe mention potential pitfalls like the one being discussed here, but all of that should also be explained in the <code>Drop</code> trait</p>\n</blockquote>\n<p>I agree it makes sense to centralize the docs</p>",
        "id": 185729312,
        "sender_full_name": "RalfJ",
        "timestamp": 1579113552
    }
]