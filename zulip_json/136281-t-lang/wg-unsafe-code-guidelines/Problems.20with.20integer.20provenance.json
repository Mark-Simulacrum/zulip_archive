[
    {
        "content": "<p>Does integers having provenance solve the problem of int&lt;-&gt;ptr transmutes and ptr-&gt;int being a side effect?</p>\n<p>It also seems to add complexity for integer optimization, but do we have a list of ones which will no longer work?</p>",
        "id": 278325026,
        "sender_full_name": "Zoxc",
        "timestamp": 1649433653
    },
    {
        "content": "<p>It does solve the problem, but it means you can no longer treat integers as equal just because they have the same value, which is pretty catastrophic AIUI</p>",
        "id": 278327326,
        "sender_full_name": "Diggsey",
        "timestamp": 1649434642
    },
    {
        "content": "<p>it's also ambiguous what is provenance of the result of various integer operations (like addition)</p>",
        "id": 278327429,
        "sender_full_name": "Diggsey",
        "timestamp": 1649434685
    },
    {
        "content": "<p>The relevant search term here is “PVI” (provenance via integers)</p>",
        "id": 278330959,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649436291
    },
    {
        "content": "<p>It's not immediately obvious to me how it is catastrophic, since you can still treat them as having the same <em>integer</em> value.</p>",
        "id": 278330960,
        "sender_full_name": "Zoxc",
        "timestamp": 1649436291
    },
    {
        "content": "<p>It prevents a lot of potential optimizations from working well</p>",
        "id": 278331040,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649436322
    },
    {
        "content": "<p><a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F</a></p>",
        "id": 278331179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649436370
    },
    {
        "content": "<p>Maybe it could work with a Sufficiently Smart Compiler (which is a bit of a well-known joke term because such a thing does not exist in practice)</p>",
        "id": 278331214,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649436389
    },
    {
        "content": "<p>I'm just asking for some specific examples to reason about.</p>",
        "id": 278331303,
        "sender_full_name": "Zoxc",
        "timestamp": 1649436428
    },
    {
        "content": "<p>the challenge that all this provenance stuff is trying to solve is that certain optimizations cannot be done even by a <em>perfect</em> compiler, because they would change observable behavior under the model</p>",
        "id": 278331349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649436447
    },
    {
        "content": "<p>Is PVI some specific model or just a generic term? I tried to google it, unsuccessfully.</p>",
        "id": 278331367,
        "sender_full_name": "Zoxc",
        "timestamp": 1649436453
    },
    {
        "content": "<p>It's a class of models considered in the paper on C pointer provenance that is making the rounds</p>",
        "id": 278331458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649436487
    },
    {
        "content": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2364.pdf\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2364.pdf</a></p>",
        "id": 278331811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649436653
    },
    {
        "content": "<p>Is there a paper which discusses the tradeoffs between them? That may contain the example I'm looking for.</p>",
        "id": 278334170,
        "sender_full_name": "Zoxc",
        "timestamp": 1649437595
    },
    {
        "content": "<p>in practice the way you'd probably want to do PVI to start with is just \"do PNVI, but do an early pass turning 'obvious' ptrtoint+inttoptr pairs into something that marks it as not-an-escape\"</p>",
        "id": 278334406,
        "sender_full_name": "Talchas",
        "timestamp": 1649437696
    },
    {
        "content": "<p>(though rust codegen might still run into \"sufficiently non-obvious\" because of inserting overflow checks)</p>",
        "id": 278334561,
        "sender_full_name": "Talchas",
        "timestamp": 1649437771
    },
    {
        "content": "<p>(and also somehow dodging issues with ptr/int punning, for which you'd have some more options)</p>",
        "id": 278334795,
        "sender_full_name": "Talchas",
        "timestamp": 1649437877
    },
    {
        "content": "<p>Specifically, PVI breaks the Global Value Numbering (GVN) pass, which sees when <code>x==y</code> and can replace <code>x</code> by <code>y</code> or reversely in downstream expressions. As I understand it, it’s important for unlocking other optimization opportunities. For instance then <code>x - y</code> simplifies to <code>x - x</code>, which simplifies to <code>0</code>, which can cut a branch from an if..then..else, etc.</p>\n<p>I don’t think there’s a theoretical reason that those optimizations couldn’t be done in PVI.  Like we could replace <code>y</code> by <code>x</code> in contexts where only the number part matters. But GVN with !PVI is just a very convenient way to express those optimizations and it removes a huge complication from the compiler.</p>",
        "id": 278338331,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649439644
    },
    {
        "content": "<p>(PNVI being the term for !PVI)</p>",
        "id": 278338384,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649439673
    },
    {
        "content": "<p>Are you suggesting it would make GVN less general or that it would make GVN more complex? Certainly the latter is true, and would be expected for an integer optimization.</p>",
        "id": 278341026,
        "sender_full_name": "Zoxc",
        "timestamp": 1649440994
    },
    {
        "content": "<p>the issue is that it can affect optimization of integer operations even when pointers aren't even mentioned in the function, it just globally makes all sorts of algebraic identities not hold anymore</p>",
        "id": 278342840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649441913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116466\">Zoxc</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278341026\">said</a>:</p>\n<blockquote>\n<p>Are you suggesting it would make GVN less general or that it would make GVN more complex? Certainly the latter is true, and would be expected for an integer optimization.</p>\n</blockquote>\n<p>Pick at least one of {worse, more complex} :)</p>",
        "id": 278343753,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649442391
    },
    {
        "content": "<p>A programming language doesn't need provenance at all. Take for instance x64 assembly — it doesn't care* about silly concepts like provenance. Same with \"C without optimizations\". But typically people want a high level language that <em>also</em> compiles to run reasonably fast</p>\n<p><code>*</code> ignoring cache coherency and instruction vs. data cache for a minute</p>",
        "id": 278344072,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649442532
    },
    {
        "content": "<p>Python doesn't really have provenance either.</p>",
        "id": 278344275,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649442623
    },
    {
        "content": "<p>well, if you don't have actual numeric pointers provenance is irrelevant (and if you use python-ffi pointers, you aren't expecting fully C-like performance and optimization)</p>",
        "id": 278347829,
        "sender_full_name": "Talchas",
        "timestamp": 1649444378
    },
    {
        "content": "<p>besides what was said above, and as discussed earlier this week in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F\">the previous copy of this same discussion</a>, PVI also makes memory models a lot more complicated because defining operations like <code>+</code> when both operands have provenance is tricky (one needs to be able to form a kind of \"union provenance\"). in contrast, there is no operation that takes 2 pointers as input and creates a pointer, so provenance is always unambiguously propagated in pointer operations.</p>",
        "id": 278356532,
        "sender_full_name": "RalfJ",
        "timestamp": 1649448837
    },
    {
        "content": "<p>Is there a problem with just requiring that integer have a singular provenance like pointers? That seems like a simpler PVI model and seems to be what the C model does if I glanced it correctly (the output of + has no provenance if both inputs have provenance). Would that rule out common pointer as integer manipulations?</p>",
        "id": 278357737,
        "sender_full_name": "Zoxc",
        "timestamp": 1649449450
    },
    {
        "content": "<p>\"the C model\"? \"the C model\" arguably is PNVI-ae-udi, where integers have <em>no</em> provenance</p>",
        "id": 278358016,
        "sender_full_name": "RalfJ",
        "timestamp": 1649449632
    },
    {
        "content": "<p>the problem is deciding whether <code>+</code> gets its provenance from the left or the right operand. no matter which one you pick, <code>+</code> becomes non-commutative.</p>",
        "id": 278358050,
        "sender_full_name": "RalfJ",
        "timestamp": 1649449654
    },
    {
        "content": "<p>I meant PVI as defined here by \"the C model\", <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2364.pdf\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2364.pdf</a></p>",
        "id": 278358631,
        "sender_full_name": "Zoxc",
        "timestamp": 1649449954
    },
    {
        "content": "<blockquote>\n<p>the output of + has no provenance if both inputs have provenance</p>\n</blockquote>\n<p>so this means <code>x</code> and <code>x+0</code> are no longer equivalent</p>",
        "id": 278359217,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450300
    },
    {
        "content": "<p>ah no I guess <code>0</code> has no provenance so that still works</p>",
        "id": 278359251,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450321
    },
    {
        "content": "<p>but <code>x+(y-x)</code> is not equivalent to <code>x</code> under this model</p>",
        "id": 278359287,
        "sender_full_name": "RalfJ",
        "timestamp": 1649450341
    },
    {
        "content": "<p>also <code>x+x+...+x</code> has provenance iff there are an odd number of <code>x</code>'s, which is... odd</p>",
        "id": 278359454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649450440
    },
    {
        "content": "<p>The odd example might be fixable by preserving provenance if both inputs have the same provenance.</p>",
        "id": 278360293,
        "sender_full_name": "Zoxc",
        "timestamp": 1649450914
    },
    {
        "content": "<p>you can't do that because you probably want <code>y[(int)&amp;x[1] - (int)&amp;x[0]]</code> to work more than that case</p>",
        "id": 278360414,
        "sender_full_name": "Talchas",
        "timestamp": 1649450990
    },
    {
        "content": "<p>I think it is kind of inevitable given that provenance has no reasonable algebraic structure that anything you do will be ad hoc and unpredictable</p>",
        "id": 278360540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649451056
    },
    {
        "content": "<p>quick fixes and patches to the model don't cut it. If it's not \"obviously the only answer\" it will be difficult for programmers to work with and it will end up contributing to rust's reputation for being tricky to get unsafe code right</p>",
        "id": 278360767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649451199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278360414\">said</a>:</p>\n<blockquote>\n<p>you can't do that because you probably want <code>y[(int)&amp;x[1] - (int)&amp;x[0]]</code> to work more than that case</p>\n</blockquote>\n<p>Probably needs more integer casts to actually break, but that rule doesn't seem like a good idea for subtraction. No idea if it's useful for addition either. Adding pointers together doesn't seem like a common operation.</p>",
        "id": 278361456,
        "sender_full_name": "Zoxc",
        "timestamp": 1649451558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278359287\">said</a>:</p>\n<blockquote>\n<p>but <code>x+(y-x)</code> is not equivalent to <code>x</code> under this model</p>\n</blockquote>\n<p>I would expect <code>x+(y-x)</code> to optimize to <code>prov(x, prov_of(x+(y-x)))</code>. A \"shadow\" of the original program is carried to peek at if the integer is used as a pointer. Probably doesn't make for efficient or terribly fun to write integer optimizations though.</p>",
        "id": 278363268,
        "sender_full_name": "Zoxc",
        "timestamp": 1649452566
    },
    {
        "content": "<p>So at the IR level, we'd split up integer and provenance parts of values to allow for integer optimizations.</p>",
        "id": 278364015,
        "sender_full_name": "Zoxc",
        "timestamp": 1649452937
    },
    {
        "content": "<p>yeah I doubt that is going to make anyone happy...</p>",
        "id": 278364244,
        "sender_full_name": "RalfJ",
        "timestamp": 1649453076
    },
    {
        "content": "<p>Consider a stricter model then, where we define integer operations to be UB if they have provenance. We also add exposing for explicit casts. That makes integer optimizations much more practical. Storing pointers as integers by transmutes is still allowed, as long as you don't mess with them while they're integers.</p>",
        "id": 278410377,
        "sender_full_name": "Zoxc",
        "timestamp": 1649511097
    },
    {
        "content": "<p>If you're saying \"otherwise safe operations on <em>some</em> values of a type become not-obviously unsound\" that also seems Not Good.</p>",
        "id": 278413369,
        "sender_full_name": "Lokathor",
        "timestamp": 1649515456
    },
    {
        "content": "<p>You'd need to be able to transmute a pointer to integer in safe code for it to be bad though.</p>",
        "id": 278413795,
        "sender_full_name": "Zoxc",
        "timestamp": 1649515973
    },
    {
        "content": "<p>that would make a lot of real world code UB, including some things that are defined by strict provenance with the current set of epicycles: if you transmute a pointer to an integer and then add 3 then you will get an integer value, but your proposal would make it UB</p>",
        "id": 278414455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649516964
    },
    {
        "content": "<p>With strict provenance the transmute would be immediately UB. You need to use <code>addr()</code> there.</p>",
        "id": 278414564,
        "sender_full_name": "Zoxc",
        "timestamp": 1649517112
    },
    {
        "content": "<p>My aim here is to delay the UB until you actually use it as an integer.</p>",
        "id": 278414616,
        "sender_full_name": "Zoxc",
        "timestamp": 1649517143
    },
    {
        "content": "<p>I believe the transmute acts like <code>addr()</code>, there is no cost in doing so so I don't see a need for it to be UB</p>",
        "id": 278414777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649517364
    },
    {
        "content": "<p>the problematic one is to make it act like <code>expose_addr()</code></p>",
        "id": 278414790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649517402
    },
    {
        "content": "<p>(well, it's not strictly the same as <code>addr()</code> if usize != uintptr_t)</p>",
        "id": 278414824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649517467
    },
    {
        "content": "<p>I assumed based on <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286</a> that we'd need the transmutes to be UB to allow the optimizations we'd want.</p>",
        "id": 278415070,
        "sender_full_name": "Zoxc",
        "timestamp": 1649517799
    },
    {
        "content": "<p>We can't add UB to this code because it is all safe, which as far as I can tell is what you're suggesting</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">some_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278416224,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649519472
    },
    {
        "content": "<p>Arithmetic on integers created from pointers is extremely widespread currently to do alignment checks</p>",
        "id": 278416290,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649519539
    },
    {
        "content": "<p>The cast would strip provenance so that's fine. Only transmutes and type punning preserves that.</p>",
        "id": 278416425,
        "sender_full_name": "Zoxc",
        "timestamp": 1649519688
    },
    {
        "content": "<p>So this function executes UB depending on how I got the integer:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I can't point to any particular rule that this is breaking, but this just seems like really bad API design. It reminds me of the crates which are never used without UB but the authors dance around \"but it's technically sound\" because they made everything <code>unsafe fn</code>.</p>",
        "id": 278417020,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649520395
    },
    {
        "content": "<p>I suppose that is to say, that I don't think an <code>unsafe fn</code>'s requirements should extend to what safe code does with what it returns</p>",
        "id": 278417047,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649520464
    },
    {
        "content": "<p>We kind of have things like already that on the LLVM IR level with poison values.</p>",
        "id": 278418768,
        "sender_full_name": "Zoxc",
        "timestamp": 1649522659
    },
    {
        "content": "<p>But also you cannot claim that your API is safe if it returns integer values with provenance, because they must support any possible use from safe code without UB.</p>",
        "id": 278418806,
        "sender_full_name": "Zoxc",
        "timestamp": 1649522730
    },
    {
        "content": "<p>UB in an IR is quite different</p>",
        "id": 278419260,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649523292
    },
    {
        "content": "<p>One issue with UB in integer operations is that it becomes illegal to <em>introduce</em> integer operations on integer values, i.e. transforming <code>x</code> to <code>x + 0</code> if <code>x: usize</code> is a parameter</p>",
        "id": 278419471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649523560
    },
    {
        "content": "<p>or more realistically, lifting an addition or other integer operation from inside a loop</p>",
        "id": 278419488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649523588
    },
    {
        "content": "<p>which I think is a pretty important optimization</p>",
        "id": 278419494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649523598
    },
    {
        "content": "<p>in fact I think the whole reason <code>poison</code> exists is to allow exactly this kind of loop invariant code motion for operations that would otherwise need to cause UB</p>",
        "id": 278419628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649523675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278419488\">said</a>:</p>\n<blockquote>\n<p>or more realistically, lifting an addition or other integer operation from inside a loop</p>\n</blockquote>\n<p>Isn't that fixed by defining integer operations to be <code>poison</code> on the LLVM IR level if provenance is involved?</p>",
        "id": 278420151,
        "sender_full_name": "Zoxc",
        "timestamp": 1649524320
    },
    {
        "content": "<p>It's certainly fine to have sound operations be unsound if you pass them \"impossible\" data as long as the impossible data can only be made unsafely. That's how library UB works with <code>&amp;str</code> after all, so I don't want us to think that we must reject the idea entirely.</p>\n<p>However, with <em>math on integers</em> being the operations in question... that just seems like it's just going too far.</p>",
        "id": 278421006,
        "sender_full_name": "Lokathor",
        "timestamp": 1649525384
    },
    {
        "content": "<p>Can you explain the library UB with <code>&amp;str</code> more? As far as I can tell, the only issue with <code>&amp;str</code> is doing a <code>from_utf8_unchecked</code> with something that is not actually UTF-8, but that's defined as a <em>precondition</em> of the function, which is very different to my mind. The UB is documented to occur at the call to <code>from_utf8_unchecked</code>, regardless of what you do afterwards.</p>",
        "id": 278421180,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649525585
    },
    {
        "content": "<p>A <code>&amp;str</code> value should always be utf8, but it <em>can</em> contain non-utf8 bytes, and it's \"just\" library UB to actually call any function that accepts a <code>&amp;str</code> value while it contains malformed data.</p>\n<p>Example: the intermediate steps of zeroing out a string that contains a 4 byte emoji to be four \\0 values aren't themselves UB, even though it has to travel through an illegal state to get between two legal states.</p>",
        "id": 278421409,
        "sender_full_name": "Lokathor",
        "timestamp": 1649525878
    },
    {
        "content": "<blockquote>\n<p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that &amp;strs are valid UTF-8.</p>\n</blockquote>\n<p>Wow that is wobbly and I do not like it one bit.</p>",
        "id": 278422289,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527059
    },
    {
        "content": "<p>are you okay with <code>NonZeroU32</code> ?</p>",
        "id": 278422372,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527166
    },
    {
        "content": "<p>Of course. It documents</p>\n<blockquote>\n<p>Creates a non-zero without checking whether the value is non-zero. This results in undefined behaviour if the value is zero.</p>\n</blockquote>",
        "id": 278422389,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527198
    },
    {
        "content": "<p>I'm starting another thread for this</p>",
        "id": 278422441,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527208
    },
    {
        "content": "<p>One neat thing is that this model would allow compressed pointers without using exposing allocations or having to add special small pointer types. Adding such special types to other models wouldn't be terribly hard though.</p>",
        "id": 278422834,
        "sender_full_name": "Zoxc",
        "timestamp": 1649527633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278414777\">said</a>:</p>\n<blockquote>\n<p>I believe the transmute acts like <code>addr()</code>, there is no cost in doing so so I don't see a need for it to be UB</p>\n</blockquote>\n<p>I dont think it should act like <code>addr</code>. there is a cost at least in terms of making it much harder to justify removing <code>x=x;</code> assignments. (the load of <code>x</code> might be a transmute, so this might store back a different list of Abstract Bytes than it loaded. this is probably still okay but it's subtle.) it also doesn't make any real-world code I know of work, so I think there is no good reason to have this complexity in the model.</p>\n<p>this is the exact same discussion at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085186517\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085186517</a> .</p>",
        "id": 278473481,
        "sender_full_name": "RalfJ",
        "timestamp": 1649603916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116466\">Zoxc</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278410377\">said</a>:</p>\n<blockquote>\n<p>Consider a stricter model then, where we define integer operations to be UB if they have provenance. We also add exposing for explicit casts. That makes integer optimizations much more practical. Storing pointers as integers by transmutes is still allowed, as long as you don't mess with them while they're integers.</p>\n</blockquote>\n<p>I hope this includes <code>==</code> in \"integer operations\", otherwise it's not enough.</p>\n<p>this <em>might</em> work. it still means you cannot optimize <code>x</code> to <code>x+0</code> (not sure if anyone would do that, but it's a footgun).<br>\nat this point you have \"values at integer type that you can literally only forward, not do anything with them\". we have a type for that in Rust: <code>MaybeUninit&lt;$int&gt;</code>. I think instead of going through hoops to let you do this with int types, we should just get everyone to use <code>MaybeUninit</code> and then the problem is equally solved.</p>",
        "id": 278473558,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604051
    },
    {
        "content": "<p>I do wonder if this would make integer types equivalent to C's <code>char</code>. I have no idea what C specifies for <code>char</code>s with provenance though.</p>",
        "id": 278473560,
        "sender_full_name": "Zoxc",
        "timestamp": 1649604055
    },
    {
        "content": "<p>Yeah, I had <code>==</code> in mind too.</p>",
        "id": 278473579,
        "sender_full_name": "Zoxc",
        "timestamp": 1649604113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116466\">Zoxc</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278473560\">said</a>:</p>\n<blockquote>\n<p>I do wonder if this would make integer types equivalent to C's <code>char</code>. I have no idea what C specifies for <code>char</code>s with provenance though.</p>\n</blockquote>\n<p>well, given a lack of a precise spec for C this is hard to say. ;) but yes, C's <code>char</code> also attempts to play the role of <code>MaybeUninit&lt;u8&gt;</code>. in Rust we dont need to let our int (or char) types do double-duty like that.</p>",
        "id": 278473618,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604126
    },
    {
        "content": "<p>Not sure how <code>MaybeUninit</code> relates, except for compressed pointers note. I guess compressed pointers can use that assuming it allows provenance. It's not an important justification. The aim here is to allow ptr&lt;-&gt;int transmutes if there's on integer operations on the pointers.</p>",
        "id": 278473847,
        "sender_full_name": "Zoxc",
        "timestamp": 1649604416
    },
    {
        "content": "<p>I think this may be better suited as a IR semantic to support legacy code than Rust. I do support making integer loads UB if they contain provenance. It gives a bit more room for compiler IRs as there are other reasonable weaker options.</p>",
        "id": 278474012,
        "sender_full_name": "Zoxc",
        "timestamp": 1649604604
    },
    {
        "content": "<p>So a question would be if this is a good idea for LLVM instead of introducing a new <code>byte</code> type?</p>",
        "id": 278474057,
        "sender_full_name": "Zoxc",
        "timestamp": 1649604718
    },
    {
        "content": "<p><code>MaybeUninit</code> is very related, also see the discussion starting at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1086218649\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1086218649</a></p>",
        "id": 278474104,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604754
    },
    {
        "content": "<p>if you want to just have \"opaque values you cant touch or compare\", you absolutely should use <code>MaybeUninit</code> in Rust as then you also support padding. uninit bytes in an integer will most likely be UB, we want to make use of those nice <code>noundef</code> attributes LLVM now has.</p>",
        "id": 278474125,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604811
    },
    {
        "content": "<p>so for Rust I see no reason (other than maybe backwards compatibility) to allow such \"opaque provenance in integer\"</p>",
        "id": 278474188,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604876
    },
    {
        "content": "<p>I think to properly support _real_ \"any data could be here\" you'd need to use <code>UnsafeCell&lt;MaybeUninit&lt;u8&gt;&gt;</code>? assuming that <code>&amp;T</code> -&gt; <code>&amp;UnsafeCell&lt;T&gt;</code> becomes allowed at some point</p>",
        "id": 278474190,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649604877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116466\">Zoxc</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278474057\">said</a>:</p>\n<blockquote>\n<p>So a question would be if this is a good idea for LLVM instead of introducing a new <code>byte</code> type?</p>\n</blockquote>\n<p>yeah that's what I was wondering. however LLVM still needs a byte type to support holding arbitrary data including undef/poison.</p>",
        "id": 278474226,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604955
    },
    {
        "content": "<p>e.g., if you implement memcpy by copying a bunch of <code>i64</code> in a loop, then if any one byte is poison, the entire <code>i64</code> chunk will become poison, which is not what you want</p>",
        "id": 278474287,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278474190\">said</a>:</p>\n<blockquote>\n<p>I think to properly support _real_ \"any data could be here\" you'd need to use <code>UnsafeCell&lt;MaybeUninit&lt;u8&gt;&gt;</code>? assuming that <code>&amp;T</code> -&gt; <code>&amp;UnsafeCell&lt;T&gt;</code> becomes allowed at some point</p>\n</blockquote>\n<p><code>UnsafeCell</code> has nothing to do with the data that could be there, but with how you (and others) access it</p>",
        "id": 278474316,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605042
    },
    {
        "content": "<p>so this is orthogonal</p>",
        "id": 278474319,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605045
    },
    {
        "content": "<p>IOW, sometimes you might need the extra <code>UnsafeCell</code>, sometimes not</p>",
        "id": 278474324,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605056
    },
    {
        "content": "<p>Yea but if im trying to support \"any data could be here\" i must conservatively assume there is an unsafe cell in the data I think</p>",
        "id": 278474413,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649605175
    },
    {
        "content": "<p>like how i must assume there might be padding or uninit memory in there so I use <code>MaybeUninit&lt;u8&gt;</code> over <code>u8</code></p>",
        "id": 278474422,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649605192
    },
    {
        "content": "<p>unsafe cell isnt a property of the data</p>",
        "id": 278474750,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605646
    },
    {
        "content": "<p>so, \"there is unsafe cell in the data\" is a category error. this statement doesnt typecheck.</p>",
        "id": 278474759,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605672
    },
    {
        "content": "<p>if you are given arbitrary data and you dont want to do shared mutable things to it, you dont need to worry about <code>UnsafeCell</code></p>",
        "id": 278474837,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278474287\">said</a>:</p>\n<blockquote>\n<p>e.g., if you implement memcpy by copying a bunch of <code>i64</code> in a loop, then if any one byte is poison, the entire <code>i64</code> chunk will become poison, which is not what you want</p>\n</blockquote>\n<p>I may need to read up on the LangRef again. The argument here is that moving poison around (including memory) may not widen it?</p>",
        "id": 278474925,
        "sender_full_name": "Zoxc",
        "timestamp": 1649605862
    },
    {
        "content": "<p>the issue is that memcpy should not widen poison, but <code>load</code> at type <code>i64</code> does</p>",
        "id": 278474950,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605914
    },
    {
        "content": "<p>I dont _know_ if shared mutable things will be done to the data if its arbitrary data- if someone has given me an <code>&amp;T</code> and I turn that into <code>&amp;MaybeUninit&lt;u8&gt;</code> despite the fact that that <code>T</code> was <code>UnsafeCell&lt;u8&gt;</code> then i've likely broken someones lovely interior mutablility sound abstraction</p>",
        "id": 278474995,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649605944
    },
    {
        "content": "<p><code>&amp;Mutex&lt;u8&gt;</code> is probably a good example of a thing that would break if you then made an <code>&amp;[MaybeUninit&lt;u8&gt;]</code> out of it</p>",
        "id": 278475032,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649606014
    },
    {
        "content": "<p>Could <code>memcpy</code> be implemented by say something like a vector load to work around that?</p>",
        "id": 278475036,
        "sender_full_name": "Zoxc",
        "timestamp": 1649606031
    },
    {
        "content": "<blockquote>\n<p>I dont _know_ if shared mutable things will be done to the data if its arbitrary data-</p>\n</blockquote>\n<p>?!? that is just entirely orthogonal</p>",
        "id": 278475072,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606042
    },
    {
        "content": "<p>when you implement <code>memcpy</code>, you have arbitrary data but you know for sure there's no shared mutable things done to it</p>",
        "id": 278475085,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606058
    },
    {
        "content": "<p>this is a common situation</p>",
        "id": 278475087,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606063
    },
    {
        "content": "<p>\"arbitrary data\" means someone gives you a <code>T</code> and you want to turn it into <code>[MaybeUninit&lt;u8&gt;; N]</code></p>",
        "id": 278475112,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606102
    },
    {
        "content": "<p>..i am shocked that is even allowed</p>",
        "id": 278475130,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649606143
    },
    {
        "content": "<p>does that not destroy pointers on cheri?</p>",
        "id": 278475137,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649606156
    },
    {
        "content": "<p>of course if someone gives you a <code>&amp;T</code> you have to also account for whatever sharing might be going on, but at this point we're talking about the aliasing model, not ptr-int-transmutes. it's a totally independent discussion.</p>",
        "id": 278475180,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278475137\">said</a>:</p>\n<blockquote>\n<p>does that not destroy pointers on cheri?</p>\n</blockquote>\n<p>well memcpy works for them so they figured out something I guess ;)</p>",
        "id": 278475202,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278475130\">said</a>:</p>\n<blockquote>\n<p>..i am shocked that is even allowed</p>\n</blockquote>\n<p><span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> me, too. ;) but that's literally what all these discussions about transmutation the last days were all about</p>",
        "id": 278475602,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606694
    },
    {
        "content": "<p>we need <em>some</em> way to store arbitrary data in a buffer of fixed type, and then recover the original data unchanged later</p>",
        "id": 278475613,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606712
    },
    {
        "content": "<p>and some people want to use integer types for that buffer. what I keep saying is that we should use <code>MaybeUninit</code>, not integer types. let's be explicit and tell the compiler what's going on, then we'll all be happier.</p>",
        "id": 278475672,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606766
    },
    {
        "content": "<p>Would allowing casting a pointer from <code>malloc</code> to <code>&amp;mut MaybeUninit&lt;T&gt;</code> require that <code>MaybeUninit</code> is able to hold provenance?</p>",
        "id": 278484374,
        "sender_full_name": "Zoxc",
        "timestamp": 1649617614
    },
    {
        "content": "<p><code>MaybeUninit</code> is able to hold anything that can be stored in AM memory, including in particular bytes with pointer provenancce</p>",
        "id": 278484782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649618067
    },
    {
        "content": "<p>It probably make sense to make it so. I was just wondering if it possible to not have it have provenance. <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> didn't sound very confident that it did in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286</a>.</p>",
        "id": 278489234,
        "sender_full_name": "Zoxc",
        "timestamp": 1649624160
    },
    {
        "content": "<p>MaybeUninit definitely can carry provenance</p>",
        "id": 278489323,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624259
    },
    {
        "content": "<p>it would make no sense to let it be uninit but disallow provenance...</p>",
        "id": 278489328,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624269
    },
    {
        "content": "<p>not sure which of my statements in that thread you are going off of</p>",
        "id": 278489373,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624298
    },
    {
        "content": "<p><code>I think we already have that type: MaybeUninit.</code><br>\n<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-869177433\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-869177433</a></p>\n<p>That may be a statement about something more general though.</p>",
        "id": 278489513,
        "sender_full_name": "Zoxc",
        "timestamp": 1649624426
    },
    {
        "content": "<p>that sentence says that we have a type that can carry provenance</p>",
        "id": 278489638,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624579
    },
    {
        "content": "<p>not sure what \"didn't sound very confident that it did\" refers to, but to hopefully remove ambiguity -- I am pretty confident that MaybeUninit can carry provenance :)</p>",
        "id": 278489660,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624617
    },
    {
        "content": "<p>I consider <code>I think</code> to be a bit weaker than <code>I am pretty confident</code> :)</p>",
        "id": 278492084,
        "sender_full_name": "Zoxc",
        "timestamp": 1649628104
    },
    {
        "content": "<p>yeah fair. I am using different amounts of hedging over time. ;)</p>",
        "id": 278492127,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628138
    },
    {
        "content": "<p>nothing in this space is absolutely certain until the lang team blesses it</p>",
        "id": 278492129,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628152
    },
    {
        "content": "<p>however, interpreting \"I think\" as \"I am not confident that\" is also quite a stretch ;)</p>",
        "id": 278492141,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628182
    },
    {
        "content": "<p>As of now, I really cant imagine a reason for why MaybeUninit cannot hold provenance.</p>",
        "id": 278492148,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628200
    },
    {
        "content": "<p>It seems like these C \"exceptions\" are handled well for my model, <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1086706207\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1086706207</a></p>",
        "id": 278492163,
        "sender_full_name": "Zoxc",
        "timestamp": 1649628231
    },
    {
        "content": "<p>Almost at the bottom of that thread now!</p>",
        "id": 278492201,
        "sender_full_name": "Zoxc",
        "timestamp": 1649628249
    },
    {
        "content": "<p>hm now I need to re-think what I say about that in my blog post ;)</p>",
        "id": 278492322,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628472
    },
    {
        "content": "<p>and I thought I was <em>finally</em> done writing :P</p>",
        "id": 278492360,
        "sender_full_name": "RalfJ",
        "timestamp": 1649628485
    },
    {
        "content": "<p>wow that blog post got a bit longer than I expected. even longer than the previous provenance blog post. ;)<br>\nI considered splitting it into 2, but there is some constant per-blogpost cost (with the surge of discussions it often creates etc) that I want to minimize, so one big blog post it is...</p>",
        "id": 278495933,
        "sender_full_name": "RalfJ",
        "timestamp": 1649634318
    },
    {
        "content": "<p>Maybe your blog has union provenance semantics</p>",
        "id": 278496630,
        "sender_full_name": "Zoxc",
        "timestamp": 1649635317
    },
    {
        "content": "<p>oh gosh please no dont do that to me^^</p>",
        "id": 278497241,
        "sender_full_name": "RalfJ",
        "timestamp": 1649636176
    },
    {
        "content": "<p>Speaking of increasing provenance, that's something my model doesn't generally allow since it could cause UB in integer operations.</p>",
        "id": 278498031,
        "sender_full_name": "Zoxc",
        "timestamp": 1649637260
    },
    {
        "content": "<p>ah yes, that is a good point. I am not sure if anything <em>needs</em> that (it came up in an alternative proposal for what to do on a ptr2int transmutation), but it is a kind of monotonicity one might intuitively expect.</p>",
        "id": 278498352,
        "sender_full_name": "RalfJ",
        "timestamp": 1649637804
    },
    {
        "content": "<p>Yeah, another example where that would add UB is if we decide that if some of a pointer's bytes have no provenance and some bytes have provenance, the resulting pointer gets the provenance that is there (as long as everything agrees) See here for related discussion: <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20bytes.20with.20different.20provenance\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Pointer.20bytes.20with.20different.20provenance</a> . I don't actually think we have any need to support this though, but it does pose a very interesting problem for C...</p>",
        "id": 278498956,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649638717
    },
    {
        "content": "<p>hm, actually my proposed solution of making it UB to load data with provenance at integer type also is non-monotone...</p>",
        "id": 278503596,
        "sender_full_name": "RalfJ",
        "timestamp": 1649645401
    },
    {
        "content": "<p>looks like implicitly stripping (but not exposing) provenance on load both <em>relies on</em> monotonicity (if we want to still be allowed to remove <code>x=x;</code>) but also is required to <em>achieve</em> monotonicity</p>",
        "id": 278503644,
        "sender_full_name": "RalfJ",
        "timestamp": 1649645443
    },
    {
        "content": "<p>Hold on, why is it non monotone?</p>",
        "id": 278509079,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649653378
    },
    {
        "content": "<p>I've been thinking about supporting <code>memcpy</code> with arbitrary sized integers and I have come to the conclusion that that requires loads and stores to preserve bytewise poison. It seems to be a general requirement for models where poison cannot be widened and not specific to mine.</p>\n<p>If changing loads and stores to have bitwise poison is reasonable, then my model can support such <code>memcpy</code>s. I think LLVM wants to lower <code>memcpy</code> to regular integer loads and stores which is another reason to support it besides user defined <code>memcpy</code> implementations.</p>",
        "id": 278543159,
        "sender_full_name": "Zoxc",
        "timestamp": 1649678734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278509079\">said</a>:</p>\n<blockquote>\n<p>Hold on, why is it non monotone?</p>\n</blockquote>\n<p>an integer load on data without provenance is fine. if you add provenance to it, the integer load becomes UB (or produces poison).<br>\nclearly that's not monotone, is it?</p>",
        "id": 278544640,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116466\">Zoxc</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278543159\">said</a>:</p>\n<blockquote>\n<p>I've been thinking about supporting <code>memcpy</code> with arbitrary sized integers and I have come to the conclusion that that requires loads and stores to preserve bytewise poison. It seems to be a general requirement for models where poison cannot be widened and not specific to mine.</p>\n<p>If changing loads and stores to have bitwise poison is reasonable, then my model can support such <code>memcpy</code>s. I think LLVM wants to lower <code>memcpy</code> to regular integer loads and stores which is another reason to support it besides user defined <code>memcpy</code> implementations.</p>\n</blockquote>\n<p><code>memcpy</code> should be implemented with <code>MaybeUninit&lt;$int&gt;</code> in Rust, so I assume you are talking about LLVM here.<br>\none plan that has been floated in LLVM for this is to use <code>[i8 x 8]</code> rather than <code>i64</code>. <code>[i8 x 8]</code> <em>does</em> handle poison per-byte. the \"only\" problem is that backends currently choke and produce terrible code when you write things like that.</p>",
        "id": 278544862,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679712
    },
    {
        "content": "<p>I forgot the arguments for why <code>i64</code> can only be entirely poison or not poison at all, but there were some good arguments IIRC. that's why people have been proposing the byte type to make this distinction explicit.</p>",
        "id": 278544940,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679744
    },
    {
        "content": "<p>(also you proposed multiple models, so not sure which one you are referring to with \"my model\" here)</p>",
        "id": 278544992,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278544640\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278509079\">said</a>:</p>\n<blockquote>\n<p>Hold on, why is it non monotone?</p>\n</blockquote>\n<p>an integer load on data without provenance is fine. if you add provenance to it, the integer load becomes UB (or produces poison).<br>\nclearly that's not monotone, is it?</p>\n</blockquote>\n<p>Isn't it? I suppose I don't know the definition of monotone you're using</p>",
        "id": 278545368,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649679974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278544862\">said</a>:</p>\n<blockquote>\n<p><code>memcpy</code> should be implemented with <code>MaybeUninit&lt;$int&gt;</code> in Rust, so I assume you are talking about LLVM here.<br>\none plan that has been floated in LLVM for this is to use <code>[i8 x 8]</code> rather than <code>i64</code>. <code>[i8 x 8]</code> <em>does</em> handle poison per-byte. the \"only\" problem is that backends currently choke and produce terrible code when you write things like that.</p>\n</blockquote>\n<p>Yeah I was expecting using arrays or vectors may cause some problems, even if it technically works.</p>",
        "id": 278546025,
        "sender_full_name": "Zoxc",
        "timestamp": 1649680309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278544992\">said</a>:</p>\n<blockquote>\n<p>(also you proposed multiple models, so not sure which one you are referring to with \"my model\" here)</p>\n</blockquote>\n<p>The integer operations are UB with provenance one.</p>",
        "id": 278546204,
        "sender_full_name": "Zoxc",
        "timestamp": 1649680390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278544940\">said</a>:</p>\n<blockquote>\n<p>I forgot the arguments for why <code>i64</code> can only be entirely poison or not poison at all, but there were some good arguments IIRC. that's why people have been proposing the byte type to make this distinction explicit.</p>\n</blockquote>\n<p>It seems like C's <code>char</code> would require bitwise loads at least. These arguments may also apply against <code>char</code> with the promotion to integer trick.</p>",
        "id": 278546910,
        "sender_full_name": "Zoxc",
        "timestamp": 1649680691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> by \"monotone\" I mean: is it an allowed program transformation to \"increase\" the provenance of a pointer/value, i.e., change its provenance such that it can access more memory?</p>",
        "id": 278569794,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690359
    },
    {
        "content": "<p>this is not the case if loading a value with provenance at int type is poison, since then adding provenance to a provenance-free value can introduce UB</p>",
        "id": 278569848,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690385
    },
    {
        "content": "<p>Ah, yes, I see</p>",
        "id": 278570094,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649690475
    },
    {
        "content": "<blockquote>\n<p>If changing loads and stores to have bitwise poison is reasonable, then my model can support such memcpys.</p>\n</blockquote>\n<p>In that case you'd have to even allow \"mixed provenance\" on an <code>i64</code> -- basically it has to be able to hold anything that 8 consecutive bytes in memory can hold.<br>\nif LLVM doesn't want a byte type, I think they need to do this (or make <code>[i8 x 8]</code> work better -- making codegen backends still treat this as a single 64bit register).</p>",
        "id": 278570978,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690818
    },
    {
        "content": "<p>but for a Rust discussion this is all very speculative. we'll just have to see what they end up deciding. or rather, we'll have to hope that they even consider this worth discussing at some point, and then we can be part of the discussion...</p>",
        "id": 278571054,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690857
    },
    {
        "content": "<p>given how long \"easy\" issues like <a href=\"https://bugs.llvm.org/show_bug.cgi?id=34548\">https://bugs.llvm.org/show_bug.cgi?id=34548</a> have been open, I am not extremely hopeful about LLVM moving to anything more coherently defined any time soon :(</p>",
        "id": 278571136,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690885
    },
    {
        "content": "<p>So to summarize, this seems to imply that we have two options:<br>\n a) Either we make ptr bytes at int type UB, in which case we need to ensure we have monotonicity everywhere (I don't see why not, but clearly this has surprised us at least once)<br>\n b) Or ptr to int strips provenance, in which case... we also need to ensure that we have monotonicity everywhere else</p>",
        "id": 278571522,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649691029
    },
    {
        "content": "<p>At least this makes the question of \"which one do we want\" somewhat simpler, since we can take the monotonicity problem out of the equation</p>",
        "id": 278571842,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649691133
    },
    {
        "content": "<p>that doesnt seem right. a) implies non-monotonicity!</p>",
        "id": 278572248,
        "sender_full_name": "RalfJ",
        "timestamp": 1649691316
    },
    {
        "content": "<p>so either we make ptr bytes at int type UB and give up on monotonicity, or we make them strip provenance implicitly and then we have to be <em>sure</em> everything else is monotone</p>",
        "id": 278572409,
        "sender_full_name": "RalfJ",
        "timestamp": 1649691379
    },
    {
        "content": "<p>Ehh... yes. I got my wires crossed</p>",
        "id": 278572520,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649691436
    },
    {
        "content": "<p>Edited to fix</p>",
        "id": 278572664,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649691485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278570978\">said</a>:</p>\n<blockquote>\n<p>In that case you'd have to even allow \"mixed provenance\" on an <code>i64</code> -- basically it has to be able to hold anything that 8 consecutive bytes in memory can hold.</p>\n</blockquote>\n<p>Even ignoring poison, \"mixed provenance\" pointers and integers are fine as long as they are not dereferenced? Integer operations are unaffected compared to singular provenance.</p>",
        "id": 278575421,
        "sender_full_name": "Zoxc",
        "timestamp": 1649692609
    },
    {
        "content": "<p>if we allow uniform provenance in ints (until they are operated on) there is no reason to forbid mixed provenance, yeah</p>",
        "id": 278578148,
        "sender_full_name": "RalfJ",
        "timestamp": 1649693817
    },
    {
        "content": "<p>less sure about pointers</p>",
        "id": 278578168,
        "sender_full_name": "RalfJ",
        "timestamp": 1649693827
    },
    {
        "content": "<p>Nuno Lopes seemed to have considered a different model for bitwise poison which had problems. We'll see if he can come up with some problems.</p>",
        "id": 278698512,
        "sender_full_name": "Zoxc",
        "timestamp": 1649772869
    },
    {
        "content": "<p>If not I may try to model it in Alive2. It does seem to fit well with LLVM's existing behavior, which could make adoption easier.</p>",
        "id": 278698850,
        "sender_full_name": "Zoxc",
        "timestamp": 1649772994
    },
    {
        "content": "<p>So to solve the problem of the 3 (seemingly) correct optimizations in <a href=\"https://www.ralfj.de/blog/2020/12/14/provenance.html\">https://www.ralfj.de/blog/2020/12/14/provenance.html</a> we answer that Clang lowered the program incorrectly to LLVM IR by not using side effecting instructions for casts.</p>",
        "id": 278699385,
        "sender_full_name": "Zoxc",
        "timestamp": 1649773212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116466\">@Zoxc</span> the side-effect is not the problem in that example</p>",
        "id": 278699777,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773390
    },
    {
        "content": "<p>I may need to consider that argument more carefully :)</p>",
        "id": 278699916,
        "sender_full_name": "Zoxc",
        "timestamp": 1649773446
    },
    {
        "content": "<p>even if we had the side-effect, if LLVM optimized</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">%</span><span class=\"n\">ptr2</span><span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">ptrtoint_exposed</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">ptr</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">ptrtoint_exposed</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"o\">%</span><span class=\"n\">ptr2</span><span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">ptr</span><span class=\"w\"></span>\n</code></pre></div>\n<p>it would still be wrong</p>",
        "id": 278699930,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773453
    },
    {
        "content": "<p>are you privately chatting with Nuno or is there some public discussion I can follow somewhere?</p>",
        "id": 278700017,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773500
    },
    {
        "content": "<p>I just emailed him.</p>",
        "id": 278700164,
        "sender_full_name": "Zoxc",
        "timestamp": 1649773565
    },
    {
        "content": "<p>My point was more a general vague idea that LLVM is correct, but we lower to LLVM IR incorrectly. If this is true, could we fix miscompilations by adding dummy asm statements to casts? So force LLVM to consider them to have a side effect, and if you want fast code, use strict provenance APIs.</p>",
        "id": 278700318,
        "sender_full_name": "Zoxc",
        "timestamp": 1649773642
    },
    {
        "content": "<p>I dont think that LLVM is correct</p>",
        "id": 278700347,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773658
    },
    {
        "content": "<p><code>inttoptr(ptrtoint(_))</code> can fundamentally not be reduced away</p>",
        "id": 278700375,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773674
    },
    {
        "content": "<p>even the LLVM twinsem model doesn't allow that</p>",
        "id": 278700448,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773696
    },
    {
        "content": "<p>I dont think there is any model that allows that</p>",
        "id": 278700472,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773708
    },
    {
        "content": "<p>even if this is the non-side-effecting <code>ptrtoint</code></p>",
        "id": 278700501,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773717
    },
    {
        "content": "<p>also doing replacement of <code>==</code>-equal pointers is likewise fundamentally broken</p>",
        "id": 278700598,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773760
    },
    {
        "content": "<p>so those two things LLVM <em>has</em> to fix</p>",
        "id": 278700622,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773770
    },
    {
        "content": "<p>of course one can always add enough optimization barriers so that these LLVM bugs do not surface any more. but that doesn't fix the bugs.</p>",
        "id": 278700772,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773815
    },
    {
        "content": "<p>also if LLVM says <code>ptrtoint</code> is like Rust's <code>addr</code>, it really should add something that is like <code>expose_addr</code>. leaving it to the frontends to somehow encode that seems terrible.</p>",
        "id": 278700830,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773844
    },
    {
        "content": "<p>and that still leaves the question of whether <code>inttoptr</code> is like <code>ptr::invalid</code> or <code>ptr::from_exposed_addr</code></p>",
        "id": 278700893,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773875
    }
]