[
    {
        "content": "<p>Moving a conversation with <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> into its own thread...</p>",
        "id": 165536441,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557759662
    },
    {
        "content": "<p>The conversation was in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Slides.20for.20talk.20on.20unsafe.20rust\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Slides.20for.20talk.20on.20unsafe.20rust\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Slides.20for.20talk.20on.20unsafe.20rust</a></p>",
        "id": 165536496,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557759700
    },
    {
        "content": "<p>and was about whether we could use the drop mechanism that already exists in Rust to replace the per-address stacks that are in stacked borrows</p>",
        "id": 165536608,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557759763
    },
    {
        "content": "<p>A draft implementation (missing a lot of Rust) is at <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=90773fba2b71073841015190bc8c1fdb\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=90773fba2b71073841015190bc8c1fdb\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=90773fba2b71073841015190bc8c1fdb</a></p>",
        "id": 165536697,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557759820
    },
    {
        "content": "<p>in particular, as <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> pointed out, it's missing interior mutability, and in particular that interior mutability allows the same memory address to have multiple simultanous access modes, e.g. a <code>&amp;RefCell&lt;u32&gt;</code> may have the same address as a <code>&amp;mut u32</code>.</p>",
        "id": 165537011,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557759988
    },
    {
        "content": "<p>There's also the point of ergonomics and integration with Miri, since this introduces \"shadow drop code\" to types that don't currently have Drop, e.g. when a borrow or reborrow finishes, the metadata is updated, and this is something that Miri doesn't track.</p>",
        "id": 165537261,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557760178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> does that seem like a fair summary of where we are?</p>",
        "id": 165537283,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557760199
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 165557783,
        "sender_full_name": "RalfJ",
        "timestamp": 1557773491
    },
    {
        "content": "<p>there's also the question about <code>&amp;T</code> which is <code>Copy</code> and hence cannot be <code>Drop</code>. you proposed some non-<code>Copy</code> variant of shared references but I am unconvinced of that^^</p>",
        "id": 165557899,
        "sender_full_name": "RalfJ",
        "timestamp": 1557773554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yes, we'd need some non-copy marker for updating the metadata of memory addresses when it is dropped.</p>",
        "id": 165567222,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557780235
    },
    {
        "content": "<p>I'm looking to see how difficult it'll be to get your example with <code>RefCell</code> into the code I wrote yesterday. We'll see.</p>",
        "id": 165567307,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557780285
    },
    {
        "content": "<p>Clearly this code is all wrong: <code>Colour</code>... <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 165569266,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1557781656
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  OK, I got your example with aliased <code>RefCell</code> to go through: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4007d27c87e5b03dd1c3ff6a4fd501a6\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4007d27c87e5b03dd1c3ff6a4fd501a6\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4007d27c87e5b03dd1c3ff6a4fd501a6</a></p>",
        "id": 165588832,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557803343
    },
    {
        "content": "<p>The trick here is that a <code>RecCell&lt;T&gt;</code> has at least one more byte of memory than a <code>T</code>,  and we can use that byte to keep the metadata for the <code>RefCell&lt;T&gt;</code> separate from the metadata for the <code>T</code>.</p>",
        "id": 165588900,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557803432
    },
    {
        "content": "<p>This trick wouldn't work for <code>UnsafeCell&lt;T&gt;</code>.</p>",
        "id": 165588924,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557803487
    },
    {
        "content": "<p>Small edit to remove some dead code: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8597244d346a2e82a45a6a731f74136b\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8597244d346a2e82a45a6a731f74136b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8597244d346a2e82a45a6a731f74136b</a></p>",
        "id": 165589092,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557803575
    },
    {
        "content": "<blockquote>\n<p>The trick here is that a <code>RecCell&lt;T&gt;</code> has at least one more byte of memory than a <code>T</code>,  and we can use that byte to keep the metadata for the <code>RefCell&lt;T&gt;</code> separate from the metadata for the <code>T</code>.</p>\n</blockquote>\n<p>so, the model needs to specifically know <code>RefCell</code> and color it differently?</p>",
        "id": 165598931,
        "sender_full_name": "RalfJ",
        "timestamp": 1557817933
    },
    {
        "content": "<p>Stacked Borrows does need to know (for shared references only) whether something is inside an <code>UnsafeCell</code> or not, that is inevitable -- but the model cannot have any idea about the fact that <code>RefCell</code>'s borrow counter has anything to do with that. in fact, that one is in an <code>UnsafeCell</code> as well, so it should get the exact same treatment.</p>",
        "id": 165598986,
        "sender_full_name": "RalfJ",
        "timestamp": 1557818032
    },
    {
        "content": "<p>the goal of this model is to enable the compiler to do better program analysis (alias analysis specifically). I dont think that can work if the model is customizable with user code -- then the compiler has to understand that user code to know what information it can even deduce.</p>",
        "id": 165599070,
        "sender_full_name": "RalfJ",
        "timestamp": 1557818130
    },
    {
        "content": "<p>OK, so to treat this properly, I'd need to implement a <code>MyRefCell&lt;T&gt;</code> in order to get at the private fields of the ref cell, one of which would be an <code>UnsafeCell&lt;T&gt;</code>.</p>",
        "id": 165625562,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557843175
    },
    {
        "content": "<p>My guess is that this is doable, using the same sort of model as before, that <code>cell.get()</code> will put down a marker whose drop code will update the metadata.</p>",
        "id": 165625764,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557843329
    },
    {
        "content": "<p>It might not even need that, the markers for casting <code>*mut T</code> to <code>&amp;T</code> or <code>&amp;mut T</code> might be enough, we'll see.</p>",
        "id": 165626339,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557843735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'll have a shot at this tonight.</p>",
        "id": 165626361,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557843756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> BTW, thanks for walking this through with me, it's really helping me to understand stacked borrows!</p>",
        "id": 165626430,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557843831
    },
    {
        "content": "<p>I'm curious where it'll lead. :D And maybe there is some kind of equivalence or so, maybe some way to justify some of my arbitrary decisions.</p>\n<p>But I also have to say that I personally don't like \"ghost code\"-style stuff. I've held this opinion mostly as a matter of principle for some time, and then recently in my research we did \"ghost code\"-style stuff for the first time... and it's awful, I see myself 100% confirmed. So I think if a more complex \"instrumented state\" like a stack lets us avoid having to insert code in complex ways, I think that alone would be totally worth it.</p>",
        "id": 165627804,
        "sender_full_name": "RalfJ",
        "timestamp": 1557844746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yeah, there may be a trade-off where the metadata can be made simpler but at the cost of introducing ghost code.</p>",
        "id": 165632135,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557847842
    },
    {
        "content": "<p>basically, you are encoding the stack implicitly in the well-nested control flow / RAII you are introducing</p>",
        "id": 165632280,
        "sender_full_name": "RalfJ",
        "timestamp": 1557847931
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Miri does have StorageLive / Storage</p>",
        "id": 165632604,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848183
    },
    {
        "content": "<p>Dead</p>",
        "id": 165632612,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848189
    },
    {
        "content": "<p>it does</p>",
        "id": 165632617,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848197
    },
    {
        "content": "<p>We could hang metadata updates on those.</p>",
        "id": 165632626,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848207
    },
    {
        "content": "<p>that doesnt really help for heap-allocated stuff though</p>",
        "id": 165632632,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848216
    },
    {
        "content": "<p>also, not all variables have these annotations</p>",
        "id": 165632653,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yeah, there's probably cases of, e.g. &amp;mut to &amp;, conversions that don't end up being tracked by Miri :/</p>",
        "id": 165632795,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848331
    },
    {
        "content": "<p>and even then, I feel it is better to tell people \"your reference is considered live until it is used the last time\" rather than \"your reference is considered live until a point which the compiler magically determines and which you cannot see\". I am also worried about how this would permanently fix where we put these \"end of life\"-annotations; moving them either way could break code.</p>",
        "id": 165632825,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> stacked borrows has that a reference is considered live until a use of an earlier reference?</p>",
        "id": 165632982,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848451
    },
    {
        "content": "<p>e.g. in <code>let x = &amp;mut 37; { let y = &amp;*x; ... } *x += 1;</code> it's the use of <code>x</code> that ends the lifetime of <code>y</code>?</p>",
        "id": 165633131,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848537
    },
    {
        "content": "<p>I'd say it is considered \"live\" until it is used the last time</p>",
        "id": 165633146,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848554
    },
    {
        "content": "<p>and then using an earlier reference while the child is still live is UB</p>",
        "id": 165633160,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848563
    },
    {
        "content": "<p>but there are many ways to say the same thing here</p>",
        "id": 165633166,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848570
    },
    {
        "content": "<p>and to be fair, my characterization misplaces where the UB happens -- it happens when the child gets used again, as only then we really know that it was live all along</p>",
        "id": 165633209,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848609
    },
    {
        "content": "<p>so in this view, the stack tracks \"pointers that are allowed to still be live\"</p>",
        "id": 165633279,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848651
    },
    {
        "content": "<p>yes, the question is where that stack lives,</p>",
        "id": 165633301,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848676
    },
    {
        "content": "<p>in stacked borrows each memory address has its own stack,</p>",
        "id": 165633328,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848691
    },
    {
        "content": "<p>I prefer this view when explaining conflicts to people: \"see, you have this pointer here that you used again there, so clearly it was live all the time, but then there is this other conflicting access that happened while the pointer was live\"</p>",
        "id": 165633362,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848706
    },
    {
        "content": "<p>it would be nice if we could use the call stack for this.</p>",
        "id": 165633373,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848721
    },
    {
        "content": "<blockquote>\n<p>it would be nice if we could use the call stack for this.</p>\n</blockquote>\n<p>fair</p>",
        "id": 165633410,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848756
    },
    {
        "content": "<p>but given that it's not even really a stack any more, I doubt that</p>",
        "id": 165633477,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848784
    },
    {
        "content": "<p>I am inserting and removing \"in the middle\" on a few occasions and found no way around that</p>",
        "id": 165633492,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848804
    },
    {
        "content": "<p>Is it interior mutability that causes those updates \"in the middle\"?</p>",
        "id": 165633542,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557848844
    },
    {
        "content": "<p>the example I posted with aliasing mutable/shared refs is one case</p>",
        "id": 165633676,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848941
    },
    {
        "content": "<p>two-phase borrows is another</p>",
        "id": 165633684,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848944
    },
    {
        "content": "<p>there are probably more but I am not sure</p>",
        "id": 165633693,
        "sender_full_name": "RalfJ",
        "timestamp": 1557848950
    },
    {
        "content": "<p>OK, I'll have a look at 2-phase borrows.</p>",
        "id": 165634020,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557849151
    },
    {
        "content": "<p>I'll get a chance to think about this tonight.</p>",
        "id": 165634048,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557849175
    },
    {
        "content": "<p>Hopefully.</p>",
        "id": 165634055,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557849181
    },
    {
        "content": "<p>what would help me in understanding this is: (a) some kind of trace of what is going on in that RefCell thing -- like, annotating the code with how the colour changes, or so. I find that had to extract from the implementation. (b) some kind of argument along the lines of <a href=\"https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html#5-key-properties\" target=\"_blank\" title=\"https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html#5-key-properties\">https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html#5-key-properties</a>: why do the checks that you are inserting <em>guarantee</em> that some unknown code does not mess with our memory?</p>",
        "id": 165635422,
        "sender_full_name": "RalfJ",
        "timestamp": 1557849964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> a trace should be pretty easy. A proof of correctness might be a bit trickier :)</p>",
        "id": 165640218,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557853238
    },
    {
        "content": "<p>well, I was more thinking of a reasonable argument than a full formal proof. ;)</p>",
        "id": 165640909,
        "sender_full_name": "RalfJ",
        "timestamp": 1557853731
    },
    {
        "content": "<p>I wouldn't call what I got in that blog post a proof, that's a proof sketch at best.^^</p>",
        "id": 165640936,
        "sender_full_name": "RalfJ",
        "timestamp": 1557853748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> fair enough.</p>",
        "id": 165641369,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557854040
    },
    {
        "content": "<p>I reliazed that if we think of <code>&amp;T</code> as being a refcounting type where the refcount is metadata then we get a very simple model (the metadata for each byte is the same as for <code>Rc&lt;u8&gt;</code>). <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0bc4a04c1186ee641450be1b03aaa031\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0bc4a04c1186ee641450be1b03aaa031\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0bc4a04c1186ee641450be1b03aaa031</a></p>",
        "id": 165739525,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557944459
    },
    {
        "content": "<p>Does suffer from the same problem as before, which is that we have to think of <code>&amp;T</code> as a type which implements <code>Clone</code> and <code>Drop</code>, even though those only update the metadata.</p>",
        "id": 165739659,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557944543
    },
    {
        "content": "<p>But the model is really really simple.</p>",
        "id": 165739677,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557944556
    },
    {
        "content": "<p>Oh, and I've not looked at <code>UnsafeCell</code> yet, I don't thiiiiiink there's anything more needed, but devil in the details.</p>",
        "id": 165739772,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557944629
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ^</p>",
        "id": 165739786,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557944640
    },
    {
        "content": "<p>Hmm, in fact there may be a way to implement all of this in safe rust (except for the casts from <code>*T</code> to <code>*U</code> which are blatantly unsafe).</p>",
        "id": 165740520,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557945079
    },
    {
        "content": "<p>This reminds me of ECSs, in that it implements refcounting, but keeps all the refcounts together. I wonder if there's an implementation of an arena that already does this?</p>",
        "id": 165740795,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557945243
    },
    {
        "content": "<blockquote>\n<p>I reliazed that if we think of &amp;T as being a refcounting type where the refcount is metadata then we get a very simple model (the metadata for each byte is the same as for Rc&lt;u8&gt;).</p>\n</blockquote>\n<p>this reminds me of some of the things I did back in 2017 with my first attempt at defining what references may and may not do. I had RwLocks back then. But unfortunately that turned out not enough when you have RefCell in RefCell in RefCell... each of them is basically a new layer of RwLock.</p>",
        "id": 165753176,
        "sender_full_name": "RalfJ",
        "timestamp": 1557953166
    },
    {
        "content": "<p>The good news is that each level of <code>RefCell</code> has at least one byte of its own data, which can be coloured independently of the contents.</p>",
        "id": 165754354,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557953938
    },
    {
        "content": "<p>I should look to see whether I can code up a <code>MyRefCell&lt;T&gt;</code> using <code>UnsafeCell&lt;T&gt;</code> and get it to fly.</p>",
        "id": 165754388,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557953978
    },
    {
        "content": "<blockquote>\n<p>The good news is that each level of <code>RefCell</code> has at least one byte of its own data, which can be coloured independently of the contents.</p>\n</blockquote>\n<p><code>RefCell</code> is just an example, this can happen without any extra data in unsafe code</p>",
        "id": 165754533,
        "sender_full_name": "RalfJ",
        "timestamp": 1557954082
    },
    {
        "content": "<p>the model cannot know where the synchronization is coming from</p>",
        "id": 165754541,
        "sender_full_name": "RalfJ",
        "timestamp": 1557954093
    },
    {
        "content": "<p>and in code like this, there is no extra byte:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">cell</span>::<span class=\"n\">UnsafeCell</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Two-phase borrows of the pointer returned by UnsafeCell::get() should not</span>\n<span class=\"c1\">// invalidate aliases.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">UnsafeCell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// We can have a unique reference</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">uniq_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">uniq_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// and then use our shared references again</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x2</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165754661,
        "sender_full_name": "RalfJ",
        "timestamp": 1557954203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I coded up your example ^ and got it to run: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8d190468b1d048261cedce9ac9b2f87c\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8d190468b1d048261cedce9ac9b2f87c\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8d190468b1d048261cedce9ac9b2f87c</a></p>",
        "id": 165759135,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557957884
    },
    {
        "content": "<p>There is an explicit <code>drop(uniq_ref)</code>, without that it UBs.</p>",
        "id": 165759182,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557957940
    },
    {
        "content": "<p>Same trade-off, simpler model, but uses <code>clone</code> and <code>drop</code>.</p>",
        "id": 165759254,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1557957986
    },
    {
        "content": "<p>I am afraid without a tracce I have no idea what is going on :/ it would take forever to dig through that code. But I am convinced that your model inherently does not have enough state to properly model nested <code>UnsafeCell</code></p>",
        "id": 165786335,
        "sender_full_name": "RalfJ",
        "timestamp": 1557991572
    },
    {
        "content": "<p>I can have N shared refs to the outer cell and M to the inner, (and K to the 3rd nested UnsafeCell and so on) and these two \"refcounts\" must be tracked separately</p>",
        "id": 165786343,
        "sender_full_name": "RalfJ",
        "timestamp": 1557991590
    },
    {
        "content": "<p>I don't see that happen, so something must be missing somewhere.</p>",
        "id": 165786354,
        "sender_full_name": "RalfJ",
        "timestamp": 1557991607
    },
    {
        "content": "<p>and then what about raw pointers, do you plan to have refcounts for those as well?</p>",
        "id": 165786382,
        "sender_full_name": "RalfJ",
        "timestamp": 1557991681
    },
    {
        "content": "<p>Also I see no checks that happen on accesses? That does not seem right, sometimes the only difference between okay and UB is whether some access is a read or a write.</p>",
        "id": 165786468,
        "sender_full_name": "RalfJ",
        "timestamp": 1557991761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span>  like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// lifetime laundering</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Reading from x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...keeps y valid.</span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Writing to x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...kills y. This line is UB.</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165786562,
        "sender_full_name": "RalfJ",
        "timestamp": 1557991864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> the example does have a trace showing the colourings, are you looking for more detail?</p>",
        "id": 165818369,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019005
    },
    {
        "content": "<p>the refcounts are on memory addresses, not on values, so raw pointers don't carry refcounts, but the memory pointed to by the raw pointer does.</p>",
        "id": 165818527,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019086
    },
    {
        "content": "<p>one thing that's interesting about the refcount model is that references are just integers, all the metadata is tracked in the memory being referred to.</p>",
        "id": 165818689,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019171
    },
    {
        "content": "<p>Making the drop explicit, your example is:</p>",
        "id": 165818745,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019204
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>\n</pre></div>",
        "id": 165818746,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019205
    },
    {
        "content": "<p>sigh, <code>Enter</code> == send message, sigh</p>",
        "id": 165818782,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019226
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// lifetime laundering</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Reading from x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...keeps y valid.</span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Writing to x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...kills y. This line is UB.</span>\n<span class=\"w\">  </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// At this point we drop y</span>\n<span class=\"w\">  </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165818920,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019314
    },
    {
        "content": "<p>whereas the version that doesn't UB is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// lifetime laundering</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Reading from x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...keeps y valid.</span>\n<span class=\"w\">  </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// At this point we drop y</span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Writing to x...</span>\n<span class=\"w\">  </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165818993,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019380
    },
    {
        "content": "<p>That is, it's when the drop code runs that determines whether the behaviour is UB or not.</p>",
        "id": 165819067,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019412
    },
    {
        "content": "<p>(which brings us to the core trade-off, simpler model vs UB based on invisible shadow code)</p>",
        "id": 165819115,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019449
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> the example does have a trace showing the colourings, are you looking for more detail?</p>\n</blockquote>\n<p>d'oh, I never thought of <em>running</em> it^^</p>",
        "id": 165819606,
        "sender_full_name": "RalfJ",
        "timestamp": 1558019777
    },
    {
        "content": "<p>:)</p>",
        "id": 165819703,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558019879
    },
    {
        "content": "<blockquote>\n<p>one thing that's interesting about the refcount model is that references are just integers, all the metadata is tracked in the memory being referred to.</p>\n</blockquote>\n<p>I think that can inherently not protected against \"misbehaving\" unsafe code though... like, in</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165819822,
        "sender_full_name": "RalfJ",
        "timestamp": 1558019961
    },
    {
        "content": "<p>we want to be sure that <code>bar</code> cannot write to this memory -- but if it has a raw pointer to that memory, without having metadata in the pointer, how would the model distinguish that from using <code>x</code> to access the same memory (which is legitimate)?</p>",
        "id": 165819955,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020026
    },
    {
        "content": "<blockquote>\n<p>(which brings us to the core trade-off, simpler model vs UB based on invisible shadow code)</p>\n</blockquote>\n<p>well at this point you also have consider the pass adding the shadow code to be part of the model, in terms of complexity. and it seems that has to be quite complex. like, how would it know when exactly to drop <code>y</code> here, when lifetimes are unreliable?</p>",
        "id": 165820200,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020186
    },
    {
        "content": "<p>so re: the example you posted, why does it not colour the memory unique when I create a mutable reference? seems like <code>uniq_ref</code> is \"less unique\" than 'cell'?</p>",
        "id": 165820401,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020337
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>(which brings us to the core trade-off, simpler model vs UB based on invisible shadow code)</p>\n</blockquote>\n<p>well at this point you also have consider the pass adding the shadow code to be part of the model, in terms of complexity. and it seems that has to be quite complex. like, how would it know when exactly to drop <code>y</code> here, when lifetimes are unreliable?</p>\n</blockquote>\n<p>True, though that complexity is a lot like the existing complexity of when does <code>Drop</code> code get inserted.</p>",
        "id": 165820426,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020355
    },
    {
        "content": "<p>TBH I doubt that, drop only has to work with moves, not borrows, and it is specifically not trying to catch misbehaving unsafe code</p>",
        "id": 165820535,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020399
    },
    {
        "content": "<p>like, if you <code>drop(ptr::read(&amp;mut local))</code>, <code>local</code> will get double-dropped</p>",
        "id": 165820550,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020419
    },
    {
        "content": "<p>I said \"a lot like\" not \"exactly the same as\" :)</p>",
        "id": 165820621,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020480
    },
    {
        "content": "<p>I know :)</p>",
        "id": 165820698,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020511
    },
    {
        "content": "<p>and btw if you are looking for more testcases, I got a few at <a href=\"https://github.com/rust-lang/miri/tree/master/tests/run-pass/stacked-borrows\" target=\"_blank\" title=\"https://github.com/rust-lang/miri/tree/master/tests/run-pass/stacked-borrows\">https://github.com/rust-lang/miri/tree/master/tests/run-pass/stacked-borrows</a> and <a href=\"https://github.com/rust-lang/miri/tree/master/tests/compile-fail/stacked_borrows\" target=\"_blank\" title=\"https://github.com/rust-lang/miri/tree/master/tests/compile-fail/stacked_borrows\">https://github.com/rust-lang/miri/tree/master/tests/compile-fail/stacked_borrows</a></p>",
        "id": 165820762,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020560
    },
    {
        "content": "<p>Ta.</p>",
        "id": 165820880,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020620
    },
    {
        "content": "<p>\"Ta.\"?</p>",
        "id": 165820897,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020644
    },
    {
        "content": "<p>Thanks for the testcases.</p>",
        "id": 165820911,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020663
    },
    {
        "content": "<p>TIL: <a href=\"https://www.dict.cc/?s=Ta\" target=\"_blank\" title=\"https://www.dict.cc/?s=Ta\">https://www.dict.cc/?s=Ta</a></p>",
        "id": 165820925,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020674
    },
    {
        "content": "<p>never saw that before^^ but it says \"Br/Aus\", so I guess that explains why ;)</p>",
        "id": 165820935,
        "sender_full_name": "RalfJ",
        "timestamp": 1558020688
    },
    {
        "content": "<p>I am so unaware of what words are colloquial.</p>",
        "id": 165820946,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020708
    },
    {
        "content": "<p>I'll have another think about the refcounted memory model, hopefully tonight.</p>",
        "id": 165821271,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020957
    },
    {
        "content": "<p>I have GL errors from VR browsers to sort out atm :)</p>",
        "id": 165821341,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558020991
    },
    {
        "content": "<p>A simplified version, which keeps track of how many unique refs and shared refs exist: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7bb59a62c3713efc40b6b9d6e90e6b20\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7bb59a62c3713efc40b6b9d6e90e6b20\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7bb59a62c3713efc40b6b9d6e90e6b20</a></p>",
        "id": 165909151,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558106550
    },
    {
        "content": "<p>There's a count of unique references due to reborrowing, which increments the count of unique refs.</p>",
        "id": 165909212,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558106594
    },
    {
        "content": "<p>If they're both non-zero, that's because a <code>&amp;mut T</code> got reborrowed as a <code>&amp;T</code> (there's a <code>Frozen</code> marker put on the stack to check that there's no live <code>&amp;T</code>s when the <code>&amp;mut T</code> becomes live again).</p>",
        "id": 165909415,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558106748
    },
    {
        "content": "<p>Same objections as before... this needs to keep track of when references are cloned, reborrowed and dropped, which Miri may not be very happy about :/</p>",
        "id": 165909597,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558106864
    },
    {
        "content": "<p>But the model is very simple, and references are just integers, all the metadata is attached to memory addresses.</p>",
        "id": 165909770,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558106955
    },
    {
        "content": "<p>Next stage is probably trying more examples.</p>",
        "id": 165909877,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558107011
    },
    {
        "content": "<p>I'm going to be in SF next week for S&amp;P (hearing about Spectre and RIDL and talking about <a href=\"https://github.com/chicago-relaxed-memory/spec-eval/blob/master/doc/paper.pdf\" target=\"_blank\" title=\"https://github.com/chicago-relaxed-memory/spec-eval/blob/master/doc/paper.pdf\">https://github.com/chicago-relaxed-memory/spec-eval/blob/master/doc/paper.pdf</a>) so the next step won't be for a bit.</p>",
        "id": 165910013,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558107111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ^</p>",
        "id": 165910024,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558107119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> thanks!</p>",
        "id": 165921029,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115236
    },
    {
        "content": "<p>but this means that with nested <code>UnsafeCell</code> you do not distinguish shared references from the different levels. there's a lot of complexity there that you are just not implementing -- or maybe moving into the pass that inserts the drops? not sure.</p>",
        "id": 165921141,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115292
    },
    {
        "content": "<p>also what if the position of the drop cannot be predicted statically? let me revive one of my earlier examples where I said you have to distinguish pointers</p>",
        "id": 165921203,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115352
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// lifetime laundering</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Reading from x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...keeps y valid.</span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Writing to x...</span>\n<span class=\"w\">   </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_undecidable_function_always_returning_false</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...kills y. This line is UB.</span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>you'd have to insert <code>drop(y)</code> after the if, right? but that means there's an error because <code>x</code> gets used while <code>y</code> is still \"live\"</p>",
        "id": 165921315,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115425
    },
    {
        "content": "<blockquote>\n<p>I'm going to be in SF next week for S&amp;P (hearing about Spectre and RIDL and talking about <a href=\"https://github.com/chicago-relaxed-memory/spec-eval/blob/master/doc/paper.pdf\" target=\"_blank\" title=\"https://github.com/chicago-relaxed-memory/spec-eval/blob/master/doc/paper.pdf\">https://github.com/chicago-relaxed-memory/spec-eval/blob/master/doc/paper.pdf</a>) so the next step won't be for a bit.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span>  oh that's interesting. is that related to the \"RFUB\" (read from untaken branch) example that came up in relaxed memory discussions recently? you mention the hardware attacks but then the directory says sth about relaxed memory^^</p>",
        "id": 165921700,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115667
    },
    {
        "content": "<p>hm, no, seems unrelated. I wonder if there is a connection though...</p>",
        "id": 165921798,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115743
    },
    {
        "content": "<p>RFUB is described here: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1217r0.html\" target=\"_blank\" title=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1217r0.html\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1217r0.html</a></p>",
        "id": 165921873,
        "sender_full_name": "RalfJ",
        "timestamp": 1558115776
    },
    {
        "content": "<p>Hmm, RFUB looks interesting. There's a lot of work on speculative evaluation atm it's very hard to keep up with all of it!</p>",
        "id": 165932285,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558123625
    },
    {
        "content": "<p>The position that the refcounted borrows model takes (at least at the moment) is that <code>&amp;UnsafeCell&lt;T&gt;</code> is not tracked at all, in the same way that <code>&amp;()</code> isn't tracked.</p>",
        "id": 165932525,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558123813
    },
    {
        "content": "<p>I am sort of thinking that \"As <code>T</code> is to <code>&amp;T</code> so <code>UnsafeCell&lt;T&gt;</code> is to <code>*T</code>.</p>",
        "id": 165932650,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558123927
    },
    {
        "content": "<p>Hmm, interesting example, that would indeed be a case that refcounting as it currently stands can't handle.</p>",
        "id": 165933097,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558124292
    },
    {
        "content": "<p>I wonder if there's an optimization that refcounting borrows validates that stacked borrows doesn't?</p>",
        "id": 165933132,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558124330
    },
    {
        "content": "<p>Something like replacing:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>by:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165933297,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558124464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ^</p>",
        "id": 165933308,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558124471
    },
    {
        "content": "<p>assuming <code>*x: &amp;mut</code>, Stacked Borrows allows this</p>",
        "id": 165933651,
        "sender_full_name": "RalfJ",
        "timestamp": 1558124756
    },
    {
        "content": "<blockquote>\n<p>Hmm, RFUB looks interesting. There's a lot of work on speculative evaluation atm it's very hard to keep up with all of it!</p>\n</blockquote>\n<p>I wonder why that is... ;)</p>",
        "id": 165933883,
        "sender_full_name": "RalfJ",
        "timestamp": 1558124922
    },
    {
        "content": "<blockquote>\n<p>The position that the refcounted borrows model takes (at least at the moment) is that <code>&amp;UnsafeCell&lt;T&gt;</code> is not tracked at all, in the same way that <code>&amp;()</code> isn't tracked.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> I see. But doesn't it need tracking insofar as it gets in the way of aliasing <code>&amp;mut</code> being unique? the <code>&amp;UnsafeCell</code> itself allows all sorts of aliasing (same in Stacked Borrows), it doesnt care, but <em>others</em> care that <code>&amp;UnsafeCell</code> is not used to break <em>their</em> properties.</p>",
        "id": 165933937,
        "sender_full_name": "RalfJ",
        "timestamp": 1558124994
    },
    {
        "content": "<blockquote>\n<p>assuming <code>*x: &amp;mut</code>, Stacked Borrows allows this</p>\n</blockquote>\n<p>Er does it? Consider putting it in parallel with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 165935537,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558126182
    },
    {
        "content": "<p>argh hit return rather than shift-return!</p>",
        "id": 165935616,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558126219
    },
    {
        "content": "<p>Consider putting it in parallel with:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\">  </span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>where <code>p = (x as *mut u8)</code>.</p>",
        "id": 165935795,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558126360
    },
    {
        "content": "<p>The first is UB-free, the second has UB, so we can't consider them to be the same as far as optimization is concerned?</p>",
        "id": 165935866,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558126421
    },
    {
        "content": "<p>Or are you thinking of a different equivalence relation for \"allowed optimization\"?</p>",
        "id": 165935936,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558126453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ^</p>",
        "id": 165935976,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1558126499
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> there's a checkbox next to the Send button, \"Press Enter to send\", which you can uncheck and should help with the shift-return annoyance. Also you can edit a message, there's a menu entry in the chevron \"message actions\" thingy to the right of a message when you hover it, and also a little pencil icon which directly allows editing — I'm assuming here you're not on mobile, that is)</p>",
        "id": 165936161,
        "sender_full_name": "lqd",
        "timestamp": 1558126649
    },
    {
        "content": "<p>(you can also edit the last message you sent by hitting the \"left\" arrow key)</p>",
        "id": 166021262,
        "sender_full_name": "RalfJ",
        "timestamp": 1558268670
    },
    {
        "content": "<blockquote>\n<p>Consider putting it in parallel with:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\">  </span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>where <code>p = (x as *mut u8)</code>.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span>  WDYM \"in parallel\"? in a different thread?<br>\nI assumed <code>x</code> is a mutable ref. Having a mutable ref in scope is sufficient to permit dereferencing it, we even set an attribute in LLVM for that</p>",
        "id": 166038873,
        "sender_full_name": "RalfJ",
        "timestamp": 1558297865
    },
    {
        "content": "<p>when <code>x</code> gets in scope, it gets retagged; if another thread can write to taht location we have a data race -&gt; UB</p>",
        "id": 166038882,
        "sender_full_name": "RalfJ",
        "timestamp": 1558297909
    },
    {
        "content": "<p>Back after S&amp;P and Memorial Day...</p>",
        "id": 166716278,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050000
    },
    {
        "content": "<p>Back to the example, which was is rustc allowed to to optimize the safe code (where <code>x: &amp;mut u8</code>):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">v</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span>:\n</pre></div>\n\n\n<p>?</p>",
        "id": 166716536,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050146
    },
    {
        "content": "<p>The problem being if there is another thread with access to <code>p = (x as *mut u8)</code> and does:</p>",
        "id": 166716601,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050191
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">unsafe</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\">  </span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 166716812,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050304
    },
    {
        "content": "<p>The original has no UB, since if <code>c</code> is true, the safe code writes to <code>x</code> and the unsafe code does nothing, and vice versa if <code>c</code> is false,</p>",
        "id": 166716953,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050382
    },
    {
        "content": "<p>but the \"optimized\" version has UB since there's a race condition.</p>",
        "id": 166716993,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050410
    },
    {
        "content": "<p>it is UB to write to memory that other threads have an <code>&amp;mut</code> to</p>",
        "id": 166716998,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050416
    },
    {
        "content": "<p>that violates the exclusive nature of <code>&amp;mut</code></p>",
        "id": 166717019,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050424
    },
    {
        "content": "<p>this is just the same as having</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// it is UB if bar writes to `x`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 166717051,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> even if the <code>&amp;mut</code> isn't written to?</p>",
        "id": 166717108,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> so first, let's get concurrency out of the way. do you agree that my example is the same?</p>",
        "id": 166717140,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050486
    },
    {
        "content": "<p>all the issues arise sequentially as well</p>",
        "id": 166717144,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050490
    },
    {
        "content": "<p>imagine <code>bar(); if (c) { *x =v; } bar();</code></p>",
        "id": 166717181,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yes, the example is essentially the same,</p>",
        "id": 166717221,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050534
    },
    {
        "content": "<p>okay. and yes this is UB under current stacked borrows, precisely because we ant to be able to introduce spurious reads and to reorder around unknown function calls.</p>",
        "id": 166717302,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050566
    },
    {
        "content": "<p>the question is whether it's <code>x</code> being in scope that triggers the UB, or an access to <code>x</code> that does.</p>",
        "id": 166717309,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050570
    },
    {
        "content": "<p>like, the goal is to make reordering the <code>if (c) { *x =v; }</code> up or down both legal</p>",
        "id": 166717326,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050585
    },
    {
        "content": "<p>(assuming <code>c</code> and <code>v</code>  have no side-effects etc.)</p>",
        "id": 166717336,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050595
    },
    {
        "content": "<p>and for that we need \"<code>x</code> is in scope\" to be enough for the UB</p>",
        "id": 166717347,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050612
    },
    {
        "content": "<p>and that's why Stacked Borrows currently says it is</p>",
        "id": 166717377,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050626
    },
    {
        "content": "<p>(this is the \"retagging\" stuff from my earlier blogposts)</p>",
        "id": 166717385,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050635
    },
    {
        "content": "<p>specifically, §3 of <a href=\"https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html\" target=\"_blank\" title=\"https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html\">https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html</a></p>",
        "id": 166717411,
        "sender_full_name": "RalfJ",
        "timestamp": 1559050652
    },
    {
        "content": "<p>Do we also have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// it is UB if bar reads  from`x`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 166717799,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559050852
    },
    {
        "content": "<p>yes</p>",
        "id": 166718469,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051230
    },
    {
        "content": "<p>here's some code for you to play with: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0660fc6baf5827ae3ff94ffa80dec42a\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0660fc6baf5827ae3ff94ffa80dec42a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0660fc6baf5827ae3ff94ffa80dec42a</a></p>",
        "id": 166718746,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> so back to your example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// lifetime laundering</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Reading from x...</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...keeps y valid.</span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Writing to x...</span>\n<span class=\"w\">   </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_undecidable_function_always_returning_false</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ...kills y. This line is UB.</span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>isn't rustc allowed to hoist the read of <code>y</code> in the UB line out of the conditional?</p>",
        "id": 166718845,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559051435
    },
    {
        "content": "<p>no because it cannot prove that it will happen</p>",
        "id": 166718890,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051464
    },
    {
        "content": "<p>and <code>y</code> is not an argument to the function so rust can't know how big its \"scope\" is</p>",
        "id": 166718936,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051501
    },
    {
        "content": "<p>the optimizations above relied on the fact that these were fn arguments, which are assumed to have a \"scope\" that's at least the fn call</p>",
        "id": 166719023,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051529
    },
    {
        "content": "<p>(that's the \"barriers\"/\"protectors\" from stacked borrows)</p>",
        "id": 166719043,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> really? We're banning hoisting loads out of conditionals? This seems quite drastic!</p>",
        "id": 166719044,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559051541
    },
    {
        "content": "<p>well in C you cannot do that either unless you can prove that the load is okay</p>",
        "id": 166719081,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Can't you? I suspect a lot of C compilers do :(</p>",
        "id": 166719225,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559051645
    },
    {
        "content": "<p>though in this specific case C might be able to rule that <code>some_undecidable_function_always_returning_false</code> cannot possibly deallocate <code>y</code> and hence the load is okay. which is interesting. this will come up when figuring out how to formalize LLVM's <code>noalias</code> <em>inside</em> functions</p>",
        "id": 166719253,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> I'd be surprised if for something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">bool</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">i</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>any C compiler would hoist the load</p>",
        "id": 166719278,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051693
    },
    {
        "content": "<p>it is easy to construct miscompilations from that</p>",
        "id": 166719305,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> won't most compilers hoist loads out of a loop?</p>",
        "id": 166719381,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559051763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128323\">@Alan Jeffrey</span> they may only do that if they can either prove that the loop iterates at least once, or have another argument for why that pointer is okay</p>",
        "id": 166719610,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051924
    },
    {
        "content": "<p>this is one of the reasons why I want the aliasing stuff for all arguments even if they dont get used -- so that Rust can do such hoisting without such concerns</p>",
        "id": 166719661,
        "sender_full_name": "RalfJ",
        "timestamp": 1559051955
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yes, I was thinking of hoisting out of do-loops rather than while loops.</p>",
        "id": 166720203,
        "sender_full_name": "Alan Jeffrey",
        "timestamp": 1559052362
    },
    {
        "content": "<p>yes that's a different situation</p>",
        "id": 166720738,
        "sender_full_name": "RalfJ",
        "timestamp": 1559052733
    }
]