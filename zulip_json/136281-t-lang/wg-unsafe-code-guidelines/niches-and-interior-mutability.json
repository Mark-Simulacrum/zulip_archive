[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  in <a href=\"https://github.com/rust-lang/rust/issues/90383\">#90383</a> you <a href=\"https://github.com/rust-lang/rust/pull/90383#discussion_r738817105\">said</a> </p>\n<blockquote>\n<p>For example, for an Option&lt;Cell&lt;NonZeroI32&gt;&gt;, mutating the discriminant through a shared ref is almost certainly going to be allowed.</p>\n</blockquote>\n<p>If I'm understanding this right it would mean that:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>a</code> could be set to <code>None</code> in the call <code>f(b)</code> if <code>T</code> is <code>Cell&lt;NonZeroI32&gt;</code></p>\n<p>I think that would be a pretty bad thing to allow (it would basically make refinement types/enum-variant-type proposals impossible...) Is this discussed anywhere, I'm not sure where to look for prior convo about this ^^</p>",
        "id": 260301831,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636045212
    },
    {
        "content": "<p>I think, logically, <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">https://github.com/rust-lang/unsafe-code-guidelines/issues/84</a>, and similar arguments therein for &amp;mut T would apply. IMO, it should be valid to treat the discriminant of an <code>Option</code> as <em>logically</em> distinct from the contained value, even if, after niche-optimization, it would physically overlap in memory. So thus if you're allowed to propagate niches through <code>Cell</code>, then logically, <code>&amp;Cell</code> (or probably generally <code>&amp;UnsafeCell</code>) should assert validity like it's suggested for <code>&amp;mut</code> in that issue.</p>",
        "id": 260308052,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636047796
    },
    {
        "content": "<p>to be clear, when I said \"allowed\" I meant \"it is not UB\"</p>",
        "id": 260887925,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507531
    },
    {
        "content": "<p>so, the compiler has to cope with the fact that code might do this</p>",
        "id": 260887948,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507548
    },
    {
        "content": "<p>that is different from the standard that we apply to arbitrary safe code (UB-freedom vs soundness, basically)</p>",
        "id": 260888012,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507573
    },
    {
        "content": "<p>making code like this UB requires \"logical discriminants\" that are not stored in an actual real location in memory. I think the consequences of that are much worse than pessimising the compiler in these cases.</p>",
        "id": 260888051,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507637
    },
    {
        "content": "<p>I think the concern that I have (and which I gather others have as well) is less about pessimizing the compiler and more about increasing cognitive burden on people who don't use <code>unsafe</code>. IMO, it's reasonable for users to assume that functions are not permitted to mutate the caller's local variables that aren't passed in as reference arguments. If we declare that these functions are actually allowed, we have a logically consistent abstract machine but a more confusing language, even for users who aren't writing unsafe code and who (ostensibly, to some extent) shouldn't be expected to care about things like niches and struct layout.</p>",
        "id": 260944703,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1636518692
    },
    {
        "content": "<p>IIUC this line of thought was addressed in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84#issuecomment-711143389\">this comment</a>, which distinguishes \"failing to uphold the safety contract\" from \"causing UB\". I interpret this to mean that a function like this is \"not allowed\" in some abstract sense, but if someone writes it anyway, the abstract machine and compiler do guarantee a specific behavior.</p>\n<p>I guess that's workable, but it sort of creates a less compelling argument for library authors to uphold the safety contract. \"Your code might produce nasal demons\" (insta-UB) or \"your code might produce nasal demons in a future version of the compiler\" (relying on unspecified things, e.g. struct layout) or \"your code might produce nasal demons if used the wrong way\" (unsound APIs) all seem more convincing than \"the rust team disapproves of your code but has committed to making it work anyway\".</p>",
        "id": 260945167,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1636519260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260887948\">said</a>:</p>\n<blockquote>\n<p>so, the compiler has to cope with the fact that code might do this</p>\n</blockquote>\n<p>Which of course means I need to write an IR spec that can cobe with the fact code might do this. That's going to be a headache and a half.</p>",
        "id": 260975834,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636543342
    },
    {
        "content": "<p>I would like to hear what the consequences of \"logical discriminants\" are</p>",
        "id": 260976693,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636543865
    },
    {
        "content": "<p>Also, wouldn't requiring <code>&amp;impl !Freeze</code> to assert validity on the same conditions proposed in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">unsafe-code-guidelines#84</a> for <code>&amp;mut T</code> solve this as well?</p>",
        "id": 260977734,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636544490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260976693\">said</a>:</p>\n<blockquote>\n<p>I would like to hear what the consequences of \"logical discriminants\" are</p>\n</blockquote>\n<p>I'd like to see a proposal that can account for all the byte-level shenanigans Rust allows <em>and</em> supports \"logical discriminants\". for<br>\nThe LLVM and Rust memory model are extremely complicated already due to things like pointer provenance -- to the extend that most programmers work with simpler, wrong models. but for provenance at least we have several published papers, a thoroughly worked-out proposal for C, an implementation in an interpreter (Miri) -- we have a lot of the basics.<br>\nHaving extra logical data that does not even live at any particular address will just make this even worse, except that we currently have nothing in terms of precise sufficiently low-level proposals. We don't even know yet if all the problems ptr provenance cause can even be solved to satisfaction, so I am of the strong opinion that we should not accept any other kind of \"weird extra state\" into our semantics.</p>",
        "id": 261203431,
        "sender_full_name": "RalfJ",
        "timestamp": 1636681269
    },
    {
        "content": "<p>once someone implements them in Miri, I'd be willing to discuss logical discriminants seriously -- but the burden here IMO is on those that want more crazy things to be added to our semantics, not on the ones that try to keep the semantics precisely defined. ;)</p>",
        "id": 261203507,
        "sender_full_name": "RalfJ",
        "timestamp": 1636681341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"392468\">@Teddy Katz</span> </p>\n<blockquote>\n<p>I think the concern that I have (and which I gather others have as well) is less about pessimizing the compiler and more about increasing cognitive burden on people who don't use unsafe.</p>\n</blockquote>\n<p>what you are asking about is the contract between a safe function and its environment. this is not the same as \"no UB\", and making it precise requires a lot more machinery than a Miri-like interpreter -- it requires something like <a href=\"https://plv.mpi-sws.org/rustbelt/popl18/\">RustBelt</a>. in that contract, I am all for saying that <code>&amp;Option&lt;T&gt;</code> remains in the same invariant no matter how this data happens to be encoded on the byte level.</p>\n<blockquote>\n<p>I interpret this to mean that a function like this is \"not allowed\" in some abstract sense, but if someone writes it anyway, the abstract machine and compiler do guarantee a specific behavior.</p>\n</blockquote>\n<p>exactly.</p>",
        "id": 261203742,
        "sender_full_name": "RalfJ",
        "timestamp": 1636681620
    },
    {
        "content": "<blockquote>\n<p>I guess that's workable, but it sort of creates a less compelling argument for library authors to uphold the safety contract. </p>\n</blockquote>\n<p>the only way to avoid this is to say that it is UB to violate the safety contract. that makes UB an undecidable property which can only be precisely expressed in the most advanced program logics that we have to day. Miri could not tell you if a particular program run has UB -- nobody could. I don't think anyone wants that.</p>",
        "id": 261203878,
        "sender_full_name": "RalfJ",
        "timestamp": 1636681803
    },
    {
        "content": "<p>So, I don't see any way to avoid convincing library authors that safety matters. there <em>is</em> UB that could come from a function that mutates the enum discriminant in a wrong way, after all -- it just requires the caller to also use unsafe code. but we can always reduce it to nasal daemons. imagine some other library wrote</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">test_me</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">is_some</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">unreachable_unchecked</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This function can only cause UB if there is some library that does this kind of discriminant manipulation. so we are squarely in \"your code might produce nasal demons if used the wrong way\" (unsound APIs), I would say, and I would hope that is convincing enough.<br>\nIn other words, we don't need UB from a complicated aliasing model to make such bad mutations cause UB when used the wrong way. a complicated aliasing model with logical discriminant would make UB already happen during the execution of <code>f</code> (if <code>f</code> was such a nasty function that tried to mutate a discriminant that happens to be located inside an UnsafeCell), but even with no aliasing model <code>test_me</code> would still lead to UB for such functions, and that should be sufficient to declare such an <code>f</code> buggy.</p>",
        "id": 261204039,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682017
    },
    {
        "content": "<p>also, note that (modulo some remaining bugs) we shouldnt even ever have niches that \"leak into\" an UnsafeCell; UnsafeCell blocks niche optimizations. see <a href=\"https://github.com/rust-lang/rust/issues/87341\">https://github.com/rust-lang/rust/issues/87341</a> for more. so we don't even need \"logical discriminants\" for this, at least currently (once that bug is fixed).</p>",
        "id": 261204247,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682274
    },
    {
        "content": "<p>(on that note I realised that what I need is not actually related to interior mutability after all)</p>",
        "id": 261204302,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636682299
    },
    {
        "content": "<p>(since what I actually want is that taking an <code>&amp;mut</code> to the inside of an <code>Option</code> cant mutate the discriminant)</p>",
        "id": 261204329,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636682336
    },
    {
        "content": "<p>I'm not completely clear on whether you think <code>test_me</code> is offering an unsound API here</p>",
        "id": 261204361,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636682378
    },
    {
        "content": "<p>(and whether that answer changes if you make it <code>f: fn(&amp;mut T)</code>)</p>",
        "id": 261204374,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636682392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260977734\">said</a>:</p>\n<blockquote>\n<p>Also, wouldn't requiring <code>&amp;impl !Freeze</code> to assert validity on the same conditions proposed in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">unsafe-code-guidelines#84</a> for <code>&amp;mut T</code> solve this as well?</p>\n</blockquote>\n<p>note that that issue is mostly around \"invalid values that are never used again at the type that would make them invalid\".</p>\n<p>thus Zulip discussion is related to <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/204\">https://github.com/rust-lang/unsafe-code-guidelines/issues/204</a>, not <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">unsafe-code-guidelines#84</a>, as far as I can see.</p>",
        "id": 261204521,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204361\">said</a>:</p>\n<blockquote>\n<p>I'm not completely clear on whether you think <code>test_me</code> is offering an unsound API here</p>\n</blockquote>\n<p>I think <code>test_me</code> is sound, i.e., cannot cause UB when called from safe code (and using other sound code). any way to cause UB will thus involve a bug in some unsafe code elsewhere.</p>",
        "id": 261204655,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682588
    },
    {
        "content": "<p>and I think the answer does not change when we make <code>f</code> take <code>&amp;mut T</code></p>",
        "id": 261204746,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204521\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/260977734\">said</a>:</p>\n<blockquote>\n<p>Also, wouldn't requiring <code>&amp;impl !Freeze</code> to assert validity on the same conditions proposed in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">unsafe-code-guidelines#84</a> for <code>&amp;mut T</code> solve this as well?</p>\n</blockquote>\n<p>note that that issue is mostly around \"invalid values that are never used again at the type that would make them invalid\".</p>\n<p>thus Zulip discussion is related to <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/204\">https://github.com/rust-lang/unsafe-code-guidelines/issues/204</a>, not <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">unsafe-code-guidelines#84</a>, as far as I can see.</p>\n</blockquote>\n<p>Fair, though I brought up 84 because the same thing came up there with &amp;mut T.</p>",
        "id": 261204755,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636682724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> , just to be clear, although you are okay with calling <code>test_me</code> sound you don't think the compiler should be licensed to insert that final line in <code>test_me</code> (i.e. optimizing with the knowledge that enum discriminants can't be modified through a reference to the inner field)</p>",
        "id": 261204820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636682787
    },
    {
        "content": "<p>Although... Actually, it's not quite analagous, since the niche change can be observed via an &amp;UnsafeCell holding the exterior (whereas in the &amp;mut case, it's impossible to observe the changed niche if we validate the interior before the <code>&amp;mut T</code> is invalidated)</p>",
        "id": 261204833,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636682816
    },
    {
        "content": "<p><strong>RalfJ</strong> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204746\">said</a>:</p>\n<blockquote>\n<p>and I think the answer does not change when we make <code>f</code> take <code>&amp;mut T</code></p>\n</blockquote>\n<p>So I guess it would be right to say that mutating an enum discriminant through setting an <code>&amp;mut NonZeroI32</code> to <code>0</code>, is not language UB but just semantically wrong? (not sure what the fancy term for \"semantically wrong\" is, usually i'd say safety invariant but safety invariant of <em>what</em>)</p>",
        "id": 261204839,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636682831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> yeah, it came up but <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">ucg#84</a> was not meant to be about enums -- the question it raises is independent of enums, it is just most easily demonstrated with enums (see the <code>bool</code> example in that issue). sadly the issue derailed from that quite a bit. :/<br>\nEDIT: actually it doesnt even talk much about discriminants, I might misremember.</p>",
        "id": 261204842,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204820\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> , just to be clear, although you are okay with calling <code>test_me</code> sound you don't think the compiler should be licensed to insert that final line in <code>test_me</code> (i.e. optimizing with the knowledge that enum discriminants can't be modified through a reference to the inner field)</p>\n</blockquote>\n<p>correct (in the presence of niche optimizations).</p>",
        "id": 261204846,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204839\">said</a>:</p>\n<blockquote>\n<p><strong>RalfJ</strong> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261204746\">said</a>:</p>\n<blockquote>\n<p>and I think the answer does not change when we make <code>f</code> take <code>&amp;mut T</code></p>\n</blockquote>\n<p>So I guess it would be right to say that mutating an enum discriminant through setting an <code>&amp;mut NonZeroI32</code> to <code>0</code>, is not language UB but just semantically wrong? (not sure what the fancy term for \"semantically wrong\" is, usually i'd say safety invariant but safety invariant of <em>what</em>)</p>\n</blockquote>\n<p>a function that writes 0 to a <code>&amp;mut NonZeroI32</code> is IMO <strong>unsound</strong>, even it it can do so without causing immediate UB like so:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">evil</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">NonZeroI32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>UB can still arise when combined with other code that we IMO should deem correct.</p>",
        "id": 261204931,
        "sender_full_name": "RalfJ",
        "timestamp": 1636682964
    },
    {
        "content": "<p>Oh wait, I just noticed that <code>test_me</code> is using shared references, not <code>&amp;mut</code> like in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">ucg#84</a>. Shouldn't that always be okay, because any interior mutability hides niches?</p>",
        "id": 261204944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636682995
    },
    {
        "content": "<p>it <em>should</em> hide niches but currently doesnt when unsafecell is newtyped</p>",
        "id": 261204989,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636683012
    },
    {
        "content": "<p>(additionally there's talk of allowing Cell to undo the niche hiding)</p>",
        "id": 261204992,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636683019
    },
    {
        "content": "<p>also do we want to rely on it hiding niches? in some situations that could be okay</p>",
        "id": 261204997,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683035
    },
    {
        "content": "<p>its not okay for Atomic types, but for Cell I dont know of a counterexample</p>",
        "id": 261205011,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683061
    },
    {
        "content": "<p>Ok I would sort of hope that one day <code>evil</code> will be immediate UB but I think its technically okay for it to not be for what I want to do... even if it will be sort of weird <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Perhaps one day ill muck around with miri but im not super far into what im trying to do so there would be no point right now.</p>",
        "id": 261205110,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636683173
    },
    {
        "content": "<p>what constitutes a counterexample here? This seems like unquestionably bad behavior, and the only tricky part is making it UB but still computationally feasible to determine that it is UB</p>",
        "id": 261205113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636683177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205113\">said</a>:</p>\n<blockquote>\n<p>what constitutes a counterexample here? This seems like unquestionably bad behavior, and the only tricky part is making it UB but still computationally feasible to determine that it is UB</p>\n</blockquote>\n<p>a counterexample would be causing UB from safe code (and clearly sound unsafe libraries)</p>",
        "id": 261205197,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683248
    },
    {
        "content": "<p>we have such examples for AtomicInt types when niches are not hidden (you can cause data races)</p>",
        "id": 261205201,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683264
    },
    {
        "content": "<p>I dont know an example with Cell</p>",
        "id": 261205204,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683269
    },
    {
        "content": "<p>if you have one, please share it :) (probably best on that issue)</p>",
        "id": 261205208,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683279
    },
    {
        "content": "<p>but that should be impossible, because we've agreed that this is part of the <em>safety</em> contract</p>",
        "id": 261205209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636683279
    },
    {
        "content": "<p>I dont follow?</p>",
        "id": 261205218,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683297
    },
    {
        "content": "<p>so if you use sound libraries then they are already promising to not do these shenanigans</p>",
        "id": 261205225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636683307
    },
    {
        "content": "<p>probably because I am hungry and should prepare dinner :D</p>",
        "id": 261205226,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683308
    },
    {
        "content": "<p>oh you said impossible</p>",
        "id": 261205246,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683350
    },
    {
        "content": "<p>I don't see how to cause a counterexample with atomic types either, because there is no <code>AtomicNonzeroU32</code> AFAIK</p>",
        "id": 261205250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636683354
    },
    {
        "content": "<p>so the atomic types already have no niches</p>",
        "id": 261205295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636683379
    },
    {
        "content": "<p>there was a counterxample, let me see if I can find it</p>",
        "id": 261205297,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683383
    },
    {
        "content": "<p>maybe it wasnt the Artomic types</p>",
        "id": 261205300,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683396
    },
    {
        "content": "<p>AtomicBool has niches</p>",
        "id": 261205304,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636683409
    },
    {
        "content": "<p>(presumably, nvm, its a newtyped u8! fun)</p>",
        "id": 261205305,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636683413
    },
    {
        "content": "<p><del>https://github.com/rust-lang/rust/issues/68303</del></p>",
        "id": 261205306,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683413
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/68206\">https://github.com/rust-lang/rust/issues/68206</a></p>",
        "id": 261205315,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683450
    },
    {
        "content": "<p>basically, you have an <code>Option&lt;Mutex&lt;bool&gt;&gt;</code></p>",
        "id": 261205318,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683469
    },
    {
        "content": "<p>and you do <code>is_some</code> on the outer option in one thread while acquiring the lock and mutating the bool in another thread</p>",
        "id": 261205360,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683488
    },
    {
        "content": "<p><em>logically</em> there is not even a race here (is_some will return true no matter which valid boolean the other thread writes), but for LLVM there certainly is a race here, and these days Miri should even be able to detect that.</p>",
        "id": 261205373,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683530
    },
    {
        "content": "<p>but yeah having a version of AtomicBool that does have a niche would cause the same issue</p>",
        "id": 261205397,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683582
    },
    {
        "content": "<p>The issue I have here, I believe I mentioned in either 84 or 77, but option gets represened something like this in lccc:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(Rust)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">union</span> <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"p\">[[</span><span class=\"n\">niche_optimize_candidate</span><span class=\"p\">]]</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// lcrust v0 abi, \"repr(Rust) enum layout\"</span>\n<span class=\"w\">     </span><span class=\"nb\">Some</span>:  <span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">               </span><span class=\"cp\">$discriminant</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">               </span><span class=\"n\">_0</span>: <span class=\"nc\">T</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">[[</span><span class=\"n\">niche_optimize_target</span><span class=\"p\">]]</span><span class=\"w\"> </span><span class=\"nb\">None</span>:  <span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cp\">$discriminant</span>: <span class=\"kt\">bool</span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(See <a href=\"https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/SJ1TeE0y_#reprRust-enums\">lcrust v0 abi, \"repr(Rust) enum layout\"</a>)<br>\nI'm unsure how I can have a reference/pointer to <code>Some._0</code>, then set the whole enum to <code>None</code> via that pointer (and make sure this works nicely within the model I basically need or I can't correctly impl C++ consteval, which I'd very much like to not have to duplicate)</p>",
        "id": 261205410,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636683594
    },
    {
        "content": "<p>Also, related to counterexamples, <code>Option&lt;RefCell&lt;NicheT&gt;&gt;</code> has the same issue, single-threaded.<br>\nYou can have a mutable reference to the interior and observe it via the shared reference.</p>",
        "id": 261205470,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636683639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205470\">said</a>:</p>\n<blockquote>\n<p>Also, related to counterexamples, <code>Option&lt;RefCell&lt;NicheT&gt;&gt;</code> has the same issue, single-threaded.<br>\nYou can have a mutable reference to the interior and observe it via the shared reference.</p>\n</blockquote>\n<p>yes that was the <a href=\"https://github.com/rust-lang/rust/issues/68303\">https://github.com/rust-lang/rust/issues/68303</a> that I linked first</p>",
        "id": 261205485,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683669
    },
    {
        "content": "<p>but its only UB with stacked borrows, so less clear</p>",
        "id": 261205493,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683689
    },
    {
        "content": "<p>(Interestingly, it may not be UB under lccc's model as long as it can't be used to write to the logical discriminant field. I'm pretty sure it's still UB under stacked borrows in that case, though)</p>",
        "id": 261205554,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636683771
    },
    {
        "content": "<blockquote>\n<p>The issue I have here, I believe I mentioned in either 84 or 77, but option gets represened something like this in lccc</p>\n</blockquote>\n<p>Yeah, I understand you have some rather abstract model of memory that you want to fit this to. I dont know how to explain low-level memory shenanigans in such a high-level model. I am surprised that this would only come up with discrimiants though, I would expect more friction in other places that mix the high-level and byte-level view of memory.</p>",
        "id": 261205579,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205554\">said</a>:</p>\n<blockquote>\n<p>(Interestingly, it may not be UB under lccc's model as long as it can't be used to write to the logical discriminant field. I'm pretty sure it's still UB under stacked borrows in that case, though)</p>\n</blockquote>\n<p>does that mean that the Mutex&lt;bool&gt; example would not be UB in lccc since there is not even a data race?</p>",
        "id": 261205626,
        "sender_full_name": "RalfJ",
        "timestamp": 1636683864
    },
    {
        "content": "<p>It would still be because of overlapping memory locations. A non-addressible field which has non-zero size and is not empty (which is the <code>$discriminant</code> field in a niche-optimized case) shares the same memory location as the following field. However, in the current domain, talking about <code>unique</code> (&amp;mut) and <code>readonly</code> (&amp;), it cares about objects (mostly).</p>",
        "id": 261205734,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636683982
    },
    {
        "content": "<p>if it is possible to take into account overlapping memory locations for the purpose of data races, the same should be possible for aliasing -- so maybe this could be used to 'allow' (make it not immediate UB) the kind of code you were worried about earlier?</p>",
        "id": 261205766,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684082
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/68206\">rust#68206</a> is interesting reading, and I understand the motivation for exposing niches in <code>Cell&lt;T&gt;</code> a bit better now. In that issue, they discuss a possible <code>UnsafeCellWithExposedNiches&lt;T&gt;</code> type, and actually I think that this might be enough to resolve the situation. The basic idea is that it is UB to write one of the niches of <code>T</code> via the <code>set</code> function of <code>&amp;UnsafeCellWithExposedNiches&lt;T&gt;</code></p>",
        "id": 261205808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684108
    },
    {
        "content": "<p>Yeah, the issue is how I specify that without increasing the number of ways that <code>unique</code> can overlap with <code>readonly</code> (which is currently only possible for mutable subobjects - how UnsafeCell is implemented).</p>",
        "id": 261205826,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205808\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/issues/68206\">rust#68206</a> is interesting reading, and I understand the motivation for exposing niches in <code>Cell&lt;T&gt;</code> a bit better now. In that issue, they discuss a possible <code>UnsafeCellWithExposedNiches&lt;T&gt;</code> type, and actually I think that this might be enough to resolve the situation. The basic idea is that it is UB to write one of the niches of <code>T</code> via the <code>set</code> function of <code>&amp;UnsafeCellWithExposedNiches&lt;T&gt;</code></p>\n</blockquote>\n<p>I think making it UB would be rather difficult to achieve (and I am being very British here) -- but the API contract could certainly say that this is not allowed</p>",
        "id": 261205827,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684166
    },
    {
        "content": "<p>Making it UB for that particular function should be easy, since the niches are known (for a given type <code>T</code>) and we're talking about a particular function here: this is basically just a miri-<code>assert!</code> at the entrance to the function</p>",
        "id": 261205892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684239
    },
    {
        "content": "<p>I'm not convinced interior mutability is very relevent here. The rules for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> should be the same as <code>&amp;mut T</code> if one of them doesnt conceptually contain the discriminant/be able to mutate it then neither should be able to</p>",
        "id": 261205894,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636684246
    },
    {
        "content": "<p>(I know im the one who opened the thread and it talks about interior mutability but.. yeah)</p>",
        "id": 261205903,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636684267
    },
    {
        "content": "<p>the issue with <code>&amp;mut T</code> is that you can cast a <code>&amp;mut NonzeroU8</code> to a <code>*mut u8</code> and write 0 to it</p>",
        "id": 261205937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684323
    },
    {
        "content": "<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>",
        "id": 261205971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205892\">said</a>:</p>\n<blockquote>\n<p>Making it UB for that particular function should be easy, since the niches are known (for a given type <code>T</code>) and we're talking about a particular function here: this is basically just a miri-<code>assert!</code> at the entrance to the function</p>\n</blockquote>\n<p><code>UnsafeCell</code> doesnt have a <code>set</code> function though so this seems like an odd API? I cant find that in the issue either in a very quick glance</p>",
        "id": 261205978,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684356
    },
    {
        "content": "<p>it doesn't? oops</p>",
        "id": 261205986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205937\">said</a>:</p>\n<blockquote>\n<p>the issue with <code>&amp;mut T</code> is that you can cast a <code>&amp;mut NonzeroU8</code> to a <code>*mut u8</code> and write 0 to it</p>\n</blockquote>\n<p>Well, the question is whether you can.</p>",
        "id": 261205988,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684377
    },
    {
        "content": "<p>Mario Carneiro <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971\">said</a>:</p>\n<blockquote>\n<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>\n</blockquote>\n<p>Yea, I just mean that this whole discussion can remove interior mutability imo</p>",
        "id": 261205995,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636684399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205988\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205937\">said</a>:</p>\n<blockquote>\n<p>the issue with <code>&amp;mut T</code> is that you can cast a <code>&amp;mut NonzeroU8</code> to a <code>*mut u8</code> and write 0 to it</p>\n</blockquote>\n<p>Well, the question is whether you can.</p>\n</blockquote>\n<p>well, you can write that code. the question is what it does, i.e., whether it is immediate UB. (that is indeed <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">ucg#84</a>, and not directly about enums.)</p>",
        "id": 261206012,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684428
    },
    {
        "content": "<p>Well, if <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> is only there to implement <code>Cell&lt;T&gt;</code> then it could have a <code>set</code> method instead of <code>get_mut</code>. But it's probably beside the point</p>",
        "id": 261206058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206012\">said</a>:</p>\n<blockquote>\n<p>well, you can write that code. the question is what it does, i.e., whether it is immediate UB. (that is indeed <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">ucg#84</a>, and not directly about enums.)</p>\n</blockquote>\n<p>Yes, I'm sort of presuming code is correct here when asking whether something can be done.</p>",
        "id": 261206071,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684486
    },
    {
        "content": "<p>(If it isn't correct code, then writing zero to that pointer can print potato to stdout for all I care)</p>",
        "id": 261206099,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205995\">said</a>:</p>\n<blockquote>\n<p>Mario Carneiro <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971\">said</a>:</p>\n<blockquote>\n<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>\n</blockquote>\n<p>Yea, I just mean that this whole discussion can remove interior mutability imo</p>\n</blockquote>\n<p>I think I agree -- the question is about whether, when a pointer is in principle mutable without immediate UB, if that means that writing <em>arbitrary</em> values to it is fine (not immediate UB), or whether we can have pointers where writing some values is UB but writing other values is not.</p>",
        "id": 261206140,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684565
    },
    {
        "content": "<p>at least that's how I prefer to think about it since this avoids invoking 'shadow discriminants' ;)</p>",
        "id": 261206147,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205995\">said</a>:</p>\n<blockquote>\n<p>Mario Carneiro <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261205971\">said</a>:</p>\n<blockquote>\n<p>the same issue presumably exists for <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code></p>\n</blockquote>\n<p>Yea, I just mean that this whole discussion can remove interior mutability imo</p>\n</blockquote>\n<p>Interior Mutability is kind of relevent, though. With <code>&amp;mut T</code>, you can defer the UB to later (such as before the function ends) as the problem can't be observed until after that later. With <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> the problem can be observed immediately.</p>",
        "id": 261206166,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684665
    },
    {
        "content": "<p>ah well I guess \"whether we can have pointes where writing some values is ub but other values is not\" is exactly what i want <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 261206225,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636684730
    },
    {
        "content": "<p>Using the \"equivalence\" of <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> and <code>&amp;mut T</code>, I think that means that my \"write-back\" proposal from <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">ucg#84</a> can't work at all. Those pointers have to stay good the whole time, not just at lifetime end</p>",
        "id": 261206251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636684793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206251\">said</a>:</p>\n<blockquote>\n<p>Using the \"equivalence\" of <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> and <code>&amp;mut T</code>, I think that means that my \"write-back\" proposal from <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">ucg#84</a> can't work at all. Those pointers have to stay good the whole time, not just at lifetime end</p>\n</blockquote>\n<p>yeah, that's what <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> pointed out -- if we unify both problems like that, the check has to happen on each write</p>",
        "id": 261206323,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684895
    },
    {
        "content": "<p>If we have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">miri</span>::<span class=\"n\">validate_location</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Magicly inserted function that asks whether `x` points to a vlaid `bool`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Then that's fine to have that be well-defined to panic, but</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">miri</span>::<span class=\"n\">validate_location</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Magicly inserted function that asks whether `x` points to a valid `bool`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the issue here is that the write to <code>x</code> could, in theory, affect the following if-let</p>",
        "id": 261206328,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684906
    },
    {
        "content": "<p>which might indicate maybe we shouldnt unify them, because for a <code>&amp;mut NonZeroU16</code> it seems it should be fine to temporarily make both bytes 0 as long as they are non-zero when the lifetime of the reference ends</p>",
        "id": 261206370,
        "sender_full_name": "RalfJ",
        "timestamp": 1636684933
    },
    {
        "content": "<p>We can probably still unify them, but make <code>&amp;mut T</code>'s version \"deferred\", whatever that means.</p>",
        "id": 261206381,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636684973
    },
    {
        "content": "<p>Haven't we worked our way to an actual counterexample of the safety of that? At least, if <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> exists and has a <code>get_mut</code></p>",
        "id": 261206396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636685003
    },
    {
        "content": "<p>that doesnt sound very unified to me any more, but I guess it depends on how the checking would work excatly</p>",
        "id": 261206399,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685012
    },
    {
        "content": "<p>agh, your second example with the <code>&amp;Cell&lt;Bool&gt;</code> made me realise I actually cant do what I want to do at all without it being lang UB to write a 0 into an <code>&amp;mut NonZeroI32</code> or a 2 into a <code>bool</code> etc</p>",
        "id": 261206415,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636685042
    },
    {
        "content": "<p>It seems to me the easiest base is to say that the rust memory model gives types to pointer values that come from references.</p>",
        "id": 261206458,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685059
    },
    {
        "content": "<p>I guess it is just not possible to reason about what variant an enum has set (with the current set of UB)</p>",
        "id": 261206461,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1636685066
    },
    {
        "content": "<blockquote>\n<p>the issue here is that the write to x could, in theory, affect the following if-let</p>\n</blockquote>\n<p>can it? so you are saying we could soundly have <code>x: &amp;Cell&lt;bool&gt;, y: &amp;Option&lt;Cell&lt;bool&gt;&gt;</code> that alias?</p>",
        "id": 261206486,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685121
    },
    {
        "content": "<p>We can safely have this rn.</p>",
        "id": 261206489,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685137
    },
    {
        "content": "<p>you mean we can create it in safe code?</p>",
        "id": 261206493,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685149
    },
    {
        "content": "<p>oh yeah we can... <code>as_ref().unwrap()</code></p>",
        "id": 261206532,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685168
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261206538,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206458\">said</a>:</p>\n<blockquote>\n<p>It seems to me the easiest base is to say that the rust memory model gives types to pointer values that come from references.</p>\n</blockquote>\n<p>I dont know what that means.^^</p>",
        "id": 261206546,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685212
    },
    {
        "content": "<p>So, x would have a \"type\" of <code>Cell&lt;bool&gt;</code> with validity invariant <code>[00|01]</code>, and that would infect pointers derived from it.</p>",
        "id": 261206579,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685259
    },
    {
        "content": "<p>(Although It may be easier to deal with it in terms of just the validity invariant, not the type - otherwise, what do you do if you go to another reference)</p>",
        "id": 261206633,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206370\">said</a>:</p>\n<blockquote>\n<p>which might indicate maybe we shouldnt unify them, because for a <code>&amp;mut NonZeroU16</code> it seems it should be fine to temporarily make both bytes 0 as long as they are non-zero when the lifetime of the reference ends</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206396\">said</a>:</p>\n<blockquote>\n<p>Haven't we worked our way to an actual counterexample of the safety of that? At least, if <code>&amp;UnsafeCellWithNiches&lt;T&gt;</code> exists and has a <code>get_mut</code></p>\n</blockquote>\n<p>to be precise:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">UnsafeCellWithNiches</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">NonZeroU16</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">NonZeroU16</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_ref</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">get_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">NonZeroU16</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// break the invariant</span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">());</span><span class=\"w\"> </span><span class=\"c1\">// oh noes</span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">NonZeroU16</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// restore the invariant</span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// lifetime of `y` ends</span>\n</code></pre></div>",
        "id": 261206660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636685343
    },
    {
        "content": "<p>You could then make it UB to write a value to the pointer that doesn't satisfy the reference's validity invariant.</p>",
        "id": 261206672,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685384
    },
    {
        "content": "<p>(Then to allow <code>&amp;mut T</code> to work, it can be defined behaviour to store an invalid value via pointers derive from a <code>&amp;mut T</code>, as long as the value is still valid immediately before the reference is invalidated)</p>",
        "id": 261206737,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206672\">said</a>:</p>\n<blockquote>\n<p>You could then make it UB to write a value to the pointer that doesn't satisfy the reference's validity invariant.</p>\n</blockquote>\n<p>so basically, like <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>'s 'writeback' proposal, store the invariant in the provenance (or the borrow stack). but this has all the same problems, because memory accesses are bytewise but invariants can correlate many bytes. you start with a pointer to a 2-byte value that may not be all 0, then cast it to <code>*mut u8</code> and write a 0  -- is this allowed? now suddenly this depends on the state of some other bytes your access didnt even touch. if some other thread concurrently mutates the other byte, do we have a data race now because conceptually our first thread \"read\" that byte?</p>",
        "id": 261206941,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685729
    },
    {
        "content": "<p>so I dont buy your claim that this would be \"easiest\". the \"easiest\" approach is to not make this UB in the first place. :)</p>",
        "id": 261206949,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685759
    },
    {
        "content": "<p>Fair. It's the easiest I can think of, while still making this UB.</p>",
        "id": 261206994,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685790
    },
    {
        "content": "<p>that might be the case -- I havent seen any other proposal that would achieve this. (not counting 'non-addressable shadow data in memory' since I have yet to see a version of that proposal that would work with byte-wise shenanigans.)</p>",
        "id": 261207091,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685913
    },
    {
        "content": "<p>Hmm... Though. It works semi-well for <code>&amp;mut T</code>, since the validation of the memory occurs immediately before the invalidation of the reference (which means that nothing else can possibly observe/mutate it yet).</p>",
        "id": 261207099,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685923
    },
    {
        "content": "<p>and with that I should definitely start preparing diner, have a good evening/night/whatever everyone :)</p>",
        "id": 261207103,
        "sender_full_name": "RalfJ",
        "timestamp": 1636685930
    },
    {
        "content": "<p>What if the invariants are always asserted from an omniscient perspective? So If you race with another thread to write the bytes then whether it is UB or not depends on what order the writes hit memory (but basically, that's a race and probably UB, although miri might not catch it because it's not good at concurrency exploration)</p>",
        "id": 261207114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636685950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261207114\">said</a>:</p>\n<blockquote>\n<p>What if the invariants are always asserted from an omniscient perspective? So If you race with another thread to write the bytes then whether it is UB or not depends on what order the writes hit memory (but basically, that's a race and probably UB, although miri might not catch it because it's not good at concurrency exploration)</p>\n</blockquote>\n<p>That interacts poorly if your memory location for data race purposes is &gt;1 byte</p>",
        "id": 261207134,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636685982
    },
    {
        "content": "<p>(Although I guess in such a world, you're probably operating on an object model anyways, so you can go nuts with how the validation is applied)</p>",
        "id": 261207269,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686050
    },
    {
        "content": "<p>The issue with <code>Option&lt;UnsafeCellWithNiches&lt;NonZeroU16&gt;&gt;</code> seems really hairy, because you have unsynchronized reading of the discriminant while writing both bytes</p>",
        "id": 261207380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636686129
    },
    {
        "content": "<p>UnsafeCellWithNiches would basically be super-!Sync</p>",
        "id": 261207396,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686164
    },
    {
        "content": "<p>It wouldn't be usable in a thread-safe interior mutability wrapper at all (at least, for a generic T or a concrete T with niches)</p>",
        "id": 261207422,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636686202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/261206328\">said</a>:</p>\n<blockquote>\n<p>If we have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">miri</span>::<span class=\"n\">validate_location</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Magicly inserted function that asks whether `x` points to a vlaid `bool`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Then that's fine to have that be well-defined to panic, but</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">miri</span>::<span class=\"n\">validate_location</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Magicly inserted function that asks whether `x` points to a valid `bool`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the issue here is that the write to <code>x</code> could, in theory, affect the following if-let</p>\n</blockquote>\n<p>I know that I am just jumping in, but I really don't understand why this first example is not UB (or why it doesn't use <code>unsafe</code>). You are writing the value of <code>2</code> to a <code>bool</code>.</p>",
        "id": 262537894,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1637718363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247082\">@Sebastian Malton</span> It doesn't use <code>unsafe</code> mostly because it's annoying to write <code>unsafe</code> all the time when the topic is unsafe code... you can assume that all code blocks on this stream are wrapped in <code>unsafe { ... }</code> unless the application of unsafe blocks is itself the topic of discussion.</p>\n<p>As for whether it is UB, while I and others would very much like it to be UB to write a <code>2</code> into a <code>&amp;mut bool</code>, the challenge is finding a way to detect that this is happening without using typed memory, because rust does not use typed memory. In the example we are not <em>syntactically</em> writing <code>2</code> to a <code>&amp;mut bool</code>, we are writing to a <code>*mut u8</code>, which is no problem at all. You could say that it is derived from a <code>&amp;mut bool</code>, but as long as a borrow is out on the value we can't look at it, and even then it's still open whether this ought to be immediate UB or only UB once the value is read at type <code>bool</code> (which could for example happen in subsequent safe code).</p>",
        "id": 262548338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637732167
    },
    {
        "content": "<p>indeed for these reasons I dont think it should be UB -- memory is not typed, and at no point does this program treat <code>2</code> as a value of type bool</p>",
        "id": 262596603,
        "sender_full_name": "RalfJ",
        "timestamp": 1637764665
    },
    {
        "content": "<p>But if that function didn't do the <code>panic!()</code> and instead returned, it would be UB?</p>",
        "id": 262598645,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1637765651
    },
    {
        "content": "<p>Well, in the above examples, reaching the <code>miri::validate_location</code> call would be UB. The question of whether returning would be UB is open, but I'd personally like it very much, so I can assume that references to the interior of an Option don't modify the discriminant, even with potential niche-optimization.</p>",
        "id": 262600672,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637766651
    },
    {
        "content": "<p>Yeah that makes the most sense to me. But I do see what <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> means about trying to track this in Miri for example.</p>",
        "id": 262657417,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1637802668
    },
    {
        "content": "<p>I think you cant even assume that references to a <code>&amp;mut bool</code> wont modify this to something non-bool (so enums and their discriminants are not the only example)</p>",
        "id": 262816142,
        "sender_full_name": "RalfJ",
        "timestamp": 1637945190
    },
    {
        "content": "<p>Shouldn't you be able to assume that once the lifetime of the reference ends are are able to?</p>",
        "id": 262817525,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1637946050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247082\">Sebastian Malton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262817525\">said</a>:</p>\n<blockquote>\n<p>Shouldn't you be able to assume that once the lifetime of the reference ends are are able to?</p>\n</blockquote>\n<p>some people say yes, some people say no. I am in the latter camp, since I think it gives undue significance to the event of \"a lifetime ends\", which is an event that becomes very fuzzy and hard to define once you talk about unsafe code doing tricky pointer shenanigans.</p>",
        "id": 262897968,
        "sender_full_name": "RalfJ",
        "timestamp": 1638054754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262897968\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"247082\">Sebastian Malton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/niches-and-interior-mutability/near/262817525\">said</a>:</p>\n<blockquote>\n<p>Shouldn't you be able to assume that once the lifetime of the reference ends are are able to?</p>\n</blockquote>\n<p>some people say yes, some people say no. I am in the latter camp, since I think it gives undue significance to the event of \"a lifetime ends\", which is an event that becomes very fuzzy and hard to define once you talk about unsafe code doing tricky pointer shenanigans.</p>\n</blockquote>\n<p>But that means that the compiler cannot assume a bool is strictly 1 or 0. </p>\n<p>Furthermore, I don't see how that significance is not a reasonable extension of what an exclusive reference means. I guess the alternative could be that merely writing the 2 is instant UB.</p>",
        "id": 262960900,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1638151968
    },
    {
        "content": "<blockquote>\n<p>But that means that the compiler cannot assume a bool is strictly 1 or 0. </p>\n</blockquote>\n<p>This is always a question of when and where the compiler can assume that. Whenever a <code>bool</code> \"comes in\" as an argument or return value of a function, the compiler <em>can</em> make this assumption -- any typed copy requires the validity invariant. But once a mutable reference to the bool has been given out, then the assumption might be violated until the next time that a typed copy is made.</p>\n<p>This is not black and white, there are many possible trade-offs here that differ in terms of how many places the compiler can make this assumption, how complicated the unsafe code rules become, and so on.</p>",
        "id": 263031532,
        "sender_full_name": "RalfJ",
        "timestamp": 1638203099
    },
    {
        "content": "<blockquote>\n<p>Furthermore, I don't see how that significance is not a reasonable extension of what an exclusive reference means. I guess the alternative could be that merely writing the 2 is instant UB.</p>\n</blockquote>\n<p>It leads to an even more complicated model than Stacked Borrows, and some questions are unanswered. For example for <code>&amp;mut NonZeroU32</code>, there is no rule which says that the \"lifetime of this reference\" ends at the same time for all the 4 bytes involves -- the \"lifetime ends\" on a conflicting access, and that might be separate for each byte.<br>\nFWIW this has all been discussed already in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">https://github.com/rust-lang/unsafe-code-guidelines/issues/84</a>, I am just repeating myself here. ;)</p>",
        "id": 263031861,
        "sender_full_name": "RalfJ",
        "timestamp": 1638203217
    }
]