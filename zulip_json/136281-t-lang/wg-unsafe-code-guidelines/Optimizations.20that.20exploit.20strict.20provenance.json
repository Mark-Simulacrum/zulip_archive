[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491603\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277491212\">said</a>:</p>\n<blockquote>\n<p>I don't know if this is possible, but it'd be lovely if we had carrots and not just sticks here -- i.e. if there were some new MIR optimization where we could say \"you only get this if you start using strict provenance\"</p>\n</blockquote>\n<p>Yeah, I've brought this up, and definitely agree. I'm slowly working towards that goal, but there are a lot of things that need to be done before MIR opts can be at that point</p>\n</blockquote>\n<p>imagine all that work was done. what would even <em>be</em> an optimization that is only correct under strict provenance, but not under permissive provenance? we dont have an example of that yet I think.</p>",
        "id": 277492153,
        "sender_full_name": "RalfJ",
        "timestamp": 1648857420
    },
    {
        "content": "<p>isn't that hard when we don't yet know exactly what the permissive provenance model is?</p>",
        "id": 277492589,
        "sender_full_name": "Diggsey",
        "timestamp": 1648857751
    },
    {
        "content": "<p>I don't either, but this is also not quite how I'm thinking about it. The question that I'm asking is closer to \"what is a strategy for doing analysis that is only correct under the strict moderl\" - of course, this depends in a pretty important way on the particular implementation of the analysis.</p>\n<p>In other words, even if it turns out there are no particular optimizations that are <em>illegal</em> permissive provenance, I still think that determining that they are only hard to implement is a comparably important datapoint. I don't have great intuition around this - I'd have to go write some actual code</p>",
        "id": 277492750,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648857924
    },
    {
        "content": "<p>if we know that int2ptr returns a pointer that never has provenance, then you have a lot more information about the return value, which in turn could mean that existing optimizations can be used more often</p>",
        "id": 277493031,
        "sender_full_name": "Diggsey",
        "timestamp": 1648858143
    },
    {
        "content": "<p>Well, yes, but that's sort of misleading. Presumably, people are doing int2ptr casts with the intention of dereferencing them, and so they would replace the cast with non-UB code in a strict provenance model</p>",
        "id": 277493370,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648858515
    },
    {
        "content": "<p>So the real question we have to ask is whether the weak provenance int2ptr is harder to optimize than the equivalent code in strict provenance</p>",
        "id": 277493380,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648858550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277492153\">said</a>:</p>\n<blockquote>\n<p>we dont have an example of that yet I think.</p>\n</blockquote>\n<p>I think I could come up with</p>\n<ul>\n<li>some contrived pair of higher-order functions <code>f</code>,<code>g</code> that use SB-untagged-ptr2int2ptr</li>\n<li>that are distinct, i.e. for any input <code>h</code>, either <code>f(h)</code> is UB or <code>g(h)</code> is UB or <code>f(h) != g(h) : int</code></li>\n<li>but if you change the ptr2int2ptr to SB-tagged-ptr2int2ptr, then <code>f'</code> and <code>g'</code> are operationally equivalent</li>\n</ul>",
        "id": 277496083,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648861797
    },
    {
        "content": "<p>I don't know that it would be interesting.</p>",
        "id": 277496126,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648861810
    },
    {
        "content": "<p>Actually under this statement of the problem, <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277312717</a> is already an example.</p>\n<p>At the time I dismissed the example as trivial, because if I write out the strict-provenance variant of that function, it will contain <code>*std::ptr::invalid(..)</code> which is just plain UB.</p>\n<p>Maybe we can find a more interesting problem statement.</p>",
        "id": 277496565,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648862399
    },
    {
        "content": "<p>This is why I think it's unhelpful to use the same syntax for two kinds of ptr2int2ptr</p>",
        "id": 277496663,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648862521
    },
    {
        "content": "<p>(I should credit my advisor Paul Levy, who really took this to the extreme with CBPV, introducing separate syntax for each little bit of semantics)</p>",
        "id": 277496784,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648862624
    },
    {
        "content": "<p>So, just for clarity, we're looking at this example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">cond</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"mi\">1000000</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">int2ptr</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">total</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277498485,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648864471
    },
    {
        "content": "<p>Where the strict provenance version is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">cond</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"mi\">1000000</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">total</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277498607,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648864523
    },
    {
        "content": "<p>What optimization are you claiming is legal on the second but not on the first?</p>",
        "id": 277498649,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648864539
    },
    {
        "content": "<p>IMO the strict provenance version would also have <code>arg: usize</code>, and then the else case is <code>total += *std::ptr::invalid(arg + i);</code> which is UB</p>",
        "id": 277499916,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648866060
    },
    {
        "content": "<p>Because that‚Äôs what strict int2ptr is: <code>std::ptr::invalid</code></p>",
        "id": 277499930,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648866092
    },
    {
        "content": "<p>It sounds stupid when you phrase it this way, doesn‚Äôt it ü§∑üèª</p>",
        "id": 277499963,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648866122
    },
    {
        "content": "<p>Well, yes, but those functions have different behaviors</p>",
        "id": 277501972,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648868677
    },
    {
        "content": "<p>Functions with different behavior might indeed optimize differently, that's not really the point</p>",
        "id": 277501981,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648868696
    },
    {
        "content": "<p>I agree</p>",
        "id": 277525174,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648900560
    },
    {
        "content": "<p>actually I think it is very easy to ensure that all optimizations are correct wrt permissive provenance: just treat ptr2int and int2ptr as FFI operations. even under strict provenance then, ptr2int might store that pointer 'somewhere', and int2ptr might return it.<br>\nit follows that any optimization that is correct under strict provenance is also correct under permissive provenance, if it treats these casts as external/unknown operations. (we can probably do better than that, e.g. we can reorder these casts with arbitrary loads and stores. but that's details.)</p>",
        "id": 277529337,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905695
    },
    {
        "content": "<p>this is related to the ideas of implementing ptr2int2ptr casts in CHERI via a hashmap. that does not work <em>in general</em>. but the thing is, to thwart the compiler, it is enough that there exists an implementation that works <em>in any specific case</em> (like, the FFI is hard-coded for a specific program). and that is always possible.</p>",
        "id": 277529450,
        "sender_full_name": "RalfJ",
        "timestamp": 1648905783
    },
    {
        "content": "<p>So... how does that fix the \"integers can be optimized in ways that are unsound if provenance is derived from them\" problem?</p>",
        "id": 277620721,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648988070
    },
    {
        "content": "<p>Going back to the \"double-cast\" example:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">ip</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)(</span><span class=\"n\">p</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">iq</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"n\">q</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">iq</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">ip</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">iq</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which optimization would the \"int2ptr is FFI\" model prevent?</p>",
        "id": 277620993,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648988269
    },
    {
        "content": "<p>You could still rewrite <code>*(char*)iq = 10</code> to <code>*(char*)ip = 10</code>, but you cannot simplify that to <code>*(p+1) = 10</code>.</p>",
        "id": 277623195,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648989485
    },
    {
        "content": "<p>yeah, <code>ip</code> is just a thing returned from an FFI function and passed to a different FFI function, so you don't get to optimize it any further</p>",
        "id": 277628904,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992562
    },
    {
        "content": "<p>ofc FFI functions will have a big perf impact, but code that wants optimizations can 'simply' use the strict provenance APIs. :)<br>\n(at least it can if we land <a href=\"https://github.com/rust-lang/rust/pull/95588\">https://github.com/rust-lang/rust/pull/95588</a>)</p>",
        "id": 277629019,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992633
    },
    {
        "content": "<p>So... my apologies if I'm showing my ignorance, trying to figure out the rules here. Given this code:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">set_value</span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ...</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is there a possible scenario where the above prints 42?</p>",
        "id": 277865547,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649159819
    },
    {
        "content": "<p>If I understand provenance correctly, the compiler might assume that, since \"value\" is a local variable, and no code using the provenance of value occurs after <code>value = 42</code>, value stays at 42?</p>",
        "id": 277865823,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649159955
    },
    {
        "content": "<p>Well, if you make ptr2int2ptr casts UB, then the snippet you posted has UB and could print anything. If they are not UB, then it would have to print 10.</p>",
        "id": 277865858,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649159975
    },
    {
        "content": "<p>Or is it assumed that <code>set_value</code> has side-effects , and side-effects can include changing arbitrary stack variables?</p>",
        "id": 277865873,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649159982
    },
    {
        "content": "<blockquote>\n<p>Well, if you make ptr2int2ptr casts UB, then the snippet you posted has UB and could print anything.</p>\n</blockquote>\n<p>I'm asking under the model where ptr2int and int2ptr are allowed and considered FFI.</p>",
        "id": 277865965,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649160007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277865873\">said</a>:</p>\n<blockquote>\n<p>Or is it assumed that <code>set_value</code> has side-effects , and side-effects can include changing arbitrary stack variables?</p>\n</blockquote>\n<p>Provenance is used to assume that any local variable for which the address is not leaked or given to some specific code won't be modified or observed by it, no matter what it is.</p>\n<p>Under PNVI-ae, then that code will print 10. Under strict provenance, yes, that code has undefined behaviour, and can  print anything. The most likely situtation is, of course, that 42 will be folded from <code>value</code> into <code>print</code>.</p>",
        "id": 277866554,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649160278
    },
    {
        "content": "<p>Although under strict provenance, it could very easily delete the body of <code>set_value</code>, possibly replacing it with <code>ud2</code> or <code>nop</code>.</p>",
        "id": 277867519,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649160742
    },
    {
        "content": "<p>I really hope we don't get in the business of doing optimizations like that. That is the sort of thing that makes devs hate compiler writers</p>",
        "id": 277867614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649160796
    },
    {
        "content": "<p>What, the \"This code is unconditional UB and thus elide the entire thing into <code>ud2</code>\" thing?</p>",
        "id": 277867676,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649160834
    },
    {
        "content": "<p>yes</p>",
        "id": 277867684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649160838
    },
    {
        "content": "<p>I have some bad news for you.</p>",
        "id": 277867732,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649160849
    },
    {
        "content": "<p>I realize it is difficult to avoid in a lot of cases, but we should try not to do it on purpose</p>",
        "id": 277867764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649160874
    },
    {
        "content": "<p>Would you rather I elided functions that are unconditionally UB into an empty body, then?</p>",
        "id": 277868059,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161039
    },
    {
        "content": "<p>people also hate compiler devs when optimizers miss obvious UB and emit slow asm</p>",
        "id": 277868095,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649161069
    },
    {
        "content": "<p>so i'd say its a lose-lose situation and just go for the fast code and tell people to stop doing UB <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 277868108,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649161079
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 277868210,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277868059\">said</a>:</p>\n<blockquote>\n<p>Would you rather I elided functions that are unconditionally UB into an empty body, then?</p>\n</blockquote>\n<p>I would do something like compile it to a panic but also remember that it is unconditional UB and propagate this to callers</p>",
        "id": 277868455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161261
    },
    {
        "content": "<p>Inserting panics in optimization passes is a very bad idea.</p>",
        "id": 277868498,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161287
    },
    {
        "content": "<p>why?</p>",
        "id": 277868527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161303
    },
    {
        "content": "<p>it's UB, it's never going to be called</p>",
        "id": 277868532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161306
    },
    {
        "content": "<p><code>ud2</code> avoids the problem of unwinding.</p>",
        "id": 277868554,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161313
    },
    {
        "content": "<p>And has well-defined semantics: #UD.</p>",
        "id": 277868621,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161329
    },
    {
        "content": "<p>certainly <code>nop</code> is a terrible idea if you fall off the end of the function</p>",
        "id": 277868651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161342
    },
    {
        "content": "<p>that's a short trip to actual <code>rm -rf /</code></p>",
        "id": 277868672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161356
    },
    {
        "content": "<p>That's what <code>TrapUnreachable</code> is for.</p>",
        "id": 277868710,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161374
    },
    {
        "content": "<p>okay, but an abort with a message is still better</p>",
        "id": 277868761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161404
    },
    {
        "content": "<p>like compilers don't have to be adversarial when it comes to diagnosing code with UB</p>",
        "id": 277868811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161438
    },
    {
        "content": "<p>Certainly lccc's xlang_backend is very aggressive rn about const-folding and generating Unreachable code traps. It also happens to know zilch about functions called <code>printf</code>.</p>",
        "id": 277868856,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161444
    },
    {
        "content": "<p>It just knows <code>self.inner.write_trap(Trap::Unreachable)</code>.</p>",
        "id": 277868891,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161465
    },
    {
        "content": "<p>that could just be <code>self.inner.write_trap(Trap::Unreachable(msg))</code> and codegen that to <code>printf</code> or whatever is available on the target</p>",
        "id": 277868951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Doing so with debug assertions is fine I think. For release mode it significantly regresses binary size and slightly regresses performance.</p>",
        "id": 277868952,
        "sender_full_name": "bjorn3",
        "timestamp": 1649161504
    },
    {
        "content": "<p>(And the <code>inner</code> just knows <code>if self.trap_unreachable { /* ud2 */}</code> (<code>trap_unreachable</code> is currently forced on, with no way to turn it off user-side)</p>",
        "id": 277868974,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161511
    },
    {
        "content": "<p>On release, <code>ud2</code> is probably the safest option that is still short</p>",
        "id": 277869029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161544
    },
    {
        "content": "<p>I used puts+ud2 in cg_clif until recently. Switching to only ud2 saved a lot on binary size.</p>",
        "id": 277869041,
        "sender_full_name": "bjorn3",
        "timestamp": 1649161549
    },
    {
        "content": "<p>The backend doesn't know enough about the target to know \"whatever is available\". That's a design feature.</p>",
        "id": 277869124,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161579
    },
    {
        "content": "<p>(It also doesn't get the optimizer mode - against, a design feature - optimizer mode is a driver concept)</p>",
        "id": 277869161,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649161601
    },
    {
        "content": "<p>See <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/pull/1220\">https://github.com/bjorn3/rustc_codegen_cranelift/pull/1220</a></p>",
        "id": 277869254,
        "sender_full_name": "bjorn3",
        "timestamp": 1649161635
    },
    {
        "content": "<p>it looks like you just took the prints out completely? Why not put it behind a compiler flag or debug setting?</p>",
        "id": 277869499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161723
    },
    {
        "content": "<p>Because cg_clif is only meant to be used in debug mode and compile fast in that case. Having a compiler flag would have been possible, but I don't think it is really worthwhile.</p>",
        "id": 277869800,
        "sender_full_name": "bjorn3",
        "timestamp": 1649161845
    },
    {
        "content": "<p>I think that supporting UB tracing properly is probably not something a compiler can do \"naturally\" but I can imagine something that gives you output a bit like Miri but only for assertions that can be statically baked into the executable</p>",
        "id": 277869827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161859
    },
    {
        "content": "<p>the print statements you removed are all kind of vague, I'm sure it wouldn't help that much to see <code>[panic] Tried to get discriminant for uninhabited type.</code> without more context</p>",
        "id": 277869956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649161922
    },
    {
        "content": "<p>While cg_clif was still frequently miscompiling things it was useful as a start point for debugging, but I agree it isn't very useful for end users.</p>",
        "id": 277870329,
        "sender_full_name": "bjorn3",
        "timestamp": 1649162069
    },
    {
        "content": "<p>You're going to get vague errors anyways.</p>",
        "id": 277870362,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162086
    },
    {
        "content": "<p>Especially with compilers like lccc that have delayed UB</p>\n<blockquote>\n<p>Attempted to branch on <code>invalid</code></p>\n</blockquote>",
        "id": 277870515,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162156
    },
    {
        "content": "<p>It seems conceivable that you can get a \"context trace\" for unreachable markers that tracks where the UB came from (in source terms) and retains this through UB back-propagation</p>",
        "id": 277870611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162183
    },
    {
        "content": "<p>That's a lot of (slow) state tracking.</p>",
        "id": 277870655,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162204
    },
    {
        "content": "<p>it would slow down the compiler but it's all just a static output</p>",
        "id": 277870703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162226
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 277870744,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162246
    },
    {
        "content": "<p>sure, it's not easy being helpful</p>",
        "id": 277870764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162258
    },
    {
        "content": "<p>Do you want a binary sometime in the next minute?</p>",
        "id": 277870798,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162276
    },
    {
        "content": "<p>i don't think it has to be tremendously expensive though</p>",
        "id": 277870846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162285
    },
    {
        "content": "<p>it's just a bit of diagnostic info attached to unreachable markers</p>",
        "id": 277870880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162304
    },
    {
        "content": "<p>it seems comparable to all the other diagnostic stuff in rustc today</p>",
        "id": 277870948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162339
    },
    {
        "content": "<p>\"unreachable markers\" aka <code>Value::Invalid</code>, which isn't even the most common source of UB (<code>Value::Uninit</code> would appear far more often, and has far more cases of UB, despite not being \"If you have this, undefined behaviour\")</p>",
        "id": 277871042,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162386
    },
    {
        "content": "<p>Is this constant propagation you are talking about? <code>Value::Invalid</code> sounds like a runtime concept</p>",
        "id": 277871178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162436
    },
    {
        "content": "<p>Yes. <code>Value::Invalid</code> is a constant value in xir that is \"The canonical invalid value of some type <code>T</code>\". It's mere production (of any type) is immediate undefined behaviour. Of course, I delay this to a few key points (such as when I actually need to determine what a value is).</p>",
        "id": 277871304,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162500
    },
    {
        "content": "<p>in that case I would attach a pointer / ID / span / whatever tracking information to the source statement that yielded a MIR/xir operation that generated the <code>Value::Invalid</code></p>",
        "id": 277871434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162537
    },
    {
        "content": "<p>you need to be keeping track of such information anyway if you want to have, say, good post-mono errors</p>",
        "id": 277871845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162707
    },
    {
        "content": "<p>Sure, but it won't get attached to the values.</p>",
        "id": 277871954,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162756
    },
    {
        "content": "<p>but doing so is not a large cost if the tracking info is small, you just have to copy it along as it propagates</p>",
        "id": 277872117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162811
    },
    {
        "content": "<p>I would assume that the <code>Value::OtherStuff</code> is already quite a bit bigger</p>",
        "id": 277872192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162841
    },
    {
        "content": "<p>Well, the value is inside of <code>VStackValue::Constant</code> which just stores an <code>xlang_struct::Value</code>. Said value could be <code>Uninit</code> or <code>Invalid</code>, but could also be <code>int(32) 0</code>.</p>",
        "id": 277872322,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162885
    },
    {
        "content": "<p>(Also, <code>Invalid</code>/<code>Uninitialized</code> both store a <code>Type</code>, which, is... uh... fairly big)</p>",
        "id": 277872539,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649162985
    },
    {
        "content": "<p>right, that seems to accord with what I said. For error values you can hold on to some originator info so that if you try to branch on it or something you can say \"this operation &gt;here&lt; produced a value that was used &gt;here&lt; and this is UB\"</p>",
        "id": 277872562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649162994
    },
    {
        "content": "<p>just because there exists an invalid value somewhere during codegen doesnt mean you need to error though, it can happen in dead code and thats perfectly fine</p>",
        "id": 277872700,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649163041
    },
    {
        "content": "<p>I don't really understand what the goal is here</p>",
        "id": 277872739,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649163061
    },
    {
        "content": "<p>that's why it's just additional tracking info in the <code>Invalid</code></p>",
        "id": 277872759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163066
    },
    {
        "content": "<p>the idea is that if this <code>Invalid</code> is actually <em>used</em> in a way that is erroneous, then you know how you got the value and can report a better error than you could otherwise</p>",
        "id": 277872857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163112
    },
    {
        "content": "<p>Having <code>Invalid</code> is erroneous.</p>",
        "id": 277872939,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163127
    },
    {
        "content": "<p>and if it just goes to the binary then you can write this info in an abort message</p>",
        "id": 277872970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163140
    },
    {
        "content": "<p>The only reason it gets produced by the backend at all is because I'm lazy and want to codegen <code>Expr::Const(c)</code> as <code>push_value(VStackValue::Constant(c))</code></p>",
        "id": 277873011,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163161
    },
    {
        "content": "<p>I deal with it when it get's used.</p>",
        "id": 277873088,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163200
    },
    {
        "content": "<p>(It's also a fairly limited source of UB - and many other values can cause UB in later ops)</p>",
        "id": 277873221,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163246
    },
    {
        "content": "<p>right, you use an <code>Invalid(info)</code> that got produced somewhere and can emit <code>Trap(format!(\"produced Invalid at {info}, {file}:{line}\"))</code></p>",
        "id": 277873261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163270
    },
    {
        "content": "<p>(It also again comes down to \"The backend doesn't know what <code>printf</code> is\")</p>",
        "id": 277873331,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163304
    },
    {
        "content": "<p>(And frankly, I think codegen introducing any kind of function call rather than a <code>ud2</code> is a huge issue)</p>",
        "id": 277873441,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163358
    },
    {
        "content": "<p>Okay, so teach it? pass it an Option&lt;Symbol&gt; for puts or something</p>",
        "id": 277873505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163367
    },
    {
        "content": "<p>and this is a debug assert anyway, you can turn it off in release</p>",
        "id": 277873559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163393
    },
    {
        "content": "<p>I am sooo much happier writing Rust code instead of C that I get nice error messages with a source location when I use an array out of bounds instead of a silent segfault. It is <em>absolutely</em> worth it</p>",
        "id": 277873689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163450
    },
    {
        "content": "<p>That's not even remotely the same as what you're describing</p>",
        "id": 277873745,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649163476
    },
    {
        "content": "<p>this is extra info in panic messages about the source location of the UB value that was generated</p>",
        "id": 277873884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163523
    },
    {
        "content": "<p>In production compilers it would be a best effort thing, not full Miri style</p>",
        "id": 277873999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277873505\">said</a>:</p>\n<blockquote>\n<p>Okay, so teach it? pass it an Option&lt;Symbol&gt; for puts or something</p>\n</blockquote>\n<p>1) From where, the backend only gets the target, features, and incoming IR.  &lt;<a href=\"https://github.com/LightningCreations/lccc/blob/main/xlang/src/plugin.rs#L67\">https://github.com/LightningCreations/lccc/blob/main/xlang/src/plugin.rs#L67</a>&gt;<br>\n2) I noted above that the backend doesn't even see the optimization level. It's just a driver concept to decide what optimizer plugins to run between the frontend and the backend (in addition to user-specified ones, and ones indicated as required by the frontend)</p>",
        "id": 277874036,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163594
    },
    {
        "content": "<p>For array out of bounds checks you have to use shadow state at runtime to produce the error instead of a segfault in more than a couple percent of the cases I think.</p>",
        "id": 277874130,
        "sender_full_name": "bjorn3",
        "timestamp": 1649163614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277873441\">said</a>:</p>\n<blockquote>\n<p>(And frankly, I think codegen introducing any kind of function call rather than a <code>ud2</code> is a huge issue)</p>\n</blockquote>\n<p>Also, re. this: what if the UB occurs inside a dynamic loader's resolution function.</p>",
        "id": 277874234,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163647
    },
    {
        "content": "<p>Now I've turned the nice noisy \"Illegal Instruction (core dumped)\", into an infinite loop.</p>",
        "id": 277874336,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163692
    },
    {
        "content": "<p>the main place I think you would see error messages like I'm describing would be in <em>unconditional</em> UB. Conditional UB will just be compiled out so you will just get the result of some other branch of execution</p>",
        "id": 277874342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163695
    },
    {
        "content": "<p>which is what I mean about \"best-effort\"</p>",
        "id": 277874380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277874342\">said</a>:</p>\n<blockquote>\n<p>the main place I think you would see error messages like I'm describing would be in <em>unconditional</em> UB. Conditional UB will just be compiled out so you will just get the result of some other branch of execution</p>\n</blockquote>\n<p>That's only if the optimizer runs. Backend isn't that smart.</p>",
        "id": 277874437,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163729
    },
    {
        "content": "<p>Backend optimizations are currently limited to what can be done linearily with the xir instruction stream.</p>",
        "id": 277874498,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163758
    },
    {
        "content": "<p>if the optimizer doesn't run then you keep the branch and have unconditional UB with a nice panic message, and the user is happy</p>",
        "id": 277874513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163767
    },
    {
        "content": "<blockquote>\n<p>Have unconditional UB with a nice panic message</p>\n</blockquote>\n<p>Unless of course, printing the panic message is reentrant to the statement that causes undefined behaviour.</p>",
        "id": 277874592,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163802
    },
    {
        "content": "<p>Then you suddenly have a worse UX problem.</p>",
        "id": 277874713,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163843
    },
    {
        "content": "<p>The existing, albeit unhelpful, diagnostic of \"Illegal Instruction\" has been replaced with either an infinite loop, or a loop for a while then \"Segmentation Fault\".</p>",
        "id": 277874822,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163892
    },
    {
        "content": "<p>eh, s/panic/abort, you get the idea</p>",
        "id": 277874843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163901
    },
    {
        "content": "<p>This issue can occur on the print-and-abort version as well.</p>",
        "id": 277874896,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163927
    },
    {
        "content": "<p>again, what if the code is <code>ldresolve</code>?</p>",
        "id": 277874942,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649163947
    },
    {
        "content": "<p>if you call <code>puts</code> and it fails then oh well</p>",
        "id": 277875026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649163971
    },
    {
        "content": "<p>I mean isn't this an issue when you do anything?</p>",
        "id": 277875080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164001
    },
    {
        "content": "<p>No, the situtation here is</p>\n<ol>\n<li>I'm in <code>ldresolve</code>. </li>\n<li>I hit UB</li>\n<li>I call <code>printf</code></li>\n<li><code>printf</code> hasn't yet been resolved, so I call the plt symbol resolver</li>\n<li>plt symbol resolver calls <code>ldresolve</code></li>\n<li>I hit UB</li>\n<li>I call <code>printf</code></li>\n<li>...</li>\n</ol>",
        "id": 277875186,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164049
    },
    {
        "content": "<p>Is <code>ldresolve</code> being compiled by your compiler?</p>",
        "id": 277875334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164098
    },
    {
        "content": "<p>Perhaps it is.</p>",
        "id": 277875357,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164110
    },
    {
        "content": "<p>If this is the <code>ldresolve</code> inside lclibc or PhantomOS, I bet it will be.</p>",
        "id": 277875389,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164135
    },
    {
        "content": "<p>this is all very strange to me. You have to be able to write in some way that is not reentrant</p>",
        "id": 277875461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164173
    },
    {
        "content": "<p>do a <code>write</code> syscall if you have to</p>",
        "id": 277875485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164183
    },
    {
        "content": "<p>That's not an option on Windows and MacOS</p>",
        "id": 277875609,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164223
    },
    {
        "content": "<p>make it a compiler intrinsic so that it doesn't have code the compiler generated in it</p>",
        "id": 277875615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164226
    },
    {
        "content": "<p>Well, see, <code>ldresolve</code> usually doesn't contain references to plt relocations.</p>",
        "id": 277875631,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164232
    },
    {
        "content": "<p><code>ldresolve</code> likely needs <code>#![no_builtins]</code>. You can disable the printf if this attribute is used.</p>",
        "id": 277875803,
        "sender_full_name": "bjorn3",
        "timestamp": 1649164303
    },
    {
        "content": "<p>Or I could just not generate unsolicited function calls in codegen.</p>",
        "id": 277875944,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164349
    },
    {
        "content": "<p>using <code>ud2</code> is certainly an easy option for a compiler (I'm doing this too) but it's not <em>nice</em> for the user</p>",
        "id": 277876031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164386
    },
    {
        "content": "<p>You already do (eg memcpy, or other calls into compiler-builtins). <code>#![no_builtins]</code> exists precisely to disable those unsolicited function calls.</p>",
        "id": 277876128,
        "sender_full_name": "bjorn3",
        "timestamp": 1649164421
    },
    {
        "content": "<p>It's the option that runs the least risk of <br>\na) Killing Binary Size (again - codegenx86 <em>does not</em> see <code>-On</code>and this is by design)<br>\nb) Creating worse situtations.</p>",
        "id": 277876292,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277876128\">said</a>:</p>\n<blockquote>\n<p>You already do (eg memcpy, or other calls into compiler-builtins). <code>#![no_builtins]</code> exists precisely to disable those unsolicited function calls.</p>\n</blockquote>\n<p>Only time the codegen currently does any kind of function call is:<br>\n1) When codegening calls to certain builtins<br>\n2) A call<br>\n3) An atomic operation which is non-lock free.</p>",
        "id": 277876393,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164511
    },
    {
        "content": "<p>Also, if you want to quantify the impact of a <code>ud2</code> vs a more helpful message, there is now a single place in the standard library where you can swap out what happens when you trip assertions related to detecting UB in <code>core</code>: <a href=\"https://github.com/rust-lang/rust/blob/634770c0a7f8598164ab825cfe419cc8b03c36e5/library/core/src/intrinsics.rs#L1995\">https://github.com/rust-lang/rust/blob/634770c0a7f8598164ab825cfe419cc8b03c36e5/library/core/src/intrinsics.rs#L1995</a></p>\n<p>When I implemented this, using <code>panic!</code> was <em>at least</em> a 6% regression in runtime. Just the <code>ud2</code> is &lt;1%. But those numbers are definitely minimizing the situation because I added a lot more checks after doing that measurement.</p>",
        "id": 277876412,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164522
    },
    {
        "content": "<p>That sounds quite reasonable for a debug option</p>",
        "id": 277876494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164559
    },
    {
        "content": "<p>You fully misunderstand what this code does</p>",
        "id": 277876571,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164576
    },
    {
        "content": "<p>It checks hardly any UB at all</p>",
        "id": 277876585,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164583
    },
    {
        "content": "<p>The actual \"check for UB\" patch would add checks for all pointer dereferences, all pointer offsets, all matches on an enum...</p>",
        "id": 277876662,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164625
    },
    {
        "content": "<p>I'm not talking about extra checks, only messages when you reach unconditional UB that the compiler saw through</p>",
        "id": 277876858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164711
    },
    {
        "content": "<p>Yes, that is <em>everywhere</em></p>",
        "id": 277876948,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164757
    },
    {
        "content": "<p>the runtime cost should be zero, except for the icache losses due to code size and the cost of writing the message itself if you happen to hit UB</p>",
        "id": 277877066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164804
    },
    {
        "content": "<p>But also, feel free to prove me wrong by writing a patch for rustc and LLVM</p>",
        "id": 277877074,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649164808
    },
    {
        "content": "<p>i am confused as to what you mean by \"Unconditional UB\"</p>",
        "id": 277877126,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649164844
    },
    {
        "content": "<p>Also, as I've mentioned, this would also introduce the same code to release as debug, because <em>the backend has no way to differentiate</em>.</p>",
        "id": 277877171,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277877126\">said</a>:</p>\n<blockquote>\n<p>i am confused as to what you mean by \"Unconditional UB\"</p>\n</blockquote>\n<p>Code that is determined by the compiler to be 100% in all code paths that enter it.</p>",
        "id": 277877327,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164935
    },
    {
        "content": "<p>The trivial example being <code>core::hint::unreachable_unchecked()</code></p>",
        "id": 277877341,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164947
    },
    {
        "content": "<p>isnt that all UB though <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 277877369,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649164957
    },
    {
        "content": "<p>Well, there can be UB the compiler can't see through.</p>",
        "id": 277877402,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649164976
    },
    {
        "content": "<p>Like in the code <span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> linked to, there is a call to <code>::core::intrinsics::abort()</code> that I would call \"unconditional\" in the sense that once we enter the branch we are committed to running the abort.</p>",
        "id": 277877406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164976
    },
    {
        "content": "<p>Well, a function that takes a <code>*mut T</code> and dereferences it is only UB if the pointer is bad, so that's not unconditional.</p>",
        "id": 277877438,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649164993
    },
    {
        "content": "<p>if the branch was optimized away, then okay, no more panic message</p>",
        "id": 277877446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649164998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277877438\">said</a>:</p>\n<blockquote>\n<p>Well, a function that takes a <code>*mut T</code> and dereferences it is only UB if the pointer is bad, so that's not unconditional.</p>\n</blockquote>\n<p>Yeah.</p>",
        "id": 277877473,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165007
    },
    {
        "content": "<p>And the compiler won't see through the function unless it inlines (or cross-function const-props)</p>",
        "id": 277877511,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165028
    },
    {
        "content": "<p>hmm i guess, it feels like a subtle distinction <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 277877527,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649165035
    },
    {
        "content": "<p>im not sure if its super meaningful..</p>",
        "id": 277877578,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649165044
    },
    {
        "content": "<p>It means that the checks wouldn't do anything at runtime.</p>",
        "id": 277877612,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165060
    },
    {
        "content": "<p>but if the compiler settings are such that for whatever reason we decided to keep that branch, then we have a bit of code where we are definitely on a crash course</p>",
        "id": 277877618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165064
    },
    {
        "content": "<p>and at that point there is no harm in printing whatever useful information we can</p>",
        "id": 277877662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165085
    },
    {
        "content": "<p>(except for code size and compile time)</p>",
        "id": 277877699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165098
    },
    {
        "content": "<p>I mean, see above.</p>",
        "id": 277877717,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165105
    },
    {
        "content": "<p>(assuming you are not inside some critical infrastructure related to printing)</p>",
        "id": 277877794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165154
    },
    {
        "content": "<p>which is almost all code</p>",
        "id": 277877851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165167
    },
    {
        "content": "<p>Or you don't have any way to print.</p>",
        "id": 277877890,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165185
    },
    {
        "content": "<p>because you aren't on a hosted system, or because of an architectural flaw?</p>",
        "id": 277877981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165220
    },
    {
        "content": "<p>Because you aren't on hosted.</p>",
        "id": 277878008,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165231
    },
    {
        "content": "<p>in that case, just skip it</p>",
        "id": 277878040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165243
    },
    {
        "content": "<p>\"best-effort\"</p>",
        "id": 277878072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165258
    },
    {
        "content": "<p>It's far easier to not have to figure that out.</p>",
        "id": 277878229,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165322
    },
    {
        "content": "<p>I just remember LLVM has an option to turn the unreachable instruction into ud2. It was enabled by default for a while to mitigate loop {} being UB in LLVM in the past. I believe it has since been disabled though.</p>",
        "id": 277878254,
        "sender_full_name": "bjorn3",
        "timestamp": 1649165335
    },
    {
        "content": "<p>On x86, I only look at the operating system to determine the ABI.<br>\nCurrently the branches are<br>\n<code>x86_64-*-windows-*</code> =&gt; <code>WIN64</code><br>\n<code>x86_86-*-*</code> =&gt; <code>SysV64</code></p>",
        "id": 277878316,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165372
    },
    {
        "content": "<p>LLVM still optimizes based on unreachable even with that option though.</p>",
        "id": 277878331,
        "sender_full_name": "bjorn3",
        "timestamp": 1649165378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I would take a page from the way panicking works in rust currently. This is a <em>language</em> feature, in that syntax like <code>[][0]</code> leads to a call to <code>print</code> somehow</p>",
        "id": 277878580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165480
    },
    {
        "content": "<p>I believe the mechanism is that the language knows how to call a library function with a name like <code>core::panicking::panic</code></p>",
        "id": 277878643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165512
    },
    {
        "content": "<p>Yeah, that panic is generated in the frontend.</p>",
        "id": 277878657,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165519
    },
    {
        "content": "<p>you could have it be a late transformation pass on the IR if it is awkward in codegen</p>",
        "id": 277878765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165561
    },
    {
        "content": "<p>Backend is: What's <code>std::panicking::panic_fmt&lt;'a&gt;(std::fmt::Arguments&lt;'a&gt;)-&gt;!</code>.</p>\n<p>I know: <code>call _ZNSt9panicking9panic_fmtIU6erasedEE_ZSt3fmt9ArgumentsIT_Ev</code></p>",
        "id": 277879062,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165694
    },
    {
        "content": "<p>panicking also has countermeasures to avoid reentrancy</p>",
        "id": 277879069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277878765\">said</a>:</p>\n<blockquote>\n<p>you could have it be a late transformation pass on the IR if it is awkward in codegen</p>\n</blockquote>\n<p>What transformation pass?</p>",
        "id": 277879116,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165714
    },
    {
        "content": "<p>replace <code>Trap(msg)</code> with <code>Call(\"intrinsic::abort_with_msg\", msg)</code></p>",
        "id": 277879182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165747
    },
    {
        "content": "<p>Pipeline is <code>frontend</code> -&gt; <code>frontend_required</code> -&gt; <code>user</code> -&gt; <code>optimizers</code> (selected by <code>-O</code>, none at <code>-O0</code>) -&gt; backend</p>",
        "id": 277879190,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277879182\">said</a>:</p>\n<blockquote>\n<p>replace <code>Trap(msg)</code> with <code>Call(\"intrinsic::abort_with_msg\", msg)</code></p>\n</blockquote>\n<p><code>Trap</code> is a concept in <code>xlang_backend</code>. It's how the generic backend instructs the raw, target-specific, backend to generate a trap.</p>",
        "id": 277879286,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165788
    },
    {
        "content": "<p><a href=\"https://github.com/LightningCreations/lccc/blob/main/xlang/xlang_backend/src/lib.rs#L277\">https://github.com/LightningCreations/lccc/blob/main/xlang/xlang_backend/src/lib.rs#L277</a> is some example code.</p>",
        "id": 277879451,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649165860
    },
    {
        "content": "<p>based on that code, I would try to stuff the name of the abort function in <code>TargetProperties</code></p>",
        "id": 277879727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649165973
    },
    {
        "content": "<p>TargetProperties ABI breaks <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span>.</p>",
        "id": 277879894,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649166036
    },
    {
        "content": "<p>or possibly adding it to <code>FunctionRawCodegen</code> as another function or a modification of <code>write_trap</code></p>",
        "id": 277880264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649166198
    },
    {
        "content": "<p>There's not much that <code>write_trap</code> (or most of codegen-x86/others)  knows about the target:<br>\n<a href=\"https://github.com/LightningCreations/lccc/blob/main/codegen-x86/src/lib.rs#L152\">https://github.com/LightningCreations/lccc/blob/main/codegen-x86/src/lib.rs#L152</a></p>",
        "id": 277880530,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649166311
    },
    {
        "content": "<p>you are right, the one in the best position to handle it would be <code>FunctionCodegen</code> itself since you want to call <code>call_fn</code>. If you can get the <code>Path</code> of lang items somehow you can call that</p>",
        "id": 277881872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649166860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277865858\">said</a>:</p>\n<blockquote>\n<p>Well, if you make ptr2int2ptr casts UB, then the snippet you posted has UB and could print anything. If they are not UB, then it would have to print 10.</p>\n</blockquote>\n<p>If uintptr_t exists it must be able to round-trip pointers, so no, that code never has UB, and we're never going to break that on CHERI</p>",
        "id": 277899248,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649173544
    },
    {
        "content": "<blockquote>\n<p>Or is it assumed that <code>set_value</code> has side-effects , and side-effects can include changing arbitrary stack variables?</p>\n</blockquote>\n<p>Wait, no, I think I get it. The compiler treats casting <code>&amp;value</code> to an <code>uintptr_t</code> as equivalent to escaping <code>value</code>'s address to a FFI function. Therefore, the compiler assumes that any function with side-effects potentially uses FFI to get the address back, therefore <code>set_value</code> must be assumed to potentially mutate <code>value</code>.</p>",
        "id": 277901575,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649174353
    },
    {
        "content": "<p>I think that works.</p>",
        "id": 277901603,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649174364
    },
    {
        "content": "<p>Jessica, the idea of strict provenance is to not support roundtripping, or not support it fully. And previous discussions made me realize we can‚Äôt have a perfect implementation of int2ptr ‚Äî it‚Äôs not possible to do it for ‚Äúinteger pointers‚Äù that come from C for instance</p>",
        "id": 277906462,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649176264
    },
    {
        "content": "<p>I don‚Äôt think anyone wants to break anything on CHERI. But right now nothing works on CHERI (I think?) and just getting strict-only provenance working is already an accomplishment . As a next step, we can implement ‚ÄúRust-only‚Äù polyfills for permissive provenance</p>",
        "id": 277906830,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649176405
    },
    {
        "content": "<p>Ah sorry, Oliver is asking about permissive provenance. It‚Äôs confusing because the topic is strict provenance. Never mind, carry on</p>",
        "id": 277907104,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649176509
    },
    {
        "content": "<p>I think the ‚Äúptr2int is FFI‚Äù part is only relevant for the compiler optimization part. It doesn‚Äôt magically make int2ptr work on CHERI</p>",
        "id": 277907284,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649176577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277906462\">said</a>:</p>\n<blockquote>\n<p>Jessica, the idea of strict provenance is to not support roundtripping, or not support it fully. And previous discussions made me realize we can‚Äôt have a perfect implementation of int2ptr ‚Äî it‚Äôs not possible to do it for ‚Äúinteger pointers‚Äù that come from C for instance</p>\n</blockquote>\n<p>I think Jessica's point is that Oliver's example uses <code>uintptr_t</code> which is a C type required to be able to round trip a pointer so there is no UB in that C code (though it might not compile on weird implementations). If you change it to use <code>size_t</code> analogous to <code>usize</code>then it is indeed UB.</p>",
        "id": 277907901,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649176839
    },
    {
        "content": "<p>and that's because CHERI implements <code>uintptr_t</code> as actually a pointer type, right? a.k.a the <code>uptr</code> type from <code>sptr</code> crate</p>",
        "id": 277908531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649177087
    },
    {
        "content": "<p>in which case there isn't really any ptr2int2ptr roundtripping happening</p>",
        "id": 277908609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649177123
    },
    {
        "content": "<p>I personally don‚Äôt read the C17 standard that way ‚Äî in my interpretation, the result only has to be ==, not actually function the same. But Jessica‚Äôs is also a reasonable interpretation. </p>\n<p>CHERI C indeed defines that uintptr_t would optionally be a capability.</p>",
        "id": 277910948,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649178106
    },
    {
        "content": "<p>So no ‚Äúreal‚Äù roundtripping occurs indeed</p>",
        "id": 277911174,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649178204
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> </p>\n<blockquote>\n<p>actually I think it is very easy to ensure that all optimizations are correct wrt permissive provenance: just treat ptr2int and int2ptr as FFI operations. even under strict provenance then, ptr2int might store that pointer 'somewhere', and int2ptr might return it.</p>\n</blockquote>\n<p>Is the idea that the FFI code could have some \"oracle\" which tells it which of the many possible provenances it should return? (Because as mentioned the map solution doesn't actually work in practice). I think that makes sense, although if you combined the strict provenance model with the kind of non-deterministic reasoning from your twinsem paper, then couldn't the compiler reason that such an oracle is not possible?</p>",
        "id": 277914616,
        "sender_full_name": "Diggsey",
        "timestamp": 1649179609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277910948\">said</a>:</p>\n<blockquote>\n<p>I personally don‚Äôt read the C17 standard that way ‚Äî in my interpretation, the result only has to be ==, not actually function the same. But Jessica‚Äôs is also a reasonable interpretation. </p>\n</blockquote>\n<p>It's a reasonable interpretation, it's the interpretation of every C compiler, it's the interpretation of a lot of code both before and after the standard, it's the interpretation of literally every proposal by the working group trying to give a reasonably formal definition. Saying a unusable pointer result is a plausible interpretation of the intent of the less formal English in C17 and prior is stretching the definition of plausible. Of course, on CHERI having this work means that uintptr_t is not quite a well-behaved <em>integer</em>, but at least that empirically mostly works in practice.</p>",
        "id": 277916660,
        "sender_full_name": "Talchas",
        "timestamp": 1649180438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277865547\">said</a>:</p>\n<blockquote>\n<p>So... my apologies if I'm showing my ignorance, trying to figure out the rules here. Given this code:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">set_value</span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ...</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is there a possible scenario where the above prints 42?</p>\n</blockquote>\n<p>if you ignore the Rust aliasing rules (Stacked Borrows), then under my proposed semantics this will definitely print 10.</p>\n<p>however, under Rust aliasing rules, when you do <code>value = 42</code>, all other pointers (\"provenances\") that can access this local get invalidated, making the next call to <code>set_value</code> UB.</p>",
        "id": 277920723,
        "sender_full_name": "RalfJ",
        "timestamp": 1649182185
    },
    {
        "content": "<p>The code cant even be interpreted under strict provenance since it uses an operation that is banned in that model (int2ptr casts). So I don't think that is a well-defined question.</p>",
        "id": 277920892,
        "sender_full_name": "RalfJ",
        "timestamp": 1649182245
    },
    {
        "content": "<p>(and also the question seems off-topic in this topic, and probably should have been a new topic. ;) generally it's probably a good idea to have a new topic for a new question, if it didnt come up in the middle of an active existing discussion.)</p>",
        "id": 277920995,
        "sender_full_name": "RalfJ",
        "timestamp": 1649182299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277914616\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> </p>\n<blockquote>\n<p>actually I think it is very easy to ensure that all optimizations are correct wrt permissive provenance: just treat ptr2int and int2ptr as FFI operations. even under strict provenance then, ptr2int might store that pointer 'somewhere', and int2ptr might return it.</p>\n</blockquote>\n<p>Is the idea that the FFI code could have some \"oracle\" which tells it which of the many possible provenances it should return? (Because as mentioned the map solution doesn't actually work in practice). I think that makes sense, although if you combined the strict provenance model with the kind of non-deterministic reasoning from your twinsem paper, then couldn't the compiler reason that such an oracle is not possible?</p>\n</blockquote>\n<p>yes, basically. for each specific piece of code, I think there exists <em>some</em> implementation of that FFI that does the right thing. for instance, if we ignore concurrency and non-determinism, the FFI might just hard-code the sequence of provenances it will return.<br>\nit's just impossible to implement this FFI once-and-for-all.</p>\n<p>for that reason I dont think the compiler can do a twinsem-style argument. the twinsem argument crucially relies on the fact that if we did an alternative execution where a different base address had been picked, the unknown function we are reasoning about would <em>execute the exact same way</em> since it had no chance to actually inspect the variable where the address is stored, and the AM state is equal up to that variable. the argument does not apply here since ptr2int explicitly leaks the provenance to the outside world, meaning you can no longer just say \"these two situations must behave exactly the same since the outside world cannot possibly have observed any difference\".</p>",
        "id": 277921639,
        "sender_full_name": "RalfJ",
        "timestamp": 1649182585
    },
    {
        "content": "<blockquote>\n<p>meaning you can no longer just say \"these two situations must behave exactly the same since the outside world cannot possibly have observed any difference\".</p>\n</blockquote>\n<p>You can if you limit the effect of ptr2int a la stacked borrows protectors, right?</p>",
        "id": 277925697,
        "sender_full_name": "bjorn3",
        "timestamp": 1649184056
    },
    {
        "content": "<p>I dont think so</p>",
        "id": 277926226,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184242
    },
    {
        "content": "<p>like, twinsem did all this work to make sure ptr2int is pure</p>",
        "id": 277926260,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184252
    },
    {
        "content": "<p>but we <em>know</em> it cannot be pure for us because of <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html\">https://lists.llvm.org/pipermail/llvm-dev/2021-June/151521.html</a> (blogpost upcoming Any Day Now)</p>",
        "id": 277926296,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184268
    },
    {
        "content": "<p>twinsem got away with it since it doesnt do <code>restrict</code>/<code>noalias</code>/SB</p>",
        "id": 277926318,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277926226\">said</a>:</p>\n<blockquote>\n<p>I dont think so</p>\n</blockquote>\n<p>With raw pointers there would be no protectors, but for &amp;mut T and &amp;T you can limit it, right?</p>",
        "id": 277926496,
        "sender_full_name": "bjorn3",
        "timestamp": 1649184362
    },
    {
        "content": "<p>but due to the above counterexample, I am going to claim that the twinsem approach cannot be generalized to more complicated models. I accept a concrete formal model definition as counterargument to my claim. ;) but not some vague sketch on the level of \"something like twinsem\".</p>",
        "id": 277926547,
        "sender_full_name": "RalfJ",
        "timestamp": 1649184370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277916660\">said</a>:</p>\n<blockquote>\n<p>Saying a unusable pointer result is a plausible interpretation of the intent of the less formal English in C17 and prior is stretching the definition of plausible.</p>\n</blockquote>\n<p>I agree that C compilers are extremely unlikely to give you an invalid pointer here. I guess the standard is simply underspecified. But C17 is pretty formal here:</p>\n<blockquote>\n<p>any valid pointer to <code>void</code> can be converted to this type, then converted back to pointer to <code>void</code>, and the result will compare equal to the original pointer</p>\n</blockquote>\n<p>If \"equality comparison\" here doesn't refer to <code>==</code>, I don't know what it is. And by <a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</a> , we know that <code>==</code> pointers are in general definitely not equivalent.</p>\n<p>Probably just an unfortunate formulation by the authors, and my expectations w.r.t. formality of the standard are too high :3</p>",
        "id": 277931039,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649186412
    },
    {
        "content": "<blockquote>\n<p>I really hope we don't get in the business of doing optimizations like that. That is the sort of thing that makes devs hate compiler writers</p>\n</blockquote>\n<p>Yes but in Rust we're at much better position than C to do that (or even not emit <code>ud2</code>).</p>",
        "id": 277955951,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649199864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"340138\">Chayim Refael Friedman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/277955951\">said</a>:</p>\n<blockquote>\n<p>Yes but in Rust we're at much better position than C to do that (or even not emit <code>ud2</code>).</p>\n</blockquote>\n<p>One of the things I like most about Rust is the recognition that \"No diagnostic is required\" is bad!</p>",
        "id": 277962101,
        "sender_full_name": "riking",
        "timestamp": 1649205308
    },
    {
        "content": "<blockquote>\n<p>One of the things I like most about Rust is the recognition that \"No diagnostic is required\" is bad!</p>\n</blockquote>\n<p>Are you talking about diagnosing UBs? Because this is hard to impossible to do reliably at compile time.</p>",
        "id": 277966582,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649210044
    },
    {
        "content": "<p>I have an optimization that exploits strict provenance AIUI:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">xpi</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">xp</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"n\">xpi</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278381483,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649469717
    },
    {
        "content": "<p>Is it OK to optimize the last statement to the constant 1764 (42 * 42)?</p>",
        "id": 278381537,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649469743
    },
    {
        "content": "<p>that one does a ptr-to-int transmute. as I keep saying, those are just Cursed.</p>",
        "id": 278381546,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469768
    },
    {
        "content": "<p>Note that you could replace transmute with a call to an opaque C function <code>transmewt()</code> that just does a transmute under the hood.</p>",
        "id": 278381562,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649469815
    },
    {
        "content": "<p>So the compiler can't special case the name <code>mem::transmute</code>.</p>",
        "id": 278381573,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649469825
    },
    {
        "content": "<p>yeah sure</p>",
        "id": 278381580,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469832
    },
    {
        "content": "<p>well it can if you do call <code>transmute</code></p>",
        "id": 278381588,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469842
    },
    {
        "content": "<p>hmm, I suppose this is special in a sense because it's a newly created reference</p>",
        "id": 278381629,
        "sender_full_name": "Talchas",
        "timestamp": 1649469863
    },
    {
        "content": "<p>literal <code>let x: something with an int = mem::transmute(something with a pointer)</code> is the easy case that could be special cased in general</p>",
        "id": 278381660,
        "sender_full_name": "Talchas",
        "timestamp": 1649469919
    },
    {
        "content": "<p>this is all covered by what I wrote <a href=\"https://www.reddit.com/r/rust/comments/tu5bw4/new_experimental_unsafe_rust_api_in_nightly/i3469k8/\">before</a> which I thought you agreed with ;)<br>\nif you do ptr-to-int transmutes, that is \"wild provenance\", not \"permissive provenance\". my claim about it being easy to ensure we dont do any optimizations that break code is for \"permissive provenance\". I think \"wild provenance\" is fundamentally impossible to support without global cost -- as in, <em>the entire program</em> has to be pessimized if wild provenance is to be used anywhere. there is no \"gradual migration\" or so.</p>",
        "id": 278381663,
        "sender_full_name": "RalfJ",
        "timestamp": 1649469921
    },
    {
        "content": "<p>but in general that example could just be <code>fn uninlined_foo(x: *mut i32) -&gt; usize</code> if you are thinking of it as an opaque C function</p>",
        "id": 278381719,
        "sender_full_name": "Talchas",
        "timestamp": 1649469967
    },
    {
        "content": "<p>if you call an opaque function the compiler ofc has to be correct for <em>any</em> possible implementation of that function that can be expressed in the Rust AM. the Rust AM can express <code>expose_addr</code>, so the compilation has to be correct if that C function does the equivalent of <code>expose_addr</code>, and hence the optimization cannot happen.</p>",
        "id": 278381730,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470012
    },
    {
        "content": "<p>But isn't all code wild provenance if you have an FFI? Because you could launder a ptr-to-int transmute through FFI.</p>",
        "id": 278381733,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649470020
    },
    {
        "content": "<p>no FFI is a complete red herring</p>",
        "id": 278381741,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470030
    },
    {
        "content": "<p>no idea why people keep bringing it up^^</p>",
        "id": 278381742,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470036
    },
    {
        "content": "<p>the name <code>transmute</code> is a red herring tbh</p>",
        "id": 278381744,
        "sender_full_name": "Talchas",
        "timestamp": 1649470040
    },
    {
        "content": "<p>the issue is the pointer pun case</p>",
        "id": 278381749,
        "sender_full_name": "Talchas",
        "timestamp": 1649470054
    },
    {
        "content": "<p>well those are both issues, just orthogonal ones ;)</p>",
        "id": 278381759,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470069
    },
    {
        "content": "<p>(and thus since transmute is defined somewhat as a pun, it's an issue)</p>",
        "id": 278381762,
        "sender_full_name": "Talchas",
        "timestamp": 1649470080
    },
    {
        "content": "<p>when you call an FFI function (a truly opaque one, no xLTO), the promise you make to the compiler is that \"the effects of this function on the AM state can be described by <em>some</em> regular AM code. that's it.</p>",
        "id": 278381813,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470140
    },
    {
        "content": "<p>so if that thing is implemented in assembly as the identity function, and you declare that the effect on the AM state is the expose the input pointer and then return its address -- that is coherent, and compilation has to be correct for that case.</p>",
        "id": 278381822,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470174
    },
    {
        "content": "<p>anyways, if you replace that transmute with <code>ffi(&amp;mut *xp)</code> or <code>&amp;mut *xp as *mut i32 as usize</code> then that snippet very much cannot be optimized without strict provenance</p>",
        "id": 278381829,
        "sender_full_name": "Talchas",
        "timestamp": 1649470192
    },
    {
        "content": "<p>if you declare that the effect on the AM state is just to return the address without exposing, that is also coherent.<br>\nits your choice though, and you are not telling the compiler your choice, so as long as <em>any</em> choice does what you want, you are good.</p>",
        "id": 278381873,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278381829\">said</a>:</p>\n<blockquote>\n<p>anyways, if you replace that transmute with <code>ffi(&amp;mut *xp)</code> or <code>&amp;mut *xp as *mut i32 as usize</code> then that snippet very much cannot be optimized without strict provenance</p>\n</blockquote>\n<p>with <code>ffi</code> it cannot be optimized even with strict provenance</p>",
        "id": 278381884,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470262
    },
    {
        "content": "<p>I guess I'm not understanding what your proposed semantics for <code>mem::transmute</code> are. Does <code>mem::transmute</code> expose addresses that are transmuted?</p>",
        "id": 278381887,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649470264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278381887\">said</a>:</p>\n<blockquote>\n<p>I guess I'm not understanding what your proposed semantics for <code>mem::transmute</code> are. Does <code>mem::transmute</code> expose addresses that are transmuted?</p>\n</blockquote>\n<p>no</p>",
        "id": 278381899,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470285
    },
    {
        "content": "<p>the proposed semantics for your transmute are that it's UB because you are producing an integer value that has provenance</p>",
        "id": 278381907,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470308
    },
    {
        "content": "<p>(yes we could add special exceptions for very particular monomorphizations of transmute, that doesnt change the general point)</p>",
        "id": 278381951,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470339
    },
    {
        "content": "<p>OK, so <code>mem::transmute::&lt;*mut T, usize&gt;</code> is different from <code>expose_addr</code>.</p>",
        "id": 278382025,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649470459
    },
    {
        "content": "<p><em>yes</em></p>",
        "id": 278382036,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470483
    },
    {
        "content": "<p>maybe I should have said that more explicitly? I kept saying ptr-to-int transmutes should be UB so I thought them being different from <code>expose_addr</code> was implied ;)</p>",
        "id": 278382047,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278382025\">said</a>:</p>\n<blockquote>\n<p>OK, so <code>mem::transmute::&lt;*mut T, usize&gt;</code> is different from <code>expose_addr</code>.</p>\n</blockquote>\n<p>and while we could hack around that by special-casing <code>mem::transmute</code> for certain types, the issue remains with the following function that is still different from <code>expose_addr</code> (and I dont know how to fix that without a global cost):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">my_transmute</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">).</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278382291,
        "sender_full_name": "RalfJ",
        "timestamp": 1649470892
    },
    {
        "content": "<p>OK, I get it now, thanks. I think you're right that under a permissive provenance model, strict provenance optimizations work as long as they treat <code>ptr as usize</code>/<code>usize as ptr</code> as effectively opaque function calls.</p>",
        "id": 278382347,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649470942
    },
    {
        "content": "<p>strict provenance optimizations, including the ones LLVM has been doing since forever ;)</p>",
        "id": 278382378,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471023
    },
    {
        "content": "<p>I'm not 100% sure LLVM isn't paying that cost already modulo bugs, but that would require more clarity on what are bugs and what are unplanned changes to the spec</p>",
        "id": 278382423,
        "sender_full_name": "Talchas",
        "timestamp": 1649471044
    },
    {
        "content": "<p>well, it's certainly possible to have an LLVM where we dont pay that cost</p>",
        "id": 278382434,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471083
    },
    {
        "content": "<p>ofc, there is no telling where LLVM will actually move, and as you say its current spec isnt precise enough to distinguish this</p>",
        "id": 278382451,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471112
    },
    {
        "content": "<p>yeah, LangRef certainly permits it afaict, but that doesn't mean optimization passes might not intentionally break code that does it</p>",
        "id": 278382502,
        "sender_full_name": "Talchas",
        "timestamp": 1649471170
    },
    {
        "content": "<p>and if they fix the bugs by treating <code>ptrtoint</code> as a side-effecting operation, we can lobby for them to add a variant that does <em>not</em> have the side-effect so that Rust's <code>addr</code> can still get All The Optimizations ;)</p>",
        "id": 278382508,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471180
    },
    {
        "content": "<p>I guess under a \"global strict provenance\" regime, where we can assume the entire codebase uses strict provenance, you could imagine doing the optimization on this code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">xpi</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"n\">xpi</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278382511,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471187
    },
    {
        "content": "<p>on <code>addr</code> I think we can always do it</p>",
        "id": 278382514,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471206
    },
    {
        "content": "<p>but not on <code>expose_addr</code></p>",
        "id": 278382516,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471212
    },
    {
        "content": "<p>Right</p>",
        "id": 278382517,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471215
    },
    {
        "content": "<p>well, you can do that even without global strict provenance as long as <code>addr()</code> has its own intrinsic to lower to</p>",
        "id": 278382519,
        "sender_full_name": "Talchas",
        "timestamp": 1649471218
    },
    {
        "content": "<p>since it would be illegal under global-strict-provenance for <code>bar</code> to dereference <code>xpi</code>.</p>",
        "id": 278382520,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471222
    },
    {
        "content": "<p>the <code>addr</code> docs now even explicilty say that you cannot cast this int back to a dereferencable ptr</p>",
        "id": 278382526,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471230
    },
    {
        "content": "<p>Also that nobody else can, not even C code you call.</p>",
        "id": 278382529,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471250
    },
    {
        "content": "<p>(or the OS kernel.)</p>",
        "id": 278382530,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471251
    },
    {
        "content": "<p>so I think it is illegal period. that's just what the docs for that method say.</p>",
        "id": 278382535,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471256
    },
    {
        "content": "<p>yes. as I said above, FFI operations have to be describable by something <em>that AM code could do</em></p>",
        "id": 278382540,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471273
    },
    {
        "content": "<p>that's like how not even FFI code can write to data behind <code>&amp;T</code></p>",
        "id": 278382581,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471304
    },
    {
        "content": "<p>(in the sense of, if FFI code does that it's UB)</p>",
        "id": 278382586,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471312
    },
    {
        "content": "<p>(UnsafeCell exceptions apply)</p>",
        "id": 278382591,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471327
    },
    {
        "content": "<p>But old code couldn't be using <code>addr</code> because it didn't exist, so there shouldn't be a back compat hazard in this case.</p>",
        "id": 278382597,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471337
    },
    {
        "content": "<p>yes that is exactly the plan :)</p>",
        "id": 278382603,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471347
    },
    {
        "content": "<p>Cool, I like it :)</p>",
        "id": 278382606,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471358
    },
    {
        "content": "<p><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 278382610,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471363
    },
    {
        "content": "<p>Thanks for patiently explaining it to me as always :)</p>",
        "id": 278382618,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471381
    },
    {
        "content": "<p>sure. :) happy to get more stakeholders on board :D</p>",
        "id": 278382688,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471453
    },
    {
        "content": "<p>I think this is an example of a \"carrot and not stick\" optimization that I was talking about. Since <code>addr</code> didn't exist before, we can actually tell programmers that you can get new optimizations by migrating your <code>ptr as usize</code> to <code>.addr()</code>.</p>",
        "id": 278382692,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471461
    },
    {
        "content": "<p>When it's safe to do so, of course.</p>",
        "id": 278382702,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471477
    },
    {
        "content": "<p>the main backcompat hazard I am worried about are those cursed ptr-to-int transmutes. I dont have a good fallback plan for those, if it somehow turns out we absolutely must allow them.</p>",
        "id": 278382709,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278382692\">said</a>:</p>\n<blockquote>\n<p>I think this is an example of a \"carrot and not stick\" optimization that I was talking about. Since <code>addr</code> didn't exist before, we can actually tell programmers that you can get new optimizations by migrating your <code>ptr as usize</code> to <code>.addr()</code>.</p>\n</blockquote>\n<p>yes, indeed. I thought I had tried to express that when you brought up carrots and sticks a few days ago but maybe I imagined it, or I didnt express myself very clearly.</p>",
        "id": 278382760,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471531
    },
    {
        "content": "<p>I'm guessing treating transmute as implicitly exposing the addresses of any pointers transmuted is just way too imprecise?</p>",
        "id": 278382772,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471555
    },
    {
        "content": "<p>though its not new optimizations you get. its the ones you already got but shouldnt have gotten. ;)</p>",
        "id": 278382775,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278382772\">said</a>:</p>\n<blockquote>\n<p>I'm guessing treating transmute as implicitly exposing the addresses of any pointers transmuted is just way too imprecise?</p>\n</blockquote>\n<p>consider the <code>my_transmute</code> -- that's just a raw ptr load. the compiler doesn't even know that a transmute is going on.<br>\ndo we want every raw ptr load to expose things? that means even if the result of the load is unused, we have to preserve this expose side-effect since some other code might rely on it!</p>",
        "id": 278382797,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471615
    },
    {
        "content": "<p>Yeah, too imprecise</p>",
        "id": 278382802,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471627
    },
    {
        "content": "<p>FWIW, that is kinda what PNVI-ae-udi says C should do. I am curious how that will pan out.</p>",
        "id": 278382875,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471706
    },
    {
        "content": "<p>C is in a slightly better position since <code>my_transmute</code> is already UB due to strict provenance</p>",
        "id": 278382889,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471726
    },
    {
        "content": "<p>so it's not <em>every</em> pointer load for them</p>",
        "id": 278382891,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471733
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278382775\">said</a>:</p>\n<blockquote>\n<p>though its not new optimizations you get. its the ones you already got but shouldnt have gotten. ;)</p>\n</blockquote>\n<p>Are you sure LLVM is aggressive here? I just tried this in C++ and LLVM was conservative: <a href=\"https://godbolt.org/z/fT14a9Pdf\">https://godbolt.org/z/fT14a9Pdf</a></p>",
        "id": 278382938,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471766
    },
    {
        "content": "<p>Which I would expect: treating the address of <code>x</code> as not exposed would probably break C++ code left and right</p>",
        "id": 278382946,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471793
    },
    {
        "content": "<p>it's very hard to explore this with concrete examples</p>",
        "id": 278383033,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471935
    },
    {
        "content": "<p>the best I got is a series of transformations all of which LLVM considers legal, that would break some such code</p>",
        "id": 278383040,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471952
    },
    {
        "content": "<p>and Rust doesn't either: <a href=\"https://godbolt.org/z/bqox7Yx4x\">https://godbolt.org/z/bqox7Yx4x</a></p>",
        "id": 278383043,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471955
    },
    {
        "content": "<p>actually making LLVM do all these optimizations in the right order could be very tricky</p>",
        "id": 278383046,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471963
    },
    {
        "content": "<p>but that's an accident, not for any good reason</p>",
        "id": 278383048,
        "sender_full_name": "RalfJ",
        "timestamp": 1649471973
    },
    {
        "content": "<p>Yeah, I think because LLVM is conservative about provenance out of fear of breaking working code.</p>",
        "id": 278383050,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471978
    },
    {
        "content": "<p>But if we have <code>addr</code>, then we don't have to be as conservative. I hope anyway!</p>",
        "id": 278383057,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649471993
    },
    {
        "content": "<p>Which is great, it means we can go fast</p>",
        "id": 278383062,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472001
    },
    {
        "content": "<p>we do have <em>some</em> concrete examples where it is not conservative enough</p>",
        "id": 278383096,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472003
    },
    {
        "content": "<p>Yeah, I don't doubt it</p>",
        "id": 278383106,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472010
    },
    {
        "content": "<p><a href=\"https://bugs.llvm.org/show_bug.cgi?id=35229\">https://bugs.llvm.org/show_bug.cgi?id=35229</a><br>\n<a href=\"https://bugs.llvm.org/show_bug.cgi?id=34548\">https://bugs.llvm.org/show_bug.cgi?id=34548</a></p>",
        "id": 278383109,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472019
    },
    {
        "content": "<p>but those are all artificially crafted</p>",
        "id": 278383113,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472032
    },
    {
        "content": "<p>It would be basically this <a href=\"https://godbolt.org/z/qr54WdGz3\">https://godbolt.org/z/qr54WdGz3</a></p>",
        "id": 278383117,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649472050
    },
    {
        "content": "<p>it's super hard to have real-world code examples as I doubt any real code affected by this would even notice that's what is going on</p>",
        "id": 278383119,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472051
    },
    {
        "content": "<p>I suspect there's real code out there that would go faster if we could be more aggressive about provenance-based optimizations.</p>",
        "id": 278383122,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383048\">said</a>:</p>\n<blockquote>\n<p>but that's an accident, not for any good reason</p>\n</blockquote>\n<p>Note that lccc has a similar thing, but as a design feature - plugins should be valid to run in any order as long as the frontend is first and codegen is last.</p>",
        "id": 278383124,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649472062
    },
    {
        "content": "<p>Which would be a lovely outcome of this work, and I think it would excite people :)</p>",
        "id": 278383127,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472064
    },
    {
        "content": "<p>they'd just assume it's UB in their code and fiddle with it until it works</p>",
        "id": 278383128,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383124\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383048\">said</a>:</p>\n<blockquote>\n<p>but that's an accident, not for any good reason</p>\n</blockquote>\n<p>Note that lccc has a similar thing, but as a design feature - plugins should be valid to run in any order as long as the frontend is first and codegen is last.</p>\n</blockquote>\n<p>yeah I think that's in theory also true for LLVM. but in practice...</p>",
        "id": 278383136,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472093
    },
    {
        "content": "<p>so I hope lccc does <em>not</em> have the thing where sequencing optimizations in the right order (even if they dont ever actually happen in that order) leads to buggy results :D</p>",
        "id": 278383202,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383122\">said</a>:</p>\n<blockquote>\n<p>I suspect there's real code out there that would go faster if we could be more aggressive about provenance-based optimizations.</p>\n</blockquote>\n<p>yeah, I hope it can help in particular around ptr tagging code</p>",
        "id": 278383205,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472178
    },
    {
        "content": "<p>And because you opt in, not opt out, we can introduce these optimizations without fear of breakage. (I guess C++ could too by introducing new types of casts, like <code>addr_cast</code> or whatever.)</p>",
        "id": 278383208,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472184
    },
    {
        "content": "<p>but I am not an expert on what limits compilers when analyzing such code</p>",
        "id": 278383215,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383202\">said</a>:</p>\n<blockquote>\n<p>so I hope lccc does <em>not</em> have the thing where sequencing optimizations in the right order (even if they dont ever actually happen in that order) leads to buggy results :D</p>\n</blockquote>\n<p>I'll make sure to run the builtin optimizers in random configurations as a test suite.</p>",
        "id": 278383223,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649472226
    },
    {
        "content": "<p>Main thing is that an ptr-to-int transmute is UB in C without <code>-f-no-strict-aliasing</code>.</p>",
        "id": 278383224,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649472230
    },
    {
        "content": "<p>But even with, clang miscompiles this, weird</p>",
        "id": 278383265,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649472244
    },
    {
        "content": "<p>Come to think of it, that would be a nice blog post to write, maybe I'll do that.</p>",
        "id": 278383267,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472245
    },
    {
        "content": "<p>\"Why you should use <code>.addr()</code>: better optimizations in the future\"</p>",
        "id": 278383272,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383223\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383202\">said</a>:</p>\n<blockquote>\n<p>so I hope lccc does <em>not</em> have the thing where sequencing optimizations in the right order (even if they dont ever actually happen in that order) leads to buggy results :D</p>\n</blockquote>\n<p>I'll make sure to run the builtin optimizers in random configurations as a test suite.</p>\n</blockquote>\n<p>now you just need the test suite to decide whether the performed optimization is correct. which is only a little harder than the halting problem. ;)</p>",
        "id": 278383273,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472262
    },
    {
        "content": "<p>Because sometimes you just want the address of a pointer because you're printing it or using it as a hash table key or something, but you aren't ever going to turn that address back into a pointer, and right now we have at least one example of LLVM pessimizing such code because it doesn't know what you're going to do with it.</p>",
        "id": 278383294,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383224\">said</a>:</p>\n<blockquote>\n<p>Main thing is that an ptr-to-int transmute is UB in C without <code>-f-no-strict-aliasing</code>.</p>\n</blockquote>\n<p>no that's not true. there are some legal ways to type-pun.</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"nf\">my_transmute</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">uintptr_t</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">res</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">uintptr_t</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is allowed. does it 'expose' <code>x</code>? no idea.</p>",
        "id": 278383295,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383273\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383223\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383202\">said</a>:</p>\n<blockquote>\n<p>so I hope lccc does <em>not</em> have the thing where sequencing optimizations in the right order (even if they dont ever actually happen in that order) leads to buggy results :D</p>\n</blockquote>\n<p>I'll make sure to run the builtin optimizers in random configurations as a test suite.</p>\n</blockquote>\n<p>now you just need the test suite to decide whether the performed optimization is correct. which is only a little harder than the halting problem. ;)</p>\n</blockquote>\n<p>Well, probably it will just be handed the language test suites.</p>",
        "id": 278383360,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649472418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383267\">said</a>:</p>\n<blockquote>\n<p>Come to think of it, that would be a nice blog post to write, maybe I'll do that.</p>\n</blockquote>\n<p>yeah, having blog posts on this from more parts of the community would be great :D</p>",
        "id": 278383365,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383265\">said</a>:</p>\n<blockquote>\n<p>But even with, clang miscompiles this, weird</p>\n</blockquote>\n<p>I cant read assembly. can you tell me where there is a miscompilation in your example? :D</p>",
        "id": 278383505,
        "sender_full_name": "RalfJ",
        "timestamp": 1649472616
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">mov</span><span class=\"w\">     </span><span class=\"n\">eax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1764</span><span class=\"w\"></span>\n<span class=\"n\">pop</span><span class=\"w\">     </span><span class=\"n\">rcx</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Basically clang optimizes out the x * x into 42 * 42.</p>",
        "id": 278383526,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649472695
    },
    {
        "content": "<p>WIth standard C it works tho, <a href=\"https://godbolt.org/z/aYTh7KaKa\">https://godbolt.org/z/aYTh7KaKa</a></p>",
        "id": 278383532,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649472715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278383117\">said</a>:</p>\n<blockquote>\n<p>It would be basically this <a href=\"https://godbolt.org/z/qr54WdGz3\">https://godbolt.org/z/qr54WdGz3</a></p>\n</blockquote>\n<p>But wait, that doesn't pass the address of <code>x</code>, that dereferences <code>xp</code>, right?</p>",
        "id": 278383675,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472944
    },
    {
        "content": "<p>Seems like a straightforward case of deleting UB, not provenance</p>",
        "id": 278383682,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649472963
    },
    {
        "content": "<p>Derp, yeah the actual one is fine <a href=\"https://godbolt.org/z/c55r43Tsq\">https://godbolt.org/z/c55r43Tsq</a></p>",
        "id": 278383735,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473007
    },
    {
        "content": "<p>You loaded 64 bits of a 32-bit stack address.</p>",
        "id": 278383738,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473013
    },
    {
        "content": "<p>OK :)</p>",
        "id": 278383740,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473016
    },
    {
        "content": "<p>(I love the way LLVM was just \"yeah, no\" and deleted the invalid load) :)</p>",
        "id": 278383758,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473076
    },
    {
        "content": "<p>Another obvious, though probably silly, theoretical optimization that would depend on strict provenance would be to delete any ptr-to-int transmutes, as well as <code>ptr as usize</code>, as dead code. :)</p>",
        "id": 278383815,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473172
    },
    {
        "content": "<p>(Not suggesting we do this for obvious reasons, though it would be valid)</p>",
        "id": 278383822,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473190
    },
    {
        "content": "<p>Or just replace <code>ptr as usize</code> with <code>0</code>, I guess.</p>",
        "id": 278383897,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473216
    },
    {
        "content": "<p>ptr-to-int transmutes are still <em>sometimes</em> okay. like, you can transmute <code>ptr::invalid</code> to an int just fine. ;)</p>",
        "id": 278383938,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473257
    },
    {
        "content": "<p>It's the int-to-ptr transmute that's more painful, because we could just allow ptr-to-int and say its <code>addr()</code>.</p>",
        "id": 278383964,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473302
    },
    {
        "content": "<p>no that's not trivial either</p>",
        "id": 278383970,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473320
    },
    {
        "content": "<p>Oh?</p>",
        "id": 278384010,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473338
    },
    {
        "content": "<p>Deleting obvious UB <em>can</em> be useful if it can never happen dynamically (perhaps due to monomorphized code where the types are constant only during monomorphized codegen), just as a code size win, though I expect the effects would be small.</p>",
        "id": 278384016,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473356
    },
    {
        "content": "<p>it violates the property that tranmsute T ‚Üí U ‚Üí T can be replaced by just doing nothing. or at least, it makes that argument a lot more complicated.</p>",
        "id": 278384017,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473358
    },
    {
        "content": "<p>also I expect people doing such transmutes will expect that after transmuting back they can dereference that pointer</p>",
        "id": 278384035,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473401
    },
    {
        "content": "<p>And sometimes replacing obvious UB with <code>ud2</code> can be a last-ditch security win, though you never want to rely on it.</p>",
        "id": 278384036,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473403
    },
    {
        "content": "<p>so while it allows more code, it still defies user expectations</p>",
        "id": 278384040,
        "sender_full_name": "RalfJ",
        "timestamp": 1649473413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278384040\">said</a>:</p>\n<blockquote>\n<p>so while it allows more code, it still defies user expectations</p>\n</blockquote>\n<p>Agreed</p>",
        "id": 278384043,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473424
    },
    {
        "content": "<p>Definitely</p>",
        "id": 278384087,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649473449
    },
    {
        "content": "<p>I think a more realistic optimization opportunity would look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">spawn_monster</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">Monster</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">monster</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">Monster</span>::<span class=\"n\">new</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">monster</span><span class=\"p\">.</span><span class=\"n\">level</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"monster at address {} spawned\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">monster</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">monster</span><span class=\"p\">.</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">monster</span><span class=\"p\">.</span><span class=\"n\">level</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">monster</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278384367,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473953
    },
    {
        "content": "<p>where the compiler should be able to optimize <code>monster.hp = monster.level * 10</code> to <code>monster.hp = 100</code>, but in practice often will not because it doesn't know that the <code>println</code> won't dereference the address</p>",
        "id": 278384380,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649473982
    },
    {
        "content": "<p>whereas if you use <code>.addr()</code>, the compiler should be able to do that optimization</p>",
        "id": 278384390,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649474040
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 278384743,
        "sender_full_name": "RalfJ",
        "timestamp": 1649474593
    },
    {
        "content": "<p>That reminds me of an issue that pointed out how printing something after a loop makes the loop slower (because the print takes an address, and the address being taken reduced optimization) -- maybe it was <a href=\"https://github.com/rust-lang/rust/issues/49457\">https://github.com/rust-lang/rust/issues/49457</a></p>\n<p>I don't think that strict provenance fixes that, though.</p>",
        "id": 278384865,
        "sender_full_name": "scottmcm",
        "timestamp": 1649474782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278384367\">said</a>:</p>\n<blockquote>\n<p>I think a more realistic optimization opportunity would look like this:</p>\n</blockquote>\n<p>And it's even more interesting if you say <code>println!(\"monster at address {:p} spawned\", &amp;monster)</code> (imho) because the <code>.addr()</code> is in stdlib not user code</p>",
        "id": 278444667,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649559760
    },
    {
        "content": "<p>(ah didn't realize that was yesterday I didn't get on yesterday)</p>",
        "id": 278444684,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649559789
    },
    {
        "content": "<p>we need to specify whether <code>{:p}</code> does <code>addr</code> or <code>expose_addr</code>...</p>",
        "id": 278472264,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602360
    },
    {
        "content": "<p>I don‚Äôt see a reason to make it <code>expose_addr</code></p>",
        "id": 278475784,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649606951
    },
    {
        "content": "<p>let's hope <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> doesn't tell us they use <code>{:p}</code> and then parse back the address and deref that pointer and expect that to work for some unspeakable reason ;)</p>",
        "id": 278477218,
        "sender_full_name": "RalfJ",
        "timestamp": 1649608580
    },
    {
        "content": "<p>well, at least there isn't <code>impl FromStr for *mut T</code> to justify it like there is <code>scanf(\"%p\")</code></p>",
        "id": 278477270,
        "sender_full_name": "Talchas",
        "timestamp": 1649608661
    },
    {
        "content": "<p>I don't see a reason to <em>not</em> make it <code>expose_addr</code>. It's almost the definition of exposing an address (literally, to the user)</p>",
        "id": 278477344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649608738
    },
    {
        "content": "<p>sure we could make it UB but it seems like a natural thing for a user to try</p>",
        "id": 278477377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649608794
    },
    {
        "content": "<p>the main difference between <code>addr</code> and <code>expose_addr</code> from the compiler's end is that the latter is less likely to be optimized away, but in <code>{:p}</code> it's definitely not going anywhere</p>",
        "id": 278477455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649608897
    },
    {
        "content": "<p>implementation-wise it's almost certainly going to be an expose and fmt certainly isn't super fast to start with</p>",
        "id": 278477460,
        "sender_full_name": "Talchas",
        "timestamp": 1649608907
    },
    {
        "content": "<p>(fmt would have to add a feature to make <code>.addr()</code> called before virtualization and uninlined fmt machinery)</p>",
        "id": 278477523,
        "sender_full_name": "Talchas",
        "timestamp": 1649608968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278477455\">said</a>:</p>\n<blockquote>\n<p>the main difference between <code>addr</code> and <code>expose_addr</code> from the compiler's end is that the latter is less likely to be optimized away, but in <code>{:p}</code> it's definitely not going anywhere</p>\n</blockquote>\n<p>there's also the key difference whether the compiler does have to account for the possibility that other code might to accesses with this pointer. and with <code>addr</code>, it doesn't. that can help a lot for alias analysis.</p>",
        "id": 278477528,
        "sender_full_name": "RalfJ",
        "timestamp": 1649608973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278477523\">said</a>:</p>\n<blockquote>\n<p>(fmt would have to add a feature to make <code>.addr()</code> called before virtualization and uninlined fmt machinery)</p>\n</blockquote>\n<p>hm okay that is fair, even with <code>addr</code> the compiler might have a real hard time telling that <code>expose_addr</code> isnt being called...</p>",
        "id": 278477554,
        "sender_full_name": "RalfJ",
        "timestamp": 1649609025
    },
    {
        "content": "<p>if the fmt traits weren't stable, it could instead be something like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Pointer</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Repr</span>: <span class=\"nc\">Pointer2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">early_fmt</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Repr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Pointer2</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">fmt</span><span class=\"p\">(</span><span class=\"n\">same</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278477690,
        "sender_full_name": "Talchas",
        "timestamp": 1649609181
    },
    {
        "content": "<p>maybe if specialization ever becomes usable for associated types that could be added with backcompat and not needing magic trait lookup in format_args!()</p>",
        "id": 278477727,
        "sender_full_name": "Talchas",
        "timestamp": 1649609241
    },
    {
        "content": "<p>Having it be <code>expose_addr</code> could make it quite slow on CHERI.</p>",
        "id": 278480255,
        "sender_full_name": "Zoxc",
        "timestamp": 1649612211
    },
    {
        "content": "<p><code>expose_addr</code> basically means it doesn't work on CEHRI (yes I know there are some ideas for getting <code>from_exposed_addr</code> to work on CHERI but they dont sound very realistic to me -- I'd be happy to be proven wrong though ;)</p>",
        "id": 278480957,
        "sender_full_name": "RalfJ",
        "timestamp": 1649613017
    },
    {
        "content": "<p>as in, on CHERI <code>from_exposed_addr</code> cannot be called -- which means <code>addr</code> and <code>expose_addr</code> are the same</p>",
        "id": 278480967,
        "sender_full_name": "RalfJ",
        "timestamp": 1649613040
    },
    {
        "content": "<p>And <code>expose_addr</code> would mean that <code>{:p}</code> doesn‚Äôt pass the <code>strict_provenance</code> lint. I expect that that would annoy users quite a bit</p>",
        "id": 278482493,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649615019
    },
    {
        "content": "<p>‚Ä¶I think? Depends on how the lint is implemented</p>",
        "id": 278482577,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649615116
    },
    {
        "content": "<p>I mentioned this on Ralf's PR but there is no need to consider <code>expose_addr</code> as violating <code>strict_provenance</code> and we shouldn't lint on it</p>",
        "id": 278482742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649615375
    },
    {
        "content": "<p><code>from_exposed_addr</code> is the only one to watch out for</p>",
        "id": 278482756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649615395
    },
    {
        "content": "<p>similarly we don't need to lint on <code>*const T as usize</code> except for the reason \"stop using <code>as</code>, use these library functions instead to declare your intent\" (which is not quite the same as violating <code>strict_provenance</code>)</p>",
        "id": 278482854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649615510
    },
    {
        "content": "<p>what's the point in <code>expose_addr</code> if there is no <code>from_exposed_addr</code> though ^^ If I want my code to be \"strict provenance compliant\" I would want to not be allowed to do <code>expose_addr</code>since it is meaningless</p>",
        "id": 278482932,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649615633
    },
    {
        "content": "<p>because a library can be strict provenance compliant while also supporting non-SP user code</p>",
        "id": 278483157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649615916
    },
    {
        "content": "<p>if your code is strict provenance compliant then you don't have to care about <code>expose_addr</code> and can just pretend they are all <code>addr</code></p>",
        "id": 278483173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649615973
    },
    {
        "content": "<p>I think it  is quite reasonable for a conscientious library to choose explicitly to use <code>expose_addr</code> because they don't want to cause surprising UB for users, and also enable <code>strict_provenance</code> linting</p>",
        "id": 278483251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649616067
    },
    {
        "content": "<p>The biggest reason to be strict provenance compliant but use <code>expose_addr</code> would be that you previously used <code>as usize</code> and don't want to change the existing behavior</p>",
        "id": 278485755,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649619329
    },
    {
        "content": "<p>E.g. there's nothing violating strict provenance in the implementation of <code>{:p}</code>, the point at which strict provenance is when you turn that representation back into a pointer and use it</p>",
        "id": 278485827,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649619389
    },
    {
        "content": "<p>With the current formatting traits, it is possible to format a pointer without type erasing it</p>",
        "id": 278486032,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649619623
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=1dcca7b6bf8b2ef2a29eebdb71e90dbb\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=1dcca7b6bf8b2ef2a29eebdb71e90dbb</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Evil</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Evil</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">fmt</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">fmt</span>::<span class=\"n\">Formatter</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">fmt</span>::<span class=\"nb\">Result</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">to_raw_parts</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">addr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Pointer</span>::<span class=\"n\">fmt</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// expose?</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span>::<span class=\"n\">from_exposed_addr</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span>::<span class=\"n\">from_raw_parts</span>::<span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278486295,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649619978
    },
    {
        "content": "<p>This is <em>very</em> artificial of course, but it shows that this <em>is</em> possible</p>",
        "id": 278486328,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278477218\">said</a>:</p>\n<blockquote>\n<p>let's hope <span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> doesn't tell us they use <code>{:p}</code> and then parse back the address and deref that pointer and expect that to work for some unspeakable reason ;)</p>\n</blockquote>\n<p><a href=\"https://zakaluka.github.io/2019/12/14/daily-coding-problem-6.html\">https://zakaluka.github.io/2019/12/14/daily-coding-problem-6.html</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">address</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">elt</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">usize</span>::<span class=\"n\">from_str_radix</span><span class=\"p\">(</span><span class=\"fm\">format!</span><span class=\"p\">(</span><span class=\"s\">\"{:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">elt</span><span class=\"p\">).</span><span class=\"n\">trim_start_matches</span><span class=\"p\">(</span><span class=\"s\">\"0x\"</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278490409,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649625637
    },
    {
        "content": "<p>lol</p>\n<blockquote>\n<p>Problem 6 - XOR Linked List</p>\n</blockquote>\n<p>there's your problem...</p>",
        "id": 278490435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649625687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278477554\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278477523\">said</a>:</p>\n<blockquote>\n<p>(fmt would have to add a feature to make <code>.addr()</code> called before virtualization and uninlined fmt machinery)</p>\n</blockquote>\n<p>hm okay that is fair, even with <code>addr</code> the compiler might have a real hard time telling that <code>expose_addr</code> isnt being called...</p>\n</blockquote>\n<p>If we are going to do inter-procedural analysis for address escaping, then this becomes no longer true</p>",
        "id": 278490527,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649625811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278475784\">said</a>:</p>\n<blockquote>\n<p>I don‚Äôt see a reason to make it <code>expose_addr</code></p>\n</blockquote>\n<p>Here's a reason: C does it.<br>\nThe rules for <code>scanf</code> (7.19.6.2 12) say that you can round-trip a pointer through <code>%p</code>.<br>\nGranted, they only say that it must compare equal to the one that was passed to <code>printf</code>, but the current standard revision does not yet have a concept of provenance, so that's the best you can get.</p>\n<p>We are of course not bound to do as C does, and in this case I think it's quite niche.</p>",
        "id": 278490534,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1649625831
    },
    {
        "content": "<p>Although... if the <code>{:p}</code> ends up in libc, the analysis might end up having to conservatively assume it escapes</p>",
        "id": 278490576,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649625854
    },
    {
        "content": "<p>barring a magic \"this doesn't escape\" attribute on the FFI binding or something</p>",
        "id": 278490603,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1649625918
    },
    {
        "content": "<p>Yeah</p>",
        "id": 278490665,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649625963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278490409\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278477218\">said</a>:</p>\n<blockquote>\n<p>let's hope <span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> doesn't tell us they use <code>{:p}</code> and then parse back the address and deref that pointer and expect that to work for some unspeakable reason ;)</p>\n</blockquote>\n<p><a href=\"https://zakaluka.github.io/2019/12/14/daily-coding-problem-6.html\">https://zakaluka.github.io/2019/12/14/daily-coding-problem-6.html</a></p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">address</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">elt</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">usize</span>::<span class=\"n\">from_str_radix</span><span class=\"p\">(</span><span class=\"fm\">format!</span><span class=\"p\">(</span><span class=\"s\">\"{:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">elt</span><span class=\"p\">).</span><span class=\"n\">trim_start_matches</span><span class=\"p\">(</span><span class=\"s\">\"0x\"</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>uh... but.... WHY???  <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 278491484,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627277
    },
    {
        "content": "<blockquote>\n<p>Here's a reason: C does it.</p>\n</blockquote>\n<p>I'm already planning to diverge from C on the ptr-to-int transmute side, so -- not sure if that's a good enough argument</p>",
        "id": 278491531,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627315
    },
    {
        "content": "<p>TBF they were a) learning Rust for the first time and b) implementing an XOR linked list</p>",
        "id": 278491540,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627348
    },
    {
        "content": "<p>right but something must be <em>seriously</em> wrong with our docs if they go for <em>that</em> rather than <code>elt as *const _ as usize</code>...</p>",
        "id": 278491607,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627438
    },
    {
        "content": "<p>Given they typically were using python, it looks like, it's not unlikely that it was an already known pattern for getting the address of an object</p>",
        "id": 278491703,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627594
    },
    {
        "content": "<p>I'm not trying to justify it, just to guess why they would've used that as a solution</p>",
        "id": 278491711,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627629
    },
    {
        "content": "<p>yeah</p>",
        "id": 278491789,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627707
    },
    {
        "content": "<p>well, not sure if that is a good argument for <code>expose_addr</code> but indeed interesting to see what people will do. I expect people with so little Rust experience will break all of the aliasing rules so that code is probably a lost cause anyway in terms of UB...</p>",
        "id": 278491799,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627749
    },
    {
        "content": "<p>It's typical for beginners to write UB in C, I think the only way we can definitely make things better is with warnings in the compiler <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 278491868,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649627848
    },
    {
        "content": "<p>I can say run Miri all I want but it doesn't work on all code and it's not beginner-friendly, and it's possible to just miss that it exists</p>",
        "id": 278491917,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649627904
    },
    {
        "content": "<p>Warnings in the compiler and best-effort checks in debug mode</p>",
        "id": 278498263,
        "sender_full_name": "Wanja Hentze",
        "timestamp": 1649637628
    },
    {
        "content": "<p>I don't know how to do provenance checks in debug mode. I recently added a bunch of debug checks to the standard library so I'm up for adding more such things if you have ideas</p>",
        "id": 278498960,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649638722
    },
    {
        "content": "<p>you can't...? Provenance checks can only be inserted by the compiler if you get lucky and can prove some static UB, or by a dynamic checker like Miri</p>",
        "id": 278499417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649639382
    },
    {
        "content": "<p>Yeah, unless you're on CHERI, MIRI, or some other high-level interpreter, Provenance is pure magic compiler shadow state that you can't really view at runtime.</p>",
        "id": 278499489,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649639492
    },
    {
        "content": "<p>You totally could check it by altering codegen to emit something like all the shadow state that ASan uses</p>",
        "id": 278500001,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649640216
    },
    {
        "content": "<p>It would not be easy and it would probably be slow, but that's different from impossible</p>",
        "id": 278500051,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649640258
    },
    {
        "content": "<p>And if this is something like debug assertions which don't have any obligation to be sound, there may be enormous corners you can cut to make it more efficient</p>",
        "id": 278500122,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649640371
    },
    {
        "content": "<p>I think <code>{:p}</code> should be <code>addr</code>. I highly doubt anyone is parsing addresses at runtime :)</p>",
        "id": 278609115,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649707600
    },
    {
        "content": "<p>The closest thing that people actually do is dynamic linkers, or Apple's old implementation of GCC precompiled headers (which coredumps GCC after parsing the headers so that that coredump can be read in later and resumed), but in those cases the addresses are binary, not ASCII</p>",
        "id": 278609305,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1649707702
    },
    {
        "content": "<p>In a CHERI C world, the runtime linker (and the C startup code for static binaries) does the equivalent of with_addr to create all global pointers, PLTs, GOTs, etc in the relocation phase. The source pointers are provided by the ELF auxargs array or mmap depending on which part of the program you're dealing with.</p>",
        "id": 278611322,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649708527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Optimizations.20that.20exploit.20strict.20provenance/near/278609115\">said</a>:</p>\n<blockquote>\n<p>I think <code>{:p}</code> should be <code>addr</code>. I highly doubt anyone is parsing addresses at runtime :)</p>\n</blockquote>\n<p>you mean besides <a href=\"https://zakaluka.github.io/2019/12/14/daily-coding-problem-6.html\">this example someone found in the wild</a> ;)</p>",
        "id": 278624871,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715708
    }
]