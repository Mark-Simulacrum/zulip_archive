[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">write_escaped</span><span class=\"p\">(</span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">collections</span>::<span class=\"n\">TryReserveError</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"c1\">//or</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">write_escaped</span><span class=\"p\">(</span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">collections</span>::<span class=\"n\">TryReserveError</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If TryReserveError is returned, dst could be invalid utf8 because it might end in a multi byte char that got truncated. Alternatively the public api could be a wrapper function with a cold error path that decreases dst len back to valid utf8 with floor_char_boundary.</p>",
        "id": 276878606,
        "sender_full_name": "Bot+",
        "timestamp": 1648476657
    },
    {
        "content": "<p>If the allocation reservation fails why does the Vec or String change at all? Shouldn't that happen once before any bytes are written, and then if it works you'd know all bytes can be written?</p>",
        "id": 276878907,
        "sender_full_name": "Lokathor",
        "timestamp": 1648476810
    },
    {
        "content": "<p>Not all characters are escaped. I could always allocate <code>src.len() * longest_escape_sequence.len()</code> but that would be wasteful. Point of write_escaped is to read src only once so dst len is unknown. (I use escape() that returns a COW for values written multiple times)</p>",
        "id": 276880333,
        "sender_full_name": "Bot+",
        "timestamp": 1648477387
    },
    {
        "content": "<p>Another option is to reduce the length of <code>dst</code> back down to its original length on allocation failure. Then it is unchanged, except for the potentially increased capacity.</p>",
        "id": 276884101,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1648478880
    },
    {
        "content": "<p>Yeah that seems like the right approach. Also be Very Careful to avoid panics, or set up a panic guard that does the same thing.</p>",
        "id": 276884707,
        "sender_full_name": "Gankra",
        "timestamp": 1648479124
    },
    {
        "content": "<p>or just don't even change the len until the end, after you've done all writing successfully</p>",
        "id": 276888075,
        "sender_full_name": "Lokathor",
        "timestamp": 1648480313
    }
]