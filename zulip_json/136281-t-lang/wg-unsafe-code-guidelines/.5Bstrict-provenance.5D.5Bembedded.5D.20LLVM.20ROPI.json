[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230304\">Francesco Dainese</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277532053\">said</a>:</p>\n<blockquote>\n<p>I was thinking of opening an issue and labeling it <code>A-strict provenance</code> since I actually have a valid use case that would break strict provenance, it's an intersection of embedded, LLVM buggy support for ROPI, and function pointers... But since I only have a rough understanding, I'd like to get some more minds on it first  to maybe iron out the details or discard it as non-issue, or even label it properly.</p>\n</blockquote>\n<p>I'm working on a project where there has been a long standing issue due to LLVM's buggy ROPI support (Read Only Position Independent code)  (sorry I couldn't find the original source, perhaps it's only specific to this platform) and to overcome the issue <a href=\"https://github.com/LedgerHQ/nanosplus-secure-sdk/blob/dd4684c36592ddbdfc1df78e045d93376beaba96/src/pic.c#L27-L34\">some pointer arithmetic</a> has to be done, and from my understanding this would break strict provenance. <br>\nThis is used in the project whenever accessing memory in read-only space, like functions, or sometimes even literals <a href=\"https://github.com/Zondax/ledger-rust/blob/main/zemu/src/ui_toolkit.rs#L214\">(not just <code>str</code>s)</a>...</p>\n<p>Is this a usecase not covered by strict-provenance? Is this enough information to open an issue with <code>A strict-provenance</code> ?</p>",
        "id": 277533505,
        "sender_full_name": "Francesco Dainese",
        "timestamp": 1648910775
    },
    {
        "content": "<p>I also found a custom <a href=\"https://github.com/obsidiansystems/ledger-platform/blob/develop/llvm-pass/LedgerROPI/Pass.cpp\">LLVM pass</a> to fix this issue with LLVM (while searching for work done to address this).<br>\nIn the same repo, in its history, there used to be an LLVM fork instead of the pass. Or at least in the default.nix was specified a custom fork and where to get it...</p>",
        "id": 277533676,
        "sender_full_name": "Francesco Dainese",
        "timestamp": 1648910996
    },
    {
        "content": "<p>Are you talking about Rust code? Your link contains a mix of C and assembly. In any case, pointer arithmetic can be done with strict provenance without even using the new methods, just <code>ptr.wrapping_offset()</code> and friends</p>",
        "id": 277536908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648914858
    },
    {
        "content": "<p>One way of looking at it is that before relocation your \"pointers\" are actually just offset relative to the PIC base and pic_internal creates an actual pointer by offsetting from the program counter/some other global base value. That kind of code also works with CHERI since otherwise we wouldn't be able to implement a runtime linker/OS kernel :)</p>",
        "id": 277538259,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1648916521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.5Bstrict-provenance.5D.5Bembedded.5D.20LLVM.20ROPI/near/277536908\">said</a>:</p>\n<blockquote>\n<p>Are you talking about Rust code? Your link contains a mix of C and assembly. In any case, pointer arithmetic can be done with strict provenance without even using the new methods, just <code>ptr.wrapping_offset()</code> and friends</p>\n</blockquote>\n<p>well it's most C yes, but we use it in Rust too, actually a there are limitations in what we can use in Rust due to this buggy ROPI support, like dyn traits... but what I wanted to know is if this would need a looser provenance</p>",
        "id": 277563666,
        "sender_full_name": "Francesco Dainese",
        "timestamp": 1648950872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"473929\">Alexander Richardson</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/.5Bstrict-provenance.5D.5Bembedded.5D.20LLVM.20ROPI/near/277538259\">said</a>:</p>\n<blockquote>\n<p>One way of looking at it is that before relocation your \"pointers\" are actually just offset relative to the PIC base and pic_internal creates an actual pointer by offsetting from the program counter/some other global base value. That kind of code also works with CHERI since otherwise we wouldn't be able to implement a runtime linker/OS kernel :)</p>\n</blockquote>\n<p>so how would you maintain provenance using this reasoning?</p>",
        "id": 277563695,
        "sender_full_name": "Francesco Dainese",
        "timestamp": 1648950914
    },
    {
        "content": "<p>not sure if this is what you're asking, but the \"program counter\" has provenance valid for at least the whole executable/dylib image</p>",
        "id": 277567734,
        "sender_full_name": "eddyb",
        "timestamp": 1648956960
    },
    {
        "content": "<p>(or you could have a separate pointer-capability in some register for accessing non-code areas, though if the PC works that's probably optimal)</p>",
        "id": 277567789,
        "sender_full_name": "eddyb",
        "timestamp": 1648957041
    },
    {
        "content": "<p>oh I see, \"some pointer arithmetic\" in the first message is a link, and that's the relevant bit, sorry</p>",
        "id": 277567843,
        "sender_full_name": "eddyb",
        "timestamp": 1648957093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230304\">@Francesco Dainese</span> <a href=\"https://github.com/LedgerHQ/nanosplus-secure-sdk/blob/dd4684c36592ddbdfc1df78e045d93376beaba96/src/pic.c#L57\">this line</a> is equivalent to this Rust code <em>today</em>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">link_address</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"p\">.</span><span class=\"n\">wrapping_offset</span><span class=\"p\">((</span><span class=\"n\">link_address</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the provenance comes from <code>en</code> which comes from inline asm which on CHERI would cover everything accessible through <code>r9</code> (in your case it's <em>at least that</em>, and includes much more)</p>",
        "id": 277567985,
        "sender_full_name": "eddyb",
        "timestamp": 1648957309
    },
    {
        "content": "<p>with strict provenance I guess you could replace the <code>as usize</code> with <code>.addr()</code> though if those aren't actual pointers but some kind of \"offsets\" or \"pre-relocation pseudo-virtual-addresses\", you could use <code>usize</code> instead of pointers</p>",
        "id": 277568047,
        "sender_full_name": "eddyb",
        "timestamp": 1648957392
    },
    {
        "content": "<p>oh I guess <code>link_address</code> specifically is either a pointer or the more offset-y thing depending on value, so it needs to stay a pointer (or use <code>uptr</code> from the <code>sptr</code> crate)</p>",
        "id": 277568098,
        "sender_full_name": "eddyb",
        "timestamp": 1648957457
    },
    {
        "content": "<p>Oh I see, thank you for the explanation :)</p>",
        "id": 277577274,
        "sender_full_name": "Francesco Dainese",
        "timestamp": 1648963801
    }
]