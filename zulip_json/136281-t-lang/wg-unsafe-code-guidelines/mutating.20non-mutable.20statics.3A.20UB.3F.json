[
    {
        "content": "<p>static FOO: u32 = 0;<br>\nlet ptr = &amp;FOO as *const u32 as *mut u32; <br>\n*ptr += 1;</p>\n<p>is this distinctly UB, or does this just this fall out of rules for references? Or do we guarantee a safe crash, relying on the static being stuffed in rodata so that mutations cause page faults (in the same way that we rely on the stack's guard page to guarantee stack overflows are safe)?</p>",
        "id": 173201515,
        "sender_full_name": "Gankra",
        "timestamp": 1565788802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ^</p>",
        "id": 173201592,
        "sender_full_name": "Gankra",
        "timestamp": 1565788835
    },
    {
        "content": "<p>you are probably invoking UB before actually writing to the read-only memory</p>",
        "id": 173202451,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789364
    },
    {
        "content": "<p>by doing a write through a pointer derived from a <code>&amp;T</code></p>",
        "id": 173202484,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789383
    },
    {
        "content": "<p>if we get &amp;raw that won't be necessary anymore</p>",
        "id": 173202630,
        "sender_full_name": "Gankra",
        "timestamp": 1565789437
    },
    {
        "content": "<p>naively it should be easy/fine to just guarantee an abort, just like with stackoverflow, but I don't know enough about linkers and exotic platforms to know if there's nightmares. Or if llvm makes it too hard to say \"no really this is defined it's fine\"</p>",
        "id": 173202751,
        "sender_full_name": "Gankra",
        "timestamp": 1565789508
    },
    {
        "content": "<p>writing to read-only memory is UB in the abstract machine</p>",
        "id": 173202821,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789528
    },
    {
        "content": "<p>is that written anywhere?</p>",
        "id": 173202846,
        "sender_full_name": "Gankra",
        "timestamp": 1565789542
    },
    {
        "content": "<p>also what is our definition of read-only memory. I do not expect the abstract machine to have a notion of like, OS pages. Does it literally only arise from immutable statics?</p>",
        "id": 173202905,
        "sender_full_name": "Gankra",
        "timestamp": 1565789590
    },
    {
        "content": "<p>in the reference</p>",
        "id": 173202913,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789594
    },
    {
        "content": "<p>read-only memory is memory that can only be read from</p>",
        "id": 173202926,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789608
    },
    {
        "content": "<p>it doesn't really matter whether it is put on read-write memory on the actual hardware or not</p>",
        "id": 173202942,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789620
    },
    {
        "content": "<p>it is read-only in the abstract machine</p>",
        "id": 173202954,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789627
    },
    {
        "content": "<p>if you want to avoid that, you can use interior mutability</p>",
        "id": 173203011,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789647
    },
    {
        "content": "<p>right so how does one declare readonly memory?</p>",
        "id": 173203014,
        "sender_full_name": "Gankra",
        "timestamp": 1565789648
    },
    {
        "content": "<p>just statics?</p>",
        "id": 173203023,
        "sender_full_name": "Gankra",
        "timestamp": 1565789657
    },
    {
        "content": "<p>declare/acquire</p>",
        "id": 173203041,
        "sender_full_name": "Gankra",
        "timestamp": 1565789671
    },
    {
        "content": "<p><code>static FOO: T;</code> where <code>T</code> does not use interior mutability</p>",
        "id": 173203042,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789672
    },
    {
        "content": "<p>can you answer my question directly yes/no?</p>",
        "id": 173203067,
        "sender_full_name": "Gankra",
        "timestamp": 1565789691
    },
    {
        "content": "<p>i did answer it, it depends on the value that you put in the static</p>",
        "id": 173203089,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789704
    },
    {
        "content": "<p><code>static FOO: AtomicU32;</code> can be mutated, so it cannot be in read-only memory, but <code>static BAR: u32</code> cannot be mutated, so it can be</p>",
        "id": 173203117,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789726
    },
    {
        "content": "<p>i am asking if there's any way <em>other</em> than statics to get immutable memory</p>",
        "id": 173203144,
        "sender_full_name": "Gankra",
        "timestamp": 1565789744
    },
    {
        "content": "<p>probably</p>",
        "id": 173203163,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789759
    },
    {
        "content": "<p>you can ask the OS for some pages, write to them, and make them read only</p>",
        "id": 173203211,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789769
    },
    {
        "content": "<p>so OS pages are part of the abstract machine?</p>",
        "id": 173203234,
        "sender_full_name": "Gankra",
        "timestamp": 1565789783
    },
    {
        "content": "<p>no</p>",
        "id": 173203237,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789786
    },
    {
        "content": "<p>or not yet</p>",
        "id": 173203252,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789796
    },
    {
        "content": "<p>how does the model know/care that pages are readonly, then?</p>",
        "id": 173203262,
        "sender_full_name": "Gankra",
        "timestamp": 1565789804
    },
    {
        "content": "<p>it doesn't know about that</p>",
        "id": 173203272,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789815
    },
    {
        "content": "<p>so the abstract machine assumes they are all writable</p>",
        "id": 173203287,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789828
    },
    {
        "content": "<p>only for certain statics and other things can it assume that you are never writing to the memory</p>",
        "id": 173203308,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789852
    },
    {
        "content": "<p>e.g. <code>let x = 0_i32</code> puts an <code>i32</code> in memory that cannot be written to</p>",
        "id": 173203341,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789875
    },
    {
        "content": "<p>in the abstract machine</p>",
        "id": 173203389,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789883
    },
    {
        "content": "<p>what happens in actual hardware doesn't really matter</p>",
        "id": 173203459,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789951
    },
    {
        "content": "<p>rust will optimize under the assumption that you don't mutate immutable memory</p>",
        "id": 173203476,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565789968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span>  for <code>static</code>s there's a <code>Freeze</code> trait in the compiler</p>",
        "id": 173203479,
        "sender_full_name": "centril",
        "timestamp": 1565789972
    },
    {
        "content": "<p>ok so if i memmap in a readonly page and write to it, is that \"safe\" or...?</p>",
        "id": 173203495,
        "sender_full_name": "Gankra",
        "timestamp": 1565789992
    },
    {
        "content": "<p>depends on what mmap says about doing that</p>",
        "id": 173203588,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790047
    },
    {
        "content": "<p>its an FFI function, with its own semantics, and it tells you what's safe or not</p>",
        "id": 173203599,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790062
    },
    {
        "content": "<p>if it tells you that you can do that, then you can do it</p>",
        "id": 173203611,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> <a href=\"https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src/libcore/marker.rs#L592-L604\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src/libcore/marker.rs#L592-L604\">https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src/libcore/marker.rs#L592-L604</a></p>",
        "id": 173203626,
        "sender_full_name": "centril",
        "timestamp": 1565790093
    },
    {
        "content": "<p>types that implement Freeze _can_ be put in read-only memory when used in statics</p>",
        "id": 173203699,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790142
    },
    {
        "content": "<p>yes that's not interesting and i understand</p>",
        "id": 173203723,
        "sender_full_name": "Gankra",
        "timestamp": 1565790162
    },
    {
        "content": "<p>whether they will actually be put in read-only memory is something that's not guaranteed, it would depend on the target (does it support that?)</p>",
        "id": 173203752,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790201
    },
    {
        "content": "<p>but from Rust point-of-view, you cannot mutate them either way</p>",
        "id": 173203764,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790222
    },
    {
        "content": "<p>(I think we should consider exposing <code>Freeze</code>)</p>",
        "id": 173203823,
        "sender_full_name": "centril",
        "timestamp": 1565790246
    },
    {
        "content": "<p>in case it wasn't clear this is Gankro i just changed my name, i am working on the page in the rustonomicon enumerating all the distinct classes of UB</p>",
        "id": 173203861,
        "sender_full_name": "Gankra",
        "timestamp": 1565790280
    },
    {
        "content": "<p>(feeling like I'm being talked down to...)</p>",
        "id": 173203881,
        "sender_full_name": "Gankra",
        "timestamp": 1565790303
    },
    {
        "content": "<blockquote>\n<p>(I think we should consider exposing Freeze)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> what problem would that solve that can't be solved with UnsafeCell&lt;T&gt; ?</p>",
        "id": 173203934,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> let's start a new thread bout that</p>",
        "id": 173204088,
        "sender_full_name": "centril",
        "timestamp": 1565790430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I'd just mention writing to immutable memory as the form of UB</p>",
        "id": 173204381,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790627
    },
    {
        "content": "<p>or maybe through an immutable binding</p>",
        "id": 173204450,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790672
    },
    {
        "content": "<p>i can't do that without a clear definition of what \"immutable memory\" means. specifically this can very easily cause misconceptions around memmap and what the language supports wrt faults</p>",
        "id": 173204489,
        "sender_full_name": "Gankra",
        "timestamp": 1565790701
    },
    {
        "content": "<p>memmap and faults are properties of a target/platform</p>",
        "id": 173204551,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790723
    },
    {
        "content": "<p>i don't think we guarantee anywhere that if you write to read-only memory you get a diagnostic</p>",
        "id": 173204570,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790739
    },
    {
        "content": "<p>in the same way that we can't guarantee that for, e.g., if you overflow the stack</p>",
        "id": 173204590,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790749
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> I'd say it's better to be conservative and say that more things are not allowed than might be for now</p>",
        "id": 173204596,
        "sender_full_name": "centril",
        "timestamp": 1565790752
    },
    {
        "content": "<p>as far as i can tell, independently of the different ways that there are of creating immutable memory, all of them let you only access it from <code>&amp;T</code></p>",
        "id": 173204644,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790787
    },
    {
        "content": "<p>i agree and that's usually the philosophy of the nomicon, but this is a case where there are very real systems programming patterns at stake here, and not just weird trivia</p>",
        "id": 173204645,
        "sender_full_name": "Gankra",
        "timestamp": 1565790788
    },
    {
        "content": "<p>so the real UB is writing through an &amp;T</p>",
        "id": 173204661,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790803
    },
    {
        "content": "<p>as a concrete example, someone was adding asserts that we don't mutate the empty singleton, and I said they shouldn't bother because it will fault</p>",
        "id": 173204698,
        "sender_full_name": "Gankra",
        "timestamp": 1565790835
    },
    {
        "content": "<p>(empty hashmap singleton)</p>",
        "id": 173204752,
        "sender_full_name": "Gankra",
        "timestamp": 1565790847
    },
    {
        "content": "<p>e.g. <code>let mut x = 0; let x = x; *(&amp;x as *mut) = 3;</code> is UB, it doesn't really matter whether the x is in rw or ro memory</p>",
        "id": 173204754,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790848
    },
    {
        "content": "<p>the case of using raw is really worth addressing though</p>",
        "id": 173204797,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790881
    },
    {
        "content": "<p>yeah that falls out of the pointer aliasing rules, statics with &amp;raw introduce a distinct class of UB</p>",
        "id": 173204803,
        "sender_full_name": "Gankra",
        "timestamp": 1565790884
    },
    {
        "content": "<p>yep</p>",
        "id": 173204807,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790890
    },
    {
        "content": "<p>I don't think anybody has mentioned this in the &amp;raw RFC</p>",
        "id": 173204834,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790909
    },
    {
        "content": "<p>without <code>&amp;raw</code> we don't really need to talk about ro or rw memory</p>",
        "id": 173204850,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790924
    },
    {
        "content": "<p>only say that writes through &amp;T are not allowed unless T uses interior mutability</p>",
        "id": 173204885,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565790957
    },
    {
        "content": "<p>(and as long as there aren't any data-races, etc.)</p>",
        "id": 173205013,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565791029
    },
    {
        "content": "<p>with <code>&amp;raw</code> you can create a raw pointer directly to a memory location without going through a <code>&amp;T</code> and raw pointers don't really have these rules</p>",
        "id": 173205048,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565791057
    },
    {
        "content": "<p>idk, feels like RFC material</p>",
        "id": 173205063,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565791071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>  it's probably best noted on the rfc</p>",
        "id": 173205127,
        "sender_full_name": "centril",
        "timestamp": 1565791095
    },
    {
        "content": "<blockquote>\n<p>i am asking if there's any way <em>other</em> than statics to get immutable memory</p>\n</blockquote>\n<p>you could count const promotion, but that's basically anonymous statics</p>",
        "id": 173217153,
        "sender_full_name": "RalfJ",
        "timestamp": 1565798913
    },
    {
        "content": "<blockquote>\n<p>as a concrete example, someone was adding asserts that we don't mutate the empty singleton, and I said they shouldn't bother because it will fault</p>\n</blockquote>\n<p>we certainly don't <em>guarantee</em> a fault when writing to immutable memory</p>",
        "id": 173217288,
        "sender_full_name": "RalfJ",
        "timestamp": 1565799017
    },
    {
        "content": "<p>I'd say kernel allocations / mmap / ...  are outside of what the abstract machine can talk about. but we can add a notion of \"read-only allocation\" to the abstract machine. Miri has that in fact.</p>",
        "id": 173217316,
        "sender_full_name": "RalfJ",
        "timestamp": 1565799053
    },
    {
        "content": "<p>that said, this notion is not needed with stacked borrows: the original code up there has UB because it writes through a (pointer derived from) a shared reference</p>",
        "id": 173217336,
        "sender_full_name": "RalfJ",
        "timestamp": 1565799077
    },
    {
        "content": "<p><code>&amp;raw</code> doesnt change that either, like <code>as *const T</code> it, too, produces a read-only pointer (except for interior mutability of course)</p>",
        "id": 173217374,
        "sender_full_name": "RalfJ",
        "timestamp": 1565799104
    },
    {
        "content": "<p>Also see <a href=\"https://github.com/rust-lang/rust/issues/56604\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/56604\">https://github.com/rust-lang/rust/issues/56604</a> for the fact that right now, <code>as *mut T</code> and <code>as *const T as *mut T</code> are <em>not</em> the same</p>",
        "id": 173217504,
        "sender_full_name": "RalfJ",
        "timestamp": 1565799192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> ^</p>",
        "id": 173217506,
        "sender_full_name": "RalfJ",
        "timestamp": 1565799194
    },
    {
        "content": "<p>ah ok, so the distinction of <code>&amp;raw</code> and <code>&amp;raw mut</code> is actually important and not just a jank artifact of *mut and *const</p>",
        "id": 173220101,
        "sender_full_name": "Gankra",
        "timestamp": 1565801114
    },
    {
        "content": "<p>(haven't actually read through the &amp;raw proposal properly, mostly just assumed its content is obvious, since it's just there to fill a weird semantic hole we have)</p>",
        "id": 173220222,
        "sender_full_name": "Gankra",
        "timestamp": 1565801187
    },
    {
        "content": "<blockquote>\n<p>ah ok, so the distinction of <code>&amp;raw</code> and <code>&amp;raw mut</code> is actually important and not just a jank artifact of *mut and *const</p>\n</blockquote>\n<p>for Stacked Borrows right now it is. some would call that a bug.</p>",
        "id": 173220262,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801218
    },
    {
        "content": "<p>but maybe it's actually reasonable.</p>",
        "id": 173220294,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801233
    },
    {
        "content": "<p>that does certainly mess up the counter-proposal i was mulling</p>",
        "id": 173220320,
        "sender_full_name": "Gankra",
        "timestamp": 1565801251
    },
    {
        "content": "<p>well, \"right now\" isn't fair as <code>&amp;[mut] raw</code> is not implemented -- but there is a difference between <code>x as *const T</code> and <code>x as *mut T</code>, and I think the same would happen with the raw-ref operator</p>",
        "id": 173220334,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801268
    },
    {
        "content": "<p>huh? really?</p>",
        "id": 173220406,
        "sender_full_name": "Gankra",
        "timestamp": 1565801290
    },
    {
        "content": "<p>i agree that that feels like a bug at first blush :)</p>",
        "id": 173220416,
        "sender_full_name": "Gankra",
        "timestamp": 1565801305
    },
    {
        "content": "<p>the borrow checker treats them differently</p>",
        "id": 173220422,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801309
    },
    {
        "content": "<p>x is &amp;mut T here?</p>",
        "id": 173220446,
        "sender_full_name": "Gankra",
        "timestamp": 1565801322
    },
    {
        "content": "<p>yes</p>",
        "id": 173220451,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801326
    },
    {
        "content": "<p>so to make Stacked Borrows, as it was designed to be, a dynamic version of the borrow checker, I saw no choice but also treat them differently in Stacked Borrows. it is rather nice in terms of model simplicity, but it looks strange when seen from the surface language.</p>",
        "id": 173220499,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801353
    },
    {
        "content": "<p>so basically as *const T acts <em>as if</em> it implicitly also contained <code>as &amp;T</code> as a prefix?</p>",
        "id": 173220509,
        "sender_full_name": "Gankra",
        "timestamp": 1565801365
    },
    {
        "content": "<p>see <a href=\"https://github.com/rust-lang/rust/issues/56604#issuecomment-477954315\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/56604#issuecomment-477954315\">https://github.com/rust-lang/rust/issues/56604#issuecomment-477954315</a> for all the details, seems silly for me to type that all again^^</p>",
        "id": 173220529,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801383
    },
    {
        "content": "<blockquote>\n<p>so basically as *const T acts <em>as if</em> it implicitly also contained <code>as &amp;T</code> as a prefix?</p>\n</blockquote>\n<p>yes</p>",
        "id": 173220538,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801394
    },
    {
        "content": "<p>for borrow checking and Stacked Borrows alike</p>",
        "id": 173220597,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801407
    },
    {
        "content": "<p>hmm, so that definitely doesn't inherently motivate that behaviour for &amp;raw</p>",
        "id": 173220620,
        "sender_full_name": "Gankra",
        "timestamp": 1565801424
    },
    {
        "content": "<p>it suggests it's worth considering though</p>",
        "id": 173220641,
        "sender_full_name": "Gankra",
        "timestamp": 1565801438
    },
    {
        "content": "<p>but i would probably need to spend several days familiarizing myself with the currently proposed rules for what you can do with a raw pointer :s</p>",
        "id": 173220731,
        "sender_full_name": "Gankra",
        "timestamp": 1565801514
    },
    {
        "content": "<p>from a Stacked Borrows lense it does motivate that quite directly ;)</p>",
        "id": 173220783,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801528
    },
    {
        "content": "<p>the action of a \"raw const reborrow\" already exists there, and is used for <code>as *const T</code> casts</p>",
        "id": 173220802,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801543
    },
    {
        "content": "<p>I'd just use that same action for <code>&amp;raw</code></p>",
        "id": 173220813,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801548
    },
    {
        "content": "<p>and, specifically, that action creates read-only pointers (modulo <code>UnsafeCell</code>)</p>",
        "id": 173220826,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801563
    },
    {
        "content": "<p>ugh, what an ugly language wart</p>",
        "id": 173220847,
        "sender_full_name": "Gankra",
        "timestamp": 1565801578
    },
    {
        "content": "<p>it's actually less ugly in some sense than what I did before when It treated them the same^^</p>",
        "id": 173220871,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801600
    },
    {
        "content": "<blockquote>\n<p>but i would probably need to spend several days familiarizing myself with the currently proposed rules for what you can do with a raw pointer :s</p>\n</blockquote>\n<p>organizational question: that's mostly orthogonal to what my PR does, right?</p>",
        "id": 173220890,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801619
    },
    {
        "content": "<p>like, <code>&amp;raw</code> isnt going to be stable for quite a while</p>",
        "id": 173220895,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801626
    },
    {
        "content": "<p>yeah we can ignore the question for now</p>",
        "id": 173220950,
        "sender_full_name": "Gankra",
        "timestamp": 1565801643
    },
    {
        "content": "<p>and given the current level of details on aliasing rules in there, I think we can fudge this together with that</p>",
        "id": 173220962,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801653
    },
    {
        "content": "<p>although, it does seem quite important to the raw RFC</p>",
        "id": 173220964,
        "sender_full_name": "Gankra",
        "timestamp": 1565801656
    },
    {
        "content": "<p>we can always refine this later</p>",
        "id": 173220967,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801658
    },
    {
        "content": "<blockquote>\n<p>although, it does seem quite important to the raw RFC</p>\n</blockquote>\n<p>the problem being that the aliasing stuff is <em>so far</em> away from RFC-ready...</p>",
        "id": 173220986,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801679
    },
    {
        "content": "<p>I think the question about <code>&amp;raw</code> and about casts should have consistent answers anyway</p>",
        "id": 173221034,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801718
    },
    {
        "content": "<p>(in fact I will lobby to remove ref-to-raw casts from MIR and desugar them to raw reborrows)</p>",
        "id": 173221048,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801730
    },
    {
        "content": "<p>so really this was quite important when <code>as *const T</code> was introduced to the language, the question doesn't change much with <code>&amp;raw</code> IMO</p>",
        "id": 173221089,
        "sender_full_name": "RalfJ",
        "timestamp": 1565801753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> i'm not sure I agree with your assessment in the linked comment that we need to appeal to the cast/coercion being performed. One can understand it as a lint, like the rest of *mut vs *const. Is there anything wrong with proposing a model where a pointer only has permissions equivalent to the reference it was derived from? In this case yes we are deriving from an &amp;mut, but it's not a \"real\" &amp;mut, it's one in \"shared reference\" mode. does that make sense?</p>",
        "id": 173221514,
        "sender_full_name": "Gankra",
        "timestamp": 1565802045
    },
    {
        "content": "<p>(full disclosure, I intend in the fullness of time to push for a third *T type (~equivalent to today's ptr::NonNull), with the intent that everyone should eventually stop using <code>*const</code>/<code>*mut</code>, and everything should work fine, so it's a bit distressing to find a case where *const vs *mut is treated as meaningful)</p>",
        "id": 173221865,
        "sender_full_name": "Gankra",
        "timestamp": 1565802282
    },
    {
        "content": "<blockquote>\n<p>Is there anything wrong with proposing a model where a pointer only has permissions equivalent to the reference it was derived from?</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span>let x = &amp;mut 0;\nlet shared = &amp;*x;\nlet y: *const i32 = x;\nlet _val = *shared;\nunsafe { *(y as *mut i32) = 1; }\n</pre></div>\n\n\n<p>is this UB?<br>\nthis code stops compiling if you make <code>y: *mut T</code>. and making this code fine as-written would require significant re-architecting of stacked borrows. not saying that says we shouldn't do it, just saying that there is some way in which this is inherently more complicated than everything else stacked borrows does.</p>",
        "id": 173226050,
        "sender_full_name": "RalfJ",
        "timestamp": 1565805368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span>  \"new permissions depend on old permission\" is kind of complicated, in the sense that \"old permission\" can differ per-location. it also makes code harder to reason about, both for users and compilers.</p>",
        "id": 173226122,
        "sender_full_name": "RalfJ",
        "timestamp": 1565805439
    },
    {
        "content": "<p>but yes, this is what Stacked Borrows 1.0 did</p>",
        "id": 173226213,
        "sender_full_name": "RalfJ",
        "timestamp": 1565805489
    },
    {
        "content": "<p>but when Stacked Borrows 2 did more precise tracking for shared references, that didn't work any more</p>",
        "id": 173226225,
        "sender_full_name": "RalfJ",
        "timestamp": 1565805504
    },
    {
        "content": "<p>I agree the const/mut distinction here is a useful way for you to write code that doesn't compile if you fuck it up, as I agree it can be difficult to reason about when shared loans expire. It is not however clear to me that we actually <em>need</em> the cast to be the thing that specifically acquires a particular permission, instead of the permission just getting \"snapshot\" at the point where the  cast occurs. That said, I am starting to think that this doesn't make sense, as we now have non-lexical borrows, and so permission is explicitly driven by use. It could be that <code>as *mut</code> vs <code>as *const</code> specifically needs to be significant for purpose of extending borrow liveness. Not sure.</p>",
        "id": 173227889,
        "sender_full_name": "Gankra",
        "timestamp": 1565806511
    },
    {
        "content": "<p>hm. interesting thought.</p>",
        "id": 173228093,
        "sender_full_name": "RalfJ",
        "timestamp": 1565806650
    },
    {
        "content": "<p>This might also still actually jive okayish with my pointer unification proposal, if I make very precise tweeks to it.</p>",
        "id": 173228229,
        "sender_full_name": "Gankra",
        "timestamp": 1565806738
    },
    {
        "content": "<p>hmm, no you can't reasonably have const/mut decay to a unified *T as a coercion (as if they only really exist for the purposes of casts), because that would be asserting non-nullness as a coercion</p>",
        "id": 173228435,
        "sender_full_name": "Gankra",
        "timestamp": 1565806877
    },
    {
        "content": "<p>would have to be <code>unsafe { ... }</code></p>",
        "id": 173228565,
        "sender_full_name": "centril",
        "timestamp": 1565806960
    },
    {
        "content": "<p>too easy to miss in a swamp of unsafe code</p>",
        "id": 173228595,
        "sender_full_name": "Gankra",
        "timestamp": 1565806981
    },
    {
        "content": "<p>that's why I think unsafe blocks should be as narrowly scoped as possible <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 173228661,
        "sender_full_name": "centril",
        "timestamp": 1565807041
    },
    {
        "content": "<p>(also just to be 100% clear on the example I gave about removing assertions on the assumption that mutating the static will crash: they were just intended as debug assertions to catch bugs more immediately)</p>",
        "id": 173228737,
        "sender_full_name": "Gankra",
        "timestamp": 1565807084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> can anything go wrong if you accidentally have too much raw pointer permission? Does there exist a program under your model that is totally sound with <code>as *const</code>, but UB with <code>as *mut</code>, assuming literally every other line of code is the same? I should think not, right?</p>",
        "id": 173229257,
        "sender_full_name": "Gankra",
        "timestamp": 1565807468
    },
    {
        "content": "<p>unlike &amp;mut vs &amp;, it's just about a strict increase in permission, and not a trade of one permission for another? (shared ^ mut for references)</p>",
        "id": 173229437,
        "sender_full_name": "Gankra",
        "timestamp": 1565807560
    },
    {
        "content": "<blockquote>\n<p>that's why I think unsafe blocks should be as narrowly scoped as possible :)</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rfcs/pull/2585\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/2585\">https://github.com/rust-lang/rfcs/pull/2585</a></p>",
        "id": 173230607,
        "sender_full_name": "RalfJ",
        "timestamp": 1565808400
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> can anything go wrong if you accidentally have too much raw pointer permission? Does there exist a program under your model that is totally sound with <code>as *const</code>, but UB with <code>as *mut</code>, assuming literally every other line of code is the same? I should think not, right?</p>\n</blockquote>\n<p>I would think not. this should be monotone.<br>\nbut this is subtle enough that I won't say anything definite without <del>my lawyer</del> a proof</p>",
        "id": 173230662,
        "sender_full_name": "RalfJ",
        "timestamp": 1565808453
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://github.com/rust-lang/rfcs/pull/2585\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/2585\">https://github.com/rust-lang/rfcs/pull/2585</a></p>\n</blockquote>\n<p>(Yeah, I'm pro, but I'd also like <a href=\"https://github.com/Centril/rfcs/pull/17\" target=\"_blank\" title=\"https://github.com/Centril/rfcs/pull/17\">https://github.com/Centril/rfcs/pull/17</a> in that case)</p>",
        "id": 173230777,
        "sender_full_name": "centril",
        "timestamp": 1565808507
    },
    {
        "content": "<blockquote>\n<p>unlike &amp;mut vs &amp;, it's just about a strict increase in permission, and not a trade of one permission for another? (shared ^ mut for references)</p>\n</blockquote>\n<p>yeah. <code>*mut</code> is always <code>SharedReadWrite</code>; <code>*const</code> is either <code>SharedReadWrite</code> or <code>SharedReadOnly</code> depending on <code>UnsafeCell</code></p>",
        "id": 173230878,
        "sender_full_name": "RalfJ",
        "timestamp": 1565808592
    },
    {
        "content": "<p>so IIUC a <code>usize as *const T as *mut T</code> that writes would be UB, but <code>usize as *mut T</code> might be ok ?</p>",
        "id": 173235017,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811583
    },
    {
        "content": "<p>what if the <code>usize</code> points to immutable memory, and I do <code>usize as *mut T</code> ?</p>",
        "id": 173235033,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565811601
    },
    {
        "content": "<blockquote>\n<p>what if the <code>usize</code> points to immutable memory, and I do <code>usize as *mut T</code> ?</p>\n</blockquote>\n<p><code>as *mut</code> is only allowed from an <code>&amp;mut</code>. so how do you do that?</p>",
        "id": 173235411,
        "sender_full_name": "RalfJ",
        "timestamp": 1565811884
    },
    {
        "content": "<p><code>transmute</code> then</p>",
        "id": 173235665,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812070
    },
    {
        "content": "<p>you will in the end have derived that pointer from an <code>&amp;</code></p>",
        "id": 173236204,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812488
    },
    {
        "content": "<p>and that's UB</p>",
        "id": 173236212,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812491
    },
    {
        "content": "<p>I don't think you can avoid that</p>",
        "id": 173236219,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812496
    },
    {
        "content": "<p>makes sense</p>",
        "id": 173236258,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812529
    },
    {
        "content": "<p>I thought one could do an <code>usize as *mut</code> without going through an <code>&amp;mut T</code></p>",
        "id": 173236275,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812544
    },
    {
        "content": "<p>but how do you get the <code>usize</code>?</p>",
        "id": 173236287,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812558
    },
    {
        "content": "<p>i think that if <code>&amp;raw</code> returns a pointer from which no pointers that can write can be obtained, then all is good</p>",
        "id": 173236338,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812573
    },
    {
        "content": "<p>at this point the result heavily depends on lots of details -- without an executable example program, the answer will always be \"it depends\"^^</p>",
        "id": 173236343,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812580
    },
    {
        "content": "<p>if you have an static variable, the usize with its address can be another static</p>",
        "id": 173236354,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812592
    },
    {
        "content": "<p>the linker can fill those appropriately (a bit of unnecessary, but bare with me)</p>",
        "id": 173236367,
        "sender_full_name": "gnzlbg",
        "timestamp": 1565812613
    },
    {
        "content": "<p>heh, pointers created by CTFE ;) I thought about that. no idea what the rules should be.</p>",
        "id": 173236379,
        "sender_full_name": "RalfJ",
        "timestamp": 1565812625
    },
    {
        "content": "<blockquote>\n<p>how do you get that <code>usize</code>?</p>\n</blockquote>\n<p>It could always be a fixed hardware address ;3</p>\n<p>because you totally <em>can</em> write <code>*(0x0400_0000_usize as *mut u16).write_volatile(1);</code>, and however else you decide the rest of pointers works, Rust needs to support that sort of expression working on many targets of varying obscurity.</p>",
        "id": 173263656,
        "sender_full_name": "Lokathor",
        "timestamp": 1565841514
    },
    {
        "content": "<p>of course, I think that having a 98% complete  memory model and saying \"also the hardware is allowed to do its own extra things\" is acceptable</p>",
        "id": 173263805,
        "sender_full_name": "Lokathor",
        "timestamp": 1565841781
    },
    {
        "content": "<p>so \"that's platform specific\" is fine</p>",
        "id": 173263816,
        "sender_full_name": "Lokathor",
        "timestamp": 1565841796
    },
    {
        "content": "<p>you are mixing \"made-up\" integer addresses and volatile. two complex subjects. yeah it'll be a bit until we get there. ;)</p>",
        "id": 173273908,
        "sender_full_name": "RalfJ",
        "timestamp": 1565857878
    },
    {
        "content": "<p>for \"made-up\" addresses, I think we can deal with them by making the Abstract Machine \"open\" -- it dos not assume total knowledge about which allocations exist in memory</p>",
        "id": 173273922,
        "sender_full_name": "RalfJ",
        "timestamp": 1565857910
    }
]