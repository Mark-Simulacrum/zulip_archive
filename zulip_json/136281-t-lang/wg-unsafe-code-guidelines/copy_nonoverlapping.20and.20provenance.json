[
    {
        "content": "<p>does <code>copy_nonoverlapping</code> preserve provenance of stuff it points to even when <code>T</code> isnt a pointer?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">owned</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">owned</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">cpd_to_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">core</span>::<span class=\"n\">ptr</span>::<span class=\"n\">copy_nonoverlapping</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">cpd_to_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">cpd_to_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>miri doesn't flag this as UB even with <code>-Zmiri-track-raw-pointers</code> and i'm wondering if <code>*cpd_to_ptr = 3</code> is actually UB and miri just doesnt detect it, or if this is actually fine.</p>",
        "id": 257940959,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634497735
    },
    {
        "content": "<p>(I had assumed this <em>wouldnt</em> be okay because ptr-int-ptr roundtrips lose provenance)</p>",
        "id": 257941001,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634497786
    },
    {
        "content": "<p>This should be legal. Memory is not typed, so this is just a memcpy, which copies all the bytes of the pointer, and the provenance goes along for the ride when you do that.</p>",
        "id": 257943611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634500229
    },
    {
        "content": "<p>There are no ptr-int-ptr roundtrips in here AFAICT</p>",
        "id": 257943629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634500260
    },
    {
        "content": "<p>yes but if this is allowed I dont see why ptr-int-ptr round trips wouldnt be too</p>",
        "id": 257944007,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634500622
    },
    {
        "content": "<p>the copy_nonoverlapping is doing a byte-by-byte copy I don't get how that could preserve provenance without \"integers have provenance\" being true which would imply ptr-int-ptr casts being okay</p>",
        "id": 257944038,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634500662
    },
    {
        "content": "<p>I think the model is something like <a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">What's in a byte?</a></p>",
        "id": 257945820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634502189
    },
    {
        "content": "<p>In this case it doesn't have to be quite as complicated as pointer fragments since you are copying all the bytes of the pointer</p>",
        "id": 257945873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634502242
    },
    {
        "content": "<blockquote>\n<p>Memory is not typed,</p>\n</blockquote>\n<p>Memory isnt typed, but accesses are... so the question is whether copy_nonoverlapping makes typed copies or untyped copies. I dont think we have a conclusive answer to that question.</p>",
        "id": 258408034,
        "sender_full_name": "RalfJ",
        "timestamp": 1634750616
    },
    {
        "content": "<p>isnt there a MIR transform that turns <code>copy_nonoverlapping(src, dst, 1)</code> into a MIR assignment? that is only legal if copy_nonoverlapping is doing a typed copy.</p>",
        "id": 258408253,
        "sender_full_name": "RalfJ",
        "timestamp": 1634750680
    },
    {
        "content": "<p>in this specific case (of both the code and the original code I was looking at before making this example) it's definitely not able to do a \"typed\" copy, we're doing <code>copy_nonoverlapping</code> of a bunch of u8's with the size set to some stored size</p>",
        "id": 258408609,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634750788
    },
    {
        "content": "<p>idt there would be any way for rust to know what type was stored at the adresses</p>",
        "id": 258408698,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634750823
    },
    {
        "content": "<p>well, that would just mean you are asking it to do a u8-typed-copy. whether that's what you want/need is a different question...</p>",
        "id": 258408782,
        "sender_full_name": "RalfJ",
        "timestamp": 1634750853
    },
    {
        "content": "<p>well, what I want to know is whether doing a u8-typed-copy preserves provenance of a ptr stored at that address</p>",
        "id": 258409038,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634750926
    },
    {
        "content": "<p>I'm guessing \"no\" but miri didnt flag it so i wanted to be sure</p>",
        "id": 258409076,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634750937
    },
    {
        "content": "<ul>\n<li>if the intrinsic does a typed copy, then no (and the copy might even be UB since these are effectively ptr-to-int transmutes)</li>\n<li>if it does an untyped copy, then yes</li>\n</ul>",
        "id": 258409721,
        "sender_full_name": "RalfJ",
        "timestamp": 1634751141
    },
    {
        "content": "<p>which kind of copy the intrinsic does is not currently specified or decided... but I fear a lot of code will break if we decide for typed.</p>",
        "id": 258409815,
        "sender_full_name": "RalfJ",
        "timestamp": 1634751180
    },
    {
        "content": "<p>so I guess I am hoping there is no MIR pass that would turn a CopyNonoverlapping into an assignment... currently I cannot find a pass doing that^^</p>",
        "id": 258410065,
        "sender_full_name": "RalfJ",
        "timestamp": 1634751264
    },
    {
        "content": "<p>okay thanks that's a pretty clear answer. yeah the entire of bevy_ecs would be unsound if it's a typed copy :D</p>",
        "id": 258410385,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1634751371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/copy_nonoverlapping.20and.20provenance/near/258410065\">said</a>:</p>\n<blockquote>\n<p>so I guess I am hoping there is no MIR pass that would turn a CopyNonoverlapping into an assignment... currently I cannot find a pass doing that^^</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/issues/83785\">#83785</a> will lower <code>copy_nonoverlapping</code> into an assignment, but only when the element count is statically known to be 1: <a href=\"https://github.com/rust-lang/rust/pull/83785/files#diff-8776080e5e11d6974f88b35bc52221ae26a59d91f04affa94ea2be06e0f5388fR63-R66\">https://github.com/rust-lang/rust/pull/83785/files#diff-8776080e5e11d6974f88b35bc52221ae26a59d91f04affa94ea2be06e0f5388fR63-R66</a></p>",
        "id": 258421121,
        "sender_full_name": "bjorn3",
        "timestamp": 1634755343
    },
    {
        "content": "<p>Left a comment on the PR to ensure that we don't forget about this conversation before deciding if it should be merged.</p>",
        "id": 258421551,
        "sender_full_name": "bjorn3",
        "timestamp": 1634755513
    },
    {
        "content": "<p>I know that C compilers get a lot of value out of optimizations that inline memcpy operations that copy a small amount of memory.</p>",
        "id": 258500591,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634801911
    },
    {
        "content": "<p>But that doesn't have to turn into an assignment.</p>",
        "id": 258500626,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634801930
    },
    {
        "content": "<p>yeah -- assignment would be allowed to drop padding, which memcpy preserves, so that has to be represented separately</p>",
        "id": 258725456,
        "sender_full_name": "RalfJ",
        "timestamp": 1634915449
    }
]