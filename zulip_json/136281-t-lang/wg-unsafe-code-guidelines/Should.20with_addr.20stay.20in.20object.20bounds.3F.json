[
    {
        "content": "<p>Currently, you can use ptr.with_addr(..) to change the pointer to some wild address, then back to the original address, and the pointer will work again. But this doesn‚Äôt work on CHERI ‚Äî a capability must always point to within the range that it allows access to.</p>\n<p>(There is no way around this information-theoretically, because of the compressed 129-bit representation.)</p>\n<p>Should we maybe spec with_addr differently so you can‚Äôt leave the provenance / the valid accessible range of the the pointer? If yes, then we should perhaps also spec from_exposed_addr so that the returned pointer has provenance that can potentially be valid in the future.</p>\n<p>Are there common coding patterns that people use in practice that change the address of a pointer to outside of the allocation (more than ‚Äúone past‚Äù the allocation), and back again to inside the allocation?</p>",
        "id": 278037792,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649257653
    },
    {
        "content": "<p>Nan boxing, for example</p>",
        "id": 278038973,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649258077
    },
    {
        "content": "<p>But also, what does this get us besides some cheri compliance? From what I understand it's already clear that cheri will not be able to deal with everything that strict provenance Rust allows (shuffling around and reorganizing pointer bytes, for example), so I'm not sure why this particular issue should be special</p>",
        "id": 278039651,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649258335
    },
    {
        "content": "<p>Boxing of u128 works 100% on CHERI, and you can even differentiate between a boxed integer and a functioning capability</p>",
        "id": 278040558,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649258715
    },
    {
        "content": "<p>I guess we get some extra compliance indeed. My understanding was that making a subset of Rust mostly ‚Äújust work‚Äù on CHERI was a major component of this experiment</p>",
        "id": 278040740,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649258789
    },
    {
        "content": "<p>Ideally so that you can pretty much use Miri on normal computers to check that your code will be CHERI-compatible</p>",
        "id": 278040853,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649258840
    },
    {
        "content": "<blockquote>\n<p>But this doesn‚Äôt work on CHERI ‚Äî a capability must always point to within the range that it allows access to</p>\n</blockquote>\n<p>AIUI, this is not correct? There are limits on what CHERI can represent, but I thought CHERI allowed the pointer to leave the allowed range as long as it is sufficiently close</p>",
        "id": 278049902,
        "sender_full_name": "Diggsey",
        "timestamp": 1649262373
    },
    {
        "content": "<p>where \"sufficiently\" depends on the size of the allowed range</p>",
        "id": 278049942,
        "sender_full_name": "Diggsey",
        "timestamp": 1649262396
    },
    {
        "content": "<p>If someone could find a way to perform an experiment with a broad array of Rust software to see how far out of bounds pointers tend to go, that would be extremely useful for future (production) CHERI capability encoding decisions.</p>",
        "id": 278051400,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649263003
    },
    {
        "content": "<p>The bytes crate will set the lowest bit to zero on some pointers that come from an allocation with an odd address, which would make it go out of bounds backwards.</p>",
        "id": 278051821,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649263195
    },
    {
        "content": "<p>That's fine as long as you don't access the out-of-bounds byte.<br>\n(We've had to modify some C str/mem functions that do word accesses for optimization to avoid that when targeting CHERI)</p>",
        "id": 278054087,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649264210
    },
    {
        "content": "<p>this does not just pertain to with_addr, it pertains to wrapping_offset in general</p>",
        "id": 278073830,
        "sender_full_name": "RalfJ",
        "timestamp": 1649273255
    },
    {
        "content": "<p>and that on CHERI was discussed at great length last week in this very Zulip :D no need to re-hash everything...</p>",
        "id": 278073861,
        "sender_full_name": "RalfJ",
        "timestamp": 1649273272
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 278083138,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649277707
    },
    {
        "content": "<p>Ah sorry, I didn‚Äôt realize that that was what was being discussed there üòÅ I‚Äôll check it out, thanks for the pointer üëÜ</p>",
        "id": 278091035,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649281770
    },
    {
        "content": "<p>Regardless of CHERI details, I'd be very interested in having a <code>with_addr_inbounds</code> prominently available for experimentation. It seems like a surprisingly large class of applications can use it, and especially with how regularly people are unsure about the status of out-of-bounds pointers, having a designated and miri-enforced way to entirely avoid that realm seems useful.</p>\n<p>It certainly isn't necessary as an extension to the model (as it is just, e.g. <code>with_addr(addr).offset(0)</code>), and I expect few optimizations will benefit from the extra information. This is just interesting for data gathering and communicating intent.</p>",
        "id": 278104560,
        "sender_full_name": "gereeter",
        "timestamp": 1649291619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295632\">Diggsey</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278049902\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But this doesn‚Äôt work on CHERI ‚Äî a capability must always point to within the range that it allows access to</p>\n</blockquote>\n<p>AIUI, this is not correct? There are limits on what CHERI can represent, but I thought CHERI allowed the pointer to leave the allowed range as long as it is sufficiently close</p>\n</blockquote>\n<p>Correct, I was wrong. There's a bunch of nuance to CHERI Concentrate that I just read up on :3 The address can go approximately 15% below base of the range of the capability, and 25% above the top.</p>",
        "id": 278238000,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649372926
    },
    {
        "content": "<hr>\n<p>Perhaps the \"tower of weakenings\" will have an additional layer near the bottom, which is \"only stuff that works on CHERI\" like <code>with_addr_inbounds</code></p>",
        "id": 278238992,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649373685
    },
    {
        "content": "<p>Although this would conflict with <a href=\"https://gankra.github.io/blah/tower-of-weakenings/\">Gankra's blog post</a>, which says that <code>strict_provenance</code> is supported by CHERI</p>\n<blockquote>\n<p>Oh also strict provenance is basically actually implemented in hardware by CHERI, so uh, doing this also just makes your code portable to CHERI. </p>\n</blockquote>\n<p>I would be in favor of a lint somehow against bare <code>with_addr</code> and <code>wrapping_offset</code>, which seem currently specced to allow going out of bounds and back again (see <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F\">#t-lang/wg-unsafe-code-guidelines &gt; Does wrapping_offset fizzle in cherry soda?</a> ). I see that <code>offset</code> is the \"in-bounds\" version of <code>wrapping_offset</code>. </p>\n<p>I'm not sure about the specifics of the lint.</p>",
        "id": 278239353,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649374002
    },
    {
        "content": "<p>I still hold my position from <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Does.20wrapping_offset.20fizzle.20in.20cherry.20soda.3F\">the previous instance of this discussion</a>: this is a platform limitation in CHERI that leads to incorrect behavior of some correct programs, similar to floating point bugs we are seeing on other platforms.<br>\nthe fact that almost-but-not-quite conformant platforms exist is unfortunate but such is life. at least (unlike with the floating point issues) the fault is very apparent, the program will segfault and that should point at the place where the pointer with the 'mangled' provenance is used.</p>",
        "id": 278354740,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447808
    },
    {
        "content": "<p>I don't think we can meaningfully lint against <code>with_addr</code>, what alternative would you recommend to people? <code>map_addr</code> has the same problem. we <em>just</em> started telling people to use those APIs rather than bare casts. now do you want to develop and document \"even stricter provenance\" APIs that can replace them? not sure what they would even look like.</p>",
        "id": 278354835,
        "sender_full_name": "RalfJ",
        "timestamp": 1649447870
    },
    {
        "content": "<p>In my view, the <code>strict_provenance</code> experiment is still fluid. I think it would be best if we redefined <code>with_addr</code> and <code>map_addr</code> to use <code>offset</code> instead of <code>wrapping_offset</code> ‚Äî the same but with a little more UB.</p>\n<p>In my view,</p>\n<blockquote>\n<p><code>strict_provenance</code> should be the subset of Rust that people aim for because it's future-proof. It also has great tooling. </p>\n</blockquote>\n<p>So, more than \"the subset that is good for compiling/checking\". It would be great if \"the designated lint and runtime checker for future-proof code\" happen to also validate that my Unsafe Rust will work on CHERI.</p>",
        "id": 278369501,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649456624
    },
    {
        "content": "<p>Gankra writes,</p>\n<blockquote>\n<p><code>wrapping_offset</code> was never the \"good\" <code>offset</code></p>\n</blockquote>\n<p>But implicitly with <em>the current version</em> of <code>strict_provenance</code>, with <code>with_addr</code> and <code>map_addr</code> defined in terms of <code>wrapping_offset</code>, we're <em>still pretending</em> that that's the \"right\" <code>offset</code>.</p>\n<p>I see this as a mistake.</p>",
        "id": 278369799,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649456866
    },
    {
        "content": "<p><code>with_addr</code> is (morally) an intrinsic, it doesn't use <code>wrapping_offset</code></p>",
        "id": 278369908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649456947
    },
    {
        "content": "<p>the point is there are two possible versions of strict provenance: one where \"with_addr\" is only guaranteed to work for inbounds addresses and one where it is guaranteed to work for any address</p>",
        "id": 278370385,
        "sender_full_name": "Diggsey",
        "timestamp": 1649457296
    },
    {
        "content": "<p>I think it's at least worth asking the question of which is preferable</p>",
        "id": 278370415,
        "sender_full_name": "Diggsey",
        "timestamp": 1649457311
    },
    {
        "content": "<p>The UB behavior of <code>with_addr</code> is defined in terms of <code>wrapping_offset</code>. Stdlib docs:</p>\n<blockquote>\n<p>This is equivalent to using <code>wrapping_offset</code> to offset <code>self</code> to the given address, and therefore has all the same capabilities and restrictions.</p>\n</blockquote>\n<p>I think this means that it's fine to <code>with_addr</code> to a large offset, and <code>with_addr</code> back to inside the object. Not UB. But the whole CHERI story is much nicer if it would be UB and checked against by Miri.</p>",
        "id": 278370537,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649457399
    },
    {
        "content": "<p>the point is with_addr is an unstable method that was just added, and it's arguable what the semantics there /should/ be</p>",
        "id": 278371048,
        "sender_full_name": "Talchas",
        "timestamp": 1649457853
    },
    {
        "content": "<p>if you had something like <code>#[repr(align(1048576))]</code>, would it be wrong to use <code>with_addr</code> with a large offset due to the 9 bits of masking? (i'm just a noob following along at home, in case this is a silly question)</p>",
        "id": 278373543,
        "sender_full_name": "skippy",
        "timestamp": 1649460035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278370537\">said</a>:</p>\n<blockquote>\n<p>I think this means that it's fine to <code>with_addr</code> to a large offset, and <code>with_addr</code> back to inside the object. Not UB. But the whole CHERI story is much nicer if it would be UB and checked against by Miri.</p>\n</blockquote>\n<p>It would certainly be more convenient for going out of bounds and then coming back in to be UB (it technically is in C). <span class=\"user-mention\" data-user-id=\"473929\">@Alexander Richardson</span> added a sanitizer to catch such cases at runtime in CHERI-LLVM because they are awkward to debug. IIRC the motivating use case was provenance bugs where pointers into a realloc'd buffer were incremented by the offset of the buffers rather than rederived from the new buffer's pointer.<br>\nThere's a bit more information on the sanitizer and another compiler warning that I think is less relevant to Rust in this report <a href=\"https://www.capabilitieslimited.co.uk/pdfs/20210917-capltd-cheri-desktop-report-version1-FINAL.pdf\">https://www.capabilitieslimited.co.uk/pdfs/20210917-capltd-cheri-desktop-report-version1-FINAL.pdf</a></p>",
        "id": 278373657,
        "sender_full_name": "Brooks Davis",
        "timestamp": 1649460170
    },
    {
        "content": "<p>So far the sanitizer only checks if the pointer had become unrepresentable, but adjusting it to detect out of bounds pointers instead is pretty simple, it just means emitting more checks and branches.</p>",
        "id": 278373873,
        "sender_full_name": "Alexander Richardson",
        "timestamp": 1649460369
    },
    {
        "content": "<p>remember that <code>with_addr</code> is similar/equivalent to doing it via usize, or uintptr_t casts in C - going out of bounds in uintptr_t and then back for the cast is _not_ UB in typical C implementations (the spec doesn't technically require <code>(char*)((uintptr_t)p + 1)</code> or any other modification to be valid afaict, so we're already out of spec territory)</p>",
        "id": 278378267,
        "sender_full_name": "Talchas",
        "timestamp": 1649465406
    },
    {
        "content": "<p>(CHERI does care, but that's CHERI where you no longer have <code>uintptr_t</code> <code>==</code> meaning equivalence in general)</p>",
        "id": 278378316,
        "sender_full_name": "Talchas",
        "timestamp": 1649465495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278369501\">said</a>:</p>\n<blockquote>\n<p>In my view, the <code>strict_provenance</code> experiment is still fluid. I think it would be best if we redefined <code>with_addr</code> and <code>map_addr</code> to use <code>offset</code> instead of <code>wrapping_offset</code> ‚Äî the same but with a little more UB.</p>\n</blockquote>\n<p>I disagree strongly; that would make them unsafe</p>",
        "id": 278380152,
        "sender_full_name": "RalfJ",
        "timestamp": 1649467845
    },
    {
        "content": "<p>What does unsafe mean in this context?</p>",
        "id": 278397266,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649493397
    },
    {
        "content": "<p>\"would need to be <code>unsafe fn</code>\", which they're not right now: <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.with_addr\">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.with_addr</a></p>",
        "id": 278397307,
        "sender_full_name": "scottmcm",
        "timestamp": 1649493452
    },
    {
        "content": "<p>Ah. I forgot‚Ä¶ that‚Äôs a good point</p>",
        "id": 278397362,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649493486
    },
    {
        "content": "<p>Bummer</p>",
        "id": 278397477,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649493696
    },
    {
        "content": "<p>If we have both <code>offset</code> and <code>wrapping_offset</code>, it would make sense to have both <code>with_addr</code> and an unsafe <code>with_inbounds_addr</code>. That does assume that say LLVM could make use of the latter.</p>\n<p>I don't recall what optimizations <code>offset</code> allows. It's possible we could just define <code>with_inbounds_addr</code> to be <code>with_addr(...).offset(0)</code>.</p>",
        "id": 278409231,
        "sender_full_name": "Zoxc",
        "timestamp": 1649509339
    },
    {
        "content": "<p>offset is the inbounds version, so it does the normal inbounds optimizations when possible. But using an offset of 0 when you're possibly out of bounds sounds very-not-good.</p>",
        "id": 278410464,
        "sender_full_name": "Lokathor",
        "timestamp": 1649511226
    },
    {
        "content": "<p><code>null.offset(0)</code> should be valid, but <code>&lt;invalid&gt;.offset(0)</code> I believe is not.</p>",
        "id": 278410816,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649511789
    },
    {
        "content": "<p>The point is you're using <code>with_inbounds_addr</code> to declare that you're in bounds.</p>",
        "id": 278410821,
        "sender_full_name": "Zoxc",
        "timestamp": 1649511819
    },
    {
        "content": "<p>You could probably be clearer about that with <code>p.with_inbounds_addr(addr)</code> being implemented (or intrinsic'd as) <code>p.offset((addr-p.addr()).try_into().unwrap_unchecked())</code></p>",
        "id": 278410940,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649511958
    },
    {
        "content": "<p>This would also mean that <code>p.with_inbounds_addr(0)</code> is only valid for a null pointer.</p>",
        "id": 278411009,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649512009
    },
    {
        "content": "<p>(And should be clear to llvm, IDK if otherwise)</p>",
        "id": 278411111,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649512132
    },
    {
        "content": "<p>Seems like it would make a terrible IR mess. It's quite possible LLVM will get a <code>with_addr</code> instruction with an <code>inbounds</code> flag though.</p>",
        "id": 278411378,
        "sender_full_name": "Zoxc",
        "timestamp": 1649512555
    },
    {
        "content": "<p>For CHERI, the important thing IMO is to express intention, so that you can tell which crates are supposed to be compatible just from the source. </p>\n<p>But for this, an alias of with_addr could technically suffice. It doesn‚Äôt need to introduce UB</p>",
        "id": 278416286,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649519532
    },
    {
        "content": "<p>Independently, I‚Äôm sympathetic to an unsafe variant of with_addr if that helps LLVM optimize better</p>",
        "id": 278416332,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649519595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278416286\">said</a>:</p>\n<blockquote>\n<p>For CHERI, the important thing IMO is to express intention, so that you can tell which crates are supposed to be compatible just from the source. </p>\n<p>But for this, an alias of with_addr could technically suffice. It doesn‚Äôt need to introduce UB</p>\n</blockquote>\n<p>Even on CHERI, you don't want to use a <code>with_inbounds_addr</code> <em>most</em> of the time, because <code>with_addr</code> is mostly for doing pointer tricks like alignment tagging which <em>do</em> go out of bounds of the object (for size &lt; align).</p>",
        "id": 278444328,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649559332
    },
    {
        "content": "<p>I'm sympathetic to the desire to be able to statically know whether things are \"supposed to\" work with a CHERI C style limited safe offset range, but <code>map_addr</code> already can't be used under miri to check if a use works on CHERI C without just running it on a CHERI C implementation.</p>",
        "id": 278444453,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649559524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278410816\">said</a>:</p>\n<blockquote>\n<p><code>null.offset(0)</code> should be valid, but <code>&lt;invalid&gt;.offset(0)</code> I believe is not.</p>\n</blockquote>\n<p>IMO <code>offset(0)</code> should be valid iff a ZST access at that ptr is valid.<br>\nso, <code>ptr::invalid(...).offset(0)</code> is fine. <code>null.offset(0)</code> is not.</p>",
        "id": 278472308,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602436
    },
    {
        "content": "<p>that's what Miri does, anyway, as this code shows</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(strict_provenance)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">invalid</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"mi\">13</span><span class=\"p\">).</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// fine</span>\n<span class=\"w\">   </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">invalid</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">).</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// UB</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278472384,
        "sender_full_name": "RalfJ",
        "timestamp": 1649602554
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> what types have size &lt; align?</p>",
        "id": 278472526,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649602746
    },
    {
        "content": "<p>We could (eventually) just add a Miri flag which does an <code>offset</code> check also on <code>with_addr</code> and <code>map_addr</code>.</p>",
        "id": 278472812,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649603066
    },
    {
        "content": "<p>By the way the ‚ÄúCHERI C‚Äù safe offset range is built into CHERI, it isn‚Äôt C-specific. It‚Äôs possible that there will be a different capability encoding in the future ‚Äî Presumably it would still allow going under and over by similar amounts</p>",
        "id": 278472908,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649603191
    },
    {
        "content": "<p>CHERI Concentrate (the current scheme) allows going &gt;= 2kB below range and &gt;=4kB above, on 64-bit, but it would be very awkward to put such numbers in a definition of Rust :(</p>",
        "id": 278473292,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649603685
    },
    {
        "content": "<p>The term ‚ÄúZST access‚Äù on Miri confuses me. Surely Miri has borrow stacks per byte of the memory, and a one-past pointer couldn‚Äôt be accessed ü§îü§î</p>",
        "id": 278473373,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649603774
    },
    {
        "content": "<p>ZST stands for zero sized type so there isnt really any bytes to access its basically a no-op</p>",
        "id": 278473393,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649603823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278473373\">said</a>:</p>\n<blockquote>\n<p>The term ‚ÄúZST access‚Äù on Miri confuses me. Surely Miri has borrow stacks per byte of the memory, and a one-past pointer couldn‚Äôt be accessed ü§îü§î</p>\n</blockquote>\n<p>Stacked Borrows indeed has nothing to say about ZST accesses</p>",
        "id": 278473781,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604335
    },
    {
        "content": "<p>but other checks do; they still need to be 'in-bounds'</p>",
        "id": 278473789,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604350
    },
    {
        "content": "<p>in that sense it is not entirely a NOP; it can still cause UB</p>",
        "id": 278473834,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604369
    },
    {
        "content": "<p>e.g. <code>std::ptr::invalid::&lt;()&gt;(0).load()</code> is UB</p>",
        "id": 278473837,
        "sender_full_name": "RalfJ",
        "timestamp": 1649604386
    },
    {
        "content": "<p>Cool, thanks. I suppose that ZST access is valid if there‚Äôs an allocated byte on that address or on the address before it</p>",
        "id": 278475714,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649606868
    },
    {
        "content": "<p>yes but there are more cases where it is valid... the <code>ptr</code> module docs explain this in more detail</p>",
        "id": 278475774,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606927
    },
    {
        "content": "<p>this is allowed: <code>std::ptr::invalid::&lt;()&gt;(1).load()</code></p>",
        "id": 278475776,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606932
    },
    {
        "content": "<p>Cool, thanks for the pointer. Complicated stuff.</p>",
        "id": 278475858,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649607022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278473292\">said</a>:</p>\n<blockquote>\n<p>CHERI Concentrate (the current scheme) allows going &gt;= 2kB below range and &gt;=4kB above, on 64-bit, but it would be very awkward to put such numbers in a definition of Rust :(</p>\n</blockquote>\n<p>It's not that simple. Morello uses a tweaked version of CHERI Concentrate with more bits dedicated to the bounds than our 64-bit encoding scheme (used on CHERI-RISC-V, and the now-abandoned CHERI-MIPS), and how far you can go out of bounds is a function of the length of the bounds themselves, just with a minimum based on the number of bounds bits you have. CHERI on 32-bit architectures has much tighter requirements (though we've not tried to optimise it, just do the simple thing of making it work with the existing scheme down-sized). Future versions of CHERI+Arm-A, should they exist, may well change the bit allocation again. This is always going to be architecture-specific and you should never put precise guarantees in the language unless you're very sure every implementation will be able to meet them; C's banning of everything other than one-past-the-end is very attractive in that regard.</p>",
        "id": 278488103,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649622583
    },
    {
        "content": "<p>That‚Äôs why I‚Äôm curious if alignment &lt; size ever happens ‚Äî does it really not work on CHERI?</p>",
        "id": 278488285,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649622827
    },
    {
        "content": "<p>It does work, but there are limits to how unaligned your allocation can be for large sizes</p>",
        "id": 278488329,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649622868
    },
    {
        "content": "<p>The short answer is on CHERI-RISC-V you get I think ~12 leading significant bits before the rest of the length must be 0</p>",
        "id": 278488338,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649622899
    },
    {
        "content": "<p>12 or 14, I forget the exact details</p>",
        "id": 278488349,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649622909
    },
    {
        "content": "<p>Ok, CHERI Clang rounds up to 10 significant bits on CHERI-RISC-V and 12 on Morello</p>",
        "id": 278488767,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1649623488
    },
    {
        "content": "<p>As far as I understand, this is a restriction on how the allocation should be aligned ‚Äî not what addresses are representable. So from the view of pointer tagging ((mis)using low-order bits of the address), there seems to be nothing different about CHERI</p>",
        "id": 278489042,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649623918
    },
    {
        "content": "<p>CAD97 said that with_addr_inbounds wouldn‚Äôt work for pointer taking on CHERI ‚Äî but I suspect it does</p>",
        "id": 278489193,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649624057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> the difference is what \"inbounds\" means</p>",
        "id": 278491160,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626704
    },
    {
        "content": "<p>Pointer tagging definitely works on CHERI</p>",
        "id": 278491169,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626718
    },
    {
        "content": "<p>But <code>inbounds</code> w.r.t. Rust pointers means inbounds in the C manner</p>",
        "id": 278491179,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626740
    },
    {
        "content": "<p>That is, only one-byte-past-the-end</p>",
        "id": 278491186,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626757
    },
    {
        "content": "<p>Rust guarantees that size is a multiple of alignment, but 0 is a multiple of any alignment</p>",
        "id": 278491243,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626814
    },
    {
        "content": "<p>And doing an inbounds offset on a pointer to a zero-sized allocation with nonzero offset is UB</p>",
        "id": 278491251,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626847
    },
    {
        "content": "<p>Thus, using non-<code>wrapping_offest</code> to tag pointers breaks for ZSTs</p>",
        "id": 278491262,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626874
    },
    {
        "content": "<p>That's a pure Rust AM restriction, nothing to do with CHERI</p>",
        "id": 278491268,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649626894
    },
    {
        "content": "<p>Right. Thanks for the explanation</p>",
        "id": 278491802,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649627754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Should.20with_addr.20stay.20in.20object.20bounds.3F/near/278472526\">said</a>:</p>\n<blockquote>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> what types have size &lt; align?</p>\n</blockquote>\n<p>Size is always a multiple of align, so the only ones with <code>size &lt; align</code> are those with <code>size == 0</code>.  (Which can have non-1 alignment, see <code>[i32; 0]</code> for example.)</p>\n<p>As for validity of <code>offset</code>, I have a hypothesis in <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277190943\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277190943</a> , though I don't know if it makes sense to actually have it that way.</p>",
        "id": 278514977,
        "sender_full_name": "scottmcm",
        "timestamp": 1649660785
    },
    {
        "content": "<p>There can be allocations where size is not a multiple of align, even if that's true of Rust types.</p>",
        "id": 278531333,
        "sender_full_name": "Zoxc",
        "timestamp": 1649671235
    }
]