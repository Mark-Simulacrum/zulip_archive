[
    {
        "content": "<p>I thought it may be a good idea to clarify how unspecified behaviour interacts with undefined behaviour in the Rust AM.</p>\n<p>In C++, <a href=\"https://eel.is/c++draft/intro.abstract#5.sentence-2\">[intro.abstract] clause 5</a> provides that </p>\n<blockquote>\n<p>However, if any such execution contains an undefined operation, this document places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</p>\n</blockquote>\n<p>This (compiled with clause 3 of the same, which defines that unspecified behaviour are non-deterministic aspects of the AM, and allow multiple executions of the same program with the same input on the same parameterized abstract AM) implies that if the a valid choice for some unspecified behaviour somewhere in the program causes the program to have undefined behaviour on a particular input, the implementation can treat it as though the program always has undefined behaviour. It can be demonstrated why, using this code</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;cstdlb&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">auto</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">rand</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">//  This produces some value in a sequence. The C Standard is vague, but the requirements seem to imply that sequence is unspecified, though consistent with sequences produced immediate after calling `std::srand(1);`</span>\n<span class=\"w\">    </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d\"</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">x</span><span class=\"p\">){</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Cause undefied behaviour</span>\n<span class=\"w\">     </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The implementation can treat this as having undefined behaviour reguardless of what <code>std::rand()</code> returns, because that choice is entirely within the purview of the implementation, so it could choose to, say, return 0 always on the first call to <code>std::rand()</code> from the seed 1.  This is the case even if the printf statement prints 42, 1337, or 65537, since, if x is zero, the the program has undefined behaviour, and the compiler can do what it wants - print 0, 99, potato, segfault, or install windows on /dev/sda.</p>\n<p>My question is, does this reasoning apply to rust? For example, would the following code be valid to treat as undefined behaviour, even if the layout of <code>Vec</code> happens to match:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span>::<span class=\"n\">new</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cap</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"kt\">usize</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}: {}\"</span><span class=\"p\">,</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"n\">len</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">cap</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As a more interesting example, allowing this unspecified whether it's undefined to undefined promotion would allow the following code to be optimized as though <code>usize</code> carried provenance (even though it most likely strictly doesn't in rust):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">do_fun_things</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Can x be removed here?</span>\n<span class=\"w\">     </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:x}\"</span><span class=\"p\">,</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">do_other_fun_things</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">do_other_fun_things</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// guess the address of x - unspecified whether we succeed</span>\n<span class=\"w\">     </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:p},{}\"</span><span class=\"p\">,</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"o\">&amp;*</span><span class=\"n\">ptr</span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In some valid executions, the address 32 bytes offset from the address of v would be the address of x (8 bytes for the base pointer, 8 bytes for the return instruction pointer, 8 bytes for ptr, 4 for padding, and 4 for x). Of course, not ever execution would have this property. If the fact at least one execution exists that the &amp;*ptr has undefined behaviour, then would it be valid to delete the value of <code>x</code>, <em>even if</em> we subsequently print the value address in both cases (possibly because indeed we happen to be on such an execution)? (This assumes the compiler is able to ensure that <code>println!()</code> doesn't do anything sneaky with <code>ptr</code>).</p>",
        "id": 251314184,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630369139
    },
    {
        "content": "<blockquote>\n<p>The implementation can treat this as having undefined behaviour reguardless of what std::rand() returns,</p>\n</blockquote>\n<p>I don't think that's what your quote is saying. It specifies \"execution\", and the UB happens in the execution only if <code>x</code> is 0, so if <code>x</code> happens to not be <code>0</code> then the execution should be well defined.</p>",
        "id": 251347303,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1630397135
    },
    {
        "content": "<p>However, it isn't possible to observe whether the program is on an execution that doesn't have undefined behaviour, as the program could have actually returned <code>0</code> from <code>rand</code>, has undefined behaviour, and  done whatever it wants. <br>\nIt also says that \"if any such execution contains an unefined operation...\" which (combined with the rest of the clause) implies that the chosen execution need not be the one that contains the operation in question.</p>",
        "id": 251362397,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630405525
    },
    {
        "content": "<blockquote>\n<p>For example, would the following code be valid to treat as undefined behaviour, even if the layout of Vec happens to match:</p>\n</blockquote>\n<p>I don't think it is UB if the layout just so happens to match. For example <code>offset_of!()</code> would allow observing what the layout is. You could then match on a number of expected layouts and then use a hard coded offset. The fact that the fields of <code>Vec</code> are private does not change what is UB according to the compiler. It only changes what is UB according to the standard library, which the compiler can't take into account when optimizing. Future library versions can change things such that library UB turns into compiler UB, but library UB is not compiler UB in itself.</p>",
        "id": 251363390,
        "sender_full_name": "bjorn3",
        "timestamp": 1630406081
    },
    {
        "content": "<p>I don't think unspecified behavior has anything to do with undefined behavior in Rust.</p>",
        "id": 251731741,
        "sender_full_name": "hannahE2",
        "timestamp": 1630595679
    },
    {
        "content": "<p>Rust does not say what the layout of Rust structs is (its \"unspecified\"), but you can inspect the layout, and exploit it, without causing UB.</p>",
        "id": 251731794,
        "sender_full_name": "hannahE2",
        "timestamp": 1630595707
    },
    {
        "content": "<p>You can also assume what the layout is, without checks, and without inspecting it, and if your assumption is correct, your program won't have UB.</p>",
        "id": 251732000,
        "sender_full_name": "hannahE2",
        "timestamp": 1630595792
    },
    {
        "content": "<p>The issue with that is that the program might not be _portable_.</p>",
        "id": 251732059,
        "sender_full_name": "hannahE2",
        "timestamp": 1630595815
    },
    {
        "content": "<p>But portability and undefined behavior are separate things.</p>",
        "id": 251732114,
        "sender_full_name": "hannahE2",
        "timestamp": 1630595835
    },
    {
        "content": "<p>Rust doesn't really have \"unspecified behavior\" as a fixed term currently (AFAIK), but the way I think it should be used is by always <em>giving a list of options</em></p>",
        "id": 252033884,
        "sender_full_name": "RalfJ",
        "timestamp": 1630798134
    },
    {
        "content": "<p>of one of the possibilities of \"unspecified behavior\" is UB, then we might as well just say it is UB</p>",
        "id": 252033894,
        "sender_full_name": "RalfJ",
        "timestamp": 1630798153
    },
    {
        "content": "<p>so, I think I said the same thing as <span class=\"user-mention\" data-user-id=\"409057\">@hannahE2</span> just more generally :)</p>",
        "id": 252033910,
        "sender_full_name": "RalfJ",
        "timestamp": 1630798186
    },
    {
        "content": "<p>Do we have a term for \"intentionally defined as incorrect\", by contrast with undefined?</p>",
        "id": 252034666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630799130
    },
    {
        "content": "<p>I don't think we do. E.g. Future::poll's doc currently says:</p>\n<blockquote>\n<p>Once a future has completed (returned Ready from poll), calling its poll method again may panic, block forever, or cause other kinds of problems; the Future trait places no requirements on the effects of such a call. However, as the poll method is not marked unsafe, Rust’s usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of unsafe functions, or the like), regardless of the future’s state.</p>\n</blockquote>",
        "id": 252034822,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630799289
    },
    {
        "content": "<p>Basically it means that \"Once a future has completed, calling its poll method again is &lt;term for intentionally defined as incorrect but not undefined&gt;.\"</p>",
        "id": 252034844,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630799324
    },
    {
        "content": "<p>On the other hand, slice::sort_by just says:</p>\n<blockquote>\n<p>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified.</p>\n</blockquote>",
        "id": 252034942,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630799434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Unspecified.20Behaviour.20with.20Undefined.20Behaviour/near/252034666\">said</a>:</p>\n<blockquote>\n<p>Do we have a term for \"intentionally defined as incorrect\", by contrast with undefined?</p>\n</blockquote>\n<p>what do you even mean by that?</p>",
        "id": 252088430,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> ah now we are entering the territory of <em>library</em> UB/unspecified behavior, which is somewhat separate from those same concepts on the language level</p>",
        "id": 252088458,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861267
    },
    {
        "content": "<p>Well I don't think we necessarily has to use different terms for library and language.</p>",
        "id": 252088574,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630861387
    },
    {
        "content": "<p>Future is tightly related to the language anyway</p>",
        "id": 252088597,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630861421
    },
    {
        "content": "<p>UB on the language level means \"the Abstract Machine says this is an error\". That <em>cannot</em> be the library definition, so we already have to define these separately.</p>",
        "id": 252088690,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861502
    },
    {
        "content": "<p>and Future isnt really tied closely to the level of the language at which UB is defined, it all gets desugared away before the Abstract Machine ever sees it.</p>",
        "id": 252088712,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861523
    },
    {
        "content": "<p>UB on the library level also involves things like how the library is allowed to change behavior in future versions</p>",
        "id": 252088734,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861558
    },
    {
        "content": "<p>so, I'd expect something similar with unspecified behavior on the language and library levels, respectively</p>",
        "id": 252088787,
        "sender_full_name": "RalfJ",
        "timestamp": 1630861576
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Unspecified.20Behaviour.20with.20Undefined.20Behaviour/near/252088430\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Unspecified.20Behaviour.20with.20Undefined.20Behaviour/near/252034666\">said</a>:</p>\n<blockquote>\n<p>Do we have a term for \"intentionally defined as incorrect\", by contrast with undefined?</p>\n</blockquote>\n<p>what do you even mean by that?</p>\n</blockquote>\n<p>I'm wondering if there's an established term, in compilers, for \"this is semantically incorrect by the definition of the language, not just undefined\".</p>\n<p>As an example, consider something like arranging to have two <code>&amp;mut</code> references pointing to the same location (e.g. via transmute or via conversion from raw pointers). That's undefined behavior, but more than that, it's semantically incorrect, because part of the definition of Rust includes the exclusivity of <code>&amp;mut</code> references, and people can count on that semantic when writing their code.</p>",
        "id": 252089553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630862434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Unspecified.20Behaviour.20with.20Undefined.20Behaviour/near/252088690\">said</a>:</p>\n<blockquote>\n<p>UB on the language level means \"the Abstract Machine says this is an error\". That <em>cannot</em> be the library definition, so we already have to define these separately.</p>\n</blockquote>\n<p>There are arguments that the definition of the AM includes the standard library (this is the case in C and C++), and thus you can have undefined behaviour in the library that are AM errors - an implementation would thus have exactly the same freedom with stdlib UB as it would with language UB.</p>",
        "id": 252089581,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630862487
    },
    {
        "content": "<p>To phrase it another way: it seems like there's a spectrum from \"defined as correct\" to \"not defined\" to \"defined as incorrect\".</p>",
        "id": 252089584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630862495
    },
    {
        "content": "<p>I thought \"undefined\" is the worse than \"defined as incorrect\". IMO integer overflow is \"defined as incorrect\" but is not \"undefined\".</p>",
        "id": 252089688,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630862615
    },
    {
        "content": "<p>I haven't seen that sort of term in other specs.<br>\nC is the closest with Bounded UB (which cannot cause arbitrarily bad things to happen, like writing to another object, or be optimized away, but can result in a trap or abort or some other graceful error), but nothing I know of (except maybe sanitizers) implements that Annex.</p>",
        "id": 252089692,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630862620
    },
    {
        "content": "<p>If I wrote a spec for the requirements of Futures, I would simply put</p>\n<blockquote>\n<p>The result of calling poll on a completed future is unspecified.</p>\n</blockquote>",
        "id": 252089770,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630862698
    },
    {
        "content": "<p>Integer overflow is certainly not defined as incorrect.</p>",
        "id": 252097898,
        "sender_full_name": "Lokathor",
        "timestamp": 1630871558
    },
    {
        "content": "<blockquote>\n<p>There are arguments that the definition of the AM includes the standard library (this is the case in C and C++), and thus you can have undefined behaviour in the library that are AM errors - an implementation would thus have exactly the same freedom with stdlib UB as it would with language UB.</p>\n</blockquote>\n<p>I don't think that's how it works in Rust.</p>",
        "id": 252209497,
        "sender_full_name": "hannahE2",
        "timestamp": 1630952954
    },
    {
        "content": "<p>Safe APIs can't have UB, and unsafe ones have pre-conditions that the user is not allowed to violate.</p>\n<p>Whether the API is a stdlib API or not doesn't really matter much.</p>",
        "id": 252209647,
        "sender_full_name": "hannahE2",
        "timestamp": 1630953055
    },
    {
        "content": "<p>For the optimizations to happen, the compiler does not even need to treat any of these functions in a special way. Any unsafe API can have a <code>core::hint::assume</code> for each pre-condition in its implementation...</p>",
        "id": 252209914,
        "sender_full_name": "hannahE2",
        "timestamp": 1630953239
    },
    {
        "content": "<blockquote>\n<p>I'm wondering if there's an established term, in compilers, for \"this is semantically incorrect by the definition of the language, not just undefined\".</p>\n</blockquote>\n<p>\"semantically incorrect by the definition of the language\" is pretty much how I would define Undefined Behavior.<br>\nUB does not mean \"the spec doesnt say anything about this\" (except if the spec uses UB as a default match arm, which IMO is a terrible choice... I am looking at you, C). UB means \"the spec says it is an error to do this\".</p>",
        "id": 253641866,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822419
    },
    {
        "content": "<blockquote>\n<p>There are arguments that the definition of the AM includes the standard library (this is the case in C and C++)</p>\n</blockquote>\n<p>I dont think this is the case in Rust... if I can help it.^^ And those part of the stdlib that are in the AM should IMO not be called \"library\" in careful technical discussion -- those are language primitives, aka intrinsics.</p>",
        "id": 253642099,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Unspecified.20Behaviour.20with.20Undefined.20Behaviour/near/252089584\">said</a>:</p>\n<blockquote>\n<p>To phrase it another way: it seems like there's a spectrum from \"defined as correct\" to \"not defined\" to \"defined as incorrect\".</p>\n</blockquote>\n<p>\"not defined\" is always a spec bug, if you ask me. :)</p>",
        "id": 253642164,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822529
    },
    {
        "content": "<p>there's also \"unspecified\" ~= \"defined as correct, without dictating what it does\"</p>",
        "id": 253642789,
        "sender_full_name": "cuviper",
        "timestamp": 1631822835
    },
    {
        "content": "<p>for \"unspecified\" to be useful it needs to provide a list of possible options</p>",
        "id": 253642819,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822852
    },
    {
        "content": "<p>that is what this discussion kind of started with, a few weeks ago ;)</p>",
        "id": 253642843,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822864
    },
    {
        "content": "<p>I'm just amused that it has to be in the spec to be unspecified</p>",
        "id": 253642963,
        "sender_full_name": "cuviper",
        "timestamp": 1631822905
    },
    {
        "content": "<p>yeah these words havent aged well :/</p>",
        "id": 253642989,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822920
    },
    {
        "content": "<p>the spec also needs to carefully define what is undefined</p>",
        "id": 253643001,
        "sender_full_name": "RalfJ",
        "timestamp": 1631822927
    }
]