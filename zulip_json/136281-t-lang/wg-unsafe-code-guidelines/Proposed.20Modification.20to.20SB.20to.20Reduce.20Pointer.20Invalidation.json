[
    {
        "content": "<p>We had a conversation in the community discord yesterday about a number of possible stacked borrows footguns. The particular code that was the background for this conversation was something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">ptr</span>::<span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">().</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">().</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">amt</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This is currently UB because under SB because the pointer in the first argument is invalidated by the <code>.as_mut_ptr()</code> method call for the second argument. In an attempt to reduce the danger of this (and some other things), I have the following proposal for a modification to the model:</p>\n<ol>\n<li>Raw pointers do not appear on the borrow stack. Instead, a raw pointer's memory now consists of a) whether it has rw provenance or just read provenance, and b) a snapshot of the current borrow stack at the time of the creation of the pointer - I'll call this the pointer's native stack.</li>\n<li>Writing to a raw pointer pops things off the current borrow stack until the borrow stack is a <em>prefix</em> of the pointer's native stack. Illegally popping a function guard in this manner is still UB. Writing through a raw pointer without write provenance is also still UB. However, in any other case, the write is well defined - regardless of what remains on the borrow stack.</li>\n<li>Reading through a raw pointer pops things off the current borrow stack until the borrow stack consists of a prefix of the pointer's native stack, possibly followed by any number of <code>SharedRO</code> items. Illegally popping a function guard is still UB. In all other cases, the read is well defined, once more regardless of the borrow stack.</li>\n</ol>\n<p>Reborrowing a pointer as a reference is unchanged. Depending on the type of the reference, this counts as a read/write of the pointer, and the resulting item is then put on top of the borrow stack. I have not carefully checked how this interacts with <code>UnsafeCell</code>. My hope is that this will mostly work out by placing things appropriately in the middle of the stack, but that obviously remains to be seen.</p>\n<p>The example above is now no longer UB. The <code>&amp;mut self</code> in the <code>.as_mut_ptr()</code> call now invalidates the <code>&amp;self</code> in <code>.as_ptr()</code>, but not the pointer derived from it. Reading from the pointer returned by <code>.as_ptr()</code> within the <code>copy</code> call also invalidates the <code>&amp;mut self</code>, but again not the pointer derived from it. At the end of this snippet, both the references have been invalidated but the code is otherwise well defined.</p>\n<p>The key optimizations we want from SB are still possible. No write through a pointer not derived from a <code>&amp;mut</code> is possible between two uses of the <code>&amp;mut</code> - even if the pointer doing the writing (or its parents) are no longer on the borrow stack, the <code>Unique</code> item would still be popped. Similar things are true for <code>&amp;</code> - any write to any aliasing pointer during its lifetime invalidates it. There is a class of optimizations that this does disallow though:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// code using x</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// code *not* using x</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In current SB, I believe it would be correct to optimize this to return 13. This would no longer be the case - the \"code using <code>x</code>\" might store a pointer that aliases, but is derived from, <code>x</code>, and the \"code not using <code>x</code>\" might write to that pointer. This could be fixed by adding the following rule:</p>\n<ol start=\"4\">\n<li>Writing through a <code>Unique</code> retags it first.</li>\n</ol>\n<p>We probably want to have this to re-allow the previous optimization. However, this is also the part I am least sure about, so I'm listing it separately.</p>\n<p>I'd love to hear what people think. I'm not super up to date on the latest developments with SB, but I vaguely remember someone mentioning other patterns that it wouldn't support. I'd be interested in hearing about that and seeing how this changes things.</p>",
        "id": 266738034,
        "sender_full_name": "Jake",
        "timestamp": 1641244834
    },
    {
        "content": "<p>FWIW, I find the first example being UB easier to wrap my head around and the pitfall could also be alleviated with a linting rule for <code>ptr::copy</code>. I've actually saw several cases of this particular kind of UB in the standard library :) Those have all been solved in the meantime (the last one I saw was in <code>&lt;[T]&gt;::copy_within()</code>) and that underlines your point that <code>ptr::copy</code> is a foot-gun in SB. The new proposal makes it easier not to accidentally make that mistake, but it makes it harder to reason about the SB rules mentally elsewhere (potentially leading to more foot-guns down the road).  It might be helpful if we find other examples in the wild other than mis-use of <code>ptr::copy</code> to see if the problem is more wide-spread. That said, by no means I want to discourage this proposal, it's good that SB is still being refined, thanks for that!</p>",
        "id": 266741795,
        "sender_full_name": "Pointerbender",
        "timestamp": 1641247300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Proposed.20Modification.20to.20SB.20to.20Reduce.20Pointer.20Invalidation/near/266741795\">said</a>:</p>\n<blockquote>\n<p>FWIW, I find the first example being UB easier to wrap my head around and the pitfall could also be alleviated with a linting rule for <code>ptr::copy</code>. I've actually saw several cases of this particular kind of UB in the standard library :) Those have all been solved in the meantime (the last one I saw was in <code>&lt;[T]&gt;::copy_within()</code>) and that underlines your point that <code>ptr::copy</code> is a foot-gun in SB. The new proposal makes it easier not to accidentally make that mistake, but it makes it harder to reason about the SB rules mentally elsewhere (potentially leading to more foot-guns down the road).  It might be helpful if we find other examples in the wild other than mis-use of <code>ptr::copy</code> to see if the problem is more wide-spread. That said, by no means I want to discourage this proposal, it's good that SB is still being refined, thanks for that!</p>\n</blockquote>\n<p>So I brought up that example because it was the source of the conversation, but there are other potential footguns too. Consider for example this code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">set_len</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"c1\">// or any other operation with `p`</span>\n</code></pre></div>\n<p>In current Rust + current SB this is not UB. However, if <code>Vec::set_len</code> is modified to internally call <code>Vec::deref()</code> for whatever reason, this suddenly becomes UB because the reference created by <code>deref</code> invalidates <code>p</code>. As such, <code>set_len</code> not using the <code>Vec</code>'s data pointer internally is now effectively a part of its API (unless we want the above code to be library UB). With my proposal, that's no longer the case. <code>Vec</code> may internally create all the references into its backing buffer that it wants, none of them invalidate <code>p</code>. This seems like a desirable property, since one of the things that SB aims for is to maximize local reasoning - presumably not only for the compiler, but also for the user.</p>",
        "id": 266744475,
        "sender_full_name": "Jake",
        "timestamp": 1641249189
    },
    {
        "content": "<p>Very nice example! Intuitively I agree that <code>set_len</code> calling <code>deref</code> internally should not be the deciding factor for whether <code>p</code> is invalidated or not :)</p>",
        "id": 266747673,
        "sender_full_name": "Pointerbender",
        "timestamp": 1641251385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Proposed.20Modification.20to.20SB.20to.20Reduce.20Pointer.20Invalidation/near/266741795\">said</a>:</p>\n<blockquote>\n<p>FWIW, I find the first example being UB easier to wrap my head around and the pitfall could also be alleviated with a linting rule for <code>ptr::copy</code>. I've actually saw several cases of this particular kind of UB in the standard library :) Those have all been solved in the meantime (the last one I saw was in <code>&lt;[T]&gt;::copy_within()</code>) and that underlines your point that <code>ptr::copy</code> is a foot-gun in SB. The new proposal makes it easier not to accidentally make that mistake, but it makes it harder to reason about the SB rules mentally elsewhere (potentially leading to more foot-guns down the road).  It might be helpful if we find other examples in the wild other than mis-use of <code>ptr::copy</code> to see if the problem is more wide-spread. That said, by no means I want to discourage this proposal, it's good that SB is still being refined, thanks for that!</p>\n</blockquote>\n<p>People disable lints like this in the wild, for example <a href=\"https://github.com/RedisLabsModules/redismodule-rs/issues/205\">https://github.com/RedisLabsModules/redismodule-rs/issues/205</a><br>\nSo I'm not sure saying \"There could be a lint for that\" is a good enough argument to underline the point</p>",
        "id": 266748099,
        "sender_full_name": "Nick12",
        "timestamp": 1641251639
    },
    {
        "content": "<blockquote>\n<p>So I brought up that example because it was the source of the conversation, but there are other potential footguns too. Consider for example this code:</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">set_len</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"c1\">// or any other operation with `p`</span>\n</code></pre></div>\n<p>Btw, I can't get Miri to trigger on that example (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=901ed622898b9c12512474d13dc9e0c6\">playground</a>).</p>",
        "id": 266748491,
        "sender_full_name": "Pointerbender",
        "timestamp": 1641251861
    },
    {
        "content": "<blockquote>\n<p>People disable lints like this in the wild, for example <a href=\"https://github.com/RedisLabsModules/redismodule-rs/issues/205\">https://github.com/RedisLabsModules/redismodule-rs/issues/205</a> So I'm not sure saying \"There could be a lint for that\" is a good enough argument to underline the point</p>\n</blockquote>\n<p>For <code>ptr::copy</code> I think it could be good enough to detect the insta-UB (which is different from the <em>unsoundness</em> lint in your link, that is not immediate UB). Detecting insta-UB is all a <code>ptr::copy</code>-lint would be good for though, I don't see a way to use lints to solve the more general case.</p>",
        "id": 266749546,
        "sender_full_name": "Pointerbender",
        "timestamp": 1641252502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Proposed.20Modification.20to.20SB.20to.20Reduce.20Pointer.20Invalidation/near/266748491\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>So I brought up that example because it was the source of the conversation, but there are other potential footguns too. Consider for example this code:</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"p\">).</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">set_len</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"c1\">// or any other operation with `p`</span>\n</code></pre></div>\n<p>Btw, I can't get Miri to trigger on that example (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=901ed622898b9c12512474d13dc9e0c6\">playground</a>).</p>\n</blockquote>\n<p>Ah yeah, the pointer doesnt get retagged, I forgot about that. I think there's <em>probably</em> a similar example which doesn't break on this, but I'm not sure</p>",
        "id": 266751078,
        "sender_full_name": "Jake",
        "timestamp": 1641253731
    },
    {
        "content": "<p>This post also has some great examples btw: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/133#issuecomment-1005883534\">https://github.com/rust-lang/unsafe-code-guidelines/issues/133#issuecomment-1005883534</a></p>",
        "id": 266958572,
        "sender_full_name": "Pointerbender",
        "timestamp": 1641401008
    },
    {
        "content": "<p>with <code>let p = unsafe { (&amp;mut *vec.as_ptr()) as *mut u8 };</code> and <code>-Zmiri-tag-raw-pointers</code>, the vec example also errors</p>",
        "id": 268203913,
        "sender_full_name": "RalfJ",
        "timestamp": 1642363412
    },
    {
        "content": "<p>This is an interesting proposal! Unfortunately I currently do not have the time to thoroughly think through all of its consequences. I will say that having to retag <code>Unique</code> pointers on each write seems problematic, since this means doing a write <em>though</em> a pointer will actually mutate that pointer -- that seems suspicious at least, since I would not usually expect us to have the permission to perform that mutation.<br>\nAlso on a conceptual level it seems strange that raw pointers behave so differently. in particular, raw pointers should behave basically the same as <code>&amp;UnsafeCell</code> pointers, so would you say they should also be treated in the same way in your model?</p>",
        "id": 268204296,
        "sender_full_name": "RalfJ",
        "timestamp": 1642363875
    }
]