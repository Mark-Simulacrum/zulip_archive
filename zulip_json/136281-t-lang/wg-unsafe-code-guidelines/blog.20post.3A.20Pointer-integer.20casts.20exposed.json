[
    {
        "content": "<p>I finally finished writing that blog post that I kept mentioning: <a href=\"https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html\">https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html</a>.<br>\nI am sorry that it got so long...</p>",
        "id": 278578427,
        "sender_full_name": "RalfJ",
        "timestamp": 1649693936
    },
    {
        "content": "<p>Hmm, I'd disagree about <code>union</code> really being all over the place, and if it were just accesses directly through the union I think it would be fine. It would be reasonably straightforward to specify at a source language level rules that could reasonably only stop optimizations when you actually do a pun or are already having the union escape.</p>\n<p>But you can take pointers to union members and then you get into the pointer pun issue and so you still lose, just one step beyond what you said in the post (and currently unions get to LLVM just as pointer puns, so you lose there anyways as well).</p>",
        "id": 278586811,
        "sender_full_name": "Talchas",
        "timestamp": 1649697385
    },
    {
        "content": "<p>Is it widely agreed that the initial definition of <code>uwu()</code> has defined behaviour in C?</p>",
        "id": 278588020,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649697966
    },
    {
        "content": "<p>it is definitely not UB by the spec's (exceedingly generous) <code>restrict</code> rule, it does no pointer math at <code>uintptr_t</code> (implementation defined iirc), and doesn't go OOB of the original array when doing <code>y-1</code>. <code>restrict</code> pointers are allowed to overlap as long as the execution does not have a write conflict through them.</p>",
        "id": 278589033,
        "sender_full_name": "Talchas",
        "timestamp": 1649698434
    },
    {
        "content": "<p>There is a write to the same object through two pointers: <code>x</code> and <code>ptr</code>.  The standard says <code>ptr</code> must be \"based on\" <code>x</code> in this case, because <code>x</code> is <code>restrict</code> qualified.  Is it?</p>",
        "id": 278593001,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649699992
    },
    {
        "content": "<p>The meaning of \"based on\" is something like \"if the value of <code>x</code> was changed, would the value of <code>ptr</code> be different?\"</p>",
        "id": 278593185,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649700046
    },
    {
        "content": "<p>But if the value of <code>x</code> was changed, we would no longer enter that block...</p>",
        "id": 278593222,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649700067
    },
    {
        "content": "<p>I think it would have to, as otherwise something like <code>x[1] = 1; if (x == (void*)0xDEADBEEF) x[1] = 2;</code> wouldn't qualify</p>",
        "id": 278594304,
        "sender_full_name": "Talchas",
        "timestamp": 1649700523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278586811\">said</a>:</p>\n<blockquote>\n<p>Hmm, I'd disagree about <code>union</code> really being all over the place, and if it were just accesses directly through the union I think it would be fine. It would be reasonably straightforward to specify at a source language level rules that could reasonably only stop optimizations when you actually do a pun or are already having the union escape.</p>\n<p>But you can take pointers to union members and then you get into the pointer pun issue and so you still lose, just one step beyond what you said in the post (and currently unions get to LLVM just as pointer puns, so you lose there anyways as well).</p>\n</blockquote>\n<p>yeah I know. it didnt feel worth spelling that all out in the post...</p>",
        "id": 278594502,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306504\">Tavian Barnes</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278593222\">said</a>:</p>\n<blockquote>\n<p>But if the value of <code>x</code> was changed, we would no longer enter that block...</p>\n</blockquote>\n<p>yes. that's exactly why the definition in the C standard is a terrible definition. ;)</p>",
        "id": 278594576,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700649
    },
    {
        "content": "<p>but if <code>(int*)(uintptr_t)x</code> is <em>not</em> \"based on\" <code>x</code>, then that means pointer-integer roundtrips are forbidden for <code>restrict</code> pointers. I cant imagine that is anyone's intention.</p>",
        "id": 278594649,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700690
    },
    {
        "content": "<p>basically, this is the one axiom I am assuming in the post: if I could have used <code>x</code> to do something, then I am also allowed to use <code>(int*)(uintptr_t)x</code> to do the same thing.</p>",
        "id": 278594734,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700722
    },
    {
        "content": "<p>RIP no cautions</p>",
        "id": 278595038,
        "sender_full_name": "Zoxc",
        "timestamp": 1649700862
    },
    {
        "content": "<p>someone is looking at my edit diffs? ;)</p>",
        "id": 278595122,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700916
    },
    {
        "content": "<p>No, spotted a typo and checked if F5 fixed it</p>",
        "id": 278595801,
        "sender_full_name": "Zoxc",
        "timestamp": 1649701209
    },
    {
        "content": "<p>:D</p>",
        "id": 278595823,
        "sender_full_name": "RalfJ",
        "timestamp": 1649701222
    },
    {
        "content": "<blockquote>\n<p>it becomes near impossible to write a tool like Miri that precisely matches the specification, since Miri cannot possibly implement this “guessing” accurately.</p>\n</blockquote>\n<p>Why is this? Can't you just give the pointer returned by the <code>i</code>th int2ptr cast the provenance <code>angelic(i)</code>, and then if the pointer is ever used, replace <code>angelic(i)</code> with whatever provenance you need for that particular use, failing if the target provenance hasn't previously been exposed.</p>",
        "id": 278598052,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649702068
    },
    {
        "content": "<p>The problem is there might be more than one legal provenance for the use</p>",
        "id": 278598743,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702335
    },
    {
        "content": "<p>It could pick up 2 provenences and narrow by further operations still?</p>",
        "id": 278598839,
        "sender_full_name": "Zoxc",
        "timestamp": 1649702379
    },
    {
        "content": "<p>Hmm. How can you get multiple provenances?</p>",
        "id": 278599035,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649702458
    },
    {
        "content": "<p>You very quickly get exponential growth in the state space though. It might never be the case that one of the choices leads to UB, so you have to permanently keep both around</p>",
        "id": 278599055,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702472
    },
    {
        "content": "<p>Actually, what is the case with multiple legal provenances?</p>",
        "id": 278599077,
        "sender_full_name": "Zoxc",
        "timestamp": 1649702478
    },
    {
        "content": "<p>each of those provenances could invalidate different other provenances I think, so if you want to precisely check things that causes branching states</p>",
        "id": 278599116,
        "sender_full_name": "Talchas",
        "timestamp": 1649702496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278599035\">said</a>:</p>\n<blockquote>\n<p>Hmm. How can you get multiple provenances?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Is this `p` or `p2`</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278599358,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702600
    },
    {
        "content": "<p>Ah, right, I see. Okay I understand why it is difficult now.</p>",
        "id": 278599617,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649702719
    },
    {
        "content": "<p>To be clear, I don't see a fundamental reason that this is actually impossible. Like, it totally might be the case that there's some super smart algorithm here that can represent the exponentially many states in some compact way that allows for execution to continue quickly. I just don't know one</p>",
        "id": 278599815,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702818
    },
    {
        "content": "<p>Wouldn't both <code>p</code> and <code>p2</code> have the provenance of <code>x</code>'s allocation? Or are you assuming some more fancy provenance model?</p>",
        "id": 278599887,
        "sender_full_name": "Zoxc",
        "timestamp": 1649702860
    },
    {
        "content": "<p>I'm assuming SB</p>",
        "id": 278599910,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702873
    },
    {
        "content": "<p>Which I suppose is that fancy provenance model</p>",
        "id": 278599927,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702881
    },
    {
        "content": "<p>Indeed other provenance models might have it easier (although PNVI-ae-udi has the UDI part that causes the same thing just in a slightly harder to hit way)</p>",
        "id": 278600039,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702930
    },
    {
        "content": "<p>I had forgotten to take into account that you get a tree of provenances by using SB, and that it wasn't just \"which allocation does it come from?\"</p>",
        "id": 278600123,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1649702979
    },
    {
        "content": "<p>the main thing I'm not 100% sure about is if you can do some approximation that doesn't detect all UB but is simpler (like letting you use a pointer with provenance for X then Y then X again); the fact that using a pointer for X can invalidate things is the issue though</p>",
        "id": 278600130,
        "sender_full_name": "Talchas",
        "timestamp": 1649702983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278600130\">said</a>:</p>\n<blockquote>\n<p>the main thing I'm not 100% sure about is if you can do some approximation that doesn't detect all UB but is simpler (like letting you use a pointer with provenance for X then Y then X again); the fact that using a pointer for X can invalidate things is the issue though</p>\n</blockquote>\n<p>If I'm not mistaken this is what's being done in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance</a></p>",
        "id": 278600267,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649703040
    },
    {
        "content": "<p>The proposal there is an under-approximation of SB + Rust-PNVI that allows miri to not completely bail on permissive provenance and also catch all SB UB on strict provenance - again, if I'm not mistaken</p>",
        "id": 278600358,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649703093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278600123\">said</a>:</p>\n<blockquote>\n<p>I had forgotten to take into account that you get a tree of provenances by using SB, and that it wasn't just \"which allocation does it come from?\"</p>\n</blockquote>\n<p>Even if it was just that though, C hits it on pointers that are either at the beginning of one allocation or one-past-the-end of another, and Rust would hit it on even more casts because when you do int2ptr it's not even clear which allocation the pointer belongs to (since there's no requirement to be in bounds)</p>",
        "id": 278600720,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649703259
    },
    {
        "content": "<p>I think there is an error in the \"Integer-pointer casts are not pure, either\" section. <code>y2copy</code> is presumably a pointer with provenance over <code>i[1]</code>, but it is out of bounds when it is created. You could do this trick in the other direction however, creating a one-past-the-end pointer to <code>i[0]</code> and then subtracting 1 to make it inbounds before reading from it</p>",
        "id": 278600741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649703270
    },
    {
        "content": "<p>I dont think there is any rule that pointers have to be \"in-bounds of their <code>restrict</code> provenance\"</p>",
        "id": 278604481,
        "sender_full_name": "RalfJ",
        "timestamp": 1649705223
    },
    {
        "content": "<p>in fact, I dont think that is even well-defined</p>",
        "id": 278604493,
        "sender_full_name": "RalfJ",
        "timestamp": 1649705229
    },
    {
        "content": "<p><code>restrict</code> just says that these two pointers cannot be used to access the same memory</p>",
        "id": 278604525,
        "sender_full_name": "RalfJ",
        "timestamp": 1649705249
    },
    {
        "content": "<p>the following is legal, even though <code>x</code> and <code>y</code> are equal:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">uwu</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"kr\">restrict</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"kr\">restrict</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">uwu</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278604670,
        "sender_full_name": "RalfJ",
        "timestamp": 1649705320
    },
    {
        "content": "<p>when you mentioned in the post that <code>restrict</code> is more complicated than <code>&amp;mut</code>, I was hoping you or someone would point me to a comprehensible description of what it actually means, because I don't really have any concept of what <code>restrict</code> does except by analogy to rust</p>",
        "id": 278608334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649707222
    },
    {
        "content": "<p>If non-deterministic int-&gt;ptr casts simplify Stacked Borrows vs intptrcast (which I assume is the comparison here)? Does that result in a blog post describing a simplified Stacked Borrows?</p>",
        "id": 278609726,
        "sender_full_name": "Zoxc",
        "timestamp": 1649707920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278608334\">said</a>:</p>\n<blockquote>\n<p>when you mentioned in the post that <code>restrict</code> is more complicated than <code>&amp;mut</code>, I was hoping you or someone would point me to a comprehensible description of what it actually means, because I don't really have any concept of what <code>restrict</code> does except by analogy to rust</p>\n</blockquote>\n<p>I am not aware of any precise description. the C standard tries to be precise but fails at that (IMO).<br>\nso the best thing I can offer is: <code>restrict</code> promises that this pointer, and all pointers derived from it, will not be used to perform memory accesses that <em>conflict</em> with any access done by pointers outside of that set. A \"conflict\" arises when two memory accesses overlap and at least one of them is a write.</p>",
        "id": 278611213,
        "sender_full_name": "RalfJ",
        "timestamp": 1649708492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116466\">Zoxc</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278609726\">said</a>:</p>\n<blockquote>\n<p>If non-deterministic int-&gt;ptr casts simplify Stacked Borrows vs intptrcast (which I assume is the comparison here)? Does that result in a blog post describing a simplified Stacked Borrows?</p>\n</blockquote>\n<p>it's just good ol' stacked borrows without <code>Untagged</code> :)</p>",
        "id": 278611348,
        "sender_full_name": "RalfJ",
        "timestamp": 1649708536
    },
    {
        "content": "<p>I've yet to page in stacked borrows ;)</p>",
        "id": 278612056,
        "sender_full_name": "Zoxc",
        "timestamp": 1649708854
    },
    {
        "content": "<p>fair ;)</p>",
        "id": 278612441,
        "sender_full_name": "RalfJ",
        "timestamp": 1649709009
    },
    {
        "content": "<p>but no I am not planning a new SB blog post</p>",
        "id": 278612489,
        "sender_full_name": "RalfJ",
        "timestamp": 1649709030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278599815\">said</a>:</p>\n<blockquote>\n<p>To be clear, I don't see a fundamental reason that this is actually impossible. Like, it totally might be the case that there's some super smart algorithm here that can represent the exponentially many states in some compact way that allows for execution to continue quickly. I just don't know one</p>\n</blockquote>\n<p>The keyword to look for is \"state reduction\", <a href=\"https://docs.rs/loom/latest/loom/\">loom</a> uses such an approach to compactly represent all the possible thread-interleavings, maybe such techniques could be ported to pointer provenance, too. (although I'm no expert in that area and would not know where to start :D )</p>",
        "id": 278673734,
        "sender_full_name": "Pointerbender",
        "timestamp": 1649759229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278673734\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/blog.20post.3A.20Pointer-integer.20casts.20exposed/near/278599815\">said</a>:</p>\n<blockquote>\n<p>To be clear, I don't see a fundamental reason that this is actually impossible. Like, it totally might be the case that there's some super smart algorithm here that can represent the exponentially many states in some compact way that allows for execution to continue quickly. I just don't know one</p>\n</blockquote>\n<p>The keyword to look for is \"state reduction\", <a href=\"https://docs.rs/loom/latest/loom/\">loom</a> uses such an approach to compactly represent all the possible thread-interleavings, maybe such techniques could be ported to pointer provenance, too. (although I'm no expert in that area and would not know where to start :D )</p>\n</blockquote>\n<p>State reduction like techniques might be one approach, but what I meant was that I don't even see a fundamental reason that there can't exist a data structure that can just represent the result of int2ptr operations without increasing the execution time of all future operations</p>",
        "id": 278675298,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649760375
    },
    {
        "content": "<p>that depends a lot on the details of the aliasing model</p>",
        "id": 278699461,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773247
    },
    {
        "content": "<p>the great thing about the nondet approach is that it is agnostic about the aliasing model</p>",
        "id": 278699484,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773260
    },
    {
        "content": "<p>so we can first figure out the perfect aliasing model for Rust, knowing that it will at least be coherent also for pointer-integer round-trips, and then we can see if we find algorithms for checking that model that are more efficient</p>",
        "id": 278699581,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773312
    },
    {
        "content": "<p>and maybe one of those algorithms is so good that we can make <em>it</em> the official memory model for Rust, even if i has a bit less UB than the nondeterministic approach</p>",
        "id": 278699666,
        "sender_full_name": "RalfJ",
        "timestamp": 1649773343
    }
]