[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/494\">Implement <code>Clone</code> for generators #494</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 274292548,
        "sender_full_name": "triagebot",
        "timestamp": 1646554227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296833\">Dante Broggi</span> has marked this topic as unresolved.</p>",
        "id": 274309707,
        "sender_full_name": "Notification Bot",
        "timestamp": 1646578313
    },
    {
        "content": "<blockquote>\n<p>It would be nice if generators, like closures, could automatically implement Clone and Copy where possible. Is this something that the lang team would consider desirable?</p>\n</blockquote>\n<p>I think this should be <a href=\"https://lang-team.rust-lang.org/initiatives/process.html\">Lang Team proposal</a> before we consider implementing this behavior in the compiler.</p>",
        "id": 274404818,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1646665842
    },
    {
        "content": "<p>Is a lang team proposal really necessary? I figure that we'll inevitably want this in the language in some form or another since (a) it's technically possible and has use-cases and (b) we already have clonable closures and generators are just a generalized form of closure. The question for the lang team is how to make this available to users, though since we haven't even settled on a design for generators yet it seems premature to open debates about how to extend that design. For now would it be sufficient to just keep this behind a feature gate?</p>",
        "id": 275081400,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647067832
    },
    {
        "content": "<p>Yeah, while generator syntax and semantics seems like lang, the type they generate and what traits it implements seem more like libs.</p>",
        "id": 275083118,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647070720
    },
    {
        "content": "<p>I think if it's behind a gate that would suffice.</p>",
        "id": 275083122,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647070738
    },
    {
        "content": "<p>I haven't had a reply to the MCP yet but I've gone ahead and implemented this. Should I make a PR with a link to the MCP?</p>",
        "id": 275138313,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647154883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20.60Clone.60.20for.20generators.20compiler-team.23494/near/275083118\">said</a>:</p>\n<blockquote>\n<p>Yeah, while generator syntax and semantics seems like lang, the type they generate and what traits it implements seem more like libs.</p>\n</blockquote>\n<p>i don't think this is necessarily true, given that this would cause the return type of async functions to implement <code>Clone</code>, which seems like t-lang to me</p>",
        "id": 275201146,
        "sender_full_name": "lcnr",
        "timestamp": 1647242977
    },
    {
        "content": "<p>this would leak a lot more about the interior of async functions as using a non <code>Clone</code> type inside of a function changes the traits implemented by its return type. Currently this is only the case for auto traits.</p>",
        "id": 275201460,
        "sender_full_name": "lcnr",
        "timestamp": 1647243283
    },
    {
        "content": "<p>i also don't really see how that can be sound, given that unlike auto traits, <code>Clone</code> can have side effects:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">Rc</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Rc</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">Rc</span>::<span class=\"n\">make_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>i would expect <code>foo</code> to implement <code>Clone</code> with your proposal, as all possible states of the underlying generator only contain types which are <code>Clone</code>. This still breaks as the generator is self referential.</p>",
        "id": 275201697,
        "sender_full_name": "lcnr",
        "timestamp": 1647243552
    },
    {
        "content": "<p>Even when restricting the <code>Clone</code> impls to movable generators - <em>edit: which you do</em> - this seems scary to me, as I personally wouldn't expect clone impls to run at these points. With unsafe code this can still cause hard to detect unsoundness</p>",
        "id": 275201994,
        "sender_full_name": "lcnr",
        "timestamp": 1647243859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20.60Clone.60.20for.20generators.20compiler-team.23494/near/275201460\">said</a>:</p>\n<blockquote>\n<p>this would leak a lot more about the interior of async functions as using a non <code>Clone</code> type inside of a function changes the traits implemented by its return type. Currently this is only the case for auto traits.</p>\n</blockquote>\n<p>for closures this isn't an issue as the only way to leak closures is via <code>impl Trait</code> where the <code>Clone</code> bound has be explicitly added for it to be usable by other crates</p>",
        "id": 275202170,
        "sender_full_name": "lcnr",
        "timestamp": 1647244061
    },
    {
        "content": "<blockquote>\n<p>for closures this isn't an issue as the only way to leak closures is via <code>impl Trait</code> where the <code>Clone</code> bound has be explicitly added for it to be usable by other crates.</p>\n</blockquote>\n<p>I think that's how it should work for generators too. There should be some way to make an <code>async</code> block cloneable but I'm not sure that it should happen implicitly. With the current implementation <code>async</code> blocks are never cloneable because they're always marked as <code>static</code> (ie. <code>Movability::Static</code>). The only way to access this feature is to use the unstable generator syntax explicitly, not mark the generator as <code>static</code> and to refer to its type as <code>impl Generator&lt;...&gt; + Clone</code>.</p>",
        "id": 275218174,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647254363
    },
    {
        "content": "<p>ah, so by default all asnyc functions are <code>Static</code> as well?</p>",
        "id": 275218312,
        "sender_full_name": "lcnr",
        "timestamp": 1647254454
    },
    {
        "content": "<p>you can't have movable generators returned from <code>async fn</code>?</p>",
        "id": 275218322,
        "sender_full_name": "lcnr",
        "timestamp": 1647254464
    },
    {
        "content": "<p>Yeah, you can't clone the type of <code>async {}</code> with this as-implemented. Whether you should be able to do that I'll leave for other people to decide.</p>",
        "id": 275218502,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647254546
    },
    {
        "content": "<p>I have seen the idea floated of being able to put <code>#[derive(...)]</code> attributed on closures, and that could be extended to generators and async blocks to. But that's a long ways off, and I have no idea how it would work on the macro side of things.</p>",
        "id": 275218769,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647254707
    },
    {
        "content": "<blockquote>\n<p>you can't have movable generators returned from <code>async fn</code>?</p>\n</blockquote>\n<p>Yes. Movability is not the same as <code>Unpin</code>. It's stricter and is declared up-front, rather than being inferred. At least that's how things work at the moment.</p>",
        "id": 275219268,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647255005
    },
    {
        "content": "<p>Even if we made async blocks implicitly be Clone if possible, that would not affect async fn. Async fn uses impl trait internally and only exposes the Future trait of the async block, nothing else (except for auto traits)</p>",
        "id": 275220491,
        "sender_full_name": "oli",
        "timestamp": 1647255704
    },
    {
        "content": "<p>I don't see a problem  in making async blocks clonable automatically beyond the fact that optimizations may cause surprising cases to work or not work. That would ve a problem in explicit cases, too, so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 275220703,
        "sender_full_name": "oli",
        "timestamp": 1647255810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20.60Clone.60.20for.20generators.20compiler-team.23494/near/275220491\">said</a>:</p>\n<blockquote>\n<p>Even if we made async blocks implicitly be Clone if possible, that would not affect async fn. Async fn uses impl trait internally and only exposes the Future trait of the async block, nothing else (except for auto traits)</p>\n</blockquote>\n<p>forgot about that <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 275221552,
        "sender_full_name": "lcnr",
        "timestamp": 1647256317
    },
    {
        "content": "<p>Would anyone be willing to review my commits for this? <a href=\"https://github.com/canndrew/rust/commits/clone-generators\">https://github.com/canndrew/rust/commits/clone-generators</a></p>",
        "id": 275887910,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647662749
    },
    {
        "content": "<p>Feel free to assign to me. If there's anything I'm unsure about i'll find someone to reassign to</p>",
        "id": 275907131,
        "sender_full_name": "oli",
        "timestamp": 1647691508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I don't have a PR yet to assign a reviewer to. I don't know whether it's appropriate to open a PR for a change that hasn't had its MCP approved. Would you be willing to second <a href=\"https://github.com/rust-lang/compiler-team/issues/494\">the MCP</a>? Or should I just go ahead and open a PR?</p>",
        "id": 275954227,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647763089
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"492\">@T-compiler</span>: Proposal <a href=\"https://github.com/rust-lang/compiler-team/issues/494#issuecomment-1073220392\">#494</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 275960095,
        "sender_full_name": "triagebot",
        "timestamp": 1647772400
    },
    {
        "content": "<p>Oops, yea, this seems good to me in gated form and we can talk to the lang team once we have done some experiments</p>",
        "id": 275960162,
        "sender_full_name": "oli",
        "timestamp": 1647772513
    },
    {
        "content": "<p>Cool :). Should I PR it then? Or just leave it on my own repo/branch for now?</p>",
        "id": 275960328,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647772764
    },
    {
        "content": "<p>Open a PR, maybe in WIP mode and assign it to me</p>",
        "id": 275961224,
        "sender_full_name": "oli",
        "timestamp": 1647774105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>: Thanks :). I've done that here: <a href=\"https://github.com/rust-lang/rust/pull/95137\">https://github.com/rust-lang/rust/pull/95137</a></p>",
        "id": 275969952,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1647786605
    },
    {
        "content": "<p>As per the comments on the MCP I've created a tracking issue for this here: <a href=\"https://github.com/rust-lang/rust/issues/95360\">https://github.com/rust-lang/rust/issues/95360</a></p>\n<p>I can't add the required labels to it though (<code>F-generator_clone</code> and <code>T-lang</code> I believe) because I don't have write access to the repo. Could someone do that for me?</p>",
        "id": 276824262,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1648438849
    },
    {
        "content": "<p>This proposal has been accepted: <a href=\"https://github.com/rust-lang/compiler-team/issues/494\">#494</a>.</p>",
        "id": 277188516,
        "sender_full_name": "triagebot",
        "timestamp": 1648665420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257503\">Andrew Cann</span>  [said]   ( <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20.60Clone.60.20for.20generators.20compiler-team.23494/near/276824262\">https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20.60Clone.60.20for.20generators.20compiler-team.23494/near/276824262</a> )：</p>\n<blockquote>\n<p>I can't add the required labels to it though (<code>F-generator_clone</code> and <code>T-lang</code> I believe) because I don't have write access to the repo. Could someone do that for me?</p>\n</blockquote>\n<p>Done.</p>",
        "id": 277684089,
        "sender_full_name": "Charles Lew",
        "timestamp": 1649050575
    }
]