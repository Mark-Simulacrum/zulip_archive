[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/422\">Update the existing musl targets to be dynamically linked. #422</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 232759888,
        "sender_full_name": "triagebot",
        "timestamp": 1617285308
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"492\">@T-compiler</span>: Proposal <a href=\"https://github.com/rust-lang/compiler-team/issues/422#issuecomment-812136431\">#422</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 232815405,
        "sender_full_name": "triagebot",
        "timestamp": 1617306934
    },
    {
        "content": "<p>Is this the right place for comments about <a href=\"https://github.com/rust-lang/compiler-team/issues/422\">https://github.com/rust-lang/compiler-team/issues/422</a>?<br>\nI might be misunderstanding the benefits of that proposal, but for me it seems like a step back. I use the <code>x86_64-unknown-linux-musl</code> target when I cross-compile from Windows to Linux. When I build on Linux for Linux I use <code>x86_64-unknown-linux-gnu</code>, but I think that target can't do cross-compilation. Now, the binaries I produce should of course run on normal (glibc-based) Linux, and preferably on Alpine Linux (the only musl-based Linux I know) as well. If I understand correctly, if the musl target were to be dynamically linked, they would stop working on normal Linux, right?<br>\nCross-compilation is <em>already</em> crippled by the fact that rustup doesn't install enough stuff to cross-compile C code, so for example simply having the <code>ring</code> crate as a (recursive) dependency already breaks it, and this proposal seems to break <em>even more</em> use cases.</p>",
        "id": 233806579,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617968459
    },
    {
        "content": "<blockquote>\n<p>If I understand correctly, if the musl target were to be dynamically linked, they would stop working on normal Linux, right?</p>\n</blockquote>\n<p>They will be dynamically linked by default, you could still specify static linking with <code>RUSTFLAGS=-Ctarget-feature=+crt-static</code></p>",
        "id": 233809107,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617969864
    },
    {
        "content": "<p>Would that be possible from Cargo.toml/Cargo-config?</p>",
        "id": 233814091,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617972266
    },
    {
        "content": "<p>I don't see why not, cargo.config should work</p>",
        "id": 233814462,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617972465
    },
    {
        "content": "<blockquote>\n<p>When I build on Linux for Linux I use x86_64-unknown-linux-gnu, but I think that target can't do cross-compilation</p>\n</blockquote>\n<p>I haven't tested but I would <em>expect</em> these to work with <code>+crt-static</code> too</p>",
        "id": 233814558,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617972505
    },
    {
        "content": "<p>Well ok, then I don't care. :) Cross-compilation already needs <code>linker = \"rust-lld\"</code>, so one more config line doesn't matter. Best would be if it worked out of the box of course.</p>",
        "id": 233814667,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617972570
    },
    {
        "content": "<p>yeah I definitely think we should have a blog post or something explaining exactly how to get the old behavior</p>",
        "id": 233814832,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617972636
    },
    {
        "content": "<blockquote>\n<p>I haven't tested but I would expect these to work with +crt-static too</p>\n</blockquote>\n<p>Hm, I have set that <code>RUSTFLAGS</code> variable that you wrote and tried a <code>cargo build --target=x86_64-unknown-linux-gnu</code>.</p>",
        "id": 233815648,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617973023
    },
    {
        "content": "<p>Doesn't work.<br>\n<a href=\"/user_uploads/4715/YJhIMpRXhaz4z8YL6yeE_hXj/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/YJhIMpRXhaz4z8YL6yeE_hXj/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/YJhIMpRXhaz4z8YL6yeE_hXj/image.png\"></a></div>",
        "id": 233815769,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617973081
    },
    {
        "content": "<p>hmm maybe not if you're building with an MSVC toolchain</p>",
        "id": 233815870,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617973109
    },
    {
        "content": "<p>Isn't it a GNU toolchain?</p>",
        "id": 233815972,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617973159
    },
    {
        "content": "<p>so it is</p>",
        "id": 233815980,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617973166
    },
    {
        "content": "<p>not sure then</p>",
        "id": 233815983,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617973168
    },
    {
        "content": "<p>I learned about that <code>linker = \"rust-lld\"</code> setting in a GitHub issue that I somehow cannot find right now, but if I remember correctly they explicitly said that cross-compilation on Windows for Linux only works with <code>x86_64-unknown-linux-musl</code>.</p>",
        "id": 233816438,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617973334
    },
    {
        "content": "<p>Ah, found it.<br>\n<a href=\"https://github.com/japaric/rust-cross/issues/33#issuecomment-348802985\">https://github.com/japaric/rust-cross/issues/33#issuecomment-348802985</a><br>\n<a href=\"https://github.com/japaric/rust-cross/issues/33#issuecomment-500111581\">https://github.com/japaric/rust-cross/issues/33#issuecomment-500111581</a></p>",
        "id": 233816812,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617973484
    },
    {
        "content": "<p>I think just setting <code>+crt-static</code> won't work. You need to <em>build</em> glibc or musl yourself. I think <code>musl</code> works now because libstd (or  the <code>libc</code> crate, I'm not sure) distributed by rustup bundles a prebuilt musl, but I assume that will no longer be the case if libc becomes dynamically-linked by default.</p>",
        "id": 233816907,
        "sender_full_name": "hyd-dev",
        "timestamp": 1617973534
    },
    {
        "content": "<p>The first comment says you need musl.</p>",
        "id": 233816916,
        "sender_full_name": "André Hänsel",
        "timestamp": 1617973536
    },
    {
        "content": "<blockquote>\n<p>I think musl works now because libstd distributed by rustup bundled a prebuilt musl, but I assume that's no longer the case if the target becomes dynamically-linked by default.</p>\n</blockquote>\n<p>I mean, that doesn't necessarily have to change. I don't think removing it gets us anything other than maybe a little internal cleanup</p>",
        "id": 233817237,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617973679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/233814832\">said</a>:</p>\n<blockquote>\n<p>yeah I definitely think we should have a blog post or something explaining exactly how to get the old behavior</p>\n</blockquote>\n<p>This is very much the plan! The MCP just got posted to /r/rust before we had gotten that far.</p>",
        "id": 233822159,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1617975571
    },
    {
        "content": "<p>I think you need something like -Cself-contained=yes or something, I forget the name</p>",
        "id": 233822626,
        "sender_full_name": "simulacrum",
        "timestamp": 1617975755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> mentioned on the MCP:</p>\n<blockquote>\n<p>The correct combination of flags to preserve the old behavior is<br>\n<code>-C target-feature=+crt-static -C link-self-contained=yes</code><br>\nbecause the old musl targets not only link libc statically by default, they also link libc and crt objects shipped with rustc by default, which is also undesirable and should be avoided in the new target config.</p>\n</blockquote>",
        "id": 233823016,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1617975912
    },
    {
        "content": "<p>Is there a reason to not tie this change to the 2021 edition? That would greatly reduce the backwards incompatibility issues...</p>",
        "id": 233843390,
        "sender_full_name": "Greg",
        "timestamp": 1617982234
    },
    {
        "content": "<p>editions are per crate, this is a property of the final binary</p>",
        "id": 233843823,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617982385
    },
    {
        "content": "<p>also, this is a bugfix, and I don't think bugfixes should be tied to an edition</p>",
        "id": 233843909,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617982409
    },
    {
        "content": "<p>The final binary (or other artifact)... is a crate though? Just take the behavior from the edition of the final binary/artifact (which is the typical place things like target settings are read from...).</p>\n<p>This changes the behavior of programs that work perfectly well, so that they don't work anymore. That's not just a bugfix.</p>",
        "id": 233844351,
        "sender_full_name": "Greg",
        "timestamp": 1617982550
    },
    {
        "content": "<p>Static vs dynamic linking produces different codegen across the crate graph.</p>",
        "id": 233846786,
        "sender_full_name": "nagisa",
        "timestamp": 1617983509
    },
    {
        "content": "<p>Yes, I'm not questioning that, so does setting <code>[profile.dev] opt-level=2</code>. Inheriting codegen flags of all kinds from the final crate seems to be normal, I'm not grasping why this is a problem for codegen settings that derive from editions?</p>",
        "id": 233847221,
        "sender_full_name": "Greg",
        "timestamp": 1617983671
    },
    {
        "content": "<p>Worth it to remove cargo from the equation entirely as it doesn't really interact with editions in this context. Once that's done, how does rustc invocation to compile a dependency know that the final artifact will use edition2021 definition of the musl target? What if the user produces two final artifacts with different editions?</p>",
        "id": 233848012,
        "sender_full_name": "nagisa",
        "timestamp": 1617983987
    },
    {
        "content": "<p>There could be some sort of a solution here but thatd require a fair amount of design effort I feel</p>",
        "id": 233848398,
        "sender_full_name": "nagisa",
        "timestamp": 1617984108
    },
    {
        "content": "<p>To extend the edition mechanism in rustc that is</p>",
        "id": 233848523,
        "sender_full_name": "nagisa",
        "timestamp": 1617984140
    },
    {
        "content": "<p><code>rustc --help</code> indicates that I can only specify one edition per invocation of rustc - so I assume you're referring to a sitution where I have another build system, I build a dependency with some fixed code gen settings, and then I try to link to it from two binaries, one with edition 2018 and one with edition 2021?</p>\n<p>Or to put it another way, to link to 2018 musl crates from 2021 musl crates you'd have to pass in to one of them the flags to say \"and use the other editions defaults for how to link to musl\". Cargo could do that automatically, but rustc can't because it doesn't know the dependency graph at the time of compiling.</p>\n<p>Ok - makes sense that that would at least be mildly problematic...</p>",
        "id": 233849273,
        "sender_full_name": "Greg",
        "timestamp": 1617984447
    },
    {
        "content": "<p>Has it been considered to make new targets instead of a breaking change to the existing ones?</p>",
        "id": 233854476,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1617986506
    },
    {
        "content": "<p>yes, that was the original proposal</p>",
        "id": 233854584,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617986532
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/82556\">https://github.com/rust-lang/rust/pull/82556</a></p>",
        "id": 233854603,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617986539
    },
    {
        "content": "<p>I agree that it would be nice to have a <code>--static</code> shorthand for people who want a static build like before.  Would there be any interest in adding that to cargo?  I can work on it.</p>",
        "id": 233883116,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1617998800
    },
    {
        "content": "<p>by all means, we <em>do not</em> want to negatively impact rust users who depend on the specific use case that was enabled by the <code>-musl</code> targets.  we just want to not have to fight those targets anymore :)</p>",
        "id": 233883215,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1617998846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/233817237\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think musl works now because libstd distributed by rustup bundled a prebuilt musl, but I assume that's no longer the case if the target becomes dynamically-linked by default.</p>\n</blockquote>\n<p>I mean, that doesn't necessarily have to change. I don't think removing it gets us anything other than maybe a little internal cleanup</p>\n</blockquote>\n<p>it seems to me, the only thing that would change is that rust ships a <code>libc.a</code> alongside the <code>libc</code> crate.  that does not seem like it is that difficult to do.</p>",
        "id": 233883615,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1617999024
    },
    {
        "content": "<p>anyway, i ask for everyone to be patient.  we are trying to solve a situation that came about due to lack of early communication.  there is no desire to break anybody's particular use case and i think everyone is dedicated to that</p>",
        "id": 233883900,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1617999168
    },
    {
        "content": "<p>i do however promise you that we're not coming for your static musl binaries.  we want people to keep doing that if they want to.  making sure that still works is <em>definitely</em> part of the goal here.</p>",
        "id": 233885213,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1617999907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360752\">Ariadne Conill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/233883116\">said</a>:</p>\n<blockquote>\n<p>I agree that it would be nice to have a <code>--static</code> shorthand for people who want a static build like before.  Would there be any interest in adding that to cargo?  I can work on it.</p>\n</blockquote>\n<p>If this can be added for the same release as the target behavior changes, I think it would be ideal. Write a nice blog post about it and include it in the release notes, and everyone updating their rust toolchains in CI/CD can just add the flag :)</p>",
        "id": 233885421,
        "sender_full_name": "Érico Nogueira Rolim",
        "timestamp": 1617999992
    },
    {
        "content": "<p>yep</p>",
        "id": 233885455,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618000007
    },
    {
        "content": "<p>I'm not personally concerned about the breaking change (though I'm not convinced this would qualify as a bugfix). However, I think that any change should try to avoid additional friction when creating static binaries. <code>--target x86_64-unknown-linux-musl -C target-feature=+crt-static -C link-self-contained=yes</code> is obviously pretty bad in comparison. An <code>x86_64-unknown-linux-musl_static</code> target is one option. Another option could be the <code>--static</code> flag proposed above, though I think some more deliberation is necessary on how that should work. One idea I had was to make <code>--static</code> equivalent to today's <code>--target x86_64-unknown-linux-musl</code> on all x64 Linux hosts, but to make <code>--target x86_64-unknown-linux-gnu --static</code> statically link glibc (which wouldn't necessarily be supported, it could just be an error).</p>",
        "id": 233896573,
        "sender_full_name": "leo60228",
        "timestamp": 1618004484
    },
    {
        "content": "<p>This seems unrelated, though. Overall I think that changing <code>x86_64-unknown-linux-musl</code> is good, but should definitely be combined with work towards making static linking easier. Another idea is to have <code>--static</code> tie into Cargo to let crates do things like replace <code>openssl</code> with <code>rustls</code> and vendor C dependencies?</p>",
        "id": 233897342,
        "sender_full_name": "leo60228",
        "timestamp": 1618004941
    },
    {
        "content": "<p>well rust previous behavior with the -musl target could be considered bad too depending on how you look at it</p>",
        "id": 233898431,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005541
    },
    {
        "content": "<p>i call it a bug :)</p>",
        "id": 233898459,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005558
    },
    {
        "content": "<p>i also think <code>--static</code> should not imply a musl target by default</p>",
        "id": 233898636,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005624
    },
    {
        "content": "<p>that would be inappropriate and we may consider that problematic in the musl community :)</p>",
        "id": 233898679,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239001\">leo60228</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/233897342\">said</a>:</p>\n<blockquote>\n<p>This seems unrelated, though. Overall I think that changing <code>x86_64-unknown-linux-musl</code> is good, but should definitely be combined with work towards making static linking easier. Another idea is to have <code>--static</code> tie into Cargo to let crates do things like replace <code>openssl</code> with <code>rustls</code> and vendor C dependencies?</p>\n</blockquote>\n<p>I like the idea that crates can see if they're being compiled with <code>--static</code></p>",
        "id": 233898720,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618005670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239001\">leo60228</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/233897342\">said</a>:</p>\n<blockquote>\n<p>This seems unrelated, though. Overall I think that changing <code>x86_64-unknown-linux-musl</code> is good, but should definitely be combined with work towards making static linking easier. Another idea is to have <code>--static</code> tie into Cargo to let crates do things like replace <code>openssl</code> with <code>rustls</code> and vendor C dependencies?</p>\n</blockquote>\n<p>I think this is a very different decision, and should probably still depend on feature flags. <code>rustls</code> doesn't even work on powerpc, for example.</p>",
        "id": 233898729,
        "sender_full_name": "Érico Nogueira Rolim",
        "timestamp": 1618005682
    },
    {
        "content": "<p>to be clear to the musl community, the use of the -musl targets in rust presently is inappropriate, in the same way that distributing a modified firefox would be seen as mozilla as inappropriate</p>",
        "id": 233898901,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005781
    },
    {
        "content": "<p>(we have discussed this at length already and the devs understand our position, i just mention it again for end users who are new.)</p>",
        "id": 233898984,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005822
    },
    {
        "content": "<p>specifically, the promotion of the concept that musl is explicitly for static linking by the rust community has done harm to musl.  rich already elaborated on that in the original PR though :)</p>",
        "id": 233899219,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618005943
    },
    {
        "content": "<p>I understand the issues with musl implying static, though I'm not sure I see the issue with static defaulting to musl. In my experience, musl conventional for statically linked binaries on Linux, not just for Rust code.</p>",
        "id": 233900257,
        "sender_full_name": "leo60228",
        "timestamp": 1618006617
    },
    {
        "content": "<p>which means that you are a victim of the misrepresentation of musl as a project</p>",
        "id": 233900540,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618006811
    },
    {
        "content": "<p>the largest consumer of musl is alpine, the second largest is openwrt, the third largest is void</p>",
        "id": 233900571,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618006833
    },
    {
        "content": "<p>all of which are dynamically linked distributions</p>",
        "id": 233900583,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618006846
    },
    {
        "content": "<p>yes, musl is much better at static linking than glibc, and that’s something the musl community is quite happy to evangelize, but in general musl should be regarded in the same way as glibc.  the default and preferred linking mode is dynamic.</p>",
        "id": 233900797,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618007022
    },
    {
        "content": "<p>if you download a prebuilt musl cross compilation toolchain from <a href=\"http://musl.cc\">musl.cc</a>, it does not generate static binaries by default, even when cross compiling.  this is why we view the difference in rustc behavior to be inappropriate.</p>",
        "id": 233900912,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618007099
    },
    {
        "content": "<p>and of course had the rust team discussed with us prior to implementing the musl port in the first place, this entire situation could have been avoided.  instead, the musl community has to basically retcon in an entirely different set of targets to replace the ones rust ships.  that’s not good for the musl community or rust, and it doesn’t make the musl community want to evangelize rust, even though many other interests are aligned</p>",
        "id": 233901097,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618007214
    },
    {
        "content": "<p>this is an admittedly disruptive change but a change i hope will be fruitful, by making it easier for the musl community to support rust users, there will be more evangelism of rust in the musl community.  more adoption is good for everyone.</p>",
        "id": 233901247,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618007314
    },
    {
        "content": "<p>And for the record, people <em>can</em> want to statically link glibc, for whatever reason. <code>ld</code> spits out warnings if you use features which don't work well with static linking (so DNS, dealing with users/groups, and iconv), but if you don't make use of them, things will mostly work</p>",
        "id": 233901371,
        "sender_full_name": "Érico Nogueira Rolim",
        "timestamp": 1618007419
    },
    {
        "content": "<p>For some reason I was under the impression that glibc was licensed under the GPL with an exception for static linking. I'm not sure where I got that idea from. <code>--static</code> on <code>x86_64-unknown-linux-gnu</code> without a <code>--target</code> flag defaulting to statically-linked glibc makes sense then, I think.</p>",
        "id": 233904835,
        "sender_full_name": "leo60228",
        "timestamp": 1618009876
    },
    {
        "content": "<p><code>--static</code> defaulting to musl was more that I'd like to be able to produce a working static binary with a single flag (today <code>--target=x86_64-unknown-linux-musl</code>, possibly <code>--static</code> in the future). I'm fine with other solutions that provide that too.</p>",
        "id": 233904935,
        "sender_full_name": "leo60228",
        "timestamp": 1618009937
    },
    {
        "content": "<p><code>--target=x86_64-unknown-linux-musl</code> does not semantically mean \"give me a static binary\" though.  that meaning is the result of harmful misrepresentation of the musl project by evangelists with good intentions.  the road to hell is paved with good intentions, as they say.</p>",
        "id": 233905017,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618010005
    },
    {
        "content": "<p>I'm not disagreeing with that. My point is solely from a usability perspective. Today, the single flag <code>--target=x86_64-unknown-linux-musl</code> will produce a useful static binary. After any musl-related changes, I'd like there to still be a single flag that does so, though I'm less concerned about what that flag is or the implementation of it.</p>",
        "id": 233905878,
        "sender_full_name": "leo60228",
        "timestamp": 1618010665
    },
    {
        "content": "<p>My understanding is that the proposal here is to improve the experience for people using musl-based systems, which I support. I was considering ways to avoid worsening the experience for building static Linux binaries.<br>\nI think the analogy between <code>--static</code> and <code>--target=x86_64-unknown-linux-musl</code> was misleading on my part. I was just trying to clarify that I think it's important that with a theoretical <code>--static</code> flag then <code>cargo build --static</code> would \"just work,\" without any need for something like <code>cargo build --target=x86_64-unknown-linux-musl --static</code> (which might otherwise be necessary if, for example, <code>x86_64-unknown-linux-gnu</code> didn't support dynamic linking).</p>",
        "id": 233906231,
        "sender_full_name": "leo60228",
        "timestamp": 1618010965
    },
    {
        "content": "<p>well, no, <code>--static</code> should give you a static binary, even if your static binary uses parts of glibc that is broken with static linking.  if you want musl, you should ask for musl with <code>--target</code>.  tools should not try to outsmart their operators, that turns them into a useful foot gun.</p>",
        "id": 233913847,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618017667
    },
    {
        "content": "<p>it is a feature that your tool does exactly what you specify, nothing more or less.</p>",
        "id": 233913958,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618017742
    },
    {
        "content": "<p>there is also the problem of C dependencies, if you compile dependencies with your glibc toolchain, and then staticly link them into a musl binary, bad things are likely to happen.</p>",
        "id": 233913995,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618017816
    },
    {
        "content": "<p>which is a problem already</p>",
        "id": 233914007,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618017837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360752\">Ariadne Conill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/233914007\">said</a>:</p>\n<blockquote>\n<p>which is a problem already</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/issues/82912\">https://github.com/rust-lang/rust/issues/82912</a> for reference</p>",
        "id": 233924574,
        "sender_full_name": "Érico Nogueira Rolim",
        "timestamp": 1618028566
    },
    {
        "content": "<p>if you ask for --static and the target can't provide it, cargo should just <em>say that</em> and suggest an alternateive.</p>",
        "id": 233926906,
        "sender_full_name": "Lokathor",
        "timestamp": 1618031289
    },
    {
        "content": "<p>sure, that would be reasonable</p>",
        "id": 233927230,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618031694
    },
    {
        "content": "<p>With my cargo team hat on, I would love to see a --static option, as well as a corresponding .cargo/config.toml option (in a target's section).</p>",
        "id": 234109417,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618209010
    },
    {
        "content": "<p>Short-term it should just affect the options used to build.</p>",
        "id": 234109457,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618209055
    },
    {
        "content": "<p>Long-term (not in the initial version) I would love to expose that to crates so they know to link external libraries statically vs dynamically.</p>",
        "id": 234109483,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618209087
    },
    {
        "content": "<p>yep that is what i had in mind <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> :)</p>",
        "id": 234110504,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618209799
    },
    {
        "content": "<p>I've read over some of the discussion here and on the issue (although not super closely), but I figured it might be worth adding my thoughts here. My main reaction is that this change is going to likely cause a lot of breakage that's very hard to detect up-front throughout the ecosystem. Since added I (and I think many others?) have equated the Rust target with a statically linked binary to run on Linux. I saw that the migration plan involves lints but almost all of the musl build processes I've created are in CI and I don't really watch them daily so at least for me personally once this change is made I'll probably have a long tail of projects where whenever they receive a PR with failing CI I'll need to go fix them. I don't personally have an opinion on whether this change is worth the breakage or not.</p>\n<p>I do, however, think that this is indicative of a larger problem that may be worth solving (not blocking this change per se, just a problem to have on the radar). Currently AFAIK there's a lot of reported pain trying to compile projects dynamically linked against musl, whereas compiling statically is much easier. I am also under the impression that the pain is \"you need to pass RUSTFLAGS to Cargo\". In that sense by switching the defaults it seems like it's just penalizing a different group of users. All the pain previously felt by those wishing to link dynamically will now be felt by those linking statically. I won't really pretend to think I have an answer to this, but I figured it'd be worth pointing out.</p>\n<p>The last thing that I'd add is that I haven't seen anywhere the expected scale of what the breakage is going to look like. Or rather what the expected scale of \"folks who need to update their build processes to pass new flags\". That I realize would be very hard to measure, but would also be a very valuable data point in considering a change like this. For example making a change like this probably looks quite different if it affects 90% of Rust users vs 1%.</p>",
        "id": 234208715,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1618252569
    },
    {
        "content": "<p>I definitely support the idea of a <code>--static</code> flag that's analogous to the current musl target (regardless of whether this also requires a target specification to achieve the current behavior)-- we don't use any musl dynamic targets, but we do build fully static binaries using the current musl target.  I also advocate the relative ease of creating fully static binaries as one of the benefits of Rust.</p>",
        "id": 234217584,
        "sender_full_name": "Jason Mobarak",
        "timestamp": 1618256325
    },
    {
        "content": "<p>Sigh, static linking is not the (whole) point of the current musl behavior.<br>\nThe point is \"self-containedness\" - you only install Rust, no extra toolchains, and you are immediately able to produce static executables (which are also self-contained).<br>\nThis approach requires shipping libc binaries together with Rust toolchain, so if this is something you are going to do it with the proposed \"<code>--static</code> flag\", then 1) the flag will be a misnomer (statically linking with non-bundled toolchain makes very much sense too, but doesn't satisfy the self-containedness property), 2) the flag will pretty much work for musl only because you cannot bundle, for example, glibc for licensing reasons, IIRC, 3) libc bundling received many complaints in the past about libc not being properly updated (which led to <a href=\"https://github.com/rust-lang/rust/issues/72274\">#72274</a>).</p>",
        "id": 234221566,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1618257879
    },
    {
        "content": "<p>If I read the github issue correctly, it looks like under this proposed change, the behavior of compiling with <code>--target x86_64-unknown-linux-musl</code> will be essentially:</p>\n<div class=\"codehilite\"><pre><span></span><code>env RUSTFLAGS=&quot;-C target-feature=-crt-static&quot; cargo build --target x86_64-unknown-linux-musl\n</code></pre></div>\n\n<p>Is that right?</p>",
        "id": 234228801,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1618260977
    },
    {
        "content": "<p>If so, then for at least some cases (like for me), the breakage will be immediate, as compiling with <code>-C target-feature=-crt-static</code> results in an immediate build error.   If this will be true for most people, then it seems like this change might cause wide-spread annoyance, but it's not likely to cause any hard to detect \"hidden effects\" (for example, a build that is successful, but fails at runtime in some non-obvious way)</p>",
        "id": 234230651,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1618261482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116015\">Alex Crichton</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/234208715\">said</a>:</p>\n<blockquote>\n<p>I've read over some of the discussion here and on the issue (although not super closely), but I figured it might be worth adding my thoughts here. My main reaction is that this change is going to likely cause a lot of breakage that's very hard to detect up-front throughout the ecosystem. Since added I (and I think many others?) have equated the Rust target with a statically linked binary to run on Linux. I saw that the migration plan involves lints but almost all of the musl build processes I've created are in CI and I don't really watch them daily so at least for me personally once this change is made I'll probably have a long tail of projects where whenever they receive a PR with failing CI I'll need to go fix them. I don't personally have an opinion on whether this change is worth the breakage or not.</p>\n<p>I do, however, think that this is indicative of a larger problem that may be worth solving (not blocking this change per se, just a problem to have on the radar). Currently AFAIK there's a lot of reported pain trying to compile projects dynamically linked against musl, whereas compiling statically is much easier. I am also under the impression that the pain is \"you need to pass RUSTFLAGS to Cargo\". In that sense by switching the defaults it seems like it's just penalizing a different group of users. All the pain previously felt by those wishing to link dynamically will now be felt by those linking statically. I won't really pretend to think I have an answer to this, but I figured it'd be worth pointing out.</p>\n<p>The last thing that I'd add is that I haven't seen anywhere the expected scale of what the breakage is going to look like. Or rather what the expected scale of \"folks who need to update their build processes to pass new flags\". That I realize would be very hard to measure, but would also be a very valuable data point in considering a change like this. For example making a change like this probably looks quite different if it affects 90% of Rust users vs 1%.</p>\n</blockquote>\n<p>Mostly agree, but at the same time, what rust is implying with the <code>-musl</code> targets is harmful to the musl community.  I think having a self-contained executable feature is awesome, and have nothing against that, but the association that musl == self-contained executables is fundamentally harmful to musl, to the point that we are now discussing the possibility of formulating a policy document to ensure this never happens again.  It makes sense that musl be used as a basis for this feature, but this feature should not be called \"musl\" if that makes sense.</p>",
        "id": 234250303,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618273486
    },
    {
        "content": "<p>i would like to arrive at a scenario where the <code>-musl</code> targets do not violate musl policies, and the ability to easily make self-contained executables is retained.</p>",
        "id": 234251047,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618274087
    },
    {
        "content": "<p>perhaps introducing a new set of targets explicitly for the self-contained executables feature, calling them something like <code>-sce</code>, which does all of the things needed to have musl as a self-contained executable could work for that and allow us to have <code>-musl</code> targets creating conformant binaries for musl-platform hosts</p>",
        "id": 234251187,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618274180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/234221566\">said</a>:</p>\n<blockquote>\n<p>Sigh, static linking is not the (whole) point of the current musl behavior.<br>\nThe point is \"self-containedness\" - you only install Rust, no extra toolchains, and you are immediately able to produce static executables (which are also self-contained).<br>\nThis approach requires shipping libc binaries together with Rust toolchain, so if this is something you are going to do it with the proposed \"<code>--static</code> flag\", then 1) the flag will be a misnomer (statically linking with non-bundled toolchain makes very much sense too, but doesn't satisfy the self-containedness property), 2) the flag will pretty much work for musl only because you cannot bundle, for example, glibc for licensing reasons, IIRC, 3) libc bundling received many complaints in the past about libc not being properly updated (which led to <a href=\"https://github.com/rust-lang/rust/issues/72274\">#72274</a>).</p>\n</blockquote>\n<p>So maybe <code>cargo --target  x86_64-unknown-linux-musl --self-contained</code>? Where <code>--self-contained</code> could imply <code>--static</code> (which IMO still makes sense  as a separate flag - there are cases where static linking works just fine). Then using just <code>--static</code> will use <code>libc.a</code> from the linker's library search path instead of the bundled one.</p>",
        "id": 234253454,
        "sender_full_name": "Érico Nogueira Rolim",
        "timestamp": 1618275975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360752\">@Ariadne Conill</span> to clarify, I'm specifically not passing personal judgement on whether I agree with this change or not. My point is that irrespective of its correctness Rust has stability guarantees and I think that they're important to consider. Rust has had breaking changes in the past fixing bugs, but even small bugs which have the possibility of breaking many users are carefully scrutinized to figure out the best roll-out plan. The \"have our cake\" part here seems to be to switch the targets to align with other targets and the musl community, but the \"eat it too\" part will come from rolling this out in a way that doesn't abruptly cause the Rust community to lose faith in the compiler's stability guarantees or the compiler's musl target.</p>\n<p>I realize, though, that I'm literally the one to blame for this quandry. I added the musl targets originally to Rust and advocated for their inclusion. There's not much I can do about that now, though, so I wanted to at least offer my thoughts on the stability/breakage aspect.</p>",
        "id": 234254711,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1618277046
    },
    {
        "content": "<p>Worth noting that targets/compiler APIs never really had a stability coverage as thorough as libs or language interfaces. This has a potential to be a change affecting most users so far compared to other breaking target changes we've done in the past, though.</p>",
        "id": 234295783,
        "sender_full_name": "nagisa",
        "timestamp": 1618306732
    },
    {
        "content": "<p>i like the -sce plan because it's a plan that could also be rolled out for windows and mac builds too.</p>",
        "id": 234325024,
        "sender_full_name": "Lokathor",
        "timestamp": 1618320745
    },
    {
        "content": "<p>I don't see why we couldn't do whatever musl would do (most likely a separate component of some sort?), but distributing proprietary binaries is unlikely to be something we'd be able to do in general, I don't think.</p>",
        "id": 234333700,
        "sender_full_name": "nagisa",
        "timestamp": 1618323667
    },
    {
        "content": "<p>I am not aware of any proprietary code that would need to be distributed for a windows SCE.</p>",
        "id": 234335186,
        "sender_full_name": "Lokathor",
        "timestamp": 1618324159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> my attitude is that whatever lint is issued here, it needs to be given the same treatment as “future incompatibility lints”, which are meant to get somewhat more visiblility in the build output (in terms of being summarized at the end of even a successful build).</p>",
        "id": 234381781,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618340350
    },
    {
        "content": "<p>its true that maybe people won’t even notice that. But at some point then the line is going to be “do you break the build, or do you not break the build.\"</p>",
        "id": 234381842,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618340379
    },
    {
        "content": "<p>I want us to at least consider being willing to break the build. The project is still relatively young, we should be brave enough to fix mistakes like this.</p>",
        "id": 234382018,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618340435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> makes sense about the lints yeah. Also though I'm neither advocating for or against this change, and I agree that breakage is fine to happen in the general sense (Rust/Cargo have historically had many instances of breakage in the past). I also agree that it's ok for Rust to change these targets.</p>\n<p>My points are about assessing the expected scale of breakage (this seems unlikely to be feasible and/or possible) and also about how if many folks complained about passing the <code>-Ctarget-feature=-crt-static</code> flag then there's likely also going to be many folks complaining about passing the <code>-Ctarget-feature=+crt-static</code> flag (plus the <code>-Clink-self-contained=yes</code> flag)</p>",
        "id": 234395594,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1618345934
    },
    {
        "content": "<p>It does seem hard to assess the scale of breakage if the diagnostic gets overlooked by our users, for whatever reason.</p>",
        "id": 234401054,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618347908
    },
    {
        "content": "<p>Also, it is sounding like people are pushing for a new <code>-Clink-self-contained=yes</code> flag. I don’t mind adding that, but it does change the trade-offs here slightly, in that, under my former understanding, we were going to be able to silence the lint here by using a flag that the compiler <em>already supports</em>.</p>",
        "id": 234401658,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618348046
    },
    {
        "content": "<p>But if this <code>-Clink-self-contained=yes</code> flag is going to be the official way to achieve the desired goal here, then that’s a new flag...</p>",
        "id": 234401774,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618348077
    },
    {
        "content": "<p>this is a <em>very weak</em> measure, but here is a <a href=\"https://github.com/search?q=x86_64-unknown-linux-musl+extension%3Ayml+extension%3Ayaml+path%3A%2F.github%2F&amp;type=Code&amp;ref=advsearch&amp;l=&amp;l=\">search of github</a> that I think shows how many github CI workflows build with the <code>x86_64-unknown-linux-musl</code>.  These results don't show how many are already using RUSTFLAGS to set the necessary target-feature.  But if we assume that most of these don't, then there's probably going to be about 1000 different projects that will probably have broken CI builds if they did nothing</p>\n<p>(here's a <a href=\"https://github.com/search?l=&amp;q=x86_64-unknown-linux-musl++filename%3A.travis.yml&amp;type=code\">similar search</a> for travis CI)</p>",
        "id": 234402291,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1618348191
    },
    {
        "content": "<p>That flag... already exists I think?</p>",
        "id": 234416540,
        "sender_full_name": "simulacrum",
        "timestamp": 1618355857
    },
    {
        "content": "<p>well it certainly does <em>something</em></p>",
        "id": 234416662,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618355920
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ rustc -Clink-self-contained=yes main.rs\n$ ./main\nSegmentation fault (core dumped)\n</code></pre></div>",
        "id": 234416672,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618355929
    },
    {
        "content": "<p>(this is a x86_64-unknown-linux-gnu host)</p>",
        "id": 234416692,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618355947
    },
    {
        "content": "<p>that's likely because the wrong crtN.o blob is used :P</p>",
        "id": 234417308,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618356324
    },
    {
        "content": "<p>what does that mean?</p>",
        "id": 234417550,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618356459
    },
    {
        "content": "<p>It is (also) dynamically linked, still.</p>",
        "id": 234417612,
        "sender_full_name": "nagisa",
        "timestamp": 1618356493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/234417612\">said</a>:</p>\n<blockquote>\n<p>It is (also) dynamically linked, still.</p>\n</blockquote>\n<p><code>rustc -Ctarget-feature=+crt-static -Clink-self-contained=yes main.rs</code> also segfaults</p>",
        "id": 234417676,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618356543
    },
    {
        "content": "<p>anyway it's not really important for gnu targets</p>",
        "id": 234417935,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1618356705
    },
    {
        "content": "<p>our crt object logic is documented here <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/crt_objects/index.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/crt_objects/index.html</a></p>",
        "id": 234418406,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1618356945
    },
    {
        "content": "<p>basically if you wind up with two instances of libc in a single binary, it will violently explode.</p>",
        "id": 234435033,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1618370178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/234401774\">said</a>:</p>\n<blockquote>\n<p>But if this <code>-Clink-self-contained=yes</code> flag is going to be the official way to achieve the desired goal here, then that’s a new flag...</p>\n</blockquote>\n<p>I'm not sure if a relevant <code>cargo</code> flag is implied here, but I think making the behavior depend on long verbose <code>RUSTFLAGS</code> setting is not really ideal; having a fully supported <code>cargo --sce</code> or similar (which removes the need, for now, for a <code>--static</code>, if we want to discuss that into the future) makes for a much better user experience, <em>and</em> avoids using the same flags for the build tools (<code>proc_macros</code> and whatever other friends)/.</p>",
        "id": 234491315,
        "sender_full_name": "Érico Nogueira Rolim",
        "timestamp": 1618404209
    },
    {
        "content": "<p>I was only speaking from the perspective of the interface into <code>rustc</code> up above, not the whole end-to-end experience of someone using <code>cargo</code>. I agree that we can provide a better user-experience there.</p>",
        "id": 234504855,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618409378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/234416540\">said</a>:</p>\n<blockquote>\n<p>That flag... already exists I think?</p>\n</blockquote>\n<p>hmm, okay, my mistake. (Though I guess it sounds like we might have to change its current behavior, if I understand the rest of the conversation correctly.)</p>",
        "id": 234505020,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618409430
    },
    {
        "content": "<p>I have a suggestion that may be silly or may be not - report all the warnings discussed above in cargo instead of rustc.</p>\n<p>Cargo detects situations similar to a \"typical CI setup\" linked above (<a href=\"https://github.com/search?q=x86_64-unknown-linux-musl+extension%3Ayml+extension%3Ayaml+path%3A%2F.github%2F&amp;type=Code&amp;ref=advsearch&amp;l=&amp;l=\">https://github.com/search?q=x86_64-unknown-linux-musl+extension%3Ayml+extension%3Ayaml+path%3A%2F.github%2F&amp;type=Code&amp;ref=advsearch&amp;l=&amp;l=</a>), and adds <code>-Ctarget-feature=+crt-static -Clink-self-contained=yes</code> to the compiler flags automatically with a warning and suggestion to add the flags manually.</p>",
        "id": 234979018,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1618655827
    },
    {
        "content": "<p>In this case the tool providing the suggestion will be the same tool that is to blame if the suggestion doesn't work (due to cargo's target vs host flags issues).</p>",
        "id": 234979133,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1618655973
    },
    {
        "content": "<p>hi, i am just checking in to see what the next steps are with this</p>",
        "id": 236388198,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1619548856
    },
    {
        "content": "<p>I recently made a related change: the next version of libz-sys will stop assuming that musl means static linking, and will allow dynamically linking zlib on a musl target if available.</p>",
        "id": 236389497,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619549432
    },
    {
        "content": "<p>So if you're using musl and libz-sys, and want to statically link, you'll have to specify the <code>static</code> feature flag to libz-sys.</p>",
        "id": 236389543,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619549450
    },
    {
        "content": "<p>(Long-term, I think cargo needs a general \"I want to statically link\" indication that can be passed down to library crates.)</p>",
        "id": 236389580,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619549469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360752\">Ariadne Conill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/236388198\">said</a>:</p>\n<blockquote>\n<p>hi, i am just checking in to see what the next steps are with this</p>\n</blockquote>\n<p>So the MCP itself has been seconded. I don’t think any concerns have been raised that would lead to us to abandon the proposal. I do think the proper next steps are to update the proposal itself with some additional info to help address the concerns that have been raised.</p>",
        "id": 236437969,
        "sender_full_name": "pnkfelix",
        "timestamp": 1619575062
    },
    {
        "content": "<p>The change will also obviously not happen without an implementation - 1) switching defaults in target specs, trivial + 2) compatibility layer / warnings preferably in cargo, shouldn't be hard either.</p>\n<p>I'd expect one of the musl people pushing for the change to step in and implement this, otherwise it's unlikely to be done any time soon.</p>",
        "id": 236488820,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1619608671
    },
    {
        "content": "<p>I think I should be able to mentor the development effort, though</p>",
        "id": 236528823,
        "sender_full_name": "pnkfelix",
        "timestamp": 1619624000
    },
    {
        "content": "<p>that is, I agree with <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> that the bulk of the work should probably come from a stakeholder, but that stakeholder shouldn’t have to fear that they’d be working in a vacuum.</p>",
        "id": 236529001,
        "sender_full_name": "pnkfelix",
        "timestamp": 1619624055
    },
    {
        "content": "<p>A thought just crossed my mind that we could reasonably have a transition period here. Specifically, when building for a musl target, if we're not given an option one way or the other regarding static linking, we could attempt to detect if we have a system version of musl available to link to, and if we don't find one, we could statically link but emit a warning explaining that in the future we will default to dynamic.</p>",
        "id": 236537011,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619626989
    },
    {
        "content": "<p>If you have a system version of musl that we can find, or if rustc itself is built for musl, we can skip that transition period and always assume you want to link dynamically unless you specifically request static linking.</p>",
        "id": 236537289,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619627099
    },
    {
        "content": "<p>I think that behavior would help people who are currently relying on the default of static linking to transition to needing to specify that.</p>",
        "id": 236537444,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619627162
    },
    {
        "content": "<p>Interesting. That's a step further than the diagnostic I was proposing</p>",
        "id": 236539365,
        "sender_full_name": "pnkfelix",
        "timestamp": 1619627905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360752\">@Ariadne Conill</span> For distributions that ship dynamically linked musl binaries, is the Rust toolchain built with musl as well?</p>",
        "id": 236551155,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619632658
    },
    {
        "content": "<p>(I'd assume so, unless you're cross-compiling from another system.)</p>",
        "id": 236551264,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619632694
    },
    {
        "content": "<p>yes</p>",
        "id": 236574689,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1619642519
    },
    {
        "content": "<p>i can do the work next week, probably.</p>",
        "id": 236574738,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1619642526
    },
    {
        "content": "<p>i just formally became chair of the new alpine security team, so i am trying to hit the ground running with that in the immediate moment, but should be able to circle back to this next week :)</p>",
        "id": 236574836,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1619642568
    },
    {
        "content": "<p>Congrats! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 236582974,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1619644984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360752\">Ariadne Conill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Update.20the.20existing.20musl.20targets.20to.20be.20dy.E2.80.A6.20compiler-team.23422/near/236574689\">said</a>:</p>\n<blockquote>\n<p>yes</p>\n</blockquote>\n<p>Given that, I think we'd get a <em>lot</em> of benefit out of a transition period that makes musl-based toolchains default to dynamic linking for musl targets right away, and makes non-musl-based toolchains make a best effort to look for a dynamic libmusl to link to (use it if found, static link and warn for a release or two otherwise).</p>",
        "id": 236593892,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619651204
    },
    {
        "content": "<p>That should allow for a fairly fast transition, and give plenty of warning to anyone who is currently assuming musl means static, without forcing any long-term issues after the transition.</p>",
        "id": 236593962,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619651255
    },
    {
        "content": "<p>yeah i thought we were all on the same page regarding that :)</p>",
        "id": 236601549,
        "sender_full_name": "Ariadne Conill",
        "timestamp": 1619656543
    },
    {
        "content": "<p>We'd talked about a transition period, but I hadn't seen any mentions of how we could make that transition smoother other than designating a cutover point and announcing it.</p>",
        "id": 236620065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619672891
    },
    {
        "content": "<p>We could potentially make it opt-in via some workspace Cargo.toml flag and make it dependent on the edition of the root. Bit awkward, but not necessarily that bad, and realistically pretty soon.</p>",
        "id": 236658027,
        "sender_full_name": "simulacrum",
        "timestamp": 1619696147
    },
    {
        "content": "<p>(we could also phase it in across all editions over time like NLL after that)</p>",
        "id": 236658087,
        "sender_full_name": "simulacrum",
        "timestamp": 1619696175
    },
    {
        "content": "<p>Hello all, according to the <a href=\"https://forge.rust-lang.org/compiler/mcp.html\">MCP procedure</a>, this proposal should be accepted and issue <a href=\"https://github.com/rust-lang/rust/issues/422\">#422</a>  closed. <br>\nSince the discussion went to some length, I'm asking if I can close it (as the implementation will run on another track)</p>",
        "id": 237697853,
        "sender_full_name": "apiraino",
        "timestamp": 1620322229
    },
    {
        "content": "<p>I'm going to close the MCP as per the procedure (proposal was accepted)</p>",
        "id": 239601468,
        "sender_full_name": "apiraino",
        "timestamp": 1621521093
    },
    {
        "content": "<p>This proposal has been accepted: <a href=\"https://github.com/rust-lang/compiler-team/issues/422\">#422</a>.</p>",
        "id": 239601481,
        "sender_full_name": "triagebot",
        "timestamp": 1621521098
    }
]