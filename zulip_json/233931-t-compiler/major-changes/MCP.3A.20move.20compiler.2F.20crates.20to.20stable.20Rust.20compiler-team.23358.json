[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/358\">MCP: move compiler/ crates to stable Rust #358</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 209910822,
        "sender_full_name": "triagebot",
        "timestamp": 1599965983
    },
    {
        "content": "<p>I'm not convinced that this is a good idea. The compiler is one of the places where new nightly features can be tested out, which can help expose issues or design flaws in features before they are stabilized</p>",
        "id": 209911250,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1599966969
    },
    {
        "content": "<p>Regarding a few of the points in the issue:</p>\n<blockquote>\n<p>Easier onboarding of outside contributors from the stable Rust ecosystem as they have to learn less new features/mannerisms.</p>\n</blockquote>\n<p>While this is true for larger features (const generic, specialization, etc), I don't think this applies to 'std only' features. For example, it's convenient to have <code>bool::then_some</code> available, and new contributors can easily learn what it does by reading the docs.</p>\n<blockquote>\n<p>Unstable features sometimes still have rough edges and soundness holes. You need to be aware of these issues when using them, making it harder for contributors.</p>\n</blockquote>\n<p>I think the solution here is to make sound versions of these features (e.g. <code>min_specialization</code>), not to give up on nightly features entirely. However, I definitely agree that we should avoid using unsound features in the compiler.</p>",
        "id": 209911299,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1599967141
    },
    {
        "content": "<p>If we can't even have rustc work with beta libstd + rustc_bootstrap (<a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd</a>), this seems even less plausible :/</p>",
        "id": 209911349,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599967253
    },
    {
        "content": "<blockquote>\n<p>From a high level point of view, rustc itself deals in data: text in, binary out. This process doesn't need nightly features from a technical perspective, yet the compiler uses many.</p>\n</blockquote>\n<p>I feel like this applies to almost any Rust program. For example, the Rocket web framework is 'just' text in, text out (HTTP request -&gt; HTTP response), but it required nightly until very recently. Many Rust programs probably don't need nightly features, but they can make things much more convenient.</p>",
        "id": 209911397,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1599967353
    },
    {
        "content": "<p>As a personal note: compiler contributions account for nearly all of my work in Rust, and I really like have nightly features available. It's always frustrating when I go to contribute to a library, and find that something I want to use is unstable.</p>",
        "id": 209911448,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1599967443
    },
    {
        "content": "<p>I would argue that dogfooding features in the compiler is also critical to the way we find important bugs.</p>",
        "id": 209911639,
        "sender_full_name": "mark-i-m",
        "timestamp": 1599967833
    },
    {
        "content": "<blockquote>\n<p>As rustc is crates.io-ified, outside users might want to use components of rustc. Often those outside users want to use stable themselves</p>\n</blockquote>\n<p>Presumably, the rustc API would still be unstable though, right? So is there any benefit of using stable rust anyway?</p>",
        "id": 209911707,
        "sender_full_name": "mark-i-m",
        "timestamp": 1599967992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/209911250\">said</a>:</p>\n<blockquote>\n<p>The compiler is one of the places where new nightly features can be tested out, which can help expose issues or design flaws in features before they are stabilized</p>\n</blockquote>\n<p>It's a fair point, but note that the Rust community has grown since the release, both stable and nightly communities, so since then there are far more eyes on potential nightly features, so the need for this has gone down. Furthermore, it's still possible to try out a nightly feature in a private branch.</p>\n<p>Regarding <code>bool::then_some</code>: each nightly feature was added to the language to make something more convenient. The convenience increase is often only minimal though. My point is that stable Rust has become convenient and easy enough for the compiler to use it.</p>\n<blockquote>\n<p>Many Rust programs probably don't need nightly features, but they can make things much more convenient.</p>\n</blockquote>\n<p>Those programs also don't use <code>RUSTC_BOOTSTRAP</code> and claim to work on stable compilers :). They also don't need  to do <code>cfg(bootstrap)</code> when a nightly feature stabilizes or changes.</p>",
        "id": 209911980,
        "sender_full_name": "est31",
        "timestamp": 1599968599
    },
    {
        "content": "<p>I can certainly see an argument that if the compiler were prohibited from using nightly features, it could \"strongly encourage\" the teams to actually stabilize nightly features in a timely manner.</p>",
        "id": 209913050,
        "sender_full_name": "Lokathor",
        "timestamp": 1599970973
    },
    {
        "content": "<p>I think there are two orthogonal reasons why this might be desirable:</p>\n<ul>\n<li>using standard rustup toolchain (nightly or beta)</li>\n<li>using stable language</li>\n</ul>\n<p>In my opinion, the fist is much more important than the second. Ie, the gain from „rustc builds on stable with RUST_BOOTSTRP“ is bigger than the additional gain of removing bootstrap.</p>\n<p>While rust-analyzer today builds on stable, I wouldn’t mind too much pining it to beta and requiring unlocking unstable features. I <em>would</em> mind requiring that it builds only with master std though.</p>",
        "id": 209919534,
        "sender_full_name": "matklad",
        "timestamp": 1599984182
    },
    {
        "content": "<p>Making rustc compile on stable would make bootstrapping from old versions like rustc 1.29.0 (latest bootstrapable with mrustc) faster, as you can skip every other version. For example 1.48.0 which is currently in nightly could be built using 1.46.0 which is the latest stable. 1.50.0 would could be built using 1.48.0  and so on.</p>",
        "id": 209919707,
        "sender_full_name": "bjorn3",
        "timestamp": 1599984452
    },
    {
        "content": "<p>Compiler is a major testing ground for new features.<br>\nDesign of the new language features is often developed (or at least fine-tuned) and stabilized by the same people who work on the compiler, so it's useful to get some actual working experience with them before deciding on stabilization.</p>",
        "id": 209921855,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1599988614
    },
    {
        "content": "<p>There are also features like <code>-Z binary-dep-depinfo</code> for which compiler bootstrapping is on of the primary intended use cases.</p>",
        "id": 209921872,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1599988676
    },
    {
        "content": "<p>I'm totally ok with using the standard beta release unlocked with <code>RUSTC_BOOTSTRAP</code> though.<br>\n(Aren't we already doing that?)</p>",
        "id": 209921965,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1599988805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> we are not doing exactly that for compiling rustc itself: we use beta rustc + master libstd. This last bit makes the build weird.</p>",
        "id": 209921998,
        "sender_full_name": "matklad",
        "timestamp": 1599988912
    },
    {
        "content": "<p>I fairly strongly feel that using nightly feature in the compiler is a net positive, but I do think that it would be nice if <code>cfg(bootstrap)</code> was not necessary and we were able to use the beta std when building stage 1.</p>\n<p>I do think that this might just move the need for <code>cfg(bootstrap)</code> from std into the compiler though, as I don't see how PRs which change both libs and the compiler at the same time (eg <a href=\"https://github.com/rust-lang/rust/issues/70705\">#70705</a>) would work otherwise, so I am not sure if that is a net improvement in the end.</p>",
        "id": 209922243,
        "sender_full_name": "lcnr",
        "timestamp": 1599989344
    },
    {
        "content": "<p>But why does that testing have to be committed into master? Wouldn't it be more helpful if instead of one person gaining experiences from porting the compiler to use a nightly feature, you have multiple people doing it in their own rustc github forks? Then they can compare their results instead of one port taking the opportunity away from everyone else.</p>\n<p>One could also think about becoming more explicit about testing requirements before stabilizing a new feature. As in: in order to get a feature stabilized, someone must share their reports about having used the feature in a codebase of theirs and reported back on their experiences. Not every feature is being tested in rustc and such a policy would add rigor to the system.</p>",
        "id": 209925672,
        "sender_full_name": "est31",
        "timestamp": 1599995236
    },
    {
        "content": "<p>Meta note: I feel like we have a pretty sprawling discussion about bootstrapping, so it might make sense to create some kind of collaborative document to list all options, requirements and tradeoffs. </p>\n<p>I might get to doing this today, but no promises, I am on vacation :P</p>",
        "id": 209925832,
        "sender_full_name": "matklad",
        "timestamp": 1599995442
    },
    {
        "content": "<p>In fact, due to experimental features being put into master, rustc now has a problem of using features that have low chances of being stabilized, but the usage in rustc makes it harder to remove the features altogether. Basically, the cleanup part of the experiments is missing.</p>",
        "id": 209925835,
        "sender_full_name": "est31",
        "timestamp": 1599995446
    },
    {
        "content": "<p>Out of tree experiments would give you that for free :)</p>",
        "id": 209925855,
        "sender_full_name": "est31",
        "timestamp": 1599995487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> I would love to collaborate on that, feel free to ping me :)</p>",
        "id": 209926316,
        "sender_full_name": "simulacrum",
        "timestamp": 1599996036
    },
    {
        "content": "<p>As I've said in other streams, I personally think in the long run this might be nice, but not now. We already can run rustbuild with stock beta. I don't really think we can afford to do dogfooding on experimental branches - I frequently gain knowledge and experience not just by transitioning a codebase to use some new feature but also by seeing multiple features interact and how easy they are to understand when reviewing code rather than writing it.</p>\n<p>I don't think the argument about it being harder to remove features just because rustc uses them is quite true - removing a feature that has no good replacement is unlikely <em>anyway</em> because one of our goals is not limiting people and forcing them to use other languages.</p>",
        "id": 209926534,
        "sender_full_name": "simulacrum",
        "timestamp": 1599996386
    },
    {
        "content": "<blockquote>\n<p>I do think that this might just move the need for cfg(bootstrap) from std into the compiler though, as I don't see how PRs which change both libs and the compiler at the same time (eg <a href=\"https://github.com/rust-lang/rust/issues/70705\">#70705</a>) would work otherwise, so I am not sure if that is a net improvement in the end.</p>\n</blockquote>\n<p>The things I see using the new discriminant types are the doc-tests, which would be run with --stage 1 anyway, and <a href=\"https://github.com/rust-lang/rust/pull/70705/files?file-filters%5B%5D=.rs&amp;file-filters%5B%5D=.stderr#diff-8fbc542a08b9274446b2fbf02bd610b2\">an assert in <code>rustc_middle</code></a>. Everything else is for <em>building</em> libstd with the feature, not using it in the compiler itself.</p>\n<p>How much of a burden do you think it would be to not use <code>DiscriminantKind</code> there, or to use <code>cfg(not(bootstrap))</code> for it?</p>",
        "id": 209928922,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600000238
    },
    {
        "content": "<p>DiscriminantKind in particular -- maybe not much. But it probably means that we cannot use unstable libs features in the compiler in general, and that seems really unfortunate.</p>",
        "id": 209929339,
        "sender_full_name": "simulacrum",
        "timestamp": 1600000838
    },
    {
        "content": "<blockquote>\n<p>we cannot use unstable libs features in the compiler in general</p>\n</blockquote>\n<p>We couldn't use unstable libs features <em>that had been added in the last 6 weeks</em></p>",
        "id": 209929412,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600000962
    },
    {
        "content": "<p>that seems like much less of a burden to me</p>",
        "id": 209929414,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600000972
    },
    {
        "content": "<p>no, you shouldn't use any, because if you use it after 6 weeks you end up with cfg(bootstrap) in the compiler when that feature changes, or have to revert that use.</p>",
        "id": 209929485,
        "sender_full_name": "simulacrum",
        "timestamp": 1600001097
    },
    {
        "content": "<p>(and in most cases it would be less than 6 weeks because it would get halfway through the release cycle)</p>",
        "id": 209929486,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600001098
    },
    {
        "content": "<p>I agree that if we, say, rename an unsatble API like <code>OnceCell</code>, this will break bootstrap (immediately). But this needs to happen only for features which <em>actually</em> change I think. The fix would be to either write the code in such a way which works with both new and old feature (which seems feasiblle for stdlib additions) or, indeed to use <code>#[cfg(bootstrap)]</code> (or just more general <code>autocfg</code>, to make sure that the crate is compatbile with a range of nightlies).</p>",
        "id": 209929747,
        "sender_full_name": "matklad",
        "timestamp": 1600001469
    },
    {
        "content": "<p>A completely alternative venue here is to finish \"make Cargo build custom std\" work (at least as an unsable feature). That way, <code>rustc</code> would still be a \"standard crate\", just the one which uses custom std.</p>",
        "id": 209929827,
        "sender_full_name": "matklad",
        "timestamp": 1600001581
    },
    {
        "content": "<p>I don't see what benefit that has over the current situation?</p>",
        "id": 209929860,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600001634
    },
    {
        "content": "<p>bootstrapping is still hard to understand and you still have to <code>build --stage 0 library/std</code> before building the compiler</p>",
        "id": 209929905,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600001654
    },
    {
        "content": "<p><code>cd compiler &amp;&amp; cargo test</code> works</p>",
        "id": 209929908,
        "sender_full_name": "matklad",
        "timestamp": 1600001666
    },
    {
        "content": "<p>that works currently actually</p>",
        "id": 209929919,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600001688
    },
    {
        "content": "<p>o_O how?</p>",
        "id": 209929923,
        "sender_full_name": "matklad",
        "timestamp": 1600001695
    },
    {
        "content": "<p>Like, this needs to build std somehow, no?</p>",
        "id": 209929932,
        "sender_full_name": "matklad",
        "timestamp": 1600001708
    },
    {
        "content": "<p>I tried this last night: <a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/209906334\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/209906334</a></p>",
        "id": 209929935,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600001715
    },
    {
        "content": "<p>Ok, let's collaborate this :-) </p>\n<p><a href=\"https://hackmd.io/@matklad/rkvyHPsND/edit\">https://hackmd.io/@matklad/rkvyHPsND/edit</a></p>",
        "id": 209930019,
        "sender_full_name": "matklad",
        "timestamp": 1600001829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> </p>\n<p>trying <code>cd compiler/rustc_middle &amp;&amp; cargo +beta check</code> gives me</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0412]: cannot find type `ControlFlow` in module `std::ops`\n  --&gt; compiler/rustc_data_structures/src/graph/iterate/mod.rs:91:37\n   |\n91 | pub type ControlFlow&lt;T&gt; = std::ops::ControlFlow&lt;(), T&gt;;\n   |                                     ^^^^^^^^^^^ not found in `std::ops`\n</code></pre></div>\n\n\n<p>which is what I'd expect</p>",
        "id": 209931729,
        "sender_full_name": "matklad",
        "timestamp": 1600004025
    },
    {
        "content": "<p>does <code>cargo +nightly check</code> work?</p>",
        "id": 209931782,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600004051
    },
    {
        "content": "<p>Maybe you got lucky and hit the rustc commit where it wasn't using any nightly features of libstd, which weren't at the same time in beta?</p>",
        "id": 209931788,
        "sender_full_name": "matklad",
        "timestamp": 1600004059
    },
    {
        "content": "<p>remember that rustc only supports master libstd</p>",
        "id": 209931789,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600004059
    },
    {
        "content": "<p>Ah, right, than we are trying to agree with each other I guess :)</p>",
        "id": 209931806,
        "sender_full_name": "matklad",
        "timestamp": 1600004078
    },
    {
        "content": "<p>ok I see what you were saying before then, you <em>want</em> this to work with beta</p>",
        "id": 209931820,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600004103
    },
    {
        "content": "<p>Yup</p>",
        "id": 209931829,
        "sender_full_name": "matklad",
        "timestamp": 1600004113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/209929485\">said</a>:</p>\n<blockquote>\n<p>no, you shouldn't use any, because if you use it after 6 weeks you end up with cfg(bootstrap) in the compiler when that feature changes, or have to revert that use.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133169\">matklad</span> helped me clear up some confusion on this point - this is sort of already the case, if you make breaking changes to unstable libstd features, you have to update the compiler. The difference in my idea is that you'd have to update it to be compatible with <em>both</em> beta and nightly libstd</p>",
        "id": 209932432,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600004908
    },
    {
        "content": "<p>Yes, and my point is that dual compatibility is too hard an ask in general IMO, so if we go for that I'd personally want no unstable libs feature use (to avoid dual compatibility)</p>",
        "id": 209934200,
        "sender_full_name": "simulacrum",
        "timestamp": 1600007673
    },
    {
        "content": "<blockquote>\n<p>But why does that testing have to be committed into master? Wouldn't it be more helpful if instead of one person gaining experiences from porting the compiler to use a nightly feature, you have multiple people doing it in their own rustc github forks? Then they can compare their results instead of one port taking the opportunity away from everyone else.</p>\n</blockquote>\n<p>Practically speaking, I think almost no one will want to spend time rewriting code to use a nightly feature if it's never actually going to get merged. From personal experience, I've never created a PR that just adds a nightly feature usage - it's always part of some other PR.</p>\n<p>I think \"comparing results\" is best done by looking at all of the different uses of a feature that have been committed to master. Having a bunch of (possibly bitrotted) branches that all touch the same thing doesn't seem very useful to me.</p>\n<p>I'm sympathetic to the argument that compiling on stable/beta would simplify things w.r.t. libstd. However, I  think pushing for progress on the features we use (either stabilization or removal) is a better (though much more involved) way to accomplish this goal.</p>",
        "id": 209936234,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1600010982
    },
    {
        "content": "<p>I haven't followed the conversation super closely, but I actually think we should be going for the reverse goal: make <code>libstd</code> build with a standard beta compiler and no bootstrapping. TMK, we are not that far from this today, and it would make a big difference for contributors if working on <code>libstd</code> had nothing to do with the compiler.</p>",
        "id": 209962536,
        "sender_full_name": "mark-i-m",
        "timestamp": 1600054494
    },
    {
        "content": "<p>You can already compile libstd with beta only</p>",
        "id": 209966701,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600061709
    },
    {
        "content": "<p>And you fundamentally <em>need</em> to be able to compile it with stage1 in order to build stage 2</p>",
        "id": 209966714,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600061729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/209936234\">said</a>:</p>\n<blockquote>\n<p>However, I  think pushing for progress on the features we use (either stabilization or removal) is a better (though much more involved) way to accomplish this goal.</p>\n</blockquote>\n<p>Yes absolutely, this is what I'd do as well. Triage the nightly features into two categories: the ones likely to stabilize and the ones that likely won't see stabilization because of open issues still. Then push for progress on the first category and move the compiler off the second. Example for first category: <code>cow_is_borrowed</code>, example for second: <code>crate_visibility_modifier</code>.</p>",
        "id": 209976330,
        "sender_full_name": "est31",
        "timestamp": 1600071375
    },
    {
        "content": "<p>So what you say here is not in conflict with my proposal.</p>",
        "id": 209976390,
        "sender_full_name": "est31",
        "timestamp": 1600071446
    },
    {
        "content": "<p>FYI I just made a feature use count, there are 61 features in use in total, with 30 lang features and 31 lib features.<br>\nIn total, there are 154 unstable lang features available and 261 lib features (sum is 415).</p>",
        "id": 209989398,
        "sender_full_name": "est31",
        "timestamp": 1600081181
    },
    {
        "content": "<p>So regarding the testing point, only a small subset of features are being tested right now</p>",
        "id": 209989429,
        "sender_full_name": "est31",
        "timestamp": 1600081201
    },
    {
        "content": "<p>Also good news for porting to stable: only 61 features to remove from the compiler/stabilize</p>",
        "id": 209989589,
        "sender_full_name": "est31",
        "timestamp": 1600081309
    },
    {
        "content": "<p>While I've read this whole thread, it's still not clear to me what exactly is being proposed. There seems to be at least two different competing proposals. </p>\n<p>However, I will say that making <code>cargo build</code> and <code>cargo test</code> work for the standard library seems like a good thing to me. However, I'm not sure how valuable it is for the compiler. I use stage 2 builds a few times a month and I don't see how cargo could be contorted to make that work so it seems like we will have both <code>x.py</code> and <code>cargo</code> and I will probably stick with <code>x.py</code> for consistency. </p>\n<p>Like many others in this thread, I think it's important that the compiler use nightly lang &amp; library features and I haven't seen an argument that's compelling to me personally to change that.</p>",
        "id": 209994707,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600084956
    },
    {
        "content": "<p>I think \"we do not use all possible features\" is a poor argument for \"we should not use any features\".</p>\n<p>For example, just recently, Niko used the use of crate visibility modifier in the compiler as a point of evaluation - <a href=\"https://github.com/rust-lang/rust/issues/53120#issuecomment-669529485\">https://github.com/rust-lang/rust/issues/53120#issuecomment-669529485</a> - something that would basically not otherwise be readily available. You really do want that sort of organic usage.</p>",
        "id": 209995283,
        "sender_full_name": "simulacrum",
        "timestamp": 1600085366
    },
    {
        "content": "<p>Making cargo build and cargo test work for the standard library definitely does not require any changes to stability; it already almost works today, and I suspect that with some work we could make it just work. The compiler working with plain cargo also mostly needs -Zbuild-std or similar pushed further on - and today the compiler can almost always be built on nightly with just cargo too. (If you carefully choose your base bors commit, this is essentially guaranteed).</p>",
        "id": 209995531,
        "sender_full_name": "simulacrum",
        "timestamp": 1600085523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> I propose what's written in <a href=\"https://github.com/rust-lang/compiler-team/issues/358\">https://github.com/rust-lang/compiler-team/issues/358</a> : removal of <code>#![feature(...)]</code> of anything in or depended by <code>compiler/</code>.</p>",
        "id": 209999445,
        "sender_full_name": "est31",
        "timestamp": 1600087927
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> you're aware that he was mentioning it in terms of having moved to stable? :) Apparently moving to stable motivates people to speak out in favour of stabilizing things. Sounds great to me ;).</p>",
        "id": 209999668,
        "sender_full_name": "est31",
        "timestamp": 1600088042
    },
    {
        "content": "<p>I am confused -- the point is, we would not have that datapoint or experience without the ability to use unstable features in the compiler. In this case, no decision has been made yet, but I am personally feeling like we should stabilize crate visibility in part <em>because of</em> working on the compiler and seeing its use there.</p>",
        "id": 209999994,
        "sender_full_name": "simulacrum",
        "timestamp": 1600088193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> note that I'm not even sure about the schedule by which to make this change, whether to make it quickly or whether to set it as a long term goal and work towards reducing the number of unstable features first, but keeping those which are deemed valuable, e.g. for testing. Given the responses in this thread, I lean towards the latter.</p>",
        "id": 210000023,
        "sender_full_name": "est31",
        "timestamp": 1600088209
    },
    {
        "content": "<p>I am personally feeling like this should not be a goal we set, even for the long-term right now.</p>",
        "id": 210000079,
        "sender_full_name": "simulacrum",
        "timestamp": 1600088235
    },
    {
        "content": "<p>The downsides seem to outweigh the upsides.</p>",
        "id": 210000143,
        "sender_full_name": "simulacrum",
        "timestamp": 1600088266
    },
    {
        "content": "<p>From what I've read, I'd agree with what <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> has said:</p>\n<blockquote>\n<p>Like many others in this thread, I think it's important that the compiler use nightly lang &amp; library features and I haven't seen an argument that's compelling to me personally to change that.</p>\n</blockquote>",
        "id": 210000279,
        "sender_full_name": "davidtwco",
        "timestamp": 1600088332
    },
    {
        "content": "<p>Note that there is a selection bias: the established compiler contributors already are familiar with nightly Rust features and the custom rustc workflows... the large costs are paid by new contributors as well as users, like people who might want to use crates-io-ified rustc crates for their own purposes.</p>",
        "id": 210000575,
        "sender_full_name": "est31",
        "timestamp": 1600088451
    },
    {
        "content": "<p>as someone who doesn't use nightly outside the rust compiler, I haven't found it to be a burden</p>",
        "id": 210000766,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600088545
    },
    {
        "content": "<p>being able to use <code>box</code> is nice <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 210000779,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600088555
    },
    {
        "content": "<p>and rustc changes so frequently that I'd expect anyone compiling it to use a pinned nightly + rustc source anyway</p>",
        "id": 210000825,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600088579
    },
    {
        "content": "<p>\"custom rustc workflows\" isn't going to change (much) because we use stable, so I think we can remove that from consideration mostly.</p>",
        "id": 210001041,
        "sender_full_name": "simulacrum",
        "timestamp": 1600088685
    },
    {
        "content": "<p>If users are struggling to use code because of a nightly feature that seems <em>good</em> and we should document that they should leave feedback to that effect -- it's really important to know of that kind of problem before we stabilize! So this seems like a benefit to me...</p>",
        "id": 210001149,
        "sender_full_name": "simulacrum",
        "timestamp": 1600088748
    },
    {
        "content": "<p>wrt to crates-io-ified rustc crates, I think it may be reasonable to say that those libraries may want to be stable-compatible or at least have feature flags to do so. But, until we have concrete libraries to consider, I don't think there's enough to discuss here</p>",
        "id": 210001334,
        "sender_full_name": "simulacrum",
        "timestamp": 1600088824
    },
    {
        "content": "<p>I can think of a couple of parts that rust-analyzer could consume if the defining crates built on stable:</p>\n<ul>\n<li>The built-in attribute list</li>\n<li>The unstable feature list</li>\n<li>The list of available lints (could be parsed from <code>rustc -Dhelp</code> too)</li>\n</ul>\n<p>Other than that, not much comes to mind.</p>",
        "id": 210001748,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1600089038
    },
    {
        "content": "<p>Right, I think there's definitely room for saying \"these bits are nice to be able to use outside rustc, e.g., in rust-analyzer\" and explicitly stabilizing those, but for now those bits are small and not even necessarily unstable already</p>",
        "id": 210003263,
        "sender_full_name": "simulacrum",
        "timestamp": 1600089841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210000575\">said</a>:</p>\n<blockquote>\n<p>Note that there is a selection bias: the established compiler contributors already are familiar with nightly Rust features and the custom rustc workflows... the large costs are paid by new contributors as well as users, like people who might want to use crates-io-ified rustc crates for their own purposes.</p>\n</blockquote>\n<p>I think there's a lot of willingness within established contributors to make changes that would benefit new contributors. Speaking more generally, however:</p>\n<ul>\n<li>I think we're under-estimating the churn for existing contributors that recent changes (and changes like this) have had (I'm reminded of <a href=\"https://youtu.be/voXVTjwnn-U\">this talk at a PyCon</a> about \"trampling flower gardens\", although I think the changes being made are generally more positive than those discussed in that talk).<div class=\"youtube-video message_inline_image\"><a data-id=\"voXVTjwnn-U\" href=\"https://youtu.be/voXVTjwnn-U\"><img src=\"https://i.ytimg.com/vi/voXVTjwnn-U/default.jpg\"></a></div></li>\n<li>I'm not convinced that we can ever get to a point where there are no roadblocks to contributing (improving rustc compile times is a laudable goal, but it'll only ever improve so much). We should invest in improving things here, I do think that reducing barriers to entry is important, but I don't think investing our limited effort to attract people who prefer using stable rather than <code>x.py</code>, or who want initial compile times to be under ten minutes, is going to lead to far more contributors (I appreciate that this is a simplification of why this is being proposed). We should seek to eliminate roadblocks, but having more mentored issues and active working groups for prospective contributors to participate in will and has gained us far more regular contributors than things like improving the defaults of <code>x.py</code> (which isn't to say that isn't helpful).</li>\n</ul>",
        "id": 210004024,
        "sender_full_name": "davidtwco",
        "timestamp": 1600089906
    },
    {
        "content": "<p>I haven't watched the video yet but I'll take a look :)</p>\n<blockquote>\n<p>We should seek to eliminate roadblocks, but having more mentored issues and active working groups for prospective contributors to participate in will and has gained us far more regular contributors than things like improving the defaults of x.py</p>\n</blockquote>\n<p>I think these improvements are different in kind. The mentored issues and working groups make new contributors more visible because they're responding to the issues: you see every new person who contributes because of it. The changes in defaults is silent: anyone it helps doesn't ask questions, because it 'just worked' for them. These don't have to be mutually exclusive: improving the defaults makes it easier for new contributors to tackle mentored issues.</p>",
        "id": 210007335,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600091416
    },
    {
        "content": "<blockquote>\n<p>I don't think investing our limited effort to attract people who [...] want initial compile times to be under ten minutes is going to lead to far more contributors</p>\n</blockquote>\n<p>Is this really so far-fetched a goal? It's definitely a lot of hard work to make it possible, but this is the number one stumbling block I've seen people run into again and again. I bought a new computer just so it would be <em>possible</em> to compile rustc without waiting half an hour.</p>\n<p>I'm not saying this should take precedence over all the other improvements, I realize there's only so much time to go around. But I really do think this would make an <em>enormous</em> improvement in getting new contributors.</p>",
        "id": 210007583,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600091542
    },
    {
        "content": "<p>I agree with all you've written. </p>\n<p>My primary concern is just that we're utilizing our resources most effectively (though ultimately, contributors can spend their time where they want, so if this is what you want to improve, power to you) and investing in efforts that will yield the most return (from my own experience, it was the experience of the NLL working group that kept me coming back, not a lack of roadblocks; so I value investment in things like that more). </p>\n<p>Though, I do think the impact of churn on existing contributors should be weighted slightly more than it is.</p>\n<blockquote>\n<p>These don't have to be mutually exclusive: improving the defaults makes it easier for new contributors to tackle mentored issues.</p>\n</blockquote>\n<p>I agree that they don't have to be mutually exclusive.</p>\n<blockquote>\n<p>I'm not saying this should take precedence over all the other improvements, I realize there's only so much time to go around.</p>\n</blockquote>\n<p>This was the crux of my point. I could be wrong (I hope I am), but I am skeptical that the contributor who is put off by a long initial compile time would become a regular long-term contributor if it weren't for that.</p>",
        "id": 210009562,
        "sender_full_name": "davidtwco",
        "timestamp": 1600092419
    },
    {
        "content": "<blockquote>\n<p>I am skeptical that the contributor who is put off by a long initial compile time would become a regular long-term contributor if it weren't for that.</p>\n</blockquote>\n<p>Another place this would have a big impact: compile times are <em>the</em> reason rust isn't packaged on openbsd (from <a href=\"https://marc.info/?l=openbsd-misc&amp;m=151233345723889&amp;w=2\">https://marc.info/?l=openbsd-misc&amp;m=151233345723889&amp;w=2</a>):</p>\n<blockquote>\n<p>In OpenBSD there is a strict requirement that base builds base.<br>\nSo we cannot replace any base utility, unless the toolchain to build<br>\nit is in the base.  Adding such a toolchain would take make build time<br>\nfrom 40 minutes to hours.  I don't see how that would happen.</p>\n<p>Such ecosystems come with incredible costs.  For instance, rust cannot<br>\neven compile itself on i386 at present time because it exhausts the<br>\naddress space.</p>\n</blockquote>",
        "id": 210018094,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600095730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210000023\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125250\">Wesley Wiser</span> note that I'm not even sure about the schedule by which to make this change, whether to make it quickly or whether to set it as a long term goal and work towards reducing the number of unstable features first, but keeping those which are deemed valuable, e.g. for testing. Given the responses in this thread, I lean towards the latter.</p>\n</blockquote>\n<p>My point is that I don't see why this is a compelling goal.</p>",
        "id": 210018121,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600095740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/209995283\">said</a>:</p>\n<blockquote>\n<p>For example, just recently, Niko used the use of crate visibility modifier in the compiler as a point of evaluation - <a href=\"https://github.com/rust-lang/rust/issues/53120#issuecomment-669529485\">https://github.com/rust-lang/rust/issues/53120#issuecomment-669529485</a> - something that would basically not otherwise be readily available. You really do want that sort of organic usage.</p>\n</blockquote>\n<p>Note that Niko is an exception. There are only two people who are both on the compiler and lang teams, he's one of them. And it's not like won't be able to test crate outside of rustc. One can use experimental projects for that. He has made an entire compiler for experimentation purposes, mostly (I presume) to test other things like IDE friendliness, but it also uses the crate visibility level (and it builds with nightly std): <a href=\"https://github.com/lark-exploration/lark/search?q=crate_visibility_modifier&amp;unscoped_q=crate_visibility_modifier\">https://github.com/lark-exploration/lark/search?q=crate_visibility_modifier&amp;unscoped_q=crate_visibility_modifier</a> </p>\n<p>So TLDR I don't think much is lost in testing ability by rustc switching to stable (at least on the master, beta and stable branches)</p>",
        "id": 210018632,
        "sender_full_name": "est31",
        "timestamp": 1600095947
    },
    {
        "content": "<p>But to be clear, I'm also strongly in favor of this:</p>\n<blockquote>\n<p>The changes in defaults is silent: anyone it helps doesn't ask questions, because it 'just worked' for them. </p>\n</blockquote>\n<p>Defaults are really important especially for new contributors.</p>",
        "id": 210018799,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600096002
    },
    {
        "content": "<p>As a person who recently tried to recruit someone to work on a compiler feature on my behalf:</p>\n<ul>\n<li>All of them asked about build times and their eyes popped at the idea that the \"long build times\" of their normal projects were peanuts compared to the glacial ages that rustc uses to build.</li>\n<li>All of them complained about the imagined complexity of even a small change to the compiler.</li>\n<li>None of them even asked about a mentorship program. They were seemingly unaware that such a program even existed. You need some PR work here it seems.</li>\n</ul>\n<p>So you <em>do</em> need to keep lowering barrier to entry. Because, and this is a key point so i'll put it in bold, <strong>if every rustacean were to contribute to the compiler just once in their life, that's years and years of work-hours contributed when you add it all up</strong>.</p>",
        "id": 210018884,
        "sender_full_name": "Lokathor",
        "timestamp": 1600096046
    },
    {
        "content": "<p>That's my point. I want to make it more \"normal\" to contribute to the compiler. Mentorship programs, making <code>cargo test</code> just work, using stable, etc. are all part of that.</p>",
        "id": 210019083,
        "sender_full_name": "est31",
        "timestamp": 1600096122
    },
    {
        "content": "<p>Sorry Est31, that was more at DavidTwco, but then i took too long to type it because i had to get coffee</p>",
        "id": 210019169,
        "sender_full_name": "Lokathor",
        "timestamp": 1600096164
    },
    {
        "content": "<p>I think we can significantly improve on that without giving up on dogfooding unstable features in rustc</p>",
        "id": 210019429,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1600096261
    },
    {
        "content": "<p>I want to make sure I'm clear - I do think that improving the overall experience is important. I want to attract contributors that'll stick around and contribute regularly and I think small roadbumps probably have less of an impact there than the way we organize ourselves so that there's a structure for those people to get involved in ongoing efforts and get help.</p>",
        "id": 210019672,
        "sender_full_name": "davidtwco",
        "timestamp": 1600096372
    },
    {
        "content": "<p>I think where we disagree is 'small' roadbumps ;)</p>",
        "id": 210019890,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600096466
    },
    {
        "content": "<p>Yeah - I don't even know that we disagree, we just differ on which aspects of the larger problem are most important.</p>",
        "id": 210020420,
        "sender_full_name": "davidtwco",
        "timestamp": 1600096691
    },
    {
        "content": "<p>fortunately we don't have to agree if we can work on both parts of the problem at once :)</p>",
        "id": 210020529,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600096744
    },
    {
        "content": "<p>I think you're exactly right <span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span>. </p>\n<p>I do see a lot of value in letting people <code>cargo build</code> or <code>cargo test</code> the compiler if that's what they want to do. It's definitely way more intuitive for a Rust developer than the current system. </p>\n<p>What I don't see is why we need to give up unstable features to do it. I use cargo with all my nightly projects. I don't see why rustc has to be different in that regard.</p>",
        "id": 210020549,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600096756
    },
    {
        "content": "<p>rust has to build with two different std's for starters</p>",
        "id": 210020614,
        "sender_full_name": "est31",
        "timestamp": 1600096787
    },
    {
        "content": "<p>no other program needs that</p>",
        "id": 210020643,
        "sender_full_name": "est31",
        "timestamp": 1600096800
    },
    {
        "content": "<p>Isn't that just the <code>#[cfg(bootstrap)]</code> stuff though?</p>",
        "id": 210020772,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600096855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210020614\">said</a>:</p>\n<blockquote>\n<p>rust has to build with two different std's for starters</p>\n</blockquote>\n<p>this would be true no matter what</p>",
        "id": 210020893,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600096916
    },
    {
        "content": "<p>since you have to be able to build with both the beta and stage 1 compiler</p>",
        "id": 210020964,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600096930
    },
    {
        "content": "<p>the only thing moving to stable gets you is that nothing would <em>change</em> between the versions of std</p>",
        "id": 210021029,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600096959
    },
    {
        "content": "<p>I think there's also a question of expectations - I don't think I would expect the compiler and standard library for the language to have exactly the same infrastructure as every other project, or that there wouldn't be some complexity to different changes - it's a massive project, that does a ton of complicated stuff, why wouldn't that be the case? Putting aside whether we can or cannot change something (and the trade-offs inherent in that), if we set accurate expectations, fewer people might find themselves unable or unwilling to contribute.</p>",
        "id": 210021034,
        "sender_full_name": "davidtwco",
        "timestamp": 1600096960
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> yeah but apparently that's much less of an issue, not sure why... there are almost equal number of unstable lang and lib features used by rustc</p>",
        "id": 210021084,
        "sender_full_name": "est31",
        "timestamp": 1600096983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> so you telling me that stable rust can't be used to build large projects?</p>",
        "id": 210021171,
        "sender_full_name": "est31",
        "timestamp": 1600097026
    },
    {
        "content": "<blockquote>\n<p>I don't think I would expect the compiler and standard library for the language to have exactly the same infrastructure as every other project<br>\nit's a massive project, that does a ton of complicated stuff</p>\n</blockquote>\n<p>sure, I think x.py has to exist in some form. But I think we should ask how much of the complexity is <em>necessary</em> and how much has just grown organically over time</p>",
        "id": 210021184,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600097034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210021171\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116107\">davidtwco</span> so you telling me that stable rust can't be used to build large projects?</p>\n</blockquote>\n<p>let's assume positive intentions :)</p>",
        "id": 210021234,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600097043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210021171\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116107\">davidtwco</span> so you telling me that stable rust can't be used to build large projects?</p>\n</blockquote>\n<p>No, I'm telling you that I wouldn't expect every language's compiler and standard library to be built without some sort of special tooling.</p>",
        "id": 210021259,
        "sender_full_name": "davidtwco",
        "timestamp": 1600097059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> yes, please assume them, it was rhetorical question</p>",
        "id": 210021274,
        "sender_full_name": "est31",
        "timestamp": 1600097067
    },
    {
        "content": "<p>Part of improving the contributor experience here could be explaining (and I think good work has been done on this in the rustc-dev-guide) why things are the way they are - that way a new contributor understands why there might be some friction.</p>",
        "id": 210021446,
        "sender_full_name": "davidtwco",
        "timestamp": 1600097149
    },
    {
        "content": "<p>(thereby setting appropriate expectations)</p>",
        "id": 210021537,
        "sender_full_name": "davidtwco",
        "timestamp": 1600097176
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> good point. gcc is full of custom gcc-isms as well. rustc isn't the only compiler where this happens.</p>",
        "id": 210021613,
        "sender_full_name": "est31",
        "timestamp": 1600097210
    },
    {
        "content": "<p>(And I consider it a problem there too)</p>",
        "id": 210021681,
        "sender_full_name": "est31",
        "timestamp": 1600097238
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> if the compiler and standard library can't work with normal cargo just because they're a large project, sounds like cargo needs to get way better somehow until it <em>can</em> handle them.</p>",
        "id": 210021901,
        "sender_full_name": "Lokathor",
        "timestamp": 1600097337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210021901\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116107\">davidtwco</span> if the compiler and standard library can't work with normal cargo just because they're a large project, sounds like cargo needs to get way better somehow until it <em>can</em> handle them.</p>\n</blockquote>\n<p>x.py is <em>not</em> just a wrapper around cargo</p>",
        "id": 210021931,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600097356
    },
    {
        "content": "<p><a href=\"https://www.reddit.com/r/rust/comments/irhj4o/blog_post_rust_in_2021/g4zwdzt/\">https://www.reddit.com/r/rust/comments/irhj4o/blog_post_rust_in_2021/g4zwdzt/</a></p>",
        "id": 210021963,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600097378
    },
    {
        "content": "<p>Bootstrapping compilers have needs that 99.999% of the rest of the ecosystem do not. Adding complexity to the standard build tools to accommodate rustc +std is not necessarily a good trade off.</p>",
        "id": 210021991,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600097396
    },
    {
        "content": "<p>to get the rustc executable plus building std with it, you don't really need more than -Z build std</p>",
        "id": 210022101,
        "sender_full_name": "est31",
        "timestamp": 1600097439
    },
    {
        "content": "<p>I should have worded my message better - being a large complicated project is why making a simple change might induce complexity, and I wouldn't expect that to be surprising (this was in reference to <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210018884\">your message</a>); requiring non-standard tooling is something that I see as being related to the nature of the project, being the compiler and standard library for the language, which I also wouldn't expect to be surprising.</p>",
        "id": 210022112,
        "sender_full_name": "davidtwco",
        "timestamp": 1600097444
    },
    {
        "content": "<p>the passes beyond the first pass aren't really needed except for testing purposes and maybe some benefit when you have some optimizations or LLVM update that creates better binaries and you want your rustc you ship to users compiled with them</p>",
        "id": 210022329,
        "sender_full_name": "est31",
        "timestamp": 1600097546
    },
    {
        "content": "<p>I personally feel like there's a lot of crossed wires in this discussion. Further up thread, it seems like the goal is to let <code>cd compiler &amp;&amp; cargo test</code> \"just work\" . That seems great to me!</p>\n<p>What I don't see is why we're talking about changing the bootstrap compiler. I further don't see why we're talking about removing uses of unstable features. Even if we use <code>stable</code>, we can still pass <code>RUST_BOOTSTRAP=1</code> and use all the unstable features. </p>\n<p>Is there a minimum set of changes we can make to let the <code>cd compiler &amp;&amp; cargo test</code> workflow be possible without changing policy around bootstrapping, use of unstable features or significantly growing the capabilities of cargo?</p>",
        "id": 210022400,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600097587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> <code>RUST_BOOTSTRAP</code> is a hack and just because the compiler uses it doesn't make it better</p>",
        "id": 210022485,
        "sender_full_name": "est31",
        "timestamp": 1600097632
    },
    {
        "content": "<p>I get why it's used in <code>library/</code></p>",
        "id": 210022536,
        "sender_full_name": "est31",
        "timestamp": 1600097643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120096\">@est31</span> Ok but if you try to change everything at once, you're not going to get anything done.</p>",
        "id": 210022565,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600097657
    },
    {
        "content": "<p>There's nothing stopping us from moving away from unstable features or to a stable bootstrap compiler after we start using cargo without the <code>x.py</code> wrapper.</p>",
        "id": 210022630,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600097696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125250\">Wesley Wiser</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210022630\">said</a>:</p>\n<blockquote>\n<p>There's nothing stopping us from moving away from unstable features or to a stable bootstrap compiler after we start using cargo without the <code>x.py</code> wrapper.</p>\n</blockquote>\n<p>(I'm still not convinced this is possible in general, maybe for stage1 builds only)</p>",
        "id": 210022668,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600097714
    },
    {
        "content": "<p>Sure, what I meant was \"moving to cargo does not make the problem worse\" :)</p>",
        "id": 210022728,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600097748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> sure, sounds good. As said above I don't really care if it's a short term or long term schedule. Ultimately, even if this MCP will be rejected maybe in 3 or 4 years it might happen anyways.</p>",
        "id": 210022785,
        "sender_full_name": "est31",
        "timestamp": 1600097769
    },
    {
        "content": "<p>The trend goes that way of the compiler using less and less compiler-special things and adopting their standard alternatives. RUSTC_BOOTSTRAP is a compiler-special thing :).</p>",
        "id": 210022949,
        "sender_full_name": "est31",
        "timestamp": 1600097874
    },
    {
        "content": "<p>The compiler is not a particularly unique program, so in the sense that eventually we'll probably not have major language features that it wants to use that aren't stabilized, yes of course it'll eventually be stable. But I have not yet been convinced that this is a goal we should strive to accelerate progress towards by changing the compiler (e.g., removing unstable feature use).</p>",
        "id": 210023182,
        "sender_full_name": "simulacrum",
        "timestamp": 1600097983
    },
    {
        "content": "<p>What I am not clear on is whether <span class=\"user-mention\" data-user-id=\"120096\">@est31</span> thinks we <em>should</em> accelerate by changing the compiler. I think the answer is yes, though.</p>",
        "id": 210023611,
        "sender_full_name": "simulacrum",
        "timestamp": 1600098207
    },
    {
        "content": "<p>Yes, ideally unstable features used by the compiler start getting tracked and removed one by one. If there's no consensus for that, then that's sad, but I guess I'll have to live with it.</p>\n<p>Weaker forms of the proposal could include just checking all the unstable features currently in use and wondering if they pull their weight, and only remove those which don't. e.g. personally I think that this would be clearer if it were just a wrapper over <code>Vec</code>: <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_arena/src/lib.rs#L53\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_arena/src/lib.rs#L53</a></p>",
        "id": 210024187,
        "sender_full_name": "est31",
        "timestamp": 1600098449
    },
    {
        "content": "<p>Basically an one time sweep over all unstable features</p>",
        "id": 210024244,
        "sender_full_name": "est31",
        "timestamp": 1600098471
    },
    {
        "content": "<p>Every other serious rust project tracks what keeps it on Nightly and usually tries to move to Stable when possible. It's totally fair for the <code>rustc</code> to hold itself to the same standard.</p>",
        "id": 210024500,
        "sender_full_name": "Lokathor",
        "timestamp": 1600098580
    },
    {
        "content": "<p>One challenge is that it's generally hard to determine the schedule of some feature's stabilization. Some might get stabilized soon, others not so soon. So that shouldn't be a component in that sweep.</p>",
        "id": 210024516,
        "sender_full_name": "est31",
        "timestamp": 1600098589
    },
    {
        "content": "<p>As in: keeping features which have tons of discussion behind them but don't trend towards stabilization alone for now, not removing their use from the compiler. Example would be the crate visibility level or box syntax.</p>",
        "id": 210025588,
        "sender_full_name": "est31",
        "timestamp": 1600099012
    },
    {
        "content": "<p>To me it feels like the compiler is in a unique place due to being the one project in Rust that never suffers from nightly breakage, which means that using nightly features has less of the \"it won't build\" downside that other projects may experience.</p>\n<p>I don't think the compiler should go out of its way to use unstable features, but if it makes sense to do so then there are real benefits, as it gives us more experience with that feature in a fairly large project setting, which can be useful.</p>",
        "id": 210025860,
        "sender_full_name": "simulacrum",
        "timestamp": 1600099121
    },
    {
        "content": "<p>Lack of obvious overlap with lang team is not really too important -- compiler team members frequently contribute to lang team discussions around stabilization, directly or indirectly.</p>",
        "id": 210025941,
        "sender_full_name": "simulacrum",
        "timestamp": 1600099156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210024500\">said</a>:</p>\n<blockquote>\n<p>Every other serious rust project tracks what keeps it on Nightly and usually tries to move to Stable when possible. It's totally fair for the <code>rustc</code> to hold itself to the same standard.</p>\n</blockquote>\n<p>I don't find this argument compelling; that \"standard\" exists for sensible reasons:</p>\n<ol>\n<li>Lots of people want to use stable (because it's stable).</li>\n<li>As a crate author, I want people to use my crate.</li>\n<li>I can therefore avoid using unstable features so that more people use my crate.</li>\n</ol>\n<p>rustc will be used regardless of whether it uses nightly features, there's no reason to hold itself to that same \"standard\". If the compiler team choose to make a crate from the compiler public then they might also choose to remove nightly feature use from that crate, but that's a decision for that specific case.</p>",
        "id": 210026036,
        "sender_full_name": "davidtwco",
        "timestamp": 1600099196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>  Features are added to the language usually because they improve <em>something</em>, so there will be usually a benefit in the usage of a feature. The question is: should the compiler get those features before everyone else does</p>",
        "id": 210026221,
        "sender_full_name": "est31",
        "timestamp": 1600099247
    },
    {
        "content": "<p>I am not sure I follow that train of thought. If I understand correctly, you mean to say that we should prevent unstable feature usage in the compiler to encourage features to stabilize faster? That seems... odd to me</p>",
        "id": 210026529,
        "sender_full_name": "simulacrum",
        "timestamp": 1600099345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210026221\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span>  Features are added to the language usually because they improve <em>something</em>, so there will be usually a benefit in the usage of a feature. The question is: should the compiler get those features before everyone else does</p>\n</blockquote>\n<p>What difference does it make? If the compiler can benefit from it, then that's great, why wouldn't you want the compiler to benefit from it? I don't think there has to be some standard of fairness whereby the compiler cannot use some features unless the ecosystem them at the same time.</p>",
        "id": 210026532,
        "sender_full_name": "davidtwco",
        "timestamp": 1600099346
    },
    {
        "content": "<p>And the compiler does get the features at the same time as everyone else - that's what nightly is for.</p>",
        "id": 210026726,
        "sender_full_name": "davidtwco",
        "timestamp": 1600099419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span></p>\n<blockquote>\n<p>being the one project in Rust that never suffers from nightly breakage, </p>\n</blockquote>\n<p>How does the compiler not suffer from nightly breakage? I can't check out an old version of rustc and compile it with my new beta rustc. Have to use that single n-1 version.</p>",
        "id": 210026839,
        "sender_full_name": "est31",
        "timestamp": 1600099451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210026839\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span></p>\n<blockquote>\n<p>being the one project in Rust that never suffers from nightly breakage, </p>\n</blockquote>\n<p>How does the compiler not suffer from nightly breakage? I can't check out an old version of rustc and compile it with my new beta rustc. Have to use that single n-1 version.</p>\n</blockquote>\n<p>If I change a nightly feature in such a way that it would break compatibility at the same time, I necessarily need to update the compiler's usage of that feature so that rustc continues to compile.</p>",
        "id": 210026972,
        "sender_full_name": "davidtwco",
        "timestamp": 1600099504
    },
    {
        "content": "<p>That's an argument for not only not using unstable features, but also having a less-aggressive MSRV than \"latest beta\" (which is loosely what we have today).</p>",
        "id": 210027021,
        "sender_full_name": "simulacrum",
        "timestamp": 1600099525
    },
    {
        "content": "<p>Which -- well, I don't think we should bite off both at the same time.</p>",
        "id": 210027052,
        "sender_full_name": "simulacrum",
        "timestamp": 1600099541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116107\">davidtwco</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210026532\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210026221\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span>  Features are added to the language usually because they improve <em>something</em>, so there will be usually a benefit in the usage of a feature. The question is: should the compiler get those features before everyone else does</p>\n</blockquote>\n<p>What difference does it make? If the compiler can benefit from it, then that's great, why wouldn't you want the compiler to benefit from it? I don't think there has to be some standard of fairness whereby the compiler cannot use some features unless the ecosystem them at the same time.</p>\n</blockquote>\n<p>This difference creates churn by the ecosystem, e.g. when people want to use their tooling used on stable compilers, in knowledge of the unstable features, and also when the compiler wants the ecosystem to use its crates.</p>",
        "id": 210027146,
        "sender_full_name": "est31",
        "timestamp": 1600099573
    },
    {
        "content": "<p>I feel like we're going around in circles</p>",
        "id": 210027354,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600099682
    },
    {
        "content": "<p>I think we shouldn't bring ecosystem use of compiler crates into this discussion, because no such crates exist today</p>",
        "id": 210027385,
        "sender_full_name": "simulacrum",
        "timestamp": 1600099685
    },
    {
        "content": "<p>When the compiler team wants to release part of the compiler as a crate, the compiler team can choose to prohibit use of unstable features in that crate - it doesn't require that the rest of the compiler, which is unlikely to have any sort of stable inferface, refrain from using those features.</p>",
        "id": 210027392,
        "sender_full_name": "davidtwco",
        "timestamp": 1600099687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210027021\">said</a>:</p>\n<blockquote>\n<p>That's an argument for not only not using unstable features, but also having a less-aggressive MSRV than \"latest beta\" (which is loosely what we have today).</p>\n</blockquote>\n<p>Sorry I should have been clearer. You can't check out an old version of rustc's <em>source code</em> and compile it with the new beta rustc <em>binary stage0</em>. So it's the opposite situation: old source code, new compiler. Means that e.g. you can't compile 1.31 with the 1.46 stable compiler. It needs 1.30 rustc for that. So you don't have a situation where each compiler gets more capable of compiling older compiler versions, but one where it stays constant. Arguably that's more of a philsophical benefit.</p>",
        "id": 210027456,
        "sender_full_name": "est31",
        "timestamp": 1600099720
    },
    {
        "content": "<p>Yeah, I agree that it feels like we're going in circles here -- I think fundamentally I at least assign different valuations to the pros and cons of this proposal, though I think there's also some disagreement about what exactly those are.</p>\n<p>It would probably help if the proposal was updated to list not only the benefits of such a change but negatives too -- but realistically, I wouldn't ask that someone does that because I would likely still \"vote\" against it :)</p>",
        "id": 210028211,
        "sender_full_name": "simulacrum",
        "timestamp": 1600100063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120096\">est31</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/209989398\">said</a>:</p>\n<blockquote>\n<p>FYI I just made a feature use count, there are 61 features in use in total, with 30 lang features and 31 lib features.<br>\nIn total, there are 154 unstable lang features available and 261 lib features (sum is 415).</p>\n</blockquote>\n<p>I'm interested in how one derives this information.</p>",
        "id": 210053431,
        "sender_full_name": "oliver",
        "timestamp": 1600112541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281739\">@Oliver</span> I did this to obtain the list of used features:</p>\n<div class=\"codehilite\"><pre><span></span><code>rg &#39;^#!\\[feature&#39; compiler/ -N --no-heading | grep -v rustc_error_codes | sed &#39;s/.*rs://;s/\\].*/]/;s/.*(//;s/).//&#39; | sort | uniq -c | sort -nr\n</code></pre></div>\n\n\n<p>Then I made a manual join with output from <code>./x.py test tidy -v</code> which outputs a list of feature gates with info on whether they are lib or lang. Then I saved to a file and grepped for lib and lang to get the counts :).</p>\n<p>To get the total numbers, I used the unstable book. For lang features, the beta book, for lib features the nightly book (as beta rustc is used and nightly std).</p>",
        "id": 210057031,
        "sender_full_name": "est31",
        "timestamp": 1600114403
    },
    {
        "content": "<p>Personally I feel this is more directional than a single major change(I don't think it is possible to finish such a change in short term). </p>\n<p>It's nice to taking rustc as an example and gather data on what unstable features is it using and why. Maybe put them into categories to form a document and submit them to <code>t-lang</code> and <code>t-libs</code> to take those into consideration, and i think it would be valuable.</p>\n<p>It's possible to eliminate or move away from some of the features involved if it was decided some of the features are not on the \"track\" of future language evolvement. I guess such plans might be made on top of the previous said document?</p>",
        "id": 210223261,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600233819
    },
    {
        "content": "<p>Yes, my main goal with the MCP was to establish that this is wanted in the first place, that PRs to replace unstable features by stable ones are welcome, etc. As you put it, directional. Once that is settled, I'd have done something similar to what you describe, categorizing features, etc.</p>",
        "id": 210227652,
        "sender_full_name": "est31",
        "timestamp": 1600239794
    },
    {
        "content": "<p>I wondered about doing an RFC instead or just opening an issue. As I knew there were reservations by some folks at least I didn't want to just start the work on it. A little bit surprised how much staying on nightly is a consensus among compiler devs</p>",
        "id": 210228492,
        "sender_full_name": "est31",
        "timestamp": 1600240515
    },
    {
        "content": "<p>As an outsider, I'm amused that one side of the argument boils down to 61 instances of \"I really just want to use <code>bool::then_some</code>\" and the other side is \"I really want to not have to use the word bootstrap 10 times when explaining rustc development.\"</p>",
        "id": 210244282,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600252500
    },
    {
        "content": "<p>It seems like the MCP proposes a direction for people who want to do the work to know that this work is supported as a goal, assuming they actually do the work. In that sense, disagreeing with the goal should require a reason other than \"I want to focus on something else\". Are the people who disagree actively saying that they want to prevent all PR's that remove uses of unstable features?</p>",
        "id": 210244821,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600252960
    },
    {
        "content": "<p>I think there are two arguments being made:</p>\n<ul>\n<li>I went off-topic by suggesting that our efforts might be better deployed in other efforts to attract new contributors (this topic wasn't the place for that discussion and I was speaking about more than just this specific MCP). You are correct that shouldn't be an argument against an MCP.</li>\n<li>Some have argued that there's a value in being able to dogfood unstable features in the compiler and standard library and that the arguments in favour of removing uses of unstable features aren't as compelling. I think that this is a perfectly valid argument against going ahead with this major change.</li>\n</ul>",
        "id": 210245653,
        "sender_full_name": "davidtwco",
        "timestamp": 1600253628
    },
    {
        "content": "<p>That isn't to say there won't be any circumstance whereby uses of an unstable feature should be removed - I don't think anyone's arguing that - just that there are arguments against the direction of \"removing <em>all</em> uses of unstable features\".</p>",
        "id": 210246137,
        "sender_full_name": "davidtwco",
        "timestamp": 1600254015
    },
    {
        "content": "<p>I have a compromise proposal that should address the major concern while allowing progress. Given that the primary objection to removing their use is to allow people to gain experience on the path to stabilizing a feature, in the <code>compiler/</code>, it would seem reasonable for people desiring such experience to explicitly track such. So, I'd propose:</p>\n<ul>\n<li>Bike shed a way for someone to 'claim', in good faith, a feature's use in the compiler for testing explicitly. This would be a statement that they think the feature is valuable to gain testing experience and that the feature is being progressed to a resolution actively (i.e. it's going to be stabilized if successful or changed/removed if unsuccessful). Obviously multiple people could claim it. Claims 'expire' in some way and have to be reconfirmed, which ensures that they are actively being tested and the experience is being accounted for. It only seems fair that people who have this perspective should be transparent about the benefits of it.</li>\n<li>People who are in favor of removing uses of unstable features may submit PR's which remove uses of unclaimed features. Ideally, the bikeshedded mechanism above would allow someone to state an interest in removing a specific feature, much like the tracking issue used in nushell.</li>\n<li>Alternatively, people who are in favor of removing uses of unstable features can work toward stabilizing them, whether claimed or not.</li>\n</ul>\n<p>It seems like this would have the natural outcome that the perspective with the most passion/effort will win out over time and if there is a time when there are no remaining unstable features, a proposal to make that permanent could be made.</p>",
        "id": 210276340,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600269038
    },
    {
        "content": "<p>It seems to me that the proposal by <span class=\"user-mention\" data-user-id=\"336395\">@Ahmed Charles</span> does not allow us to easily use the beta std when compiling rustc, which is the only mentioned benefit of this proposal I personally value enough to spend time on.</p>\n<p>Muting this now, as I have already spend far too much time with this</p>",
        "id": 210280033,
        "sender_full_name": "lcnr",
        "timestamp": 1600270614
    },
    {
        "content": "<p>I think that a minimal agreement can be had that the compiler should not rely on \"perma unstable\" features?</p>\n<p>Everything that is unstable should be on a path to stabilization or be removed and replaced.</p>\n<p>This leads us to careful tracking of nightly feature usage and also could potentially lead to being able to build with beta.</p>",
        "id": 210327672,
        "sender_full_name": "Lokathor",
        "timestamp": 1600295052
    },
    {
        "content": "<p>I.. hesitate to say yes. For example, the old assembly syntax was obviously permanently unstable, but use of it would've imo been fine</p>",
        "id": 210327987,
        "sender_full_name": "simulacrum",
        "timestamp": 1600295296
    },
    {
        "content": "<p>(Also, e.g., intrinsics are likely perma-unstable in their current form)</p>",
        "id": 210328002,
        "sender_full_name": "simulacrum",
        "timestamp": 1600295312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210328002\">said</a>:</p>\n<blockquote>\n<p>(Also, e.g., intrinsics are likely perma-unstable in their current form)</p>\n</blockquote>\n<p>True, though wrappers around some of them can be stabilized, and have been stabilized.</p>",
        "id": 210328028,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600295337
    },
    {
        "content": "<p>But yeah, in general I don't think std should need to avoid all nightly-only features.</p>",
        "id": 210328038,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600295351
    },
    {
        "content": "<p>(that goes for std and rustc, btw)</p>",
        "id": 210328335,
        "sender_full_name": "simulacrum",
        "timestamp": 1600295572
    },
    {
        "content": "<p>But llvm_asm having no path to stability is what got us to actually get a move on and design a much better asm system and now it does have a path to stability. That's a win for the language, the project, and the ecosystem.</p>",
        "id": 210328378,
        "sender_full_name": "Lokathor",
        "timestamp": 1600295611
    },
    {
        "content": "<p>I don't mean \"ban all nightly tomorrow\", but if things are useful enough to be used by the compiler, to people <em>outside</em> the compiler, it always feels very bad to see that useful thing and be told \"oh you'll never get that, sorry\"</p>",
        "id": 210328502,
        "sender_full_name": "Lokathor",
        "timestamp": 1600295699
    },
    {
        "content": "<p>So maybe there's maybe some small portion that really is just implementation detail that won't become stable, but we should take care to keep that small and to try to move all useful things into a stable form.</p>",
        "id": 210328619,
        "sender_full_name": "Lokathor",
        "timestamp": 1600295790
    },
    {
        "content": "<p>I think that's always true, generally speaking</p>",
        "id": 210328759,
        "sender_full_name": "simulacrum",
        "timestamp": 1600295885
    },
    {
        "content": "<p>but it's not really a reason not to use things</p>",
        "id": 210328769,
        "sender_full_name": "simulacrum",
        "timestamp": 1600295890
    },
    {
        "content": "<p>it's a reason to say \"things we need are <em>almost certainly</em> things others want, so we should consider stabilization eventually, in one form or another\"</p>",
        "id": 210328796,
        "sender_full_name": "simulacrum",
        "timestamp": 1600295914
    },
    {
        "content": "<p>Right, I don't personally want to prevent Nightly usage. I do think that a reasonable time period of Nightly experimentation and testing gives us a better end design.</p>\n<p>I just want to keep the \"perma unstable\" pile as small as possible.</p>",
        "id": 210329090,
        "sender_full_name": "Lokathor",
        "timestamp": 1600296170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> That I would <em>completely</em> agree with.</p>",
        "id": 210329349,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600296439
    },
    {
        "content": "<p>I don't think we should prevent std from using nightly features, in general.</p>",
        "id": 210329360,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600296451
    },
    {
        "content": "<p>But we should absolutely take usage in std as a suggestion that the feature is useful, and that it <em>probably</em> shouldn't be perma-unstable, unless there's a very good reason for it.</p>",
        "id": 210329376,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600296474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210328002\">said</a>:</p>\n<blockquote>\n<p>(Also, e.g., intrinsics are likely perma-unstable in their current form)</p>\n</blockquote>\n<p>Indeed, but if the compiler would use them it'd be pretty weird. It should instead use the stable wrappers that std provides. My proposal limits itself to <code>compiler/</code> crates for that reason.</p>",
        "id": 210330362,
        "sender_full_name": "est31",
        "timestamp": 1600297249
    },
    {
        "content": "<p>I think that's somewhat true, yeah.</p>",
        "id": 210330915,
        "sender_full_name": "simulacrum",
        "timestamp": 1600297718
    },
    {
        "content": "<p>I certainly can't think of a reason for the compiler to directly use an intrinsic in most cases.</p>",
        "id": 210330921,
        "sender_full_name": "simulacrum",
        "timestamp": 1600297735
    },
    {
        "content": "<p>Regarding the \"perma unstable\" features proposal: I don't think it would help much, because most features have stabilization scheduled <em>somewhere</em> or at least it isn't certain.</p>",
        "id": 210339773,
        "sender_full_name": "est31",
        "timestamp": 1600306809
    },
    {
        "content": "<p>But in general the idea is good to separate features. If the top N used/important features are selected and put onto a whitelist, it would already be progress</p>",
        "id": 210339812,
        "sender_full_name": "est31",
        "timestamp": 1600306907
    },
    {
        "content": "<p>But most statements here have made me quite sad, basically dismissing the idea of it being progress or useful in the first place</p>",
        "id": 210339867,
        "sender_full_name": "est31",
        "timestamp": 1600306938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210328335\">said</a>:</p>\n<blockquote>\n<p>(that goes for std and rustc, btw)</p>\n</blockquote>\n<p>Just curious, why does the compiler specifically require access to unstable intrinsics or assembly syntax? Honestly asking.</p>",
        "id": 210340139,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600307358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210329360\">said</a>:</p>\n<blockquote>\n<p>I don't think we should prevent std from using nightly features, in general.</p>\n</blockquote>\n<p>The title of this topic says that it's about <code>compiler/</code> not <code>std</code>. Was there a suggestion that nightly features be forbidden in <code>std</code>?</p>",
        "id": 210340242,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600307509
    },
    {
        "content": "<p>But yeah, different valuations of advantages/disadvantages I guess. I personally think there is only little benefit in using <code>then_some</code>, but it seems to be a big deal for others, while usage of <code>RUSTC_BOOTSTRAP</code> in places where it doesn't belong is a big deal for me.</p>",
        "id": 210340243,
        "sender_full_name": "est31",
        "timestamp": 1600307512
    },
    {
        "content": "<p>Apparently replying before reading everything has downsides. Sorry about that.</p>",
        "id": 210340370,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600307652
    },
    {
        "content": "<p>I'm not saying those are the best features to call out, but assembly for example would've been useful in whatever form for some of the performance work we're working on (fine-grained instruction counting). Today, we'd use the new assembly, but if we were having this conversation 1 year ago I'd still feel like using the old assembly would've been perfectly reasonable.</p>\n<p>It is harder to argue for intrinsics -- they're sort of \"very wide\" in terms of what they could do -- but even there, I could imagine us adding specialized things that we want to try out ad-hoc in some places.</p>",
        "id": 210340378,
        "sender_full_name": "simulacrum",
        "timestamp": 1600307686
    },
    {
        "content": "<p>I think the problem is that for something like then_some, you'd probably see no major pushback. If rustc was \"mostly stable\" today and had a few libs features, I could see us saying that there's real value in pushing that to completion and having a fully stable rustc. But that's not where we're at -- and most feature use in rustc is either library (but long-termish unstable) or language, I think.</p>",
        "id": 210340448,
        "sender_full_name": "simulacrum",
        "timestamp": 1600307785
    },
    {
        "content": "<p>yeah in 2-3 years or so when/if min_specialization and never type are stable, the situation will be different and lean further towards stable Rust</p>",
        "id": 210340543,
        "sender_full_name": "est31",
        "timestamp": 1600307912
    },
    {
        "content": "<p>I'm pretty sure that's why I suggested allowing interested parties to remove uses of unstable features for which there is no active party pursuing stabilization or an alternative.</p>",
        "id": 210340546,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600307918
    },
    {
        "content": "<p>But the core issue is inertia then: as rustc is not \"mostly stable\", PRs to remove unstable features are not welcome, and thus rustc is not \"mostly stable\" :-)</p>",
        "id": 210340661,
        "sender_full_name": "est31",
        "timestamp": 1600308021
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 210340675,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308042
    },
    {
        "content": "<p>You can't argue that the big reason why moving to stable is the number of unstable features currently in use when you keep adding more and prevent people from removing them. That's disingenuous. In that case, the reason isn't \"we're not close to compiling on stable\", the reason is, \"we don't want to compile on stable\".</p>",
        "id": 210340774,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308141
    },
    {
        "content": "<p>I think I would expect that any change -- whether adding or removing unstable features -- needs to be considered on its merits. I believe that today's Rust is more expressive, more powerful, and better suited for rustc when in the unstable subset. In 2-3 years -- I fully agree that we can even <em>hope</em> that will slowly not be the case.</p>",
        "id": 210340801,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308190
    },
    {
        "content": "<p>And at least for me \"not using an unstable feature\" is not an improvement, really, for the compiler's codebase -- the argument needs to go further than that.</p>",
        "id": 210340822,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308222
    },
    {
        "content": "<p>i.e., I don't think there's unstable feature use <em>for the sake of unstable feature use</em> in the compiler today</p>",
        "id": 210340873,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308258
    },
    {
        "content": "<p>That's never going to be the case. The next unstable feature will always be more expressive, otherwise it wouldn't get added to the language.</p>",
        "id": 210340874,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308262
    },
    {
        "content": "<p>People don't seriously propose features that make the language worse, so simply saying that \"well, today unstable is more expressive, so we should use it\" is the same as saying the same thing without 'today'.</p>",
        "id": 210340909,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308325
    },
    {
        "content": "<p>Seems like an argument to keep the unstable subset, then -- right? Like, I'm not sure that's always going to be true, rustc isn't after all desperately searching for new unstable features</p>",
        "id": 210340911,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308327
    },
    {
        "content": "<p>That's an argument that you have to pick, stable or unstable. Today isn't special. :P</p>",
        "id": 210340962,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308366
    },
    {
        "content": "<p>It's not an argument for unstable, it's an argument that tomorrow isn't going to change the math.</p>",
        "id": 210340971,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308393
    },
    {
        "content": "<p>My argument is that I don't see why that distinction matters that much <em>for rustc</em> -- I can definitely see it mattering for crates on <a href=\"http://crates.io\">crates.io</a> or in general</p>",
        "id": 210340972,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308395
    },
    {
        "content": "<p>And if it doesn't matter, then obviously I want rustc to be using the most expressive, easy to read, etc. feature set</p>",
        "id": 210340984,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308427
    },
    {
        "content": "<p>The distinction matters little for rustc because in order to use rust, you need to use rustc and it is delivered as binary to users</p>",
        "id": 210340991,
        "sender_full_name": "est31",
        "timestamp": 1600308442
    },
    {
        "content": "<p>any extension of the model isn't possible (like choosing select rustc crates for your own project)</p>",
        "id": 210341000,
        "sender_full_name": "est31",
        "timestamp": 1600308466
    },
    {
        "content": "<p>as I've (and other's) have mentioned before, the calculus would change for me <em>if</em> we had such crates</p>",
        "id": 210341049,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308498
    },
    {
        "content": "<p>I personally want rustc to use the feature set that results in it being the most stable and reliable.</p>",
        "id": 210341055,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308515
    },
    {
        "content": "<p>and indeed, e.g. rust-analyzer and the librarification effort has moved parts of the compiler closer to stable with that goal</p>",
        "id": 210341056,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308516
    },
    {
        "content": "<p>You can't for example make your own library-specific set of clippy lints (large part of clippy lints is: \"you could use  this feature of the std library\")</p>",
        "id": 210341057,
        "sender_full_name": "est31",
        "timestamp": 1600308516
    },
    {
        "content": "<p>but it would still change <em>for those crates</em>, not as a general decision</p>",
        "id": 210341073,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308550
    },
    {
        "content": "<p>If the next milestone is \"get clippy onto stable\", I'd be happy</p>",
        "id": 210341135,
        "sender_full_name": "est31",
        "timestamp": 1600308617
    },
    {
        "content": "<p>If that's the resolution of this MCP :)</p>",
        "id": 210341144,
        "sender_full_name": "est31",
        "timestamp": 1600308635
    },
    {
        "content": "<p>IMO that's basically not even a long-term goal at this point, we need to stabilize way too much</p>",
        "id": 210341146,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308638
    },
    {
        "content": "<p>like clippy on stable and the compiler on stable are equivalent in my eyes, or largely so, because clippy depends on the compiler</p>",
        "id": 210341159,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308661
    },
    {
        "content": "<p>Yeah they are pretty much close</p>",
        "id": 210341168,
        "sender_full_name": "est31",
        "timestamp": 1600308688
    },
    {
        "content": "<p>I mostly want it to compile on stable because that would mean I could build rustc in a third the time. Granted, there are other reasons, but I suspect those would be viewed poorly, even though I intend them genuinely.</p>",
        "id": 210341173,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308696
    },
    {
        "content": "<p>I don't understand how rustc compiling on stable speeds up your builds by 3x -- at most you'd avoid the minute or two of a single std build</p>",
        "id": 210341236,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308740
    },
    {
        "content": "<p>The last time I compiled rustc was years ago, but removing the concept of stages seems like it would be a huge win.</p>",
        "id": 210341263,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308786
    },
    {
        "content": "<p>Yeah build time benefit would be minor</p>",
        "id": 210341265,
        "sender_full_name": "est31",
        "timestamp": 1600308791
    },
    {
        "content": "<p>stages have nothing to do with this</p>",
        "id": 210341269,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308800
    },
    {
        "content": "<p>A rustc built on stable wouldn't require multiple stages.</p>",
        "id": 210341283,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308826
    },
    {
        "content": "<p>...no, it still would for sure</p>",
        "id": 210341291,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308835
    },
    {
        "content": "<p>So, I fail to see why that's not appealing.</p>",
        "id": 210341293,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308839
    },
    {
        "content": "<p>Clang doesn't require stages does it?</p>",
        "id": 210341331,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308849
    },
    {
        "content": "<p>You can make rustc not require stages as well</p>",
        "id": 210341342,
        "sender_full_name": "est31",
        "timestamp": 1600308881
    },
    {
        "content": "<p>Mostly they exist for testing purposes</p>",
        "id": 210341346,
        "sender_full_name": "est31",
        "timestamp": 1600308889
    },
    {
        "content": "<p>I.e. it is possible to write a production compiler that can bootstrap without having people always bootstrap.</p>",
        "id": 210341347,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308891
    },
    {
        "content": "<p>It has nothing to do with rustc being on stable</p>",
        "id": 210341355,
        "sender_full_name": "est31",
        "timestamp": 1600308903
    },
    {
        "content": "<p>like, a stage1 rustc build (which is what a no-stage clang build gives you) is fully functional</p>",
        "id": 210341358,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308903
    },
    {
        "content": "<p>and is indeed what 99% of rustc developers use</p>",
        "id": 210341364,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308920
    },
    {
        "content": "<p>Isn't it the case that currently, I have to build multiple stages just to know that I didn't break bootstrap?</p>",
        "id": 210341371,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600308941
    },
    {
        "content": "<p>I mean that's true of clang too?</p>",
        "id": 210341374,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308952
    },
    {
        "content": "<p>(I don't see how that's not true of <em>any</em> compiler)</p>",
        "id": 210341377,
        "sender_full_name": "simulacrum",
        "timestamp": 1600308961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"336395\">@Ahmed Charles</span> yes you need to run tests in order to be able to check whether tests run :)</p>",
        "id": 210341416,
        "sender_full_name": "est31",
        "timestamp": 1600308968
    },
    {
        "content": "<p>It's not, because clang doesn't make use of the most recent features, therefore, if you can build it with itself, you can always bootstrap.</p>",
        "id": 210341432,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309008
    },
    {
        "content": "<p>that's not testing bootstrapping</p>",
        "id": 210341438,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309023
    },
    {
        "content": "<p>or at least, not really</p>",
        "id": 210341441,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309026
    },
    {
        "content": "<p>That's my point though.</p>",
        "id": 210341447,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309035
    },
    {
        "content": "<p>There is no <code>#define BOOTSTRAP</code> in clang.</p>",
        "id": 210341456,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309065
    },
    {
        "content": "<p>Breaking bootstrap is possible, for example, a miscompilation could. But forgetting to place <code>#[cfg(bootstrap)]</code> in the right place isn't possible.</p>",
        "id": 210341520,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"336395\">@Ahmed Charles</span> maybe you confuse things? <code>#[cfg(bootstrap)]</code> is present in rustc right now, and if rustc were on stable, one wouldn't need it any more. That'S an advantage of rustc being on stable. But it has nothing to do with the fact that bootstrap <em>exists</em> in the first place</p>",
        "id": 210341541,
        "sender_full_name": "est31",
        "timestamp": 1600309152
    },
    {
        "content": "<p>I presume that C++'s standard libraries either use cfg(bootstrap) or feature detection of the compiler building them</p>",
        "id": 210341542,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309153
    },
    {
        "content": "<p>The std library does, but clang as a compiler doesn't.</p>",
        "id": 210341558,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309193
    },
    {
        "content": "<p>rust std = libc++, neither of which I'm talking about.</p>",
        "id": 210341609,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309221
    },
    {
        "content": "<p>rustc basically doesn't either</p>",
        "id": 210341611,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309225
    },
    {
        "content": "<p>(and in any case I don't see how it's relevant)</p>",
        "id": 210341613,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309235
    },
    {
        "content": "<p>clang builds on 5 year old compilers, is my point.</p>",
        "id": 210341622,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309258
    },
    {
        "content": "<p>That results in never needing to bootstrap for the average developer.</p>",
        "id": 210341639,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309288
    },
    {
        "content": "<p>That's their choice to limit themselves to C++11(?)</p>",
        "id": 210341646,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309295
    },
    {
        "content": "<p>the average (Rust) developer doesn't use a 5 years old rustc either</p>",
        "id": 210341657,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309311
    },
    {
        "content": "<p>I think it's now C++14 minus some stuff that isn't well supported.</p>",
        "id": 210341660,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309316
    },
    {
        "content": "<p>Yes, that IS an advantage of rustc compiling on stable again. It makes it easier to introduce a longer term MSRV regime like N year old compilers. But it's a separate decision.</p>",
        "id": 210341664,
        "sender_full_name": "est31",
        "timestamp": 1600309321
    },
    {
        "content": "<p>Rust 1.0 is 5 years old, so no. But that's not my point.</p>",
        "id": 210341711,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309343
    },
    {
        "content": "<p>Personally I feel rustc should follow what most of the ecosystem does, most of the ecosystem is on stable compilers but usually uses recent compilers as MSRV</p>",
        "id": 210341714,
        "sender_full_name": "est31",
        "timestamp": 1600309357
    },
    {
        "content": "<p>I would expect <em>even if</em> someone convinced me and others that this MCP was a good idea, we would need another one to even consider lowering MSRV requirements.</p>",
        "id": 210341716,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309363
    },
    {
        "content": "<p>I'm interested in rustc in 5 years being able to compile on stable, in the hope that working on it then will be as easy as working on clang now. :P</p>",
        "id": 210341740,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309405
    },
    {
        "content": "<p>Sure, the path is paved with the resistance of MCP's but fine. This is the first one, right? :P</p>",
        "id": 210341804,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309452
    },
    {
        "content": "<p>I am unconvinced that being able to use old compilers is a significant boost in \"ease of working on\"</p>",
        "id": 210341840,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309505
    },
    {
        "content": "<p>(or stable compilers)</p>",
        "id": 210341845,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309514
    },
    {
        "content": "<p>Is  needing a custom build system a hurdle? Sure, yes, definitely. But if you already have that, it does not seem much of a hurdle to -- like really any other nightly Rust project -- say \"please use this nightly\" (or in rustc's case, <em>this beta</em>)</p>",
        "id": 210341868,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309560
    },
    {
        "content": "<p>I.e in theory, this MCP is to answer the question of, if I submit two PR's tomorrow, 1) which removes <code>bool::then_some</code> from <code>compiler/</code> and 2) which stabilizes <code>bool::then_some</code>, then one of them will get chosen instead of both being rejected. Right?</p>",
        "id": 210341910,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309571
    },
    {
        "content": "<p>Well, it depends on your motivation</p>",
        "id": 210341920,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309597
    },
    {
        "content": "<p>Stabilizations require FCPs and team approvals</p>",
        "id": 210341923,
        "sender_full_name": "est31",
        "timestamp": 1600309602
    },
    {
        "content": "<p>if it's \"then_some is less readable in these places\" then I'd happily r+ that PR if I agree we do end up with more readable code</p>",
        "id": 210341927,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309620
    },
    {
        "content": "<p>if it's \"less unstable feature use\" then I don't personally consider that an argument, and no one's convinced me otherwise yet :)</p>",
        "id": 210341932,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309639
    },
    {
        "content": "<p>Sure, but if <code>bool::then_some</code> gets rejected for stabilization, then removing it should be feasible and the other PR accepted, right?</p>",
        "id": 210341935,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309648
    },
    {
        "content": "<p>Hence the goal of this MCP. To answer the higher level question of direction.</p>",
        "id": 210341940,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309670
    },
    {
        "content": "<p>Depends on the rejection. If it's \"we're removing it from std\", of course it would be removed?</p>",
        "id": 210341941,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309673
    },
    {
        "content": "<p>Removed from use in the compiler.</p>",
        "id": 210341983,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309687
    },
    {
        "content": "<p>Usually features in Rust don't get rejected, they just slow down and discussion threads span years while people are debating on whether to <em>really</em> remove it or not :)</p>",
        "id": 210341989,
        "sender_full_name": "est31",
        "timestamp": 1600309694
    },
    {
        "content": "<p>In general, if the MCP were accepted, I feel that there will be more pressure to stabilize the features</p>",
        "id": 210341996,
        "sender_full_name": "est31",
        "timestamp": 1600309714
    },
    {
        "content": "<p>I disagree personally that there will be increased speed of stabilization, and would actually expect opposite effect personally</p>",
        "id": 210342011,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309737
    },
    {
        "content": "<p>I want to be able to submit two PRs and say, \"pick\". And have people actually pick and make progress.</p>",
        "id": 210342023,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309752
    },
    {
        "content": "<p>That seems immensely helpful.</p>",
        "id": 210342028,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309769
    },
    {
        "content": "<p>Doesn't work that way, and I don't want this MCP to make it work that way</p>",
        "id": 210342038,
        "sender_full_name": "est31",
        "timestamp": 1600309788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"336395\">@Ahmed Charles</span> that's not how rust development works</p>",
        "id": 210342043,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309799
    },
    {
        "content": "<p>I don't mean that literally.</p>",
        "id": 210342064,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309804
    },
    {
        "content": "<p>and it seems unhelpful, to be honest, to say \"you have two options\" -- clearly, the options are many. One of the easiest is \"we're not sure yet\"</p>",
        "id": 210342094,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309827
    },
    {
        "content": "<p>But ultimately, it is illogical to never stabilize a feature while always using it in the compiler itself.</p>",
        "id": 210342106,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309840
    },
    {
        "content": "<p>but no one is making that argument?</p>",
        "id": 210342108,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309852
    },
    {
        "content": "<p>and surprise that easiest option is where 99% of the unstable features are :)</p>",
        "id": 210342109,
        "sender_full_name": "est31",
        "timestamp": 1600309854
    },
    {
        "content": "<p>I made the 'pick one of these two' as the extreme opposite of that.</p>",
        "id": 210342130,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309891
    },
    {
        "content": "<p>If it's illogical to not pick one, then one must be chosen.</p>",
        "id": 210342135,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309914
    },
    {
        "content": "<p>no?</p>",
        "id": 210342176,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309925
    },
    {
        "content": "<p>well, I mean, that's a leap</p>",
        "id": 210342180,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309938
    },
    {
        "content": "<p>you always have the option not to choose</p>",
        "id": 210342186,
        "sender_full_name": "oliver",
        "timestamp": 1600309946
    },
    {
        "content": "<p>It seems to be the logical conclusion.</p>",
        "id": 210342190,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309951
    },
    {
        "content": "<p>it is perfectly reasonable to not pick one, but just not make any decision yet</p>",
        "id": 210342193,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309957
    },
    {
        "content": "<p>\"But ultimately, it is illogical to never stabilize a feature while always using it in the compiler itself.\" is very different from \"illogical to not pick stabilization or removal <em>immediately</em>\"</p>",
        "id": 210342205,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309982
    },
    {
        "content": "<p>One of the choices is \"never stabilize\", so not choosing is in fact, choosing.</p>",
        "id": 210342206,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600309983
    },
    {
        "content": "<p>but no one is making that choice?</p>",
        "id": 210342210,
        "sender_full_name": "simulacrum",
        "timestamp": 1600309990
    },
    {
        "content": "<p>if someone were, then maybe, but that's really not a choice I recall us ever making</p>",
        "id": 210342221,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310007
    },
    {
        "content": "<p>Sure, that's why it's a logical argument taken to infinity.</p>",
        "id": 210342222,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310009
    },
    {
        "content": "<p>But clearly, I'm not being clear.</p>",
        "id": 210342224,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310016
    },
    {
        "content": "<p>I am confused</p>",
        "id": 210342225,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310020
    },
    {
        "content": "<p>it's arguing extremes</p>",
        "id": 210342275,
        "sender_full_name": "oliver",
        "timestamp": 1600310063
    },
    {
        "content": "<p>If I'm told that I can't submit a PR which removes an unstable feature from the compiler and I'm also told that I can't submit a PR to stabilize that feature, then the outcome is (lacking nuance) that the feature is permanently unstable.</p>",
        "id": 210342293,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310104
    },
    {
        "content": "<p>I don't think it's fair to equate stabilizing a feature with its use in the compiler</p>",
        "id": 210342321,
        "sender_full_name": "oliver",
        "timestamp": 1600310138
    },
    {
        "content": "<p>Nuance is critical, though, and that seems identical to saying \"we must never have unstable features because if they're unstable for a day then they will be unstable forever\"</p>",
        "id": 210342325,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310144
    },
    {
        "content": "<p>(which is obviously untrue)</p>",
        "id": 210342329,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310160
    },
    {
        "content": "<p>Nuance is critical for a specific feature. But I don't see how to apply it when considering all 61 currently used by the compiler.</p>",
        "id": 210342376,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310176
    },
    {
        "content": "<p>I think the discussion has reached a point where it's not helpful any more</p>",
        "id": 210342394,
        "sender_full_name": "est31",
        "timestamp": 1600310233
    },
    {
        "content": "<p>Perhaps I'll ask the other question. Am I welcome to pick a random unstable feature and remove it from the compiler, assuming I do so correctly and submit it?</p>",
        "id": 210342397,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310241
    },
    {
        "content": "<p>Maybe the best way to make progress on this isn't an MCP any more but a rustc fork that compiles on stable</p>",
        "id": 210342408,
        "sender_full_name": "est31",
        "timestamp": 1600310271
    },
    {
        "content": "<p>And upstream being welcome to take the patches</p>",
        "id": 210342413,
        "sender_full_name": "est31",
        "timestamp": 1600310281
    },
    {
        "content": "<p>If there's demand in the ecosystem, ppl will use it</p>",
        "id": 210342457,
        "sender_full_name": "est31",
        "timestamp": 1600310302
    },
    {
        "content": "<p>That's the most insightful question I can ask, I suppose.</p>",
        "id": 210342464,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"336395\">@Ahmed Charles</span> again, if your motivation is just \"oh no unstable feature\" then probably not</p>",
        "id": 210342472,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310327
    },
    {
        "content": "<p>But it's more work than an MCP and subsequently doing the porting to stable once</p>",
        "id": 210342478,
        "sender_full_name": "est31",
        "timestamp": 1600310337
    },
    {
        "content": "<p>I agree that so far I have not heard convincing arguments. I personally would not accept patches that are unconvincing in motivation to me :)</p>",
        "id": 210342492,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Sure, let's assume I pick the best possible random unstable feature that no one likes.</p>",
        "id": 210342498,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310381
    },
    {
        "content": "<p>Of course the main benefit of stable-only is for contributors only, so the fork has to go further than that (e.g. more tolerant MSRV regime)</p>",
        "id": 210342552,
        "sender_full_name": "est31",
        "timestamp": 1600310406
    },
    {
        "content": "<p>Again, it has nothing to do with \"unstable feature\"</p>",
        "id": 210342554,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310410
    },
    {
        "content": "<p>If your patch is an improvement to the compiler codebase, then it would likely get accepted. Regardless of what it does (modulo backwards compat etc of course)</p>",
        "id": 210342562,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310437
    },
    {
        "content": "<p>Sure, but that's the entire point of this MCP, as I see it. Is to say, \"Yes, removing unstable feature usage in the compiler is a worthwhile goal\"</p>",
        "id": 210342580,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310467
    },
    {
        "content": "<p>All roads lead to stabilization?</p>",
        "id": 210342587,
        "sender_full_name": "oliver",
        "timestamp": 1600310486
    },
    {
        "content": "<p>That's my understanding of the MCP, but I've not personally yet been convinced by either <span class=\"user-mention\" data-user-id=\"120096\">@est31</span> or anyone else arguing for this MCP that it <em>is</em> a worthwhile goal as a standalone thing at this point in time.</p>",
        "id": 210342607,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310519
    },
    {
        "content": "<p>So, it only has to do with \"unstable feature\".</p>",
        "id": 210342610,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310521
    },
    {
        "content": "<p>(The MCP has not yet been accepted, and current rustc policy definitely doesn't see unstable features as bad)</p>",
        "id": 210342666,
        "sender_full_name": "simulacrum",
        "timestamp": 1600310546
    },
    {
        "content": "<p>That's obvious.</p>",
        "id": 210342686,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600310583
    },
    {
        "content": "<p>Btw <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> offtopic but I'm working on rustc right now and tried out the binary LLVM download feature. It's much much nicer now! Now one only needs to have bootstrap not check out the llvm submodule if the feature is enabled. It takes over a gb of storage space :). 30% of my rustc checkout storage space use (including generated binaries!) is llvm submodule checkouts, but 2 of them are old/outdated.</p>",
        "id": 210349158,
        "sender_full_name": "est31",
        "timestamp": 1600319764
    },
    {
        "content": "<p>Also see <a href=\"https://github.com/rust-lang/rust/pull/76821\">https://github.com/rust-lang/rust/pull/76821</a> with some low hanging fruit, hopefully non-controversial</p>",
        "id": 210351457,
        "sender_full_name": "est31",
        "timestamp": 1600323087
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120096\">@est31</span> If you drop the last commit (<code>RawVec</code> -&gt; <code>Vec</code>), I don't think there would be any contention about accepting the PR. It seems like an obvious improvement to me regardless of this MCP.</p>",
        "id": 210374187,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1600340571
    },
    {
        "content": "<p>Great! It's now dropped</p>",
        "id": 210380974,
        "sender_full_name": "est31",
        "timestamp": 1600345516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210019890\">said</a>:</p>\n<blockquote>\n<p>I think where we disagree is 'small' roadbumps ;)</p>\n</blockquote>\n<p>compile times strike again <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/ui.20tests\">https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/ui.20tests</a></p>",
        "id": 210623717,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600533679
    },
    {
        "content": "<p>Thanks for making that PR, <span class=\"user-mention\" data-user-id=\"120096\">@est31</span>.  Definitely nice to cleanup the superfluous or exposed-on-stable ones, regardless of how this MCP goes.</p>",
        "id": 210780370,
        "sender_full_name": "scottmcm",
        "timestamp": 1600712477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120096\">@est31</span>  I haven't followed the whole conversation but there's a question I haven't seen answered: what are examples of nightly features that you feel make it harder for new contributors? I assume it's not just the concept of a nightly feature that you find to be a roadblock</p>",
        "id": 219295381,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607486046
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> I agree the concept of a nightly feature is easy to explain. It's more just that you won't find the nightly features themselves in Rust textbooks. some nightly features used by rustc are documented, but most are not, or underdocumented. And they are less commonly used, so most folks who come from the greater Rust ecosystem which is mostly on stable might not have encountered those features. Having to deal with them in the compiler adds to the mental burden.</p>",
        "id": 219461118,
        "sender_full_name": "est31",
        "timestamp": 1607600433
    },
    {
        "content": "<p>Like... rustc used to have a giant makefile as buildsystem. That was extremely weird for people coming from cargo projects. Nowadays it uses cargo instead and it's way more \"standard\", way more familiar for people. Originally the makefile made sense, as it predates cargo, but eventually its time came.</p>",
        "id": 219461351,
        "sender_full_name": "est31",
        "timestamp": 1607600616
    },
    {
        "content": "<p>@est31 I understand the idea. But for example all the nightly-only methods and traits are correctly documented and easy to find. And some other features are easy to understand despite their lack of documentation I think. That's why I'm asking you for specific examples of features you find hard to understand</p>",
        "id": 219466275,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607604116
    },
    {
        "content": "<p>Cause if the problem is documentation, that could be easier to solve than not using the features. For example we could improve the unstable book and mention it at the beginning of the rustc dev guide</p>",
        "id": 219466377,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607604172
    },
    {
        "content": "<p>i <em>thought</em> the main reason for the compiler to be buildable with stable was to make the bootstrap process simpler and also to make it easier for \"normal\" people to get into the compiler's development just using the stable version of rust they have from rustup</p>",
        "id": 219543114,
        "sender_full_name": "Lokathor",
        "timestamp": 1607639310
    },
    {
        "content": "<p>(deleted, network issue)</p>",
        "id": 219566985,
        "sender_full_name": "Nadrieril",
        "timestamp": 1607664053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210623717\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358/near/210019890\">said</a>:</p>\n<blockquote>\n<p>I think where we disagree is 'small' roadbumps ;)</p>\n</blockquote>\n<p>compile times strike again <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/ui.20tests\">https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/ui.20tests</a></p>\n</blockquote>\n<p>I don't understand how this proposal saves any time for that issue. If you change the compiler, you still need to build it before testing it. So <code>./x.py test src/test/ui --test-args XXX</code> (which is implicitly <code>--stage 1</code> these days) will not be any faster even if rustc can be built without nightly features, right?</p>",
        "id": 220569282,
        "sender_full_name": "RalfJ",
        "timestamp": 1608545589
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> to <a class=\"stream-topic\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358\">#t-compiler &gt; MCP: move compiler/ crates to stable Rust compiler-team#358</a></p>",
        "id": 221003222,
        "sender_full_name": "Notification Bot",
        "timestamp": 1609064861
    },
    {
        "content": "<p>while a discussion about mentoring is somewhat relevant here, I moved it to a different topic, as this here is about the <em>technical</em> aspects of making working on the Rust compiler easier (I'm not saying that making the Rust compiler work on stable is doing that or not). Let's keep the discussion about mentoring or other things not directly related to the MCP in the other thread.</p>",
        "id": 221003443,
        "sender_full_name": "oli",
        "timestamp": 1609065292
    }
]