[
    {
        "content": "<p>The associated GitHub issue has been renamed. Renaming this Zulip topic.</p>",
        "id": 253968048,
        "sender_full_name": "triagebot",
        "timestamp": 1632081577
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"311727\">@Harald Hoyer</span> <span class=\"user-mention\" data-user-id=\"404550\">@Mike Leany</span></p>",
        "id": 253968208,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632081687
    },
    {
        "content": "<p>What kind of object/executable files would be produced by x86_64-unknown-none?</p>",
        "id": 253976599,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632090889
    },
    {
        "content": "<p>I was doing a build of binutils to see what it does; apparently the target isn't supported.<br>\nQuestion, then: would x86_64-{unknown,pc}-elf be a good target name? <br>\nThis has existing support in GNU binutils and gcc, and is recognized as a \"generic x86_64 target producing elf files\" (the osdev wiki, for example, suggests using it for cross compilation until you're ready to add your own custom target). It also opens the door for other, similar, targets like x86_64-unknown-coff.<br>\nThis would help with compatibility between toolchains and things handling targets.</p>",
        "id": 253977207,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632091627
    },
    {
        "content": "<p><code>rustc --print target-list | grep none</code> shows quite a mix already -- risc-v went with <code>unknown-none-elf</code>; arm/thumb use <code>none-eabi[hf]</code>; aarch64, bpf, and mips use <code>unknown-none</code>.</p>",
        "id": 253981403,
        "sender_full_name": "cuviper",
        "timestamp": 1632096084
    },
    {
        "content": "<p>I would say <code>x86_64-unknown-none-elf</code> is the best. Having ELF in the name clearly suggests the output format, and open possibility for other object file formats; on the other hand, the \"none\" part will clearly suggest that there are no \"C library support implied\".</p>",
        "id": 253982629,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632097317
    },
    {
        "content": "<p>um, aren't these supposed to be triples?</p>",
        "id": 253982861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632097548
    },
    {
        "content": "<p>having three <code>-</code> in the name will break scripts et al</p>",
        "id": 253982880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632097562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Tier.203.20target.20proposal.3A.20x86_64-unknown-no.E2.80.A6.20compiler-team.23462/near/253982880\">said</a>:</p>\n<blockquote>\n<p>having three <code>-</code> in the name will break scripts et al</p>\n</blockquote>\n<p>No, targets can have 3 or 4 components. x86_64-pc-linux-gnu is an example.</p>",
        "id": 253982955,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632097646
    },
    {
        "content": "<p>I'd be more worried that <code>x86_64-unknown-none-elf</code> isn't a target that's supported by existing toolchains. My personal preference is that targets should be moving towards compatibility between toolchains, which is why I mentioned x86_64-unknown-elf specifically. Not only is it a well known target name for the purpose (as mentioned, the <code>elf</code> system is suggested by the osdev wiki <a href=\"https://wiki.osdev.org/Target_Triplet\">https://wiki.osdev.org/Target_Triplet</a>), but it also has existing support in the GNU toolchain.</p>",
        "id": 253983329,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632098043
    },
    {
        "content": "<p>Well my RISC-V gcc cross compiler is prefixed with <code>riscv64-unknown-elf-</code> but Rust target is named <code>riscv64gc-unknown-none-elf</code>.</p>",
        "id": 253984140,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632098897
    },
    {
        "content": "<p>Most Rust targets do not match GCC targets, so a translation is necessary already</p>",
        "id": 253984385,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632099131
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton/cc-rs/blob/178fd031e74f643721605e25110ee6abce8dbe05/src/lib.rs\">https://github.com/alexcrichton/cc-rs/blob/178fd031e74f643721605e25110ee6abce8dbe05/src/lib.rs</a></p>",
        "id": 253984396,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632099138
    },
    {
        "content": "<p>Yes, I know about that. (I've dealt with it - I have a proposal planned to rectify that).</p>\n<p>Right now, my goal here is to lessen the divergence with the instant target, hense my suggestion.</p>",
        "id": 253984458,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632099217
    },
    {
        "content": "<p>My view is that we shouldn't force ourselves to align with GCC, and we should choose a name that describes the target best.</p>",
        "id": 253984717,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632099476
    },
    {
        "content": "<p>I am actually curious about <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span>'s view about this.</p>",
        "id": 253984886,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632099604
    },
    {
        "content": "<p>Forcing translation runs into issues when there are (potentially slight) semantic differences in targets. I've mentioned this a few times in the past.<br>\nRight now, using the x86_64-pc-linux-gnu target with rust forces you to step through <code>x86_64-unknown-linux-gnu</code>, but if you need to pull the gcc target out of the rust target, you can't do so losslessly (which means that if you encoded information in otherwise semantically unused components, you need to work arround that at the rustc level). It also makes handling those mappings difficult. I currently have over 100 lines of sh doing the mapping,in &lt;<a href=\"https://github.com/chorman0773/rust-autotools\">https://github.com/chorman0773/rust-autotools</a>&gt; (<a href=\"https://github.com/chorman0773/rust-autotools/blob/main/m4/lcrust_prog_rustc.m4#L33..L140\">https://github.com/chorman0773/rust-autotools/blob/main/m4/lcrust_prog_rustc.m4#L33..L140</a>), and I'd prefer not to have to make it longer, that makes it harder to maintain, and easier to be wrong.</p>",
        "id": 253985232,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632099902
    },
    {
        "content": "<p>So, there are a few issues with using <code>x86_64-unknown-elf</code>, primarily that that target name exists in some toolchains but with a different meaning, namely including a newlib C library.</p>",
        "id": 254006844,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632121998
    },
    {
        "content": "<p>I don't want to unintentionally pick up someone's C toolchain that will not actually be compatible.</p>",
        "id": 254006947,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632122063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Tier.203.20target.20proposal.3A.20x86_64-unknown-no.E2.80.A6.20compiler-team.23462/near/253981403\">said</a>:</p>\n<blockquote>\n<p><code>rustc --print target-list | grep none</code> shows quite a mix already -- risc-v went with <code>unknown-none-elf</code>; arm/thumb use <code>none-eabi[hf]</code>; aarch64, bpf, and mips use <code>unknown-none</code>.</p>\n</blockquote>\n<p>I think there's a little more consistency there than the naming suggests. Suffixes like <code>eabi</code>, <code>eabihf</code>, or <code>softfloat</code> are ABIs, and in these cases they're more an extension of the CPU field than they are the OS field. If you ignore those ABI suffixes, there's only two: RISC-V uses -unknown-none-elf, and <em>everything else</em> uses <code>-unknown-none</code>.</p>",
        "id": 254007182,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632122235
    },
    {
        "content": "<p>The two reasons I proposed <code>-unknown-none</code>:</p>\n<ul>\n<li>Every freestanding/bare-metal Rust target other than RISC-V uses <code>-unknown-none</code>, and we should try to be as consistent as possible.</li>\n<li>I've seen many instances of toolchains where the <code>-elf</code> suffix indicated a toolchain that wasn't actually suitable for some standalone usage, because invoking it implied a C library.</li>\n</ul>",
        "id": 254007394,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632122365
    },
    {
        "content": "<p>On top of that, many embedded/freestanding/bare-metal users will need to use a linker script anyway, and linker scripts allow you to change the output format for the final object, using <code>OUTPUT_FORMAT</code>.</p>",
        "id": 254007544,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632122458
    },
    {
        "content": "<p>So in a way, ELF is just the <em>default</em> object format, not the <em>only</em> object format.</p>",
        "id": 254007573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632122474
    },
    {
        "content": "<p>Using <code>OUTPUT_FOTMAT</code> isn't sufficient I think. Different object formats require the compiler to codegen certain constructs in different ways. For example TLS is handled using completely different instruction sequences between object formats. And there are different ways to import and export symbols from dylibs. I don't think a linker can fix these after compilation.</p>",
        "id": 254008981,
        "sender_full_name": "bjorn3",
        "timestamp": 1632123429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> That's true, though I don't expect people to typically use this with dylibs (since a dynamic linker would imply a great deal more OS support, or a bare-metal system that has manually implemented its own dynamic module loader).</p>",
        "id": 254015884,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632127588
    },
    {
        "content": "<p>I'm not suggesting it's perfectly convertible, just that in the cases where someone wants an alternative, it may be possible. Also, I've never seen an embedded system use PE, other than UEFI (which has its own target).</p>",
        "id": 254015927,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632127620
    },
    {
        "content": "<p>(Doesn't mean there aren't any, but to the best of my knowledge it's much less common.)</p>",
        "id": 254015985,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632127661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Tier.203.20target.20proposal.3A.20x86_64-unknown-no.E2.80.A6.20compiler-team.23462/near/254006947\">said</a>:</p>\n<blockquote>\n<p>I don't want to unintentionally pick up someone's C toolchain that will not actually be compatible.</p>\n</blockquote>\n<p>You'd probably have this problem anyways. As mentioned, the target doesn't exist for GNU toolchains, so when picking a linker, you'd (potentially) need to convert to <code>x86_64-{pc,unknown}-elf</code> anyways, which runs into the same issue.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Tier.203.20target.20proposal.3A.20x86_64-unknown-no.E2.80.A6.20compiler-team.23462/near/254007544\">said</a>:</p>\n<blockquote>\n<p>On top of that, many embedded/freestanding/bare-metal users will need to use a linker script anyway, and linker scripts allow you to change the output format for the final object, using <code>OUTPUT_FORMAT</code>.</p>\n</blockquote>\n<p><code>OUTPUT_FORMAT</code> won't affect the format of intermediate files. If you need coff objects for one reason or another (maybe you have coff files to link in from a different source), then this won't be an option available, and you'd need another step to convert (<code>objcopy</code> is a way to do this).</p>",
        "id": 254026921,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632133161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Tier.203.20target.20proposal.3A.20x86_64-unknown-no.E2.80.A6.20compiler-team.23462/near/254007182\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Tier.203.20target.20proposal.3A.20x86_64-unknown-no.E2.80.A6.20compiler-team.23462/near/253981403\">said</a>:</p>\n<blockquote>\n<p><code>rustc --print target-list | grep none</code> shows quite a mix already -- risc-v went with <code>unknown-none-elf</code>; arm/thumb use <code>none-eabi[hf]</code>; aarch64, bpf, and mips use <code>unknown-none</code>.</p>\n</blockquote>\n<p>I think there's a little more consistency there than the naming suggests. Suffixes like <code>eabi</code>, <code>eabihf</code>, or <code>softfloat</code> are ABIs, and in these cases they're more an extension of the CPU field than they are the OS field. If you ignore those ABI suffixes, there's only two: RISC-V uses -unknown-none-elf, and <em>everything else</em> uses <code>-unknown-none</code>.</p>\n</blockquote>\n<p>Not quite -- apart from the ABI suffix, the arm/thumb targets also don't have <code>unknown</code>, e.g. <code>armv7a-none-eabi</code></p>",
        "id": 254064280,
        "sender_full_name": "cuviper",
        "timestamp": 1632150212
    },
    {
        "content": "<p>there's also <code>msp430-none-elf</code>, so we have all 4 variations toggling <code>unknown</code> or <code>elf</code></p>",
        "id": 254065403,
        "sender_full_name": "cuviper",
        "timestamp": 1632150679
    },
    {
        "content": "<p>the only consistency is <code>none</code></p>",
        "id": 254065419,
        "sender_full_name": "cuviper",
        "timestamp": 1632150685
    },
    {
        "content": "<p>we can try to do better, of course -- my point is just that you can't really argue precedent here</p>",
        "id": 254065768,
        "sender_full_name": "cuviper",
        "timestamp": 1632150816
    },
    {
        "content": "<p>Would it be feasible to document somewhere the difference between this new target and using the existing x86_64-unknown-linux-gnu with <code>no_std</code>?</p>",
        "id": 254077496,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1632155177
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"404395\">@Dan Gohman</span> Using <code>#[no_std]</code> still expects to run as a Linux kernel userspace process, with a main entry point and system calls.</p>",
        "id": 254078205,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632155482
    },
    {
        "content": "<p>I see the point about <code>main</code>, but does <code>no_main</code> change that? Also, what system calls does <code>core</code> make? I'm not objecting; I'm just interested in learning how these parts of the toolchain work :-).</p>",
        "id": 254078886,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1632155739
    },
    {
        "content": "<p>Ah, perhaps it's that even with no_std/no_main, <code>target_os</code> is still <code>linux</code>, so existing Rust code may assume it's running on a Linux box and can make syscalls.</p>",
        "id": 254079567,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1632156020
    },
    {
        "content": "<p>Right, that's a big part of it as well.</p>",
        "id": 254080464,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632156406
    },
    {
        "content": "<p>You'd have to use <code>#[no_main]</code>, and <code>#[no_std]</code>, and provide your own allocator or not use alloc, and then it <em>might</em> work with a lot of care, but you could very easily accidentally end up with a syscall.</p>",
        "id": 254080614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632156469
    },
    {
        "content": "<p>It makes sense to have a separate freestanding target.</p>",
        "id": 254080688,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632156489
    },
    {
        "content": "<p>Should we be having a broader discussion about the naming conventions that we use for these various targets? <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> said some related questions came up in <a href=\"https://github.com/rust-lang/rust/issues/88991\">#88991</a>, which seems to imply that we need broader guidelines?</p>",
        "id": 255574493,
        "sender_full_name": "pnkfelix",
        "timestamp": 1633008860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I think we should have that broader discussion, but I would personally prefer that we pick one of the two reasonable names and move forward with it.</p>",
        "id": 255793389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633115464
    },
    {
        "content": "<p>We already have some targets using one name pattern and some using the other.</p>",
        "id": 255793425,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633115481
    },
    {
        "content": "<p>So since consistency alone doesn't push us unambiguously in one direction or the other, I'd propose that we should have that conversation in parallel, but I'd propose that we could add a tier 3 target (which people have to build from source to use anyway) and have the conversation while the target works its way to tier 2.</p>",
        "id": 255793833,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633115680
    },
    {
        "content": "<p>Okay. I agree that the broader discussion need to block progress here.</p>",
        "id": 255807152,
        "sender_full_name": "pnkfelix",
        "timestamp": 1633122099
    },
    {
        "content": "<p>I'm fine continuing the conversation about target naming without blocking new Tier 3 targets.</p>",
        "id": 257552281,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1634224491
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"492\">@T-compiler</span>: Proposal <a href=\"https://github.com/rust-lang/compiler-team/issues/462#issuecomment-943457151\">#462</a> has been seconded, and will be approved in 10 days if no objections are raised.</p>",
        "id": 257552359,
        "sender_full_name": "triagebot",
        "timestamp": 1634224516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> Thank you!</p>",
        "id": 257555099,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634225480
    },
    {
        "content": "<p>This proposal has been accepted: <a href=\"https://github.com/rust-lang/compiler-team/issues/462\">#462</a>.</p>",
        "id": 259352422,
        "sender_full_name": "triagebot",
        "timestamp": 1635408009
    },
    {
        "content": "<p>What does it take to promote this to Tier 2 with <code>core</code> and <code>alloc</code> built?</p>",
        "id": 265297330,
        "sender_full_name": "Harald Hoyer",
        "timestamp": 1639749064
    },
    {
        "content": "<p>As I understand, this would probably require a new MCP and a PR adding it to CI and updating the platform support documentation. For most targets, <code>std</code> would have to be implemented, but we should get an exception since it \"cannot possibly be supported on the target.\"</p>",
        "id": 265648446,
        "sender_full_name": "Mike Leany",
        "timestamp": 1640063797
    }
]