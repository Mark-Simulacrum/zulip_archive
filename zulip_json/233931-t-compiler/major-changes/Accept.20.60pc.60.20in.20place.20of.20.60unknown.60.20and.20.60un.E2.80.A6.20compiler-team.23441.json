[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/441\">Accept <code>pc</code> in place of <code>unknown</code> and <code>unknown</code> in place of <code>pc</code> for <code>x86_64</code> and <code>i?86</code> targets #441</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 243265298,
        "sender_full_name": "triagebot",
        "timestamp": 1624131168
    },
    {
        "content": "<p>fwiw, I really appreciate that rustc only uses a single canonical string for a target. Having aliases can cause confusion, and makes any tool that needs to deal with triples deal with the aliasing problems. For example, Cargo itself assumes there is a single triple, and its cfg matching wouldn't know about the aliases.</p>\n<p>I'm a bit uncertain from the context of the proposal. It seems like there is a desire to try to match GNU-style triples with rustc-style triples. Is that what the script is trying to do? It seems like that is a much larger problem than just differences of pc and unknown. My understanding of <a href=\"https://github.com/gcc-mirror/gcc/blob/master/config.guess\">config.guess</a> and GNU-style triples is that it supports a large number of heuristics for matching target triples, and those can be changed by distros to all sorts of different variants. I would be surprised if just pc and unknown would be sufficient to map the two in general.</p>",
        "id": 243269470,
        "sender_full_name": "Eric Huss",
        "timestamp": 1624137356
    },
    {
        "content": "<p>Cargo cfg matching uses <code>rustc --print cfg</code> so it would work fine with aliasing targets as soon as rustc supports it.</p>",
        "id": 243270461,
        "sender_full_name": "bjorn3",
        "timestamp": 1624138892
    },
    {
        "content": "<p>Not for exact target name matches.  And same with any build script or anything else that inspects the target name.  (though I think that practice is flawed, and I'm disappointed that exact target name matching is going to be added to <code>cfg</code>).</p>",
        "id": 243271824,
        "sender_full_name": "Eric Huss",
        "timestamp": 1624141079
    },
    {
        "content": "<p>I would rather eliminate the <code>pc</code> and <code>unknown</code> tag altogether, and simply refer to Windows as e.g. <code>x86_64-windows-msvc</code></p>",
        "id": 243271992,
        "sender_full_name": "Jubilee",
        "timestamp": 1624141371
    },
    {
        "content": "<blockquote>\n<p>I'm a bit uncertain from the context of the proposal. It seems like there is a desire to try to match GNU-style triples with rustc-style triples. Is that what the script is trying to do? It seems like that is a much larger problem than just differences of pc and unknown. </p>\n</blockquote>\n<p>If you are referring to the script I linked in the issue, right now, yes, that's what it's doing. It attempts to fix the host target name to one acceptable to the rust compiler detected previously. Since it's using the value of $host from autotools (this is an m4 macro), it will be automatically detected (if not overridden at the --build or --host levels) which is where the issue is (though it's not apparent there, as host checking isn't performed if --host isn't specified). As a result, I use a serious of nested case and if blocks to attempt to find a correct variation that is accepted.<br>\nThe current issues I've noted are pc vs. unknown as well as the generalization of i?86 (rustc only accepts i586 and i686 for linux and windows. I believe there is at least one i486.)</p>\n<p>I would note that the proposal is not to change the name of rustc's targets here, simply to accept these cases when passed explicitly to --target.</p>",
        "id": 243273354,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624143523
    },
    {
        "content": "<blockquote>\n<p>Not for exact target name matches.  And same with any build script or anything else that inspects the target name.  (though I think that practice is flawed, and I'm disappointed that exact target name matching is going to be added to <code>cfg</code>).</p>\n</blockquote>\n<p>Exact name matching can be useful (eg. invoking other toolchains), and in those cases you may <em>want</em> a particular form as the end user.</p>",
        "id": 243273426,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624143648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/243271992\">said</a>:</p>\n<blockquote>\n<p>I would rather eliminate the <code>pc</code> and <code>unknown</code> tag altogether, and simply refer to Windows as e.g. <code>x86_64-windows-msvc</code></p>\n</blockquote>\n<p>That would change the form of the target, though. While <code>pc</code> and <code>unknown</code> vendors are generally not distinct (for x86_64 and ix86), some are (for example, <code>x86_64-apple-darwin</code> is functionally distinct from <code>x86_64-unknown-darwin</code> or <code>x86_64-pc-darwin</code>)</p>",
        "id": 243273781,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624144253
    },
    {
        "content": "<p>Sure, but we don't meaningfully support the distinction.</p>",
        "id": 243276950,
        "sender_full_name": "Jubilee",
        "timestamp": 1624148894
    },
    {
        "content": "<p>If we decided to have an <code>unknown-darwin</code> target that is, say, PureDarwin on a possibly-non-Apple-provided PC, that's fine.<br>\nMy argument is simply that it functionally is just one token for us. Truncating unnecessary data from the token is fine.</p>",
        "id": 243277229,
        "sender_full_name": "Jubilee",
        "timestamp": 1624149338
    },
    {
        "content": "<p>In any case, that would also operate counter to my proposal, which is intended to make it easier to use non-cargo tooling (such as autotools).</p>",
        "id": 243280530,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624154633
    },
    {
        "content": "<p>Another reasonable use would be to nail down the semantics for non-rustc compilers.<br>\ngcc-rs will likely support every gcc target reguardless, including target aliases. This may or may not be less of a concern, because gcc is a single-target toolchain, so it will never be able to compile for both <code>x86_64-pc-linux-gnu</code> and <code>x86_64-unknown-linux-gnu</code> (despite them otherwise being semantically identical). <br>\n&lt;<a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a>&gt;, being written by myself, also would differ in that the frontend, which  would query target properties via the middle architecture library <code>libxlang</code>, would never be able to observe the difference, unless it needed to access the exact target name for various reasons (such as setting implicit cfg flags, such as <code>target</code>). In xlang itself, <code>Target{Architecture::X86_64,Vendor::PC,OperatingSystem::Linux,Environment::GNU,BinaryFormat::None}</code> (is the canonical representation of <code>x86_64-pc-linux-gnu</code>) maps to the same <code>const TargetDescriptor*</code> as <code>Target{Architecture::X86_64,Vendor::Unknown,OperatingSystem::Linux,Environment::GNU,BinaryFormat::None}</code>. Thus, if there are issues with aliasing targets, my <em>strong</em> preference is that they be resolved.</p>",
        "id": 243300015,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624190614
    },
    {
        "content": "<p>I mean I don’t think the <code>pc</code> variant doesn’t have to be a literal alias, you could have distinct <code>unknown</code> and <code>pc</code> target variants for platforms that are functionally the same, so to rustc they’re two separate targets, but behind the scenes they’re derived from the same target spec with the only difference being the vendor name, similar to the base targets we already have today.</p>\n<p>That would fulfill the same goal of having compatibility with other tools.</p>",
        "id": 243303693,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1624196861
    },
    {
        "content": "<p>My understanding is our targets don't precisely match GCC's understanding of the targets, so that the apparent naming compatibility is somewhat misleading. Thus, I am in favor not of making them more alike but instead further differentiating them.</p>",
        "id": 243315973,
        "sender_full_name": "Jubilee",
        "timestamp": 1624214923
    },
    {
        "content": "<p>e.g. I believe i686 is a Pentium Pro to GCC and a Pentium 4 to Rust.<br>\nWhile this may seem somewhat orthogonal, if the goal of this is to provide seamless compatibility with GCC tooling, then we've already failed that.</p>",
        "id": 243316341,
        "sender_full_name": "Jubilee",
        "timestamp": 1624215487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/243316341\">said</a>:</p>\n<blockquote>\n<p>e.g. I believe i686 is a Pentium Pro to GCC and a Pentium 4 to Rust.<br>\nWhile this may seem somewhat orthogonal, if the goal of this is to provide seamless compatibility with GCC tooling, then we've already failed that.</p>\n</blockquote>\n<p>Isn't this technically wrong on the part of rustc, though (may or may not be an issue)? The sixth generation x86, 80686 or i686, is the Pentium Pro (from intel, at least).  <a href=\"https://en.wikipedia.org/wiki/X86#Chronology\">Wikipedia</a> seems to list Pentium 4 under \"Enhanced Platform\", not under 6th generation. That being said, I assume this is somewhat of a lesser issue, unless someone actually tries compiling for a Pentium Pro. I'm not looking for 100% seamless compatibility, just better compatibility with such tooling without absolute hacks being necessary, as well as compatibility with compilers that do use GNU-style tuples.</p>",
        "id": 243317736,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624217515
    },
    {
        "content": "<blockquote>\n<p>Isn't this technically wrong on the part of rustc</p>\n</blockquote>\n<p>Yes, rustc is wrong here, but I believe that part of the reason i686 and i586 are separated is so that i686 would allow access to the target features present on common 64bit-capable hardware (namely sse and sse2). If my understanding is correct, then doing the \"correct\" thing here would somewhat defeat the point of having these targets.</p>",
        "id": 243318476,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624218577
    },
    {
        "content": "<p>That's probably also wrong, if the intent is to allow 32-bit programs on a 64-bit machine.</p>",
        "id": 243318564,
        "sender_full_name": "Jubilee",
        "timestamp": 1624218708
    },
    {
        "content": "<p>Don't really need to look for 4D chess moves in all this. Targets grew in a very ad-hoc manner and in most cases making decisions about the targets went the way of \"seemed reasonable to do it like this at the time\". GNU toolchains made these arbitrary-ish decisions in somewhat a different direction. Where rust mostly worked backwards from \"what would make sense for this target name _today_?\", gnu toolchains mostly went \"what the name should be for this new hardware?\"</p>",
        "id": 243318803,
        "sender_full_name": "nagisa",
        "timestamp": 1624219065
    },
    {
        "content": "<p>Right.</p>",
        "id": 243318856,
        "sender_full_name": "Jubilee",
        "timestamp": 1624219129
    },
    {
        "content": "<p>But at the same time, GNU made sure that many names that could make sense are treated as the correct names in the end. Rust makes no such attempt currently.</p>",
        "id": 243318944,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1624219298
    },
    {
        "content": "<p>Might not be too late. Just nobody cared about the naive implementation enough to work it to completion of some sort.</p>",
        "id": 243319007,
        "sender_full_name": "nagisa",
        "timestamp": 1624219371
    },
    {
        "content": "<p>In any case, my argument is that harmonizing the names with GCC re: <code>pc</code> and <code>unknown</code> without reconciling our differences in this regard is removing the appearance of a seam when there is very much a seam there. I have already had to be corrected on certain misunderstandings because I thought there was a direct parallel between Rust's tuples and the GNU build system's tuples. Providing more illusory seamlessness does not seem like a good time. I don't want others to have more opportunities to make my mistakes.</p>\n<p>If the differences are reconciled... well, I do not know if adopting GNU's decisions wholesale is a good idea either. But I would obviously wholly retract my objection re: making convenient something that should be (slightly) inconvenient.</p>",
        "id": 243319101,
        "sender_full_name": "Jubilee",
        "timestamp": 1624219547
    },
    {
        "content": "<p>Some newer targets like wasm32-wasi dropped the -unknown- part. If anything I would be in favor of renaming eg x86_64-unknown-linux-gnu to  x86_64-linux-gnu and making the former an alias to the later. That also more closely matches the target names debian uses. (It uses amd64 instead of x86_64 though I think.)</p>",
        "id": 243319342,
        "sender_full_name": "bjorn3",
        "timestamp": 1624219821
    },
    {
        "content": "<p><code>pc</code> vs <code>unknown</code> seems to not actually be a difference on x86; it's just different defaults for that slot.</p>\n<p>The field is just part of the standard target tuple format, and it was easier to keep it around with a placeholder value than eliminate it.</p>",
        "id": 243319438,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1624220002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/243319342\">said</a>:</p>\n<blockquote>\n<p>Some newer targets like wasm32-wasi dropped the -unknown- part. If anything I would be in favor of renaming eg x86_64-unknown-linux-gnu to  x86_64-linux-gnu and making the former an alias to the later. That also more closely matches the target names debian uses. (It uses amd64 instead of x86_64 though I think.)</p>\n</blockquote>\n<p>Well, <code>x86_64-linux-gnu</code> is also a useful target, but it's not a canonical target, at least as far as config.sub is concerned. In fact, <code>x86_64-linux-gnu</code> canonicalizes to <code>x86_64-pc-linux-gnu</code>. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"396093\">Ray Redondo</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/243319438\">said</a>:</p>\n<blockquote>\n<p><code>pc</code> vs <code>unknown</code> seems to not actually be a difference on x86; it's just different defaults for that slot.</p>\n<p>The field is just part of the standard target tuple format, and it was easier to keep it around with a placeholder value than eliminate it.</p>\n</blockquote>\n<p><code>pc</code> and <code>unknown</code> are indeed not functionally distinct on i?86 or x86_64. The slot was kept to keep a consistent canonical form, as there are some architectures (and some vendors) where the vendor field is menaingful. Having consistenly 3 parts (where the third can sometimes be further split), makes it easier to split, and to match individual components, especially in shell scripting. Having worked on <code>config.sub</code> and also <a href=\"https://crates.io/crates/target-tuples\">https://crates.io/crates/target-tuples</a>, the consistent form of canonical targets is actually incredibly helpful (and working with non-canonical forms is also painful).</p>",
        "id": 243320410,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624221524
    },
    {
        "content": "<p>In any case, based on further discussion on the IRLO thread (&lt;<a href=\"https://internals.rust-lang.org/t/expand-targets-acceptable-to-rustc/14885/16\">https://internals.rust-lang.org/t/expand-targets-acceptable-to-rustc/14885/16</a>&gt;), I believe this is something that warrants an RFC. Am I correct in assuming that an MCP can move to an RFC after approval for t-compiler?</p>",
        "id": 243320808,
        "sender_full_name": "Connor Horman",
        "timestamp": 1624222180
    },
    {
        "content": "<p>...So, now that we have extended key-value attributes stabilized by <a href=\"https://github.com/rust-lang/rust/pull/83366\">https://github.com/rust-lang/rust/pull/83366</a>, forgive me if I don't understand what it enables, but would it be possible to define a Target type with appropriate fields that allows (non-exhaustive, of course) pattern-matching on real types with real paths instead of strings? Forgive me if I don't understand.</p>\n<p>There are many errors related to the \"string typing\" interfaces of current targets such that I believe moving away from it would be preferable, and I believe we'd actually have a much easier time <strong>defining</strong> aliases to those real types if we actually had them, as well.</p>",
        "id": 243323034,
        "sender_full_name": "Jubilee",
        "timestamp": 1624225274
    },
    {
        "content": "<p>then \"pc\" and \"unknown\" becomes <code>Target { vendor: Unknown, .. }</code><br>\nand then when we talk about making the strings aliases, we know what the real value that we're pointing to is.</p>",
        "id": 243323182,
        "sender_full_name": "Jubilee",
        "timestamp": 1624225472
    },
    {
        "content": "<p>Sorry, I realize that this is getting a bit afield.</p>",
        "id": 243323287,
        "sender_full_name": "Jubilee",
        "timestamp": 1624225616
    },
    {
        "content": "<p>I don't understand how key-value attributes are related.</p>",
        "id": 243323302,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624225665
    },
    {
        "content": "<p>they look like <code>#[KEY = VALUE]</code>, where <code>VALUE</code> may include 0 or more macros as long as they expand to a literal</p>",
        "id": 243323367,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624225720
    },
    {
        "content": "<p>the one used most often is <code>#[doc = include_str!(\"x.md\")]</code></p>",
        "id": 243323622,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624226103
    },
    {
        "content": "<p><del>The problem (or rather the good thing) with targets is that they are a map of string to target definition on the compiler side, rather than the language side.</del></p>\n<p>Lets see if I can reword this to read right:</p>\n<p>The good thing: the target string to target definition is entirely a compiler-side thing (that's good, it means we can change it)<br>\nThe bad thing: its a direct string -&gt; definition map, not something smarter (that's bad)</p>",
        "id": 243324241,
        "sender_full_name": "nagisa",
        "timestamp": 1624227074
    },
    {
        "content": "<p>Though <a href=\"https://github.com/rust-lang/rfcs/pull/2991\">https://github.com/rust-lang/rfcs/pull/2991</a> is set to bake the target strings into the language too.</p>",
        "id": 243324249,
        "sender_full_name": "nagisa",
        "timestamp": 1624227107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> I’m not sure it’s correct to interpret <a href=\"https://github.com/rust-lang/rfcs/issues/2991\">rfcs#2991</a> as baking the string values into the language, as that would be incompatible with the target tier policy. We have reserved the right to remove targets so it’s perfectly valid for <code>#[cfg(target = “arch-vendor-env”)]</code> to work in one release, never in the next release, and then work again in another release.</p>\n<p>Additionally there are custom targets which get to set the names, so people are already using <code>cfg</code> with target components that aren’t available by default to the compiler.</p>",
        "id": 243326159,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1624230265
    },
    {
        "content": "<p>(Custom targets aren't stable, though, right? To some extent I guess that's <a href=\"https://github.com/rust-lang/rust/issues/71009\">https://github.com/rust-lang/rust/issues/71009</a>...)</p>",
        "id": 243326437,
        "sender_full_name": "simulacrum",
        "timestamp": 1624230802
    },
    {
        "content": "<p>I don't consider the target components to share the same issues for the purposes of this as they come from the target definition not the target string. Most notably target_arch will not always match the first component of the target triple and there isn't really a widespread expectation that it would.</p>",
        "id": 243326702,
        "sender_full_name": "nagisa",
        "timestamp": 1624231260
    },
    {
        "content": "<p>Target strings also aren't quite a combination of target arch/vendor/os/env though it might be interesting if they were canonically.</p>",
        "id": 243326799,
        "sender_full_name": "nagisa",
        "timestamp": 1624231434
    },
    {
        "content": "<p>Sure, I was just mostly trying to have a example, without getting caught up in the specifics of a real target.</p>",
        "id": 243332384,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1624240627
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Ah I didn’t know that was not intentional, the embedded WG use it in their guides, so I assumed it was intentional. Though the ship might have sailed in my opinion for disabling custom targets through JSON outright, because this is something being relied on in production situations. There are targets that simply can’t ever be put in rustc because they are proprietary and confidential to the point that you can’t contain any references unless it’s under NDA. These platforms need a custom target spec, and I feel like too many may already depend on it that if it was disabled, those users would just pin to the last version that accepted it.</p>",
        "id": 243332647,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1624241038
    },
    {
        "content": "<p>I think fully destabilizing is indeed likely not feasible, but identifying a stable subset might be more viable. The schema changes pretty regularly.</p>",
        "id": 243332712,
        "sender_full_name": "simulacrum",
        "timestamp": 1624241127
    },
    {
        "content": "<p>I think the schema being completely unstable is totally reasonable. In the situations where I’ve used custom targets we’re pinning to a version anyway and choose when to upgrade the compiler.</p>",
        "id": 243332787,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1624241235
    },
    {
        "content": "<p>Hi all. From skimming the conversation here, it looks like there was a lot of discussion back when this MCP was first put up, but now there’s been silence for months. Does anyone thing there’s a path to some kind of consensus here? Is this something that enough people want that it should be promoted to an RFC? Or is it simply so unlikely to happen that we should just close the MCP?</p>",
        "id": 254719030,
        "sender_full_name": "pnkfelix",
        "timestamp": 1632495943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> ^</p>",
        "id": 254719069,
        "sender_full_name": "pnkfelix",
        "timestamp": 1632495957
    },
    {
        "content": "<p>Oh yeah, I plan was to promote to an RFC but I was wondering whether the MCP should go through first, since that's what happens with lang-team.</p>",
        "id": 254719304,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632496030
    },
    {
        "content": "<p>Or should the MCP be closed and an RFC submitted.</p>",
        "id": 254719479,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632496095
    },
    {
        "content": "<p>Although I have something larger planned (My intent is to pitch it sometime this weekend, I just want to run some final checks over it), that would effectively subsume this, so maybe this could be held to see what happens with that.</p>",
        "id": 254720560,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632496550
    },
    {
        "content": "<p>It doesn't really seem clear that this needs a full RFC, beyond the MCP. I personally think it might suffice to have the MCP and then a PR implementing the aliasing.</p>",
        "id": 254751963,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632508725
    },
    {
        "content": "<p>Assuming the plan is just to treat treat the target names as equivalent and internally map them to the existing targets, that seems like it'd be relatively simple.</p>",
        "id": 254752219,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632508824
    },
    {
        "content": "<p>(I'm hoping that this doesn't in any way affect the behavior of <code>cfg(target_vendor)</code> in Rust code, just the behavior of the toolchain CLI.)</p>",
        "id": 254752271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632508851
    },
    {
        "content": "<p>like a <code>type</code> alias, not a newtype</p>",
        "id": 254752354,
        "sender_full_name": "cuviper",
        "timestamp": 1632508905
    },
    {
        "content": "<p>It doesn't seem like it's that simple. At the very least, there seems to be a need for discussion on how this aliasing affects other tooling built around rustc (e.g., cargo, rustup) and whether the expectation is that they would also need to map (for example: rustup target add x86_64-pc-linux-gnu -&gt; x86_64-unknown-linux-gnu)</p>",
        "id": 254752357,
        "sender_full_name": "simulacrum",
        "timestamp": 1632508907
    },
    {
        "content": "<p>Fair question. I'd think the most important behavior would be the handling of <code>rustc --target</code> and <code>cargo --target</code>, and the next most important would indeed be rustup.</p>",
        "id": 254752615,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509021
    },
    {
        "content": "<p>I'm not sure, but it's also possible that the name of the target features in other places (e.g., build scripts) in a way that is difficult to alias successfully -- certainly it's \"expected\" by rustc's build system that stuff gets placed in target/$TARGET/ if that's the target passed to it on --target, but if Cargo applies the aliasing and bootstrap does not, this will break that, right? So some level of care is needed.</p>",
        "id": 254752894,
        "sender_full_name": "simulacrum",
        "timestamp": 1632509156
    },
    {
        "content": "<p>Oh, interesting; I had expected that rustc would do the target mapping very early, such that build products for <code>--target x86_64-pc-linux-gnu</code> got put in <code>target/x86_64-unknown-linux-gnu</code>.</p>",
        "id": 254753090,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/254752615\">said</a>:</p>\n<blockquote>\n<p>Fair question. I'd think the most important behavior would be the handling of <code>rustc --target</code> and <code>cargo --target</code>, and the next most important would indeed be rustup.</p>\n</blockquote>\n<p>My expectation for cargo is it does nothing - it doesn't map the target at all and passes it, verbaitum, to <code>$RUSTC</code>. That <code>$RUSTC</code> would then decide what to do about it.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/254752271\">said</a>:</p>\n<blockquote>\n<p>(I'm hoping that this doesn't in any way affect the behavior of <code>cfg(target_vendor)</code> in Rust code, just the behavior of the toolchain CLI.)</p>\n</blockquote>\n<p>Under both the aforemetioned plan (which should hopefully solve the target issue entirely) and this, I would expect it to likely not, but I might expect that <code>cfg(target)</code> may be affected (and that it is likewise the verbaitum value of <code>--target</code>).</p>",
        "id": 254753283,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632509308
    },
    {
        "content": "<p>That's my biggest concern: I'd like to make sure that inside Rust code, there's one canonical target name that <code>cfg</code> can detect, regardless of aliases.</p>",
        "id": 254753553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509410
    },
    {
        "content": "<p>I could <em>maybe</em> imagine value in allowing <code>cfg(target = \"x86_64-pc-linux-gnu\")</code> to match, though it's not clear how much value that would provide. But I definitely would want <code>cfg(target = \"x86_64-unknown-linux-gnu\")</code> to still match.</p>",
        "id": 254753666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509459
    },
    {
        "content": "<p>But in general, it's not clear why it'd be important for <em>Rust</em> code to be able to match the different <code>target_vendor</code> value. It seems, from the proposal, that this is more about compatibility with different toolchains and Linux distributions in which the same target has different names, and that seems like a CLI interface and invocation issue that wouldn't affect Rust code <code>cfg</code>s.</p>",
        "id": 254753884,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509530
    },
    {
        "content": "<blockquote>\n<p>My expectation for cargo is it does nothing - it doesn't map the target at all and passes it, verbaitum, to $RUSTC. That $RUSTC would then decide what to do about it.</p>\n</blockquote>\n<p>The reason for this is mainly other compilers, if they assign a different toolchain-level meaning to different targets: for example, if they use <code>&lt;libdir&gt;/&lt;target&gt;</code> to store rlibs, I would expect that the search path for <code>--target x86_64-pc-linux-gnu</code> would be <code>&lt;libdir&gt;/x86_64-pc-linux-gnu</code> rather than <code>&lt;libdir&gt;/x86_64-unknown-linux-gnu</code>, especially if it also uses the same path to search for other link-time artifacts (such as platform libraries). <br>\nNot saying that rustc should do this as well, it would primarily be an implementation detail</p>",
        "id": 254753933,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632509551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/254753666\">said</a>:</p>\n<blockquote>\n<p>I could <em>maybe</em> imagine value in allowing <code>cfg(target = \"x86_64-pc-linux-gnu\")</code> to match, though it's not clear how much value that would provide. But I definitely would want <code>cfg(target = \"x86_64-unknown-linux-gnu\")</code> to still match.</p>\n</blockquote>\n<p>The reason for this is to allow implementations to keep the exact and/or canonical name internally, without having to destructively map the target name, and report that exactly to rust code in <code>cfg(target)</code>.</p>",
        "id": 254754197,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632509669
    },
    {
        "content": "<p>My primary concern is making sure that Rust code never has to care about the distinction.</p>",
        "id": 254754473,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509765
    },
    {
        "content": "<p>If both match, that'd be fine, albeit unusual. If the existing canonical target name <em>doesn't</em> match, that could break code expecting it to match, and that code shouldn't have to match both possibilities when they're equivalent.</p>",
        "id": 254754583,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509818
    },
    {
        "content": "<p>That is fair, though there is also the potential argument that if they are matching the entire tuple, then they do care.  I don't have an example with which to make that argument, though.</p>",
        "id": 254754651,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632509846
    },
    {
        "content": "<p>I can't really imagine <em>any</em> code that would have a reason to distinguish between the two, considering that they should in every way be identical other than name.</p>",
        "id": 254754710,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509872
    },
    {
        "content": "<p>As I've mentioned a few times, the difference in name can be a semantic difference.</p>",
        "id": 254754847,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632509922
    },
    {
        "content": "<p>Every example I've seen of that seems to be a case of \"you can build a toolchain with any semantics you want\", but having both on the same system seems like a rather unusual configuration.</p>",
        "id": 254754968,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509968
    },
    {
        "content": "<p>My personal preference would be to do the mapping as early as possible and then store only one target name. Then, <em>optionally</em>, if it turns out to be needed for some reason, we could use the same alias table in reverse to allow matching any of the aliases no matter which one of them was originally passed.</p>",
        "id": 254755004,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509982
    },
    {
        "content": "<p>(Which is why I don't like the requirement of mapping targets and losing this information - the fact it was originally <code>pc</code> may be singificant)</p>",
        "id": 254755014,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632509986
    },
    {
        "content": "<p>Perhaps, but that may also gratuitously and unnecessarily break code written to expect <code>unknown</code>.</p>",
        "id": 254755234,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/254754968\">said</a>:</p>\n<blockquote>\n<p>Every example I've seen of that seems to be a case of \"you can build a toolchain with any semantics you want\", but having both on the same system seems like a rather unusual configuration.</p>\n</blockquote>\n<p>See lfs, where the cross-toolchain will exist on (and in the PATH of) the host system, and uses a name canonically equivalent to <code>x86_64-unknown-linux-gnu</code>.</p>",
        "id": 254755245,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632510050
    },
    {
        "content": "<p>i remember you mentioning that one, but in that case the vendor was <code>lfs</code>, right? So that sounds like a reason to not treat <code>lfs</code> as a simple alias.</p>",
        "id": 254755312,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510079
    },
    {
        "content": "<p>Well, that's complicated here.  But this does generalize. The noncanonical vendor field in  is, after all, basically free real estate in the target name.</p>",
        "id": 254755624,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632510212
    },
    {
        "content": "<p>I think the amount of complexity we're dealing with here is a demonstration that it definitely isn't free.</p>",
        "id": 254756033,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510372
    },
    {
        "content": "<p>Indeed. Handling targets is always fun, especially when nobody agrees on what they mean or on how to name them.</p>",
        "id": 254756216,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632510464
    },
    {
        "content": "<p>In general, I think Rust needs to do a better job of handling the \"corresponding C toolchain and sysroot\" problem on behalf of programs. Right now, most of that lives in the <code>cc</code> crate.</p>",
        "id": 254756300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510491
    },
    {
        "content": "<p>Ignoring the vendor field for a moment, it's perfectly legitimate to have two completely independent C compilers and sysroots on your system, and want to pick which one Rust uses.</p>",
        "id": 254756357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510520
    },
    {
        "content": "<p>Whether they have the same target name or a different one.</p>",
        "id": 254756399,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510536
    },
    {
        "content": "<p>So I'm wondering if there's some way we can treat these as orthogonal problems.</p>",
        "id": 254756462,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510566
    },
    {
        "content": "<p>If rustc did the job of finding your C compiler, then it could add the non-canonical target as part of its search mechanism (e.g. look for ${noncanon}-gcc then ${canon}-gcc), while still not forcing Rust <code>cfg</code> to distinguish.</p>",
        "id": 254756733,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510658
    },
    {
        "content": "<p>Part of it would (presumably) be handled by cargo finding and passing <code>$CC</code> to build scripts, instead of leaving <code>cc</code> to guess. The question is where that ends. Does it also pass <code>$CXX</code>? What about <code>$AS</code>, <code>$LD</code>, or <code>$AR</code>, etc.?</p>",
        "id": 254756789,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632510684
    },
    {
        "content": "<p>Considering that Rust gives control over the linker you use, passing LD seems sensible too.</p>",
        "id": 254756930,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510740
    },
    {
        "content": "<p>I'd be happy to see any or all of those that are useful passed along.</p>",
        "id": 254756955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510752
    },
    {
        "content": "<p>The question is where usefulness ends. I would expect that build scripts still need to get the exact target name, so it can find additional tools, directories, sysroots, etc. It's fairly simple to produce a tool that does different things based on a configuration target, and eg. autotools makes it trivial to find these (<code>AC_PATH_TOOL</code> finds stuff for <code>$noncanonical_host</code>)</p>",
        "id": 254757269,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632510894
    },
    {
        "content": "<p>(Although imo cargo build scripts are unsuited for some of the typical tasks a standard autotools or cmake build script will do, but that's a completely orthogonal discussion)</p>",
        "id": 254757485,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632510980
    },
    {
        "content": "<p>(I'd be interested to hear more about that, but in a separate Zulip thread.)</p>",
        "id": 254757522,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632510998
    },
    {
        "content": "<p>I can imagine, hypothetically, passing a separate environment variable that contains the non-canonical target name or alias, for the purposes of guessing tool prefixes.</p>",
        "id": 254757628,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632511049
    },
    {
        "content": "<p>We could export <code>TARGET_ALIAS</code> or similar, and then crates like <code>cc</code> could check that before <code>TARGET</code>.</p>",
        "id": 254757887,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632511172
    },
    {
        "content": "<p>That way, things that want to do target detection can keep using <code>TARGET</code> and ignore <code>TARGET_ALIAS</code>, while things that want to look for tools can look for <code>${TARGET_ALIAS}-tool</code> then <code>${TARGET}-tool</code>.</p>",
        "id": 254758190,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632511299
    },
    {
        "content": "<p>Would that be sufficient to address the toolchain issue, while not exposing the complexity to Rust <code>cfg</code>?</p>",
        "id": 254758292,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632511330
    },
    {
        "content": "<p>Perhaps, though the question would become what be put in <code>TARGET</code> itself. For example, if I was in autotools land and (being lazy) decided to compile and run a cargo buildscript from a crate instead of rewriting it, what would <code>TARGET</code> be set to, <code>rustc_host_target</code> or some output from <code>$RUSTC</code> (wlg. <code>HOST</code> with <code>rustc_build_target</code> )?  If the former, what would such a build script do if it wanted the actual canonical target, but not some restricted set rust uses. Although I guess in that case, they can canonicalize <code>TARGET_ALIAS</code> (shamless plug for <a href=\"https://crates.io/target-tuples\">https://crates.io/target-tuples</a>).</p>\n<p>Also, without <code>--target</code>,  what would be the behaviour of <code>TARGET_ALIAS</code>. Would it be unset/empty (which is what <code>configure</code> does - it sets them verbaitum from <code>--build</code>, <code>--host</code>, and <code>--target</code> respectively, and leaves them unset if the option isn't provided), or would it be <code>$TARGET</code>?</p>",
        "id": 254758978,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632511628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/254753933\">said</a>:</p>\n<blockquote>\n<p>The reason for this is mainly other compilers</p>\n</blockquote>\n<p>I don't believe Rust needs to align target names with other compilers. There are already so many targets that don't match, and their name couldn't be changed so a mapping will be necessary anyway.</p>\n<p>Creating aliases wouldn't help; it would just make things more messy and less consistent.</p>",
        "id": 254769071,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632515962
    },
    {
        "content": "<p>While I agree that we shouldn't change target names to align or otherwise limit ourselves to the constraints of a different compiler, I do think there's value in providing aliases if we can reasonably do so.</p>",
        "id": 254771832,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632517272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441/near/254753090\">said</a>:</p>\n<blockquote>\n<p>Oh, interesting; I had expected that rustc would do the target mapping very early, such that build products for <code>--target x86_64-pc-linux-gnu</code> got put in <code>target/x86_64-unknown-linux-gnu</code>.</p>\n</blockquote>\n<p>FWIW, this seems \"terrible\" from a build system/user's perspective, since you either need to know about aliases or execute rustc with special flags etc to get the output paths -- we do that a little with rustbuild, but having passed an opaque string target, currently I'm guessing code <em>is</em> relying on the fact that that <em>same</em> string is used anywhere the target is mentioned in outputs.</p>",
        "id": 254772299,
        "sender_full_name": "simulacrum",
        "timestamp": 1632517463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> There's actually a long-standing cargo request to make it easier to set or obtain the target path.</p>",
        "id": 254774582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632518533
    }
]