[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/437\">Don't steal the resolver when lowering HIR; instead look resolution info up on-demand #437</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 241669736,
        "sender_full_name": "triagebot",
        "timestamp": 1622950598
    },
    {
        "content": "<p>I have some (very broken) WIP code, I will try to push it somewhere before I go to bed so you can get an idea of what the changes look like. I don't yet know how to access the Queries struct in TyCtxt, does anyone know how?</p>",
        "id": 241669799,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622950752
    },
    {
        "content": "<p>(happy to move this to <a class=\"stream\" data-stream-id=\"182449\" href=\"/#narrow/stream/182449-t-compiler.2Fhelp\">#t-compiler/help</a> if you want to keep this stream focused on whether this is a good idea or not)</p>",
        "id": 241669874,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622950868
    },
    {
        "content": "<p>the other thing I just ran into is I don't know how to get a &amp;Resolver from a &amp;BoxedResolver (<code>.access()</code> requires <code>&amp;mut BoxedResolver</code>). This seems like it should be possible but <code>declare_box_region_type </code> in rustc_data_structures is a nightmare of keywords</p>",
        "id": 241671353,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622952808
    },
    {
        "content": "<p>Have you seen <a href=\"https://github.com/rust-lang/rust/pull/85885\">https://github.com/rust-lang/rust/pull/85885</a>?</p>",
        "id": 241671645,
        "sender_full_name": "bjorn3",
        "timestamp": 1622953229
    },
    {
        "content": "<p>I have not! Thank you <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 241671659,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622953301
    },
    {
        "content": "<p>I would really like if <code>TyCtxt</code> keeps using <code>ResolverOutputs</code> as input instead of <code>Resolver</code>. It saves memory and provides a really nice abstraction point to decouple the frontend (everythjng before HIR) from the middle end (everything with HIR before codegen) and would theoretically allow for example plugging in a frontend for a rust like language or using completely different frontends for different editions.</p>",
        "id": 241672008,
        "sender_full_name": "bjorn3",
        "timestamp": 1622953854
    },
    {
        "content": "<p>What do you think about this setup?</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/compiler/rustc_middle/src/ty/context.rs b/compiler/rustc_middle/src/ty/context.rs</span>\n<span class=\"gh\">index 970e669c16f..cf3e9109910 100644</span>\n<span class=\"gd\">--- a/compiler/rustc_middle/src/ty/context.rs</span>\n<span class=\"gi\">+++ b/compiler/rustc_middle/src/ty/context.rs</span>\n<span class=\"gu\">@@ -932,6 +932,10 @@ fn deref(&amp;self) -&gt; &amp;Self::Target {</span>\n     }\n }\n\n<span class=\"gi\">+pub trait Resolver {</span>\n<span class=\"gi\">+    fn resolver_outputs(&amp;self) -&gt; &amp;ty::ResolverOutputs;</span>\n<span class=\"gi\">+}</span>\n<span class=\"gi\">+</span>\n pub struct GlobalCtxt&lt;'tcx&gt; {\n     pub arena: &amp;'tcx WorkerLocal&lt;Arena&lt;'tcx&gt;&gt;,\n\n<span class=\"gu\">@@ -1129,7 +1133,7 @@ pub fn create_global_ctxt(</span>\n         s: &amp;'tcx Session,\n         lint_store: Lrc&lt;dyn Any + sync::Send + sync::Sync&gt;,\n         arena: &amp;'tcx WorkerLocal&lt;Arena&lt;'tcx&gt;&gt;,\n<span class=\"gd\">-        resolutions: ty::ResolverOutputs,</span>\n<span class=\"gi\">+        resolver: &amp;'tcx impl Resolver,</span>\n         krate: &amp;'tcx hir::Crate&lt;'tcx&gt;,\n         dep_graph: DepGraph,\n         on_disk_cache: Option&lt;query::OnDiskCache&lt;'tcx&gt;&gt;,\n</code></pre></div>\n<p>that keeps the abstraction boundary while still not requiring the outputs to be cloned</p>",
        "id": 241672078,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622953987
    },
    {
        "content": "<blockquote>\n<p>would theoretically allow for example plugging in a frontend for a rust like language or using completely different frontends for different editions.</p>\n</blockquote>\n<p>this isn't possible even today, rustdoc wouldn't work with the other frontend</p>",
        "id": 241672161,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954077
    },
    {
        "content": "<p>exactly because it uses the Resolver directly</p>",
        "id": 241672165,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954092
    },
    {
        "content": "<p><code>trait Resolver</code> could work, but I don't know if the overhead isn't too high.</p>",
        "id": 241672180,
        "sender_full_name": "bjorn3",
        "timestamp": 1622954130
    },
    {
        "content": "<p>While rustdoc wouldn't support it, rustc should support alternative frontends without too much changes to rustc_interface already I think.</p>",
        "id": 241672227,
        "sender_full_name": "bjorn3",
        "timestamp": 1622954188
    },
    {
        "content": "<p>I would expect the overhead to be less than cloning the CStore, but I don't have any data to back it up.</p>",
        "id": 241672229,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954193
    },
    {
        "content": "<p>I was thinking about the overhead for regular compilation.</p>",
        "id": 241672246,
        "sender_full_name": "bjorn3",
        "timestamp": 1622954230
    },
    {
        "content": "<p>regular compilation also clones the CStore.</p>",
        "id": 241672249,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954248
    },
    {
        "content": "<p>err hmm no I think you're right, Rc::try_unwrap will succeed when rustdoc isn't running</p>",
        "id": 241672254,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954267
    },
    {
        "content": "<p>It currently doesn't go through an indirection when accessing resolver outputs from TyCtxt.</p>",
        "id": 241672303,
        "sender_full_name": "bjorn3",
        "timestamp": 1622954294
    },
    {
        "content": "<p>oh, you mean because with the new setup the TyCtxt would have to call <code>resolver_outputs()</code> each time</p>",
        "id": 241672309,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954337
    },
    {
        "content": "<p>if that turns out to be an issue I can add a function for each individual output, that should reduce the boxing/cloning</p>",
        "id": 241672318,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/241669799\">said</a>:</p>\n<blockquote>\n<p>I have some (very broken) WIP code, I will try to push it somewhere before I go to bed so you can get an idea of what the changes look like.</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/compare/master...jyn514:no-steal?expand=1\">https://github.com/rust-lang/rust/compare/master...jyn514:no-steal?expand=1</a></p>",
        "id": 241672450,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622954546
    },
    {
        "content": "<p>I could also have it return borrows instead of owned values, that should make things a lot faster and only the boxing will be left</p>",
        "id": 241672793,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622955184
    },
    {
        "content": "<p>Before I forget: the current setup will cause BorrowMut errors when rustdoc tries to access the resolver; instead I can implement ty::Resolver for Queries and pass that in.</p>\n<p>To reduce the overhead further I could pass in ResolverOutputs directly when rustdoc isn't running, but that requires more <code>actually_rustdoc</code> special casing so I'd rather not unless the perf difference is really bad.</p>",
        "id": 241673096,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622955637
    },
    {
        "content": "<p>I don't think this is a good idea, and I still think <a href=\"https://github.com/rust-lang/rust/issues/83761\">https://github.com/rust-lang/rust/issues/83761</a> is preferable and also easier to implement.</p>",
        "id": 241683009,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1622972107
    },
    {
        "content": "<p>With frozen resolver you cannot do pretty much anything, and modifying resolver is dangerous because it's not covered by query system and its changes are not tracked.</p>",
        "id": 241683158,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1622972345
    },
    {
        "content": "<p>Integrating name resolution into incremental/queries is a large future task, and fixing <a href=\"https://github.com/rust-lang/rust/issues/83761\">#83761</a> by collecting doc links in rustdoc earlier should be a much simpler task.</p>",
        "id": 241683227,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1622972479
    },
    {
        "content": "<p>This MCP could be a first step towards this integration, as a baby step, and would unlock querifying HIR lowering.</p>",
        "id": 241685502,
        "sender_full_name": "cjgillot",
        "timestamp": 1622976244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> fixing this in Rustdoc is <em>not</em> easier to implement, I made more progress in the three hours I played around last night than in the 2 weeks I spent on the rustdoc approach.</p>\n<blockquote>\n<p>modifying resolver is dangerous because it's not covered by query system and its changes are not tracked</p>\n</blockquote>\n<p>Hmm, you mean rustdoc modifying the resolver is dangerous? Rustdoc doesn't modify the incremental cache so I'm not <em>super</em> worried about that:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>rm -r target\n<span class=\"gp\">$ </span>cargo doc\n<span class=\"go\"> Documenting hello-world v0.1.0 (/home/joshua/src/rust/hello-world)</span>\n<span class=\"go\">    Finished dev [unoptimized + debuginfo] target(s) in 2.41s</span>\n<span class=\"gp\">$ </span>ls target/debug/incremental/\n<span class=\"gp\">$</span>\n</code></pre></div>\n<p>My proposed scheme with <code>trait Resolver</code> wouldn't allow modifying the resolver through the TyCtxt, so it shouldn't be an issue for rustc itself.</p>\n<blockquote>\n<p>With frozen resolver you cannot do pretty much anything</p>\n</blockquote>\n<p>This is the existing situation, not my proposed change, right?</p>",
        "id": 241689963,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622983283
    },
    {
        "content": "<p>The associated GitHub issue has been renamed. Renaming this Zulip topic.</p>",
        "id": 241690078,
        "sender_full_name": "triagebot",
        "timestamp": 1622983412
    },
    {
        "content": "<p>I updated the MCP with the discussion in this thread to make it more clear the TyCtxt won't have mutable access.</p>",
        "id": 241690226,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622983578
    },
    {
        "content": "<blockquote>\n<p>Hmm, you mean rustdoc modifying the resolver is dangerous? Rustdoc doesn't modify the incremental cache so I'm not super worried about that:</p>\n</blockquote>\n<p>I guess the way this could go wrong is, within the same rustdoc invocation:</p>\n<ol>\n<li>TyCtxt is created</li>\n<li>Rustdoc runs a query that depends on resolve info (maybe DefIds? I don't know what can actually change; my understanding is that the resolver doesn't update DefIds even when more crates are loaded)</li>\n<li>Rustdoc loads a new crate</li>\n<li>Rustdoc reruns the query, and the TyCtxt gives it the cached old value, but it may have changed based on the new crate</li>\n</ol>\n<p>I am ok with that risk, it only affects rustdoc and it seems like something we could work around.</p>",
        "id": 241690583,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1622984139
    },
    {
        "content": "<p>any further thoughts on this? having this be broken is causing lots of rustdoc regressions (in particular the mess in <a href=\"https://github.com/rust-lang/rust/pull/84867\">https://github.com/rust-lang/rust/pull/84867</a>)</p>",
        "id": 242421770,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1623464589
    },
    {
        "content": "<p>What is the source of the regressions?<br>\nIf it's <a href=\"https://github.com/rust-lang/rust/pull/83738\">https://github.com/rust-lang/rust/pull/83738</a> then feel free to land <a href=\"https://github.com/rust-lang/rust/pull/85749\">https://github.com/rust-lang/rust/pull/85749</a> if it's needed for the upcoming release.<br>\nI still plan to investigate the underlying issues behind it (<a href=\"https://github.com/rust-lang/rust/issues/84738\">https://github.com/rust-lang/rust/issues/84738</a>), but I was busy during the last weeks and now I'm on vacation.</p>",
        "id": 242526588,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1623612415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> the one I was thinking of was <a href=\"https://github.com/rust-lang/rust/issues/82465\">https://github.com/rust-lang/rust/issues/82465</a>, which has a fix in <a href=\"https://github.com/rust-lang/rust/pull/82496\">https://github.com/rust-lang/rust/pull/82496</a> but can't be merged because of the inconsistent crate loading. I guess \"causing regressions\" is incorrect, but it is true that the whole mess would be cleared up if this were fixed.</p>",
        "id": 242527385,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1623613707
    },
    {
        "content": "<p>(<a href=\"https://github.com/rust-lang/rust/pull/84867\">https://github.com/rust-lang/rust/pull/84867</a> is a giant mess that has landed on some channels but not others; there's info in <a href=\"#narrow/stream/241545-t-release/topic/how.20to.20track.20ETA.20when.20nightly.20will.20be.20cut.20to.20beta/near/242135597\">https://rust-lang.zulipchat.com/#narrow/stream/241545-t-release/topic/how.20to.20track.20ETA.20when.20nightly.20will.20be.20cut.20to.20beta/near/242135597</a> if you really want to know)</p>",
        "id": 242527397,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1623613764
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I guess, but there's nothing actionable here for you</p>",
        "id": 242527449,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1623613806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> I'm a bit confused by this -- we are storing a \"read-only view\" of the resolver in the tyctxt, is the idea, but mutation is still possible?</p>",
        "id": 243023608,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1623939300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> mutation is possible, but only through Queries, not through TyCtxt</p>",
        "id": 243026686,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1623940465
    },
    {
        "content": "<p>That makes it effectively read-only for most of the compiler, but still lets rustdoc mutate it and have the compiler see the changes.</p>",
        "id": 243026763,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1623940500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> This is definitely contra to the design of incremental; what kind of mutations do we expect?</p>",
        "id": 243200991,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1624045375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I think the only mutations should be new crates loaded after HIR is built, and new DefIds registered within that crate.</p>\n<p>Are you saying this is contrary to the design because resolutions aren't tracked by the query system? I wouldn't expect them to inherently not fit because the whole point of incremental is to delay things as long as possible.</p>",
        "id": 243201356,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624045619
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> may have more insight into what can change after the TyCtxt is created.</p>",
        "id": 243201392,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624045642
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> I'm reading more about this, playing catch up on the threads. What does \"partial resolution\" mean, as referenced in <a href=\"https://github.com/rust-lang/rust/issues/83761#issuecomment-812968168\">your github comment</a>?</p>",
        "id": 243789196,
        "sender_full_name": "pnkfelix",
        "timestamp": 1624542869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/243201356\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> I think the only mutations should be new crates loaded after HIR is built, and new DefIds registered within that crate.</p>\n</blockquote>\n<p>Does this imply that rustdoc has control-flow paths that loads new crates after HIR is built, and these control-flow paths do not exist in rustc itself?</p>",
        "id": 243789357,
        "sender_full_name": "pnkfelix",
        "timestamp": 1624542941
    },
    {
        "content": "<blockquote>\n<p>Does this imply that rustdoc has control-flow paths that loads new crates after HIR is built, and these control-flow paths do not exist in rustc itself?</p>\n</blockquote>\n<p>Yes. Intra-doc links can link to items that are not used otherwise.</p>",
        "id": 243789494,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624542986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/243789196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> I'm reading more about this, playing catch up on the threads. What does \"partial resolution\" mean, as referenced in <a href=\"https://github.com/rust-lang/rust/issues/83761#issuecomment-812968168\">your github comment</a>?</p>\n</blockquote>\n<p>It's kind of a implementation detail of the strategy I was using there, which didn't work out. The idea was to do the path-based resolution before the TyCtxt was created and the type-based resolution after, which required splitting the whole intra-doc pass into two. I am no longer pursuing that approach.</p>",
        "id": 243789710,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624543076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/243789494\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Does this imply that rustdoc has control-flow paths that loads new crates after HIR is built, and these control-flow paths do not exist in rustc itself?</p>\n</blockquote>\n<p>Yes. Intra-doc links can link to items that are not used otherwise.</p>\n</blockquote>\n<p>this is actually the whole reason for the ICEs, if we didn't support this it wouldn't be an issue. But that's already on stable so I don't think we can change it now :/ and it seems confusing to have to add imports for rustdoc when things would work fine in code.</p>",
        "id": 243790139,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624543220
    },
    {
        "content": "<p>another possible alternative is to do this in the opposite order: store <em>only</em> a read-only resolver on TyCtxt, start tracking changes to it in the query system, and only then allow rustdoc to mutate it. That's a lot more time and effort, but it seems more correct and inline with the compiler's long-term goals</p>",
        "id": 243791243,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624543650
    },
    {
        "content": "<p>I would need mentoring to work on that I think, but I can put in some time on weekends.</p>",
        "id": 243791319,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624543683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> </p>\n<blockquote>\n<p>It's kind of a implementation detail of the strategy I was using there, which didn't work out. The idea was to do the path-based resolution before the TyCtxt was created and the type-based resolution after, which required splitting the whole intra-doc pass into two.</p>\n</blockquote>\n<p>Why didn't it work out?<br>\nThis is the approach that rustc uses, quite successfully.<br>\nI still think this is what rustdoc should do as well.</p>",
        "id": 243795936,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1624545647
    },
    {
        "content": "<p>it was several weeks of work, and each change I made made me realize how much more work it was going to be. I don't have to work on it now and I don't think anyone else does either.</p>",
        "id": 243796058,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624545708
    },
    {
        "content": "<p>(full-time weeks, not \"a weekend each week\")</p>",
        "id": 243796126,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624545726
    },
    {
        "content": "<p>I don't say that it will be easy, because rustdoc has been consistently painting itself into corners for years by inventing custom hygiene rules for intra-doc links, and doing other horrifying stuff, but it's still the easiest thing to do (and a proper one, I think).</p>",
        "id": 243796303,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1624545809
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> I personally am not willing to work on it</p>",
        "id": 243796538,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624545908
    },
    {
        "content": "<p>I will note that the hard part is the error reporting, not the hygiene rules. Splitting the pass means all <em>potential</em> failures have to be resolved up front too.</p>",
        "id": 243797152,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624546140
    },
    {
        "content": "<p>and rustdoc has more constraints than resolve because it doesn't know what namespace the item belongs in.</p>",
        "id": 243797234,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624546174
    },
    {
        "content": "<p>(At this point this issue annoys me enough to be willing to work on it, the problem is that I don't have time.)</p>",
        "id": 243797256,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1624546185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/243797152\">said</a>:</p>\n<blockquote>\n<p>I will note that the hard part is the error reporting, not the hygiene rules. Splitting the pass means all <em>potential</em> failures have to be resolved up front too.</p>\n</blockquote>\n<p>Could you elaborate, what is the problem exactly?<br>\nIf the exact namespace is not known, then the path can be resolved in all namespaces, all partial resolutions can be saved for later if necessary, all procuced errors can be saved for later if necessary as well.</p>",
        "id": 243798080,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1624546509
    },
    {
        "content": "<p>It's out of cache for me. I'd have to look at the errors on <a href=\"https://github.com/jyn514/rust/commit/8d3d43f3a1a97739505d03430972ff08e1667a23\">https://github.com/jyn514/rust/commit/8d3d43f3a1a97739505d03430972ff08e1667a23</a>.</p>",
        "id": 243798422,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1624546634
    },
    {
        "content": "<p>I see, I guess I'll have to look at it myself anyway to really understand what's the problem.</p>",
        "id": 243799328,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1624546934
    },
    {
        "content": "<p>Ok, I took another look at the code and I'm remembering why this was hard. Essentially the problem is I have to go line-by-line through the 2k line file and decide whether it belongs in the early or late pass, then decide how to store the state at that exact point in the program so that it can be retrieved later.  (also rebasing the code is a pain because I made the mistake of trying to split things into different files before it was finished)</p>\n<p>My concern essentially is that this is a <em>lot</em> of work that will be unnecessary once the resolver is involved in incremental <em>anyway</em>. So rather than spending two or three weeks on nothing but this, I would rather spend the time on making the resolver incremental, which helps both rustdoc and the compiler itself, and doesn't waste effort.</p>",
        "id": 251059958,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630161182
    },
    {
        "content": "<p>there's progress being made on incremental already, <span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> has been working on that pretty steadily <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> <a href=\"https://github.com/rust-lang/rust/pull/87234\">https://github.com/rust-lang/rust/pull/87234</a></p>",
        "id": 251059982,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630161222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/241683227\">said</a>:</p>\n<blockquote>\n<p>Integrating name resolution into incremental/queries is a large future task, and fixing <a href=\"https://github.com/rust-lang/rust/issues/83761\">#83761</a> by collecting doc links in rustdoc earlier should be a much simpler task.</p>\n</blockquote>\n<p>^ essentially I disagree that collecting links earlier is simpler</p>",
        "id": 251060693,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630161954
    },
    {
        "content": "<p>Ok, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> and I talked this over and we have a plan for making this work without major changes to the resolver; he convinced me it will take a very long time for the resolver to be part of incremental, and I want to try and fix these issues without having to wait. I'll close the MCP.</p>",
        "id": 251135721,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630246859
    },
    {
        "content": "<blockquote>\n<p>he convinced me it will take a very long time for the resolver to be part of incremental</p>\n</blockquote>\n<p>(and also that it will be easier to make the resolver incremental if it doesn't have to deal with rustdoc being special)</p>",
        "id": 251136096,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630247271
    },
    {
        "content": "<p>I'm also interested in the solution you found.</p>",
        "id": 251136621,
        "sender_full_name": "cjgillot",
        "timestamp": 1630247859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251136621\">said</a>:</p>\n<blockquote>\n<p>I'm also interested in the solution you found.</p>\n</blockquote>\n<p>It's the same basic idea as <a href=\"https://github.com/rust-lang/rust/issues/83761#issuecomment-812347962\">https://github.com/rust-lang/rust/issues/83761#issuecomment-812347962</a> (expand the dropdown), we just fleshed it out a bit more.</p>\n<p>Actually <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> I don't think we'd need an index for the links, we could just store them directly using the <code>EarlyIntraDocLink</code> type I mention there. Rustdoc doesn't care what order the links are in, it already compares them using the link target: <a href=\"https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/html/markdown.rs#L371\">https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/html/markdown.rs#L371</a></p>",
        "id": 251136904,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248151
    },
    {
        "content": "<p>i.e. the map would be <code>FxHashMap&lt;DefId, Vec&lt;Link&gt;&gt;</code>, we wouldn't need an index to go with the DefId</p>",
        "id": 251136924,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248190
    },
    {
        "content": "<p>also <span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> is working on moving <code>traits_in_scope</code> to the early pass, and at the same time storing the info in rustc's internal map instead of rustdoc replicating it</p>",
        "id": 251137026,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248291
    },
    {
        "content": "<p>we didn't discuss macro resolution in detail, but the only uses which aren't in intra-doc links are a pretty bad misuse of the API and I don't think they will be terribly hard to fix: <a href=\"https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/clean/inline.rs#L180\">https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/clean/inline.rs#L180</a></p>",
        "id": 251137063,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248345
    },
    {
        "content": "<p>fyi <span class=\"user-mention\" data-user-id=\"417924\">@inquisitivecrystal</span> I think you forgot to update this line, it assumes all macro_rules macros have macro_export <a href=\"https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/clean/inline.rs#L189\">https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/clean/inline.rs#L189</a></p>",
        "id": 251137129,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248388
    },
    {
        "content": "<p>(although maybe that's just how macro_rules works <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> )</p>",
        "id": 251137152,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251136904\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251136621\">said</a>:</p>\n<blockquote>\n<p>I'm also interested in the solution you found.</p>\n</blockquote>\n<p>Actually <span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> I don't think we'd need an index for the links, we could just store them directly using the <code>EarlyIntraDocLink</code> type I mention there. Rustdoc doesn't care what order the links are in, it already compares them using the link target: <a href=\"https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/html/markdown.rs#L371\">https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/html/markdown.rs#L371</a></p>\n</blockquote>\n<p>oh no I'm being silly - your idea was to have this replace the call in <code>resolve_path</code> altogether, which has only the path_str. So we do need to replace the path_str with an index.</p>",
        "id": 251137644,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630248944
    },
    {
        "content": "<p>I don't think it needs the DefId of the item being documented though, only the DefId of the module. If multiple items in the same module have the same link they can cache the result between them.</p>",
        "id": 251139795,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630251373
    },
    {
        "content": "<p>Hmm, so even resolving the early link properly is somewhat tricky - rustdoc chooses the parent module based on <em>lots</em> of things: <a href=\"https://github.com/rust-lang/rust/blob/ef524710669a003cf2b24361dc6b04b566e560fa/src/librustdoc/passes/collect_intra_doc_links.rs#L836-L916\">https://github.com/rust-lang/rust/blob/ef524710669a003cf2b24361dc6b04b566e560fa/src/librustdoc/passes/collect_intra_doc_links.rs#L836-L916</a></p>",
        "id": 251143179,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630254945
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> is there a way to get the DefKind of a DefId from the resolver? or do I need to already have a Res? DefIdTree only gives me DefIds</p>",
        "id": 251143227,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630254970
    },
    {
        "content": "<p>ah, I want <code>resolver.cstore().def_kind()</code></p>",
        "id": 251143253,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630255026
    },
    {
        "content": "<p>Hmm, I'm not sure how this could work for <code>Self::</code>. The way it works currently is by finding what item <code>Self</code> is and turning it into a string, but the way it does that depends heavily on the tcx: <a href=\"https://github.com/rust-lang/rust/blob/ef524710669a003cf2b24361dc6b04b566e560fa/src/librustdoc/passes/collect_intra_doc_links.rs#L881-L897\">https://github.com/rust-lang/rust/blob/ef524710669a003cf2b24361dc6b04b566e560fa/src/librustdoc/passes/collect_intra_doc_links.rs#L881-L897</a><br>\nand I'm not sure how to do it without stringifying. Hmm, maybe I can try tackling that alone first, not stringifiying.</p>",
        "id": 251144162,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630256102
    },
    {
        "content": "<p>Is the <code>Self</code> logic used for paths literally starting with <code>Self</code> like <code>Self::foo</code>?<br>\nIf such a path is passed to <code>resolve_str_path_error</code> then it will always return an error, <code>Self::foo</code> is type-based resolution.</p>",
        "id": 251144708,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630256647
    },
    {
        "content": "<p>Or is it used for something else, like determining the parent module for a link path based on what <code>Self</code> resolves to?<br>\nE.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// `a::b` &lt;- resolves in the parent module of `Yyy`</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Zzz</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Yyy</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 251144836,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630256768
    },
    {
        "content": "<p>Does <code>src\\librustdoc\\passes\\collect_intra_doc_links\\early.rs</code> work correctly by using parent modules returned by <code>attrs.collapsed_doc_value_by_module_level()</code>?<br>\nIf yes then we already have parent modules, if no then why we don't have ICEs from missing crates due to incorrect parent modules being used?</p>",
        "id": 251145050,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630257004
    },
    {
        "content": "<hr>\n<p>Regarding the traits in scope, looks like we cannot use the rustc's map, it only keeps traits in scope for local nodes, but rustdoc needs traits that are in scope for foreign modules, so we need a separate rustdoc-specific map after all.</p>",
        "id": 251145802,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630257827
    },
    {
        "content": "<p>Ok, a question that I must ask - why we are getting this when documenting an almost empty crate (<code>pub fn foo() {}</code>):</p>\n<div class=\"codehilite\"><pre><span></span><code>// in `fn traits_implemented_by(cx: &amp;mut DocContext&lt;&#39;_&gt;, type_: DefId, module: DefId) -&gt; FxHashSet&lt;DefId&gt; {`\n\n[src\\librustdoc\\passes\\collect_intra_doc_links.rs:775] module = DefId(2:7461 ~ core[84a3]::iter::traits::iterator)\n[src\\librustdoc\\passes\\collect_intra_doc_links.rs:776] type_ = DefId(2:42307 ~ core[84a3]::iter::adapters::peekable::Peekable)\n</code></pre></div>",
        "id": 251154820,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630267625
    },
    {
        "content": "<p>There are no links at all, the function doesn't refer to anything in <code>core::iter</code>, but rustdoc still wants to know which traits are in scope in that module.</p>",
        "id": 251154862,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630267682
    },
    {
        "content": "<p>Apparently rustdoc resolves links from the whole standard library when documenting any program.</p>",
        "id": 251155789,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630268753
    },
    {
        "content": "<blockquote>\n<p>Is the Self logic used for paths literally starting with Self like Self::foo?</p>\n</blockquote>\n<p>Yes, but the <code>Self</code> is replaced by the name of the item (see the link above). Parent modules have their own whole mess, but it's unrelated to Self.</p>\n<blockquote>\n<p>Does src\\librustdoc\\passes\\collect_intra_doc_links\\early.rs work correctly by using parent modules returned by attrs.collapsed_doc_value_by_module_level()?  If yes then we already have parent modules, if no then why we don't have ICEs from missing crates due to incorrect parent modules being used?</p>\n</blockquote>\n<p>Sort of - it uses the right function, but because it passes in <code>None</code> for the extra attributes it only has the attributes for the current item, not attributes that come from a re-export of the original definition. The difference comes when you add additional docs on a re-export:</p>\n<div class=\"codehilite\"><pre><span></span><code>/// Link to [foo]\npub use std::process::Command;\n</code></pre></div>\n<p>The reason it doesn't ICE is the same, because it completely ignores all new attributes.</p>\n<blockquote>\n<p>Ok, a question that I must ask - why we are getting this when documenting an almost empty crate (pub fn foo() {}):</p>\n</blockquote>\n<p>I'm not sure off the top of my head, but I suspect rustdoc is trying to look at the links written in other crates, not just the current. That seems like the wrong behavior, I'd have to look into it. I did a little looking just now and found that it's trying to document <code>impl&lt;T&gt; From&lt;!&gt; for T</code> - maybe one of <code>clean::blanket_impl</code> or <code>clean::auto_trait</code> are buggy?</p>",
        "id": 251155792,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630268759
    },
    {
        "content": "<blockquote>\n<p>Yes, but the Self is replaced by the name of the item (see the link above)</p>\n</blockquote>\n<p>Well, since it's a hack anyway, the impl type can be printed during early resolution as well, using <code>pprust</code>.<br>\n(I doubt that the current behavior can be translated precisely if rustdoc uses some type information when preparing paths passed to <code>resolve_str_path_error</code> or determining their parent modules.)</p>",
        "id": 251156438,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630269486
    },
    {
        "content": "<p>Ideally, <code>Self::foo</code> should be resolved using type checker, not resolver.</p>",
        "id": 251156489,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630269562
    },
    {
        "content": "<p>In rustc it gets to type checker as a partially resolved path with the resolved part having resolution <code>Res::SelfTy</code>.</p>",
        "id": 251156590,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630269651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251156489\">said</a>:</p>\n<blockquote>\n<p>Ideally, <code>Self::foo</code> should be resolved using type checker, not resolver.</p>\n</blockquote>\n<p>is this possible? I've found the type checker really confusing, how can I ask it to resolve a type?</p>",
        "id": 251156602,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630269672
    },
    {
        "content": "<p>Type-based resolution for associated types is done by <code>fn associated_path_to_ty</code>, and for associated functions and constants by <code>fn resolve_fully_qualified_call</code>.<br>\nI'm not sure what is necessary to use these methods from rustdoc, perhaps setting up some contexts will be required.</p>",
        "id": 251158427,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630271680
    },
    {
        "content": "<blockquote>\n<p>Type-based resolution for associated types is done by fn associated_path_to_ty, and for associated functions and constants by fn resolve_fully_qualified_call.</p>\n</blockquote>\n<p>hmm, these both give hard errors, so rustdoc can't use them</p>",
        "id": 251159566,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630272927
    },
    {
        "content": "<p>it has to be a recoverable error</p>",
        "id": 251159573,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630272933
    },
    {
        "content": "<p>actually I think <span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> added some API to ignore errors when implementing go-to-definition</p>",
        "id": 251159581,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630272948
    },
    {
        "content": "<p>I did :)</p>",
        "id": 251159646,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1630273002
    },
    {
        "content": "<blockquote>\n<p>Apparently rustdoc resolves links from the whole standard library when documenting any program.</p>\n</blockquote>\n<p>All that stuff is added to rustdoc <code>Crate</code> by the <code>collect-trait-impls</code> pass.</p>",
        "id": 251161045,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630274545
    },
    {
        "content": "<p>(I'll investigate further tomorrow.)</p>",
        "id": 251161145,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630274605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251137129\">said</a>:</p>\n<blockquote>\n<p>fyi <span class=\"user-mention silent\" data-user-id=\"417924\">inquisitivecrystal</span> I think you forgot to update this line, it assumes all macro_rules macros have macro_export <a href=\"https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/clean/inline.rs#L189\">https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src/librustdoc/clean/inline.rs#L189</a></p>\n</blockquote>\n<p>After staring at that code for 5 minutes in an attempt to understand it, I think you're right.</p>",
        "id": 251172258,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1630286190
    },
    {
        "content": "<p>I don't have the least clue how to test it though (either locally or as a real test).</p>",
        "id": 251172532,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1630286524
    },
    {
        "content": "<p>Left to my own devices, I'd probably change it, and then if the tests still pass assume that the changed version is correct.</p>",
        "id": 251172587,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1630286590
    },
    {
        "content": "<p>Hmm, the code says something about source links - maybe see if the [src] link goes to the wrong place if the macro is defined in a file other than the root <a href=\"http://lib.rs\">lib.rs</a>?</p>",
        "id": 251174419,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630288754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> <br>\nDoes extraction of intra doc links (i.e. paths to resolve) require nontrivial markdown parsing (like using <code>pulldown-cmark</code>)?</p>",
        "id": 251736113,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630597402
    },
    {
        "content": "<p>I thought about resolving the intra doc links in rustc and writing them into metadata (under an option, or even by default if it's cheap).</p>",
        "id": 251736291,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630597469
    },
    {
        "content": "<p>The main difference between rustc and rustdoc is that rustc doesn't have to \"compile code from other crates\", it just takes everything from the other crate's metadata in already prepared form, because all the relevant data was gathered in advance during that other crate's compilation.</p>",
        "id": 251736493,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630597559
    },
    {
        "content": "<p>That's why rustc never needs things like \"collect traits in scope at some point in other crate\".</p>",
        "id": 251737099,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630597801
    },
    {
        "content": "<blockquote>\n<p>resolving the intra doc links</p>\n</blockquote>\n<p>(*) resolving in rustc sense, with all the extras like namespace disambiguators being left for rustdoc.</p>",
        "id": 251737517,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630597928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251736113\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <br>\nDoes extraction of intra doc links (i.e. paths to resolve) require nontrivial markdown parsing (like using <code>pulldown-cmark</code>)?</p>\n</blockquote>\n<p>yes, parsing markdown is non-trivial</p>",
        "id": 251739416,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630598570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251736291\">said</a>:</p>\n<blockquote>\n<p>I thought about resolving the intra doc links in rustc and writing them into metadata (under an option, or even by default if it's cheap).</p>\n</blockquote>\n<p>Hmm, I think gating this under an option would break cargo; it assumes that if it runs <code>cargo check</code> on a dependency then that metadata can be reused for rustdoc</p>",
        "id": 251739560,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630598620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Don't.20steal.20the.20resolver.20when.20lowering.20HI.E2.80.A6.20compiler-team.23437/near/251737099\">said</a>:</p>\n<blockquote>\n<p>That's why rustc never needs things like \"collect traits in scope at some point in other crate\".</p>\n</blockquote>\n<p>hmm, did this turn out to be especially hard? I wouldn't expect it to be terrible to do ahead of time if you're keeping it in rustdoc. Trying to move it to rustc seems harder.</p>",
        "id": 251739720,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630598665
    },
    {
        "content": "<p>It's shouldn't be that hard, it just requires some rustdoc knowledge.<br>\nIn particular, either the high-level rustdoc logic needs to be restructured to run the <code>collect_trait_impls</code> pass before the <code>src\\librustdoc\\passes\\collect_intra_doc_links\\early.rs</code> stuff, or <code>collect_trait_impls</code> needs to be duplicated in some simpler form.</p>",
        "id": 251741202,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630599210
    },
    {
        "content": "<p>I was just thinking about possible alternatives, if intra doc link parsing requires pulling <code>pulldown-cmark</code> into rustc, then it's probably not the best idea.</p>",
        "id": 251741377,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630599265
    },
    {
        "content": "<p>I'm going the \"duplicated in some simpler form\" route right now.</p>",
        "id": 251741518,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630599329
    },
    {
        "content": "<p>wait, do you mean the pass that looks at auto and blanket impls? I wouldn't expect that to be related to intra-doc links - why does it need to come before?</p>",
        "id": 251742419,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630599652
    },
    {
        "content": "<p>do you mean <code>traits_implemented_by</code>?</p>",
        "id": 251742540,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630599697
    },
    {
        "content": "<p>I would expect the only thing that needs to be lifted into the early pass is this bit: <a href=\"https://github.com/rust-lang/rust/blob/fcce644119cf4e8e36001368e514bb5ed67cb855/src/librustdoc/passes/collect_intra_doc_links.rs#L773-L782\">https://github.com/rust-lang/rust/blob/fcce644119cf4e8e36001368e514bb5ed67cb855/src/librustdoc/passes/collect_intra_doc_links.rs#L773-L782</a><br>\nwhich doesn't depend on the tcx</p>",
        "id": 251742672,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630599742
    },
    {
        "content": "<p><code>collect_trait_impls</code> collects impl items from other crates, those impl items have doc comments with links on them, those links are resolved at the impl's def site, including associated segments that require traits that are in scope at the impl's def site.</p>",
        "id": 251744154,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630600324
    },
    {
        "content": "<p><code>traits_implemented_by</code> is modified to take traits from a map pre-populated in <code>early.rs</code> (instead of accessing resolver), so <code>early.rs</code> needs to know \"locations\" of all items collected by <code>collect_trait_impls</code>.</p>",
        "id": 251744314,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630600405
    },
    {
        "content": "<p>oh I see, collect_trait_impls is adding items to <code>clean::Crate</code></p>",
        "id": 251744864,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630600650
    },
    {
        "content": "<p>Hmm. I don't see how you can do that without access to a tyctxt, doesn't it need to see if trait bounds are met for types?</p>",
        "id": 251745053,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630600717
    },
    {
        "content": "<p>since it's looking at blanket impls</p>",
        "id": 251745083,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630600736
    },
    {
        "content": "<p>Yeah, that's a problem.<br>\nIn theory, <code>get_auto_trait_and_blanket_impls</code> for foreign crates can work with <code>CStore</code> alone, without <code>tcx</code>, but in practice that would mean duplicating a lot of code.</p>",
        "id": 251747743,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630601763
    },
    {
        "content": "<p>Status update: pre-populating traits in scope for <em>all</em> foreign modules with impls works fine, now I only have one panicking test - <code>src\\test\\rustdoc\\intra-doc\\libstd-re-export.rs</code>, reexport modules are not yet processed.<br>\nIt shouldn't even be that slow, <code>collect_trait_impls</code> alone should be significantly more expensive.<br>\n<a href=\"https://github.com/petrochenkov/rust/commits/doctrscope\">https://github.com/petrochenkov/rust/commits/doctrscope</a></p>",
        "id": 251789967,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630618356
    },
    {
        "content": "<blockquote>\n<p>It shouldn't even be that slow, collect_trait_impls alone should be significantly more expensive.</p>\n</blockquote>\n<p>yeah collect_trait_impls is horrifically slow, anything that doesn't touch  the trait system should be much faster</p>",
        "id": 251793563,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630620262
    },
    {
        "content": "<p>Status update: PR is up <a href=\"https://github.com/rust-lang/rust/pull/88679\">https://github.com/rust-lang/rust/pull/88679</a>.</p>",
        "id": 252109112,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630884364
    }
]