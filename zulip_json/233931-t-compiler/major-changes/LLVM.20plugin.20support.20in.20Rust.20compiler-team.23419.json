[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/419\">LLVM plugin support in Rust #419</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 230743659,
        "sender_full_name": "triagebot",
        "timestamp": 1616005984
    },
    {
        "content": "<p>This seems reasonable. I think it'd need to stay on nightly for a <em>long</em> time, and might or might not be possible to stabilize, since I don't think we'd be able to offer much in the way of stability guarantees about it.</p>",
        "id": 230807193,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1616036489
    },
    {
        "content": "<p>I don't think we should stabilize that rustc uses an LLVM backend at all; that break cg_clif and prevents other implementations from using a backend other than LLVM</p>",
        "id": 230810520,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1616039724
    },
    {
        "content": "<p>adding this on nightly seems fine though</p>",
        "id": 230810524,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1616039732
    },
    {
        "content": "<p>That wasn't my primary concern; I was already assuming that any such mechanism would have to be conditionally available.</p>",
        "id": 230818678,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1616048673
    },
    {
        "content": "<p>My concern was that even after addressing that, it would be likely to break compatibility of the plugin interface regularly.</p>",
        "id": 230818718,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1616048699
    },
    {
        "content": "<p>Maybe we could add a generic way to send stringly typed configuration to backends? It would then be the backend's job to error on invalid configuration values</p>",
        "id": 230829704,
        "sender_full_name": "oli",
        "timestamp": 1616057299
    },
    {
        "content": "<p>That did be <code>-Cllvm-args</code>. I am using it in cg_clif too.</p>",
        "id": 230830181,
        "sender_full_name": "bjorn3",
        "timestamp": 1616057549
    },
    {
        "content": "<p>I think we can conditionally enable this only when building with system LLVM. that would make me significantly more comfortable with this.</p>",
        "id": 230837410,
        "sender_full_name": "nagisa",
        "timestamp": 1616061568
    },
    {
        "content": "<p>system-LLVM-only would work for me, but it does feel weird that a third-party build would be more featureful</p>",
        "id": 230896989,
        "sender_full_name": "cuviper",
        "timestamp": 1616085440
    },
    {
        "content": "<p>Could we get a list of all use cases for LLVM plugins? The only I know of currently is annobin, for which I could see value in integrating it in rustc proper. For example an LLVM plugin wouldn't be able to get the list of source files used for the build, while rustc can. It also has overlap with <a href=\"https://github.com/Shnatsel/rust-audit\">https://github.com/Shnatsel/rust-audit</a>.</p>",
        "id": 230899054,
        "sender_full_name": "bjorn3",
        "timestamp": 1616086204
    },
    {
        "content": "<p>I really want to avoid people relying on us shipping a LLVM as a DSO in any particular shape or form. Were a profilic consumer of rustc (for sake of example lets say Firefox) start relying on a particular version of LLVM we ship, upgrading LLVM would also become significantly more painful â€“ we'd be breaking or need to coordinate whatever upgrades.</p>",
        "id": 230905542,
        "sender_full_name": "nagisa",
        "timestamp": 1616088420
    },
    {
        "content": "<p>(I say this as somebody who at some point tried to do <a href=\"https://github.com/nagisa/llvm_build_utils.rs\">something similar</a>)</p>",
        "id": 230905750,
        "sender_full_name": "nagisa",
        "timestamp": 1616088495
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span>  the rust ml group is interested in using Enzyme (<a href=\"https://github.com/wsmoses/Enzyme\">https://github.com/wsmoses/Enzyme</a>) to provide automatic differentiation capabilities for certain codes [obvious bias as both author of this MCP and Enzyme].</p>\n<p>Regarding LLVM version nonsense, I would argue that only plugins built for the precise version of LLVM rustc is built agains should be allowed. We might even be able to enforce this if we only allowed plugins built by a specific Rust build process that builds it against the same version of LLVM.</p>",
        "id": 230969655,
        "sender_full_name": "William Moses",
        "timestamp": 1616123471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> So, I wouldn't want to make it dependent on LLVM version, but I would really like to ship the LLVM associated with a rust build in a sysroot crate.</p>",
        "id": 230979927,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1616133309
    },
    {
        "content": "<p>Binaries and library. So that you always have a matching clang for cross-language LTO, or a library for bindgen.</p>",
        "id": 230979992,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1616133364
    },
    {
        "content": "<p>If we were to go that route, the first step would be to make the llvm backend its own distributable component.</p>",
        "id": 231017705,
        "sender_full_name": "nagisa",
        "timestamp": 1616158527
    },
    {
        "content": "<p>(<a href=\"https://github.com/rust-lang/rust/pull/81746\">https://github.com/rust-lang/rust/pull/81746</a> would pave the way for this)</p>",
        "id": 231017864,
        "sender_full_name": "nagisa",
        "timestamp": 1616158600
    },
    {
        "content": "<p>Hi Nagisa, Josh (and everyone else involved).</p>\n<p>After half a year of development, I would like to revisit this decision.<br>\nGenerally, we have two options. The plugin above, together with the calling convention here: <a href=\"https://enzyme.mit.edu/getting_started/CallingConvention/\">https://enzyme.mit.edu/getting_started/CallingConvention/</a>, or using Enzyme as a library on some LLVM-IR.<br>\nThe C-API is generally preferable, as it allows more flexibility to add a nice Rust frontend and generate gradients in the most efficient way.<br>\nHowever, here are some disadvantages we encountered (some also apply to the plugin approach):</p>\n<p>1) Cargo intentionally doesn't support <a href=\"http://post-build.rs\">post-build.rs</a>, however I can only invoke Enzyme after running cargo. Wrapping cargo to run twice or building dependencies which use enzyme in an external dir isn't desirable.<br>\n2) We use the C-abi / ffi, in order to create an archive with the gradient functions which we link then. However, Enzyme could support more types (slices, non-repr(c) structs, ..) which would increase the usefulness and performance of the generated code.<br>\nNot requiring [no-mangle] and extern blocks would also clean up the Rust api of Enzyme.<br>\n3) We need a custom build rustc/llvm/enzyme/clang stack atm., which can't make use of rust's PGO and is an extra layer of complexity.<br>\nThat's mainly needed since rustc isn't exposing some of the required llvm symbols.<br>\n4) We currently rely on dwarf output to analyze the memory layout of types. That's not perfect and especially due to the C-Abi we<br>\nalready had mismatches, e.g. returning { f32, f32 } might show up as the return of a double value or { T } was simplified to T.<br>\n5) I guess there is no real path for stabilization with the current setup (including the -llvm-plugins flag)?</p>\n<p>We think that most of these issues should be solvable by moving from a library solution into the compiler, mostly cg_llvm.</p>\n<ul>\n<li>A single compilation run would be sufficient</li>\n<li>We could get the type information directly, without using proxies like dwarf</li>\n<li>We can skip the entire ffi overhead, since we can directly add the generated functions, rather than linking them back.</li>\n<li>We should be able to access our missing llvm symbols, so can work with the default rustc.</li>\n</ul>\n<p>Are there any general issues which you can see with this approach, from the rustc side? Of course we would need to have Enzyme as a part of the llvm monorepo before being able to stabilize something like this (together with a new rfc), but do you have any other, early thoughts? </p>\n<p>cc: <span class=\"user-mention\" data-user-id=\"282616\">@Lorenz Schmidt</span> <span class=\"user-mention\" data-user-id=\"398596\">@William Moses</span></p>",
        "id": 262512745,
        "sender_full_name": "Manuel Drehwald",
        "timestamp": 1637701087
    },
    {
        "content": "<p>Stabilizing something like llvm plugins would have to be done carefully, in order to avoid stabilizing the existance of llvm itself.</p>",
        "id": 262513351,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637701426
    },
    {
        "content": "<p>I'm not sure if stabilizing this new approach even requires stabilizing -Z llvm-plugins. <br>\nSome more lightweight solution might already suffice, like adding \"enzyme\" to -C llvm-args ( or whatever might replace llvm-args).<br>\nThen we could just run an extra llvm-pass and along the way pass the generated llvm-ir to enzyme using it's API, but we might even get completely around running Enzyme as an llvm plugin. That's one of the parts we would need to find out while experimenting.</p>",
        "id": 262516945,
        "sender_full_name": "Manuel Drehwald",
        "timestamp": 1637703418
    },
    {
        "content": "<p>Are you suggesting adding a dependency edge from cg_llvm to enzyme, and thus shipping enzyme as part of a typical rustc distribution?</p>",
        "id": 262532817,
        "sender_full_name": "nagisa",
        "timestamp": 1637713377
    },
    {
        "content": "<p>Basically yes. For all official work I would wait till LLVM ships Enzyme, right now we only want to do the preparatory experiments.</p>",
        "id": 262534450,
        "sender_full_name": "Manuel Drehwald",
        "timestamp": 1637714926
    }
]