[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/455\">prefer-dynamic=subset #455</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 249670355,
        "sender_full_name": "triagebot",
        "timestamp": 1629165708
    },
    {
        "content": "<p>it seems odd to me that we put link modifiers on <code>-l</code> flags corresponding to individual native libs, but for <code>prefer-dynamic</code> we have a <em>single</em> modifier and would list the set of lib names under it</p>",
        "id": 249676809,
        "sender_full_name": "tmandry",
        "timestamp": 1629173396
    },
    {
        "content": "<p>it does make sense to have a special flag for the std case; clang has analogous flags like <code>-static-libc++</code> or similar</p>",
        "id": 249676933,
        "sender_full_name": "tmandry",
        "timestamp": 1629173585
    },
    {
        "content": "<p>and we allow linking crates without specifying them directly on the command line, so for that you need something like this</p>",
        "id": 249676983,
        "sender_full_name": "tmandry",
        "timestamp": 1629173672
    },
    {
        "content": "<p>but for uses where you are listing deps explicitly (<code>-l</code> or <code>--extern</code>), it would be nice to have a modifier syntax for this</p>",
        "id": 249677008,
        "sender_full_name": "tmandry",
        "timestamp": 1629173739
    },
    {
        "content": "<p>that said, as long as <code>subset</code> is appended each successive flag, I think this proposal would still cover 99% of use cases</p>",
        "id": 249677069,
        "sender_full_name": "tmandry",
        "timestamp": 1629173839
    },
    {
        "content": "<p>the other 1% is when you need to <em>override</em> an earlier flag requesting dynamic linking for some reason.</p>",
        "id": 249677076,
        "sender_full_name": "tmandry",
        "timestamp": 1629173853
    },
    {
        "content": "<p>(this can come up in build systems that assemble flags from a lot of sources, some of which take priority over others)</p>",
        "id": 249677134,
        "sender_full_name": "tmandry",
        "timestamp": 1629173927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/249677008\">said</a>:</p>\n<blockquote>\n<p>but for uses where you are listing deps explicitly (<code>-l</code> or <code>--extern</code>), it would be nice to have a modifier syntax for this</p>\n</blockquote>\n<p>actually I guess for <code>--extern</code> you just point directly to the rlib or dylib you want, so it's unambiguous already</p>",
        "id": 249677209,
        "sender_full_name": "tmandry",
        "timestamp": 1629174047
    },
    {
        "content": "<p>Another option would be to ignore <code>crate-type</code> for dependencies and instead add a <code>dynamic</code> flag to <code>[profile]</code> allowing the user to make whatever crate(s) they want dynamic. This currently can't be done without without patching the source of dependencies.</p>",
        "id": 249683090,
        "sender_full_name": "bjorn3",
        "timestamp": 1629181830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/249676809\">said</a>:</p>\n<blockquote>\n<p>it seems odd to me that we put link modifiers on <code>-l</code> flags corresponding to individual native libs, but for <code>prefer-dynamic</code> we have a <em>single</em> modifier and would list the set of lib names under it</p>\n</blockquote>\n<p>This is a good point. I think I could make <code>-Cprefer-dynamic=crate</code> additive: if the flag occurs multiple times, then we take the union of the sets. That way, <code>-Cprefer-dynamic=crate1 -Cprefer-dynamic=crate2</code> would be synonymous with <code>-Cprefer-dynamic=crate1,crate2</code>.</p>",
        "id": 249721519,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629208332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/249683090\">said</a>:</p>\n<blockquote>\n<p>Another option would be to ignore <code>crate-type</code> for dependencies and instead add a <code>dynamic</code> flag to <code>[profile]</code> allowing the user to make whatever crate(s) they want dynamic. This currently can't be done without without patching the source of dependencies.</p>\n</blockquote>\n<p>There’s lots of ways that I would consider changing <code>cargo</code> in this space (e.g. I think it could do a better job of analyzing the crate graph and telling people about problematic combinations up front). But I will admit that I worry a little bit about trying to monkey-patch dynamic library support onto a crate that didn’t explicitly opt in to having a <code>dylib</code> output type.</p>",
        "id": 249721842,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629208463
    },
    {
        "content": "<blockquote>\n<p>But I will admit that I worry a little bit about trying to monkey-patch dynamic library support onto a crate that didn’t explicitly opt in to having a dylib output type.</p>\n</blockquote>\n<p>The only crates which wouldn't support it are those linking to non-rust libraries. Those crates would give problems anyway if you try to depend on them from dylibs. <code>[profile.'&lt;profile&gt;'.package.'&lt;package name&gt;'] dynamic = true</code> allows the user to decide exactly which crates they want to be dylibs and which not. Strategic dylib usage allows for great reductions in linking time. This can speedup compilation by more than 2x in certain cases: <a href=\"https://bevyengine.org/news/bevy-0-4/#dynamic-linking\">https://bevyengine.org/news/bevy-0-4/#dynamic-linking</a></p>",
        "id": 249731958,
        "sender_full_name": "bjorn3",
        "timestamp": 1629212635
    },
    {
        "content": "<p>In any case, I see no reason we wouldn’t do both things here? I.e., provide some change to <code>rustc</code>, so that people who aren’t using cargo can still benefit? And then independently look into the changes that you suggest, to make it easier for people who don’t want to mess around with RUSTFLAGS settings?</p>",
        "id": 249740871,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629216466
    },
    {
        "content": "<p>Yeah, I guess doing both has benefits too. I think <code>-Cprefer-dynamic=subset</code> could be useful even for cargo with <code>[profile] dynamic = true</code>.</p>",
        "id": 249742995,
        "sender_full_name": "bjorn3",
        "timestamp": 1629217393
    },
    {
        "content": "<p>As a non-cargo user, I'm pretty sure the only thing we want this feature for is <code>std</code>. If we want to build a crate as a dylib we will specify that on the crate target and <em>only</em> build it as a dylib. If we need to build it as both for some reason, we will create a new target with a different output name.</p>",
        "id": 249796517,
        "sender_full_name": "tmandry",
        "timestamp": 1629247810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> (or anyone else): I’m trying to puzzle something out. Right now, we only compute dylib dependencies by scanning dylibs. My inference has been that an rlib, by design, cannot implicitly link to a .dylib</p>",
        "id": 249869107,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629301375
    },
    {
        "content": "<p>actually, let me put some names in here. Consider e.g. the <a href=\"https://github.com/rust-lang/rust/issues/82151#issuecomment-779368017\">minimized example</a> from <a href=\"https://github.com/rust-lang/rust/issues/82151\">#82151</a>: we have:</p>\n<div class=\"codehilite\"><pre><span></span><code>app &lt;- shared (dylib) &lt;- foo (rlib) &lt;- bar ([&quot;lib&quot;, &quot;staticlib&quot;, &quot;cdylib&quot;])\n</code></pre></div>",
        "id": 249869391,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629301484
    },
    {
        "content": "<p>and that crate structure yields the error  \"undefined reference to `bar::bar’” at link time.</p>",
        "id": 249869624,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629301570
    },
    {
        "content": "<p>The question I have is: Should we extend the <code>rlib</code> format to carry its dylib dependencies, and change rustc_metadata::dependency_format to scan rlibs for those dependencies, the same way it scans dylibs?</p>",
        "id": 249869731,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629301622
    },
    {
        "content": "<p>I was avoiding adopting such a solution because an explicit <code>-Cprefer-dynamic</code> flag seemed like a good thing to offer and it seemed sufficient to solve the problem, while extending the rlib format sounds scary</p>",
        "id": 249869842,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629301680
    },
    {
        "content": "<p>I should go back and revise that example. It doesn’t illustrate the actual problem well at all, since its providing a <code>cdylib</code> that itself tries to export a Rust function.</p>",
        "id": 249871041,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629302206
    },
    {
        "content": "<p>cdylibs should be completely ignored in the linkage code. you can't link against them as rust code, only as c code.</p>",
        "id": 249874609,
        "sender_full_name": "bjorn3",
        "timestamp": 1629303777
    },
    {
        "content": "<p>Right, that’s why I was saying the example was bad</p>",
        "id": 249879931,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629306098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/249869107\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> (or anyone else): I’m trying to puzzle something out. Right now, we only compute dylib dependencies by scanning dylibs. My inference has been that an rlib, by design, cannot implicitly link to a .dylib</p>\n</blockquote>\n<p>Okay I explored a little further and determined that my above inference was incorrect. The run-make test I just added to PR <a href=\"https://github.com/rust-lang/rust/issues/88101\">#88101</a> illustrates that the scenario is a little more subtle.</p>",
        "id": 250039274,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629402360
    },
    {
        "content": "<p>Namely, I made a test that looks like this: </p>\n<div class=\"codehilite\"><pre><span></span><code>m6 (app) -&gt; m5 (rlib) -&gt; m4 (dylib) -&gt; m3 (rlib,dylib) -&gt; m2 (lib) -&gt; m1 (dylib,rlib)\n</code></pre></div>\n<p>Today, out of the box, the above doesn’t build by default. I.e leaving out <code>-C prefer-dynamic</code> entirely leads to a linker failure when building <code>m6</code>.</p>\n<p>You can add <code>-C prefer-dynamic</code> at various points along the chain and get different linkage results. So far I’ve constructed, using vanilla <code>-C prefer-dynamic</code> alone:</p>\n<div class=\"codehilite\"><pre><span></span><code>(v2): m5:rlib m4:dylib m3:dylib m2:lib m1:rlib\n(v6): m5:rlib m4:dylib m3:dylib m2:lib m1:dylib\n</code></pre></div>\n<p>But with the new <code>-C prefer-dynamic=subset</code>, I was also able to express:</p>\n<div class=\"codehilite\"><pre><span></span><code>(v5): m5:rlib m4:dylib m3:rlib m2:lib m1:rlib\n</code></pre></div>",
        "id": 250040416,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629402866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/249677076\">said</a>:</p>\n<blockquote>\n<p>the other 1% is when you need to <em>override</em> an earlier flag requesting dynamic linking for some reason.</p>\n</blockquote>\n<p>This actually came up literally today (there's a workaround but it's annoying), so I'm going to say we should have a way of expressing this :-)</p>",
        "id": 250067151,
        "sender_full_name": "tmandry",
        "timestamp": 1629421854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/250040416\">said</a>:</p>\n<blockquote>\n<p>Today, out of the box, the above doesn’t build by default. I.e leaving out <code>-C prefer-dynamic</code> entirely leads to a linker failure when building <code>m6</code>.</p>\n</blockquote>\n<p>This sounds like a bug?</p>",
        "id": 250067589,
        "sender_full_name": "tmandry",
        "timestamp": 1629422392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/250067589\">said</a>:</p>\n<blockquote>\n<p>This sounds like a bug?</p>\n</blockquote>\n<p>This is the struggle I’m having. It <em>does</em> sound like a bug. But its not a bug I think I’m prepared to try to solve <del>today</del> in the short term.</p>",
        "id": 250068029,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629422923
    },
    {
        "content": "<p>The issue is that our tools (or at least rustc), as a whole, tend to pooh-pooh mixing of rlibs and dylibs in your project. The messaging seems to fall into: “you should just make sure you have the same library type available all the way up the chain.” (Note that in the example I’m describing, there is one path that is all just rlibs nor all just dylibs.)</p>",
        "id": 250068134,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423043
    },
    {
        "content": "<p>So right now, I’d prefer to figure out what flag(s) to offer</p>",
        "id": 250068148,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423074
    },
    {
        "content": "<blockquote>\n<p>You can add <code>-C prefer-dynamic</code> at various points along the chain and get different linkage results. </p>\n</blockquote>\n<p>Looking at this makes me a little uneasy :) Your goal is to modify graph edges in the build, but this is doing it with global rustflags that specify crate names, which may not even be unique within the workspace. Technically this can work for just about any case, with crate renaming, but this isn't how I'd design it if I were working with any other build system. I think this flag is really working around a limitation in cargo; namely, that it doesn't let you control these aspects of the build at a fine grained level.</p>\n<p>The fact that this flag turns on <a href=\"https://rust-lang.github.io/rfcs/0404-change-prefer-dynamic.html\">heuristic behavior we've had to change in the past</a> tells me that it's working at the wrong level of abstraction for a compiler flag. Ideally I think <code>prefer-dynamic</code> would have been a cargo option which implemented those heuristics and then invoked rustc with flags telling it exactly which libraries to link, and how. Then this conversation would be about how to design more fine-grained control over the build graph in cargo.</p>\n<p>I'm not entirely sure what this means for \"where we should go from here,\" though. Some of this is my pent up frustration/confusion with trying to understand the interface in the past, and it's not fair for me to take that out on this MCP which is strictly an improvement :). But it definitely makes me think that we want to look for a lower level interface in the long term.</p>",
        "id": 250068164,
        "sender_full_name": "tmandry",
        "timestamp": 1629423101
    },
    {
        "content": "<p>I think we need to do both. Of course we need to improve <code>cargo</code>.</p>",
        "id": 250068217,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423142
    },
    {
        "content": "<p>And maybe I’m making a mistake in trying to paper over the <code>cargo</code> limitations rather than address them directly</p>",
        "id": 250068233,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423168
    },
    {
        "content": "<blockquote>\n<p>Some of this is my pent up frustration/confusion with trying to understand the interface in the past, and it's not fair for me to take that out on this MCP which is strictly an improvement</p>\n</blockquote>\n<p>I’m glad I’m not the only one who is confused by the interface.</p>",
        "id": 250068267,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/250068233\">said</a>:</p>\n<blockquote>\n<p>And maybe I’m making a mistake in trying to paper over the <code>cargo</code> limitations rather than address them directly</p>\n</blockquote>\n<p>I'm unsure about this too. I guess it partly depends on how urgently the feature is needed</p>",
        "id": 250068340,
        "sender_full_name": "tmandry",
        "timestamp": 1629423297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> nonetheless, it sounds like you’re saying you, as a non-<code>cargo</code> user, would benefit from <code>-C prefer-dynamic=std</code>, right?</p>",
        "id": 250068360,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423334
    },
    {
        "content": "<p>Or do you all already get that effect, but you just have to do some grodier magic to compose the right <code>rustc</code> invocation to express it?</p>",
        "id": 250068382,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423365
    },
    {
        "content": "<p>My basic point of view is that I’ve done about as much hacking on rustc’s <code>prefer-dynamic</code> as I want to do, besides fixing obvious bugs. All further work from here on out should be on <code>cargo</code>.</p>",
        "id": 250068426,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629423413
    },
    {
        "content": "<p>we do get that effect, because <code>std</code> is the only rust library that is built as both and rlib and a dylib under the same name in our build</p>",
        "id": 250068427,
        "sender_full_name": "tmandry",
        "timestamp": 1629423415
    },
    {
        "content": "<p>but that might be a restriction we would want to lift in the future. I'm not sure</p>",
        "id": 250068441,
        "sender_full_name": "tmandry",
        "timestamp": 1629423438
    },
    {
        "content": "<p>hmm, the fact that I just said we might want to do something \"in the past\" instead of \"in the future\" tells me I need to stop working :-)</p>",
        "id": 250068545,
        "sender_full_name": "tmandry",
        "timestamp": 1629423572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/prefer-dynamic.3Dsubset.20compiler-team.23455/near/250068441\">said</a>:</p>\n<blockquote>\n<p>but that might be a restriction we would want to lift in the future. I'm not sure</p>\n</blockquote>\n<p>this would be nice to have, I think, though not critical</p>",
        "id": 250069015,
        "sender_full_name": "tmandry",
        "timestamp": 1629424123
    },
    {
        "content": "<p>One thing I’d love to hear from other people: It wuold be great if someone who actually cares about the semantics of rlibs mixed with dylbis (both the heuristic selection of rlib/dylib and how things behave when you have rlibs depending on dylibs) could look over the results of the <a href=\"https://github.com/pnkfelix/rust/blob/issue-82151-parameterize-prefer-dynamic/src/test/run-make-fulldeps/dylib-subset/Makefile#L46\">run-make test</a> I made, and tell me which cases you think represent outright bugs. (I.e. things like <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> ’s reaction up above, which corresponds to <code>v1</code> in the run-make test.)</p>",
        "id": 250071072,
        "sender_full_name": "pnkfelix",
        "timestamp": 1629426631
    },
    {
        "content": "<p>I'm currently looking into this although I didn't yet read the PR's code in detail.</p>",
        "id": 251086654,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630189487
    },
    {
        "content": "<p>I'm skeptical about pulling this logic into <code>rustc</code> in general.<br>\nThe preferred mode of operation for libraries since cargo introduction is feeding libraries to rustc precisely with <code>--extern name=EXACT_PATH</code>.<br>\nSo the build system (cargo or other, doesn't matter) is responsible for deciding what <code>EXACT_PATH</code> is, what crate type it has, and building prerequisites for it, so  rustc doesn't generally choose or prefer, that's basically a legacy pre-cargo logic, it just obeys the build system commands.<br>\nThe exception is crates linked by name like <code>--extern name</code>/<code>extern crate name;</code> and that's standard library in most cases.</p>",
        "id": 251086991,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630189916
    },
    {
        "content": "<p>Also, cargo is better suited for addressing anything by name - you can specify the package name and version, and it can unify all the version constraints from your crate and dependencies (including indirect ones) and give you the right path to the crate.<br>\nWith disambiguation happening in rustc you have to address crates by their \"internal\" names written into metadata, I guess? (I'll look in more detail tomorrow.) Internal names can duplicate in the same build tree.<br>\nIn the PR comments bjorn3 suggests to also pass some hashes from the build system to uniquely identify the crate, but if that logic is already put into the build system, then why not pass the right set of <code>--extern name=EXACT_PATH</code>s instead so rustc doesn't have to disambiguate at all?</p>",
        "id": 251087744,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630190865
    },
    {
        "content": "<p>I need to think about the case where the crate is looked up by name instead of precise path (aka \"usually std\").</p>",
        "id": 251087847,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630190975
    },
    {
        "content": "<blockquote>\n<p>the case where the crate is looked up by name</p>\n</blockquote>\n<p>Actually, it may be as simple as passing <code>--extern std=/path/to/libstd.so</code> or <code>--extern std=/path/to/libstd.rlib</code>?<br>\nExplicit path dependencies are preferred to lookup by name.</p>",
        "id": 251088878,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630192108
    },
    {
        "content": "<p>The exact location and name of libstd is an implementation detail. The name depends on the rustc version. You can't just use the only file in the sysroot that matches libstd-*.so as in cause of a globally installed rust installation, there may be other versions of the standard library installed in the same location.</p>",
        "id": 251107976,
        "sender_full_name": "bjorn3",
        "timestamp": 1630215477
    },
    {
        "content": "<hr>\n<p>The situation with indirect dependencies is worse than I thought.<br>\nEven if we are using <code>--extern name=EXACT_PATH</code> when building a rlib <code>A</code>, the exact path and even its \"crate flavor\" (rmeta/rlib/dylib) are lost.<br>\nSo when we are building a crate <code>B</code> depending on <code>A</code>, <code>A</code>s dependencies will be looked up again (by hash) and we may find a different set of rmeta/rlib/dylib flavors than it was found originally.<br>\nI implemented preserving the flavor in <a href=\"https://github.com/petrochenkov/rust/tree/cflavor\">https://github.com/petrochenkov/rust/tree/cflavor</a> but there's a catch...</p>\n<p>The catch is that cargo actively relies on the flavor being lost.<br>\nThe <code>EXACT_PATH</code> passed by cargo is usually <code>--extern name=path/to/mylib.rmeta</code>.<br>\nHowever, the second lookup finds rlibs and dylibs with the same hash in addition to that rmeta, and uses them.</p>\n<p>We can change cargo to pass <code>--extern name=path/to/mylib.(rlib or dylib)</code> as well to specify the preferred flavor, but it conflicts with pipelined compilation.<br>\n<code>--extern name=EXACT_PATH</code> requires the <code>EXACT_PATH</code> to exist, but with pipelined compilation it does not yet exist, that's why cargo passes the rmeta only and relies on the second lookup to find corresponding rlibs/dylibs.</p>",
        "id": 251703549,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1630584080
    },
    {
        "content": "<blockquote>\n<p>Even if we are using --extern name=EXACT_PATH when building a rlib A, the exact path and even its \"crate flavor\" (rmeta/rlib/dylib) are lost.<br>\nSo when we are building a crate B depending on A, As dependencies will be looked up again (by hash) and we may find a different set of rmeta/rlib/dylib flavors than it was found originally.</p>\n</blockquote>\n<p>Ah, this does indeed sound like it is at the heart of some of the oddness I was encountering.</p>",
        "id": 252334949,
        "sender_full_name": "pnkfelix",
        "timestamp": 1631033195
    }
]