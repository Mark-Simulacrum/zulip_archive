[
    {
        "content": "<p>A new proposal has been announced: <a href=\"https://github.com/rust-lang/compiler-team/issues/475\">Build-time execution sandboxing #475</a>. It will be announced at the next meeting to try and draw attention to it, but usually MCPs are not discussed during triage meetings. If you think this would benefit from discussion amongst the team, consider proposing a design meeting.</p>",
        "id": 265726650,
        "sender_full_name": "triagebot",
        "timestamp": 1640115844
    },
    {
        "content": "<p>Previous discussion in #general: <a href=\"#narrow/stream/122651-general/topic/Build.20script.20security.20and.20isolation\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/Build.20script.20security.20and.20isolation</a></p>",
        "id": 265726889,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640116002
    },
    {
        "content": "<blockquote>\n<p>Note that while I primarily want to push for it as a security feature, I want to emphasize that there are benefits beyond security.</p>\n</blockquote>\n<p>I assume that this refers to things like reproducible builds - could you expand on those benefits in the MCP?</p>",
        "id": 265727062,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640116111
    },
    {
        "content": "<p>I think we should use the sandboxing code from one of the major browsers. Creating watertight sandboxes is notoriously difficult and even browser vendors mess up from time to time. Given that they spent a lot of resources on securing these sandboxes I think the best course of action would be to borrow the implementation rather than handrolling it.</p>",
        "id": 265727070,
        "sender_full_name": "bjorn3",
        "timestamp": 1640116120
    },
    {
        "content": "<p>Also note that on linux at least full sandboxes need suid on the sandboxing executable to allow it to use certain kinds of namespaces.</p>",
        "id": 265727133,
        "sender_full_name": "bjorn3",
        "timestamp": 1640116177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265727062\">said</a>:</p>\n<blockquote>\n<p>I assume that this refers to things like reproducible builds - could you expand on those benefits in the MCP?</p>\n</blockquote>\n<p>Will do, thanks for the feedback!</p>",
        "id": 265727262,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640116251
    },
    {
        "content": "<blockquote>\n<p>As far as Iâ€™m aware, no other major language supports something like this. A successful implementation may encourage other languages to do the same, improving security across the industry.</p>\n</blockquote>\n<p>Some build systems like bazel sandbox everything.</p>",
        "id": 265727313,
        "sender_full_name": "bjorn3",
        "timestamp": 1640116286
    },
    {
        "content": "<p>This is similar to what I'm planning on eventually doing for a game I'm writing, it would run cargo/rustc for compiling game plugins inside a wasm/wasi sandbox with a virtual filesystem and limited network access</p>",
        "id": 265727519,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640116420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265727070\">said</a>:</p>\n<blockquote>\n<p>I think we should use the sandboxing code from one of the major browsers. Creating watertight sandboxes is notoriously difficult and even browser vendors mess up from time to time. Given that they spent a lot of resources on securing these sandboxes I think the best course of action would be to borrow the implementation rather than handrolling it.</p>\n</blockquote>\n<p>I didn't explicitly mention it since I wanted the proposal to be implementation agnostic (maybe I should?) but I think people have been generally receptive of using a wasm runtime (e.g. wasmtime) as our sandboxed runtime. Would that address your concerns?</p>",
        "id": 265727551,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640116442
    },
    {
        "content": "<p>How should the sandboxing configuration look like if you want to for example build a C library? Will you have to manually allow the C compiler (which a user may want to override), every system library and every header location? Or will there be ways to do a blanket allow of reading <code>/usr</code>? And what if the user installed the C compiler in a non-standard location? Would the end user be able to override the sandbox configuration?</p>",
        "id": 265727591,
        "sender_full_name": "bjorn3",
        "timestamp": 1640116453
    },
    {
        "content": "<p>for running cargo in wasi: <a href=\"https://github.com/rust-lang/cargo/issues/9287\">https://github.com/rust-lang/cargo/issues/9287</a></p>",
        "id": 265727642,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640116501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265727133\">said</a>:</p>\n<blockquote>\n<p>Also note that on linux at least full sandboxes need suid on the sandboxing executable to allow it to use certain kinds of namespaces.</p>\n</blockquote>\n<p>I don't think that's true any longer with user namespaces (which, granted, aren't enabled on all distros). But you lose the ability to setup network bridges and such without suid helpers. But that's probably not needed for isolated builds?</p>",
        "id": 265727684,
        "sender_full_name": "The 8472",
        "timestamp": 1640116533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"462933\">Edward Shen</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265727551\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265727070\">said</a>:</p>\n<blockquote>\n<p>I think we should use the sandboxing code from one of the major browsers. Creating watertight sandboxes is notoriously difficult and even browser vendors mess up from time to time. Given that they spent a lot of resources on securing these sandboxes I think the best course of action would be to borrow the implementation rather than handrolling it.</p>\n</blockquote>\n<p>I didn't explicitly mention it since I wanted the proposal to be implementation agnostic (maybe I should?) but I think people have been generally receptive of using a wasm runtime (e.g. wasmtime) as our sandboxed runtime. Would that address your concerns?</p>\n</blockquote>\n<p>A lot of build scripts exist to build C dependencies. Running a C compiler in a wasm runtime would require compiling every part of the toolchain to wasm. How would this C compiler be distributed? And how will it remain compatible with the native toolchain?</p>",
        "id": 265727705,
        "sender_full_name": "bjorn3",
        "timestamp": 1640116549
    },
    {
        "content": "<p>for compiling c code, we could do it similarly to how zig allows cross-compilation of c code <a href=\"https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html\">https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html</a></p>",
        "id": 265728010,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640116714
    },
    {
        "content": "<p>Zig isn't compiled to wasm, right?</p>",
        "id": 265728057,
        "sender_full_name": "bjorn3",
        "timestamp": 1640116747
    },
    {
        "content": "<blockquote>\n<p>Sandboxing build time execution greatly reduces the attack surface. This is a huge win for CI or any remote build system, as it provides a layer of security ensuring that build-time execution, for example, is not leaking sensitive data.</p>\n</blockquote>\n<p>I think it would be helpful to describe briefly what the threat model is and how sandboxing build time execution helps resolve threats there. My inference is that the threat model is \"you have a malicious dependency that runs <a href=\"http://build.rs\">build.rs</a> or proc macros\" but given that most CI systems immediately follow <code>cargo build</code> with <code>cargo test</code>, I don't see how this actually provides security.</p>",
        "id": 265728100,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1640116779
    },
    {
        "content": "<p>and it builds on llvm, so you don't get gcc-supported targets. which isn't relevant yet, but might be at some point.</p>",
        "id": 265728104,
        "sender_full_name": "The 8472",
        "timestamp": 1640116783
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> alternatively that's an argument for also running tests in a sandbox.</p>",
        "id": 265728582,
        "sender_full_name": "The 8472",
        "timestamp": 1640117069
    },
    {
        "content": "<p>But at some point you'll have to trust your build results, yeah.</p>",
        "id": 265728610,
        "sender_full_name": "The 8472",
        "timestamp": 1640117101
    },
    {
        "content": "<p>Depending on what your code does, that might be totally valid as well but I would imagine for more \"integration\" level tests, you probably want to run them in a similar environment as to where they will actually be running.</p>",
        "id": 265728732,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1640117181
    },
    {
        "content": "<p>But yeah, even then, if your dependency is actually malicious, it will just wait until prod to run the payload.</p>",
        "id": 265728761,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1640117220
    },
    {
        "content": "<p>I've done some fairly interesting things in <a href=\"http://build.rs\">build.rs</a>, and sandboxing might make that very difficult.</p>",
        "id": 265728778,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640117237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Thanks for the comments! I expected C dependencies to be especially tricky and I won't say that I have a concrete solution for. I'd need to investigate alternatives, but for now the MCP has no support for C dependencies and those build targets would be out-of-scope for at least this MCP (and left for a future improvement?)</p>",
        "id": 265728904,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640117328
    },
    {
        "content": "<p>(And I don't necessarily trust that rustc cc would support every thing I'd want to check using a C compiler - for example, I'd prefer that my system use x86_64-pc-linux-gnu for the C target, rather than <code>*-unknown-*</code>)</p>",
        "id": 265728913,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640117330
    },
    {
        "content": "<p>For rustc devs it could be useful to have a sandboxed build when debugging/profiling random reproducer code.</p>",
        "id": 265728929,
        "sender_full_name": "The 8472",
        "timestamp": 1640117346
    },
    {
        "content": "<p>I certainly feel a bit paranoid whenever someone points to an entire repo full of non-reduced reproducer for their issue.</p>",
        "id": 265729070,
        "sender_full_name": "The 8472",
        "timestamp": 1640117439
    },
    {
        "content": "<blockquote>\n<p>Zig isn't compiled to wasm, right?</p>\n</blockquote>\n<p>afaict, zig isn't currently compiled to wasm. this is likely for similar reasons as why cargo can't run in wasi -- it's missing spawning processes, pipes, and network access</p>",
        "id": 265729123,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640117487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265728778\">said</a>:</p>\n<blockquote>\n<p>I've done some fairly interesting things in <a href=\"http://build.rs\">build.rs</a>, and sandboxing might make that very difficult.</p>\n</blockquote>\n<p>I would love to have some examples! And to be clear, this proposal is opt-in and meant to be non-breaking, so in the worst case your use cases can justifiably chose not to sandbox.</p>",
        "id": 265729202,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640117524
    },
    {
        "content": "<p>seconding the request for a threat model.</p>",
        "id": 265729398,
        "sender_full_name": "The 8472",
        "timestamp": 1640117649
    },
    {
        "content": "<p><a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a> has a few examples, both for it's stdlib (<a href=\"https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libstd/build.rs\">https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libstd/build.rs</a>), and in the host (though the checks in xlang_host are not yet complete, it will be similar in that it calls out to the C compiler and tries to compile a bunch of programs autotools style).</p>",
        "id": 265729591,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640117778
    },
    {
        "content": "<p>(... I forgot I removed the libstd checks to refactor, and never actually did complete the refactor)</p>",
        "id": 265729671,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640117836
    },
    {
        "content": "<p>TL;DR, instead of hardcoding a bunch of platforms, I test for the features I need, usually by asking the C compiler nicely.</p>",
        "id": 265729758,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640117887
    },
    {
        "content": "<p>Re: threat modeling; I'll incorporate that feedback as changes into the MCP when I get a chance. But otherwise, you have the gist of it.</p>\n<p>We're specifically targeting malicious dependencies that try to exfiltrate data at build-time, via a malicious proc-macro or build script. We assume that the prod environment is sufficiently secured such that malicious actors aren't able to do anything if they get malicious code running (e.g. there's network mitigations in place).</p>\n<p>We can't strictly apply the same security measures on our prod hosts as we do with our CI as there's necessary holes we need to make in our security for CI to be functional (network access, for example, to fetch resources). As a result, we need a mitigation lower in the stack to help with this; this is that mitigation.</p>\n<p>This is a very weak layer of defense, and there are other ways for malware to bypass this as people have mentioned, but the goal here is to block the lowest hanging fruit. Forcing malicious actors to defer to runtime or to tests (which a can be a good security followup), where other mitigations should be in place, is the entire goal. We can build upon this layer of defense later; but for now _something_ is better than _nothing_, in my opinion.</p>\n<p>This MCP (because of it's scope) only targets build time, but isolating tests would be a good follow-up.</p>\n<p>I hope this threat model address your concerns. Please feel free to give feedback as well; I'd very much appreciate it.</p>",
        "id": 265731410,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640118954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265729591\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/LightningCreations/lccc\">https://github.com/LightningCreations/lccc</a> has a few examples, both for it's stdlib (<a href=\"https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libstd/build.rs\">https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libstd/build.rs</a>), and in the host (though the checks in xlang_host are not yet complete, it will be similar in that it calls out to the C compiler and tries to compile a bunch of programs autotools style).</p>\n</blockquote>\n<p>Thanks, I'll take a glance at this later!</p>",
        "id": 265732063,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640119362
    },
    {
        "content": "<blockquote>\n<p>as we do with our CI as there's necessary holes we need to make in our security for CI to be functional (network access, for example, to fetch resources)</p>\n</blockquote>\n<p>Couldn't this also be achieved by cargo vendor/cargo --offline &amp; co and then doing the actual build in a similarly isolated environment as prod?<br>\nAlso, the \"prod is isolated\" argument might not be applicable for many uses.</p>",
        "id": 265733692,
        "sender_full_name": "The 8472",
        "timestamp": 1640120469
    },
    {
        "content": "<p>I mean I can see some uses, but they quite process-specific</p>",
        "id": 265733888,
        "sender_full_name": "The 8472",
        "timestamp": 1640120600
    },
    {
        "content": "<p>I don't think this has to support all use-cases to start with (or maybe ever) to be useful</p>",
        "id": 265734281,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640120856
    },
    {
        "content": "<p>For the reproducible build use-cases, I think it would be great to be able to guarantee that a pure-rust crate graph isn't pulling the contents of arbitrary files / network requests into the build</p>",
        "id": 265734381,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640120910
    },
    {
        "content": "<p>If I'm just running <code>cargo build; cargo clean; cargo build</code>, then the output could still be depending on my system in some undesirable way - however, I won't know if that dependency happens to stay unchanged across by two builds</p>",
        "id": 265734556,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640121004
    },
    {
        "content": "<p>Being able to isolate proc macros (and maybe see a report that \"X out of Y proc macros in your graph support isolation\" would be very useful</p>",
        "id": 265734665,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640121094
    },
    {
        "content": "<p>ability to ship wasm or similarly portable precompiled build scripts and proc-macros in crates is another very desirable feature which can make whatever is being attempted here easier to push through.</p>",
        "id": 265738196,
        "sender_full_name": "nagisa",
        "timestamp": 1640123135
    },
    {
        "content": "<p>In the other direction, it may make sense to approach this piecemeal. <code>build.rs</code> scripts are entirely a concern of Cargo team and proc macros are mostly a concern of the compiler team. Having those be separate efforts, even if the effort is towards the same goals, may make it easier to get something to experiment with first and then the other side can be easier to motivate.</p>",
        "id": 265738378,
        "sender_full_name": "nagisa",
        "timestamp": 1640123258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265738378\">said</a>:</p>\n<blockquote>\n<p>In the other direction, it may make sense to approach this piecemeal. <code>build.rs</code> scripts are entirely a concern of Cargo team and proc macros are mostly a concern of the compiler team. Having those be separate efforts, even if the effort is towards the same goals, may make it easier to get something to experiment with first and then the other side can be easier to motivate.</p>\n</blockquote>\n<p>Yeah, this MCP is intended to be relatively broad and unspecific as I expected talking about implementation details too heavily won't get anything moving at all. The goal here was to have a north star in terms of  \"hey this is what we want to work towards\" and lay enough groundwork for people to think \"yeah this is possible and we can work towards it\".</p>\n<p>Implementation of this will likely be incremental and modular. Other than getting an sandboxing environment in first, what we decide to work towards after will likely depend on the situation at the time (who's available to mentor, if a working group is formed then the opinions on it, etc). I personally think going for proc macros first might be a good way to experiment and ease-in, since we have a lot more prior artwork for it, but of course, I am open to other opinions as well once the time arrives.</p>",
        "id": 265740509,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640124600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"462933\">@Edward Shen</span> I think a standalone wasm runtime with wasi support is the right answer as well. wasmtime seems ideal.</p>",
        "id": 265741025,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640124813
    },
    {
        "content": "<p>I also love the idea of preventing network access, or access to the home directory other than the source dir.</p>",
        "id": 265741171,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640124911
    },
    {
        "content": "<p>Just want to thank everyone here again! I've incorporated the discussion here as part of the MCP. Let me know if I've missed something or if there's any additional feedback :)</p>",
        "id": 265744782,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640127535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265738378\">said</a>:</p>\n<blockquote>\n<p>In the other direction, it may make sense to approach this piecemeal. <code>build.rs</code> scripts are entirely a concern of Cargo team and proc macros are mostly a concern of the compiler team. Having those be separate efforts, even if the effort is towards the same goals, may make it easier to get something to experiment with first and then the other side can be easier to motivate.</p>\n</blockquote>\n<p>Yeah, focusing at the start on proc macros seems best to me, also because I <em>think</em> they will have the biggest impact compared to sandboxing build scripts. Most build scripts need to interact with the host system (git, c compiler...), while a lot of proc macros don't need any access in addition to the input token stream. Having a sandbox with no exceptions would allow a lot of proc macros to leverage it, while it would prevent most build scripts from doing so.</p>",
        "id": 265792631,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640171846
    },
    {
        "content": "<p>Also, this seems too \"big\" for a compiler team MCP? Considering we'll need to decide on the sandbox runtime, what APIs it will allow and how to best expose it, this seems to be RFC-worthy.</p>",
        "id": 265792706,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640171899
    },
    {
        "content": "<p>I think I share the same intuition as <span class=\"user-mention\" data-user-id=\"121055\">@Pietro Albini</span>  -- <a href=\"http://build.rs\">build.rs</a> scripts are much more likely to touch external resources, while proc macros are more likely to just operate on the token stream.  I wonder if there's a way to analyze published proc macros and see how many of them depend only on syn/quote and how many depend on other things</p>",
        "id": 265825396,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640191432
    },
    {
        "content": "<p>(hmm, not as easy as I was hoping:  the crates.io-index entries don't indicate if a crate is a proc-macro -- you have to download and inspect the Cargo.toml to learn if it's a proc macro or not)</p>",
        "id": 265827006,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640192336
    },
    {
        "content": "<p><a href=\"https://www.pietroalbini.org/blog/downloading-crates-io/\">https://www.pietroalbini.org/blog/downloading-crates-io/</a></p>",
        "id": 265827519,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640192558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121055\">Pietro Albini</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265792706\">said</a>:</p>\n<blockquote>\n<p>Also, this seems too \"big\" for a compiler team MCP? Considering we'll need to decide on the sandbox runtime, what APIs it will allow and how to best expose it, this seems to be RFC-worthy.</p>\n</blockquote>\n<p>I was suggested to write an MCP first by <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> , and once the MCP gets approved to then write proper RFCs (whether that be alone or with a working group). My understanding is that this MCP is more for visibility than anything.</p>",
        "id": 265832526,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640195286
    },
    {
        "content": "<p>Right. I <em>do</em> think this will need an RFC or two, but it made sense to me that it might want to start with a proposal, rough alignment and requirements discussion, experimentation, and then an RFC.</p>",
        "id": 265832689,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640195389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222286\">Andrew Chin (eminence)</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/265827006\">said</a>:</p>\n<blockquote>\n<p>(hmm, not as easy as I was hoping:  the crates.io-index entries don't indicate if a crate is a proc-macro -- you have to download and inspect the Cargo.toml to learn if it's a proc macro or not)</p>\n</blockquote>\n<p>I've sent an email to <a href=\"mailto:help@crates.io\">help@crates.io</a> to see if they can accommodate exposing whether or not a crate is a proc-macro or not. Hopefully we'll hear back soon with good news!</p>",
        "id": 265948216,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640289198
    },
    {
        "content": "<p>I'm already downloading the latest version of every crate (36k downloaded so far), with the idea of seeing how many are proc macros (and then looking at their dependencies).  It's a fun holiday project.  I'll for sure report back to this thread with the results.  But feel free to also poke at this too</p>",
        "id": 265961474,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640300863
    },
    {
        "content": "<p>Oh whoops, I didn't see your message. I've spent today writing a <a href=\"https://github.com/edward-shen/proc-macro-stats\">script</a> that fetches from <a href=\"http://static.crates.io\">static.crates.io</a> and have some results.</p>\n<p>The script utilizes the git index to get all crate names, and fetches and caches Cargo.toml files on disk, so hacking on this should be pretty easy and won't constantly redownload Cargo.toml files. I used natural rate limiting (blocking network requests + rayon) so your mileage may vary on speed, but it doesn't take long to download it all.</p>\n<p>Out of the snapshot I took of 71036 crates, only 3397 have <code>lib.proc-macro</code> set to <code>true</code>.  Of those 3397, 1716 have non-standard dependencies (where \"standard dependencies\" are <code>syn</code>, <code>quote</code>, and <code>proc-macro2</code>; this might need fine tuning).</p>\n<p>I've posted the data in that repo (see <code>data</code> for a proc-macro to dependency mapping, and <code>stats</code> for counts of dependencies). I don't have anything conclusive at this time, but just letting people know if they want to investigate for themselves.</p>",
        "id": 265970293,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640311380
    },
    {
        "content": "<p>Is it worth taking a sample of those 1716 proc macros to see if they may or may not work well in a highly constrained wasm sandbox?</p>",
        "id": 265970436,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640311649
    },
    {
        "content": "<p>Maybe! I think that number is conservative; included in that count of  1716 crates are proc macros for the actual crate. e.g. <code>axum-debug-macros</code> has a non-standard dependency of <code>axum</code>, which makes sense</p>",
        "id": 265970520,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640311782
    },
    {
        "content": "<p>Yeah</p>",
        "id": 265970811,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640312180
    },
    {
        "content": "<p>Yeah, I think this script needs support for recursive dependencies but that's a headache I'd rather not tackle for today.</p>\n<p>In the mean time I'm going to see which direct dependencies we can ignore; stuff like, <code>proc-macro-{crate,hack,error}</code>, <code>heck</code>, <code>darling</code>, and <code>lazy_static</code> are just some of the more popular ones, and that cuts it down to 1352 crates.</p>",
        "id": 265970818,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640312201
    },
    {
        "content": "<p>I'm still having fun with this coding project, so I'll continue to try to get more data.  But if the theory is that \"proc macros would be a good initial focus for sandboxing\", maybe we don't need hard data to actually make the MPC/RFC.  Maybe we just declare this, and then in the background continue to do some research and data collection.</p>",
        "id": 265970879,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640312326
    },
    {
        "content": "<p>Yeah, I'd like to have independent confirmation of my results too. That will definitely be helpful in finding weirdness, I think.</p>",
        "id": 265970942,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640312434
    },
    {
        "content": "<p>I'll soon share my code soon.  I've gotten some crazy ideas that's leading me down some tangents, like being able to compile an arbitrary \"filter function\" to wasm, which can be loaded at runtime to find crates of interest.  But that's pretty off-topic for this thread, so I won't say much more about it.  I can ping you with details later, if you want</p>",
        "id": 265971134,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640312717
    },
    {
        "content": "<p>I added some crates that I knew should be pure and ignored proc macros with 1 or 0 dependencies (assuming those with a singular dependency is an associated crate) and I'm down to 223 proc macros, or about 6%. We can probably get lower; but I'm calling it here for tonight at least.</p>\n<blockquote>\n<p>I've gotten some crazy ideas that's leading me down some tangents, like being able to compile an arbitrary \"filter function\" to wasm, which can be loaded at runtime to find crates of interest.</p>\n</blockquote>\n<p>That's just cool! :) Plugin architecture is always something I've wanted to do in Rust but never got the chance to. But yeah, maybe best kept to a PM.</p>",
        "id": 265971982,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640314021
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"462933\">@Edward Shen</span> Can you post the list of 223 proc macro crates somewhere?</p>",
        "id": 265980796,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640326912
    },
    {
        "content": "<p>Sorry; I got confused earlier; I confused the proc macro with their dependencies in the code. Of the 3397 proc macros, 1110 proc macros have \"non-standard\" dependencies. Of those 1110 proc macros, only 402 have &gt; 1 dependency. Here's the list of the 402 proc macros: <a href=\"/user_uploads/4715/PgfphoRko4RnpCCDaZNEyygA/data\">data</a></p>\n<p>To clarify, this list only maps a proc macro to it's \"non-standard\" deps; the standard ones have been removed for clarity.</p>",
        "id": 265981472,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640327881
    },
    {
        "content": "<p>Let me know if you need less filtering of that or in a different format (I posted src if you also want to fiddle around with it as well)</p>",
        "id": 265981538,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640327925
    },
    {
        "content": "<p>Actually, here's the list of the full 1100 proc macros as well, since it was easy for me to do: <a href=\"/user_uploads/4715/2kBs_JBO-RoKx27Y2l_oHCEA/data\">data</a></p>",
        "id": 265981662,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640328097
    },
    {
        "content": "<p>Here's a few interesting and popular procmacros that currently do something that's not easily sandboxed:</p>\n<ul>\n<li><a href=\"https://github.com/dtolnay/rustversion\">https://github.com/dtolnay/rustversion</a> -- Uses a <a href=\"http://build.rs\">build.rs</a> script to get the current rustc version, to allow for conditional compilation based on rust version</li>\n<li><a href=\"https://crates.io/crates/migrations_macros/\">https://crates.io/crates/migrations_macros/</a> -- From the diesel project, looks like it can read migration files from disk at compile time to embed into a project</li>\n<li><a href=\"https://github.com/SergioBenitez/Rocket/tree/master/core/codegen\">https://github.com/SergioBenitez/Rocket/tree/master/core/codegen</a> -- I can't tell exactly what this does, but it will read files from $CARGO_MANIFEST_DIR</li>\n<li><a href=\"https://crates.io/crates/sqlx-macros\">https://crates.io/crates/sqlx-macros</a> -- I think this might actually talk to a live database server</li>\n</ul>\n<p>(Will update this msg later as I find more)</p>",
        "id": 266025652,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640382304
    },
    {
        "content": "<p>Reading files from the source directory should be fine even for sandboxed proc macros, right?</p>",
        "id": 266026673,
        "sender_full_name": "bjorn3",
        "timestamp": 1640383769
    },
    {
        "content": "<p>Yes, we probably would want to allow that (but doing so would require WASI and support from the sandboxing runtime)</p>",
        "id": 266026924,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640384153
    },
    {
        "content": "<p>we'd want to eventually have some way of having a separate api or just intercepting <code>File</code> anyway for cargo tracking which files a proc macro depends on so it knows when to rebuild, sandboxing with wasi is a good way to intercept that</p>",
        "id": 266027568,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640385164
    },
    {
        "content": "<p>I suspect that proc-macros and build scripts might need to opt-in to sandboxing (which is essentially the 'separate api'), at least at the start</p>",
        "id": 266038251,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1640401484
    },
    {
        "content": "<p>We could have a separate target for sandboxed proc macros. This target could be implemented using wasm+wasi for sandboxing or the native target for codegen backends that don't support wasm or if something better pops up. (maybe a custom syscall interface is better suited for proc macros)</p>",
        "id": 266049958,
        "sender_full_name": "bjorn3",
        "timestamp": 1640422642
    },
    {
        "content": "<p>Like <a href=\"https://crates.io/crates/watt\">https://crates.io/crates/watt</a> but motivated by sandboxing instead of ahead-of-time compilation.</p>",
        "id": 266061601,
        "sender_full_name": "cuviper",
        "timestamp": 1640442483
    },
    {
        "content": "<p>(watt does mention isolation already)</p>",
        "id": 266061618,
        "sender_full_name": "cuviper",
        "timestamp": 1640442540
    },
    {
        "content": "<p>It could be motivated by both.</p>",
        "id": 266094906,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640500961
    },
    {
        "content": "<p>Such a target would be a good candidate for the oft discussed proposals to precompile binary artifacts on <a href=\"http://crates.io\">crates.io</a>.</p>",
        "id": 266094921,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640500995
    },
    {
        "content": "<p>precompiled binaries on <a href=\"http://crates.io\">crates.io</a> get really complex really fast</p>",
        "id": 266102659,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640513920
    },
    {
        "content": "<ul>\n<li>the compiler will have to offer a stable ABI for proc macros, otherwise we'd have to rebuild everything every six weeks</li>\n<li>how will new dependencies versions be handled?</li>\n</ul>",
        "id": 266102724,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640514042
    },
    {
        "content": "<p>Yeah, I'd rather see focus on the isolation part, still compiling from source and representing everything in <code>Cargo.lock</code>/tree/vendor/etc.</p>",
        "id": 266116663,
        "sender_full_name": "cuviper",
        "timestamp": 1640536364
    },
    {
        "content": "<p>I'm worried that every sandbox escape and many vulnerability in the libraries bundled within the sandboxed environment would have to be treated as a <em>Rust</em> security vulnerability once this is adopted.</p>",
        "id": 266123898,
        "sender_full_name": "Florian Weimer",
        "timestamp": 1640546493
    },
    {
        "content": "<p>Right now, every proc macro and/or buildscript is a possible security vulnerability, so that's a defeatist attitude I think. I'd think a good approach would be to compile everything from source to WASI/WASM. This lets us punt on the stable ABI side of things (although it would be a pretty good extension).</p>",
        "id": 266125825,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1640549683
    },
    {
        "content": "<p>I think the concern is that if one makes security promises people may start relying on them and shift their expectations. And once those new expectations are violated there'll be demand for fixing things on short timelines. So the increased maintenance should be considered or disclaimed.</p>",
        "id": 266127581,
        "sender_full_name": "The 8472",
        "timestamp": 1640552610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121055\">@Pietro Albini</span> I would expect wasm-targeted proc macros to have a stable wasm ABI.</p>",
        "id": 266127582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640552612
    },
    {
        "content": "<p>I agree that new dependency versions would be an issue, but many common proc macro crates don't actually have their dependencies change that often, or at least not substantially more often than themselves. So the bigger issue would be if some crate had a <code>&lt;</code> or <code>=</code> constraint on a dependency shared with the proc macro crate, and since crates typically <em>shouldn't</em> use <code>&lt;</code> or <code>=</code> constraints, I think it'd be fine if crates that do end up having to rebuild from source.</p>",
        "id": 266127691,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640552761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/266127691\">said</a>:</p>\n<blockquote>\n<p>I agree that new dependency versions would be an issue, but many common proc macro crates don't actually have their dependencies change that often, or at least not substantially more often than themselves. So the bigger issue would be if some crate had a <code>&lt;</code> or <code>=</code> constraint on a dependency shared with the proc macro crate, and since crates typically <em>shouldn't</em> use <code>&lt;</code> or <code>=</code> constraints, I think it'd be fine if crates that do end up having to rebuild from source.</p>\n</blockquote>\n<p>I don't think that's the only case. I could see a project wanting to bump to a newer <code>syn</code> version to gain support for new syntax, or pinning a specific version of a dependency to avoid a regression.</p>",
        "id": 266128959,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640554789
    },
    {
        "content": "<p>(anyway, I think it's better to focus first on having compile-time wasm sandboxing, which doesn't have the abi nor deps issue, and then later think about redistributing precompiled macros)</p>",
        "id": 266129029,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640554902
    },
    {
        "content": "<p>Why would wasm proc macros have a stable abi when regular proc macros don't?</p>",
        "id": 266130681,
        "sender_full_name": "bjorn3",
        "timestamp": 1640557359
    },
    {
        "content": "<p>Regular proc macros already don't depend on the rust abi. The abi is defined in terms of the C abi yo ensure building rustc itself can use proc macros.</p>",
        "id": 266130713,
        "sender_full_name": "bjorn3",
        "timestamp": 1640557420
    },
    {
        "content": "<p>The abi changes because we change the crate metadata format (used to encode what macros exist in the crate), because we add or remove exposed interfaces and because we move code between the proc macro client and server side (this can reduce the amount of calls between both sides which are slow, especially when sandboxing or possibly in the future running on another thread.)</p>",
        "id": 266130838,
        "sender_full_name": "bjorn3",
        "timestamp": 1640557575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/266130713\">said</a>:</p>\n<blockquote>\n<p>Regular proc macros already don't depend on the rust abi. The abi is defined in terms of the C abi yo ensure building rustc itself can use proc macros.</p>\n</blockquote>\n<p>It's not specified, though, so even though rustc internally uses the C abi, it's fairly moot as soon as we get anything other than rustc. Unless rust wants to specify the abi of everything in <code>proc_macro</code> as well.</p>",
        "id": 266131072,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640557945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/266130681\">said</a>:</p>\n<blockquote>\n<p>Why would wasm proc macros have a stable abi when regular proc macros don't?</p>\n</blockquote>\n<p>the stable ABI is needed to make precompiled macros available through <a href=\"http://crates.io\">crates.io</a> (or well, a related service like we did with <a href=\"http://docs.rs\">docs.rs</a>) a possibility, if we want to do so (would be nice!)</p>",
        "id": 266131225,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640558213
    },
    {
        "content": "<p>otherwise we'd need to rebuild all proc macros every time a stable compiler comes out, and we wouldn't be able to support nightly and beta (as rebuilding everything every day is really not feasible)</p>",
        "id": 266131238,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640558247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121055\">Pietro Albini</span> <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Build-time.20execution.20sandboxing.20compiler-team.23475/near/266129029\">said</a>:</p>\n<blockquote>\n<p>(anyway, I think it's better to focus first on having compile-time wasm sandboxing, which doesn't have the abi nor deps issue, and then later think about redistributing precompiled macros)</p>\n</blockquote>\n<p>but like, it'd be better to just focus first on one thing and then incrementally make progress on the others, otherwise we'll never finish designing this <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 266131284,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640558307
    },
    {
        "content": "<blockquote>\n<p>It's not specified, though, so even though rustc internally uses the C abi, it's fairly moot as soon as we get anything other than rustc. Unless rust wants to specify the abi of everything in <code>proc_macro</code> as well.</p>\n</blockquote>\n<p>My posts after the post you quoted say that too. I was explaining why non-wasm vs wasm shouldn't matter for the proc macro abi stability.</p>",
        "id": 266131500,
        "sender_full_name": "bjorn3",
        "timestamp": 1640558739
    },
    {
        "content": "<p><span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> sorry it's late</p>",
        "id": 266132211,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1640559807
    },
    {
        "content": "<p>Thanks folks for the activity! I really do appreciate that this is getting attention, espeically during the holiday season. I've updated the MCP to include notes on maintenance costs (w.r.t bugs in sandboxing becoming a Rust vulnerability) and made a list of explicit items not in scope, including binary artifact distribution on <a href=\"http://crates.io\">crates.io</a>. I agree with the sentiment that considering that feature now is too much, and that something like that should be deferred for consideration after this feature is accepted and implemented.</p>\n<p>As always, please let me know if I missed a concern!</p>",
        "id": 266133587,
        "sender_full_name": "Edward Shen",
        "timestamp": 1640561941
    },
    {
        "content": "<p>From reading through the discussion, it seems like there's lots of opinions on what exactly this should (or should not) look like, but no objections to the idea of sandboxing itself</p>",
        "id": 267000140,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641421346
    },
    {
        "content": "<p>As I understand it, the purpose of this MCP is ensure acceptance of the overall idea, and then to begin discussing the design and implementation in more detail</p>",
        "id": 267000265,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641421425
    },
    {
        "content": "<p>Unless anyone objects to my summary, I'm going to second this proposal</p>",
        "id": 267000365,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641421461
    },
    {
        "content": "<p>I was sort under an impression that it was more a discussion about scope and less about an implementation approach.</p>",
        "id": 267004417,
        "sender_full_name": "nagisa",
        "timestamp": 1641423840
    },
    {
        "content": "<p>Seems to be fairly universally accepted that the sandboxing would involve a wasm runtime of some sort, at least.</p>",
        "id": 267004486,
        "sender_full_name": "nagisa",
        "timestamp": 1641423864
    },
    {
        "content": "<p>I mean that the design and implementation would occur after it's accepted</p>",
        "id": 267004630,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641423956
    },
    {
        "content": "<p>I do think that we should, before the MCP gets seconded, agree on the different scopes that should be treated independently.</p>",
        "id": 267005314,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641424366
    },
    {
        "content": "<p>For instance, I think it's important to observe that sandboxing of proc macros is very different from sandboxing of build scripts, and that there's value in doing the former even if we haven't yet done the latter.</p>",
        "id": 267005368,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641424400
    },
    {
        "content": "<p>With that caveat, I completely agree that the right approach here is to green-light experimentation with possible designs.</p>",
        "id": 267005403,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641424425
    },
    {
        "content": "<p>Sounds good. Is there anything else blocking this or for me to address? Or can we move ahead with a second (and full approval and FCP?)?</p>",
        "id": 267520705,
        "sender_full_name": "Edward Shen",
        "timestamp": 1641860119
    },
    {
        "content": "<p>Any update on this? Are we waiting on a meeting or clarification for this to move forward or did this simply fall through the cracks?</p>",
        "id": 270237663,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1643732022
    },
    {
        "content": "<p>Not sure. I think we just need someone to second this (followed by a FCP?) as there isn't much concern with this, but I think people are just busy and haven't gotten back to this issue yet.</p>",
        "id": 270905429,
        "sender_full_name": "Edward Shen",
        "timestamp": 1644174007
    }
]