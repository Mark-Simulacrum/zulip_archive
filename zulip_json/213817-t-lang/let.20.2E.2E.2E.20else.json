[
    {
        "content": "<p>I've been repeatedly finding cases where I'd like <code>let pat = expr else { ... }</code>. We talked about that some time ago, and it seemed like folks were in favor, modulo getting the syntax right/unambiguous.</p>",
        "id": 228689433,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614814971
    },
    {
        "content": "<p>Other than getting the syntax right and unambiguous, were there any blockers for that?</p>",
        "id": 228689484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614815002
    },
    {
        "content": "<p>Not to my recollection</p>",
        "id": 228690165,
        "sender_full_name": "simulacrum",
        "timestamp": 1614815345
    },
    {
        "content": "<p>I'm still not 100% confident about wanting it but I do agree it comes up a bunch</p>",
        "id": 228690212,
        "sender_full_name": "simulacrum",
        "timestamp": 1614815376
    },
    {
        "content": "<p>I really often find myself writing code like <code>let x = if let Some(x) = expr { x } else { ... };</code>. That pattern seems to crop up repeatedly in many functions I write.</p>",
        "id": 228690530,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614815541
    },
    {
        "content": "<p>\"not 100% confident about wanting it\" is how I would have described <code>if let</code> to begin with. However, since we have <code>if let</code> already, it seems entirely natural to extend the ability with an <code>else</code> possibility.</p>",
        "id": 228691667,
        "sender_full_name": "Lokathor",
        "timestamp": 1614816200
    },
    {
        "content": "<p>I definitely hit that pattern repeatedly</p>",
        "id": 228692193,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614816526
    },
    {
        "content": "<p>I tend to write it with <code>match</code> but...</p>",
        "id": 228692245,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614816543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> said:</p>\n<blockquote>\n<p>requiring that the else block diverses seems… pretty weird to me. Not from the perpective of why you'd require but from the perspective of this seeming fairly constrained to add additional syntax over.</p>\n</blockquote>\n<p>I've seen this pattern in many, many code bases.</p>",
        "id": 228693508,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817292
    },
    {
        "content": "<p>Not just in Rust, either. It's a common pattern in other languages, too, in a different way.</p>",
        "id": 228693631,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817362
    },
    {
        "content": "<p>In Rust, though, it interacts with safety and initialization.</p>",
        "id": 228693709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817425
    },
    {
        "content": "<p><code>if some_condition { diverge }</code> is simpler than <code>if some_condition { diverge } else { entire rest of the function }</code> (whichever order you write the two clauses in).</p>",
        "id": 228693774,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817457
    },
    {
        "content": "<p><code>if let refutable_pattern = expr { ... }</code> works great if you have something to do if the pattern matches, and then you rejoin and do the same thing either way afterward.</p>",
        "id": 228693857,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817510
    },
    {
        "content": "<p>It doesn't work so well if you want bindings for the variables in the refutable pattern, throughout the rest of the function.</p>",
        "id": 228693904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817534
    },
    {
        "content": "<p>I… would still perhaps look for a way to make <code>if let</code> work for this. In my experience writhing this same code many times, I would revert to <code>match</code> primarily because with formatting people generally prefer (think: default rustfmt) <code>if let</code> in this scenario introduces many more lines.</p>",
        "id": 228694091,
        "sender_full_name": "nagisa",
        "timestamp": 1614817626
    },
    {
        "content": "<p>There was a great deal of discussion on this the last time it came up. One of many proposals was something like <code>if let !Some(x) = pattern { diverge }</code>, and then <code>x</code> got bound if you <em>didn't</em> enter the <code>if</code>. That seemed much less clear.</p>",
        "id": 228694244,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817699
    },
    {
        "content": "<p>So to me the issue with the <code>if let</code> in this situation is more about poor defaults. An extra name binding… I _think_ is not as big of a deal to me.</p>",
        "id": 228694255,
        "sender_full_name": "nagisa",
        "timestamp": 1614817708
    },
    {
        "content": "<p>Can you say more about what you mean by \"poor defaults\" here?</p>",
        "id": 228694303,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817737
    },
    {
        "content": "<p>/me is also trying to find the previous discussion of this.</p>",
        "id": 228694540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614817862
    },
    {
        "content": "<p>Well, like whenever I write this kind of construct I generally write this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">apple</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I do so because its fewer lines than </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">apple</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which is what rustfmt would format that statement as by default. It adds way more noise than I'd like. But its not necessarily an issue with the construct. I wouldn't mind using <code>if let</code> in this scenario if this ended up being formatted as</p>\n<div class=\"codehilite\"><pre><span></span><code>let x = if let Some(x) = apple { x } else {\n    return;\n}\n</code></pre></div>\n<p>I think _even_ with the additional binding if this kind of pattern is formatted a different way, it'd become a second nature for people to identify this pattern through how it \"looks\".</p>",
        "id": 228694782,
        "sender_full_name": "nagisa",
        "timestamp": 1614817996
    },
    {
        "content": "<p>It's absolutely possible to identify the pattern by looking at it. But it still feels like a \"code smell\". It's a pattern that indicates the need for improvement.</p>",
        "id": 228694968,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818094
    },
    {
        "content": "<p>The formatting you suggest above is an improvement, but doesn't solve the primary thing that <code>let ... else</code> does.</p>",
        "id": 228695038,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818139
    },
    {
        "content": "<p>(I also tend to introduce functions/etc and utilize <code>?</code> when this pattern repeats more than once or a twice in a function)</p>",
        "id": 228695039,
        "sender_full_name": "nagisa",
        "timestamp": 1614818140
    },
    {
        "content": "<p>(So perhaps <code>try {}</code> is some form of a solution there?)</p>",
        "id": 228695065,
        "sender_full_name": "nagisa",
        "timestamp": 1614818154
    },
    {
        "content": "<p>You still have to write <code>x</code> three times (and <code>let</code> twice), you push <code>apple</code> much further to the right (which is an issue if <code>apple</code> itself is complicated), and you push <code>Some(x)</code> into the middle of a longer expression when that pattern match is actually important.</p>",
        "id": 228695157,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818193
    },
    {
        "content": "<p>It's a recognizable pattern but an obfuscating one.</p>",
        "id": 228695247,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818256
    },
    {
        "content": "<p>I wonder how common is this pattern for types that don't implement <code>Try</code>.</p>",
        "id": 228695381,
        "sender_full_name": "nagisa",
        "timestamp": 1614818356
    },
    {
        "content": "<p>It applies even if the type does implement <code>Try</code>, if what you want to put in the <code>else</code> doesn't match the behavior of <code>?</code>.</p>",
        "id": 228695477,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> is there a reason the else has to diverge in the case you're bringing up? It feels like an unnecessary restriction to me, the <code>let pat = expr else { ... };</code> isn't just sugar then.</p>",
        "id": 228695859,
        "sender_full_name": "simulacrum",
        "timestamp": 1614818660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/228695859\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> is there a reason the else has to diverge in the case you're bringing up? It feels like an unnecessary restriction to me, the <code>let pat = expr else { ... };</code> isn't just sugar then.</p>\n</blockquote>\n<p>Because if it doesn't diverge, it'd continue into the containing block without binding the values in <code>pat</code>.</p>",
        "id": 228695881,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818689
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"huh, it didn't match\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// What is x now?</span>\n</code></pre></div>",
        "id": 228695941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818734
    },
    {
        "content": "<p>No, I mean, it can be sugar for <code>let binding = if let pat = expr { binding } else { ... }</code></p>",
        "id": 228695945,
        "sender_full_name": "simulacrum",
        "timestamp": 1614818739
    },
    {
        "content": "<p>Right?</p>",
        "id": 228695959,
        "sender_full_name": "simulacrum",
        "timestamp": 1614818746
    },
    {
        "content": "<p>If you don't diverge you need ... to also have the same type as binding</p>",
        "id": 228696020,
        "sender_full_name": "simulacrum",
        "timestamp": 1614818772
    },
    {
        "content": "<p>So your example would be \"just\" a type error</p>",
        "id": 228696041,
        "sender_full_name": "simulacrum",
        "timestamp": 1614818792
    },
    {
        "content": "<p>I see.</p>",
        "id": 228696050,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818800
    },
    {
        "content": "<p>That'd be a more complex desugaring, and we'd have to specify exactly how you provide a set of bindings, but it could theoretically work.</p>",
        "id": 228696083,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818830
    },
    {
        "content": "<p>Are you proposing <code>let Some(x) = expr else { Some(42) }</code> or <code>let Some(x) = expr else { 42 }</code>?</p>",
        "id": 228696143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818863
    },
    {
        "content": "<p>/me steps away for a bit, but will be back later this evening.</p>",
        "id": 228696158,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614818878
    },
    {
        "content": "<p>Hm. I think it has to be the latter, otherwise you still need to confirm the match. Presumably we would only support single-variable bindings to start.</p>",
        "id": 228696292,
        "sender_full_name": "simulacrum",
        "timestamp": 1614818949
    },
    {
        "content": "<p>This is perhaps better exemplified by having more complicated bindings than just <code>Some(x)</code>. What about, say <code>let Enum::Variant { foo, bar, baz, .. }</code> = ... else { ??? }`?</p>",
        "id": 228696333,
        "sender_full_name": "nagisa",
        "timestamp": 1614818988
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 228696478,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614819058
    },
    {
        "content": "<p>To me it seems like if we're implementing something like this, requiring divergence is a significantly safer choice than limiting this to single-variable bindings.</p>",
        "id": 228696510,
        "sender_full_name": "nagisa",
        "timestamp": 1614819078
    },
    {
        "content": "<p>That complexity, together with the lack of a need for a non-diverging else case in the primary use case, is the reason why all the proposals I've seen have required a diverging else.</p>",
        "id": 228696511,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614819080
    },
    {
        "content": "<p>It seems OK to require it to diverge, though it definitely feels \"more weird\" to me at first glance, though it certainly has good reasons for that limitation. It's forwards compatible too, I think, with future extensions.</p>",
        "id": 228696887,
        "sender_full_name": "simulacrum",
        "timestamp": 1614819318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/228695381\">said</a>:</p>\n<blockquote>\n<p>I wonder how common is this pattern for types that don't implement <code>Try</code>.</p>\n</blockquote>\n<p>As I recall this is highly common in clippy, and such, where it's looking for specific patterns and wants to <code>continue</code>/etc if it's not that patterns, but it's in complex AST types, not <code>Try</code> types.</p>",
        "id": 228699019,
        "sender_full_name": "scottmcm",
        "timestamp": 1614820487
    },
    {
        "content": "<p>That said, I do think it would be nice to have a special syntax for try-like types, so that something like <code>let x = my_opt ☃ foo() ☃ 4;</code> could work.  (Like <code>?</code> or <code>??</code> in <code>C#</code>.)</p>\n<p>But that's a different thing from <code>let else</code>, so I guess I shouldn't talk about it.</p>",
        "id": 228699579,
        "sender_full_name": "scottmcm",
        "timestamp": 1614820792
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I think that's just unwrap_or_else or map_or or similar; that one is easier to solve with combinators.</p>",
        "id": 228710540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614828695
    },
    {
        "content": "<p>I think <code>if !let Some(x) = apple { diverge }</code> makes more sense than <code>if let !Some(x) = apple { diverge }</code>, although perhaps you don't like either option. It makes more sense if <code>if let pat1 = ... &amp;&amp; let pat2 = ...</code> for if-chain is approved. Personally I would be really happy to see any form of this land</p>",
        "id": 228716223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614833004
    },
    {
        "content": "<p>If we ever added structural record types (a.k.a. anonymous structs), it would allow us to not force divergence in the else case. But without that, and without a sufficiently-motivated use-case...</p>",
        "id": 228716373,
        "sender_full_name": "isHavvy",
        "timestamp": 1614833112
    },
    {
        "content": "<p>I actually have a macro for this pattern in my project</p>",
        "id": 228716404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614833138
    },
    {
        "content": "<p>Link?</p>",
        "id": 228716481,
        "sender_full_name": "isHavvy",
        "timestamp": 1614833181
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/mm0/blob/0ba34ef477b7b8d0f94e250ca338b32eb33034b5/mm0-rs/components/mm0_util/src/lib.rs#L118-L143\">https://github.com/digama0/mm0/blob/0ba34ef477b7b8d0f94e250ca338b32eb33034b5/mm0-rs/components/mm0_util/src/lib.rs#L118-L143</a></p>",
        "id": 228716590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614833268
    },
    {
        "content": "<p>It's specialized to the case <code>diverge = std::hint::unreachable_unchecked()</code> but I've been thinking about extending it to other kinds of divergence</p>",
        "id": 228716663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614833311
    },
    {
        "content": "<p>This is just a simple <code>macro_rules</code> macro, but with a procedural macro you can automatically construct the binding pattern from the refutable pattern, so that the <code>else</code> doesn't have to diverge and instead returns a tuple of the bindings</p>",
        "id": 228716819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614833443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/228710540\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> I think that's just unwrap_or_else or map_or or similar; that one is easier to solve with combinators.</p>\n</blockquote>\n<p>Depends, as usual, whether it's <code>let x = foo ☃ bar().await?;</code>.  (I don't currently use async.await in Rust, but in C# I've had that kind of thing before.)</p>",
        "id": 228722973,
        "sender_full_name": "scottmcm",
        "timestamp": 1614838261
    },
    {
        "content": "<p>What are the types there? I would guess that <code>foo?.bar().await?;</code> or <code>foo.and_then(|foo| foo.bar())?.await?;</code> or similar would work</p>",
        "id": 228723652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614838860
    },
    {
        "content": "<p>What if the <code>else</code> block had the same declared bindings, just not initialized yet, so you could assign them?</p>\n<div class=\"codehilite\"><pre><span></span><code>let Some(Foo { x, y }) = foo() else {\n    x = 1;\n    y = 2;\n};\n</code></pre></div>\n<p>If you don't assign all bindings in the pattern, the rest will be unusable later, just there for conditional drop I guess. Or if you diverge, that's fine too.</p>",
        "id": 228729390,
        "sender_full_name": "cuviper",
        "timestamp": 1614843561
    },
    {
        "content": "<p>As if:</p>\n<div class=\"codehilite\"><pre><span></span><code>let (x, y);\nif let Some(Foo { x: pat_x, y: pat_y }) = foo() {\n    x = pat_x;\n    y = pat_y;\n} else {\n    x = 1;\n    y = 2;\n}\n</code></pre></div>",
        "id": 228729691,
        "sender_full_name": "cuviper",
        "timestamp": 1614843741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> That seems reasonable as an alternative, sure.</p>",
        "id": 228735698,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614847370
    },
    {
        "content": "<p>I definitely badly want this; I write <code>match foo { Some(x) =&gt; x, None =&gt; diverge() }</code> really <em>all</em> the time</p>",
        "id": 228762376,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1614860567
    },
    {
        "content": "<p>(see also <a href=\"https://github.com/rust-lang/rfcs/issues/2616\">https://github.com/rust-lang/rfcs/issues/2616</a>)</p>",
        "id": 228789598,
        "sender_full_name": "kennytm",
        "timestamp": 1614870973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/228729390\">said</a>:</p>\n<blockquote>\n<p>What if the <code>else</code> block had the same declared bindings, just not initialized yet, so you could assign them?</p>\n</blockquote>\n<p>That's really clever!  I don't remember it having been raised in any of the previous conversations, either.</p>",
        "id": 228829697,
        "sender_full_name": "scottmcm",
        "timestamp": 1614884210
    },
    {
        "content": "<p>My usual comment when \"block that must be <code>-&gt; !</code> comes up\":</p>\n<p>That could also be a reason to have <code>unless</code>.  It's questionably useful in most languages, where <code>unless A</code> is just <code>if !(A)</code>.  But with better type requirements, it would allow the reader to concentrate on the \"what requirement is being upheld after this\", since they have a language guarantee that control flow <em>cannot</em> resume after the block.</p>\n<p>And the inverted phrasing is most useful for that, which is why it's <code>assert!(a &gt; 0)</code> not <code>panic_if!(a &lt;= 0)</code> -- <code>assert!(a)</code> is <code>unless a { panic!() }</code>.</p>\n<p>So that would make it the \"clearly doing precondition checks\" form -- <code>unless i % 4 == 0 { continue }</code> in loops, etc.  And <code>unless let Some(x) = x { panic() }</code> for <code>unwrap</code>.</p>\n<p>(But historically people haven't liked the idea.)</p>",
        "id": 228830792,
        "sender_full_name": "scottmcm",
        "timestamp": 1614884605
    },
    {
        "content": "<p>I can see why a general <code>unless</code> may not be well received, but I have to admit that <code>unless let Some(x) = fallible() { return; }</code> looks quite nice.</p>\n<p>A mention a bit tangentially related to <code>let … else</code> are <code>in patterns</code>, which may be especially interesting if considering a non-diverging else path, is <code>in</code> patterns. Taking <span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span>'s example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span>: <span class=\"nc\">in</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// or</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>Incidentally, this would make Rust become Python: <code>let (in x, in y) = (y, x);</code> <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></li>\n</ul>",
        "id": 228835533,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614886327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/228830792\">said</a>:</p>\n<blockquote>\n<p>So that would make it the \"clearly doing precondition checks\" form -- <code>unless i % 4 == 0 { continue }</code> in loops, etc.  And <code>unless let Some(x) = x { panic() }</code> for <code>unwrap</code>.</p>\n<p>(But historically people haven't liked the idea.)</p>\n</blockquote>\n<p>I don't like <code>unless</code> non-historically <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p>but it reads much more naturally in the form of Swift's <code>guard i % 4 == 0 else { continue }</code>, the <code>else</code> being the important separator.</p>",
        "id": 228835977,
        "sender_full_name": "kennytm",
        "timestamp": 1614886488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> I think <a href=\"https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html\">destructuring assigment</a> will cover that<br>\nbut I suppose <code>in</code>-patterns would let you mix new and existing bindings</p>",
        "id": 228836215,
        "sender_full_name": "cuviper",
        "timestamp": 1614886578
    },
    {
        "content": "<p>True! Although that RFC comes with:</p>\n<blockquote>\n<p>Patterns must be irrefutable.</p>\n</blockquote>\n<p>Which to me, is a bigger annoyance than having to type that <code>in</code> keyword, since I was also thinking of being able to use it with <code>match</code> arms (I hate having to do <code>Pattern { x: x_, … } =&gt; { x = x_;  … },</code>).<br>\nFor the irrefutable pattern kind of case, however, having that <code>let</code> seems a bit useless, so I wouldn't even mind having both options around. But should there be only one such feature, <code>in</code> being a more flexible tool is an important thing to keep in mind.</p>",
        "id": 228837093,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614886943
    },
    {
        "content": "<p>hmm, that might improve my <code>let</code>-<code>else</code> desugaring too<br>\n(edit: oh wow, I missed that you literally spelled that out before)</p>",
        "id": 228837692,
        "sender_full_name": "cuviper",
        "timestamp": 1614887178
    },
    {
        "content": "<p>I had only noticed what you wrote in the <code>else</code> block before</p>",
        "id": 228839325,
        "sender_full_name": "cuviper",
        "timestamp": 1614887779
    },
    {
        "content": "<p>idk it feels quite ...wrong?... when a pattern is \"impure\", like will there be any problem with</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">).</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">                          </span><span class=\"c1\">//^ should it point to the outside `x`, or `foo`</span>\n</code></pre></div>",
        "id": 228839488,
        "sender_full_name": "kennytm",
        "timestamp": 1614887805
    },
    {
        "content": "<p>by scoping it would have to be the one inside <code>foo</code>, which would be a borrowck error since you don't get mutable access in the guard</p>",
        "id": 228840068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614887950
    },
    {
        "content": "<p>but assuming you could observe it (a little difficult because of name shadowing), the guard should see the old value of the shadowed variable, and the assignment to the variable happens after the guard but before any code in the branch</p>",
        "id": 228840314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614888051
    },
    {
        "content": "<p>(That said this is just a rule I made up; I guess your point is that the rule may not be obvious)</p>",
        "id": 228840403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614888090
    },
    {
        "content": "<p>lemme see. in the case of <code>if let</code> chain (<a href=\"https://github.com/rust-lang/rfcs/issues/2497\">rfc#2497</a>), the assignment happens after the full chain</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// x, y reassigned here</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// x, y keeps original value</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>in</code> is disallowed in function params</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">//       ^~~~ throw error i suppose</span>\n</code></pre></div>\n<p>allowed in <code>for</code> loop</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// x, y reassigned every loop</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 228841506,
        "sender_full_name": "kennytm",
        "timestamp": 1614888522
    },
    {
        "content": "<p>I don't know if it's advisable, but there's a perfectly valid desugaring of <code>in</code> in function params:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>=</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">z_</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">z_</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 228843036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614889124
    },
    {
        "content": "<p>yeah.</p>",
        "id": 228843528,
        "sender_full_name": "kennytm",
        "timestamp": 1614889323
    },
    {
        "content": "<p>so now you get</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span>: <span class=\"nc\">in</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">}))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 228843864,
        "sender_full_name": "kennytm",
        "timestamp": 1614889420
    },
    {
        "content": "<p>Now that's an idiom that will take some getting used to</p>",
        "id": 228845567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614890019
    },
    {
        "content": "<p>Unfortunately I don't think it will work as \"let ... else\" because rust doesn't support initialization checking via boolean control flow; you would have to rewrite the match inside the <code>matches!</code> so that the false branches are <code>break</code></p>",
        "id": 228845929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614890156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I can't say I'm a fan of <code>unless</code> in general, but I'll admit that <code>unless let Some(x) = ... { diverge }</code> is nicer than <code>if !let Some(x) = ... { diverge }</code>. But I feel like both of them are a little harder to mentally parse than <code>let Some(x) = ... else</code>. Specifically, I feel like it needs to be obvious that \"this binds x\", so the important thing to \"lead with\" is \"let\", not \"if\" or \"unless\".</p>",
        "id": 228857664,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614895003
    },
    {
        "content": "<p>Mental parser: \"What kind of statement is this? Ah, it's a let; it's binding something. Oh, that's a refutable pattern. And there's the <code>else</code> for if it doesn't match...\"</p>",
        "id": 228857757,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614895049
    },
    {
        "content": "<p>That's doubly true if you're scanning <em>upwards</em> from a use of <code>x</code> later in the function to see where <code>x</code> is assigned/bound.</p>",
        "id": 228857891,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614895098
    },
    {
        "content": "<p>I can mention, as prior art, that in Lean (a functional programming language) inside monadic do blocks you can assign a variable with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n<span class=\"bp\">...</span>\n<span class=\"n\">a</span> <span class=\"bp\">&lt;-</span> <span class=\"o\">(</span><span class=\"n\">ma</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>and you can use an irrefutable pattern there:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n<span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"o\">(</span><span class=\"n\">mab</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span> <span class=\"n\">B</span><span class=\"o\">)),</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>as well as a refutable pattern, provided the monad is alternative or you provide an \"else\" case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n<span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"o\">(</span><span class=\"n\">mab</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span> <span class=\"n\">B</span><span class=\"o\">)))</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mr</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>where <code>R</code> is the return value of the whole block (so this would be something like <code>return</code> or <code>break 'a</code> in rust). I'm pretty sure this is cribbed from haskell, like the rest of do notation.</p>",
        "id": 228858574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614895357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/228857757\">said</a>:</p>\n<blockquote>\n<p>Mental parser: \"What kind of statement is this? Ah, it's a let; it's binding something. Oh, that's a refutable pattern. And there's the <code>else</code> for if it doesn't match...\"</p>\n</blockquote>\n<p>I think it can also go poorly in a mental parser, though: \"What kind of statement is this? Ah, it's a let, so it's irrefutable.  Wait, why is the <code>Ok(v)</code> irrefutable?  Is the error type <code>!</code>?  Oh, wait, there's an <code>else</code>, never mind.\"</p>\n<p>Rust is usually pretty good about not having \"common prefix\" syntax.</p>",
        "id": 228863661,
        "sender_full_name": "scottmcm",
        "timestamp": 1614897585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Fair.</p>",
        "id": 228870013,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614900939
    },
    {
        "content": "<p>Maybe <code>if not let</code>?</p>",
        "id": 229014382,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1614974043
    },
    {
        "content": "<p>I guess it's not that different from/better than <code>if !let</code></p>",
        "id": 229097007,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1615036393
    },
    {
        "content": "<p><code>if !let</code> opens weird questions about <code>if</code>-<code>else</code> chains, like the scoping for <code>if cond {} else if !let ...</code></p>",
        "id": 229197335,
        "sender_full_name": "cuviper",
        "timestamp": 1615132346
    },
    {
        "content": "<p>Maybe that's just not allowed, but then it makes an exception, that only <em>some</em> kinds of <code>else if</code> are allowed</p>",
        "id": 229197385,
        "sender_full_name": "cuviper",
        "timestamp": 1615132421
    },
    {
        "content": "<p>I think <code>if !let</code> only has weird scoping in the case where there is no fallback clause. If, for consistency, there is also a two-sided <code>if !let</code> then logically it should just be <code>if let</code> with the branches swapped</p>",
        "id": 229198045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615132948
    },
    {
        "content": "<p>I like that leading with <code>let</code> means that <code>let ... else</code> is introducing bindings in the current scope, like any other <code>let</code>. And the idea that the <code>else</code> can have the same (uninitialized) bindings means that it's naturally sharing the parent scope -- only the initialization is conditional, if the pattern is refuted.</p>",
        "id": 229198065,
        "sender_full_name": "cuviper",
        "timestamp": 1615132970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> you're saying that <code>if !let</code> would have an <code>else</code> with the bindings? But I think the whole idea is supposed to add bindings to the parent scope.</p>",
        "id": 229198193,
        "sender_full_name": "cuviper",
        "timestamp": 1615133104
    },
    {
        "content": "<p>Oh, but then <code>if cond {} else if !let pat = x {}</code> never binds <code>pat</code> - the bindings only last until the end of the <code>if !let pat = x {}</code> block which ends immediately because it is the <code>else</code> branch of a conditional</p>",
        "id": 229198211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615133132
    },
    {
        "content": "<p>yeah that's weird and useless</p>",
        "id": 229198238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615133158
    },
    {
        "content": "<p>Right</p>",
        "id": 229198312,
        "sender_full_name": "cuviper",
        "timestamp": 1615133185
    },
    {
        "content": "<p>I'm liking the \"can assign to the same bindings in the else\" approach. I still think the first version of this should just require divergence, but that no longer seems like a hard requirement for all future versions.</p>",
        "id": 229207330,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615141514
    },
    {
        "content": "<p>Hmm, would</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">unreachable!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>be Rust's first shift-reduce conflict?  Or are there other ones already in similarly-contrived cases?</p>",
        "id": 229215520,
        "sender_full_name": "scottmcm",
        "timestamp": 1615148919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Is.20the.20.60if.60.20in.20.60else.20if.60.20part.20of.20the.20first.20.60if.60.3F/near/229215520\">said</a>:</p>\n<blockquote>\n<p>Hmm, would</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">unreachable!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>be Rust's first shift-reduce conflict?  Or are there other ones already in similarly-contrived cases?</p>\n</blockquote>\n<p>Are you talking about <code>let ... else</code> there, or is there something else going on in that expression?</p>",
        "id": 229215960,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615149336
    },
    {
        "content": "<p>Oops, didn't notice that the thread was about <code>else if</code>, and wasn't the <code>let ...else</code> thread.  Yeah, I meant the \"does the else go with the if or the let\".  I'll see if I can move the messages...</p>",
        "id": 229216360,
        "sender_full_name": "scottmcm",
        "timestamp": 1615149725
    },
    {
        "content": "<p>(There, magically \"fixed\".)</p>",
        "id": 229216545,
        "sender_full_name": "scottmcm",
        "timestamp": 1615149918
    },
    {
        "content": "<p>I think you can count <code>{ {} &amp;&amp; false }</code> as a shift reduce conflict; there are some messy disambiguation rules in the code for this</p>",
        "id": 229216617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615149970
    },
    {
        "content": "<p>Ah, because of all the \"does a block need a semicolon\" magic?</p>",
        "id": 229216631,
        "sender_full_name": "scottmcm",
        "timestamp": 1615149994
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 229216633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615150002
    },
    {
        "content": "<p>Crazy idea: <code>let { pat = val } else { diverge }</code></p>",
        "id": 229216762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615150119
    },
    {
        "content": "<p>Also, the issue of <code>let ... else</code> with type <code>()</code> came up in previous discussions about <code>let ... else</code>, and the general conclusion was to just pick a direction to resolve it and not worry about it because in practice code using <code>let () = if</code> doesn't show up in the wild in ways that would break.</p>",
        "id": 229216789,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615150152
    },
    {
        "content": "<p>what's the issue with type <code>()</code>?</p>",
        "id": 229216804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615150187
    },
    {
        "content": "<p>I assume that <code>let () = val else { bla }</code> isn't valid (or would be linted against?) because the pattern is irrefutable so the else block is unreachable</p>",
        "id": 229216897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615150248
    },
    {
        "content": "<p>It'd potentially be an issue at parse time (before we got as far as \"is this pattern refutable\"), because of the ambiguity Scott mentioned above.</p>",
        "id": 229216926,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615150282
    },
    {
        "content": "<p>That ambiguity can just be resolved in favor of \"match the if with the else\", and if someone <em>really</em> wants the alternative (which as you observed would trigger a message about the refutable pattern) they can parenthesize the <code>if</code>:<br>\n<code>let () = (if ...) else { this is unreachable }</code>.</p>",
        "id": 229217013,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615150369
    },
    {
        "content": "<p>It does feel like we have a bunch of \"expression because match arms and such, not because anyone ever really cares\" cases.</p>\n<p>Probably not worth moving all those things in the grammar, but surprisingly we don't even seem to lint about them:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7f6ab60cfa2739526ae48497da3b2272\">without complaint</a>.</p>",
        "id": 229217353,
        "sender_full_name": "scottmcm",
        "timestamp": 1615150795
    },
    {
        "content": "<p>what's wrong with that? I'm sure I've written code like that</p>",
        "id": 229217560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615150934
    },
    {
        "content": "<p>I've started using clippy and it gets hissy about passing units generated in \"interesting\" ways to a function, but it's a nice way to compress statements, especially if that's a closure</p>",
        "id": 229217651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615151036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I don't feel like <code>if</code> without <code>else</code> having type <code>()</code> is just for match arms; I think it's part of the general Rust property that there's no such thing as a statement, only an expression of type <code>()</code>.</p>",
        "id": 229218691,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615151996
    },
    {
        "content": "<p>(There are exceptions, namely defining an item. But still.)</p>",
        "id": 229218750,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615152008
    },
    {
        "content": "<p>and <code>let</code></p>",
        "id": 229218760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615152017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I mention match arms as the one place that comes to mind for me where assignment, for example, being a statement instead of an expression matters (as it allows <code>=&gt; a = b,</code> instead of needing <code>=&gt; { a = b; }</code>).</p>",
        "id": 229218967,
        "sender_full_name": "scottmcm",
        "timestamp": 1615152238
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> we do need to decide whether the new bindings are visible in <code>else</code>, even if it's required to diverge, because of shadowing.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// ...</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Does this see `None`, or the new uninitialized binding?</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 229221395,
        "sender_full_name": "cuviper",
        "timestamp": 1615154603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> Oh, interesting.</p>",
        "id": 229221456,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154666
    },
    {
        "content": "<p>If it saw the new uninitialized binding it would need to fail to compile, presumably.</p>",
        "id": 229221468,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154685
    },
    {
        "content": "<p>Yes</p>",
        "id": 229221477,
        "sender_full_name": "cuviper",
        "timestamp": 1615154707
    },
    {
        "content": "<p>And good example, because I'd expect <code>let Some(name) = name else { ... }</code> to be a very common pattern for \"refinement\".</p>",
        "id": 229221482,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154710
    },
    {
        "content": "<p>At first glance, that pattern makes me inclined towards \"no, they shouldn't be visible\", because it seems entirely reasonable to be able to access the pre-refinement value inside the else.</p>",
        "id": 229221551,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154768
    },
    {
        "content": "<p>Well, the shadowing doesn't even have to be that immediate. It could have been something separate that was shadowed.</p>",
        "id": 229221713,
        "sender_full_name": "cuviper",
        "timestamp": 1615154895
    },
    {
        "content": "<p>Sure, but I think the refinement case is likely to be common.</p>",
        "id": 229221731,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154919
    },
    {
        "content": "<p>Your idea that the new uninitialized binding could be visible and assigned to does make sense, if we want to allow non-diverging <code>else</code>.</p>\n<p>So I think this now becomes a question of which we'd expect to be more common: diverging else that may want to use the non-refined value (e.g. to include it or a formatted version of it in an error), or non-diverging else that wants to initialize the value in a different way in the else.</p>",
        "id": 229221764,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154941
    },
    {
        "content": "<p>Either way, one of those two will become more difficult to write.</p>",
        "id": 229221787,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615154962
    },
    {
        "content": "<p>I think you just shouldn't shadow if that's what you need, or you can use a full <code>match</code>.</p>",
        "id": 229221788,
        "sender_full_name": "cuviper",
        "timestamp": 1615154963
    },
    {
        "content": "<p>For the sake of completeness, I'll point out that there's a \"choose not to decide\" choice here: we could error on any reference to the new binding from within the <code>else</code>, even if there's a shadowed binding in scope, which would be forward-compatible with either option. I don't necessarily think that's a good idea, but it seems worth mentioning.</p>",
        "id": 229221874,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155022
    },
    {
        "content": "<p>Erroring like that <em>might</em> be a good idea if we think people will find such code confusing or ambiguous to read.</p>",
        "id": 229221896,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155045
    },
    {
        "content": "<p>I guess the non-diverging use could <code>match</code> too</p>",
        "id": 229221905,
        "sender_full_name": "cuviper",
        "timestamp": 1615155057
    },
    {
        "content": "<p>Right.</p>",
        "id": 229221907,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155062
    },
    {
        "content": "<p>Why don't we write two sensible examples, one for each, and see how they'd look depending on which way we go?</p>",
        "id": 229221955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/229221905\">said</a>:</p>\n<blockquote>\n<p>I guess the non-diverging use could <code>match</code> too</p>\n</blockquote>\n<p>I also suspect the non-diverging case could potentially use <code>unwrap_or</code> or <code>unwrap_or_else</code>, frequently.</p>",
        "id": 229222044,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155161
    },
    {
        "content": "<p>Diverging case that benefits from referencing the pre-refinement binding:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"p\">.</span><span class=\"n\">parse</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">fatal_parse_error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Failed to parse number: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Non-diverging case that benefits from assigning to the new binding:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">parse</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">non_fatal_parse_error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Failed to parse number: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">token</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// try to recover, to catch more errors in the same run</span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 229222446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155511
    },
    {
        "content": "<p>In the diverging case, we could rewrite it as a match or if-let (which would defeat the purpose of <code>let ... else</code> I think), or modify the names to avoid shadowing.</p>\n<p>In the non-diverging case, we could rewrite that to use <code>token.parse::&lt;u64&gt;().unwrap_or_else(...)</code>.</p>",
        "id": 229222564,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> Do those seem like fair examples to you?</p>",
        "id": 229222652,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615155682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/229222044\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else/near/229221905\">said</a>:</p>\n<blockquote>\n<p>I guess the non-diverging use could <code>match</code> too</p>\n</blockquote>\n<p>I also suspect the non-diverging case could potentially use <code>unwrap_or</code> or <code>unwrap_or_else</code>, frequently.</p>\n</blockquote>\n<p>For sure I'm going to be using this for patterns other than Option though, which generally has more than enough combinators to cover all these use cases already. Stuff like <code>let Expr::Add(lhs, rhs) = add_expr else { continue }</code></p>",
        "id": 229223559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615156611
    },
    {
        "content": "<p>Fair.</p>",
        "id": 229223593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615156672
    },
    {
        "content": "<p>The question then becomes, do you ever want to <em>not</em> diverge in the else, and instead assign to <code>lhs</code> and <code>rhs</code>?</p>",
        "id": 229223635,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615156686
    },
    {
        "content": "<p>And would that be clearer than using a match or if-let?</p>",
        "id": 229223649,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615156697
    },
    {
        "content": "<p>I wouldn't be bothered much if this didn't support non-divergence at all, there are plenty of other ways to write it if necessary</p>",
        "id": 229223685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615156760
    },
    {
        "content": "<p>I see the appeal of making the control flow more regular though</p>",
        "id": 229223745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615156810
    },
    {
        "content": "<p>TBH, I really like the \"skimmability\" benefit of forced-diverging for these cases.</p>",
        "id": 229223805,
        "sender_full_name": "scottmcm",
        "timestamp": 1615156902
    },
    {
        "content": "<p>I think there is some readability hazard in having those uninitialized bindings in scope in the else branch</p>",
        "id": 229223859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615156930
    },
    {
        "content": "<p>there isn't anything in the code that makes that scoping obvious</p>",
        "id": 229223870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615156945
    },
    {
        "content": "<p>It lets the first read ignore the <code>else</code> branch as irrelevant for the code that comes next, like how one can read code in a first pass by not thinking about the <code>?</code>s.</p>\n<p>(And it's a really elegant consequence of rust having <code>!</code> in the type system.)</p>",
        "id": 229223900,
        "sender_full_name": "scottmcm",
        "timestamp": 1615156994
    },
    {
        "content": "<p>\"lets the first read ignore the else branch\" is a nice way of putting it.</p>",
        "id": 229224093,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615157191
    },
    {
        "content": "<p>\"To a first approximation, make this binding; see the else case for how this code handles the pattern not matching.\"</p>",
        "id": 229224153,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615157240
    },
    {
        "content": "<p>I do think that exposing the uninitialized bindings in the else case was a really clever idea, though.</p>",
        "id": 229224224,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615157299
    },
    {
        "content": "<p>But on balance, I feel like this will be clearer if we require the <code>else</code> to always diverge, and give it access to whatever the binding <em>would</em> have shadowed if anything.</p>",
        "id": 229224240,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615157336
    },
    {
        "content": "<p>The uninitialized bindings in the <code>else</code> is also nice in that it avoids the temptation to want typestate-like things in</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">yeet</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 229224348,
        "sender_full_name": "scottmcm",
        "timestamp": 1615157435
    },
    {
        "content": "<p>should there be a second let-else there?</p>",
        "id": 229224389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615157495
    },
    {
        "content": "<p>Oh I see, it's doing the second half of a pattern match</p>",
        "id": 229224397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615157521
    },
    {
        "content": "<p>Scott goes off on a wild tangent idea:<br>\n<code>let v = foo?;</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">yeet</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(Basically lean into how this is all sugar for a <code>match</code> anyway.  This doesn't trip my usual \"I don't want <code>else match</code>\" because it's all one construct, so the match can work without needing typestate.)</p>",
        "id": 229224443,
        "sender_full_name": "scottmcm",
        "timestamp": 1615157529
    },
    {
        "content": "<p>(Aside: this is something fmt-rfcs should make a call on, but I think <code>let ... else</code> should generally be formatted with a hanging else.)</p>",
        "id": 229226364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615159432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Doesn't that mean the <code>else match</code> construct still has to implement a kind of typestate in order to implement exhaustiveness checking?</p>",
        "id": 229226476,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615159541
    },
    {
        "content": "<p>Either way, I don't think I'd want to have that; at that point it's no longer clearer than a match, I think.</p>",
        "id": 229226553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615159588
    },
    {
        "content": "<p>I'm picturing that as one big construct which would desugar to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">yeet</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 229226563,
        "sender_full_name": "scottmcm",
        "timestamp": 1615159611
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 229226568,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615159621
    },
    {
        "content": "<p>Is that something you'd want to seriously propose, or a thought experiment you wanted to explore?</p>",
        "id": 229226592,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615159641
    },
    {
        "content": "<p>More the latter.</p>\n<p>Inspired by the shadowing discussion of whether the original value would be available in <code>let Some(v) = v else {... };</code>, I was thinking what it would look like if someone actually wanted to use that value somehow.</p>\n<p>As well as pondering whether there'd be other cases for the \"I want the first-read-ignores-the-else\" and \"it sure would be nice to not have to repeat the bindings\" that would be more than binary.  Like if <a href=\"https://api.rocket.rs/v0.4/rocket/enum.Outcome.html\"><code>let Outcome::Success(x) = ...</code></a> might be useful only if the other paths could match their variants.</p>",
        "id": 229226828,
        "sender_full_name": "scottmcm",
        "timestamp": 1615159861
    },
    {
        "content": "<p>I feel like if the else case cares about knowing that it isn't the case described by the refutable let pattern, that's a good sign to use a match instead.</p>",
        "id": 229226929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615159953
    },
    {
        "content": "<p>If you want to write <code>let Outcome::Success(x) = expr else { diverge with note about expr }</code>, that seems like a good use of <code>let ... else</code>. If the else expression wants to match on <code>expr</code> and you want to avoid having to write something like <code>Outcome::Success =&gt; unreachable!()</code>, use <code>match</code> instead of <code>let ... else</code>.</p>",
        "id": 229226999,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615160035
    },
    {
        "content": "<p>I do agree that it <em>could</em> be desugared the way you described though.</p>",
        "id": 229227051,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615160052
    }
]