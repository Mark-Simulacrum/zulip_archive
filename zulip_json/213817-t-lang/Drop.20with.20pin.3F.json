[
    {
        "content": "<p>Will be <code>fn drop(self: Pin&lt;&amp;mut Self&gt;)</code> included in 2021 edition?</p>",
        "id": 231307913,
        "sender_full_name": "Soveu",
        "timestamp": 1616419179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> i'm not aware of any plans for that yet. but there's still time left if there's a concrete proposal</p>",
        "id": 231327547,
        "sender_full_name": "Mara",
        "timestamp": 1616426254
    },
    {
        "content": "<p>what is that :)</p>",
        "id": 231335901,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616428813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/231335901\">said</a>:</p>\n<blockquote>\n<p>what is that :)</p>\n</blockquote>\n<p>basically, current definition of <code>Drop</code> can be kinda unsound when used with <code>!Unpin</code> types, because it gives you <code>&amp;mut Self</code> instead of <code>Pin&lt;&amp;mut Self&gt;</code> so some workarounds are needed, for example</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">PinnedStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* We have just &amp;mut self even though the pointer should be also pinned */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">pin_drop</span><span class=\"p\">(</span><span class=\"n\">seif</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"cm\">/* Using it here is now safer */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pin_drop</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 231358065,
        "sender_full_name": "Soveu",
        "timestamp": 1616436657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120054\">@Jon Gjengset</span> was talking about this during his <code>Pin</code> Crust of Rust stream</p>",
        "id": 231358586,
        "sender_full_name": "Soveu",
        "timestamp": 1616436870
    },
    {
        "content": "<p>and it doesn't make drop of <code>Unpin</code> types more complex, just <code>Pin::get_mut</code> is needed</p>",
        "id": 231360876,
        "sender_full_name": "Soveu",
        "timestamp": 1616437798
    },
    {
        "content": "<p>Yeah, <code>Pin&lt;&amp;mut Self&gt;</code> is the right receiver type for <code>Drop</code></p>",
        "id": 232174605,
        "sender_full_name": "RalfJ",
        "timestamp": 1616946439
    },
    {
        "content": "<p>the fact that it is currently <code>&amp;mut Self</code> means that the <code>Pin</code> docs need to specifically warn about being careful in the destructor</p>",
        "id": 232174639,
        "sender_full_name": "RalfJ",
        "timestamp": 1616946474
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/issues/3105\">https://github.com/rust-lang/rfcs/issues/3105</a></p>",
        "id": 233085744,
        "sender_full_name": "Soveu",
        "timestamp": 1617548087
    },
    {
        "content": "<p>This is easily going to be the most invasive change in the edition, if we go forward with it.</p>",
        "id": 233100158,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617557837
    },
    {
        "content": "<p>Regarding the \"use compiler magic\" solution, what if we used a different method, instead? We could call pin_drop instead of drop, on pinned types, so that drop doesn't have to have different parameter types. That would mean most code doesn't need to change.</p>",
        "id": 233100245,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617557945
    },
    {
        "content": "<p>Or, for that matter, we could use compiler magic to provide a default implementation of pin_drop for Unpin that calls drop. Effectively, a \"conditional default impls\" mechanism for traits.</p>",
        "id": 233100355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617558034
    },
    {
        "content": "<p>Then, the error message you would get when using a type that is not Unpin would make perfect sense: no impl of pin_drop.</p>",
        "id": 233100394,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617558087
    },
    {
        "content": "<p>By \"more problems\" i was thinking about case where a type is generic over T</p>",
        "id": 233102373,
        "sender_full_name": "Soveu",
        "timestamp": 1617560318
    },
    {
        "content": "<p>then, how to handle both pinned and Unpinned cases?</p>",
        "id": 233102400,
        "sender_full_name": "Soveu",
        "timestamp": 1617560367
    },
    {
        "content": "<p>The best middle-ground between the different issues would be, imho, to have a <code>PinnedDrop</code> trait with a blanket impl of <code>Drop</code> for it (<em>Ã  la</em> <a href=\"https://github.com/taiki-e/pin-project/blob/c8c8b5db302ad7b26d5c59da07bd1fa78d1173d3/src/lib.rs#L185-L188\">https://github.com/taiki-e/pin-project/blob/c8c8b5db302ad7b26d5c59da07bd1fa78d1173d3/src/lib.rs#L185-L188</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">PinnedDrop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// `unsafe fn` or compiler magic cannot / should not be called directly,</span>\n<span class=\"w\">    </span><span class=\"c1\">// except within an `Drop` impl:</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">drop_pinned</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"nb\">_</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cm\">/* unsafe */</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- see below</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">PinnedDrop</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">PinnedDrop</span>::<span class=\"n\">drop_pinned</span><span class=\"p\">(</span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I suspect that writing this in <code>core</code> <em>as is</em> will probably cause coherence problems, so that's where I'd expect the compiler magic to kick in and manage to make this case work as expected.</p>\n<hr>\n<p>An extension to that would be, if that were possible within an edition boundary (I suspect it technically isn't, although it <em>could</em>), to then make <code>impl Drop</code> require <code>unsafe</code> unless we have <code>Self : Unpin</code>.</p>\n<ul>\n<li>That way, for the vast majority of types out there which are already <code>Unpin</code>, we still have <code>impl Drop</code> work as expected.</li>\n<li>For types for which <code>Self : Unpin</code> does not generically hold (types that \"are not\" / \"may not be\" <code>Unpin</code>), then the compiler will error about the missing <code>unsafe</code>, suggesting the non-<code>unsafe</code> <code>PinnedDrop</code> trait be implemented instead.</li>\n<li>Callers can still use <code>unsafe impl Drop</code> if they know what they are doing? (<em>e.g.</em>, they somehow know that all instances of <code>Self</code> will never be exposed to arbitrary code behind a <code>Pin</code>ning pointer) To be fair, I find this very much equivalent to not offering this option altogether, and requiring thats users use <code>Pin::get_unchecked_mut()</code> within a <code>PinnedDrop</code> implementation (way more explicit / readable way of using <code>unsafe</code>).</li>\n</ul>",
        "id": 233103047,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617561158
    },
    {
        "content": "<p>or just include an \"optional\" method</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cm\">/* unsafe? */</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">pin_drop</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"cm\">/* If type is Unpin, this uses normal drop if it is defined */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 233103691,
        "sender_full_name": "Soveu",
        "timestamp": 1617561946
    },
    {
        "content": "<p>crazy idea: implement <code>DerefMut&lt;Target=T&gt; for Pin&lt;&amp;mut T&gt; where T: Unpin</code><br>\nthen drop signature will still be changed to <code>fn drop(self: Pin&lt;&amp;mut Self&gt;)</code>, but <code>self.field</code> will normally work</p>",
        "id": 233103979,
        "sender_full_name": "Soveu",
        "timestamp": 1617562308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/233103979\">said</a>:</p>\n<blockquote>\n<p>crazy idea: implement <code>DerefMut&lt;Target=T&gt; for Pin&lt;&amp;mut T&gt; where T: Unpin</code></p>\n</blockquote>\n<p>we already have that: <a href=\"https://doc.rust-lang.org/stable/std/pin/struct.Pin.html#impl-DerefMut\">https://doc.rust-lang.org/stable/std/pin/struct.Pin.html#impl-DerefMut</a></p>",
        "id": 233104269,
        "sender_full_name": "Mara",
        "timestamp": 1617562622
    },
    {
        "content": "<p>Then, what is the major issue with just changing the <code>fn drop</code> signature?<br>\nIn <code>Unpin</code> case (so in most of them)  it requires _just_ changing the receiver type</p>",
        "id": 233105605,
        "sender_full_name": "Soveu",
        "timestamp": 1617564126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/233103691\">said</a>:</p>\n<blockquote>\n<p>or just include an \"optional\" method</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cm\">/* unsafe? */</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">pin_drop</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"cm\">/* If type is Unpin, this uses normal drop if it is defined */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is what I was proposing above.</p>",
        "id": 233113693,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617571167
    },
    {
        "content": "<p>But also, that raises an interesting notion.</p>",
        "id": 233113782,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617571262
    },
    {
        "content": "<p>We could special-case <code>Drop::drop</code> in the compiler, such that if and <em>only</em> if your type implement <code>Unpin</code>, you're <em>allowed</em> (but not required) to write the signature as <code>fn drop(&amp;mut self)</code>, in which case the compiler will dereference the Pin for you. If your type doesn't implement <code>Unpin</code>, you start getting a compilation error in the edition, telling you very specifically that you need to write <code>fn drop(Pin&lt;&amp;mut self&gt;)</code> instead, and pointing to some hints about how to do that safely.</p>",
        "id": 233113885,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617571351
    },
    {
        "content": "<p>Given how <em>many</em> drop impls exist, and how <em>few</em> of them need to worry about <code>Pin</code>, I think that would be worth doing to improve compatibility.</p>",
        "id": 233113902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617571376
    },
    {
        "content": "<p>That's roughly equivalent to the notion of <code>pin_drop</code>; either way we'd need some compiler special-casing.</p>",
        "id": 233113928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617571422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/233113885\">said</a>:</p>\n<blockquote>\n<p>We could special-case <code>Drop::drop</code> in the compiler, such that if and <em>only</em> if your type implement <code>Unpin</code>, you're <em>allowed</em> (but not required) to write the signature as <code>fn drop(&amp;mut self)</code>, in which case the compiler will dereference the Pin for you. If your type doesn't implement <code>Unpin</code>, you start getting a compilation error in the edition, telling you very specifically that you need to write <code>fn drop(Pin&lt;&amp;mut self&gt;)</code> instead, and pointing to some hints about how to do that safely.</p>\n</blockquote>\n<p>But what about types generic over some T, where T can be both pinned or <code>Unpin</code>ned?</p>",
        "id": 233281454,
        "sender_full_name": "Soveu",
        "timestamp": 1617696538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> Fair point.</p>",
        "id": 233373220,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617736563
    },
    {
        "content": "<p>For now, we could allow both <code>&amp;mut self</code> and <code>Pin&lt;&amp;mut Self&gt;</code>, deprecating the first one</p>",
        "id": 233479866,
        "sender_full_name": "Soveu",
        "timestamp": 1617799454
    },
    {
        "content": "<p>So meanwhile we are talking about how to break the smallest subset of <a href=\"http://crates.io\">crates.io</a>, the problem at least starts to fix itself :D</p>",
        "id": 233480230,
        "sender_full_name": "Soveu",
        "timestamp": 1617799624
    },
    {
        "content": "<p>Deprecating <code>fn drop(&amp;mut self)</code> is a... massive change that would cause a ton of churn.</p>",
        "id": 234019569,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1618121366
    },
    {
        "content": "<p>Do we have other option? Deprecation doesn't break code, it just generates a warning</p>",
        "id": 234290603,
        "sender_full_name": "Soveu",
        "timestamp": 1618304029
    },
    {
        "content": "<p>Honestly, I'm less concerned about the churn, and more concerned about the side effect of forcing the larger set of people who care about Drop to have to know about Pin.</p>",
        "id": 234367930,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618334822
    },
    {
        "content": "<p>I would love to make it so that only people who need to deal with Pin already have to deal with it here, if that's possible.</p>",
        "id": 234368031,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618334861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/234290603\">said</a>:</p>\n<blockquote>\n<p>Do we have other option? Deprecation doesn't break code, it just generates a warning</p>\n</blockquote>\n<p>Rust has a strong culture of wanting zero-warning builds, so that would still effect a lot churn</p>",
        "id": 234368505,
        "sender_full_name": "cuviper",
        "timestamp": 1618335018
    },
    {
        "content": "<blockquote>\n<p>The side effect of forcing the larger set of people who care about Drop to have to know about Pin.</p>\n</blockquote>\n<p>what about something like: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">DropGuard</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and <br>\n<code>fn drop(self: DropGuard&lt;'_, Self&gt;) {...}</code></p>",
        "id": 234454481,
        "sender_full_name": "Charles Lew",
        "timestamp": 1618385832
    },
    {
        "content": "<p>We discussed this briefly in today's @T-lang design meeting. We agreed that this isn't going to be able to make the 2021 edition; it's just too last-minute and there's no concrete design proposal we're prepared to accept, so getting such a change through design, implementation, and stabilization would be too much.</p>",
        "id": 234549512,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618424543
    },
    {
        "content": "<p>That said, we'd still like to see this worked on, just not tied to this edition.</p>",
        "id": 234549562,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618424564
    },
    {
        "content": "<p>And we discovered that some people aren't seeing this discussion at all, because it's been in the edition 2021 stream.</p>",
        "id": 234549618,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618424583
    },
    {
        "content": "<p>With that in mind, any objections to moving this thread elsewhere, either to the lang or libs stream?</p>",
        "id": 234549669,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618424606
    },
    {
        "content": "<p>I think it may be worth clarifying that \"still like to see this worked on\" --- this is not meant, I think, to imply that there is consensus within the lang team on necessarily doing something here, just that there is interest in potentially seeing a proposal, correct?</p>",
        "id": 234549779,
        "sender_full_name": "simulacrum",
        "timestamp": 1618424646
    },
    {
        "content": "<p>(I am happy to move the thread once we decide where. I lean towards lang, myself, but no strong opinion).</p>",
        "id": 234549823,
        "sender_full_name": "simulacrum",
        "timestamp": 1618424669
    },
    {
        "content": "<p>I'm not suggesting that there was a consensus to do something; I'm suggesting that there was a consensus to continue discussing this and figure out if we should do something.</p>",
        "id": 234550237,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618424838
    },
    {
        "content": "<p>I'd lean towards lang as well, since Drop is heavily language-integrated, and since some potential proposals for handling this would require language changes.</p>",
        "id": 234550381,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618424888
    },
    {
        "content": "<p>Ok, well, I'll take that as brief consensus. Moving is pretty cheap. I'll do that :)</p>",
        "id": 234550854,
        "sender_full_name": "simulacrum",
        "timestamp": 1618425075
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"268952\" href=\"/#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F\">#edition 2021 &gt; Drop with pin?</a> by <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span></p>",
        "id": 234550881,
        "sender_full_name": "Notification Bot",
        "timestamp": 1618425089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234368505\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/234290603\">said</a>:</p>\n<blockquote>\n<p>Do we have other option? Deprecation doesn't break code, it just generates a warning</p>\n</blockquote>\n<p>Rust has a strong culture of wanting zero-warning builds, so that would still effect a lot churn</p>\n</blockquote>\n<p>That was kinda the idea - \"force\" people to fix their code by themselves :D</p>\n<p>On the other hand, <em>just</em> accepting both <code>fn drop(&amp;mut self)</code> and <code>fn drop(self: Pin&lt;&amp;mut Self&gt;)</code>might be a decent idea for now - it doesn't break code and allows to use Pin for those who want it</p>",
        "id": 234883656,
        "sender_full_name": "Soveu",
        "timestamp": 1618590500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> I'd actually be happy to push people towards Pin if their types require it. I just don't want to make people whose types don't need to worry about Pin deal with Pin.</p>",
        "id": 234885831,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618591403
    },
    {
        "content": "<p>So, it's fine if people who use Pin but have <code>drop</code> take just <code>&amp;mut self</code> get a warning, I just don't want <em>every</em> user of Drop to get a warning.</p>",
        "id": 234885885,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618591427
    },
    {
        "content": "<p>how about changing <code>Drop</code> to require <code>Pin&lt;&amp;mut Self&gt;</code> if <code>Self: !Unpin</code> otherwise allow either <code>&amp;mut self</code> or <code>Pin&lt;&amp;mut self&gt;</code> on a new edition? <code>Drop</code> is already basically compiler magic since it doesn't act at all like a normal trait -- you can't call it directly and it doesn't really work in bounds (if I were redesigning Rust, I'd probably have it not be a trait)</p>",
        "id": 234902363,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1618598572
    },
    {
        "content": "<p>That would play havoc with generics that may or may not be <code>Unpin</code>.</p>",
        "id": 234902449,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1618598625
    },
    {
        "content": "<p>not really, just use the <code>Pin&lt;&amp;mut Self&gt;</code> version -- it works in both cases.</p>",
        "id": 234902590,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1618598683
    },
    {
        "content": "<p>That was one of the original ideas</p>",
        "id": 234902865,
        "sender_full_name": "Soveu",
        "timestamp": 1618598792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/233281454\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/Drop.20with.20pin.3F/near/233113885\">said</a>:</p>\n<blockquote>\n<p>We could special-case <code>Drop::drop</code> in the compiler, such that if and <em>only</em> if your type implement <code>Unpin</code>, you're <em>allowed</em> (but not required) to write the signature as <code>fn drop(&amp;mut self)</code>, in which case the compiler will dereference the Pin for you. If your type doesn't implement <code>Unpin</code>, you start getting a compilation error in the edition, telling you very specifically that you need to write <code>fn drop(Pin&lt;&amp;mut self&gt;)</code> instead, and pointing to some hints about how to do that safely.</p>\n</blockquote>\n<p>But what about types generic over some T, where T can be both pinned or <code>Unpin</code>ned?</p>\n</blockquote>",
        "id": 234902915,
        "sender_full_name": "Soveu",
        "timestamp": 1618598821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234902865\">said</a>:</p>\n<blockquote>\n<p>That was one of the original ideas</p>\n</blockquote>\n<p>guess that's what I get for not reading the whole history... :)</p>",
        "id": 234903098,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1618598893
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> Hmmm. Since <code>Unpin</code> is an auto-trait, if you have a generic <code>T</code> that you don't know to be <code>Unpin</code>, that means you've declared it as <code>?Unpin</code>, right?</p>",
        "id": 234903149,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234903098\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234902865\">said</a>:</p>\n<blockquote>\n<p>That was one of the original ideas</p>\n</blockquote>\n<p>guess that's what I get for not reading the whole history... :)</p>\n</blockquote>\n<p>originally this topic was on <a class=\"stream\" data-stream-id=\"268952\" href=\"/#narrow/stream/268952-edition-2021\">#edition 2021</a></p>",
        "id": 234903228,
        "sender_full_name": "Soveu",
        "timestamp": 1618598965
    },
    {
        "content": "<p>If that's the case, then I think it'd be perfectly fine to require using <code>Pin&lt;&amp;mut self&gt;</code> in that case, because you've mentioned <code>?Unpin</code> so it's OK to make you deal with pinning.</p>",
        "id": 234903340,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599011
    },
    {
        "content": "<p>Whereas if you write <code>impl&lt;T&gt; Drop for Foo&lt;T&gt;</code>, without mentioning pin/unpin, you get something that's <code>Unpin</code>, so it's OK to let you use <code>&amp;mut self</code>.</p>",
        "id": 234903403,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599046
    },
    {
        "content": "<p>It seems like that'd be a relatively reasonable and understandable heuristic for people to deal with.</p>",
        "id": 234903888,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599287
    },
    {
        "content": "<p>So <code>!Unpin</code> will go under <code>?Unpin</code> ?</p>",
        "id": 234904255,
        "sender_full_name": "Soveu",
        "timestamp": 1618599481
    },
    {
        "content": "<p>Right, either way you've mentioned pinning so you get to deal with pinning.</p>",
        "id": 234904327,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599499
    },
    {
        "content": "<p>If you can statically determine that the type is <code>Unpin</code> then you can use <code>&amp;mut self</code>, if not then you have to deal with <code>Pin&lt;&amp;mut self&gt;</code>.</p>",
        "id": 234904401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599535
    },
    {
        "content": "<p>Pondering: since <code>Drop</code> is already a weird magic trait that you can't even call and <em>shouldn't</em> ever mention in bounds, we could start calling a different <code>PinDrop</code> in certain situations, right?</p>",
        "id": 234904450,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> That would certainly make this change fit into the language better and be less magical. The only \"downside\" would be that you can't mention <code>Drop</code> bounds without accounting for <code>PinDrop</code>.</p>",
        "id": 234904624,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599621
    },
    {
        "content": "<p>Now the <code>?Unpin</code> solution that Josh proposed is my new favorite</p>",
        "id": 234904736,
        "sender_full_name": "Soveu",
        "timestamp": 1618599669
    },
    {
        "content": "<p>You could have compiler generated impls so you can still make sure a drop impl isn't provided. Or really I think blanket impls would work.</p>",
        "id": 234904760,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1618599683
    },
    {
        "content": "<p>Prior art: C# has both <code>IDisposable</code> and <a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable?view=net-5.0\"><code>IAsyncDisposable</code></a>, which is one of the things that had me thinking in that way.  <code>using var</code> will call the former, and <code>await using var</code> will call the latter.</p>\n<p>(AsyncDrop isn't directly related to PinDrop, but whatever happens here might start to set precedent for the other.)</p>",
        "id": 234904970,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> If we had both <code>Drop</code> and <code>PinDrop</code> (I can already see the puns coming), how would we expect people to drop things? Would <code>drop(x)</code> move to having a <code>PinDrop</code> bound, and we'd have a blanket impl from <code>Drop</code> to <code>PinDrop</code>?</p>",
        "id": 234905041,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599803
    },
    {
        "content": "<p>(I mean, technically <code>drop</code> doesn't actually express that bound...)</p>",
        "id": 234905081,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599829
    },
    {
        "content": "<p>Well <code>drop(x)</code> moves <code>x</code>, so doing it on a pinned value would be bad.</p>",
        "id": 234905345,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1618599953
    },
    {
        "content": "<p>imho <code>mem::drop</code> should always just be <code>pub fn drop&lt;T&gt;(_: T) {}</code></p>",
        "id": 234905893,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1618600210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> so, you want <code>Unpin</code> to become like <code>Sized</code>?<br>\nThat would mean some types would start to reject pinned types, because of the implicit <code>Unpin</code> bound</p>",
        "id": 234906454,
        "sender_full_name": "Soveu",
        "timestamp": 1618600474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> I was under the impression it already is.</p>",
        "id": 234906524,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600515
    },
    {
        "content": "<p>It's an auto trait that's implemented by default.</p>",
        "id": 234906549,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600527
    },
    {
        "content": "<p>I wasnât aware that the <code>?Trait</code> supported anything today besides <code>?Sized</code></p>",
        "id": 234906700,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618600596
    },
    {
        "content": "<p>but Iâd be happy to be proven wrong</p>",
        "id": 234906712,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618600606
    },
    {
        "content": "<p>/me goes to look</p>",
        "id": 234906726,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618600613
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Pinned</span><span class=\"p\">(</span><span class=\"n\">PhantomPinned</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// this doesn't compile</span>\n<span class=\"k\">fn</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">Pinned</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// this does</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span></p>",
        "id": 234906985,
        "sender_full_name": "Soveu",
        "timestamp": 1618600743
    },
    {
        "content": "<p>/me is a little confused about <code>Unpin</code> being an auto trait, then...</p>",
        "id": 234907155,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600818
    },
    {
        "content": "<p>Send and Sync are also auto-traits, but you don't have to specify ?Send + ?Sync every time you write a struct</p>",
        "id": 234907239,
        "sender_full_name": "Soveu",
        "timestamp": 1618600857
    },
    {
        "content": "<p>Ah, fair point.</p>",
        "id": 234907275,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600866
    },
    {
        "content": "<p>That makes sense; a trait can be automatic but not assumed in all trait bounds the way <code>Sized</code> is.</p>",
        "id": 234907314,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600892
    },
    {
        "content": "<p>Alright. Then this idea doesn't work at all.</p>",
        "id": 234907329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600900
    },
    {
        "content": "<p>(well, i think the idea could be tied to an edition change. But its too late for 2021.)</p>",
        "id": 234907441,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618600956
    },
    {
        "content": "<p>Another one is to massively hack negative bounds to allow them with Drop</p>",
        "id": 234907459,
        "sender_full_name": "Soveu",
        "timestamp": 1618600966
    },
    {
        "content": "<p>That would still mean that you couldn't write a <code>Drop</code> impl using <code>&amp;mut self</code> if you accepted a generic <code>T</code>, which breaks the premise of \"you only have to deal with <code>Pin&lt;&amp;mut self&gt;</code> if you already deal with pinning\".</p>",
        "id": 234907608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618601045
    },
    {
        "content": "<p>yeah</p>",
        "id": 234907650,
        "sender_full_name": "Soveu",
        "timestamp": 1618601069
    },
    {
        "content": "<p>(I was thinking something along the lines of âfor new editions, <code>impl&lt;T&gt; Drop for â¦</code> has an implicit <code>T: Unpin</code> bound, and you <em>have</em> to write <code>impl&lt;T: ?Unpin&gt; Drop for â¦</code> if you donât want it.)</p>",
        "id": 234907755,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601119
    },
    {
        "content": "<p>problem with this is, you can forget to add the bound and then suddenly, without any warning you lose your drop impl</p>",
        "id": 234907904,
        "sender_full_name": "Soveu",
        "timestamp": 1618601187
    },
    {
        "content": "<p>hmm</p>",
        "id": 234907959,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601220
    },
    {
        "content": "<p>that seems like something the compiler could error on</p>",
        "id": 234907978,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601230
    },
    {
        "content": "<p>we already require <code>impl Drop for Struct</code> to have a pretty strong match with the <code>struct Struct</code> declaration itself</p>",
        "id": 234908039,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601266
    },
    {
        "content": "<p>in terms of forcing the bounds to be the same in both cases</p>",
        "id": 234908057,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601280
    },
    {
        "content": "<p>The âlose your drop implâ that you describe <span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> sounds like another instance of that?</p>",
        "id": 234908131,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601299
    },
    {
        "content": "<p>As I said, for now maybe it will be good enough to allow both <code>fn drop(&amp;mut self)</code> and <code>fn drop(self: Pin&lt;&amp;mut Self&gt;)</code>unconditionally<br>\nIt is kinda how Josh wants it, no one needs to mess with Pin if they don't need/want to</p>",
        "id": 234908204,
        "sender_full_name": "Soveu",
        "timestamp": 1618601331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234907978\">said</a>:</p>\n<blockquote>\n<p>that seems like something the compiler could error on</p>\n</blockquote>\n<p>How would compiler know if this is intentional or not?</p>",
        "id": 234908458,
        "sender_full_name": "Soveu",
        "timestamp": 1618601453
    },
    {
        "content": "<p><code>impl&lt;T&gt;</code> is <code>impl&lt;T&gt;</code></p>",
        "id": 234908509,
        "sender_full_name": "Soveu",
        "timestamp": 1618601481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> We could even require that you use <code>Pin&lt;&amp;mut self&gt;</code> if we can statically tell that you aren't Unpin.</p>",
        "id": 234908611,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618601527
    },
    {
        "content": "<p>I think that'd be useful; we just don't want to give such warnings to <em>every</em> Drop impl out there.</p>",
        "id": 234908648,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618601546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234908458\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234907978\">said</a>:</p>\n<blockquote>\n<p>that seems like something the compiler could error on</p>\n</blockquote>\n<p>How would compiler know if this is intentional or not?</p>\n</blockquote>\n<p>the idea is to force the developer to be consistent. The bounds on the drop impl have to match the bounds on the struct declaration.</p>",
        "id": 234908686,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601564
    },
    {
        "content": "<p>so you <em>canât</em> just forget to add the bound\\</p>",
        "id": 234908724,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601582
    },
    {
        "content": "<p>(but I admit, this may mean that my <code>impl&lt;T&gt; Drop</code> has implicit <code>T: Unpin</code> bound has more ramifications than I thought. It probably means that the <em>struct definition</em> for anything that implements <code>Drop</code> <em>also</em> needs to use the same rule.)</p>",
        "id": 234908959,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span>  ok, so then you have to add <code>+ ?Unpin</code> to every Box and every other smart pointer<br>\nThat's a (very confusing) breaking change</p>",
        "id": 234908974,
        "sender_full_name": "Soveu",
        "timestamp": 1618601695
    },
    {
        "content": "<p>I think you can add it to just the struct defintions though, not to every impl...</p>",
        "id": 234909034,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601725
    },
    {
        "content": "<p>and yeah, it would have to be tied to an edition boundary</p>",
        "id": 234909089,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601759
    },
    {
        "content": "<p>I admit it probably  would be too confusing to pass the sniff test.</p>",
        "id": 234909232,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618601829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234908648\">said</a>:</p>\n<blockquote>\n<p>I think that'd be useful; we just don't want to give such warnings to <em>every</em> Drop impl out there.</p>\n</blockquote>\n<p>I mean, if we don't want to give warnings, we don't need to<br>\nWe already have the guarantees under the hood, it's \"just\" a change in signature</p>",
        "id": 234909413,
        "sender_full_name": "Soveu",
        "timestamp": 1618601921
    },
    {
        "content": "<p>i thought the point was that <code>&amp;mut self</code> is <em>wrong</em> in some cases?</p>",
        "id": 234910004,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618602246
    },
    {
        "content": "<p>(or at least, <em>can be</em> wrong, depending on what one does in the <code>fn drop(&amp;mut self) { â¦ }</code> itself?)</p>",
        "id": 234910052,
        "sender_full_name": "pnkfelix",
        "timestamp": 1618602282
    },
    {
        "content": "<p>Depends on your definition of \"wrong\"<br>\nDrop could give you a <code>*mut ()</code>-  it would not be <em>wrong</em>, just very annoying to use</p>",
        "id": 234911269,
        "sender_full_name": "Soveu",
        "timestamp": 1618602845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234910052\">said</a>:</p>\n<blockquote>\n<p>(or at least, <em>can be</em> wrong, depending on what one does in the <code>fn drop(&amp;mut self) { â¦ }</code> itself?)</p>\n</blockquote>\n<p><a href=\"https://doc.rust-lang.org/std/pin/index.html#drop-implementation\">https://doc.rust-lang.org/std/pin/index.html#drop-implementation</a></p>",
        "id": 234911994,
        "sender_full_name": "Soveu",
        "timestamp": 1618603183
    },
    {
        "content": "<p>I'd agree it is <em>wrong</em> in the sense that it does no accurately reflect the true capabilities of this pointer</p>",
        "id": 234973075,
        "sender_full_name": "RalfJ",
        "timestamp": 1618649314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Drop.20with.20pin.3F/near/234885885\">said</a>:</p>\n<blockquote>\n<p>So, it's fine if people who use Pin but have <code>drop</code> take just <code>&amp;mut self</code> get a warning, I just don't want <em>every</em> user of Drop to get a warning.</p>\n</blockquote>\n<p>The users of <code>Drop</code> that would have to now care about <code>Pin</code> are those that implement generic types that are not always <code>Unpin</code>. What would be the best way to find out how many of those there are?<br>\nI checked some of the common standard-library types and they all seem to be unconditionally <code>Unpin</code>, usually through auto trait implementations (since all ptr types are unconditionally <code>Unpin</code>).</p>",
        "id": 234973304,
        "sender_full_name": "RalfJ",
        "timestamp": 1618649610
    },
    {
        "content": "<p>There are to ways to fix such types: make the unconditionally <code>Unpin</code> (this is always sound if there is no unsafe Pin-related code in this type), or properly work with <code>Pin&lt;&amp;mut T&gt;</code> in <code>drop</code>. Not doing either of these is still sound but only if there is no unsafe Pin-related code in this type (i.e., only if the type author merely forgot to make this <code>Unpin</code> even though they could have).</p>",
        "id": 234973402,
        "sender_full_name": "RalfJ",
        "timestamp": 1618649726
    }
]