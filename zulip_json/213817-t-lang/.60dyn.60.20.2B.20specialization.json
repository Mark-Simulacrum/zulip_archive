[
    {
        "content": "<p>Hey all, I wrote <a href=\"https://blog.yoshuawuyts.com/uninit-read-write/\">a post</a> on writing into uninitialized memory across trait boundaries. It got me wondering: what are the limitations between dynamic dispatch and specialization, if there are any?</p>\n<p>I found <a href=\"https://paper.dropbox.com/doc/IO-Buffer-Initialization--BXrMP0u_xTZ5lGsyqSiNHxCsAg-MvytTgjIOTNpJAS6Mvw38\">these notes</a> from a while back which alludes to specialization and <code>dyn</code> being mutually exclusive. I asked colleagues what the state of this is in C++, and it appears <a href=\"https://paper.dropbox.com/doc/IO-Buffer-Initialization--BXrMP0u_xTZ5lGsyqSiNHxCsAg-MvytTgjIOTNpJAS6Mvw38\">it is possible to combine the two</a>.</p>\n<p>My knowledge of both specialization and dynamic dispatch is limited. So I wanted to ask here if folks might be able to explain what restrictions exist, and whether those could potentially be lifted in the future. Thanks!</p>",
        "id": 264038310,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1638898530
    },
    {
        "content": "<p>Seems to be the wrong link for the C++ notes</p>",
        "id": 264042696,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638899534
    },
    {
        "content": "<p>I think C++ folks talking about specialisation mean argument overloading? I don’t know what specialisation in the rust sense would look like in c++</p>",
        "id": 264042858,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638899609
    },
    {
        "content": "<p>I don't see any particular conflict between dyn and specialization.</p>",
        "id": 264042879,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1638899617
    },
    {
        "content": "<p>At the point where you create the vtable, you have all the info you need to reliably resolve to a particular set of functions</p>",
        "id": 264043022,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1638899654
    },
    {
        "content": "<p>That said, there are <em>some</em> potential interactions. For example, I have been working with <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> on this \"dyner\" idea, basically finding ways to lift some of the limitations around dyn-safety, and some of those could interact with specialization.</p>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd like to make that trait dyn safe, but the way that would work is that the <code>impl Debug</code> would wind up \"casted\" to a <code>&amp;dyn Debug</code>, essentially, for dynamic dispatch. In that case, some things you might try with specialization on the other side might not work, since they would observe the type as <code>&amp;dyn Debug</code> instead of the original type.</p>",
        "id": 264043359,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1638899767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60dyn.60.20.2B.20specialization/near/264042858\">said</a>:</p>\n<blockquote>\n<p>I think C++ folks talking about specialisation mean argument overloading? I don’t know what specialisation in the rust sense would look like in c++</p>\n</blockquote>\n<p>Isn't C++ template specialization basically the same thing as rust specialization?</p>",
        "id": 264152106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638969074
    },
    {
        "content": "<p>Yeah, it's fairly close, though the former is currently (and probably will remain) more powerful.</p>",
        "id": 264152311,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638969196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60dyn.60.20.2B.20specialization/near/264042696\">said</a>:</p>\n<blockquote>\n<p>Seems to be the wrong link for the C++ notes</p>\n</blockquote>\n<p>oops, fixed!</p>",
        "id": 264153422,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1638969727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60dyn.60.20.2B.20specialization/near/264042858\">said</a>:</p>\n<blockquote>\n<p>I think C++ folks talking about specialisation mean argument overloading? I don’t know what specialisation in the rust sense would look like in c++</p>\n</blockquote>\n<p><a href=\"https://godbolt.org/z/zKcss4sd6\">The example</a> dispatches to a different function in the v-table depending on which class it's called on, and the type of the data passed. It also also includes \"default\" semantics, using <code>std::span&lt;char&gt;</code> as the default implementation. Even though the ergonomics aren't as nice as Rust's, the semantics should roughly map to <code>dyn</code> + specialization in Rust.</p>",
        "id": 264155188,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1638970551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60dyn.60.20.2B.20specialization/near/264043359\">said</a>:</p>\n<blockquote>\n<p>I'd like to make that trait dyn safe, but the way that would work is that the <code>impl Debug</code> would wind up \"casted\" to a <code>&amp;dyn Debug</code>, essentially, for dynamic dispatch. In that case, some things you might try with specialization on the other side might not work, since they would observe the type as <code>&amp;dyn Debug</code> instead of the original type.</p>\n</blockquote>\n<p>I seee!</p>",
        "id": 264156896,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1638971260
    },
    {
        "content": "<p>It sounds like specialization could maybe use an attribute to the effect of: \"This specialization is load-bearing; warn / error if it becomes unreachable.\"</p>",
        "id": 264157515,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1638971554
    },
    {
        "content": "<p>But overall this is really cool though; I'm happy to hear that <code>dyn</code> + specialization is not inherently incompatible! :D</p>",
        "id": 264157588,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1638971601
    }
]