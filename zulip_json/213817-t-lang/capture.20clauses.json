[
    {
        "content": "<p>So um I went a little nuts this morning and wrote up an argument in favor of an explicit capture clause annotation on closures:</p>\n<p><a href=\"https://hackmd.io/38jKhUkvSC2pkG1BrI3boQ?edit\">https://hackmd.io/38jKhUkvSC2pkG1BrI3boQ?edit</a></p>\n<p><em>Something</em> like this is needed to complete the RFC 2229 work. This is more than we need, but I think it's readily implementable and would be really nice to have.</p>",
        "id": 230079853,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615575301
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> I'd like to hear loose thoughts, I can open up a project proposal -- in fact, I probably should've done that instead</p>",
        "id": 230079899,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615575323
    },
    {
        "content": "<p>Under RFC 2229, is there any way to write \"capture the clone of an <code>Arc</code> rather than the original <code>Arc</code>\" other than the block-with-let pattern or the proposed <code>#[capture(x.clone())]</code>?</p>",
        "id": 230081722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615576030
    },
    {
        "content": "<p>Also, initial reaction, I feel like allowing expressions like <code>x.clone()</code> there is a rabbit hole.</p>",
        "id": 230081750,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615576048
    },
    {
        "content": "<p>I also don't think \"prevent capturing anything that isn't listed\" is a limitation we need to add to closures. (That's leaving aside other potential motivations.)</p>",
        "id": 230081936,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615576140
    },
    {
        "content": "<p>I <em>do</em> find the idea of explicitly saying \"I want to capture this by reference\" or \"I want to capture this by value\" interesting, but I wonder how often people will find the automatic detection problematic.</p>",
        "id": 230081985,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615576165
    },
    {
        "content": "<p>Other than edition migration, what are the use cases for \"I know I <em>could</em> capture less, but I want to capture more\"?</p>",
        "id": 230082027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615576195
    },
    {
        "content": "<p>Thanks for the detailed writeup! Overall, I'm not opposed to capture clauses. I'm curious how frequently you imagine users reaching for explicit capture clauses (e.g. is this something that we'd encourage folks to use most/all of the time, or is this an exceptional thing?).</p>\n<p>Other unorganized thoughts:</p>\n<p><code>x.0.clone()</code> becoming named <code>x</code> will be a source of confusion, and I think I'd prefer <code>x = x.0.clone()</code>, even though it's a slight ergonomic hit. I also think I'm not yet convinced of the relative merit of </p>\n<p>I'm not totally sold on the \"why this can't be a procedural macro\" motivation. Ensuring that no other variables are captured feels like an unnecessary step for users to me, perhaps because I'm used to today's Rust where variable captures are implicit.</p>",
        "id": 230084909,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1615577574
    },
    {
        "content": "<p>I do want <code>&lt;ident&gt;.&lt;ident&gt;(..)</code> to bind to the first identifier though, to allow for getters / as_ref/_mut. This relates to a separate concern I have that also applies to the new capture behavior. We currently have a big language pain point around setters/getters not having similar expressivity to field access. This gap stinks, as it imposes severe limits on the usage of structs with private fields. Method access to private fields is useful for guarding against future changes to types (e.g. moving a field behind a Box) and when representing lazily deserialized structures.</p>",
        "id": 230086159,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1615578132
    },
    {
        "content": "<p>I suppose one way around that is to only offer the <code>&lt;ident&gt; = &lt;expr&gt;</code> syntax, but that quickly becomes quite verbose to the point that an explicit block with <code>let</code> bindings isn't much less inconvenient.</p>",
        "id": 230086289,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1615578205
    },
    {
        "content": "<p>I do think, other than \"prevent anything else from being captured\", none of this needs to be at the language level.</p>",
        "id": 230105841,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615586662
    },
    {
        "content": "<p>I think this looks a lot better than the <code>{ let x = x.clone(); || ... }</code> idiom (in particular, the default formatting is more convenient), although the attribute makes it clear that this is an afterthought-addition to the language. But it's rare enough that that doesn't bother me so much. For anything other than <code>&amp;x</code> and <code>&amp;mut x</code>, name shadowing should require rebinding like <code>x = x.0</code> for consistency with patterns and struct literals. Something like <code>x.clone()</code> seems just a bit too magical for something in the language itself; it looks more like what a third party crate would do, where you can afford to go nuts with syntax sugar.</p>\n<p>As for whether this should be a procedural macro, as a user I don't think it matters, unless this is outside std. I see a possible use for non-<code>..</code> captures but I don't think it should be the default; the main reason I would reach for this feature is to edit a single binding that isn't working right, not ban all the others.</p>",
        "id": 230110450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615588365
    },
    {
        "content": "<p>Random thought: if it only has explicit captures, it could expose those captures under their names as public fields.</p>\n<p>(I'm not yet convinced this is a <em>good</em> idea, but I recall people asking about ways of getting things out of closures, which seems more justifiable if they had to say exactly what was in them anyway.)</p>",
        "id": 230113862,
        "sender_full_name": "scottmcm",
        "timestamp": 1615590370
    },
    {
        "content": "<p>On the naming thing: maybe we can lean on intuition from <code>&amp;self</code>?  So <code>&amp;x</code> and <code>&amp;mut x</code> would be enough, but for anything more complicated it's <code>x = y.z.4</code>.</p>\n<p>(Though I'm not really a fan of expressions in attributes, since it makes me think it wants to be \"real\" syntax.)</p>",
        "id": 230114188,
        "sender_full_name": "scottmcm",
        "timestamp": 1615590573
    },
    {
        "content": "<p>One of the things I like in JavaScript is that I can refer to properties on the function object from the function.</p>\n<div class=\"codehilite\" data-code-language=\"JavaScript\"><pre><span></span><code><span class=\"kd\">function</span> <span class=\"nx\">make_public_adder</span><span class=\"p\">(</span><span class=\"nx\">addend</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">fn</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"nx\">this_fn</span><span class=\"p\">(</span><span class=\"nx\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nx\">this_fn</span><span class=\"p\">.</span><span class=\"nx\">a</span> <span class=\"o\">+</span>  <span class=\"nx\">b</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n    <span class=\"nx\">fn</span><span class=\"p\">.</span><span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"nx\">addend</span><span class=\"p\">;</span>\n   <span class=\"k\">return</span> <span class=\"nx\">fn</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 230142584,
        "sender_full_name": "isHavvy",
        "timestamp": 1615618126
    },
    {
        "content": "<p>I think it would be much better to just stabilize <code>FnOnce&lt;T&gt;</code> so that people can write callable objects rather than adding so much sugar on closure types</p>",
        "id": 230143911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615619540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230081936\">said</a>:</p>\n<blockquote>\n<p>I also don't think \"prevent capturing anything that isn't listed\" is a limitation we need to add to closures. (That's leaving aside other potential motivations.)</p>\n</blockquote>\n<p>I should perhaps strengthen the motivation argument there -- in short, I think I would find it surprising to see</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[captures(a, &amp;b)]</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and then find out that the closure also captures <code>c</code>. I can say that I personally have found it annoying sometimes to determine, if there is a long closure, exactly what it captures -- for this reason I personally tend to avoid long closures and prefer methods, so that I can see exactly what state is being passed, but others feel differently.</p>",
        "id": 230150922,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615627736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230105841\">said</a>:</p>\n<blockquote>\n<p>I do think, other than \"prevent anything else from being captured\", none of this needs to be at the language level.</p>\n</blockquote>\n<p>Yes, agreed in a technical sense. But I think capture clauses will <em>feel</em> like part of the language however they're implemented, and we do need to ship it by default so we can use it in migration.</p>",
        "id": 230151003,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615627810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230084909\">said</a>:</p>\n<blockquote>\n<p><code>x.0.clone()</code> becoming named <code>x</code> will be a source of confusion, and I think I'd prefer <code>x = x.0.clone()</code>, even though it's a slight ergonomic hit. </p>\n</blockquote>\n<p>Agreed. I wasn't sure about that part of it. I'd be happy to require an explicit name for cases that involve fields. I'm also not sure how important fields are, tbh, but I wanted some way to be \"as expressive as the inferred cases\", I think (which reminds me, we should include <code>*</code> in the list of places we accept). I should add those notes to the RFC.</p>",
        "id": 230151073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615627888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230113862\">said</a>:</p>\n<blockquote>\n<p>Random thought: if it only has explicit captures, it could expose those captures under their names as public fields.</p>\n</blockquote>\n<p>Plausible future extension, perhaps with <code>pub</code> keyword or something.</p>",
        "id": 230151086,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615627916
    },
    {
        "content": "<p>OK, I've reworked the draft to include the feedback. I've done the following:</p>\n<ul>\n<li>We now require an explicit name for captures with fields like <code>x.0.1</code>.</li>\n<li>I expanded on the reasoning for requiring a \"complete capture list\" and gave some examples.</li>\n<li>I adjusted the alternatives section to FAQ format and expanded it to include a number of points raised here and the reasons I chose to take the approach I did.</li>\n</ul>",
        "id": 230154354,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615632155
    },
    {
        "content": "<p>I also added some more interesting potential future directions that came to me.</p>",
        "id": 230154362,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615632174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230143911\">said</a>:</p>\n<blockquote>\n<p>I think it would be much better to just stabilize <code>FnOnce&lt;T&gt;</code> so that people can write callable objects rather than adding so much sugar on closure types</p>\n</blockquote>\n<p>Can you elaborate a bit more? I don't know exactly what you mean. However, I also think this is unlikely to be something we could fully design and ship in time to be used with the RFC 2229 plans.</p>",
        "id": 230154387,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615632217
    },
    {
        "content": "<p>Ohhh I've wanted explicit closure captures for a while!! When programming with unsafe one needs to be very careful with what gets captured, for instance.<br>\nI am, however, skeptical of the attribute syntax: std / official attributes have never interacted with runtime code like that. What I mean is while it is possible to write Rust code inside an attribute parameter, only some proc-macros use that (some in a stringified fashion, others in a raw fashion), and code highlifhters handle that wrong.</p>\n<p>To me, the better syntax would be to use the <code>move</code> annotation with some optional list of captures. After all, <code>move</code>s and captures mean the same thing, but for the unique \"fake binding\" sugar for by-ref and by-mut-ref captures. But precisely thanks to the <code>ref</code> and <code>ref mut</code> keywords, that wouldn't impact that often:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//or</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230157770,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615636380
    },
    {
        "content": "<p>The grammar being that it's either an identifier with optional ref and mut modifiers, or a <code>pat = expr</code> (could be a <code>:</code> to mimic struct sugar, but since that syntax was deemed problematic in hindsight, maybe we shouldn't use that in new places, and favor <code>=</code> in its stead)</p>",
        "id": 230157974,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615636631
    },
    {
        "content": "<p>This would also solve the awkwardness of</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// why should this be mut?</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>we'd have instead:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230158229,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615636851
    },
    {
        "content": "<p>I really like the idea of attaching this to the move keyword.</p>",
        "id": 230175354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615654849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Yes, I'd prefer stable callable objects as well, rather than the closure equivalent of field definitions.</p>",
        "id": 230175467,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615654935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> My point was that if migrations don't need to limit what gets captured (just expand it), that doesn't need a new syntax, since it could use one of the several translations we'd already talked about (drop or a capture macro).</p>",
        "id": 230175813,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615655254
    },
    {
        "content": "<p>This syntax itself may potentially provide great value, and I'd love to see more use cases for it, but I don't think migration is necessarily one of them, given that.</p>",
        "id": 230175865,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615655290
    },
    {
        "content": "<p>I'm starting to see the use case you're getting at for explicitly listing the captures of a closure. That does seem potentially useful, to help wrangle complexity. Rather than tying it to migration and the edition, I'm wondering if we could instead develop that syntax orthogonally to migration, and without having to rush to meet the edition deadline.</p>",
        "id": 230176042,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615655447
    },
    {
        "content": "<p>I was actually thinking of making a proc-macro that would try to implement this (using some hygiene hacks to prevent accessing variables that aren't listed). I'd be strongly in favor of having this built-in to the language</p>",
        "id": 230176711,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1615656201
    },
    {
        "content": "<p>As a future extension to this, it might be useful to have an allow-by-default lint that that lints against any closures <em>not</em> using the explicit capture syntax. This would allow projects to require that all of their code uses the explicit capture syntax. However, this would essentially be a clippy 'restriction lint' that's part of the main compiler, so I'm not sure that the policy around that is</p>",
        "id": 230176878,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1615656371
    },
    {
        "content": "<blockquote>\n<p>I really like the idea of attaching this to the move keyword.</p>\n</blockquote>\n<p>I sort of do too. I remember being against <code>keyword(modifiers)</code> when <code>pub(crate)</code> first came out, but on reflection it seems like it solves a variety of syntactic problems, e.g. you could imagine the weird pseudo-lifetime syntax of labeled-break as instead <code>while(label)</code>/<code>break(label)</code>.</p>\n<p>although, in any case there's no reason this couldn't start life as an attribute and be expanded into syntax later.</p>",
        "id": 230180273,
        "sender_full_name": "bstrie",
        "timestamp": 1615660105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230175354\">said</a>:</p>\n<blockquote>\n<p>I really like the idea of attaching this to the move keyword.</p>\n</blockquote>\n<p>me, too -- with the <code>=</code> syntax it even supports <code>x = x.clone()</code>.<br>\nlooks like we're moving closer towards C++ closures then. ;)</p>",
        "id": 230180298,
        "sender_full_name": "RalfJ",
        "timestamp": 1615660153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> That's actually one of the reasons I didn't care for it at first. I don't like C++'s much more manual closures and manual capture syntax.</p>",
        "id": 230182200,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615662200
    },
    {
        "content": "<p>oh sure, keep the automatic mode. but as was said by others above, sometimes this control is what you want.</p>",
        "id": 230182337,
        "sender_full_name": "RalfJ",
        "timestamp": 1615662354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230079899\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> I'd like to hear loose thoughts, I can open up a project proposal -- in fact, I probably should've done that instead</p>\n</blockquote>\n<p>I had thought there were (well-established?) issues with putting variables/expressions into attributes, in terms of how that interacts with hygiene and name-resolution. But maybe some of those issues are resolved when the attribute in question is still <em>within the scope</em> of the variable it refers to.</p>",
        "id": 230407266,
        "sender_full_name": "pnkfelix",
        "timestamp": 1615837921
    },
    {
        "content": "<p>Also, I’m curious how strong the motivation is to have this expressed as a single explicit list on the lambda expression (or, more generally, each lambda expression, when they are nested.) it would be good if the document considered the alternative of attaching this attribute (or some variation thereof) <em>within</em> the closure body. Something like <code>let c = move || println!(\"{:?}\", (#[capture] x).1);</code> (to capture all of <code>x</code>) vs <code>let c = move || println!(\"{:?}\", #[capture] x.1);</code> (which would capture just the field.</p>",
        "id": 230408964,
        "sender_full_name": "pnkfelix",
        "timestamp": 1615838530
    },
    {
        "content": "<p>that's definitely less expressive, since it doesn't cover the <code>clone()</code> examples, although it's probably sufficient for recovering expressivity loss from RFC 2229</p>",
        "id": 230412829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615840003
    },
    {
        "content": "<p>OK, just catching up here</p>",
        "id": 230434931,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849305
    },
    {
        "content": "<p>I'm debating about the move keyword -- my biggest concern is that it doesn't express the implicit capture case. I don't consider <code>move(ref x)</code> to be very nice, because it doesn't behave like <code>ref</code> does in patterns. A <code>ref x </code> pattern gives <code>x</code> a type of <code>&amp;T</code>, but implicit capture in patterns gives <code>x</code> a type of <code>T</code>.</p>",
        "id": 230435048,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849368
    },
    {
        "content": "<p>I think the line between attributes and regular syntax is pretty squishy; we have tried to hold the line of a 'attributes don't change the \"intent\" of the code' -- so e.g. you can add <code>#[repr]</code> attributes to a struct, and it may affect the layout, but for the most part you don't need to look at that to understand code using the struct.</p>",
        "id": 230435135,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849428
    },
    {
        "content": "<p>One could argue the same is true of <code>#[capures]</code>, but it's a bit trickier</p>",
        "id": 230435153,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849438
    },
    {
        "content": "<p>Anyway I have to run now but later on I'll go over the thread and try to summarize the feedback and update the RFC</p>",
        "id": 230435204,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> a quite note -- I think that the main problem is that it fails to meet my motivation of 'easily identify what is captured by the closure'</p>",
        "id": 230435221,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849466
    },
    {
        "content": "<p>I guess that one could say that <code>..</code> in \"move\" means \"implied mode\", i.e., we will move these things, and infer the rest</p>",
        "id": 230435388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849566
    },
    {
        "content": "<p>after all, my <code>#[captures]</code> annotation is only moves</p>",
        "id": 230435418,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849586
    },
    {
        "content": "<p>so that the explicit form becomes <code>move(&amp;x) || ..</code>, and the migrations insert <code>move(a, ..) || { use(&amp;a, &amp;b) }</code> (which would mean \"capture <code>a</code> by move, and <code>b</code> by shared reference\".</p>",
        "id": 230435482,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849640
    },
    {
        "content": "<p>I don't know, that last example looks awfully misleading to me.</p>",
        "id": 230435492,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615849647
    },
    {
        "content": "<p>I definitely wouldn't want <code>move(ref x)</code>; I think <code>move(&amp;x)</code> logically means \"move a reference to x into the closure\".</p>",
        "id": 230437362,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615850919
    },
    {
        "content": "<p>(I debated about whether to try to generalize my counter proposal to <code>#[capture] (x.clone())</code>, but at that point I think what one is really trying to express is some notion of Aspect Oriented Programming, ie injecting arbitrary code that is meant to be run right before the lambda expression is evaluated. I do think it’s nice to have the definition of the desired expression close to where it will be used (Ie nested within the lambda body) but I suspect it would also be pretty confusing, much like AOP )</p>",
        "id": 230440814,
        "sender_full_name": "pnkfelix",
        "timestamp": 1615853178
    },
    {
        "content": "<p>Right the question is what do you consider expressions inside a <code>move()</code> to be. To me they sound a lot like uses, much like passing things to a function as arguments, rather than patterns. So a strong vote for <code>move(&amp;val)</code> from me in context of the <code>move</code> syntax.</p>",
        "id": 230441153,
        "sender_full_name": "nagisa",
        "timestamp": 1615853428
    },
    {
        "content": "<p>Incidentally I wrote some pretty similar code to what the misleading example looks like <a href=\"https://gist.github.com/nagisa/544fcb02b9c4da0067cdad1114a0feab\">in C++ just now</a>. I think the resulting code is probably somewhat worse in C++ as you can still mutate the referenced value after it has been captured. With rust's unique mutable ownership semantics that would be… less of a problem.</p>",
        "id": 230441441,
        "sender_full_name": "nagisa",
        "timestamp": 1615853665
    },
    {
        "content": "<p>Also it just occurred to me that in the <code>move(a, b) || use(&amp;a, &amp;b)</code> example there is a serious danger of the reader seeing two function calls separated by OR, if they don't know rust very well and don't realize <code>move</code> is a keyword (or if they just read too quickly). Hopefully they have good syntax highlighting. (That said, I don't really have a better syntax suggestion.)</p>",
        "id": 230451540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615862074
    },
    {
        "content": "<p>well other kinds of grouping tokens could be used. <code>move[...]</code>, <code>move&lt;...&gt;</code>, <code>move{ ... }</code>. I'm quite partial to the last option as an alternative as it looks a lot like struct construction syntax which what closures really are</p>",
        "id": 230488149,
        "sender_full_name": "nagisa",
        "timestamp": 1615889861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230451540\">said</a>:</p>\n<blockquote>\n<p>Also it just occurred to me that in the <code>move(a, b) || use(&amp;a, &amp;b)</code> example there is a serious danger of the reader seeing two function calls separated by OR, if they don't know rust very well and don't realize <code>move</code> is a keyword (or if they just read too quickly). Hopefully they have good syntax highlighting. (That said, I don't really have a better syntax suggestion.)</p>\n</blockquote>\n<p>(this definitely concerned me as soon as I saw that example, because that’s how my brain parses it at first glance. I’d want to explore ways to make it clearer that this is <em>not</em> an or-expression. Not sure what would actually work, though.)</p>",
        "id": 230544830,
        "sender_full_name": "pnkfelix",
        "timestamp": 1615911775
    },
    {
        "content": "<p>(of options <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> posted, <code>move&lt;…&gt;</code> is one that strikes me as “most different” from an expression. but maybe <code>move { … }</code> would do…)</p>",
        "id": 230545202,
        "sender_full_name": "pnkfelix",
        "timestamp": 1615911931
    },
    {
        "content": "<p>So regarding <code>move</code>, I don't mind the grouping sigil used there, I considered brackets given the C++ syntax, and braces given the parallel with the env struct that the closure would have there (but in that case we might go back to using <code>: &lt;expr&gt;</code>?).</p>\n<p>And regarding being able to explicitly express the semantics of current implicit by-ref captures, is that a hard requirement? AFAIK, the only place where that occurs is with closures; no user-written code can mimic that, ever. That can be convenient when wanting to be implicit (<em>e.g.</em>, imagine using the <code>with</code> api of <code>LocalKey</code>: one just writes codes without worrying about captures and it Just Works™; this is always the cause for immediately-called closures, and in that case, hiding the technicalities of closure captures makes a lot of sense. But if we are go to using <code>move { a, b }</code> captures, that is, when captures matter, I find the lack of sugar to be quite acceptable, since it consistently mimics pattern destructuring (<em>e.g.</em>, in a hypothetical world, we could have made <code>ref x</code> still bind <code>x</code> to the value, but restricting the access to shared ones, like within a closure capture. In that world, it would make to also feature that capability for explicit closure captures, and the natural syntax for that would have been writing <code>ref &lt;binding&gt;</code>).</p>\n<p>To summarize, I do think that this <code>a</code> / <code>b</code> \"fields\" ought to be written similarly to struct bodies: </p>\n<ul>\n<li>The mental model here for <code>ref x</code> is that we would be pattern-destructuring against the imaginary struct containing all the available locals at that point. In that regard, writing <code>&amp;x</code> to bind an implicit <code>x</code> by reference would go against the pattern matching habits.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Vars</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Vars</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>as well as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">cartesian_product</span><span class=\"o\">&lt;'</span><span class=\"na\">lt</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">lt</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Copy</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">lt</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Copy</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">l</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">lt</span> <span class=\"p\">[</span><span class=\"n\">L</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">r</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">lt</span> <span class=\"p\">[</span><span class=\"n\">R</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">lt</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//                                          consistent syntax</span>\n<span class=\"w\">    </span><span class=\"c1\">//                                             vv    vv</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">flat_map</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">|&amp;</span><span class=\"n\">y</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>For instance, if somebody that used to write <code>let inc_ref = || Arc::clone(&amp;x)</code> wanted to write the capture explicitly, they would be able to write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Implicit by ref</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// Explicit</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// or</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Implicit owned</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// Explicit</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Implicit owned clone</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// Explicit</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inc_ref</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">x</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">Arc</span>::<span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(In a way, current arg-less <code>move</code> would be sugar for <code>move { .. }</code>).</li>\n</ul>\n<hr>\n<p>The other alternative, but which, at the very least, should not be using braced syntax, is to get rid of patterns altogether (since, despite being a core part of the language, it is one very specific to Rust, so many programmers find this paradigm to be confusing and try to reduce it to a minimum (<em>e.g.</em> <a href=\"https://rust-lang.github.io/rust-clippy/master/#toplevel_ref_arg\">it is sometimes linted against</a>, and it's also a reason motivating match ergonomics).</p>\n<p>In that case, the syntax ought to be: non-brace group delimiter (I'd even say it ought to be using parenthesis here), and using <code>=</code> instead of <code>:</code>, so as to go as far as possible from struct patterns as possible:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//                +------ values -------+</span>\n<span class=\"c1\">//                |                     |</span>\n<span class=\"c1\">//                vv                   vv</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">y</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"w\"> </span><span class=\"p\">})(</span><span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//            ^        ^</span>\n<span class=\"c1\">//            +- pats -+</span>\n</code></pre></div>\n<ul>\n<li>With no shorthand, this approach is very similar to the pattern-based one, but for only identifiers being allowed on the lhs of the <code>=</code> sign (no <code>ref x</code>; but I imagine we'd still have <code>mut x</code>?)</li>\n</ul>\n<p>And then add the (imho, bad) idea that <code>&amp;x</code> would in this one instance of the language be a possible shorthand for a binding by ref: <code>x=&amp;x</code></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">//            +------- values ------+</span>\n<span class=\"c1\">//            |                     |</span>\n<span class=\"c1\">//            vv                   vv</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">y</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"w\"> </span><span class=\"p\">})(</span><span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//             ^   ^</span>\n<span class=\"c1\">//             bindings</span>\n</code></pre></div>",
        "id": 230570724,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615920959
    },
    {
        "content": "<blockquote>\n<p>(e.g., in a hypothetical world, we could have made <code>ref x</code> still bind <code>x</code> to the value, but restricting the access to shared ones, like within a closure capture. […]</p>\n</blockquote>\n<p>what an interesting idea. I wonder how that would have gone over; if it would have made <code>ref</code> “patterns\" more palatable… (probably not).</p>",
        "id": 230572200,
        "sender_full_name": "pnkfelix",
        "timestamp": 1615921556
    },
    {
        "content": "<blockquote>\n<p>And regarding being able to explicitly express the semantics of current implicit by-ref captures, is that a hard requirement?</p>\n</blockquote>\n<p>The hard requirement is being able to migrate RFC 2229 closures in some way. We could use <code>drop(&amp;a);</code> for that migration, but I would like there to be a syntax for us to move users to that is actually <em>appealing</em>, since in some cases annotations of this kind of will be necessary to get the desired semantics.</p>",
        "id": 230573585,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922112
    },
    {
        "content": "<p>I suppose that we can migrate <code>move</code> closures using <code>move(a, b, c)</code> and non-move closures using <code>drop(&amp;a)</code>, but that seems ungreat.</p>",
        "id": 230573648,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922138
    },
    {
        "content": "<p>We can support <code>move(..)</code> to mean \"move any places used but not explicitly named here\"</p>",
        "id": 230573747,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922165
    },
    {
        "content": "<p>We <em>could</em> support <code>move(ref..)</code> or something for the current implicit capture syntax, but I don't love it, for the reasons I've given before (<code>ref</code> calls to mind <code>ref</code> bindings, and they operate differently)</p>",
        "id": 230573795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922185
    },
    {
        "content": "<p>also, some of the inferred captures may not be refs, they could be mut refs or moves</p>",
        "id": 230573873,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922218
    },
    {
        "content": "<p>We could support <code>move(a, b)</code> and say that we have a lint that warns if you have any variables not cited in the move</p>",
        "id": 230573981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230573585\">said</a>:</p>\n<blockquote>\n<p>The hard requirement is being able to migrate RFC 2229 closures in some way. We could use <code>drop(&amp;a);</code> for that migration, but I would like there to be a syntax for us to move users to that is actually <em>appealing</em>, since in some cases annotations of this kind of will be necessary to get the desired semantics.</p>\n</blockquote>\n<p>maybe we should go for this, I don't know-- we can certainly use <code>drop(&amp;a);</code> for the migration and punt this, but it feels to me like a lost opportunity</p>",
        "id": 230574146,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922313
    },
    {
        "content": "<p>instead of the rather cryptic <code>drop(&amp;a); drop(&amp;b); drop(&amp;c);</code>, <code>let _capture = (&amp;a, &amp;b, &amp;c);</code> would also work, right?</p>",
        "id": 230574280,
        "sender_full_name": "Mara",
        "timestamp": 1615922375
    },
    {
        "content": "<p>I added this FAQ:</p>",
        "id": 230575006,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922676
    },
    {
        "content": "<h2>Why not use <code>move(CC)</code> as the syntax instead of <code>#[captures(CC)]</code>?</h2>\n<p>Syntax like <code>move(a, b, c) || a + b * c</code> has certain advantages:</p>\n<ul>\n<li>It feels more \"built-in\" than an attribute.</li>\n<li>Something like <code>move(&amp;x)</code> rather clearly expresses that the closure captures a reference to <code>x</code>.</li>\n<li>There are no hygiene issues that we have to resolve around the use of attributes.</li>\n</ul>\n<p>It has some disadvantages as well:</p>\n<ul>\n<li>It suggests that the closure is a \"move\" closure, and hence there is no satisfying way to express \"and the remaining uses are inferred as normal\". This means that <code>move(a, b)</code> cannot be used to migrate non-move closures for RFC 2229 migration; we would have to insert <code>drop(&amp;a);</code> statements explicitly in such code, and all such code in the future would have to be written as move closures.</li>\n<li><code>move(a, b) || c</code> looks rather like a function call and the boolean <code>||</code> operator.</li>\n</ul>\n<p>There are some other alternatives:</p>\n<ul>\n<li><code>move[a]</code> or <code>move{a}</code> look less like a function call, but they are not consistent visually with <code>pub(super)</code> and the like.</li>\n</ul>",
        "id": 230575012,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922678
    },
    {
        "content": "<p>Regarding the migration, <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> is this because it would be done by humans? Because an automatic <code>rustfix</code> would be able to prepend <code>*</code> to all the occurrences of a binding (<code>x</code> -&gt; <code>(*x)</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// old:</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// new:</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230575039,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615922688
    },
    {
        "content": "<p>It is done by rustfix, but that's a lot more code to write</p>",
        "id": 230575090,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922706
    },
    {
        "content": "<p>I suppose it is plausible</p>",
        "id": 230575105,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922710
    },
    {
        "content": "<p><code>move(&amp;x) || println!(\"{}\", *x)</code> &lt;-- it would probably be that ;)</p>",
        "id": 230575151,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230574280\">said</a>:</p>\n<blockquote>\n<p>instead of the rather cryptic <code>drop(&amp;a); drop(&amp;b); drop(&amp;c);</code>, <code>let _capture = (&amp;a, &amp;b, &amp;c);</code> would also work, right?</p>\n</blockquote>\n<p>that's true, I consider this also rather cryptic though</p>",
        "id": 230575188,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922740
    },
    {
        "content": "<p><code>drop((&amp;a, &amp;b, &amp;c));</code> is more compact, but equally cryptic</p>",
        "id": 230575220,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230575105\">said</a>:</p>\n<blockquote>\n<p>I suppose it is plausible</p>\n</blockquote>\n<p>this may be worth considering</p>",
        "id": 230575308,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922773
    },
    {
        "content": "<p>yeah, all options other than new syntax/attributes are cryptic. but it'd be nice to avoid the word <code>drop</code>. also, clippy will get angry at you for dropping Copy stuff like references.</p>",
        "id": 230575366,
        "sender_full_name": "Mara",
        "timestamp": 1615922794
    },
    {
        "content": "<p>I suppose we could say that rustfix adds <code>drop(&amp;a)</code> and people migrate by hand</p>",
        "id": 230575431,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922820
    },
    {
        "content": "<p>also</p>",
        "id": 230575447,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922826
    },
    {
        "content": "<p>(fwiw, I personally find <code>let _captures =</code> to be a bit more readable than <code>drop</code>)</p>",
        "id": 230575463,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615922833
    },
    {
        "content": "<p>like, the <code>move(&amp;a)</code> is the <em>recommended</em> way to do it, but...</p>",
        "id": 230575466,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922833
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230575463\">said</a>:</p>\n<blockquote>\n<p>(fwiw, I personally find <code>let _captures =</code> to be a bit more readable than <code>drop</code>)</p>\n</blockquote>\n<p>it is, it's just not good enough (to me) to be the \"official' way to do this</p>",
        "id": 230575503,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922848
    },
    {
        "content": "<p>and i think we want something to tell authors of new code when they're like \"how can I force it to capture all of <code>a</code>\"</p>",
        "id": 230575532,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922870
    },
    {
        "content": "<p>That's fair</p>",
        "id": 230575534,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615922870
    },
    {
        "content": "<p>I'd rather that not be <code>let _capture = &amp;a</code></p>",
        "id": 230575550,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922876
    },
    {
        "content": "<p>the \"cliff\" to <code>move</code> is a bit unfortunate but maybe ok</p>",
        "id": 230575611,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615922891
    },
    {
        "content": "<p>(sure. but <code>let _ = &amp;a;</code> is still better than <code>drop(&amp;a);</code> which keeps coming up as an example)</p>",
        "id": 230575688,
        "sender_full_name": "Mara",
        "timestamp": 1615922937
    },
    {
        "content": "<p>looking forward to explicit capture syntax</p>",
        "id": 230575806,
        "sender_full_name": "Mara",
        "timestamp": 1615922985
    },
    {
        "content": "<p>I suppose <code>let _ = &amp;a</code> actually does work</p>",
        "id": 230575928,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923013
    },
    {
        "content": "<p>I thought it didn't, beacuse of the \"special semantics\" of <code>let _ = &lt;place&gt;</code></p>",
        "id": 230575996,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923033
    },
    {
        "content": "<p>but <code>&amp;a</code> is not a place</p>",
        "id": 230576003,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923036
    },
    {
        "content": "<p>regardless, the point stands :)</p>",
        "id": 230576015,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923041
    },
    {
        "content": "<p>I do agree <code>let _ = (&amp;a, &amp;b, ... &amp;z);</code> is a better migration</p>",
        "id": 230576088,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923064
    },
    {
        "content": "<p>I just don't love it as the official answer for what to do</p>",
        "id": 230576155,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923086
    },
    {
        "content": "<p>ballpark estimate of how common you expect this to be needed? 1% of the time, more, less? using an attribute as placeholder syntax isn't a bad idea if it's a particularly rare case, as long as you're okay with attributes referencing runtime things</p>",
        "id": 230576212,
        "sender_full_name": "bstrie",
        "timestamp": 1615923111
    },
    {
        "content": "<p>Fairly uncommon</p>",
        "id": 230576562,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923221
    },
    {
        "content": "<p>I think if it were <em>just</em> rfc2229 I wouldn't worry <em>that</em> much, though I'm not <em>thrilled</em>, but I think that if you add up the various motivations, you get a stronger case.</p>",
        "id": 230576643,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923243
    },
    {
        "content": "<p>I'm going to weigh the <code>move</code> syntax idea a bit :)</p>",
        "id": 230576656,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615923249
    },
    {
        "content": "<p>Potentially stupid suggestion I just came up with: if we are not using <code>ref x</code> but <code>&amp;x</code>, we no longer have to follow pattern logic <em>at all</em>, so what about <code>move(&amp;x)</code> captures by reference but binds to the type of <code>x</code>?</p>",
        "id": 230577214,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615923468
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">get_ft</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230577365,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615923515
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/gQM1nJBWF-ZfuXgC2EFnF9Po/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/gQM1nJBWF-ZfuXgC2EFnF9Po/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/gQM1nJBWF-ZfuXgC2EFnF9Po/image.png\"></a></div>",
        "id": 230577632,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615923604
    },
    {
        "content": "<p>not <code>ref x</code>, but still <code>mut x</code>?</p>",
        "id": 230577822,
        "sender_full_name": "Mara",
        "timestamp": 1615923677
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Allowing the <code>move[mut x]</code> shorthand would be convenient but inconsistent with the <code>&amp;x</code> suggestion I just made.<br>\nI guess the <code>mut</code> case ought to need the full syntax (which does not seem too bad to me):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">move</span><span class=\"p\">[</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 230578472,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615923937
    },
    {
        "content": "<p>then you could also do <code>move[mut x = 0] || { x += 1; x }</code> without needing to declare an <code>x</code> outside of it at all. but at this point <code>move</code> is a bit of a weird word to use here.</p>",
        "id": 230581671,
        "sender_full_name": "Mara",
        "timestamp": 1615925075
    },
    {
        "content": "<p>what about <code>move</code> inside the closure? <code>|| { move x; ... }</code></p>",
        "id": 230582477,
        "sender_full_name": "bstrie",
        "timestamp": 1615925370
    },
    {
        "content": "<p>we've had other discussions about <code>move</code> in expressions, not directly related to closures</p>",
        "id": 230582778,
        "sender_full_name": "cuviper",
        "timestamp": 1615925472
    },
    {
        "content": "<p><a href=\"#narrow/stream/122651-general/topic/In.20a.20closure.2C.20how.20do.20I.20move.20some.20things.20but.20not.20others.3F\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/In.20a.20closure.2C.20how.20do.20I.20move.20some.20things.20but.20not.20others.3F</a></p>",
        "id": 230582903,
        "sender_full_name": "cuviper",
        "timestamp": 1615925519
    },
    {
        "content": "<p>well I guess that did start about closures, but the <code>.move</code> idea has potential traction regardless, IMO</p>",
        "id": 230583126,
        "sender_full_name": "cuviper",
        "timestamp": 1615925597
    },
    {
        "content": "<p>here's another thread on that:</p>",
        "id": 230583292,
        "sender_full_name": "cuviper",
        "timestamp": 1615925656
    },
    {
        "content": "<p><a href=\"#narrow/stream/213817-t-lang/topic/Spitballing.3A.20a.20.60move(x).60.20expression.3F\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Spitballing.3A.20a.20.60move(x).60.20expression.3F</a></p>",
        "id": 230583295,
        "sender_full_name": "cuviper",
        "timestamp": 1615925657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/213817-t-lang/topic/capture.20clauses/near/230581671\">said</a>:</p>\n<blockquote>\n<p>at this point <code>move</code> is a bit of a weird word to use here.</p>\n</blockquote>\n<p>Interesting, I personally find it very intuitive: we are moving a value (<code>0</code>) as <code>x</code> into the closure('s captures). The one a bit weird is my suggested semantics for <code>move(&amp;x)</code>, since it would be kind of an oxymoron <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  (in that regard, <code>#[captures]</code> has at least the advantage of being a bit more readable)</p>",
        "id": 230584123,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1615925981
    },
    {
        "content": "<p>yes, that thread on <code>move</code> expressions seems pretty relevant here, although if the semantics are chosen such that <code>let y = x.move</code> invalidates <code>x</code> even if <code>x</code> is <code>Copy</code>, then for the purposes here you might sometimes need to do <code>(&amp;x).move</code> (or <code>move &amp;x</code>), which I suppose is no worse than the <code>drop</code> or <code>let _captures</code> forms above</p>",
        "id": 230584551,
        "sender_full_name": "bstrie",
        "timestamp": 1615926126
    }
]