[
    {
        "content": "<p>TL; DR - I'd like to propose allowing <code>for&lt;'a&gt; |closure_arg: &amp;'a str|</code> to explicitly indicate a higher-ranked closure. Regardless of what we decide to do about the closure region inference issues described below, I think this will help to improve the clarity of certain tricky code.</p>\n<p>I've been revisiting some of the open issues around closure lifetimes (<a href=\"https://github.com/rust-lang/rust/issues/91966\">https://github.com/rust-lang/rust/issues/91966</a> and <a href=\"https://github.com/rust-lang/rust/issues/41078\">https://github.com/rust-lang/rust/issues/41078</a>). From what I can tell, there are essentially two problems that can happen:</p>\n<ol>\n<li>We infer a higher-ranked region (<code>for&lt;'a&gt; fn(&amp;'a u8)</code>) when we really want some specific (local) region. This occurs in the following code:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fields</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pusher</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which gives the error:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0521]: borrowed data escapes outside of closure\n --&gt; src/main.rs:3:28\n  |\n2 |     let mut fields: Vec&lt;&amp;str&gt; = Vec::new();\n  |         ---------- `fields` declared here, outside of the closure body\n3 |     let pusher = |a: &amp;str| fields.push(a);\n  |                   -        ^^^^^^^^^^^^^^ `a` escapes the closure body here\n  |                   |\n  |                   `a` is a reference that is only valid in the closure body\n</code></pre></div>\n<p>The issue is that <code>Vec&lt;&amp;str&gt;</code> is not higher-ranked, so we can only push an <code>&amp;'0 str</code> for some specific lifetime <code>'0</code>. The <code>pusher</code> closure signature requires that it accept <em>any</em> lifetime, which leads to a compiler error.</p>\n<ol start=\"2\">\n<li>We infer some specific region when we really want a higher-ranked region. This occurs in the following code:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">cell</span>::<span class=\"n\">Cell</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">static_cell</span>: <span class=\"nc\">Cell</span><span class=\"o\">&lt;&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">25</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">closure</span><span class=\"p\">(</span><span class=\"n\">static_cell</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">short_cell</span>: <span class=\"nc\">Cell</span><span class=\"o\">&lt;&amp;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">val</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">closure</span><span class=\"p\">(</span><span class=\"n\">short_cell</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'm using <code>Cell</code> to force invariance, since otherwise, region subtyping will make this example work even without a higher-ranked region. The above code produces the following error:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0597]: `val` does not live long enough\n  --&gt; src/main.rs:8:43\n   |\n4  |     let static_cell: Cell&lt;&amp;&#39;static u8&gt; = Cell::new(&amp;25);\n   |                      ----------------- type annotation requires that `val` is borrowed for `&#39;static`\n...\n8  |     let short_cell: Cell&lt;&amp;u8&gt; = Cell::new(&amp;val);\n   |                                           ^^^^ borrowed value does not live long enough\n9  |     closure(short_cell);\n10 | }\n   | - `val` dropped here while still borrowed\n</code></pre></div>\n<p>Here, the closure gets inferred to <code>|s: Cell&lt;&amp;'static u8&gt;|</code>, so it cannot accept a <code>Cell&lt;&amp;'0 u8&gt;</code> for some shorter lifetime <code>&amp;'0</code>. What we really want is <code>for&lt;'a&gt; |s: Cell&lt;&amp;'a u8&gt;|</code>, so that the closure can accept both <code>Cell</code>s.</p>\n<p>As far as I know, this is the only place in the compiler where type inference needs to pick between a higher-ranked region or a specific region in a <em>signature</em>. In all other cases, (functions, traits, <code>impl Trait</code>, etc), the signature is not inferred from a function body, so we never need to decide whether or not to 'convert' some specific region into a higher-ranked region.</p>\n<p>It might be possible to improve the closure lifetime inference logic to always pick the 'correct' lifetime. However, even if this is possible, I think this will be one of the most complex things inferred by the compiler. In particular, I'm concerned that the leak-check changes could actually cause this to influence runtime behavior. As described in <a href=\"https://github.com/rust-lang/rust/pull/72493#issue-623623350\">https://github.com/rust-lang/rust/pull/72493#issue-623623350</a>, the following impls do <strong>not</strong> overlap:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// impl A</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// impl B</span>\n</code></pre></div>\n<p>This means that a higher-ranked closure <code>for&lt;'a&gt; |arg: &amp;'a str|</code> will coerce to a function pointer that uses impl A, while the non-higher-ranked closure <code>|arg: &amp;'0 str|</code> will coerce to a function pointer that uses impl B. I haven't yet been able to come up with an actual example where this happens automatically (I think an automatic closure to fn ptr coercion only happens when a function pointer type is explicitly written, not when we just have an impl for an fn ptr). However, I think this case is complex enough to be concerning, especially considering that it's not easy to tell whether or not a closure is higher-ranked.</p>\n<p>Because of this complexity, I think it would be useful to allow explicitly specifying that a closure should be higher-ranked. Using <code>for&lt;'a&gt; |val: &amp;'a str|</code> seems like a natural extension of how lifetimes are explicitly indicated for functions (this syntax is currently banned for closures, so we don't need to worry about affecting existing code). This will provide a way of making a closure 'obviously' higher-ranked - even if the inference algorithm is improved, I think this will still be useful when improving a closure. For example, we might later decided to infer <code>|val: &amp;str|</code> to be non-higher-ranked in some cases, but <code>for&lt;'a&gt; |val: &amp;'str|</code> will always mean a higher-ranked closure.</p>\n<p>Of course, this still leaves users without a way of explicitly indicating that a closure should <em>not</em> be higher-ranked (<code>|val: &amp;str|</code> currently gets inferred as a higher-ranked closure in all cases, I think). I considered <code>|val: &amp;'_ str|</code>, but that currently compiles and means the same thing as <code>|val: &amp;str|</code>. I think we could separately address non-higher-ranked lifetime annotations (if at all). Allowing <code>for&lt;'a&gt; |val: &amp;'a str|</code> will make closures more consistent with functions, and would make sense even if we never allow any other kind of explicit lifetime annotations.</p>",
        "id": 266401264,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640838011
    },
    {
        "content": "<p>For reference, <code>for&lt;'a&gt; |_val: &amp;'a str| {}</code> current errors with:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: cannot introduce explicit parameters for a closure\n --&gt; src/main.rs:2:5\n  |\n2 |     for&lt;&#39;a&gt; |_val: &amp;&#39;a str| {};\n  |     ^^^^^^^ ------------------ the parameters are attached to this closure\n  |     |\n  |     help: remove the parameters\n</code></pre></div>",
        "id": 266401343,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640838128
    },
    {
        "content": "<p>I agree. <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> you could also mention all the cases where a <code>funnel</code> function is used to nudge the closure into getting the right signature (such instances can be foind in a bunch of the aforentioned issues, or abundantly on URLO).</p>\n<p>Also, regarding the objective of a non-higher-order <code>|s : &amp;str|</code> closure, <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> , I believe that <code>for&lt;&gt;</code> syntax could achieve that: that is, the <code>for</code> syntax could be required to be exhaustive. That being said, a <code>|s| { let _: &amp;str = s; ... }</code> is another way to type annotate in a non-higher-order fashion a closure aprameter</p>",
        "id": 266411485,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640852649
    },
    {
        "content": "<p>Is the idea that <code>for&lt;'a&gt; |first: &amp;'a str, second: &amp;bool|</code> would have a higher-ranked <code>str</code> reference but a non-higher-ranked <code>bool</code> reference?</p>",
        "id": 266442476,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640883736
    },
    {
        "content": "<p>If so, I think that could work - however, I think it could be confusing that adding a explicit lifetime (by adding a <code>for&lt;&gt;</code>) can change the interpretation of a different</p>",
        "id": 266442616,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640883859
    },
    {
        "content": "<p>We could start out by banning lifetime elision when <code>for&lt;&gt;</code> is used, so you can only use it to write entirely higher-ranked closures</p>",
        "id": 266442656,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640883911
    },
    {
        "content": "<p>and then later decide what the behavior should be with a mixture of explicit and elided lifetimes inside <code>for&lt;&gt;</code></p>",
        "id": 266442676,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640883949
    },
    {
        "content": "<p>If the overall idea sounds reasonable to everyone, I'll write up an RFC</p>",
        "id": 266442955,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640884203
    },
    {
        "content": "<p>It looks like the possibility of accepting <code>for&lt;'a&gt; |param: &amp;'a str|</code> was previously mentioned in <a href=\"https://github.com/rust-lang/rust/pull/70209\">https://github.com/rust-lang/rust/pull/70209</a></p>",
        "id": 266447713,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640888749
    },
    {
        "content": "<p>Pre-RFC is up: <a href=\"https://internals.rust-lang.org/t/pre-rfc-allow-for-a-syntax-with-closures-for-explicit-higher-ranked-lifetimes/15888\">https://internals.rust-lang.org/t/pre-rfc-allow-for-a-syntax-with-closures-for-explicit-higher-ranked-lifetimes/15888</a></p>",
        "id": 266532377,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640998863
    },
    {
        "content": "<p>RFC is up: <a href=\"https://github.com/rust-lang/rfcs/pull/3216\">https://github.com/rust-lang/rfcs/pull/3216</a></p>",
        "id": 267117380,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641504579
    }
]