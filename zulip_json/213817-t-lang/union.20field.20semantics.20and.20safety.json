[
    {
        "content": "<p>Starting this thread to discuss <a href=\"https://github.com/rust-lang/rust/issues/87520\">https://github.com/rust-lang/rust/issues/87520</a> .<br>\ncc <span class=\"user-mention\" data-user-id=\"255061\">@Léo Lanteri Thauvin</span> <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 248258084,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628014343
    },
    {
        "content": "<p>When we discussed this in today's lang meeting, we came to the conclusion that several of the \"safe\" examples shouldn't be safe.</p>",
        "id": 248258184,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628014404
    },
    {
        "content": "<p>To the degree that we may potentially want to consider those reads a soundness hole and fix them (and use crater to determine how much impact that would have, hopefully fairly little given that it mostly affects irrefutable patterns).</p>",
        "id": 248258399,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628014520
    },
    {
        "content": "<p>My first inclination would be for <em>all</em> of the patterns shown there, other than the match of <code>()</code>, to be unsafe.</p>",
        "id": 248258555,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628014583
    },
    {
        "content": "<p>(The ZST <code>()</code> would only be safe because it's a simple special case of \"every possible value of this memory is valid\" semantics that we may want in the future for safe reads of the fields from <code>union { f: f32, u: u32 }</code>; for a ZST, every possible value of the zero bytes of memory they occupy is valid.)</p>",
        "id": 248258699,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628014660
    },
    {
        "content": "<p>As far as I can tell, there wasn't any specific deliberate effort to make some union field reads safe in the MIR unsafety checker; it sounds like it just happened because of the semantics of MIR.</p>",
        "id": 248259325,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628014946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248258555\">said</a>:</p>\n<blockquote>\n<p>My first inclination would be for <em>all</em> of the patterns shown there, other than the match of <code>()</code>, to be unsafe.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I know you said similar in the meeting, but I want to clarify this point: You want to treat this as a special case based on the hypothetical generalization in the future? Why not wait until that future to support the ZST case (where it would, I assume, naturally fall out of the generalization you described)</p>",
        "id": 248264508,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628017387
    },
    {
        "content": "<p>I guess if it reduces the impact of this change, in terms of code breakage, then that’s a motivation. But we’d have to get some data on that.</p>",
        "id": 248264702,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628017485
    },
    {
        "content": "<p>We could say that \"any read of a union is unsafe\", which is a very easy rule to understand. If we stick to that, then matching on a ZST does no reads, and so is still safe, regardless of how the other situations shake out.</p>",
        "id": 248273066,
        "sender_full_name": "Lokathor",
        "timestamp": 1628021127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248273066\">said</a>:</p>\n<blockquote>\n<p>We could say that \"any read of a union is unsafe\", which is a very easy rule to understand. If we stick to that, then matching on a ZST does no reads, and so is still safe, regardless of how the other situations shake out.</p>\n</blockquote>\n<p>I think this is roughly how the unsafety checker works today: the reason why it doesn't report a read of a union field is because they are absent in MIR</p>",
        "id": 248273746,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628021421
    },
    {
        "content": "<p>And it still leads to behavior that is arguably surprising</p>",
        "id": 248273848,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628021479
    },
    {
        "content": "<p>The only reason to support the ZST case would be because it's already supported today and it might avoid some breakage. If crater shows that it doesn't matter either way, then I have no problem with the simpler rule of all field reads being unsafe, until we have a fuller infrastructure for determining what's safe.</p>",
        "id": 248274825,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628021927
    },
    {
        "content": "<p>But the weirdness of the ZST case is also why I think it's unlikely to arise in practice, so it may not matter either way.</p>",
        "id": 248274892,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628021959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"255061\">Léo Lanteri Thauvin</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248273746\">said</a>:</p>\n<blockquote>\n<p>I think this is roughly how the unsafety checker works today: the reason why it doesn't report a read of a union field is because they are absent in MIR</p>\n</blockquote>\n<p>But it appears that in today's rust the <code>OneVal::One</code> situation is also skipping the read.</p>\n<p>And while it's easy to see that this is in some sense technically correct: It's UB to have read any value other than the one enum variant that exists, so you can naturally skip the read, I think that maybe should stay unsafe anyway.</p>",
        "id": 248275579,
        "sender_full_name": "Lokathor",
        "timestamp": 1628022280
    },
    {
        "content": "<p>Even if the read doesn't actually occur after optimization, act \"as if\" it did occur and make it require unsafe.</p>",
        "id": 248275713,
        "sender_full_name": "Lokathor",
        "timestamp": 1628022359
    },
    {
        "content": "<blockquote>\n<p>safe reads of the fields from union { f: f32, u: u32 }</p>\n</blockquote>\n<p>FWIW, this would imply that <code>MaybeUninit::&lt;u32&gt;::uninit().assume_init()</code> is not UB. But we don't have to agree on this now I guess. ;)</p>",
        "id": 248328999,
        "sender_full_name": "RalfJ",
        "timestamp": 1628070107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248275713\">said</a>:</p>\n<blockquote>\n<p>Even if the read doesn't actually occur after optimization, act \"as if\" it did occur and make it require unsafe.</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> has been using <code>read</code> to mean the syntactic occurrence of a field access in the code, not an actual load being emitted in the LLVM IR.</p>",
        "id": 248329135,
        "sender_full_name": "RalfJ",
        "timestamp": 1628070201
    },
    {
        "content": "<p>I dont have a strong opinion on this as long as we dont presuppose that reading <code>i32</code> fields might ever be safe.</p>",
        "id": 248329164,
        "sender_full_name": "RalfJ",
        "timestamp": 1628070235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248328999\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>safe reads of the fields from union { f: f32, u: u32 }</p>\n</blockquote>\n<p>FWIW, this would imply that <code>MaybeUninit::&lt;u32&gt;::uninit().assume_init()</code> is not UB. But we don't have to agree on this now I guess. ;)</p>\n</blockquote>\n<p>Can I ask the reasoning that leads to that implication? I think Josh's example is dependent on the structure of the union in question. In particular, a <code>MaybeUninit</code> has fields with differing sizes (<code>()</code> and <code>T</code>), so its possible to create it via the <code>MaybeUninit { uninit: () }</code> form and thus one cannot assume there are initialized bits for the <code>T</code>. I thought the point of <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> ’s example was that no matter what path you use to create a <code>union { f: f32, u: u32 }</code>, you have to provide the 32-bits of data (that is, assuming only safe code here).</p>",
        "id": 248342088,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628079709
    },
    {
        "content": "<p>Josh said the justification is \"every possible value of this memory is valid\". But I don't think that uninitialized memory (which is distinct from any fixed, initialized bit pattern) should be valid for for integers.</p>",
        "id": 248342789,
        "sender_full_name": "RalfJ",
        "timestamp": 1628080157
    },
    {
        "content": "<p>but maybe I misunderstood</p>",
        "id": 248342815,
        "sender_full_name": "RalfJ",
        "timestamp": 1628080178
    },
    {
        "content": "<p>At least currently, that's not how validity of unions works in the formal model. A union is always an arbitrary blob of bytes of the appropriate size, regardless of the types in the union. I think even a singleton union <code>union { u: u32 }</code> is equivalent to <code>MaybeUninit&lt;u32&gt;</code> by this model.</p>\n<p>I agree that this is a little surprising, but I think it is simpler for the compiler since there isn't much advantage in exploiting an invariant like that</p>",
        "id": 248342828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628080185
    },
    {
        "content": "<p>I would assume that detecting whether that copy is safe is along the lines of safe transmute, though, otherwise you'd have to be incredibly choosy about which types work (which would probably mean that all fields are scalar types of the same size is the best you can do).</p>",
        "id": 248342838,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628080189
    },
    {
        "content": "<p>also this pertains to the validity invariant for <code>union</code> -- if it's up to me, then <code>MaybeUninit::uninit().assume_init()</code> will actually be non-UB for <em>any union</em>. (It might still be <code>unsafe</code> because unions can have user-defined safety invariants like all other named types.)<br>\n(EDIT: ah, raced with <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> )</p>",
        "id": 248342951,
        "sender_full_name": "RalfJ",
        "timestamp": 1628080242
    },
    {
        "content": "<p>Couldn't it still be safe, though, if all unions obtained a safety invariant of holding a valid value of it's elements (idk how breaking that would be, though).</p>",
        "id": 248343381,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628080470
    },
    {
        "content": "<p>I think the complication this saves is the need to define \"active element\" a la C++</p>",
        "id": 248343425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628080505
    },
    {
        "content": "<p>Well, that wouldn't need to be defined.</p>",
        "id": 248343463,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628080530
    },
    {
        "content": "<blockquote>\n<p>It is generally valid for unsafe code to assume that at least one field of a union is valid </p>\n</blockquote>\n<p>would be how I'd write it</p>",
        "id": 248343632,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628080624
    },
    {
        "content": "<p>I don't think you can guarantee that it is valid with any of the variants. For example you could have a <code>union { (bool, u8), (u8, bool) }</code> set to <code>(3, 3)</code></p>",
        "id": 248343653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628080641
    },
    {
        "content": "<p>I think validity checking in miri for this case would be pretty hard (under a hypothetical alternative validity invariant that says a union is valid iff it is valid at one of its variants)</p>",
        "id": 248343898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628080792
    },
    {
        "content": "<p>Well, that's why I'd say it's a safety invariant. This would allow it to become safe to read union fields under the same rules for safe transmute (If all fields can be transmuted to each other in the current context, assuming nothing, then it can be safe to read any field of a type with trivial destruction)</p>",
        "id": 248344027,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628080870
    },
    {
        "content": "<p>(Assuming safe transmute ever happens, of course)</p>",
        "id": 248344053,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628080893
    },
    {
        "content": "<p>The safety invariant for unions almost never matters because it is always overridden by a user-defined safety invariant</p>",
        "id": 248344124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628080930
    },
    {
        "content": "<p>But given how much you have to use unsafe around unions I think it is prudent to have it be the same as the validity invariant.</p>",
        "id": 248344356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628081087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248344027\">said</a>:</p>\n<blockquote>\n<p>Well, that's why I'd say it's a safety invariant. This would allow it to become safe to read union fields under the same rules for safe transmute (If all fields can be transmuted to each other in the current context, assuming nothing, then it can be safe to read any field of a type with trivial destruction)</p>\n</blockquote>\n<p>This sounds like it wants to be a library, like some kind of <code>Transmutable&lt;A, B&gt;</code> wrapper around a <code>A, B</code> union. There is no need for it to be a language feature</p>",
        "id": 248344705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628081278
    },
    {
        "content": "<blockquote>\n<p>Josh said the justification is \"every possible value of this memory is valid\".</p>\n</blockquote>\n<p>I don't wanna speak for Josh too much but I'm 99% sure they meant \"every possible initialization\" of this union (<code>{f32, u32}</code>) is valid data for all fields. <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 248349580,
        "sender_full_name": "Lokathor",
        "timestamp": 1628083779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> That \"Transmutable\" trait is already a library (<code>bytemuck</code>), and we're still making it a language feature (project safe transmute). Because it's better for the compiler to check it than to have some system you try and manage by hand.</p>",
        "id": 248349845,
        "sender_full_name": "Lokathor",
        "timestamp": 1628083914
    },
    {
        "content": "<p>I mean that <code>Transmutable</code> would be powered by all that safe-transmute intrinsic stuff</p>",
        "id": 248350051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628084000
    },
    {
        "content": "<p>why would we add all that to the compiler and then not also eventually make the compiler able to detect when unions can be safely read from?</p>",
        "id": 248350370,
        "sender_full_name": "Lokathor",
        "timestamp": 1628084137
    },
    {
        "content": "<p>because <code>Transmutable&lt;A, B&gt;</code> is actually adding a nontrivial safety invariant over <code>union { A, B }</code></p>",
        "id": 248350656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628084261
    },
    {
        "content": "<p>it's not just a type alias</p>",
        "id": 248350673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628084271
    },
    {
        "content": "<p>you could call it a safe wrapper function</p>",
        "id": 248350939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628084385
    },
    {
        "content": "<p>could you elaborate on what safety invariant is being added compared to the compiler detecting what reads are fine on its own?</p>",
        "id": 248351194,
        "sender_full_name": "Lokathor",
        "timestamp": 1628084497
    },
    {
        "content": "<p>it makes it safe to read some fields from unions with public fields -- which is not justified by the validity invariant so it can only be the safety invariant</p>",
        "id": 248354871,
        "sender_full_name": "RalfJ",
        "timestamp": 1628086251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248343653\">said</a>:</p>\n<blockquote>\n<p>I don't think you can guarantee that it is valid with any of the variants. For example you could have a <code>union { (bool, u8), (u8, bool) }</code> set to <code>(3, 3)</code></p>\n</blockquote>\n<p>Oh, my. I had thought from the RFC that the safe writes had to be to whole variants of the union. I didn’t realize this was legal (but it is accepted by compiler today): </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">union</span> <span class=\"nc\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">bu8</span>: <span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">u8b</span>: <span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">bu8</span>: <span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)};</span><span class=\"w\"></span>\n<span class=\"n\">u</span><span class=\"p\">.</span><span class=\"n\">u8b</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(and indeed, miri allows it too; miri only complains if you subsequently try to read the now-invalid boolean fields.)</p>",
        "id": 248355544,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628086547
    },
    {
        "content": "<p>I don’t know how the compiler is going to be able to reason about code-generation for matches in such a scenario.</p>",
        "id": 248355674,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628086595
    },
    {
        "content": "<p>(except to specify the exact order of operations for matches, e.g. that the reads will be emitted from left-to-right. Which was something we were not thrilled about doing in the lang team meeting…)</p>",
        "id": 248356097,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628086795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> assuming that A and B are some two specific types that one <em>can</em> transmute between then they would have to always meet each other's validity invariant already.</p>",
        "id": 248357102,
        "sender_full_name": "Lokathor",
        "timestamp": 1628087207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> but the union's validity invariant allows just plain uninit memory no matter the A/B (at least I think it should)</p>",
        "id": 248357501,
        "sender_full_name": "RalfJ",
        "timestamp": 1628087363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248355674\">said</a>:</p>\n<blockquote>\n<p>I don’t know how the compiler is going to be able to reason about code-generation for matches in such a scenario.</p>\n</blockquote>\n<p>what exactly is the problem?</p>",
        "id": 248357614,
        "sender_full_name": "RalfJ",
        "timestamp": 1628087407
    },
    {
        "content": "<p>Im in the midst of writing an example to establish the missing context</p>",
        "id": 248357669,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087430
    },
    {
        "content": "<p><code>union</code> is a bad name for these types, the way they work in Rust -- IMO the right mental model here is to just think of them as convenient syntax for transmutes (\"transmute whateveter the underlying bytes are to the field type\"). there's no way in which a <code>union</code> is the \"union\" of its fields.</p>",
        "id": 248357727,
        "sender_full_name": "RalfJ",
        "timestamp": 1628087452
    },
    {
        "content": "<p>just to fill in the missing context for <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248355674\">my comment above</a> about codegen for <code>match</code>, here’s a <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8a656a728bfa56cb4b08f8d93ce0c4e2\">playground</a>, with some code like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">union</span> <span class=\"nc\">U</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// invariant: outline.1 == 0</span>\n<span class=\"w\">    </span><span class=\"n\">outline</span>: <span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// invariant: inline.2 == 1</span>\n<span class=\"w\">    </span><span class=\"n\">inline</span>: <span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248358298,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087657
    },
    {
        "content": "<p>and this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">outline</span>: <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"outline({:?})\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inline</span>: <span class=\"p\">(</span><span class=\"n\">d1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"inline({:?}, {:?})\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d2</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"should be impossible if code is correct.\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248358337,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087678
    },
    {
        "content": "<p>in particular, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> asserted during the meeting that the intention has been that one should be able to use <code>match</code> on (parts of) union fields to discriminate which field we are in.</p>",
        "id": 248358461,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087737
    },
    {
        "content": "<p>(as opposed to requiring that such tagging live outside the union)</p>",
        "id": 248358501,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I don't see a value to programmers if <code>union{u32,f32}</code>, which can only have a <code>u32</code> or <code>f32</code> written to it by fully safe code, is not readable safely from either field.</p>",
        "id": 248358661,
        "sender_full_name": "Lokathor",
        "timestamp": 1628087820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248358461\">said</a>:</p>\n<blockquote>\n<p>in particular, <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> asserted during the meeting that the intention has been that one should be able to use <code>match</code> on (parts of) union fields to discriminate which field we are in.</p>\n</blockquote>\n<p>Now what I’m worried about is how to do codegen for something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">outline</span>: <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"outline(... {:?})\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inline</span>: <span class=\"p\">(</span><span class=\"n\">d1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"inline({:?}, {:?})\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d2</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"should be impossible if code is correct.\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248358786,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087869
    },
    {
        "content": "<p>Handling the above requires dereferencing the <code>&amp;[u32]</code> in the <code>outline</code> case. Knowing that we are in the outline case requires inspecting the appropriate constant value (<code>0</code> in this case). But the compiler cannot be expected to infer which part of the union field has that role.</p>",
        "id": 248359068,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087966
    },
    {
        "content": "<p>So it seems like we may be forced to say “you cannot write code like that.\"</p>",
        "id": 248359123,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628087991
    },
    {
        "content": "<p>On the plus side, Miri does detect an incorrect access from code like the above</p>",
        "id": 248359293,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628088048
    },
    {
        "content": "<p>(i’m now checking if moving the tag to the <code>.0</code> part of each field lets the whole shebang proceed, at least in miri)</p>",
        "id": 248359450,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628088115
    },
    {
        "content": "<p>okay, <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=adf95a812704901dfbecfa1032f9f0fb\">confirmed</a> that putting tag data first makes miri happy. So maybe the best answer in the end is to specify that code-emission for pattern matching is specified as top-down, left-to-right, and that any deviation from that from within the compiler has to justified via static analysis.</p>",
        "id": 248360431,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628088505
    },
    {
        "content": "<p>(and if you are forced to declare your data in an manner that makes left-to-right matching incorrect, like my <code>U { outline: … }</code> example above, then you need to force the operations to be in a valid order e.g. via guards on the arm as in <code>match u { U { outline: (p, 0) } if let &amp;[10, 20, 30, x] = p =&gt; { … } … }</code>, once if let guards are supported, that is.)</p>",
        "id": 248361249,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628088841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> The name \"union\" applies because it's a union of the <em>types</em> and <em>fields</em> involved, and thus also the possible values.</p>",
        "id": 248368383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628091984
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> And, sidestepping the \"uninitialized memory\" argument, I'm not (today) talking about MaybeUninit::uninit().assume_init(). Unions track whether they've been initialized, just like a normal let does. A union of u32 and f32 that <em>has</em> been initialized should be safe to read via either field, for the same reason that a struct with a u32 field should be safe to read the field from.</p>",
        "id": 248368892,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628092250
    },
    {
        "content": "<p>If you assume_init on something uninitialized, the UB would happen at that point, and that's within unsafe code.</p>",
        "id": 248368972,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628092299
    },
    {
        "content": "<p>If we make it safe to read and write both fields of a union of u32 and f32, I don't see any path by which that would allow UB in safe code.</p>",
        "id": 248369115,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628092373
    },
    {
        "content": "<blockquote>\n<p>A union of u32 and f32 that has been initialized should be safe to read via either field</p>\n</blockquote>\n<p>But that only works because f32 and u32 have the same validity invariants, so to support this in general there would need to be a notion of \"validity equality\"</p>",
        "id": 248369176,
        "sender_full_name": "bstrie",
        "timestamp": 1628092414
    },
    {
        "content": "<p>Right, and that's why this needs to wait until we have the safe-transmute infrastructure in the compiler.</p>",
        "id": 248369261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628092452
    },
    {
        "content": "<p>is safe-transmute infrastructure independent from unsafe-checking-on-THIR?</p>",
        "id": 248369369,
        "sender_full_name": "bstrie",
        "timestamp": 1628092526
    },
    {
        "content": "<p>(As a first pass, I think the easiest case will be when all fields are the same size and don't <em>have</em> any validity invariants.)</p>",
        "id": 248369407,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628092548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> As far as I know they aren't connected...</p>",
        "id": 248369476,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628092566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248368892\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> And, sidestepping the \"uninitialized memory\" argument, I'm not (today) talking about MaybeUninit::uninit().assume_init(). Unions track whether they've been initialized, just like a normal let does. A union of u32 and f32 that <em>has</em> been initialized should be safe to read via either field, for the same reason that a struct with a u32 field should be safe to read the field from.</p>\n</blockquote>\n<p>As mentioned though, this would have to be justified either by a safety invariant or a validity invariant imposed on all <code>union</code> types.</p>",
        "id": 248370376,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628092975
    },
    {
        "content": "<p>I don't understand why it's imposed on all union types</p>",
        "id": 248371900,
        "sender_full_name": "Lokathor",
        "timestamp": 1628093726
    },
    {
        "content": "<p>This would only apply to unions that have fields that are compatible</p>",
        "id": 248372191,
        "sender_full_name": "Lokathor",
        "timestamp": 1628093864
    },
    {
        "content": "<p>Well, it seems counterintuitive that the invariant for <code>union {x: char, y: u32}</code> is more relaxed than <code>union {x: f32, y:u32}</code></p>",
        "id": 248372660,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628094064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> What do you mean by \"more relaxed\"? The latter would allow safe reads, the former would not.</p>",
        "id": 248372935,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628094183
    },
    {
        "content": "<p>Well, if we accept that as a validity invariant <code>union</code>s can be uninitialized, but unions with only compatible fields have a safety invariant that the memory must be valid for at least one of the fields, then the former can be left uninitialized and passed into foreign safe code, whereas the latter cannot.</p>",
        "id": 248373131,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628094284
    },
    {
        "content": "<p>What do you mean by \"unions can be uninitialized\"?</p>",
        "id": 248373239,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628094335
    },
    {
        "content": "<p>Not any more or less so than other types...</p>",
        "id": 248373260,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628094349
    },
    {
        "content": "<p>There's a validity invariant that unions may contain any bit pattern, so there would be a difference for unions containing fields with types for which not all bit patterns are valid, but reading from such a field wouldn't be safe.</p>",
        "id": 248373485,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628094451
    },
    {
        "content": "<p>You can't ever actually read uninit, i think we all agree on that.</p>\n<p>thus, saying that you can read from some types of unions based on static info about the fields isn't adding any rules, because if the bytes were uninit you already weren't allowed to actually read them.</p>",
        "id": 248373725,
        "sender_full_name": "Lokathor",
        "timestamp": 1628094576
    },
    {
        "content": "<blockquote>\n<p>You can't ever actually read uninit, i think we all agree on that.</p>\n</blockquote>\n<p>\"agree\" is a strong word. I'm just not rehashing a well-trodden argument on that topic, because it isn't relevant to this issue about when union fields can be safe.</p>\n<blockquote>\n<p>thus, saying that you can read from some types of unions based on static info about the fields isn't adding any rules, because if the bytes were uninit you already weren't allowed to actually read them.</p>\n</blockquote>\n<p>Exactly.</p>",
        "id": 248374146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628094777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248373239\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"unions can be uninitialized\"?</p>\n</blockquote>\n<p>I agree with Connor here. I think it would be problematic to have a rule that causes <code>union { [u8; N], [u8; 8] }</code> to be valid for uninitialized memory (that is, <code>uninit().assume_init()</code> does not cause UB) for all <code>N</code> except <code>N = 8</code></p>",
        "id": 248375378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628095368
    },
    {
        "content": "<p>The advantage of <code>Transmutable&lt;A, B&gt;</code> is that you are explicitly opting in to the valid-A-or-B behavior, and it's a safety invariant so the compiler doesn't have to get involved</p>",
        "id": 248375633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628095495
    },
    {
        "content": "<p>I don't think this would change the validity invariant, just the safety invariant essentially</p>",
        "id": 248375881,
        "sender_full_name": "Lokathor",
        "timestamp": 1628095617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248373725\">said</a>:</p>\n<blockquote>\n<p>You can't ever actually read uninit, i think we all agree on that.</p>\n</blockquote>\n<p>Actually, you can read uninit into types that allow uninit (like <code>union</code>!) That is, with the current bag-of-bytes semantics, the compiler could conceivably make reading the <code>u</code> field of <code>union { a: A, u: union { b: B, c: C } }</code> safe, although from a language consistency POV I don't think it's worth it</p>",
        "id": 248375909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628095629
    },
    {
        "content": "<p>I would <em>like</em> to make that safe and well-defined, but that's a problem for another day, and I don't think it's a prerequisite to making the simple case of u32/f32 unions safe.</p>",
        "id": 248376448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628095877
    },
    {
        "content": "<p>why can't this wait for safe-transmute? I assume that's the main reason for wanting safe unions like this</p>",
        "id": 248376599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628095946
    },
    {
        "content": "<p>(also, if we need to say that generic unions are only safe if they're statically provable to be safe pre-monomorphization, that seems fine. So, for instance, if you had to declare a bound using one of the safe transmute traits.)</p>",
        "id": 248376607,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628095952
    },
    {
        "content": "<p>It can, and it should.</p>",
        "id": 248376625,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628095959
    },
    {
        "content": "<p>It seems like safe-transmute solves these problems already and better. I don't think <code>union</code> should be used for this purpose</p>",
        "id": 248376647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628095973
    },
    {
        "content": "<p>I am specifically suggesting that once the safe transmute infrastructure exists in the compiler, we should use exactly the same infrastructure to determine when reading and writing union fields can be safe.</p>",
        "id": 248376673,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628095988
    },
    {
        "content": "<p>I think it solves these problems, and I think sometimes you want a transmute and sometimes you want a union.</p>",
        "id": 248376716,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096014
    },
    {
        "content": "<p>because it gets really hairy to determine that all fields are layout compatible and don't have issues like <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248355544\">this one</a></p>",
        "id": 248376816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096046
    },
    {
        "content": "<p>That sounds like exactly the same problem the safe transmute infrastructure has: it also has to determine if (bool, u8) and (u8, bool) are compatible, which they aren't.</p>",
        "id": 248376928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096122
    },
    {
        "content": "<p>Also I'm not sure that layout compatibility in the sense of safe-transmute is good enough because you can use field writes to do \"recombination\"</p>",
        "id": 248376935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096125
    },
    {
        "content": "<p>if you construct something that is half-A and half-B it might not be valid for either one</p>",
        "id": 248377062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248376599\">said</a>:</p>\n<blockquote>\n<p>why can't this wait for safe-transmute? I assume that's the main reason for wanting safe unions like this</p>\n</blockquote>\n<p>To be clear: The question being originally asked via <a href=\"https://github.com/rust-lang/rust/issues/87520\">#87520</a> was “what patterns should be considered safe”, and the issue was specifically pointing out cases that are accepted today via the MIR unsafety checking that are questionable (at least when compared to the text of the original RFC for union).</p>",
        "id": 248377071,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096177
    },
    {
        "content": "<p>Also, for a first pass, it would suffice to allow safety only in the cases where every possible value is valid. So, it would be fine if introducing a bool or enum or char or any other type with some invalid bit patterns would mean you have to use unsafe.</p>",
        "id": 248377098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096194
    },
    {
        "content": "<p>So my take is that, if anything, we’re trying to figure out how to make fewer things safe, not how to make more things safe.</p>",
        "id": 248377103,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096195
    },
    {
        "content": "<p>(Agreed. Making more things safe can happen later, when we have the safe transmit infrastructure.)</p>",
        "id": 248377154,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248376928\">said</a>:</p>\n<blockquote>\n<p>That sounds like exactly the same problem the safe transmute infrastructure has: it also has to determine if (bool, u8) and (u8, bool) are compatible, which they aren't.</p>\n</blockquote>\n<p>(you should take a look at the example that <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> and I were talking about <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248355544\">above</a>. It does not strike me as the same problem as safe transmute.)</p>",
        "id": 248377384,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096326
    },
    {
        "content": "<p>The case of matching on a repr(u8) \"zst\" is interesting. I see why it is allowed to be safe, since there isn't any code run to access the union. It's not even that it would be UB for it to be anything else, it's that it is literally an irrefutable match: if you check that the value is 0 then that implies that there is another branch if it's not</p>",
        "id": 248377467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096366
    },
    {
        "content": "<p>I did see that example. I was suggesting that since safe-transmute would flag those two as not compatible, all the field accesses would become unsafe, which would solve the problem.</p>",
        "id": 248377499,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096382
    },
    {
        "content": "<p>I see</p>",
        "id": 248377604,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Yeah, I can see why it works as well. But it also seems like confusing semantics to have anywhere near unsafe code, and it might lead people to make invalid assumptions.</p>",
        "id": 248377629,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> To use a similar example, if you had a union of <code>(bool, u8)</code> and <code>(bool, i8)</code>, that could allow safe reads/writes.</p>",
        "id": 248377708,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096453
    },
    {
        "content": "<p>IMO it's not clear that even unsafe field access is enough to make enum matches viable (i.e., what the author needs to do to justify it's actually not UB)</p>",
        "id": 248377718,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096460
    },
    {
        "content": "<p>It is also possible to make this unsafe \"by fiat\", even though the desugaring doesn't say anything about this being a problem - just add a fake MIR operation to retain the fact that a union is getting matched on</p>",
        "id": 248377793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> what do you think of my assertion <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248358786\">above</a> that the only realistic plan would be to specific the pattern-match order-of-evaluation?</p>",
        "id": 248377834,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096519
    },
    {
        "content": "<p>I think that would <em>help</em> but it feels like the sort of thing where if I was reviewing the code I'd probably say \"don't use match here\", too dangerous. ifs and such are likely easier to understand, would be my guess.</p>",
        "id": 248377957,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096569
    },
    {
        "content": "<p>yes, I agree that I would recommend people not use <code>match</code> for such cases</p>",
        "id": 248378012,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096596
    },
    {
        "content": "<p>but I still think we need to spell out the compiler’s rules</p>",
        "id": 248378030,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096603
    },
    {
        "content": "<p>hm, I mean, the alternative is to just not support unsafe field access in matches, right?</p>",
        "id": 248378083,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096631
    },
    {
        "content": "<p>pattern evaluation order might also become relevant for deref-patterns</p>",
        "id": 248378186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096664
    },
    {
        "content": "<p>like, I'd rather not bend over backwards to define something that restricts the compiler's implementation and is likely impractical for users to rely on, if that makes sense</p>",
        "id": 248378251,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096700
    },
    {
        "content": "<p>but specifying pattern evaluation order too much prevents the compiler from optimizing matches</p>",
        "id": 248378296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248377834\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> what do you think of my assertion <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248358786\">above</a> that the only realistic plan would be to specific the pattern-match order-of-evaluation?</p>\n</blockquote>\n<p>I think it would be possible to do this without restricting order-of-evaluation, though it'd be a challenge.</p>",
        "id": 248378305,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I don’t see how, not in the general case</p>",
        "id": 248378330,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096745
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> You could freeze the union's memory before matching on it.</p>",
        "id": 248378428,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096774
    },
    {
        "content": "<p>(need to go to lang meeting, more later)</p>",
        "id": 248378459,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628096790
    },
    {
        "content": "<p>you could do it the same way as layout optimizations: the compiler picks <em>a</em> choice and it's not UB if you guess right but the specific order is unstable</p>",
        "id": 248378492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096806
    },
    {
        "content": "<p>which in practice means that you can't write matches like that</p>",
        "id": 248378526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096825
    },
    {
        "content": "<p>yeah I don’t see how that’s a solution</p>",
        "id": 248378544,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628096834
    },
    {
        "content": "<p>unless you know the order doesn't matter</p>",
        "id": 248378553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096839
    },
    {
        "content": "<p>I think the alternative is if we had a \"untyped\" memcmp of some kind, but my understanding that's not really a thing</p>",
        "id": 248378607,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096869
    },
    {
        "content": "<p>(This is sort of \"freeze on steroids\")</p>",
        "id": 248378689,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096891
    },
    {
        "content": "<p>wait, memcmp is typed?</p>",
        "id": 248378692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628096895
    },
    {
        "content": "<p>Well, not literally memcmp, but, like, if we could lower match (maybe just for unions) to a memcmp (and that worked for uninit etc) then it might work out</p>",
        "id": 248378805,
        "sender_full_name": "simulacrum",
        "timestamp": 1628096947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> maybe I’m missing something, but: As I tried to illustrate <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248358786\">above</a>, in general you’ll still need to handle dereferencing pointers while pattern matching. I don’t see how memcmp handles that, (unless you’re talking about something where we try to dynamically detect whether a memory address is valid to dereference?)</p>",
        "id": 248380914,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628097951
    },
    {
        "content": "<p>Ah, sure, yes, that's still a problem. I mean that memcmp or similar may help solve the <em>flat</em> case at least, and in theory you could build some sort of rules like matching the sort of \"top-level\" bits that are present without going through pointers, and those dictating which pointers are (assumed) valid to follow</p>",
        "id": 248381125,
        "sender_full_name": "simulacrum",
        "timestamp": 1628098044
    },
    {
        "content": "<p>Interesting. In the limiting case, you could have two pointer fields, and you need to deference one to determine the validity of the other. Matching both of those in one match arm does seem like it'd be near-impossible to support reasonably.</p>",
        "id": 248381175,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098070
    },
    {
        "content": "<p>talk about pathological examples, josh! what a monster</p>",
        "id": 248381290,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098113
    },
    {
        "content": "<p>Not completely pathological. Consider if the first is a string giving the type of the second. :)</p>",
        "id": 248381335,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098140
    },
    {
        "content": "<p>I am curious whether we could get way with specifying left-to-right <em>solely</em> within <code>union</code></p>",
        "id": 248381362,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098153
    },
    {
        "content": "<p>well it's not \"in\" the union, it's in the tuple match after the union</p>",
        "id": 248381416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098180
    },
    {
        "content": "<p>i.e. give compiler more freedom with portions of data structures outside of the context of a <code>union</code></p>",
        "id": 248381451,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098194
    },
    {
        "content": "<p>Sure, I’m just saying: it could be a context-sensitive rule</p>",
        "id": 248381522,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I would ideally not want to prevent the compiler from doing some kind of wider comparison, if there's no padding that it needs to avoid matching (or if it has some wide comparison op that can skip the padding).</p>",
        "id": 248381537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098218
    },
    {
        "content": "<p>sorry, josh, can you spell out your concern a bit more?</p>",
        "id": 248381620,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098259
    },
    {
        "content": "<p>are you talking about wanting to skip padding that is embedded in a union?</p>",
        "id": 248381657,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098273
    },
    {
        "content": "<p>I was just thinking that <code>unsafe match</code> should be a thing, so that you can say that a pattern match is doing unsafe things without also saying the same about the branches, but it occurs to me that this would also help here, since you could say that <code>unsafe match</code> has stricter ordering rules</p>",
        "id": 248381702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098298
    },
    {
        "content": "<p>Ignore the padding case for now (it could be handled but it's more complex). Here's the case I'm thinking of:</p>",
        "id": 248381703,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248381702\">said</a>:</p>\n<blockquote>\n<p>I was just thinking that <code>unsafe match</code> should be a thing, so that you can say that a pattern match is doing unsafe things without also saying the same about the branches, but it occurs to me that this would also help here, since you could say that <code>unsafe match</code> has stricter ordering rules</p>\n</blockquote>\n<p>We've talked in the past about having \"unsafe\" in patterns, so you could write something like <code>match expr { unsafe { pat } =&gt; ... }</code></p>",
        "id": 248381809,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098328
    },
    {
        "content": "<p>I suppose the idea of having <code>unsafe</code> imply stricter order-of-eval for patterns works for both <code>unsafe match</code> and <code>unsafe { pat }</code></p>",
        "id": 248381932,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098395
    },
    {
        "content": "<p>If I have <code>union U { n: u32, f: f32 }; struct S { ty: u32, val: U }</code>, and I write a match arm <code>S { ty: 0, val: U { n: 42 } }</code>, it <em>should</em> be fine to match the whole 64 bits at a time.</p>",
        "id": 248381959,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098408
    },
    {
        "content": "<p>...unsafely?</p>",
        "id": 248382061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098452
    },
    {
        "content": "<p>Safely, but that's orthogonal to the point; I'm suggesting that strict \"left-to-right\" semantics might not allow that.</p>",
        "id": 248382096,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098475
    },
    {
        "content": "<p>And I think we shouldn't prevent the compiler from emitting that code.</p>",
        "id": 248382114,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098485
    },
    {
        "content": "<p>that sounds like it could be implemented as a compiler optimization based on the type definitions</p>",
        "id": 248382159,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098510
    },
    {
        "content": "<p>Or at least, I do not yet see where order-of-eval breaks that specific case. Unless you meant that the compiler has to assume there might be padding in there, even when it knows there isn’t?</p>",
        "id": 248382230,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098546
    },
    {
        "content": "<p>If you are okay with having this be a \"spurious unsafe\", I don't see any problem with that code - presumably you know that your union is initialized and there aren't any pointers to cause issues, so as a user you should feel fine writing that, and the compiler is under no particular obligations</p>",
        "id": 248382309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I see. You're suggesting that the compiler could see that the types are all valid-for-all-bit-patterns and then use the as-if rule to do a 64-bit match?</p>",
        "id": 248382328,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098583
    },
    {
        "content": "<p>I guess your point is that if the semantics is that we never inspect <code>U { n: … }</code> as a pattern without separately checking the <code>ty == 0</code> , then that is what breaks reading all 64-bits at once?</p>",
        "id": 248382361,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248382328\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> I see. You're suggesting that the compiler could see that the types are all valid-for-all-bit-patterns and then use the as-if rule to do a 64-bit match?</p>\n</blockquote>\n<p>yes, that is essentially what I was getting at</p>",
        "id": 248382383,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> Right, exactly. I don't want the way in which we specify the semantics to <em>prevent</em> the compiler from doing that optimization when it can.</p>",
        "id": 248382419,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098636
    },
    {
        "content": "<p>because I can imagine variations of your example, namely involving pointers, where it would absolutely be wrong to try to deref the pointer without first separately confirming the type-tag</p>",
        "id": 248382438,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> <em>Absolutely</em>!</p>",
        "id": 248382453,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098661
    },
    {
        "content": "<p>If one of the union variants were a pointer-to-string, you couldn't dereference and do a string comparison before you check the ty field.</p>",
        "id": 248382582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098708
    },
    {
        "content": "<p>What if the other variant is <code>()</code>?</p>",
        "id": 248382605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098722
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Then the match should be <em>unsafe</em>, but the compiler could still theoretically do a 64-bit comparison.</p>",
        "id": 248382637,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098742
    },
    {
        "content": "<p>For me, I’m more concerned about whether we want to allow <code>U { n: usize, p: &amp;’static Thing }; struct S { ty: u32, val: U }</code> and a subsequent match arm <code>S { val: U { p: &amp;Thing(UH_OH) }, ty: THING_TAG }</code></p>",
        "id": 248382681,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098772
    },
    {
        "content": "<p>Is it safe to do a 64-bit comparison with a partially uninitialized value (in LLVM)?</p>",
        "id": 248382710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> That's why I was suggesting that one solution would be for the match to emit a <code>freeze</code> operation on the union's memory before doing a comparison.</p>",
        "id": 248382792,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098820
    },
    {
        "content": "<p>or if the match arm, as written by the user, has to <em>always</em> put the <code>ty</code> to the left of the <code>val</code> in the struct pattern</p>",
        "id": 248382806,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248382681\">said</a>:</p>\n<blockquote>\n<p>For me, I’m more concerned about whether we want to allow <code>U { n: usize, p: &amp;’static Thing }; struct S { ty: u32, val: U }</code> and a subsequent match arm <code>S { val: U { p: &amp;Thing(UH_OH) }, ty: THING_TAG }</code></p>\n</blockquote>\n<p>That's an <em>excellent</em> question.</p>",
        "id": 248382821,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628098844
    },
    {
        "content": "<p>I suppose that might be a case where people will be advised to prefer tuple-structs over named-fields</p>",
        "id": 248382889,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098891
    },
    {
        "content": "<p>in order to encourage specific pattern-evaluation orderings</p>",
        "id": 248382919,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628098909
    },
    {
        "content": "<p>this all seems very footgunny</p>",
        "id": 248383005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098945
    },
    {
        "content": "<p>I'm not sure <code>unsafe</code> is even good enough to cover this</p>",
        "id": 248383050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098968
    },
    {
        "content": "<p>because people will already be expecting to have to use <code>unsafe</code> around unions</p>",
        "id": 248383089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628098993
    },
    {
        "content": "<p>I do think it's important to allow matching a type tag and the associated value in the same match arm. But I can <em>definitely</em> imagine that there are corner cases of that that we can't support.</p>",
        "id": 248383129,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248382889\">said</a>:</p>\n<blockquote>\n<p>I suppose that might be a case where people will be advised to prefer tuple-structs over named-fields</p>\n</blockquote>\n<p>(even though one could still write <code>{S { 1: U { p: &amp;Thing(UH_OH) }, 0: THING_TAG }</code>)</p>",
        "id": 248383227,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099065
    },
    {
        "content": "<p>I think the reference case would be sufficiently complicated to support that for the moment we probably <em>don't</em> want to support that.</p>",
        "id": 248383243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099079
    },
    {
        "content": "<p>What does “don’t want to” mean here? I.e., some cases of this work today</p>",
        "id": 248383305,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099111
    },
    {
        "content": "<p>namely, Miri accepts code that obeys the left-to-right ordering rule</p>",
        "id": 248383335,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248383335\">said</a>:</p>\n<blockquote>\n<p>namely, Miri accepts code that obeys the left-to-right ordering rule</p>\n</blockquote>\n<p>I didn't know that rule was part of the compiler's semantics today...</p>",
        "id": 248383354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099141
    },
    {
        "content": "<p>(from what I’ve seen so far, that is. I admit its been a shallow investigation.)</p>",
        "id": 248383362,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099147
    },
    {
        "content": "<p>I thought that was a proposed semantics.</p>",
        "id": 248383366,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099149
    },
    {
        "content": "<p>right, and I’m trying to figure out what we’re willing to specify as “will work in the future\"</p>",
        "id": 248383445,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099172
    },
    {
        "content": "<p>if we’re talking about invalidating <em>all</em> cases where a match pattern dereferences under a union, then that is a breaking change from today</p>",
        "id": 248383496,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099205
    },
    {
        "content": "<p>/me shakes his head.</p>",
        "id": 248383516,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099219
    },
    {
        "content": "<p>At most, we'd be talking about cases of matching a reference while simultaneously determining if that reference is valid.</p>",
        "id": 248383541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099238
    },
    {
        "content": "<p>But if we already specify left-to-right, that could potentially work.</p>",
        "id": 248383569,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099255
    },
    {
        "content": "<p>right now my guess is that the compiler is doing mostly left to right ordering during MIR generation since that's the obvious thing to do, and the soundness of the operations is well defined by that point</p>",
        "id": 248383614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628099277
    },
    {
        "content": "<p>Its tough because I don’t know what we actually <em>specify</em> today. Its hard for users to observe the ordering. (Maybe impossible, at least in stable code, becase we don’t support <code>Deref</code> in patterns?)</p>",
        "id": 248383686,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099297
    },
    {
        "content": "<p>Just to confirm, I <em>think</em> the question of match order is orthogonal to unsafety, insofar as we need to handle match order whether a field is safe or unsafe to read?</p>",
        "id": 248383687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099300
    },
    {
        "content": "<p>so it's not too surprising that miri testing reveals this</p>",
        "id": 248383697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628099305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248383686\">said</a>:</p>\n<blockquote>\n<p>Its tough because I don’t know what we actually <em>specify</em> today. Its hard for users to observe the ordering. (Maybe impossible, at least in stable code, becase we don’t support <code>Deref</code> in patterns?)</p>\n</blockquote>\n<p>Do we support user-defined Eq in patterns?</p>",
        "id": 248383730,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628099328
    },
    {
        "content": "<p>ah, right. Matching CONST sometimes uses <code>Eq</code></p>",
        "id": 248383760,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099344
    },
    {
        "content": "<p>or at least it used to</p>",
        "id": 248383773,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099350
    },
    {
        "content": "<p>we tried to legislate that away</p>",
        "id": 248383781,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099358
    },
    {
        "content": "<p>I thought that's restricted to structural_eq marked impls or something?</p>",
        "id": 248383797,
        "sender_full_name": "simulacrum",
        "timestamp": 1628099365
    },
    {
        "content": "<p>Doesn't that require the unstable <code>StructuralEq</code> trait?</p>",
        "id": 248383804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628099366
    },
    {
        "content": "<p>which now ties into the struct equality question. :)</p>",
        "id": 248383811,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099368
    },
    {
        "content": "<p>right right</p>",
        "id": 248383818,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099372
    },
    {
        "content": "<p>so users cannot override it</p>",
        "id": 248383835,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099382
    },
    {
        "content": "<p>it needs to be a derived implementation of <code>PartialEq</code>, all the way down</p>",
        "id": 248383851,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099390
    },
    {
        "content": "<p>if I recall correctly</p>",
        "id": 248383869,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099396
    },
    {
        "content": "<p>So: unstable code can observe order of pattern evaluation, e.g. via manual impl of <code>StructuralEq</code> and manual impl of <code>PartialEq</code>, etc.</p>",
        "id": 248384048,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099481
    },
    {
        "content": "<p>but still, no evidence that I know of that stable code can observe pattern order-of-eval</p>",
        "id": 248384096,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099510
    },
    {
        "content": "<p>I have to admit, I’m sort of amazed that the conversation took a turn that ended up aligning with the struct-eq stuff.</p>",
        "id": 248384196,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628099537
    },
    {
        "content": "<p>So just a quick summary so far: if supporting detection of tag field and also payload field in a single match is desired, we need one of:</p>\n<ul>\n<li>a way to tell the compiler which field is the tag</li>\n<li>a very clearly specified order for how matching works.</li>\n<li>implicit freeze operation on the full union before the matching begins.</li>\n</ul>",
        "id": 248384580,
        "sender_full_name": "Lokathor",
        "timestamp": 1628099745
    },
    {
        "content": "<p>You also need a way to make sure all the tags in the different fields line up, which I think is difficult to impossible in repr(rust)</p>",
        "id": 248384954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628099926
    },
    {
        "content": "<p>could always use two unions and a struct</p>",
        "id": 248385321,
        "sender_full_name": "Lokathor",
        "timestamp": 1628100076
    },
    {
        "content": "<p>I think an implicit freeze would suffice for any case that doesn't involve dereferencing a potentially invalid pointer.</p>",
        "id": 248385384,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628100115
    },
    {
        "content": "<p>You'd need to make sure your reads are unaligned, too, I think, if you want to support variable length tags (e.g, some u8 and some u64), right?</p>",
        "id": 248385537,
        "sender_full_name": "simulacrum",
        "timestamp": 1628100187
    },
    {
        "content": "<p>(I guess it depends -- maybe that's only the case if you can have an unaligned field, such as in a packed union?)</p>",
        "id": 248385686,
        "sender_full_name": "simulacrum",
        "timestamp": 1628100255
    },
    {
        "content": "<p>Right, as far as I know a union with a u64 field has u64 alignment unless you do something to change that (such as packing).</p>",
        "id": 248386091,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628100459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248358661\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>  I don't see a value to programmers if <code>union{u32,f32}</code>, which can only have a <code>u32</code> or <code>f32</code> written to it by fully safe code, is not readable safely from either field.</p>\n</blockquote>\n<p>I think trying to capture in the validity (or safety) invariant properties such as \"every field allows value X on this byte\" is fragile and a lot more complicated than the benefits that could be gained from this.</p>",
        "id": 248603588,
        "sender_full_name": "RalfJ",
        "timestamp": 1628252693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248373260\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"unions can be uninitialized\"?<br>\nNot any more or less so than other types...</p>\n</blockquote>\n<p>That's not at all how my <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">proposed model of unions</a> works. There, all unions can always be uninitialized (and besides padding they are in fact the old types that can be uninitialized).</p>\n<p>But anyway, for now we seem to all agree that all accesses should be unsafe for now (except maybe for <code>()</code>), and all potential relaxations of this can delegated to the future.</p>",
        "id": 248603824,
        "sender_full_name": "RalfJ",
        "timestamp": 1628252850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248385384\">said</a>:</p>\n<blockquote>\n<p>I think an implicit freeze would suffice for any case that doesn't involve dereferencing a potentially invalid pointer.</p>\n</blockquote>\n<p>I am rather sceptical of any solution that relies on <code>freeze</code>...</p>",
        "id": 248603968,
        "sender_full_name": "RalfJ",
        "timestamp": 1628252942
    },
    {
        "content": "<p>i wouldn't call it an altered validity invariant, I'd call it a safety invariant</p>",
        "id": 248617198,
        "sender_full_name": "Lokathor",
        "timestamp": 1628259763
    },
    {
        "content": "<p>Same as you can make &amp;str values not contain valid utf8 using unsafe, but it's absolutely the fault of the unsafe code that made that value and let it out into the rest of the program when things go wrong.</p>",
        "id": 248617344,
        "sender_full_name": "Lokathor",
        "timestamp": 1628259843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248617198\">said</a>:</p>\n<blockquote>\n<p>i wouldn't call it an altered validity invariant, I'd call it a safety invariant</p>\n</blockquote>\n<p>yeah but <code>str</code> is a particular type that <em>we</em> define. OTOH as language designers we are not really in the business of defining the safety invariants of <em>user-defined</em> types like <code>union</code>s.</p>",
        "id": 248618277,
        "sender_full_name": "RalfJ",
        "timestamp": 1628260265
    },
    {
        "content": "<p>not normally, no.</p>\n<p>Then again, if you violate the safety invariant and put uninit into the union and someone goes and reads it, then that's UB anyway, even if textually on the page it said <code>unsafe { }</code>. So I don't think this is a heavy burden.</p>\n<p>but hek it could be a repr modifier like align, i dont think anyone would mind. What nearly everyone wants is safe reading of an initialized union when the compiler can statically determine that it's fine.</p>",
        "id": 248619057,
        "sender_full_name": "Lokathor",
        "timestamp": 1628260681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think that interpretation of unions is a major question for discussion.</p>",
        "id": 248632117,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628266599
    },
    {
        "content": "<p>There was a large discussion about union semantics at the last Rust all-hands, the outcome of which did settle one question: unions are a bag of bits that may have any value, including values not valid for any of the variants, and that's allowed as long as you don't read any of the variants.</p>",
        "id": 248632262,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628266676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248632117\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I think that interpretation of unions is a major question for discussion.</p>\n</blockquote>\n<p>yeah I guess so. ;) I hope to finally write down the framework that would allow us to have this discussion in a more precise way...</p>",
        "id": 248632318,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266688
    },
    {
        "content": "<p>That discussion at the all-hands didn't settle the issue of uninitialized unions, and I don't recall anyone at the meeting bringing up the compiler-oriented notion of \"uninitialized\" being different from any actual value of the bits in memory.</p>",
        "id": 248632442,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628266769
    },
    {
        "content": "<p>But in any case, without settling that question, I think it's still reasonable to say that union field reads may be safe under some circumstances, and that shouldn't be incompatible with either answer regarding uninitialized unions, if we say that the responsibility to avoid undefined behavior lies with whoever leaves a union uninitialized and lets some other safe code think it can read from it.</p>",
        "id": 248632650,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628266880
    },
    {
        "content": "<p>To the best of my knowledge, even if a union can be uninitialized, you can't create an uninitialized union that other code thinks is initialized (and thus thinks it can read from) without unsafe code. So we could say that that unsafe code is responsible for avoiding undefined behavior.</p>",
        "id": 248632777,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628266930
    },
    {
        "content": "<p>Does that seem potentially reasonable?</p>",
        "id": 248632795,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628266940
    },
    {
        "content": "<p>you are basically suggesting what <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> did, to make this a safety invariant</p>",
        "id": 248632823,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266954
    },
    {
        "content": "<p>I dont like putting a safety invariant on user-defined unions, but I agree that this could be done</p>",
        "id": 248632869,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266974
    },
    {
        "content": "<p>can safety invariants be weakened by user code? That would let you write unsound functions using only safe code, although since it's a user safety invariant this is arguably not the language's problem</p>",
        "id": 248633131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267069
    },
    {
        "content": "<p>(i.e. if you wanted a bag-of-bits union and put a safety invariant that says it can be uninit, even though it is implemented with a rust <code>union</code> which has a safety invariant disallowing uninit, under Josh's proposal)</p>",
        "id": 248633303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267138
    },
    {
        "content": "<p>safety invariants cannot in general be weakened because you don't know what unsafe code is relying on them to create a safe API.</p>",
        "id": 248633398,
        "sender_full_name": "Lokathor",
        "timestamp": 1628267166
    },
    {
        "content": "<p>If it is a user API over a rust builtin that seems to be less of a concern - you only have to worry about things the compiler is doing, which in this case means you have to audit code not marked <code>unsafe</code> as though it was</p>",
        "id": 248633566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267239
    },
    {
        "content": "<p>If you want uninit, MaybeUninit would continue to exist, and the way it's currently implemented internally in the compiler wouldn't even allow safe field reads because it's a <code>union{(),T}</code>, so saying \"when fields match it becomes safe\" doesn't affect that since () doesn't match with T. even if it matches with a monomorph of T because T is a ZST, that's actually still \"fine\" since the read is a read of 0 bytes.</p>",
        "id": 248633762,
        "sender_full_name": "Lokathor",
        "timestamp": 1628267314
    },
    {
        "content": "<p>what about <code>MaybeUninit&lt;()&gt;</code>?</p>",
        "id": 248633825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248633131\">said</a>:</p>\n<blockquote>\n<p>can safety invariants be weakened by user code? That would let you write unsound functions using only safe code, although since it's a user safety invariant this is arguably not the language's problem</p>\n</blockquote>\n<p>weakened compared to what?</p>",
        "id": 248633923,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267393
    },
    {
        "content": "<p>then what i just said applies, you can read out a () but that's fine because you're reading 0 bytes so none of the bytes read are uninit</p>",
        "id": 248633926,
        "sender_full_name": "Lokathor",
        "timestamp": 1628267394
    },
    {
        "content": "<p>in principle it is possible to have a safety invariant on a private field that is weaker than what the type of the field would dictate. I'd usually advise against it though...</p>",
        "id": 248634016,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> what do you think of an opt-in repr modifier</p>",
        "id": 248634074,
        "sender_full_name": "Lokathor",
        "timestamp": 1628267440
    },
    {
        "content": "<p><code>repr</code> doesnt feel like the right hammer to me</p>",
        "id": 248634107,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> For example, suppose someone made a wrapper around <code>str</code> to <code>NotUtf8</code> which acts the same as <code>[u8]</code>. As long as they expose the right API that seems like it could be done (although in this particular case it would be dumb since <code>[u8]</code> already exists)</p>",
        "id": 248634174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267484
    },
    {
        "content": "<p>but yeah some kind of opt-in from the type author to make explicit this part of their safety invariant would help I think</p>",
        "id": 248634187,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248634174\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> For example, suppose someone made a wrapper around <code>str</code> to <code>NotUtf8</code> which acts the same as <code>[u8]</code>. As long as they expose the right API that seems like it could be done (although in this particular case it would be dumb since <code>[u8]</code> already exists)</p>\n</blockquote>\n<p>yes exactly</p>",
        "id": 248634206,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267502
    },
    {
        "content": "<p>it can be done but it's usually not a good idea</p>",
        "id": 248634230,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267513
    },
    {
        "content": "<p>I think the reverse is <em>much</em> better: the default should be the weak contract and a user API can put the stronger invariant on top</p>",
        "id": 248634307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267534
    },
    {
        "content": "<p><code>Ref</code> and <code>RefMut</code> do this, btw... the lifetime they use on their ptr to the RefCell content is too long. And indeed this actually leads to a soundness problem...</p>",
        "id": 248634325,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267545
    },
    {
        "content": "<p>(<a href=\"https://github.com/rust-lang/rust/issues/63787\">https://github.com/rust-lang/rust/issues/63787</a>)</p>",
        "id": 248634369,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267564
    },
    {
        "content": "<p>The <code>Transmutable&lt;A, B&gt;</code> type I mentioned does basically this for <code>union</code>: it's a union with the added safety invariant that the value is valid for one of the two types, so reads are safe</p>",
        "id": 248634496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267616
    },
    {
        "content": "<p>Is the main argument against it that it lacks language sugar?</p>",
        "id": 248634533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267634
    },
    {
        "content": "<p>yeah</p>",
        "id": 248634548,
        "sender_full_name": "Lokathor",
        "timestamp": 1628267641
    },
    {
        "content": "<p>the point is safe union field reads. any design path that doesn't get there is thus missing the goal.</p>",
        "id": 248634729,
        "sender_full_name": "Lokathor",
        "timestamp": 1628267711
    },
    {
        "content": "<p>does it have to be <code>union</code> specifically? i.e. (straw-man proposal) if there was <code>safe_union</code> that had the same syntax but acted like <code>Transmutable</code> then that would solve the problem</p>",
        "id": 248634944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267792
    },
    {
        "content": "<p>an attribute could probably work (probably not <code>repr</code> since it's not changing the repr)</p>",
        "id": 248635100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628267864
    },
    {
        "content": "<p>With box_patterns you can safely destructure a Box in a way that looks a lot like dereferencing a null pointer: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=7d083001d68c11d606930f627b0bcd3b\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=7d083001d68c11d606930f627b0bcd3b</a></p>",
        "id": 248636694,
        "sender_full_name": "Smittyvb",
        "timestamp": 1628268589
    },
    {
        "content": "<p>Yeah, unions with reference fields is very dangerous indeed.</p>",
        "id": 248640211,
        "sender_full_name": "Lokathor",
        "timestamp": 1628270049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"317035\">Smittyvb</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248636694\">said</a>:</p>\n<blockquote>\n<p>With box_patterns you can safely destructure a Box in a way that looks a lot like dereferencing a null pointer: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=7d083001d68c11d606930f627b0bcd3b\">https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=7d083001d68c11d606930f627b0bcd3b</a></p>\n</blockquote>\n<p>“looks a lot like”, but not doing so in actuality, at least not according to Miri. Here’s a variant (similar to something I wrote earlier in this topic) that actually <em>is</em> doing such a dereference (and Miri flags it as being UB):<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a8c41f39db4143676f9140d17ca09285\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a8c41f39db4143676f9140d17ca09285</a></p>",
        "id": 248666557,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628282923
    },
    {
        "content": "<p><del>oh sorry, need to update that link</del> (corrected now)</p>",
        "id": 248666663,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628282984
    },
    {
        "content": "<p>I wonder whether to fix this issue it would suffice to say that a pattern match on a unit struct or enum with one variant counts as a read of the place, inserting a fake read if necessary.  That means that <code>let _ = *ptr;</code> is a no-op but <code>let () = *ptr;</code> \"reads the pointer\" and so is unsafe (although it is still a no-op)</p>",
        "id": 248668872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628284200
    },
    {
        "content": "<p>That sounds potentially reasonable.</p>",
        "id": 248669662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1628284574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/union.20field.20semantics.20and.20safety/near/248668872\">said</a>:</p>\n<blockquote>\n<p>I wonder whether to fix this issue it would suffice to say that a pattern match on a unit struct or enum with one variant counts as a read of the place, inserting a fake read if necessary.  That means that <code>let _ = *ptr;</code> is a no-op but <code>let () = *ptr;</code> \"reads the pointer\" and so is unsafe (although it is still a no-op)</p>\n</blockquote>\n<p>This reminds me of <a href=\"https://github.com/rust-lang/rust/issues/80059\">https://github.com/rust-lang/rust/issues/80059</a></p>",
        "id": 249754181,
        "sender_full_name": "scottmcm",
        "timestamp": 1629222733
    }
]