[
    {
        "content": "<p>Our <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from\">offset_from</a> on pointers has the requirement that</p>\n<blockquote>\n<p>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object.</p>\n</blockquote>\n<p>However, this unfortunately forbids code like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">start_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">end_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">start_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">end_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">offset_from</span><span class=\"p\">(</span><span class=\"n\">start_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>end_ptr and start_ptr point \"to the same allocation\" (in the sense that their provenance is for the same allocation), but end_ptr is not in-bounds of that allocation.<br>\nThere is not really any good reason to forbid such code AFAIK -- the codegen implementation is certainly fine with this, and Miri actually forgets to check the in-bounds part of the condition...</p>\n<p>Also, this is actually a problem for code such as iterators that want to support ZST -- they usually use out-of-bounds ptrs like the above to represent the current state of the iterator, and so they cannot use offset_from to compute the size. \"normal\" code just casts to integer and does the subtraction there, but that is not an option for <code>const fn</code>. (that came up in <a href=\"https://github.com/slightlyoutofphase/staticvec/issues/48\">this issue</a>.)</p>\n<p>So... I think it would make sense to remove the \"in-bounds\" part of the condition. both pointers still need to \"point to the same allocation\" in the sense that they have the same provenance, but out-of-bounds ptrs computed with wrapping_offset should be fine IMO.<br>\nAny thoughts?</p>",
        "id": 265914345,
        "sender_full_name": "RalfJ",
        "timestamp": 1640264577
    },
    {
        "content": "<p>Are there any actual cases where in bounds or one byte past in documentation doesn't really just mean \"same provenance\"?</p>",
        "id": 265930448,
        "sender_full_name": "nagisa",
        "timestamp": 1640276193
    },
    {
        "content": "<p>slicing?</p>",
        "id": 265930944,
        "sender_full_name": "The 8472",
        "timestamp": 1640276566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/265930448\">said</a>:</p>\n<blockquote>\n<p>Are there any actual cases where in bounds or one byte past in documentation doesn't really just mean \"same provenance\"?</p>\n</blockquote>\n<p>yes, <code>offset</code> (as opposed to <code>wrapping_offset</code>)</p>",
        "id": 265931068,
        "sender_full_name": "RalfJ",
        "timestamp": 1640276645
    },
    {
        "content": "<p>...huh, how does runtime computation of an iterator position in a ZST array with greater than u16::MAX items work on a \"usize is u16\" platform?</p>",
        "id": 265964594,
        "sender_full_name": "Jubilee",
        "timestamp": 1640304293
    },
    {
        "content": "<p>On a usize is u16 platform an array can't have more than u16::MAX elements? And it's not an issue yet because slice iterators aren't const and therefore can use pointer to integer casts.</p>",
        "id": 265970420,
        "sender_full_name": "The 8472",
        "timestamp": 1640311576
    },
    {
        "content": "<p>yeah, ZST arrays are limited to <code>usize::MAX</code> elements (on all platforms)</p>",
        "id": 265994478,
        "sender_full_name": "RalfJ",
        "timestamp": 1640343624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/265970420\">said</a>:</p>\n<blockquote>\n<p>On a usize is u16 platform an array can't have more than u16::MAX elements? And it's not an issue yet because slice iterators aren't const and therefore can use pointer to integer casts.</p>\n</blockquote>\n<p>oh right.</p>",
        "id": 266033759,
        "sender_full_name": "Jubilee",
        "timestamp": 1640393803
    },
    {
        "content": "<p>So, I remember that there is no <code>wrapping_offset_from</code>, since the <code>wrapping_offset</code> operation is already a big footgun, and so it was deemed that having the callers go through the integer realm shenanigans was maybe more honest not to warrant the wrapping_offset_from operation.</p>\n<p>But if the integer shenanigans can't be used in a <code>const</code> context, then that reasoning does not apply anymore. I'd thus advocate for the addition of a <code>wrapping_offset_from</code> operation, rather than loosening <code>offset_from</code>, just for the sake of consistency / symmetry with with the <em>adding</em> variants</p>",
        "id": 266056749,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640434137
    },
    {
        "content": "<p>OTOH, wrapping_offset_from and offset_from would generate the same code under all our current backends.<br>\nalso unlike the <code>add</code> methods they would both be unsafe.</p>",
        "id": 266059119,
        "sender_full_name": "RalfJ",
        "timestamp": 1640438333
    },
    {
        "content": "<p>the footgun argument IMO does not apply equally -- what makes wrapping_offset tricky is understanding what you can do with the resulting pointer, but this method here just returns an integer</p>",
        "id": 266059151,
        "sender_full_name": "RalfJ",
        "timestamp": 1640438402
    },
    {
        "content": "<blockquote>\n<p>So, I remember that there is no wrapping_offset_from, since the wrapping_offset operation is already a big footgun, and so it was deemed that having the callers go through the integer realm shenanigans was maybe more honest not to warrant the wrapping_offset_from operation.</p>\n</blockquote>\n<p>I tried to reconstruct the history of this but found no such discussion.  the doc comment seemed to just require \"in-bounds of the same allocation\" from the beginning without much consideration of alternatives. back then this was still implemented in pure Rust via integer casts; it became an intrinsic later to add <code>const</code> support.</p>",
        "id": 266059192,
        "sender_full_name": "RalfJ",
        "timestamp": 1640438466
    },
    {
        "content": "<p>Would this cause any problems with getelementpointer inbounds in LLVM?</p>",
        "id": 266072263,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640460641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/266059119\">said</a>:</p>\n<blockquote>\n<p>also unlike the <code>add</code> methods they would both be unsafe.</p>\n</blockquote>\n<p>Oh, that's a good point, which breaks my \"sake of consistency\" argument. I withdraw my advocating for a <code>wrapping_offset_from</code> <em>for your intended use case</em>, since it can't be made non-<code>unsafe</code>.</p>\n<blockquote>\n<p>reconstruct the history</p>\n</blockquote>\n<p>Thanks to a post from <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> on URLO (<a href=\"https://users.rust-lang.org/t/what-is-the-difference-between-ptr-offset-and-ptr-wrapping-offset/68083/6?u=yandros\">link</a>), I had stumbled upon <em>deprecate <code>wrapping_offset_from</code></em>, which you obviously know since you authored it <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>: <a href=\"https://github.com/rust-lang/rust/pull/73580\">https://github.com/rust-lang/rust/pull/73580</a></p>\n<ul>\n<li>It links to <a href=\"https://github.com/rust-lang/rust/issues/41079#issuecomment-433140733\">https://github.com/rust-lang/rust/issues/41079#issuecomment-433140733</a> (cc <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span>)</li>\n</ul>",
        "id": 266107288,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640521224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/266072263\">said</a>:</p>\n<blockquote>\n<p>Would this cause any problems with getelementpointer inbounds in LLVM?</p>\n</blockquote>\n<p>no, this is not using GEP.<br>\nLLVM might get a <code>psub</code> operation some day to do pointer subtraction, and in the form that <a href=\"https://www.ralfj.de/research/twinsem/twinsem.pdf\">we proposed</a> it would be the \"wrapping\" variant. I imagine if there is interest in an inbounds version of that we'd have <code>psub inbounds</code>, similar to GEP.</p>",
        "id": 266186186,
        "sender_full_name": "RalfJ",
        "timestamp": 1640623424
    },
    {
        "content": "<p>yeah there used to be a safe <code>wrapping_offset_from</code> but it never got stabilized</p>",
        "id": 266186256,
        "sender_full_name": "RalfJ",
        "timestamp": 1640623466
    },
    {
        "content": "<p>I'd note that lccc has a <code>sub</code> operation between pointers, that (necessarily, because constant evaluation can be aborted by it) has the same UB as C/++, and thus Rust's <code>.offset_from</code>. Without the inbounds constraint, it would need to be implemented via casts to integers.</p>",
        "id": 266190682,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640626878
    },
    {
        "content": "<blockquote>\n<p>has the same UB as C/++</p>\n</blockquote>\n<p>C/C++ do not even allow creating out-of-bounds ptrs, so the question we are discussing here cannot arise there</p>",
        "id": 266363360,
        "sender_full_name": "RalfJ",
        "timestamp": 1640799179
    },
    {
        "content": "<p>It does, actually. Dangling pointers are out-of-bounds.</p>",
        "id": 266370470,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640804771
    },
    {
        "content": "<p>(and also, the two pointers can be mutually out-of-bounds of each other, which is UB for both pointer subtraction in C/++, and <code>offset_from</code>)</p>",
        "id": 266370509,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640804807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/266370470\">said</a>:</p>\n<blockquote>\n<p>It does, actually. Dangling pointers are out-of-bounds.</p>\n</blockquote>\n<p>and they are also indeterminate values (\"lifetime end zapping\"), so basically equivalent to uninit memory -- so that's not really helpful for this discussion either, I think? even comparing them for equality is UB (at least in C, I know less about C++)</p>",
        "id": 266373993,
        "sender_full_name": "RalfJ",
        "timestamp": 1640807801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/266370509\">said</a>:</p>\n<blockquote>\n<p>(and also, the two pointers can be mutually out-of-bounds of each other, which is UB for both pointer subtraction in C/++, and <code>offset_from</code>)</p>\n</blockquote>\n<p>yes and it would still be UB with my proposal. quoting from my OP here:</p>\n<blockquote>\n<p>both pointers still need to \"point to the same allocation\" in the sense that they have the same provenance</p>\n</blockquote>",
        "id": 266374015,
        "sender_full_name": "RalfJ",
        "timestamp": 1640807840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/266373993\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/offset_from.20in-bounds.20constraint.3F/near/266370470\">said</a>:</p>\n<blockquote>\n<p>It does, actually. Dangling pointers are out-of-bounds.</p>\n</blockquote>\n<p>and they are also indeterminate values (\"lifetime end zapping\"), so basically equivalent to uninit memory -- so that's not really helpful for this discussion either, I think? even comparing them for equality is UB (at least in C, I know less about C++)</p>\n</blockquote>\n<p>Not exactly. Just indeterminate pointers. Still initialized values, but you can't do anything with them (other than destroy them).</p>",
        "id": 266374134,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640807985
    },
    {
        "content": "<p>not sure how that is functionally different from an indeterminate value, but sure.^^<br>\neither way, the distinction between the current offset_from and the one I am proposing is not observable in C/C++.</p>",
        "id": 266380422,
        "sender_full_name": "RalfJ",
        "timestamp": 1640813429
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/92512\">https://github.com/rust-lang/rust/issues/92512</a> suggests that it stays UB to use oob pointers, but I don't see anything in the discussion here actually requiring this. Can someone explain why we need oob pointers to be UB?</p>",
        "id": 266674968,
        "sender_full_name": "oli",
        "timestamp": 1641208419
    },
    {
        "content": "<p>I was about to link to <a href=\"https://github.com/rust-lang/rust/issues/92512\">https://github.com/rust-lang/rust/issues/92512</a> :)</p>",
        "id": 266733609,
        "sender_full_name": "RalfJ",
        "timestamp": 1641242028
    },
    {
        "content": "<blockquote>\n<p>suggests that it stays UB to use oob pointers</p>\n</blockquote>\n<p>Not sure what you mean -- the issue says that <em>currently</em>, it is UB to use oob pointers.</p>",
        "id": 266733669,
        "sender_full_name": "RalfJ",
        "timestamp": 1641242054
    },
    {
        "content": "<p>one way to fix the issue would be to allow oob pointers as long as they have the same provenance (\"are derived from the same pointer\")</p>",
        "id": 266733705,
        "sender_full_name": "RalfJ",
        "timestamp": 1641242083
    },
    {
        "content": "<p>I dont know why the oob requirement is present; it existed already in the initial PR that added the method -- where the implementation used <code>as usize</code>. so from the start the implementation was a lot more permissive than the docs.</p>",
        "id": 266733757,
        "sender_full_name": "RalfJ",
        "timestamp": 1641242133
    }
]