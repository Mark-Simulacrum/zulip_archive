[
    {
        "content": "<p>Splitting this out:</p>",
        "id": 265842026,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200751
    },
    {
        "content": "<p>It's painful <em>in general</em> to use a <code>DifferentAlloc</code>.</p>",
        "id": 265842034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200762
    },
    {
        "content": "<p>People embed <code>Vec&lt;T&gt;</code> in their structs, and we don't necessarily want to make every <code>struct</code> start taking an <code>A</code> parameter. Or do we?</p>",
        "id": 265842077,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200789
    },
    {
        "content": "<p>How can we make this substantially easier, in general?</p>",
        "id": 265842139,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200805
    },
    {
        "content": "<p>And then that would potentially make <code>StaticAlloc</code> viable for const contexts.</p>",
        "id": 265842151,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use/near/265842139\">said</a>:</p>\n<blockquote>\n<p>How can we make this substantially easier, in general?</p>\n</blockquote>\n<p>automatically add a trailing <code>A: Allocator = GlobalAlloc</code> bound to all types that use a type with a generic parameter of <code>Allocator</code> type? XD</p>",
        "id": 265842349,
        "sender_full_name": "oli",
        "timestamp": 1640200938
    },
    {
        "content": "<p>While I don't think I'd want to handle it <em>quite</em> that way, the idea of having \"magic generic parameters\" like that seems potentially useful.</p>",
        "id": 265842411,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200990
    },
    {
        "content": "<p>In particular, allocation context could be an \"ambient generic parameter\" that's automatically present everywhere, but can be overridden <em>if</em> you want a specific different allocator.</p>",
        "id": 265842537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201070
    },
    {
        "content": "<p>Except that right now, it's currently valid for people to write <code>Vec&lt;u32&gt;</code> and <em>rely</em> on that using <code>GlobalAlloc</code>.</p>",
        "id": 265842576,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201106
    },
    {
        "content": "<p>(e.g. if their <code>GlobalAlloc</code> had some kind of object tracking involved, it'd be valid for an object holding a <code>Vec&lt;u32&gt;</code> to look up the vector in their tracking allocator and scream if it isn't there.)</p>",
        "id": 265842634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201142
    },
    {
        "content": "<p>So, I think you'd need to specify \"I can handle a Vec of any allocator\", <em>but</em> you wouldn't need to propagate the allocator as a type parameter of your own.</p>",
        "id": 265842710,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201180
    },
    {
        "content": "<p><code>struct S { v: Vec&lt;u32, ?allocbikeshed&gt; }</code></p>",
        "id": 265842761,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201214
    },
    {
        "content": "<p><code>let diff_s = S&lt;?allocbikeshed = DifferentAlloc&gt;;</code></p>",
        "id": 265842868,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201279
    },
    {
        "content": "<p>That's a lot of magic, though.</p>",
        "id": 265843347,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201533
    },
    {
        "content": "<p>whatever the \"magic generic parameters\" solution is, I would imagine it would be something that could be generalized to cover lifetimes too.</p>",
        "id": 265843663,
        "sender_full_name": "pnkfelix",
        "timestamp": 1640201729
    },
    {
        "content": "<p><a href=\"https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/\">\"Contexts and capabilities\" proposal</a> might give some help here, if it makes its way into the language.</p>",
        "id": 265878255,
        "sender_full_name": "Charles Lew",
        "timestamp": 1640228154
    },
    {
        "content": "<p>re: allowing overriding Allocator even if not specified, this sounds vaguely like how Scala allows locally overriding implicit params.</p>",
        "id": 265964810,
        "sender_full_name": "Jubilee",
        "timestamp": 1640304518
    },
    {
        "content": "<p>I've thought a polymorphic solution would be good, but it can't be SmartPtr&lt;dyn Allocator&gt; — since that (pretty much) inherently requires allocation itself. I've sketched out a few designs for something like <a href=\"https://doc.rust-lang.org/nightly/std/task/struct.RawWakerVTable.html\">https://doc.rust-lang.org/nightly/std/task/struct.RawWakerVTable.html</a> (which allows polymorphism without forcing allocations) but never got that far with it — part of my lack of motivation here is that the allocator-wg seems to have no energy for changes anymore.</p>",
        "id": 266016739,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1640369743
    },
    {
        "content": "<p>However, the solution obviously needs to support generic allocators as well — it's just not clear that's the right way forward. most of the time (admittedly not always) the overhead you save by specifying the allocator statically is fairly minor.</p>\n<p>And there are very many times where you cannot insert a generic parameter (methods on object-safe traits, for example).</p>",
        "id": 266017306,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1640370458
    },
    {
        "content": "<p>I really don't like implicit params. I feel that the complexity it adds to code readers will outweight any benefits it provides.</p>",
        "id": 267272672,
        "sender_full_name": "Gary Guo",
        "timestamp": 1641613304
    },
    {
        "content": "<p>I'm pretty sure it's an improvement over explicit parameters for this case.</p>",
        "id": 267279056,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1641622144
    },
    {
        "content": "<p>I still can't help but feel that maybe generics are the wrong tool for this. But I don't know what the right tool is, and everyone who knows anything seems to think that they are in fact the right tool.</p>",
        "id": 267279066,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1641622197
    },
    {
        "content": "<p>I'm not sure they're the right tool, but I also don't know anything.</p>",
        "id": 267280024,
        "sender_full_name": "Lokathor",
        "timestamp": 1641623944
    },
    {
        "content": "<p>I don't know that implicit parameters are an improvement over explicit parameters, especially since you can write <code>&lt;A: Allocator = Global&gt;</code>, so downstream code gets the same interface in the default case. There really isn't a benefit here, at least not one that I can see, and I agree with<br>\n<span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use/near/267272672\">said</a>:</p>\n<blockquote>\n<p>I really don't like implicit params. I feel that the complexity it adds to code readers will outweight any benefits it provides.</p>\n</blockquote>\n<p>that it adds complexity for readers and maintainers.</p>",
        "id": 267281814,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641626990
    },
    {
        "content": "<p>I really would like to see a POC of allocation using the \"with\" clauses (<a href=\"https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/\">https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/</a>). I could imagine that allocators could be \"special\" in that there is the default Global allocation, but can be overwritten.</p>\n<p>Though, I'm not sure how you could handle allocating using multiple different allocators simultaneously.</p>",
        "id": 267297215,
        "sender_full_name": "Jack Huey",
        "timestamp": 1641650268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use/near/267297215\">said</a>:</p>\n<blockquote>\n<p>I really would like to see a POC of allocation using the \"with\" clauses (<a href=\"https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/\">https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/</a>). I could imagine that allocators could be \"special\" in that there is the default Global allocation, but can be overwritten.</p>\n<p>Though, I'm not sure how you could handle allocating using multiple different allocators simultaneously.</p>\n</blockquote>\n<p>The issue with that (other than the implementation, which seems <em>fun</em> without TLS) is you'd need a way (as above) for individual types to opt-in to the context allocator (and use Global instead, even if forcibly overriden by users). Also, it would be unsound if it's possible for values to leave the allocation context, or be moved into a different allocation context, because the destructor would have to deallocate using the context allocator or the default allocator (either that, or at least <code>Box&lt;T&gt;</code> would be unable to opt-in, even if the user does, as it's stabily abi compatible with <code>*mut T</code>).</p>",
        "id": 267298060,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641651547
    },
    {
        "content": "<p>last i heard the current design proposal is that only Box&lt;T, GlobalAlloc&gt; is kept as absolutely a single pointer, but a box from non-ZST allocators can be bigger than a single pointer.</p>",
        "id": 267304800,
        "sender_full_name": "Lokathor",
        "timestamp": 1641661092
    },
    {
        "content": "<p>Indeed, which is why I noted <code>Box&lt;T&gt;</code> specifically.</p>",
        "id": 267310820,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641669513
    },
    {
        "content": "<p>Then i don't understand, wouldn't the context force the type to be <code>Box&lt;T, ContextAlloc&gt;</code>?</p>",
        "id": 267311097,
        "sender_full_name": "Lokathor",
        "timestamp": 1641669915
    },
    {
        "content": "<p>Depends on if the context is compile time, or runtime.</p>",
        "id": 267311447,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641670492
    },
    {
        "content": "<p>And how the context propagates (could it affect Box&lt;T&gt; in callee code?)</p>",
        "id": 267311463,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641670532
    }
]