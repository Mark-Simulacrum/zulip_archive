[
    {
        "content": "<p>Hey folks. So I've gotten pretty interested in trying to push impl Trait through to stability. I think it's crucial for async code, for one thing, but it's also pretty squarely in the Rust roadmap mandate of \"finishing up unfinishing things\".</p>\n<p>I've spend a number of hours today preparing notes. They're not yet in a form that can be consumed by the public, but I will try to arrange them better. I want to propose that we use an upcoming design meeting for this topic -- perhaps May 20th? </p>\n<p>Things I am trying to ultimately pull together:</p>\n<ul>\n<li>Discrepancies between the implementation and what the RFCs said, and the reasons for them (and how we might resolve them).</li>\n<li>Lingering unspecified details to be resolved.</li>\n<li>Stabilization \"schedule\" -- what should be stabilized and when?</li>\n</ul>\n<p>I think the meeting would probably focus on the first two, plus perhaps some amount of \"review\".</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> <span class=\"user-mention\" data-user-id=\"256759\">@boats</span> , folks who I know have had a lot of interest in <code>impl Trait</code> in the past.</p>",
        "id": 196956577,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976090
    },
    {
        "content": "<p>If you're glutton for punishment, my notes are in <a href=\"https://github.com/nikomatsakis/lang-team/blob/impl-trait-everywhere/src/design_notes/impl_trait_everywhere.md\" title=\"https://github.com/nikomatsakis/lang-team/blob/impl-trait-everywhere/src/design_notes/impl_trait_everywhere.md\">this file</a> -- the section on \"philosophy\" however didn't quite work out as beautifully as I hoped and has some unfinished ramblings for me to reconcile. =) Though I still think the core idea is reasonable.</p>",
        "id": 196956799,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976224
    },
    {
        "content": "<p>(I would probably enjoy some \"pre-design meeting\" discussion too.)</p>",
        "id": 196957159,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976485
    },
    {
        "content": "<p>I am interested in discussing this, but I'll need to refresh my memory on the whole topic; I'll try to do so over the weekend.</p>",
        "id": 196957299,
        "sender_full_name": "varkor",
        "timestamp": 1588976596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Thank you for the <em>detailed</em> example showing everywhere it might make sense.</p>",
        "id": 196957312,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976612
    },
    {
        "content": "<p>it's missing a case or two still, notably structs</p>",
        "id": 196957341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976641
    },
    {
        "content": "<p>Do \"where clause position\" and \"associated type binding position\" remain identical when used in trait methods?</p>",
        "id": 196957459,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976703
    },
    {
        "content": "<p>Or does there need to be a \"trait method where clause position\" and similar?</p>",
        "id": 196957470,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976714
    },
    {
        "content": "<p>Also, the example right up at the top that you called \"named\" might benefit from an \"also known as 'type alias'\".</p>",
        "id": 196957511,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976752
    },
    {
        "content": "<p>Another few cases, which may be identical to existing cases:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">closure_arg</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196957606,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976813
    },
    {
        "content": "<p>I believe so, but i'm going to add to the cod for now to remind me to think more about it</p>",
        "id": 196957609,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976818
    },
    {
        "content": "<p>notably I think it's not entirely clear the precise circumstances in which <code>impl Trait</code> should be permitted in where causes (I think it largely should not, except for in associated type binding positions)</p>",
        "id": 196957645,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976865
    },
    {
        "content": "<p>Interesting. Why is the one you labeled \"where clause position\" not something you'd want to support?</p>",
        "id": 196957737,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976930
    },
    {
        "content": "<p>It seems generally useful.</p>",
        "id": 196957743,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976935
    },
    {
        "content": "<p>because the obvious interpretation to me creates an unconstrained type parameter</p>",
        "id": 196957770,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976966
    },
    {
        "content": "<p>and you have no way to specify its value</p>",
        "id": 196957776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976970
    },
    {
        "content": "<p>that said, there are other plausible interpretations</p>",
        "id": 196957800,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588976991
    },
    {
        "content": "<p>What do you mean by \"unconstrained type parameter\"?</p>",
        "id": 196957801,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588976991
    },
    {
        "content": "<p>consider </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"kt\">u32</span>: <span class=\"nb\">PartialOrd</span><span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196957863,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977016
    },
    {
        "content": "<p>I believe that probably \"wants to\" desugar to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"kt\">u32</span>: <span class=\"nb\">PartialOrd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196957879,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977038
    },
    {
        "content": "<p>but what is this <code>T</code>?</p>",
        "id": 196957900,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977051
    },
    {
        "content": "<p>That doesn't seem like the right desugar.</p>",
        "id": 196957915,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977060
    },
    {
        "content": "<p>in the latter case, the user can specify, but in the former case, they cannot, and there are many types that <code>u32</code> can be ordered with</p>",
        "id": 196957925,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977065
    },
    {
        "content": "<p>that is one possible interpretation, yes, another plausible desugar is</p>",
        "id": 196957934,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977071
    },
    {
        "content": "<p>It should desugar to:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"kt\">u32</span>: <span class=\"nb\">PartialOrd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Debug</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196957952,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977078
    },
    {
        "content": "<p>oh, that's not the imp't debug though, but that's true</p>",
        "id": 196957973,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977087
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"kt\">u32</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Debug</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">PartialOrd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196957981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977098
    },
    {
        "content": "<p>that would be another plausible desugar</p>",
        "id": 196957984,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977103
    },
    {
        "content": "<p>Oh, I see.</p>",
        "id": 196957987,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977109
    },
    {
        "content": "<p>we don't yet support that notation, but we have to and will soon enough</p>",
        "id": 196957988,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977111
    },
    {
        "content": "<p>for GATs</p>",
        "id": 196957989,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977112
    },
    {
        "content": "<p><em>that</em> interpretation does make sense</p>",
        "id": 196958033,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977123
    },
    {
        "content": "<p>this is (imo) related to <code>'_</code> notation</p>",
        "id": 196958037,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977128
    },
    {
        "content": "<p>So the question is, does this desugar to \"you must accept any Debug\" or \"the call must be for a specific Debug\"?</p>",
        "id": 196958048,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977134
    },
    {
        "content": "<p>right now we don't I don't think accept</p>",
        "id": 196958049,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977135
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Blah</span><span class=\"o\">&lt;</span><span class=\"nb\">&#39;_</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196958060,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977142
    },
    {
        "content": "<p>but I think if we it should introduce a region in the same place as the <code>T</code> above, whatever we decided :)</p>",
        "id": 196958067,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977155
    },
    {
        "content": "<p>I understand now.</p>",
        "id": 196958083,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977170
    },
    {
        "content": "<p>I gotta go now, dinner time and end of day here</p>",
        "id": 196958095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977177
    },
    {
        "content": "<p>The specific case where I'd imagine using it would be for a specific impl, but this seems like an absolutely reasonable distinction. And if you already have a where clause, it's not that bad to have to extend it.</p>",
        "id": 196958135,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977208
    },
    {
        "content": "<p>(I'm still reviewing the rustc impl code, that's the major to do I have left, plus to wrestle with my framing of things as scopes and see if I can make it make sense :)</p>",
        "id": 196958141,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588977211
    },
    {
        "content": "<p>Thanks for all this work!</p>",
        "id": 196958142,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588977212
    },
    {
        "content": "<p>I think <code>Named</code> should be <code>Type alias</code> and <code>Associated type value position</code> should be <code>Associated type (alias)</code>, which are the terms that have been previously used (at least informally).</p>",
        "id": 196987909,
        "sender_full_name": "varkor",
        "timestamp": 1589024900
    },
    {
        "content": "<p><code>impl Trait for impl Type { }</code> â€” is this added just to have a name to refer to? This is not being considered?</p>",
        "id": 196987987,
        "sender_full_name": "varkor",
        "timestamp": 1589025008
    },
    {
        "content": "<p>I think several of these positions behave identically, but that seems to be intentional for now.</p>",
        "id": 196988104,
        "sender_full_name": "varkor",
        "timestamp": 1589025181
    },
    {
        "content": "<p>Re.</p>\n<blockquote>\n<p>Use the natural interpretation to guide the choice.</p>\n</blockquote>\n<p>I think if the choice is at all ambiguous, it should be disallowed. This feeds into the point about \"It may be that the interpretation is not clear for readers\", though it's slightly stronger.</p>",
        "id": 196988391,
        "sender_full_name": "varkor",
        "timestamp": 1589025559
    },
    {
        "content": "<blockquote>\n<p>Existential types</p>\n</blockquote>\n<p>Also, let's not use this terminology: it's continually caused confusion in the past, because many people don't really understand what existential types are. We're using \"opaque type\" in the compiler, and that seems reasonable to use technically as well.</p>",
        "id": 196988460,
        "sender_full_name": "varkor",
        "timestamp": 1589025709
    },
    {
        "content": "<blockquote>\n<p>Existential type aliases cannot be used in impl blocks</p>\n</blockquote>\n<p>This would be slightly more readable as: \"It is not possible to <code>impl</code> methods for opaque types.\".</p>",
        "id": 196988538,
        "sender_full_name": "varkor",
        "timestamp": 1589025809
    },
    {
        "content": "<p>I think the general guidelines match with my intuition, though I need to think more carefully about the nesting <code>impl Trait</code>: it seems quite plausible that we would never want to permit this.</p>",
        "id": 196988729,
        "sender_full_name": "varkor",
        "timestamp": 1589026164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> <a href=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/196988460\" title=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/196988460\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Existential types</p>\n</blockquote>\n<p>Also, let's not use this terminology: it's continually caused confusion in the past, because many people don't really understand what existential types are. We're using \"opaque type\" in the compiler, and that seems reasonable to use technically as well.</p>\n</blockquote>\n<p>To clarify, I don't think \"universal/existential binders\" cause confusion, but referring to <code>impl Trait</code> as an existential type does.</p>",
        "id": 196988970,
        "sender_full_name": "varkor",
        "timestamp": 1589026538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> <a href=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/196988970\" title=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/196988970\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> <a href=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/196988460\" title=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/196988460\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Existential types</p>\n</blockquote>\n<p>Also, let's not use this terminology: it's continually caused confusion in the past, because many people don't really understand what existential types are. We're using \"opaque type\" in the compiler, and that seems reasonable to use technically as well.</p>\n</blockquote>\n<p>To clarify, I don't think \"universal/existential binders\" cause confusion, but referring to <code>impl Trait</code> as an existential type does.</p>\n</blockquote>\n<p>I think in the case of niko's notes it actually made a lot of sense, compared to previous attempts. The way return-position <code>impl Trait</code> is an existential within the forall of the next generic scope out perfectly captures the way that the actual type can depend on those generic parameters but not the function's value-level parameters.</p>",
        "id": 197000962,
        "sender_full_name": "rpjohnst",
        "timestamp": 1589043599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> are you around by any chance?</p>",
        "id": 198212935,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589987636
    },
    {
        "content": "<p>I am now...</p>",
        "id": 198221157,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1589991078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> I was going to ask some questions about the impl Trait code but I think I figured out enough for the time being.</p>",
        "id": 198224933,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589992883
    },
    {
        "content": "<p>Reminder <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> that we have a design meeting in 10 mnutes -- I forgot to update the calendar, but the planned topic was <a href=\"https://hackmd.io/w_xcaFmASEqzVMC3J2L8Dw?edit\">\"impl Trait everywhere\"</a>. <br>\nI'm currently preparing a <a href=\"https://hackmd.io/w_xcaFmASEqzVMC3J2L8Dw?edit\">hackmd</a> that I expect to use to drive the meeting.</p>",
        "id": 198226210,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589993473
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> design meeting is now =)</p>",
        "id": 198227525,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589994101
    },
    {
        "content": "<p>(computer and/or zoom is behaving weird; will try to rejoin in a sec)</p>",
        "id": 198228007,
        "sender_full_name": "pnkfelix",
        "timestamp": 1589994286
    },
    {
        "content": "<p>I just lost the meeting too</p>",
        "id": 198234246,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589997332
    },
    {
        "content": "<p>So i'm not sure if we should keep editing the hackmd or not, so i'll just say here, but <code>Foo::foo::return</code> could be a general \"phrase\" for accessing the return type of any method or function. It's not an \"expression\" since it resolves to a type instead of a value.</p>",
        "id": 198237256,
        "sender_full_name": "Lokathor",
        "timestamp": 1589998717
    },
    {
        "content": "<p>Would it be considered an inherent associated type?</p>",
        "id": 198291859,
        "sender_full_name": "isHavvy",
        "timestamp": 1590044346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I also wonder if somefunc::arg&lt;2&gt; would work as a phrase to access the second argument.</p>",
        "id": 198293472,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1590046114
    },
    {
        "content": "<p>Well, we'd need a keyword in place of arg...</p>",
        "id": 198293489,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1590046133
    },
    {
        "content": "<p>Maybe somefunc::2, since normally you'd need an identifier?</p>",
        "id": 198293534,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1590046174
    },
    {
        "content": "<p>yeah i hadn't thought that you'd need to name arg types too, but i guess it might come up</p>",
        "id": 198293622,
        "sender_full_name": "Lokathor",
        "timestamp": 1590046242
    },
    {
        "content": "<p>Or somefunc::fn&lt;2&gt; .</p>",
        "id": 198293688,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1590046305
    },
    {
        "content": "<p>there might be a limit to how much we can sanely reuse keywords XD</p>",
        "id": 198293808,
        "sender_full_name": "Lokathor",
        "timestamp": 1590046435
    },
    {
        "content": "<p>okay okay, if we need inputs and outputs, and also not to flood the possibility space of what the user has to read too much, we could do <code>somefunc::type&lt;N&gt;</code> to get the type of the Nth argument, or <code>somefunc::type&lt;return&gt;</code> for the type of the return value.</p>",
        "id": 198294397,
        "sender_full_name": "Lokathor",
        "timestamp": 1590047019
    },
    {
        "content": "<p><code>somefunc::in&lt;0&gt;</code></p>",
        "id": 198294581,
        "sender_full_name": "isHavvy",
        "timestamp": 1590047170
    },
    {
        "content": "<p>ooooh</p>",
        "id": 198295339,
        "sender_full_name": "Lokathor",
        "timestamp": 1590047937
    },
    {
        "content": "<p>The <code>::return</code> syntax seems kind of wordy to me</p>",
        "id": 198356237,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590084794
    },
    {
        "content": "<p>e.g., imagine you have </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Service</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">launch</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>then you would write</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">launch_service</span><span class=\"o\">&lt;</span><span class=\"n\">S</span>: <span class=\"nc\">Service</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>::<span class=\"n\">launch</span>::<span class=\"k\">return</span>: <span class=\"nb\">Send</span>\n</code></pre></div>",
        "id": 198356352,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590084847
    },
    {
        "content": "<p>vs </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">launch_service</span><span class=\"o\">&lt;</span><span class=\"n\">S</span>: <span class=\"nc\">Service</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>::<span class=\"n\">Launch</span>: <span class=\"nb\">Send</span>\n</code></pre></div>",
        "id": 198356396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590084879
    },
    {
        "content": "<p>or even <code>S::launch: Send</code></p>",
        "id": 198356439,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590084907
    },
    {
        "content": "<p>that said, another thing that would be useful is some way to say <em>all the async fns in this trait return Send futures</em> (or <em>all the <code>impl Future</code> ...</em>)</p>",
        "id": 198356519,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590084959
    },
    {
        "content": "<p>something like (to use <code>return</code> notation)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">S</span>::<span class=\"o\">*</span>::<span class=\"k\">return</span>: <span class=\"nb\">Send</span>\n</code></pre></div>\n\n\n<p>(not that I actually think I would want this syntax)</p>",
        "id": 198356603,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590084990
    },
    {
        "content": "<p><a href=\"https://github.com/cramertj/impl-trait-goals/blob/impl-trait-in-traits/0000-impl-trait-in-traits.md\">https://github.com/cramertj/impl-trait-goals/blob/impl-trait-in-traits/0000-impl-trait-in-traits.md</a> is the RFC that I had written for inferred associated types btw. It's quite old and outdated now, but it shows where my head was at one point in time.</p>",
        "id": 198383447,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1590098914
    },
    {
        "content": "<p>Rather than <code>::return</code>/<code>::fn</code>/<code>::arg</code>/etc, it might be nicer to come up with a syntax for the client to give that type a name it can use. (By analogy: pattern matching rather than projection, or C++20 requires-expressions rather than C++11 declval.) Maybe something like <code>where (for(s: &amp;S) { s.launch() }): F, F: Send</code>?</p>\n<p>As const generics gets further along I expect people will need similar tools there anyway- things like <code>where doesnt_overflow({ X + 3 })</code> (or perhaps even <code>where { X + 3 &lt; Y }</code>). Some sort of cohesive tool for talking about expressions, even expressions pulled out of thin air like <code>for(s: &amp;S) { s.launch() }</code> might be a good way to handle <code>impl Trait</code> bounds as well.</p>",
        "id": 198392857,
        "sender_full_name": "rpjohnst",
        "timestamp": 1590105316
    },
    {
        "content": "<p>I do want to say that</p>",
        "id": 198472300,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169512
    },
    {
        "content": "<p>in general, I think that turbofish is kind of \"meh\"</p>",
        "id": 198472309,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169520
    },
    {
        "content": "<p>especially when you have a long list of \"optional\" parameters</p>",
        "id": 198472325,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169531
    },
    {
        "content": "<p>e.g., if we have <code>HashMap&lt;T, H(asher), A(llocator)&gt;</code></p>",
        "id": 198472353,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169548
    },
    {
        "content": "<p>it'd be nice to  be able to specify the Allocator without speciying the hasher</p>",
        "id": 198472373,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169558
    },
    {
        "content": "<p>I guess that being able to give some name might tie in with <code>impl Trait</code></p>",
        "id": 198472435,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169573
    },
    {
        "content": "<p>I'm not sure I quite understand <span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> your const generics examples though</p>",
        "id": 198472491,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590169605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/198472491\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I quite understand <span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> your const generics examples though</p>\n</blockquote>\n<p>I could be totally wrong there, but my understanding is that, to use a const generic parameter in an expression, the parameter must be constrained enough that the use won't produce monomorphization-time errors- thus a need to put expressions in constraints.</p>",
        "id": 198484483,
        "sender_full_name": "rpjohnst",
        "timestamp": 1590175666
    },
    {
        "content": "<p>Argh, I intended to attend this meeting, but it slipped my mind with everything else that's going on <span aria-label=\"weary\" class=\"emoji emoji-1f629\" role=\"img\" title=\"weary\">:weary:</span></p>",
        "id": 198540295,
        "sender_full_name": "varkor",
        "timestamp": 1590247938
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> -- I was wondering if you'd be interested in scheduling a time to chat to talk about impl Trait implementation issues. I just saw <a href=\"https://github.com/rust-lang/rust/pull/72080/\">https://github.com/rust-lang/rust/pull/72080/</a> and I've been thinking about this as well.</p>",
        "id": 198829244,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590531964
    },
    {
        "content": "<p>That sounds good. I'm generally free after 4:30  UTC</p>",
        "id": 198918060,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1590597413
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span></p>",
        "id": 199476657,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591096607
    },
    {
        "content": "<p>Heh I was wondering where I started this thread, thanks <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span></p>",
        "id": 199499852,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591108179
    },
    {
        "content": "<p>Also cc <span class=\"user-mention\" data-user-id=\"124288\">@oli</span></p>",
        "id": 199500031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591108204
    },
    {
        "content": "<p>I think best for me might be to try and talk more on Friday</p>",
        "id": 199500108,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591108221
    },
    {
        "content": "<p>well or maybe Wed</p>",
        "id": 199500132,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591108225
    },
    {
        "content": "<p>Either of those sounds fine for me</p>",
        "id": 199504670,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591109938
    },
    {
        "content": "<p>I will try to review <a href=\"https://github.com/rust-lang/rust/issues/72080\">#72080</a> in the meantime</p>",
        "id": 199505137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591110095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> let's do friday, say 13:00 Boston time == 17:00 UTC I believe</p>",
        "id": 199657310,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591208655
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> (and maybe <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>)</p>",
        "id": 199905962,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376499
    },
    {
        "content": "<p>So... I was hoping to talk a bit about impl trait implementation questions</p>",
        "id": 199906089,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376543
    },
    {
        "content": "<p>I had hoped to do prep but mostly I just read <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span>'s PR -- in any case, I'm going to start typing and leaving notes and thoughts and doing a bit of investigating, and maybe if you folks are around now, that's great, else we can discuss more later</p>",
        "id": 199906188,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376586
    },
    {
        "content": "<p><a href=\"https://hackmd.io/OgSPmb7URaemYMNL2hGbiA\">hackmd</a></p>",
        "id": 199906212,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376603
    },
    {
        "content": "<p>I'm here</p>",
        "id": 199906539,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591376763
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 199906641,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376832
    },
    {
        "content": "<p>sorry, was afk for a sec, back now</p>",
        "id": 199906678,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376866
    },
    {
        "content": "<p>OK, so, looking at the questions of implementation...</p>",
        "id": 199906760,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376894
    },
    {
        "content": "<p>I guess that there are a few categories of things going on</p>",
        "id": 199906771,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376899
    },
    {
        "content": "<p>for me a big goal is enabling people to return futures/closures/etc in trait impls</p>",
        "id": 199906794,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376909
    },
    {
        "content": "<p>which I guess is basically a pattern of </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">P0</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"n\">Pn</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Something</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P0</span><span class=\"o\">..</span><span class=\"n\">Pn</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">SomeTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">P0</span><span class=\"o\">..</span><span class=\"n\">Pn</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 199906888,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591376982
    },
    {
        "content": "<p>I bring this up because there is a distinct case where the opaque type appears in the arguments of the fn</p>",
        "id": 199906964,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377012
    },
    {
        "content": "<p>and I think that this case is more challenging and also harder for our implementation</p>",
        "id": 199906981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377026
    },
    {
        "content": "<p>so in particular i'm looking at \"are there important use cases we could prioritize for stabilization\"</p>",
        "id": 199907001,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377037
    },
    {
        "content": "<p>I think that opaque types where the \"defining uses\" are in the return type only are such a case</p>",
        "id": 199907028,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377061
    },
    {
        "content": "<p>Yes</p>",
        "id": 199907178,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591377130
    },
    {
        "content": "<p>I'm trying now to find my older hackmd</p>",
        "id": 199907287,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377200
    },
    {
        "content": "<p>where I had a more comprehensive list of where impl Trait could appear</p>",
        "id": 199907305,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377208
    },
    {
        "content": "<p>I guess it was at the top of this topic</p>",
        "id": 199907315,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377213
    },
    {
        "content": "<p><a href=\"https://github.com/nikomatsakis/lang-team/blob/impl-trait-everywhere/src/design_notes/impl_trait_everywhere.md\">here they are</a></p>",
        "id": 199907353,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377236
    },
    {
        "content": "<p>oh, right, it was not a gist..</p>",
        "id": 199907461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377290
    },
    {
        "content": "<p>so in particular the reason to separate out the return position</p>",
        "id": 199907512,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377312
    },
    {
        "content": "<p>There's also <a href=\"https://hackmd.io/w_xcaFmASEqzVMC3J2L8Dw?edit\">https://hackmd.io/w_xcaFmASEqzVMC3J2L8Dw?edit</a></p>",
        "id": 199907533,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591377326
    },
    {
        "content": "<p>is that it doesn't encounter the challenge of \"how to think about the opaque type during inference\"</p>",
        "id": 199907534,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377327
    },
    {
        "content": "<p>oh yes</p>",
        "id": 199907601,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377361
    },
    {
        "content": "<p>ok</p>",
        "id": 199907604,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377362
    },
    {
        "content": "<p>so many notes :)</p>",
        "id": 199907644,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377365
    },
    {
        "content": "<p>I guess I'm curious to see if there are any problems with other positions</p>",
        "id": 199907669,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377380
    },
    {
        "content": "<p>I think usage in const/static doesn't present any <em>particular</em> difficulties, even if it currently errors more than we'd like?</p>",
        "id": 199907700,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377395
    },
    {
        "content": "<p>I'm not 100% sure what the status is of <code>let x: impl Trait = ..</code> after your PR, I remember the impl before had some serious flaws</p>",
        "id": 199907755,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377426
    },
    {
        "content": "<p>it seems to me that these are the \"big categories\" though:</p>\n<ul>\n<li>all \"defining uses\" are outputs (<code>-&gt; impl Trait</code>, <code>const X: impl Trait</code>)</li>\n<li>\"defining use\" in fn body (<code>let x: impl Trait</code> or <code>let x: Foo</code>)</li>\n<li>\"defining use\" in inputs (<code>fn foo(x: OpaqueType)</code>)</li>\n</ul>",
        "id": 199907895,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377494
    },
    {
        "content": "<p>I think it's still pretty bad. I think that all I did was change one ICE for another that gives a slightly better message.</p>",
        "id": 199907899,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591377496
    },
    {
        "content": "<p>I probably ordered those wrong</p>",
        "id": 199907924,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377514
    },
    {
        "content": "<p>in that if you do this order:</p>",
        "id": 199907943,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377525
    },
    {
        "content": "<ul>\n<li>all \"defining uses\" are outputs (<code>-&gt; impl Trait</code>, <code>const X: impl Trait</code>)</li>\n<li>\"defining use\" in inputs (<code>fn foo(x: OpaqueType)</code>)</li>\n<li>\"defining use\" in fn body (<code>let x: impl Trait</code> or <code>let x: Foo</code>)</li>\n</ul>",
        "id": 199907963,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377533
    },
    {
        "content": "<p>it might be more the order of priority?</p>",
        "id": 199907973,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377537
    },
    {
        "content": "<p>I'm actually not sure about that</p>",
        "id": 199907980,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377540
    },
    {
        "content": "<p>I mean you never <em>need</em> <code>let x: impl Foo</code> in a fn body, but it might be in some senses simpler, and I've found I really would like it when writing docs</p>",
        "id": 199908013,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377556
    },
    {
        "content": "<p>but anyhow</p>",
        "id": 199908035,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377568
    },
    {
        "content": "<p>There's also the non-defining use in defining scope issue.</p>",
        "id": 199908047,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591377580
    },
    {
        "content": "<p>do you mean the \"passthrough\" use case?</p>",
        "id": 199908061,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377593
    },
    {
        "content": "<p>yes</p>",
        "id": 199908069,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591377598
    },
    {
        "content": "<p>specifically I mean that</p>",
        "id": 199908123,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377608
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">OpaqueType</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">OpaqueType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>is supposed to work</p>",
        "id": 199908143,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377620
    },
    {
        "content": "<p>so, that is an issue, but I note that it requires a \"defining use\" in inputs</p>",
        "id": 199908152,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377628
    },
    {
        "content": "<p>maybe I'm using \"defining use\" in a confusing way</p>",
        "id": 199908171,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377636
    },
    {
        "content": "<p>I don't actually mean what the compiler means by it</p>",
        "id": 199908181,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377641
    },
    {
        "content": "<p>I mean what the RFC means by, that is, basically <em>any</em> use that is inside the \"scope\" of the opaque type</p>",
        "id": 199908201,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377656
    },
    {
        "content": "<p>let's call it .. in-scope use?</p>",
        "id": 199908249,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377684
    },
    {
        "content": "<blockquote>\n<p>Ultimately all <code>impl Trait</code> outside of fn arguments desugar to a \"opaque type\" that has some \"defining scope\".</p>\n<p>This scope may be a particular item or it may be the enclosing module.</p>\n<p>A \"in-scope use\" is a reference to that opaque type from within the \"defining scope\".</p>\n</blockquote>",
        "id": 199908379,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377741
    },
    {
        "content": "<p>That's my mental model, sound correct?</p>",
        "id": 199908402,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377749
    },
    {
        "content": "<p>Sounds good</p>",
        "id": 199908419,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591377764
    },
    {
        "content": "<blockquote>\n<p><strong>Layer 1. All \"in-scope uses\" are in a \"defining\" location.</strong></p>\n<p>A \"defining\" location is one of the following:</p>\n<ul>\n<li>fn return type</li>\n<li>const/static type annotation</li>\n</ul>\n</blockquote>",
        "id": 199908571,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377872
    },
    {
        "content": "<blockquote>\n<p>What these have in common is that there are no expressions that the user can reference that yield values of the opaque type until the opaque type is fully inferred (it would result in a cycle error).</p>\n<p>Claim: the current implementation in these cases matches the RFC.</p>\n</blockquote>",
        "id": 199908580,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377879
    },
    {
        "content": "<p>Sound correct?</p>",
        "id": 199908585,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377881
    },
    {
        "content": "<p>We should probably test that claim :)</p>",
        "id": 199908601,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377895
    },
    {
        "content": "<p>I wonder how to think about </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">OpaqueType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span>: <span class=\"nc\">OpaqueType</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 199908761,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377978
    },
    {
        "content": "<p>It is not a member of that layer, clearly :)</p>",
        "id": 199908780,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591377990
    },
    {
        "content": "<blockquote>\n<p>What these have in common is that there are no expressions that the user can reference that yield values of the opaque type until the opaque type is fully inferred (it would result in a cycle error).</p>\n</blockquote>\n<p>I'm not sure what you mean by this. It's possible to write:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">A</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">rec</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 199909482,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591378364
    },
    {
        "content": "<p>Hmm ok I guess that's just false :)</p>",
        "id": 199909779,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378538
    },
    {
        "content": "<p>I guess it's only if we have to evaluate an auto trait</p>",
        "id": 199909802,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378551
    },
    {
        "content": "<p>that you get the cycle error</p>",
        "id": 199909806,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378553
    },
    {
        "content": "<p>that gets at something I was just thinking about</p>",
        "id": 199909868,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378571
    },
    {
        "content": "<p>I'm not sure I entirely know what the expected behavior is in this case</p>",
        "id": 199909888,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378588
    },
    {
        "content": "<p>is the type of <code>x</code> \"opaque\"</p>",
        "id": 199909900,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378601
    },
    {
        "content": "<p>or \"revealed\"</p>",
        "id": 199909905,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378604
    },
    {
        "content": "<p>similarly if you had </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">OpaqueType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">OpaqueType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22_</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">44</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>does that compile?</p>",
        "id": 199909980,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378659
    },
    {
        "content": "<p>I ask because I could imagine an alternate impl strategy where we don't \"replace\" opaque-types-being-inferred with fresh inference variables</p>",
        "id": 199910061,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378691
    },
    {
        "content": "<p>but rather collect the constraints</p>",
        "id": 199910077,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378697
    },
    {
        "content": "<p>it might be ever so slightly backwards incompatible</p>",
        "id": 199910105,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378714
    },
    {
        "content": "<p>for a case like</p>",
        "id": 199910111,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378718
    },
    {
        "content": "<p>The current behaviour is opaque I think.</p>",
        "id": 199910121,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591378720
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">XXX</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">YYY</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// maybe the type of XXX informs  the expected type for YYY here?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 199910156,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378747
    },
    {
        "content": "<p>but I imagine that would be .. very rare .. and perhaps solveable, at worst via a hack</p>",
        "id": 199910188,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378768
    },
    {
        "content": "<p>I could imagine either behavior, I'm not sure what I expect</p>",
        "id": 199910370,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378870
    },
    {
        "content": "<p><em>but</em> I see some advantages to this impl strategy</p>",
        "id": 199910379,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378879
    },
    {
        "content": "<p>it would I think help with the problems of impl Trait in argment position etc</p>",
        "id": 199910388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378890
    },
    {
        "content": "<p>not sure if what I sketched is clear</p>",
        "id": 199910537,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378958
    },
    {
        "content": "<p>what I imagine is maybe something like this</p>",
        "id": 199910543,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378962
    },
    {
        "content": "<p>we have in the inference context a list of \"opaque types being inferred\"</p>",
        "id": 199910556,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591378976
    },
    {
        "content": "<p>whenever we are asked to equate an opaque type .. xxx .. ok, what I was about to write would not work :)</p>",
        "id": 199910594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379004
    },
    {
        "content": "<p>well, I'll write it anyway, the idea would be that unification succeeds, but we collect the type you unified with</p>",
        "id": 199910629,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379027
    },
    {
        "content": "<p>one reason it would not work is that you have things like \"test if this impl for String applies\"</p>",
        "id": 199910683,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379044
    },
    {
        "content": "<p>(and you basically never want those impls to apply)</p>",
        "id": 199910698,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379054
    },
    {
        "content": "<p>so we'd have to sort of distinguish a bit better what we mean there</p>",
        "id": 199910742,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/impl.20Trait.20everywhere/near/199910698\">said</a>:</p>\n<blockquote>\n<p>(and you basically never want those impls to apply)</p>\n</blockquote>\n<p>except maybe when we do? sometimes impl selection affects inference, after all</p>",
        "id": 199910833,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379146
    },
    {
        "content": "<p>in terms of what behavior we want, <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> mentioned a \"guideline\" that maybe helps. As much as possible, you should be able to take a <code>impl Trait</code> and \"extract\" it to a type alias and things should kind of work the same. This is only sort of possible because of \"universal-to-existential\" conversion, though. But it would suggest that</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">44</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>is an error, so it should be the same if you do</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">44</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 199911020,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379242
    },
    {
        "content": "<p>I'm thinking about that recursive case and trying to decide whether it implies that I am wrong that we could potentially move faster towards stabilizing impl trait in return position</p>",
        "id": 199911388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379449
    },
    {
        "content": "<p>presumably the compiler treats such types as opaque</p>",
        "id": 199911410,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379462
    },
    {
        "content": "<p>yes, it does</p>",
        "id": 199911437,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379479
    },
    {
        "content": "<p>so e.g. this does not compile</p>",
        "id": 199911445,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379482
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=cf0280260f6828c6059476ed81e03ef9\">playground</a></p>",
        "id": 199911461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379495
    },
    {
        "content": "<p>so I guess one thing to do might be to experiment with this idea I was describing, though I'd have to decide how to handle the distinct between \"probing\" whether a type can unify and \"declaring\" that it must unify</p>",
        "id": 199911827,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379678
    },
    {
        "content": "<p>I was already thinking that the real way to handle this would be to have the \"obligations\" that get propagated back encode information about the constraints on opaque types that are required (similar to region constraints), which might be part of the answer</p>",
        "id": 199911902,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379720
    },
    {
        "content": "<p>...this is also similar to the \"semantic vs syntactic equality\" split, maybe?, that we are pursuing in chalk...</p>",
        "id": 199911930,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379733
    },
    {
        "content": "<p>if we <em>could</em> get it to work, it seems like it would behave much better and also fit the RFC more closely</p>",
        "id": 199911955,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379750
    },
    {
        "content": "<p>got to go, will ponder a bit, I'm leaning towards \"it's worth experimenting some to see what problems arise\"</p>",
        "id": 199912330,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591379903
    },
    {
        "content": "<blockquote>\n<p>in terms of what behavior we want, @Taylor Cramer mentioned a \"guideline\" that maybe helps. As much as possible, you should be able to take a impl Trait and \"extract\" it to a type alias and things should kind of work the same. This is only sort of possible because of \"universal-to-existential\" conversion, though.</p>\n</blockquote>\n<p>I think this could possibly be taken to be a <em>definition</em> of impl Trait, which may make thinking of it more intuitive. What are the cases where this guideline fails?</p>",
        "id": 200881619,
        "sender_full_name": "varkor",
        "timestamp": 1592223880
    },
    {
        "content": "<p>well </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>is the obvious example, to start</p>",
        "id": 200902513,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1592234014
    },
    {
        "content": "<p>Ah, I meant non-argument-position impl Trait, which is really a distinct feature.</p>",
        "id": 200905010,
        "sender_full_name": "varkor",
        "timestamp": 1592234913
    },
    {
        "content": "<p>I think the property already holds for cases of \"non-argument-position\" impl Trait, modulo that you may need to create a module to contain things.</p>",
        "id": 200928502,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1592246176
    }
]