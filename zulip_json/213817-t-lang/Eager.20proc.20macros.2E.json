[
    {
        "content": "<p>Hello i wonder what people think about the idea of a general mechanism for \"eager proc macros\", which:</p>\n<ul>\n<li>Registered to enable only from command line parameters like <code>rustc --eager-macro concat_idents = std::concat_idents</code></li>\n<li>Invoked for all tokentree sequences of the form <code>identifier ! group</code> where identifier is registered.</li>\n<li>NOT AST-typed, performs <code>TokenStream -&gt; TokenStream</code> inline replacement conceptually BEFORE AST tree is formed.</li>\n<li><code>concat_idents</code>, <code>include</code> and maybe others be migrated into this mechanism, and be registered as builtin macros.</li>\n</ul>",
        "id": 261297876,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636744485
    },
    {
        "content": "<blockquote>\n<p>concat_idents, include and maybe others be migrated into this mechanism, and be registered as builtin macros.</p>\n</blockquote>\n<p>That would be a breaking change for <code>foo!(include!(\"a\"))</code> where currently <code>foo!</code> would get<code>include!(\"a\")</code> as raw input instead of it's expansion.</p>",
        "id": 261298428,
        "sender_full_name": "bjorn3",
        "timestamp": 1636744763
    },
    {
        "content": "<p>Yes, it is. Though in practice this is quite rare. Actually if the <code>included!()</code> is used as a <code>$expr</code>, the current behavior in this example -  <code>include!</code> macro reading the first expression and discarding rest silently - is not a very well-behaved behavior and potentially surprising to users...</p>",
        "id": 261299061,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636745050
    },
    {
        "content": "<p>Whatâ€™s the motivation?</p>",
        "id": 261301366,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636746223
    },
    {
        "content": "<p>And in what sense are they eager?</p>",
        "id": 261301386,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636746236
    },
    {
        "content": "<p>Fixing <code>concat_idents!</code> behavior.</p>",
        "id": 261301388,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636746237
    },
    {
        "content": "<p>Currently  <code>let concat_idents!(foo, bar) = 5;</code> doesn't work.</p>",
        "id": 261301478,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636746268
    },
    {
        "content": "<p>because it's an expression macro.</p>",
        "id": 261301591,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636746336
    },
    {
        "content": "<p>I feel like I wrote an rfc for this 4 or 5 years ago? But I canâ€™t remember it at all ðŸ¤£</p>",
        "id": 261301598,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636746339
    },
    {
        "content": "<p>Maybe itâ€™s a different kind of eager?</p>",
        "id": 261301625,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636746353
    },
    {
        "content": "<p>While eager expansions could solve stuff, the approach you suggest, for <code>concat_idents!</code>, would not work, since the meaningful usages of that macro are with at least one metavariable argument, which could thus not be handled by a \"dummy syntactical preprocessor\".</p>\n<p>In the case of <code>concat_idents</code>, the issue is the call-site rather than the eagerness of the call. In that regard, we could imagine a <code>#[rename_concat]</code> attribute that could be applicable to <code>fn</code> defs and <code>let</code> bindings:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[rename_concat($foo, _test)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">__</span><span class=\"p\">(</span><span class=\"n\">arg</span>: <span class=\"nc\">Arg</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Back to the topic of eager expansion (to chain macros), there seem to be significant issues in the general case, but a simpler experimental <code>expand_expr</code> <code>TokenStream</code> helper is about to be added to nightly: <a href=\"https://github.com/rust-lang/rust/pull/87264\">https://github.com/rust-lang/rust/pull/87264</a></p>",
        "id": 261309107,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636750386
    }
]