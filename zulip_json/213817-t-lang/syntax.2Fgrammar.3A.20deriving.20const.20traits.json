[
    {
        "content": "<p>I think that the ability to derive a const trait is useful, and I am certain others agree on this point. <code>#[derive(const Default)]</code> is syntactically invalid at the moment. After digging in the parser a bit, it looks like the only way to permit it here is to permit it in <em>any</em> attribute macro, which I don't see as desirable. The alternative would be to special-case the <code>derive</code> macro similar to how <code>cfg</code> is, but I don't believe that would be possible (at least without significant effort or an edition boundary) because you can <code>use derive as foo</code> and then <code>#[foo(Default)]</code>. As odd as that may seem I do recall seeing a UI test for this, so it's intended behavior.</p>\n<p>I'm trying to implement this speculatively before an RFC is written to take note of any major issues. I'd like to permit <code>#[derive(const Foo)]</code> both for standard library traits and third-party derives (by having <code>#[proc_macro_derive(const Foo)]</code> permitted. And if we're going down that road, may as well permit <code>#[derive(unsafe Send, unsafe Sync)]</code> as well I would think.</p>\n<p>What would be the best way to attempt an implementation here?</p>",
        "id": 266466258,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640906355
    },
    {
        "content": "<p>I actually see an alternative from <a href=\"https://rust-lang.github.io/rfcs/1559-attributes-with-literals.html#token-trees\">RFC 1559</a> showing an alternative being raw token trees inside the attribute. I think this is backwards compatible if we wanted to go that route?</p>",
        "id": 266476727,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640919142
    },
    {
        "content": "<p>Even permitting arbitrary tokens inside the parenthesized part of an attribute would be extremely flexible.</p>",
        "id": 266476762,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640919240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> Permitting the tokens syntactically and then rejecting them later semantically seems reasonable.</p>",
        "id": 266479359,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640923194
    },
    {
        "content": "<p>If someone writes <code>#[derive(let Default)]</code>, it seems fine if the compiler waits until later to go \"what?\".</p>",
        "id": 266479452,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640923230
    },
    {
        "content": "<p>(Assuming that change suffices.)</p>",
        "id": 266479463,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640923256
    },
    {
        "content": "<p>I think this would be another case where derive arguments would be useful</p>",
        "id": 266479650,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923518
    },
    {
        "content": "<p>I'm in the process of writing up an RFC for that</p>",
        "id": 266479652,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923527
    },
    {
        "content": "<p>Alternatively, you could add a derive helper attribute, and do something like <code>#[const_derive(Default, Debug, MyCustomDerive)]</code></p>",
        "id": 266479705,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923579
    },
    {
        "content": "<p>and have the individual derive macros search for their own name in the list</p>",
        "id": 266479707,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923593
    },
    {
        "content": "<p>The code I have locally currently parses <code>const</code> specifically, so any other keyword would be rejected. It creates a new <code>ConstWord</code> meta item, but realistically that was just a temporary thing for playing around.</p>",
        "id": 266479708,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640923599
    },
    {
        "content": "<p>I thought of splitting the derive into a const derive attribute, but having <code>#[derive(const Default)]</code> just feels right</p>",
        "id": 266479728,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640923643
    },
    {
        "content": "<p>with derive arguments, that could be <code>#[derive(Debug(const), Default, OtherTrait(const))]</code></p>",
        "id": 266479800,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> I believe in general that if something uses a particular syntax in one context it should use the same syntax in other contexts if at all possible. We write <code>impl const Default</code>, so we should be able to write <code>derive(const Default)</code>.</p>",
        "id": 266479823,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640923801
    },
    {
        "content": "<p>how would that get interpreted by the derive macro?</p>",
        "id": 266479881,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923851
    },
    {
        "content": "<p>Would it receive a list of keywords used?</p>",
        "id": 266479887,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923865
    },
    {
        "content": "<p>Basically, yes.</p>",
        "id": 266479890,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640923876
    },
    {
        "content": "<p>On the code I have locally it currently adds a new meta item, but ultimately it would make sense to add information directly to the existing ones.</p>",
        "id": 266479936,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640923925
    },
    {
        "content": "<p>I think the derive argument syntax would be more flexible, and could accept the same syntax that attribute macros do</p>",
        "id": 266479942,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923939
    },
    {
        "content": "<p>Also, the connection between a derive macro and a particular trait is \"just\" a strong convention</p>",
        "id": 266479948,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923965
    },
    {
        "content": "<p>As far as the macro system is concerned, a derive macro can expand to any list of items</p>",
        "id": 266479960,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640923989
    },
    {
        "content": "<p>Yes, but the expectation is generally that they expand to the thing named.</p>",
        "id": 266479970,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640924018
    },
    {
        "content": "<p>I'm not saying that we should encourage other non-trait uses of derive</p>",
        "id": 266479971,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924020
    },
    {
        "content": "<p>but this seems to be making derive more 'opinionated' than it currently is</p>",
        "id": 266479985,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924041
    },
    {
        "content": "<p>Not really. The built-in macros would handle it the clear way, while proc macros could <code>#[proc_macro_derive(const Foo)]</code> and do whatever they want still.</p>",
        "id": 266480043,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640924111
    },
    {
        "content": "<p>Mainly, I think that if we're going to allow additional tokens to be 'directed' at a particular derive macro invocation, we should do it in a flexible way</p>",
        "id": 266480052,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924127
    },
    {
        "content": "<p>and we already have a mechanism for (AFAIK) arbitrary tokens as arguments to an attribute macro</p>",
        "id": 266480058,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924153
    },
    {
        "content": "<p>I think it would be better to re-use that instead of introducing a new, more restricted form of arguments for just derive</p>",
        "id": 266480103,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924178
    },
    {
        "content": "<p>I don't believe that is the case.</p>",
        "id": 266480105,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640924181
    },
    {
        "content": "<p>Which part?</p>",
        "id": 266480116,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924213
    },
    {
        "content": "<p>The arbitrary tokens as arguments</p>",
        "id": 266480188,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640924339
    },
    {
        "content": "<p>I just tested, and it appears to allow any tokens</p>",
        "id": 266480244,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924404
    },
    {
        "content": "<p>Though I think I've only ever seen comma-separated tokens and nested parents in practice</p>",
        "id": 266480263,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I think I see <code>#[derive(Trait)] struct Foo {}</code> as being closer to <code>#[attribute_macro] struct Foo {}</code> than <code>impl Trait for Foo {}</code></p>",
        "id": 266480340,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924576
    },
    {
        "content": "<p>That is, while it should expand to a normal trait impl (and maybe an inherent impl) to match user expectations, it's still first and foremost a macro call</p>",
        "id": 266480367,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924640
    },
    {
        "content": "<p>I also have a separate use-case for derive macro arguments in mind (using them to explicitly opt-in to newly added libstd derive helpers), so I'm definitely biased towards a more general way of passing arguments :)</p>",
        "id": 266480479,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924815
    },
    {
        "content": "<p>What did you try out of curiosity? I was digging through the code earlier and didn't think that was the case (there are RFCs that clearly indicate it shouldn't be).</p>\n<p>While of course it is a macro call, I'd be surprised if most people viewed it that way. I've always viewed it as \"generate this named trait for me\"</p>",
        "id": 266480550,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640924910
    },
    {
        "content": "<p>I tried <code>#[my_macro(a =&gt; b . + - ())]</code></p>",
        "id": 266480569,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640924959
    },
    {
        "content": "<p>I wonder if there could be a generalization of this.<br>\nSomething like<br>\n<code>#[proc_macro_extended_derive(Name)]</code>, which accepts one preceeding keyword, then the derive Name, followed by full meta syntax in paramethesis (each part of this is optional), and passes the entire thing in a second TokenStream to the function?</p>",
        "id": 266480626,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925037
    },
    {
        "content": "<p>I think passing the arguments inline <code>#[derive(Foo(some args))]</code> would be much easier to read</p>",
        "id": 266480766,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925243
    },
    {
        "content": "<p>since there's only one use of the derive macro name</p>",
        "id": 266480777,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925271
    },
    {
        "content": "<p>Yeah, that would also be reasonable (that's covered by the \"full meta syntax in parenthesis\")</p>",
        "id": 266480780,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925277
    },
    {
        "content": "<p>Basically, my idea for <code>#[proc_macro_extended_derive]</code> would work like a combination of <code>#[proc_macro_derive]</code> (in that it interfaces with the <code>#[derive]</code> attribute), and <code>#[proc_macro_attribute]</code> (in that it accepts the attribute, or in this case, the relevant portion of the <code>#[derive]</code> input, as a second TokenStream)</p>",
        "id": 266480857,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925384
    },
    {
        "content": "<p>What about something that isn't optional though? Of course <code>const Default</code> can go either way, but <code>#[derive(unsafe Send)]</code> wouldn't have <code>unsafe</code> be optional. Sure, the macro could enforce it itself, but it seems cleaner to do it the way written here.</p>",
        "id": 266480860,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/213817-t-lang/topic/syntax.2Fgrammar.3A.20deriving.20const.20traits/near/266480860\">said</a>:</p>\n<blockquote>\n<p>What about something that isn't optional though? Of course <code>const Default</code> can go either way, but #[derive(unsafe Send)]<code> wouldn't have </code>unsafe` be optional. Sure, the macro could enforce it itself, but it seems cleaner to do it the way written here.</p>\n</blockquote>\n<p>The macro itself would need to communicate what is and is not accepted (and optional/mandatory) in the keyword slot, so it seems better in that version to just let the macro handle it.</p>",
        "id": 266480878,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925455
    },
    {
        "content": "<p>Oh, I think I misread your comment - you were proposing an attribute on the proc macro definition</p>",
        "id": 266480924,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925495
    },
    {
        "content": "<p>Not an additional attribute that you would apply to the invocation site</p>",
        "id": 266480931,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925513
    },
    {
        "content": "<p>I think we're actually in complete agreement</p>",
        "id": 266480948,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925538
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 266480954,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925551
    },
    {
        "content": "<p>Yes, but my intent for showing what's optional is to have <code>#[proc_macro_derive(const Foo)]</code> be its own thing, separate from the non-const version. The implementation <em>should</em> be nearly identical but this wouldn't be enforced.</p>",
        "id": 266480961,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/213817-t-lang/topic/syntax.2Fgrammar.3A.20deriving.20const.20traits/near/266480961\">said</a>:</p>\n<blockquote>\n<p>Yes, but my intent for showing what's optional is to have <code>#[proc_macro_derive(const Foo)]</code> be its own thing, separate from the non-const version. The implementation <em>should</em> be nearly identical but this wouldn't be enforced.</p>\n</blockquote>\n<p>Hmm...</p>",
        "id": 266481018,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925622
    },
    {
        "content": "<p>I think there are a lot of other useful options that we might want to pass to derive macros</p>",
        "id": 266481032,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925684
    },
    {
        "content": "<p>I'm not disputing that</p>",
        "id": 266481034,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925700
    },
    {
        "content": "<p>e.g. skipping fields for <code>Debug</code> or adjusting <code>where</code> clauses</p>",
        "id": 266481037,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925704
    },
    {
        "content": "<p>I just don't think it's the appropriate mechanism to mark something const</p>",
        "id": 266481040,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925712
    },
    {
        "content": "<p>and in general, they can't have an equivalent syntax to what it would look like on an impl</p>",
        "id": 266481079,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925728
    },
    {
        "content": "<p>The proposed enhanced derive macro, though, would be useful for other things. For example, specifying options of something like <code>#[derive(serde::Deserialize/Serialize)]</code></p>",
        "id": 266481080,
        "sender_full_name": "Connor Horman",
        "timestamp": 1640925728
    },
    {
        "content": "<p>So, this seems like special-casing <code>const</code> over other impl customizations</p>",
        "id": 266481089,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925755
    },
    {
        "content": "<p>That is:</p>",
        "id": 266481090,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925759
    },
    {
        "content": "<p><code>impl const Foo</code> will match up nicely with <code>#[derive(const Foo)]</code></p>",
        "id": 266481094,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925781
    },
    {
        "content": "<p>But <code>impl MyTrait for Bar where MyWhereClause</code> can't really match up directly with a derive</p>",
        "id": 266481110,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925822
    },
    {
        "content": "<p>Correct. Matching the derive syntax with the impl</p>",
        "id": 266481116,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925841
    },
    {
        "content": "<p>Unless we wanted to allow <code>#[derive(Foo where MyWhereClause)]</code></p>",
        "id": 266481157,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925856
    },
    {
        "content": "<p>Keep in mind that my original question was solely how I should go about doing this grammatically and semantically in the compiler, by the way. I actually wasn't coming here for a debate — that was for the RFC that hasn't even been started</p>",
        "id": 266481167,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925899
    },
    {
        "content": "<p>I definitely think an RFC is a good idea</p>",
        "id": 266481179,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925924
    },
    {
        "content": "<p>I can save this discussion for that PR, if you'd like</p>",
        "id": 266481185,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925940
    },
    {
        "content": "<p>In terms of the implementation:</p>",
        "id": 266481231,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640925965
    },
    {
        "content": "<p>Up to you. That was just my nice way of saying that I don't particularly feel like debating the specifics right now — I just wasn't sure the best way to implement the parser when playing around locally.</p>",
        "id": 266481235,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640925993
    },
    {
        "content": "<p>The RFC, like I said, hasn't even been started. I'll definitely post it on IRLO first if you track that.</p>",
        "id": 266481241,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640926020
    },
    {
        "content": "<p>Are you looking to modify your current implementation to make it easier to experiment with locally?</p>",
        "id": 266481243,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926025
    },
    {
        "content": "<p>Or are you trying to make a more robust implementation?</p>",
        "id": 266481246,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926037
    },
    {
        "content": "<p>Uhh not sure? First thing I was trying to do was to get it working. Which I'm nearly there I think</p>",
        "id": 266481298,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640926129
    },
    {
        "content": "<p>The 'final' implementation would probably have the proc macro definition taking in two TokenStream arguments, but that could be kind of a pain to implement</p>",
        "id": 266481314,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926192
    },
    {
        "content": "<p>as you would need to handle the function having either one or two arguments</p>",
        "id": 266481363,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926221
    },
    {
        "content": "<p>If you're just working with built-in attributes, you could probably stash the extra data in the ExtCtxt</p>",
        "id": 266481372,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926247
    },
    {
        "content": "<p>Like I have a vision of what I want and am trying to implement it (largely) before writing an RFC. Primary purpose, at least initially, is to have the built in derived support const traits. Later goal is proc macro derives.</p>",
        "id": 266481388,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640926303
    },
    {
        "content": "<p>Built-in will probably be much simpler, since you won't have to deal with any of the bridge/dylib/harness code</p>",
        "id": 266481435,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926344
    },
    {
        "content": "<p>which has several different pieces spread out across the compiler</p>",
        "id": 266481440,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640926368
    },
    {
        "content": "<p>Actually making the trait const is laughably easy. The only issue is parsing the syntax.</p>",
        "id": 266481451,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640926392
    },
    {
        "content": "<p>having more parens all over is a bad time. That's what makes cfg stuff terrible. So if at all possible, <code>const Default</code> is better than <code>Default(const)</code>.</p>",
        "id": 266513900,
        "sender_full_name": "Lokathor",
        "timestamp": 1640970131
    },
    {
        "content": "<p>All these suggest using <code>#[derive_const(Default)]</code>: no extra params, and no need to tackle derive args as well. For those mentioning a _single_ keyword syntax, what of <code>#[derive(unsafe Send)]</code>, <code>#[derive(unsafe const Foo)]</code>, and so on?</p>\n<p>I personally believe that having derives behave like attribute macros, and take args will end up being necessary. And for that, I'm afraid, we'll end up needing another layer of parens. But only one: inside them, the derive can feature whatever parsing they want:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(</span>\n<span class=\"cp\">    Debug, // sugar for `Debug()`</span>\n<span class=\"cp\">    Default(const),</span>\n<span class=\"cp\">    // in the future, to opt out of bounds:</span>\n<span class=\"cp\">    Default(const, bounds = impl&lt;T&gt;),</span>\n<span class=\"cp\">    // or directly:</span>\n<span class=\"cp\">    Default(impl&lt;T&gt; const),</span>\n<span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and, back to the \"derive helpers\" discussion:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(</span>\n<span class=\"cp\">    MyDerive(rename_helpers = my_derive, crate = some::path),</span>\n<span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[my_derive = </span><span class=\"s\">\"…\"</span><span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// …</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266516061,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640973316
    },
    {
        "content": "<p>Hmm…I'm not necessarily opposed to permitting arbitrary tokens given the obvious future possibilities (both for stdlib and third-party crates). It's definitely something I'll have to think more about.</p>",
        "id": 266518973,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1640977528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/213817-t-lang/topic/syntax.2Fgrammar.3A.20deriving.20const.20traits/near/266479705\">said</a>:</p>\n<blockquote>\n<p>Alternatively, you could add a derive helper attribute, and do something like <code>#[const_derive(Default, Debug, MyCustomDerive)]</code></p>\n</blockquote>\n<p>This makes me wonder, actually, how common would it be for some to be const but others not be const?</p>\n<p>If one would need to have <code>#[derive(const Debug, const PartialEq, const Eq, const Hash, const Copy, const Clone)]</code> much of the time, I think it'd be nice to just have <code>#[const_derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]</code> anyway.</p>\n<p>(And then two attributes if you need some const and some non-const.)</p>",
        "id": 267623437,
        "sender_full_name": "scottmcm",
        "timestamp": 1641925101
    },
    {
        "content": "<p>I personally think we shouldn't be separating non-const derives from const derives if we were to stabilize it that way. what about <code>#[derive(const(Debug, PartialEq, Eq, Hash, Clone, Copy), Default)]</code>?</p>",
        "id": 267624554,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641925595
    },
    {
        "content": "<p>For what it's worth my viewpoint is now in favor of arbitrary tokens as a second parameter. I don't see having to repeat <code>const</code> as a huge cost, particularly given that each derive is its own logical item.</p>",
        "id": 267670684,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1641949917
    },
    {
        "content": "<p>Arbitrary tokens seems to be the simplest solution that provides const derives and <em>literally</em> anything else we might want in the future derive-wise.</p>",
        "id": 267670750,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1641949941
    }
]