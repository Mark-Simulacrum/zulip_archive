[
    {
        "content": "<p>I have mostly just been lurking here since the yield closures MCP, but I had an idea for pin-stuff that wold be interesting to run by people.</p>",
        "id": 257592980,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634240313
    },
    {
        "content": "<p>I was mostly just wondering how FnPin could be used by ordinary closures in addition to yield closures and fell down a pin-projection rabbithole</p>",
        "id": 257593089,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634240376
    },
    {
        "content": "<p>I'm not sure what proposals have been made in this direction, but it seems like it should be possible to have first-class pin projection and self-referential structs in the language with sorta minor additions</p>",
        "id": 257593237,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634240429
    },
    {
        "content": "<p>Random info-dump here: <a href=\"https://gist.github.com/samsartor/cc848e4d10a2dfb2228236a7f1654d4c\">https://gist.github.com/samsartor/cc848e4d10a2dfb2228236a7f1654d4c</a></p>",
        "id": 257593256,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634240438
    },
    {
        "content": "<p>Rust-for-linux project would really appreciate first class pinning</p>",
        "id": 257593598,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634240598
    },
    {
        "content": "<p>TL;DR you could have a perma/long-term-unstable &amp;pin reference type similar to Pin&lt;&amp;mut T&gt; which would handle projection, and then use traits/auto-ref to allow users to interact with it</p>",
        "id": 257593608,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634240602
    },
    {
        "content": "<p>We especially need ways to create pinned struct from the beginning, rather than creating it first and then pin it.</p>",
        "id": 257593747,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634240655
    },
    {
        "content": "<p>I have an experiment with macros here <a href=\"http://docs.rs/pin-init/\">docs.rs/pin-init/</a>, but needing macros for each construction isn't very ergonomic</p>",
        "id": 257593835,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634240707
    },
    {
        "content": "<p>Hmmm, I haven't been thinking in that direction yet. Actually I was trying to make it so the struct could exist as long as needed with placeholder values before being pinned and initialized fully.</p>",
        "id": 257593868,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634240726
    },
    {
        "content": "<p>Looking at <code>pin-init</code>, I think we'd need something more than just this proposal to make it ergonomic. The problem is all the <code>MaybeUinit</code> types everywhere which should be guaranteed to get initialized after pinning, right? With how I am picturing things now, you'd still have to juggle them manually.</p>",
        "id": 257596337,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634241734
    },
    {
        "content": "<p>I'm really struggling with any sort of idea which ties pinned-ness to initialized-ness. Such a requirement can't be imposed on <code>Pin</code> in retrospect, because functions like <code>Box::pin</code> can never be required to call initialization traits. And if &amp;pin adds that requirement alone, it breaks compatibility with <code>Pin</code> Then instead of &amp;pin being \"taking the sharp corners off of Pin transparently\",  it would become \"the alternate version of Pin we should have made in the first place\". Which I think is kinda unacceptable.</p>",
        "id": 257606135,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634245686
    },
    {
        "content": "<p>I think that means any feature for guaranteeing deep initialization must be orthogonal to guaranteeing fixed allocation.</p>",
        "id": 257606326,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634245771
    },
    {
        "content": "<p>&amp;out?</p>",
        "id": 257606671,
        "sender_full_name": "The 8472",
        "timestamp": 1634245918
    },
    {
        "content": "<p>Just realized the pin-init on <a href=\"http://docs.rs\">docs.rs</a> is still 0.1 since I forgot to publish 0.2 <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 257623224,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634254589
    },
    {
        "content": "<p>Thinking about this some more, I could be ok to require an explicit conversion from <code>Pin&lt;&amp;mut T&gt;</code> to <code>&amp;pin T</code>, which would perform initialization. And I like the nice symmetry of pinned types knowing both when they enter and leave their fixed allocation. We'd just have to consider the tradeoffs of migrating from <code>Pin</code> to <code>&amp;pin</code> vs trying to make them fully interchangeable.</p>",
        "id": 257735952,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634319439
    },
    {
        "content": "<p>Really I am fishing for someone to mentor an initiative of some kind lol</p>",
        "id": 257736246,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634319551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> it'd be helpful to see the code you are writing now (and perhaps a sketch of what code you would want to write)</p>",
        "id": 258230856,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634662346
    },
    {
        "content": "<p>I'm a bit '50/50' on integrating pin more deeply; I do see the appeal, but I'd like to understand the uses better, especially as I hope that we can move it further and further under the covers for async I/O</p>",
        "id": 258230926,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634662371
    },
    {
        "content": "<p>IMO, we want to put the Pin API under the covers only because it is so challenging to use. Lots more could be done with it if we made it friendly.</p>",
        "id": 258248985,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634668321
    },
    {
        "content": "<p>I agree that it could be made more friendly with some relatively limited improvements; however, I also think that a new <code>&amp;pin</code> reference type is a large \"surface area change\" to the language in some sense.</p>",
        "id": 258249405,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634668479
    },
    {
        "content": "<p>First example off the top of my head: type alias impl trait should allow users to put futures inside pinned structs. But that is a pain in practice because of pin projection. Most of the time people will probably continue to use <code>Box&lt;dyn Future&gt;</code> for futures inside structs.</p>",
        "id": 258249414,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634668483
    },
    {
        "content": "<p>Absolutely no doubt it would be a huge surface area change if stabilized.</p>",
        "id": 258249512,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634668520
    },
    {
        "content": "<p>That is why I wanted to emphasize you could get pin projection with perma-unstable <code>&amp;pin</code> just banking off auto-ref.</p>",
        "id": 258249596,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634668559
    },
    {
        "content": "<p>But guaranteed initialization does throw a wrench in that, lots of tradeoffs.</p>",
        "id": 258249731,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634668597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/first.20class.20pin/near/258230856\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> it'd be helpful to see the code you are writing now (and perhaps a sketch of what code you would want to write)</p>\n</blockquote>\n<p>In Linux kernel a lot of stuff are chained together by intrusive linked lists, and this includes <code>Mutex</code>es.  They have to pinned to be initialized. Currently we have to use a lot of unsafe code to achieve that, creating an uninitialized <code>Mutex</code>, pin it and then initialize it.</p>\n<p>This is how rust-for-linux could use pin-init: <a href=\"https://github.com/nbdd0121/linux/commit/549b8e36166d61a54c990a87cccc93021d968ac2\">https://github.com/nbdd0121/linux/commit/549b8e36166d61a54c990a87cccc93021d968ac2</a>.</p>\n<p>Given that pinned structs are everywhere in Linux kernel we feel that proc macro isn't the ideal solution and hopefully can have a first class support.</p>",
        "id": 258264735,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634674621
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> Thinking a bunch more about guaranteed pin init, I can see what is so nice about it:</p>\n<ul>\n<li>We want a wrapper type state to track initialization, <code>&amp;pin TypeToInit</code> wold do the trick.</li>\n<li>We want initialization state to \"project\", that is if you init a pinned <code>struct Foo { data: Mutex }</code>, you should init <code>data</code> as well.</li>\n</ul>\n<p>The problem is, so long as it is only safe to init once, there would be no way to convert to <code>&amp;pin</code> inside <code>Future::poll</code>: the existing Pin API can't ever guarantee init, and init can't happen inside poll because poll is called more than once. Even if we migrated to a new pin type over an edition using a new defaulted <code>poll_init</code> function or something, it wouldn't really be compatible with tokio, futures, etc.</p>\n<p>That being said, I think there is a nice way to make it work with a small additional library, and a fairly simple derive macro.</p>",
        "id": 258368318,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634737038
    },
    {
        "content": "<p>It could look something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(PinDefault)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Process</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">inner</span>: <span class=\"nc\">Mutex</span><span class=\"o\">&lt;</span><span class=\"n\">ProcessInner</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">refs</span>: <span class=\"nc\">Mutex</span><span class=\"o\">&lt;</span><span class=\"n\">ProcessNodeRefs</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">some_counter</span>: <span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">process</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">pin</span><span class=\"p\">(</span><span class=\"n\">Construct</span>::<span class=\"o\">&lt;</span><span class=\"n\">Process</span><span class=\"o\">&gt;</span>::<span class=\"n\">new</span><span class=\"p\">()).</span><span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">process</span><span class=\"p\">.</span><span class=\"n\">some_counter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">process</span><span class=\"p\">.</span><span class=\"n\">inner</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">().</span><span class=\"n\">do_stuff</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 258370873,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1634737944
    },
    {
        "content": "<p>Many structs couldn't be default-initialized though (or would need unnecessary <code>Option</code> wrapping and <code>unwrap</code> everywhere).</p>",
        "id": 258422941,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634756017
    }
]