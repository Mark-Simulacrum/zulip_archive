[
    {
        "content": "<p>Hello! I recently ran into some <a href=\"https://github.com/rust-lang/rust/issues/91877\">corner cases</a> with constant evaluation and <code>const_panic</code> and through working with folks to document things I've realized that it's unclear in what situations CTFE is guaranteed to happen and whether the guarantees are stabilized. Ralf Jung <a href=\"https://github.com/rust-lang/reference/pull/1147#issuecomment-1023622753\">encouraged</a> me to ask here.</p>\n<p>As implemented it currently looks like:</p>\n<p>1. Unnamed free constants (<code>const _: () = ...;</code>) always trigger CTFE<br>\n  2. Named free constants always trigger CTFE, even if unused<br>\n  3. For associated constants inside impl blocks, it triggers when it's referenced. Ralf Jung kindly provided some <a href=\"https://github.com/rust-lang/rust/issues/91877#issuecomment-995026270\">details</a> about that</p>\n<p>My question is, is the behavior in (1) and (2) actually stabilized? It feels like at least (1) is stabilized since it's used in <a href=\"https://github.com/rust-lang/rust/issues/89006\">the stabilization issue</a> for <code>const_panic</code> and in the release notes,  but I couldn't find explicit mentions.</p>",
        "id": 269640621,
        "sender_full_name": "Alan Wu",
        "timestamp": 1643318888
    },
    {
        "content": "<p>1&amp;2 are only behind a lint, they are not hard errors out of backwards compatibility reasons.</p>",
        "id": 269643677,
        "sender_full_name": "oli",
        "timestamp": 1643320171
    },
    {
        "content": "<p>Well, for <code>panic</code> specifically they are a hard error, but not for other failures</p>",
        "id": 269643889,
        "sender_full_name": "oli",
        "timestamp": 1643320205
    },
    {
        "content": "<p>We want to move to always making it a hard error, but the procedure is unclear. We should probably crater it and see if we can just get away with it</p>",
        "id": 269644292,
        "sender_full_name": "oli",
        "timestamp": 1643320283
    },
    {
        "content": "<p>3 is impossible to do eagerly in general, as it may depend on generic parameters</p>",
        "id": 269644469,
        "sender_full_name": "oli",
        "timestamp": 1643320320
    },
    {
        "content": "<p>Is (1) always evaluating the right hand side stabilized? If evaluation panics, it's a hard error, but I'm not sure if evaluation is guaranteed to happen at all.</p>",
        "id": 269645330,
        "sender_full_name": "Alan Wu",
        "timestamp": 1643320688
    },
    {
        "content": "<p>The result of it happening successfully and then having its result not used and not happening should be indistinguishable, no?</p>",
        "id": 269702833,
        "sender_full_name": "The 8472",
        "timestamp": 1643359173
    },
    {
        "content": "<p>Evaluation is guaranteed for free constants. We have a visitor whose sole purpose is doing this</p>",
        "id": 269707523,
        "sender_full_name": "oli",
        "timestamp": 1643361706
    },
    {
        "content": "<p>Thank you oli! I would like to add this guarantee about free constants to the reference. Do you think a FCP is warranted to make sure everyone is onboard with this is being a stable feature of the language like Ralf <a href=\"https://github.com/rust-lang/reference/pull/1147#issuecomment-1023622753\">suggested</a>? I'll need to review again, but I think currently there is nothing about this in the reference.</p>",
        "id": 269815071,
        "sender_full_name": "Alan Wu",
        "timestamp": 1643410728
    }
]