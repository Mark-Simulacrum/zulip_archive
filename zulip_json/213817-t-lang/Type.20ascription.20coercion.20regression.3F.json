[
    {
        "content": "<p>I have the following expression: <code>&amp;[85, 87, 90, 91]: &amp;[_]</code> I expect this to compile since <code>let g1: &amp;[_] = &amp;[86, 88, 89, 92];</code> also compiles, and type ascription should be a possible coercion site. Was this changed accidentally or deliberately? Or did it never work? (Note that as opposed to coercing trait objects, using <code>as</code> doesn't work here).</p>",
        "id": 271811023,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644836329
    },
    {
        "content": "<p>And follow-up, is there anyone to force the coercion without declaring a local variable?</p>",
        "id": 271811272,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644836445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/Type.20ascription.20coercion.20regression.3F/near/271811272\">said</a>:</p>\n<blockquote>\n<p>And follow-up, is there anyone to force the coercion without declaring a local variable?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">core</span>::<span class=\"n\">convert</span>::<span class=\"n\">identity</span>::<span class=\"o\">&lt;&amp;</span><span class=\"p\">[</span><span class=\"n\">_</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=d6770c2e773a3ed008d9e21f8b7ff9ad\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=d6770c2e773a3ed008d9e21f8b7ff9ad</a></p>",
        "id": 271815724,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644839386
    },
    {
        "content": "<p>So, as of <code>1.33</code>,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(type_ascription)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">normal</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">coerced</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">_</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>already failed <a href=\"https://rust.godbolt.org/z/sr8G6v6M8\">https://rust.godbolt.org/z/sr8G6v6M8</a>.</p>\n<p>So I guess that when you talk of regression is not <em>w.r.t.</em> a past implementation of the feature, but <em>w.r.t.</em> the semantics laid out in the RFC. As in, you'd expect <code>&lt;expr&gt; : &lt;ty&gt;</code> to behave kind of like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">expr</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">e</span>: <span class=\"o\">&lt;</span><span class=\"n\">ty</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">e</span><span class=\"w\"></span>\n<span class=\"p\">}}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>right? (or <code>identity::&lt;ty&gt;(&lt;expr&gt;)</code> (or <code>match &lt;expr&gt; { e: &lt;ty&gt; =&gt; e }</code> if ascriptions on patterns were a thing)). From looking at <a href=\"https://rust-lang.github.io/rfcs/0803-type-ascription.html\">the <code>ascription</code> RFC (<code>#803</code>)</a>, it does seem like <em>implicit</em> coercion is expected to be part of the features of type ascription, so you are right that the full RFC hasn't been implemented yet.</p>\n<p>Moreover, the last comment in that RFC's tracking issue is from Niko, who <a href=\"https://github.com/rust-lang/rust/pull/21836#issuecomment-172988891\">states</a>:</p>\n<blockquote>\n<p>(Note that this has now been implemented in <a href=\"https://github.com/rust-lang/rust/pull/30184\">#30184</a>, but without the coercion aspect.)</p>\n</blockquote>\n<p>And indeed <a href=\"https://github.com/rust-lang/rust/pull/30184\">#30814</a> states:</p>\n<blockquote>\n<p>So, you can't write things with coercions like <code>let slice = &amp;[1, 2, 3]: &amp;[u8];</code>. It obviously makes type ascription less useful than it should be, but it's still much more useful than not having type ascription at all.<br>\nIn particular, things like <code>let v = something.iter().collect(): Vec&lt;_&gt;;</code> and <code>let u = t.into(): U;</code> work as expected and I'm pretty happy with these improvements alone.</p>\n</blockquote>",
        "id": 271826138,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644845679
    },
    {
        "content": "<p>Note that some of these unsugarings would thus be allowed to <em>move</em> from a place:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// OK</span>\n\n<span class=\"c1\">// vs.</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"nc\">_</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Error, use of moved value?</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Error, use of moved value for sure.</span>\n</code></pre></div>\n<p>Is that desired?</p>",
        "id": 271826658,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644845957
    },
    {
        "content": "<p>(For reference, <code>as</code> casts do move / perform a place-to-value conversion even in the identity case; and the current implementation of <code>:</code> casts does not).</p>",
        "id": 271826855,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644846080
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> IMO only the last of your examples should cause a coercion, i.e. <code>e: _</code> should always be equivalent to <code>e</code> even if <code>e</code> is a place expression. Coercions should always be derivable from a top down reading of the code. If you tried to use <code>x</code> later in the second example as <code>&amp;Box&lt;dyn Send&gt;</code> you would get an error</p>",
        "id": 271905094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644881649
    },
    {
        "content": "<p>the RFC doesn't give an example with <code>: _</code> but it probably should</p>",
        "id": 271905299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644881809
    }
]