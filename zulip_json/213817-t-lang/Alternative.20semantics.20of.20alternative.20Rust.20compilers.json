[
    {
        "content": "<p>This is a follow-up to <a href=\"https://github.com/Rust-GCC/gccrs/issues/653#issuecomment-913965979\">https://github.com/Rust-GCC/gccrs/issues/653#issuecomment-913965979</a>, where <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> wrote</p>\n<blockquote>\n<p>Yes, -ffast-math changes the semantics, but not in a way that causes changes to the set of accepted programs, or similar compatibility issues; that combined with the fact that it isn't the default makes me not concerned about it. In general, I'd prefer if all Rust compilers stuck very precisely to the language semantics across the board. But in the interests of trying to make sure people and projects have room to experiment, I'd settle for all Rust compilers not changing language semantics in a way that causes some programs to work on some compilers and fail on others. That holds especially true when the change is a non-standard option, rather than the default behavior of that compiler. Another compiler choosing to expose a --give-slightly-wrong-answers flag won't cause problems in the Rust ecosystem, the way an --accept-incorrect-programs flag would.</p>\n</blockquote>\n<p>I am trying to understand why you think this would cause less trouble, because I think it causes <em>more</em> trouble. \"This\" being: two Rust compilers both accepting a program and giving distinct guaranteed semantics to it (i.e., I am not talking about non-determinism here). I think such a change in semantics has the potential to cause massive  problems in the Rust ecosystem: <code>--give-slightly-wrong-answers</code> will mean that Rust programs can suddenly misbehave but only in obscure situations that would not be discovered during testing. I think this is <em>worse</em> than an alternative compiler accepting more or less programs than rustc would; if compilation fails at least we know at compile time that something is wrong (this is basically just an experimental language extension, we have those all the time inside rustc). But I think it is crucial that <em>if</em> compilation succeeds, one can be sure of how the program will behave.<br>\nWith such a flag we can easily end up with some crates only working properly with default semantics, and some crates only working with <code>--give-slightly-wrong-answers</code> -- the same kind of ecosystem split we can have when alternative compilers accept more programs than rustc, but made worse by the fact that there is no way to tell if you accidentally ended up including a crate that requires the alternative compiler.</p>",
        "id": 253663773,
        "sender_full_name": "RalfJ",
        "timestamp": 1631833166
    },
    {
        "content": "<p>I admit that with fast-math specifically, it seems unlikely that a crate would work <em>only</em> with fast-math and fail to work with regular rustc. fast-math is somewhat of a special case here. But you phrased your statement as being about deviations from the standard language semantics in general, and against that I want to strongly push back.</p>",
        "id": 253664076,
        "sender_full_name": "RalfJ",
        "timestamp": 1631833296
    },
    {
        "content": "<p>Note that many compilers will expose different semantics and requirements via the command line by virtue of having different interfaces. ]<br>\nI think the canonical example would be the borrow checker:<br>\nmrustc is an example of a rust compiler that does not have a borrow checker at all. Not gated at invocation or build time, simply doesn't exist.<br>\nLikewise, the default lccc rust frontend won't come with a borrow checker out of the box (as it would just use a runtime plugin to call out to polonius which the host may not be able to build), and will have both configure time and invocation time options to enable or disable it (the invocation time option is likely less necessary, but the configure time option is to ensure that polonius doesn't end up dictating the build requirements for the rust frontend, making bootstrapping difficult).</p>\n<p>For runtime options, <code>-ffast-math</code> and similar does seem like a reasonable option: it cannot be set by crates, only users. This is true of any extension option that any alternative rust compiler provides, both in non-standard CLIs and rustc-like CLIs. <br>\nI plan a number myself for lccc, one notable one is <code>-Z build-abi</code> which affects the version of a guaranteed abi provided by lccc - someone could rely on this abi in a crate, which would break on non-lccc compilers (and on any version that changes the default abi version, or when the user specifies an abi-affecting flag on the command-line), but I personally see this as a non-issue, as the crate itself cannot set the flag, only the user. <br>\nA crate could, of course, detect the presense of the flag and use that to write optimized code relying on the abi, and fall back to a safe implementation (I do this myself within the standard library of lccc, I detect the abi version and whether randomized layout is enabled by generating a manifest file and reading it's <code>abi_version</code> field). If done correctly, however, this shouldn't cause issues as the test would fail on other compiles, so the fallback code would be selected. <br>\nYou could argue that a guaranteed abi is a guarantee an alternative rust compiler shouldn't make, however the abi is necessary within lccc (a primary use case was proc-macros, as the project was originally written in C++, though even while transition to rust the abi-safety is still a potential question, as the compiler may not be compiled by itself), and I refuse to ever make or rely on an undocumented internal guarantee - in my opinion that leads to Left-hand Right-hand bugs, or bugs when there are two sources of truth that disagree. With something like ABI that's a recipe for undefined behaviour.</p>",
        "id": 253667392,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631835544
    },
    {
        "content": "<p>An argument against <code>-ffast-math</code> specifically would be that it does, in fact, introduce new undefined behaviour over the rust language. However, this is notably the case in other programming languages (it is notably non-compliant with both the C and C++ standards to enable the option), and it is well-documented as such. I would expect such documentation to be sufficient to cover it.</p>",
        "id": 253667695,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631835760
    },
    {
        "content": "<p>yeah, i don't think just copying C++'s ffast-math behavior is a good model. I do think we need something to that effect (but honestly, IMO the finite-math-only flags are footguns, and probably should be either not part of it or a separate thing), but i'd rather it be integrated into the language more</p>",
        "id": 253686141,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631851283
    },
    {
        "content": "<p>(and tbh i kind of think specifying this might help clear up some of the \"situations\" rust currently has around non-ieee-compliant floats...)</p>",
        "id": 253686188,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631851322
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> To be clear, I'm not arguing that <code>-ffast-math</code> in particular is a great idea (it bundles together too many things), and also, I'd love to see some subsets of it added to rustc. But the case I was making is this:</p>",
        "id": 253686363,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631851459
    },
    {
        "content": "<p>I really don't want to see compilers changing language semantics in a way that accepts more or less programs; that changes the language itself. But <code>-ffast-math</code> does two things: 1) make the program faster and 2) make the results less accurate. (1) isn't an issue, and (2) is a quality-of-implementation issue: either it won't be an issue or it'll make people not want to use the option. The <em>existence</em> of the option can't bifurcate the ecosystem.</p>",
        "id": 253686511,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631851592
    },
    {
        "content": "<p>I'm contrasting that with something like <code>-fmake-borrow-checker-errors-into-warnings</code>, which would be extremely damaging, because it would accept a different language that isn't quite Rust, and lead to crates that only work on one compiler but not another.</p>",
        "id": 253686541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631851633
    },
    {
        "content": "<p>An option like <code>--give-slightly-wrong-answers</code> could make people want to use the compiler if there's a good reason for it, or could make people not want to use the option if it causes problems, but as long as it isn't the default I don't see how it does harm.</p>",
        "id": 253686628,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631851695
    },
    {
        "content": "<p>Now, if there were a <code>--give-slightly-more-right-answers</code> option, that could be a problem; people might depend on that, and it could cause a similar rift in the ecosystem. That's the kind of thing that ought to get coordinated, and if the semantics of it seem like something people would want or need, we could add it to the language.</p>",
        "id": 253686680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631851755
    },
    {
        "content": "<p>Note that mrustc gets a pass because it's not trying to be a compiler for all Rust code, but rather a compiler for rustc specifically.</p>",
        "id": 253689387,
        "sender_full_name": "isHavvy",
        "timestamp": 1631854160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/253686541\">said</a>:</p>\n<blockquote>\n<p>I'm contrasting that with something like <code>-fmake-borrow-checker-errors-into-warnings</code>, which would be extremely damaging, because it would accept a different language that isn't quite Rust, and lead to crates that only work on one compiler but not another.</p>\n</blockquote>\n<p>I mentioned basically this specifically, though an <code>-fno-borrowck</code> (invocation-time) or a <code>--disable-borrowck</code> (configure-time), rather than a demotion to warnings. The borrow checker is, imo, the most complicated and the least well-documented part of the rust language. Every implementation that I know of that plans to implement one at all plans to shell out to polonius to implement it. <br>\nIn lccc, the option to disable the borrow checker is present at the configuration level (enabled by default if the requirements for polonius are detected, disabled otherwise). Like many other configure time options, it has a invocation-time counterpart, when enabled at configuration-time.</p>",
        "id": 253725956,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631877315
    },
    {
        "content": "<p>(The reason for the option is simple, lccc, like every other alternative rust compiler I'm aware of that has one, implements the borrowchecker via polonius, but the requirements for polonius may not be satisfied by the host system when the requirements for the rest of the frontend and project are. Thus it switches based on feature detection and can be explicitly toggled by the person running configure)</p>",
        "id": 253726415,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631877564
    },
    {
        "content": "<p>It is reasonable to expect that such an option (from both sides) <em>could</em> lead to crates depending on it to compile, however, I don't expect it to be often as the default state is enabled and crates can't enable the flag themselves.</p>",
        "id": 253727227,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631877990
    },
    {
        "content": "<p>(Well, via cargo they can't. A project using rust-autotools or some other alternative build system could do so, but at that point, they could also detect the precense of lccc, gcc-rs, mrustc, or w/e, or could set some even more interesting options to then proceed to rely on)</p>",
        "id": 253727510,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631878173
    },
    {
        "content": "<blockquote>\n<p>But -ffast-math does two things: 1) make the program faster and 2) make the results less accurate. (1) isn't an issue, and (2) is a quality-of-implementation issue: either it won't be an issue or it'll make people not want to use the option. The existence of the option can't bifurcate the ecosystem.</p>\n</blockquote>\n<p>One person's \"less accurate\" is another person's \"wrong\". There is not really a clear line dividing this. And having a compiler that gives wrong answers can easily bifurcate the ecosystem in silent and hard to detect ways, once there are crates relying on the wrong answer.</p>",
        "id": 254085642,
        "sender_full_name": "RalfJ",
        "timestamp": 1632158481
    },
    {
        "content": "<p>Wouldn't it be the same as cpus that give wrong answers?</p>",
        "id": 254085729,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632158515
    },
    {
        "content": "<p>You can rely on wrong hardware semantics just as much as compiler optimizations.</p>",
        "id": 254085824,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632158542
    },
    {
        "content": "<p>sure</p>",
        "id": 254085867,
        "sender_full_name": "RalfJ",
        "timestamp": 1632158562
    },
    {
        "content": "<p>To be honest, with -ffast-math specifically, a lot of things affect the result of floating-point operations, especially where both contracted floating-point operations, and extended intermediate operands (FLT_EVAL_MODE in C). I'd find it hard to rely on the flag accidentally.</p>",
        "id": 254086800,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632158954
    },
    {
        "content": "<p>And it's always possible to deliberately rely on compiler differences. Just ask the compiler what it's version is.</p>",
        "id": 254086880,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632158991
    },
    {
        "content": "<p>(Unless you'd argue that compilers must avoid reporting the actual program name and copyright information with --version)</p>",
        "id": 254087116,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632159089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254085642\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But -ffast-math does two things: 1) make the program faster and 2) make the results less accurate. (1) isn't an issue, and (2) is a quality-of-implementation issue: either it won't be an issue or it'll make people not want to use the option. The existence of the option can't bifurcate the ecosystem.</p>\n</blockquote>\n<p>One person's \"less accurate\" is another person's \"wrong\". There is not really a clear line dividing this. And having a compiler that gives wrong answers can easily bifurcate the ecosystem in silent and hard to detect ways, once there are crates relying on the wrong answer.</p>\n</blockquote>\n<p>I'm not arguing that \"less accurate\" isn't wrong; it absolutely is. I'm just suggesting that it'd be extremely unlikely for code to somehow rely specifically on that wrong answer, especially given that <code>-ffast-math</code> isn't the default.</p>",
        "id": 254087258,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159146
    },
    {
        "content": "<p>Someone would have to use a different compiler, use a non-standard option for that compiler, and then somehow rely specifically on an exact floating-point result produced by that combination of compiler and options. That seems extremely unlikely.</p>",
        "id": 254087911,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159392
    },
    {
        "content": "<p>Indeed, and, as I mentioned, even more difficult to rely on accidentally.</p>",
        "id": 254088018,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632159435
    },
    {
        "content": "<blockquote>\n<p>Someone would have to use a different compiler, use a non-standard option for that compiler,</p>\n</blockquote>\n<p>true... but the same argument would then apply to non-default compiler flags that make the compiler accept more programs</p>",
        "id": 254088197,
        "sender_full_name": "RalfJ",
        "timestamp": 1632159487
    },
    {
        "content": "<p>Right. You'd really have to go out of your way, or you'd have to have a very specialized algorithm that may or may not stabilize with slightly different floating-point results. Which is absolutely possible, but why would you compile such an algorithm with <code>-ffast-math</code> <em>and</em> rely on it <em>and</em> not test with rustc or without <code>-ffast-math</code>.</p>",
        "id": 254088207,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159490
    },
    {
        "content": "<p>With -ffast-math the compiler is allowed to just ignore it. It relaxes a guarantee the compiler normally gives. It doesn't strengthen it.</p>",
        "id": 254088265,
        "sender_full_name": "bjorn3",
        "timestamp": 1632159514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088197\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Someone would have to use a different compiler, use a non-standard option for that compiler,</p>\n</blockquote>\n<p>true... but the same argument would then apply to non-default compiler flags that make the compiler accept more programs</p>\n</blockquote>\n<p>But non-defalut compiler flag that make the compiler accept more programs are something people may seek out and <em>seek</em> to rely on.</p>",
        "id": 254088284,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159522
    },
    {
        "content": "<p>Versus something like <code>-ffast-math</code> which isn't designed to be a thing people rely on the semantics of. It's designed to be a thing you <em>can't</em> rely on the semantics of. :)</p>",
        "id": 254088378,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088265\">said</a>:</p>\n<blockquote>\n<p>With -ffast-math the compiler is allowed to just ignore it. It relaxes a guarantee the compiler normally gives. It doesn't strengthen it.</p>\n</blockquote>\n<p>With -fno-borrowchecker the compiler is not allowed to ignore it as it guarantees that code not passing the borrowchecker will compile.</p>",
        "id": 254088438,
        "sender_full_name": "bjorn3",
        "timestamp": 1632159584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088207\">said</a>:</p>\n<blockquote>\n<p>Right. You'd really have to go out of your way, or you'd have to have a very specialized algorithm that may or may not stabilize with slightly different floating-point results. Which is absolutely possible, but why would you compile such an algorithm with <code>-ffast-math</code> <em>and</em> rely on it <em>and</em> not test with rustc or without <code>-ffast-math</code>.</p>\n</blockquote>\n<p>Or a <code>-ffast-math</code> option on a different compiler that may do different things. Or a different version of the same compiler.</p>",
        "id": 254088463,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632159596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088438\">said</a>:</p>\n<blockquote>\n<p>With -fno-borrowchecker the compiler is not allowed to ignore it as it guarantees that code not passing the borrowchecker will compile.</p>\n</blockquote>\n<p>Well, the compiler can reject the option.</p>",
        "id": 254088619,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632159652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088378\">said</a>:</p>\n<blockquote>\n<p>Versus something like <code>-ffast-math</code> which isn't designed to be a thing people rely on the semantics of. It's designed to be a thing you <em>can't</em> rely on the semantics of. :)</p>\n</blockquote>\n<p>okay that is a distinction I can find myself agreeing with much more. it seems only tangentially related to whether it changes the set of accepted programs or not.</p>",
        "id": 254088635,
        "sender_full_name": "RalfJ",
        "timestamp": 1632159663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Exactly. And someone might seek that out because they're struggling with the borrow-checker and still in the mindset of \"I know what I'm doing, the compiler should just let me do it\", and then find an option that does just that...</p>",
        "id": 254088642,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088635\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254088378\">said</a>:</p>\n<blockquote>\n<p>Versus something like <code>-ffast-math</code> which isn't designed to be a thing people rely on the semantics of. It's designed to be a thing you <em>can't</em> rely on the semantics of. :)</p>\n</blockquote>\n<p>okay that is a distinction I can find myself agreeing with much more. it seems only tangentially related to whether it changes the set of accepted programs or not.</p>\n</blockquote>\n<p>I think it's closely related. A thing that changes the set of accepted programs is much more likely to be relied on.</p>",
        "id": 254088743,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159705
    },
    {
        "content": "<p>-ffast-math shrinks the set of programs that compile without UB. -fno-borrowchecker expands it. You can't rely on -ffast-math being used, because if your program was well behaved with it for all possible compilers, it will still be well behaved without it. You can rely on -fno-borrowchecker being used, because some programs will no longer work without it.</p>",
        "id": 254089075,
        "sender_full_name": "bjorn3",
        "timestamp": 1632159837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  do you consider UB-removing flags to be \"changing the set of accepted programs\"?</p>",
        "id": 254089166,
        "sender_full_name": "RalfJ",
        "timestamp": 1632159860
    },
    {
        "content": "<p>(as in, is \"accepting\" a static notion or does it include UB-freedom)</p>",
        "id": 254089228,
        "sender_full_name": "RalfJ",
        "timestamp": 1632159885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> As in, something that changes UB to defined behavior, such that you can write a program using that behavior without invoking UB?</p>",
        "id": 254089260,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159900
    },
    {
        "content": "<p>IMO \"accepting\" includes UB-freedom.</p>",
        "id": 254089284,
        "sender_full_name": "bjorn3",
        "timestamp": 1632159908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089075\">said</a>:</p>\n<blockquote>\n<p>-ffast-math shrinks the set of programs that compile without UB. -fno-borrowchecker expands it. You can't rely on -ffast-math being used, because if your program was well behaved with it for all possible compilers, it will still be well behaved without it. You can rely on -fno-borrowchecker being used, because some programs will no longer work without it.</p>\n</blockquote>\n<p>You could also rely on mrustc, or a version of some compiler compiled without a borrow checker at all (which is what lccc provides: <code>--disable-borrowck</code> doesn't build or include the borrow checker at all)</p>",
        "id": 254089324,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632159921
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Yes, I would absolutely consider that to be \"changing the set of accepting programs\".</p>",
        "id": 254089477,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632159971
    },
    {
        "content": "<p>As much as there are things that are currently UB that I'd love to define <em>in Rust</em>, to the extent we haven't defined those things yet, a non-standard compiler option to enable them would have that same risk of bifurcating the ecosystem.</p>",
        "id": 254089551,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089260\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> As in, something that changes UB to defined behavior, such that you can write a program using that behavior without invoking UB?</p>\n</blockquote>\n<p>Note that I'd argue this is a fundamental freedom of having undefined behaviour =&gt; Undefined Behaviour leaves the behaviour of the program undefined, up to the implementation. A natural collary is that it allows the implementation to ascribe a particular guaranteed behaviour to that result.</p>",
        "id": 254089615,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160035
    },
    {
        "content": "<p>okay. well then I have a hard time coming up with other realistic examples for semantics-changing flags... I dont necessarily agree that those are inherently less likely to be relied upon, its more than we only have one real example and that has a bunch of facts making less of an issue^^</p>",
        "id": 254089676,
        "sender_full_name": "RalfJ",
        "timestamp": 1632160060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089615\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089260\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> As in, something that changes UB to defined behavior, such that you can write a program using that behavior without invoking UB?</p>\n</blockquote>\n<p>Note that I'd argue this is a fundamental freedom of having undefined behaviour =&gt; Undefined Behaviour leaves the behaviour of the program undefined, up to the implementation. A natural collary is that it allows the implementation to ascribe a particular guaranteed behaviour to that result.</p>\n</blockquote>\n<p>That's not the same thing. An implementation is free to do something different, because it's not defined. But if an implementation tries to <em>define</em> it and make that a <em>guarantee</em>, that's a semantic change to the language.</p>",
        "id": 254089699,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160075
    },
    {
        "content": "<p>Well, it depends on why it defines it.</p>",
        "id": 254089792,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089676\">said</a>:</p>\n<blockquote>\n<p>okay. well then I have a hard time coming up with other realistic examples for semantics-changing flags... I dont necessarily agree that those are inherently less likely to be relied upon, its more than we only have one real example and that has a bunch of facts making less of an issue^^</p>\n</blockquote>\n<p>I can think of a few. For instance, consider an option that always initializes variables to 0, and lets you write something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 254089906,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160160
    },
    {
        "content": "<p>that changes the set of accepted programs</p>",
        "id": 254090057,
        "sender_full_name": "RalfJ",
        "timestamp": 1632160221
    },
    {
        "content": "<p><code>-fno-mutable-aliasing</code></p>",
        "id": 254090163,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160269
    },
    {
        "content": "<p>likewise (removes UB)</p>",
        "id": 254090198,
        "sender_full_name": "RalfJ",
        "timestamp": 1632160283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254090198\">said</a>:</p>\n<blockquote>\n<p>likewise (removes UB)</p>\n</blockquote>\n<p><code>-Z mutable-noalias=no</code></p>",
        "id": 254090244,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254089792\">said</a>:</p>\n<blockquote>\n<p>Well, it depends on why it defines it.</p>\n</blockquote>\n<p>no -- changing the set of UB is always a language change. there is a hierarchy here, where a compiler that is correct for \"Rust with less UB\" is also always a correct compiler for \"real Rust\". but that does not change the fact that these are 2 distinct languages.</p>",
        "id": 254090477,
        "sender_full_name": "RalfJ",
        "timestamp": 1632160397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think by definition anything that turns UB into defined behavior changes the set of \"valid\" programs. Are you looking specifically for things that would not change the set of \"accepted\" programs, insofar as rustc \"accepts\" the program but the resulting compiled code invokes UB?</p>",
        "id": 254090501,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160409
    },
    {
        "content": "<p>well I was looking for something that would fall in the category of fast-math. you claim that that category in general is less likely to be relied upon, but I cant even come up with another realistic example.^^</p>",
        "id": 254090732,
        "sender_full_name": "RalfJ",
        "timestamp": 1632160490
    },
    {
        "content": "<p>Ah, I see! You're looking for options that <em>don't</em> do any harm.</p>",
        "id": 254090794,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160521
    },
    {
        "content": "<p>I can think of a lot of those.</p>",
        "id": 254090804,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160525
    },
    {
        "content": "<p>One moment...</p>",
        "id": 254090811,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160527
    },
    {
        "content": "<p>I'd argue that any compiler option or change in behaviour that can be observed at all can be relied upon.</p>",
        "id": 254091058,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254091058\">said</a>:</p>\n<blockquote>\n<p>I'd argue that any compiler option or change in behaviour that can be observed at all can be relied upon.</p>\n</blockquote>\n<p>Potentially, yes, but not everything that could be observed and <em>theoretically</em> relied upon is likely to cause issues.</p>",
        "id": 254091135,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160642
    },
    {
        "content": "<p>You can 100% observe the difference in code using <code>-C opt-level=0</code> vs.<code>-C opt-level=3</code> could be relied upon to an extent that breaks if one is used rather than the other.</p>",
        "id": 254091194,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160674
    },
    {
        "content": "<p>\"disable the borrow checker\" or \"allow mutable aliasing\" or \"allow use of uninitialized variables\" or similar change semantics in a way that would absolutely lead programs to rely on them if used.</p>",
        "id": 254091195,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632160675
    },
    {
        "content": "<p>I'd also ask what the difference would be between an option of a non-standard CLI, or of a <code>-Z</code> or <code>-Z</code> enabled option is, vs. say <code>#[feature]</code>, which can basically do the same thing. I could just as easily write <code>#![feature(disable_borrow_rules)]</code> and provide that in a compiler, instead of just a <code>-Z borrowck=no</code> option.</p>",
        "id": 254091755,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632160859
    },
    {
        "content": "<p>Both are compiler-specific, both are obviously unstable (except maybe the non-standard CLI version), and only the latter can be imposed at the crate level when using standard cargo.</p>",
        "id": 254092183,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632161029
    },
    {
        "content": "<p>Well, one difference is that we're not likely to add a <code>-Z borrowck=no</code> option, and we're even less likely to stabilize it. :)</p>",
        "id": 254093118,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161419
    },
    {
        "content": "<p>But in any case, <code>-Z</code> options and similar nightly-only features are the actual process by which we evolve Rust semantics, and they're intentionally presented as unstable and can break at any time, and thus we discourage people from relying on their semantics.</p>",
        "id": 254093226,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161466
    },
    {
        "content": "<p>Well, compilers can (and rustc already does, distinct from the language features) add their own unstable features. <code>#[feature(stability_attributes)]</code> comes to mind</p>",
        "id": 254093255,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632161478
    },
    {
        "content": "<p>And despite that, people <em>do</em> already write code to rely on nightly features, and that code only builds on nightly Rust.</p>",
        "id": 254093297,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161499
    },
    {
        "content": "<p>Well yes, and specifically nightly rustc.</p>",
        "id": 254093402,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632161527
    },
    {
        "content": "<p>Imo, unstable options and unstable features both represent an opt-in to non-portability, not just instability.</p>",
        "id": 254093487,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632161567
    },
    {
        "content": "<p>(I'm still intentionally using those terms synonymously, yes.)</p>",
        "id": 254093496,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161570
    },
    {
        "content": "<p>Yes, and on top of that, Rust's mechanism for ensuring that you can't use nightly options on a stable compiler makes it even less likely that people will rely on them.</p>",
        "id": 254093603,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161619
    },
    {
        "content": "<p>There are, by design, programs that rely on nightly, because they need that support. The authors of those programs are the same people who help push for those options to be stabilized.</p>",
        "id": 254093948,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161739
    },
    {
        "content": "<p>So then my argument is that a user setting the <code>-Z borrowck=no</code> option would implicitly accept the burden of portability, or lack thereof, just like one using a <code>#![feature(disable_borrow_rules)]</code> would (keeping the <code>-fno-borrowck</code> version out of this, because the gcc CLI is inherently non-portable, so imo, the behaviour of <code>-Z</code> options would extend to them)</p>",
        "id": 254094221,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632161846
    },
    {
        "content": "<p>And even taking all that into account, it would still be hazardous for us to introduce an option that we're <em>never</em> likely to stabilize, if people are going to start relying on it.</p>",
        "id": 254094224,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> GCC doesn't have any similar mechanism for distinguishing nightly versus stable, though. If an option exists for experimentation purposes, it'll get released as part of the next GCC release, and people can start relying on its semantics.</p>",
        "id": 254094398,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161914
    },
    {
        "content": "<p>If such options only existed when you build a GCC nightly snapshot, that'd be much less likely for people to start relying on, rather than just testing as part of the development and evolution process.</p>",
        "id": 254094454,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632161943
    },
    {
        "content": "<p>(That's one of a few possible approaches that could potentially help mitigate the chances of people relying on non-standard options and the corresponding semantics.)</p>",
        "id": 254094580,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Another potentially interesting option that I can imagine a compiler providing would be one that guarantees tail-call optimization. Programs could easily rely on that, by writing recursive algorithms that would otherwise run out of stack. So that has the same kind of problem.</p>",
        "id": 254094870,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162101
    },
    {
        "content": "<p>Another option in the vein of <code>-ffast-math</code> where people <em>could</em> rely on it but probably won't: <code>-falign-functions</code>.</p>",
        "id": 254095363,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162300
    },
    {
        "content": "<p>You could, for instance, align all functions to 32-byte boundaries, and then write code that relies on that, by using the lower 5 bits of function pointers.</p>",
        "id": 254095469,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162340
    },
    {
        "content": "<p>A crate using gcc's gcc CLI wouldn't work with conventional tooling anyways, directly.<br>\nOf course, adaptors are being worked on (cargo-gccrs is one, I'm writing one for a couple of projects, though they wouldn't be directly used with pure-cargo projects), which may run into the same point.</p>",
        "id": 254095713,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632162424
    },
    {
        "content": "<p>I'd expect that <code>cargo-gccrs</code> wrapper to get used (and be a primary way people invoke gccrs), and it's more-or-less running cargo with a wrapper that behaves like rustc.</p>",
        "id": 254095924,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162499
    },
    {
        "content": "<p>As for the stable vs. nightly, it would also impact <code>#[feature]</code>s in the same way (stable/beta rustc doesn't accept those either, but nightly/dev does), so this is more of a fundamental issue with compilers that don't make this distinction (of course, I'd argue it should be unnecessary to do so). </p>\n<p>I likewise don't distinguish between the two modes in lccc's rust frontend.<br>\nIn theory, binary versions of either could be built in a stable-only configuration, but as both are primarily intended for from-source builds rather than binary distribution (though I would expect gcc-rs to be distributed by distro package amangers), that option would have to be up to the person building the program to set, and it would, of course, require an opt-out for stdlib building purposes. <br>\nMy intention is not to provide this option as a matter of lack of necessity; I am unaware of any consideration on this matter from gcc-rs.</p>",
        "id": 254096254,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632162635
    },
    {
        "content": "<p>I'm not arguing that it's a necessity. I'm just observing that it <em>contributes</em> to the likelihood of an option creating an issue and leading people to rely on it.</p>",
        "id": 254096554,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Despite <code>-falign-functions</code> potentially affecting semantics in a way people can rely on, I don't think such an option is likely to cause any serious issue, for a few different reasons.</p>",
        "id": 254096613,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632162796
    },
    {
        "content": "<p>It's very much in the vein of \"optional hack\", and it's so very simple to <em>not</em> rely on it; the delta it represents is so small that making a non-specialized program that inherently relies on it seems exceedingly unlikely.</p>",
        "id": 254097495,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632163178
    },
    {
        "content": "<p>I see, makes sense</p>",
        "id": 254290023,
        "sender_full_name": "RalfJ",
        "timestamp": 1632264650
    },
    {
        "content": "<p>I actually had a question reguarding this.<br>\nSo an option like -Z borrowck=no wouldn't be a good idea as demonstrated above, but what about --disable-borrowck (configure option removing borrowck support altogether, so basically mrustc). I noted previously that lccc has this option (and some logic to enable/disable it by default, depending on rustc version) to avoid elevating build requirements, particularly when bootstrapping (lccc is ideally buildable with mrustc or one step away).</p>",
        "id": 254293939,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632267291
    },
    {
        "content": "<p>I think if there was some bootstrapping reason why it was important, such as building without it to then use that compiler to build polonius for a stage 2 build, that would make sense. But shipping that as a Rust compiler would cause problems.</p>",
        "id": 254298245,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632270420
    },
    {
        "content": "<p>(Note that in lccc, the default build is not a bootstrap build as with gcc or rustc, rather the default build is a single stage like llvm is - this behaviour is controlled by the <code>--enable-boostrap</code> (which is disabled by default)  flag, or else can be performed manually. Bootstrapping here refers to building the compiler from a chain starting with a language other than rust)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254298245\">said</a>:</p>\n<blockquote>\n<p>I think if there was some bootstrapping reason why it was important, such as building without it to then use that compiler to build polonius for a stage 2 build, that would make sense. But shipping that as a Rust compiler would cause problems.</p>\n</blockquote>\n<p>This sort of depends what is meant by \"shipping\". As I noted previously, lccc is intended for source distributation rather than binary distribution, so in theory, the rust frontend is \"shipped\" with both options, and you'd choose this at the site. By default, of course, it will build the borrow checker if it detects that the host rust compiler (<code>$RUSTC</code> or <code>$RUSTC_FOR_BUILD</code>) is sufficiently capable of building polonius (if it's unsure, it will emit an error asking for one option or the other, though it will disable it for known bad <code>$RUSTC</code>s).</p>",
        "id": 254299530,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632271514
    },
    {
        "content": "<p>Is the <code>-ffast-math</code> under discussion here one that makes basic math on floating-point be potentially UB?  Or to produce garbage results?  Or is it just doing things like FMA and replacing division with reciprocals?</p>\n<p>Because I feel like they're very different conversations.</p>",
        "id": 254412675,
        "sender_full_name": "scottmcm",
        "timestamp": 1632334408
    },
    {
        "content": "<p>I believe that in gcc/clang, -ffast-math makes certain operations Undefined Behaviour (specifically, it turns on -ffinite-math-only which makes it UB for an operation to produce an infinite or NaN result)</p>",
        "id": 254413283,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632334668
    },
    {
        "content": "<p>(Which, in rust, would imply the flag is unsound. The idea is that code that cares wouldn't have issues with it)</p>",
        "id": 254413503,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632334746
    },
    {
        "content": "<p>seems like, fitting into the larger Rust language, that's something that should go on functions/modules, not the entire compilation</p>",
        "id": 254421634,
        "sender_full_name": "Lokathor",
        "timestamp": 1632337841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/254413503\">said</a>:</p>\n<blockquote>\n<p>(Which, in rust, would imply the flag is unsound. The idea is that code that cares wouldn't have issues with it)</p>\n</blockquote>\n<p>This is what scares me, yeah.  Anything that allows UB from safe code -- even if opted into from a compiler flag -- isn't something that would make me happy.  And <code>f32: Add</code>, so we can't really even say \"well the <code>+</code> becomes <code>unsafe</code> for floats\".</p>",
        "id": 257402442,
        "sender_full_name": "scottmcm",
        "timestamp": 1634145044
    },
    {
        "content": "<p>Isn't there precedent for compiler flags being unsafe (such as -C target-feature)?</p>",
        "id": 257410091,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634148030
    },
    {
        "content": "<p>not really. in the case of target feature the entire program is still safe, you just need a higher minimum CPU. However, all programs always have implied minimum CPU requirements you're expected to meet before you even begin to discuss soundness.</p>",
        "id": 257447995,
        "sender_full_name": "Lokathor",
        "timestamp": 1634163584
    },
    {
        "content": "<p>If you build a program for x86 and try to run it on an ARM device... when things go wrong that's not because of an unsound part of the program, that's a simple user error.</p>",
        "id": 257448230,
        "sender_full_name": "Lokathor",
        "timestamp": 1634163704
    },
    {
        "content": "<p>Well, <code>-C target-cpu</code> can cause ABI mismatches with floating-point types on i686, even if we don't call entering code with a particular target-feature enabled UB if it is not actually present (which is what I would argue is the semantics).</p>",
        "id": 257452277,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634166047
    },
    {
        "content": "<p>I <em>would</em> call it UB to enter code compiled for a feature level that the CPU doesn't support, but I still would not call the flag itself unsafe just because the binary could potentially be misused after the compilation completes.</p>\n<p>In the case of the floating point stuff on i686, yeah I guess that's essentially a linking error being caused by the flag, so I suppose the flag should count as unsafe, or at least \"dangerous\" (if we want to reserve unsafe for specifically Rust code related concerns).</p>",
        "id": 257469283,
        "sender_full_name": "Lokathor",
        "timestamp": 1634177985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Alternative.20semantics.20of.20alternative.20Rust.20compilers/near/257469283\">said</a>:</p>\n<blockquote>\n<p>In the case of the floating point stuff on i686, yeah I guess that's essentially a linking error being caused by the flag, so I suppose the flag should count as unsafe, or at least \"dangerous\" (if we want to reserve unsafe for specifically Rust code related concerns).</p>\n</blockquote>\n<p>It's not even a linker error. <a href=\"https://godbolt.org/z/eKzzajPzE\">https://godbolt.org/z/eKzzajPzE</a></p>",
        "id": 257497507,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634199798
    },
    {
        "content": "<p>I am aware it's not a literal error code produced by the linker. however, a symbol was declared to be available using a particular signature and then the linker was provided an object file that contains the symbol but under some other signature. So I would say that it's an issue in the linking stage of the compilation. If a correct object file were provided to the linker instead then there would have been no problem.</p>",
        "id": 257539914,
        "sender_full_name": "Lokathor",
        "timestamp": 1634220054
    }
]