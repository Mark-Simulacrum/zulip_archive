[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> That kind of two-phase compilation without knowledge of code generation isn't something that Rust currently contemplates, given the need to handle cfg and similar very early.</p>",
        "id": 270223767,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727434
    },
    {
        "content": "<p>It would, as you note, require full knowledge of certain features in the first compile.</p>",
        "id": 270223902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727483
    },
    {
        "content": "<p>Anything rust has a cfg for.</p>",
        "id": 270223938,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727499
    },
    {
        "content": "<p>That's why xlang_target handles all of the target specific information. It has all of the cfgs rustc sets, a few more than lccc sets with a flag (<code>target_int_width</code>, <code>target_long_width</code> via <code>-Z set-cfg-properties-widths</code>), and basically all the information that it needs to be consistent.</p>",
        "id": 270224159,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643727601
    },
    {
        "content": "<p>(It knows about int/long/long long/long double width because the C frontend needs to know this)</p>",
        "id": 270224443,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643727675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270201381\">said</a>:</p>\n<blockquote>\n<p>Maybe a <code>#[cfg(compiler_asm_supported)]</code> could quickly be introduced for the optimization case?</p>\n</blockquote>\n<p><code>asm!</code> is target-specific, and I'd expect it to be supported on a target-by-target basis. People won't use it on a target that Rust doesn't support it on, but once Rust supports it on a target, I'd expect it to work on any backend for that target. We did carefully define it in a way that made it possible for any backend to support, so I don't think we should start adding a mechanism for backends to opt out and expecting crates to use that (which I don't expect them to do).</p>",
        "id": 270224618,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727737
    },
    {
        "content": "<blockquote>\n<p>carefully define it in a way that made it possible for any backend to support</p>\n</blockquote>\n<p>Heh.</p>",
        "id": 270224708,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643727772
    },
    {
        "content": "<p>I didn't say \"support in the way that backend would prefer to support\". :)</p>",
        "id": 270224746,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727787
    },
    {
        "content": "<p>It's always <em>possible</em> to spawn an external assembler, even if it isn't preferable.</p>",
        "id": 270224776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270224776\">said</a>:</p>\n<blockquote>\n<p>It's always <em>possible</em> to spawn an external assembler, even if it isn't preferable.</p>\n</blockquote>\n<p>Unless you don't <em>have</em> one that is compatible.</p>",
        "id": 270224806,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643727815
    },
    {
        "content": "<p>If I'm on msvc host/target, I at best know I have <code>ml.exe</code>. Which is definately not GNU as compatible in the slightest.</p>",
        "id": 270225002,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643727882
    },
    {
        "content": "<p>And it is more than preferable that lccc not introduce any additional non-vendored runtime dependencies that the C compiler for a particular platform itself has - it's basically necessary to compete in that space.</p>",
        "id": 270225167,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643727948
    },
    {
        "content": "<p>You could always emit an error if and only if someone uses <code>asm!</code> saying that they need to install llvm-as.</p>",
        "id": 270225310,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727988
    },
    {
        "content": "<p>Again, not saying it's ideal, just that it's <em>possible</em>.</p>",
        "id": 270225338,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643727998
    },
    {
        "content": "<p>You could also ship a separate binary that links to LLVM and internally uses its asm support, if you prefer to put it in your own wrapper interface.</p>",
        "id": 270225435,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728024
    },
    {
        "content": "<p>That also means that asm requires to be run on a host that supports either llvm or gnu as.</p>",
        "id": 270225504,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728045
    },
    {
        "content": "<p>Why is it called <code>asm!</code> instead of <code>llvm_asm!</code>? It's apparently still tied up with LLVM</p>",
        "id": 270225700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728094
    },
    {
        "content": "<p>at least if <code>llvm_asm!</code> got stabilized then it would make sense for it to be explicitly non-portable to other backends</p>",
        "id": 270225812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728127
    },
    {
        "content": "<p>The platform I can think of that being the case on is wasm, which I definately do want to support hosting on.</p>",
        "id": 270225830,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225830\">said</a>:</p>\n<blockquote>\n<p>The platform I can think of that being the case on is wasm, which I definately do want to support hosting on.</p>\n</blockquote>\n<p>LLVM should run just fine in WebAssembly.</p>",
        "id": 270225909,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225700\">said</a>:</p>\n<blockquote>\n<p>Why is it called <code>asm!</code> instead of <code>llvm_asm!</code>? It's apparently still tied up with LLVM</p>\n</blockquote>\n<p>Or do what C++ does, which is just say its <em>conditionally-supported</em> with <em>implementation-defined</em> semantics.</p>",
        "id": 270225982,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225982\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225700\">said</a>:</p>\n<blockquote>\n<p>Why is it called <code>asm!</code> instead of <code>llvm_asm!</code>? It's apparently still tied up with LLVM</p>\n</blockquote>\n<p>Or do what C++ does, which is just say its <em>conditionally-supported</em> with <em>implementation-defined</em> semantics.</p>\n</blockquote>\n<p>A world of <em>nope</em> to anything \"implementation-defined\" in Rust.</p>",
        "id": 270226146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728213
    },
    {
        "content": "<p>I'm hoping to make <code>asm!</code> future compatible with a version that is actually backend-portable (by parsing the string and supporting a portable subset); would the C++ word salad enable that?</p>",
        "id": 270226261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728252
    },
    {
        "content": "<p>To the extent we have a Rust spec in the future, I'm very much hoping it's \"here's exactly how Rust works, with no wiggle-room and no implementation-specific variation\".</p>",
        "id": 270226264,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728254
    },
    {
        "content": "<p>A lot of things are already implementation-defined.<br>\nWhether or not overflow is panic or wrapping is implementation-defined.<br>\nThe target is implementation-defined.<br>\nArguably, <code>size_of::&lt;usize&gt;()</code>/pointers is implementation-defined (but constrained on well-known targets).</p>",
        "id": 270226405,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728307
    },
    {
        "content": "<p>And even more things are unspecified, which is implementation-defined but not required to be documented:<br>\nLayout of repr(Rust) types and of tuples.<br>\nABI of <code>extern \"Rust\"</code> functions.</p>",
        "id": 270226582,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728354
    },
    {
        "content": "<p>I am deeply concerned about the effect of the current version of <code>asm!</code> wrt the eventual specification. The PR is underspecified regarding the legal syntax in those strings, and I can't see how you would avoid copy-pasting the entire specification of GNU <code>as</code> into rust's spec. Plus I'm not even sure such a GNU <code>as</code> spec even exists</p>",
        "id": 270226617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728365
    },
    {
        "content": "<p>At the moment, <code>size_of::&lt;usize&gt;()</code> is well-defined in one way; we're <em>talking</em> about making it well-defined with a <em>different</em> meaning, but it's not implementation-defined.</p>",
        "id": 270226619,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226617\">said</a>:</p>\n<blockquote>\n<p>I am deeply concerned about the effect of the current version of <code>asm!</code> wrt the eventual specification. The PR is underspecified regarding the legal syntax in those strings, and I can't see how you would avoid copy-pasting the entire specification of GNU <code>as</code> into rust's spec. Plus I'm not even sure such a GNU <code>as</code> spec even exists</p>\n</blockquote>\n<p>People actually <em>use</em> those assembler directives in inline assembler; there are important mechanisms you can't achieve without them.</p>",
        "id": 270226712,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728402
    },
    {
        "content": "<p>Unless the spec codifies the exhaustive list of targets that an implementation is permitted to support, which I would be very much against, you will necessarily have implementation-defined behaviour.</p>",
        "id": 270226753,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728419
    },
    {
        "content": "<p>I'm not saying you can't use directives. I'm saying that you should document what directives are supported</p>",
        "id": 270226772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226582\">said</a>:</p>\n<blockquote>\n<p>And even more things are unspecified, which is implementation-defined but not required to be documented:<br>\nLayout of repr(Rust) types and of tuples.<br>\nABI of <code>extern \"Rust\"</code> functions.</p>\n</blockquote>\n<p>For the purposes of a spec, those are \"not a thing you can depend on at all\", rather than \"implementation-defined\".</p>",
        "id": 270226788,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226772\">said</a>:</p>\n<blockquote>\n<p>I'm not saying you can't use directives. I'm saying that you should document what directives are supported</p>\n</blockquote>\n<p>We did: \"the subset supported by both LLVM and GNU AS\". If someone wants to turn that into an exhaustive list of directives, they can, but nobody volunteered to do that. :)</p>",
        "id": 270226929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226788\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226582\">said</a>:</p>\n<blockquote>\n<p>And even more things are unspecified, which is implementation-defined but not required to be documented:<br>\nLayout of repr(Rust) types and of tuples.<br>\nABI of <code>extern \"Rust\"</code> functions.</p>\n</blockquote>\n<p>For the purposes of a spec, those are \"not a thing you can depend on at all\", rather than \"implementation-defined\".</p>\n</blockquote>\n<p>\"not a thing you can depend on at all\" is not a specification.<br>\nFor the purposes of the specification, it would be unspecified behaviour.</p>",
        "id": 270226940,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728472
    },
    {
        "content": "<p>There's a difference between \"this is implementation-defined (but presumably specific and you could count on one implementation's behavior)\" and \"you can never count on this, it could change arbitrarily and you can't depend on it even within one implementation\".</p>",
        "id": 270227095,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728532
    },
    {
        "content": "<p>deferring to GNU AS is just kicking the can down the road, and I'm worried we'll realize after it is too late to change that we opted into some horrible edge case by doing so</p>",
        "id": 270227148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226753\">said</a>:</p>\n<blockquote>\n<p>Unless the spec codifies the exhaustive list of targets that an implementation is permitted to support, which I would be very much against, you will necessarily have implementation-defined behaviour.</p>\n</blockquote>\n<p>Rust has target-specific behavior, and a complete spec would necessarily <em>have</em> to document the target-specific behavior for each supported target.</p>",
        "id": 270227234,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728576
    },
    {
        "content": "<p>It's not a matter of \"targets that an implementation is permitted to support\" (though it would have that net effect), it's \"what is the target named, what behavior does it have, what choices does it make\", etc.</p>",
        "id": 270227304,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270227095\">said</a>:</p>\n<blockquote>\n<p>There's a difference between \"this is implementation-defined (but presumably specific and you could count on one implementation's behavior)\" and \"you can never count on this, it could change arbitrarily and you can't depend on it even within one implementation\".</p>\n</blockquote>\n<p>Yes, there is. The former requires the implementation to document it's choice, and the latter does not require that.</p>",
        "id": 270227358,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728630
    },
    {
        "content": "<p>You can't even necessarily rely on implementation-defined behaviour being consistent: The implementation would simply be required to document <em>how</em> it is inconsistent.</p>",
        "id": 270227420,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728658
    },
    {
        "content": "<p>Well, Rust does not document the layout of <code>extern \"Rust\"</code> or the calling ABI, so I think that's consistent with what I said above. :)</p>",
        "id": 270227432,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728661
    },
    {
        "content": "<p>Exactly. It's <em>unspecified</em> in terms of C/++.</p>",
        "id": 270227479,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728680
    },
    {
        "content": "<p>Hence why for the present I would want some wording that is at least consistent with a future version of <code>asm!</code> that is fully implemented in rust. Switching from <code>llvm_asm</code> to <code>rust_asm</code> could break some things so we need a stability guarantee that accommodates this possibility</p>",
        "id": 270227522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728685
    },
    {
        "content": "<p>C++'s \"unspecified\" does that</p>",
        "id": 270227543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728696
    },
    {
        "content": "<p>but it might also be a bit too heavy of a hammer</p>",
        "id": 270227583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> There's nothing preventing us from fully implementing <code>asm!</code> in Rust today, it'd just be a great deal of work.</p>",
        "id": 270227619,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728722
    },
    {
        "content": "<p>(And an implementation <em>can</em> choose to document it's choices for unspecified behaviour, and commit to allowing users to rely on it)</p>",
        "id": 270227637,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728728
    },
    {
        "content": "<p>Sorry if it was already mentioned but <a href=\"https://github.com/rust-lang/rustc_codegen_gcc/\">rustc_codegen_gcc</a> successfully <a href=\"https://github.com/rust-lang/rustc_codegen_gcc/blob/master/src/asm.rs\">implemented</a> the new <code>asm!</code>syntax.</p>",
        "id": 270227701,
        "sender_full_name": "Urgau",
        "timestamp": 1643728752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270227637\">said</a>:</p>\n<blockquote>\n<p>(And an implementation <em>can</em> choose to document it's choices for unspecified behaviour, and commit to allowing users to rely on it)</p>\n</blockquote>\n<p>And code relying on that would not be Rust code anymore, it'd be some variant of Rust.</p>",
        "id": 270227722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  I think you would have huge problems with getting results perfectly compatible with LLVM / GNU as if you actually tried</p>",
        "id": 270227731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728762
    },
    {
        "content": "<p>(I've already chosen to do this with lccc, via the lcrust v0 abi, which specifies the layout/abi choices of lccc and others that choose to support it)</p>",
        "id": 270227774,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> LLVM managed to do it.</p>",
        "id": 270227778,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728778
    },
    {
        "content": "<p>by definition?</p>",
        "id": 270227832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270227774\">said</a>:</p>\n<blockquote>\n<p>(I've already chosen to do this with lccc, via the lcrust v0 abi, which specifies the layout/abi choices of lccc and others that choose to support it)</p>\n</blockquote>\n<p>And while I hope you enjoy working on it, I also hope nobody ever counts on that.</p>",
        "id": 270227833,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728798
    },
    {
        "content": "<p>there isn't actually a spec here, you literally said \"whatever LLVM and GNU AS\" supports. Of course LLVM supports that</p>",
        "id": 270227961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270227832\">said</a>:</p>\n<blockquote>\n<p>by definition?</p>\n</blockquote>\n<p>No, by continuing to implement their assembler support and add to it as long as they ran into real-world code that used more functionality of it.</p>",
        "id": 270227965,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728834
    },
    {
        "content": "<p>Ignoring what Rust <code>asm!</code> supports specifically for the moment, LLVM's assembler support pretty much took GNU AS as a spec and implemented the vast majority of it, because they <em>had</em> to for real-world inline asm compatibility.</p>",
        "id": 270228114,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728880
    },
    {
        "content": "<p>but if you want to implement that in a third assembler (like lccc), then that spec is lacking, you need an actual listing of what it can do</p>",
        "id": 270228131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> We have a <em>lot</em> of things for which a \"spec\" is lacking, and you have to look at what rustc does.</p>",
        "id": 270228206,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728909
    },
    {
        "content": "<p>I'm not arguing that that's a feature, necessarily, but asm is not unique or even unusual in that regard.</p>",
        "id": 270228328,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270227833\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270227774\">said</a>:</p>\n<blockquote>\n<p>(I've already chosen to do this with lccc, via the lcrust v0 abi, which specifies the layout/abi choices of lccc and others that choose to support it)</p>\n</blockquote>\n<p>And while I hope you enjoy working on it, I also hope nobody ever counts on that.</p>\n</blockquote>\n<p>I actually do in lccc (host), in two ways:</p>\n<ul>\n<li>proc-macros will be implemented via FFI using the extern \"Rust\" abi (this was the origin of the abi - I refuse to rely on multiple sources of truth for the ABI agreeing)</li>\n<li>If I know that the host compiler supports the ABI (by which I mean I ask it nicely), I optimize certain defintions that emulate features to simply rely on that ABI. </li>\n</ul>\n<p>You can't necessarily even count on it in lccc (absent building with the <code>-Z build-abi</code> option), since it says you can rely on \"it or a future version\", but you can test the compiler and polyfill when unsupported.</p>",
        "id": 270228336,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643728941
    },
    {
        "content": "<p>Looking at what rustc does is one thing, looking at rustc, llvm, and gnu AS is quite another</p>",
        "id": 270228372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643728954
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> The difference here is that instead of \"it's completely unspecified\", the answer is instead \"it's specified somewhere else by another tool\", and that seems to be seen as <em>worse</em> than just \"unspecified\".</p>",
        "id": 270228491,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643728993
    },
    {
        "content": "<p>at least everything in rust nominally goes through the RFC process. Here we're opting in to a huge spec no one has cared to look into in detail</p>",
        "id": 270228565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270228491\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> The difference here is that instead of \"it's completely unspecified\", the answer is instead \"it's specified somewhere else by another tool\", and that seems to be seen as <em>worse</em> than just \"unspecified\".</p>\n</blockquote>\n<p>It is, yes.</p>",
        "id": 270228577,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729031
    },
    {
        "content": "<p>it feels like an end-run around the RFC system</p>",
        "id": 270228600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270228565\">said</a>:</p>\n<blockquote>\n<p>at least everything in rust nominally goes through the RFC process. Here we're opting in to a huge spec no one has cared to look into in detail</p>\n</blockquote>\n<p>It's also a fun thing for implementors. I didn't even see that this was a thing until mid december (when I was busy with exams, and then the x86 backend for use with the C frontend).</p>",
        "id": 270228861,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270228577\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270228491\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> The difference here is that instead of \"it's completely unspecified\", the answer is instead \"it's specified somewhere else by another tool\", and that seems to be seen as <em>worse</em> than just \"unspecified\".</p>\n</blockquote>\n<p>It is, yes.</p>\n</blockquote>\n<p>I wasn't using \"unspecified\" in a spec sense, as in \"implementations can do whatever they want\". I was using \"unspecified' in the sense of \"this RFC doesn't document it, so it'll have to get specified when we implement it in Rust\".</p>",
        "id": 270228864,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729125
    },
    {
        "content": "<p>Which is roughly what we would have ended up doing if we hadn't nailed it down <em>more</em> precisely to \"support the common subset of LLVM and GNU AS\".</p>",
        "id": 270229007,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729175
    },
    {
        "content": "<p>It seems like the RFC documented <em>more</em> than it would need to, and that's being seen as worse than documenting <em>less</em>.</p>",
        "id": 270229054,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729200
    },
    {
        "content": "<p>Yeah, and the common subset is great for llvm, and arguably for gcc.</p>",
        "id": 270229055,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270229054\">said</a>:</p>\n<blockquote>\n<p>It seems like the RFC documented <em>more</em> than it would need to, and that's being seen as worse than documenting <em>less</em>.</p>\n</blockquote>\n<p>Yes, that is exactly the issue here.</p>",
        "id": 270229088,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270229055\">said</a>:</p>\n<blockquote>\n<p>Yeah, and the common subset is great for llvm, and arguably for gcc.</p>\n</blockquote>\n<p>This seems like it's coming very close to \"Rust should have required less, so that an implementation could get away with doing less and not be seen as incompatible with Rust\".</p>",
        "id": 270229132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729233
    },
    {
        "content": "<p>To the extent the language in the RFC is preventing that, it's working as intended.</p>",
        "id": 270229165,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729246
    },
    {
        "content": "<p>yes... that's the reality</p>",
        "id": 270229188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729256
    },
    {
        "content": "<p><code>asm!</code> as currently implemented does not have neat bounds on when it works, so if when we get around to writing those bounds we find some things in LLVM / GNU AS can't be supported, then we need the flexibility to be able to say that actually it wasn't supported after all and it was just an accident that it happened to work</p>",
        "id": 270229378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270229165\">said</a>:</p>\n<blockquote>\n<p>To the extent the language in the RFC is preventing that, it's working as intended.</p>\n</blockquote>\n<p>Yes, I am not disputing that the language in the RFC is not doing what it's supposed to. The defect is in the design itself, rather than the wording.</p>",
        "id": 270229442,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729352
    },
    {
        "content": "<p>FWIW, to get a little less abstract, and more concrete about potential next steps: I would be <em>completely</em> sympathetic to a documentation patch that specifically excluded the GNU AS macro directives, as being something we don't support.</p>",
        "id": 270229528,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729385
    },
    {
        "content": "<p>I'm <em>not</em> going to say that, if people end up using them anyway because they happen to work, we're going to break that in the future and say \"well, we warned you\".</p>",
        "id": 270229622,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729408
    },
    {
        "content": "<p>But I do think it'd be reasonable to document that those specific directives aren't intended to be supported, and encourage people to not use them.</p>",
        "id": 270229651,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729426
    },
    {
        "content": "<p>I'm confused. The directives are not supported but we can't stop supporting them?</p>",
        "id": 270229758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> As an analogous situation: We have, in the past, had documentation saying \"don't rely on X\" in the library documentation. If in the future we actually want to change X, we still very carefully check if anyone is <em>relying</em> on X, and if they are, the existence of the comment does not automatically make that <em>not</em> a breaking change and give us carte blanche to say \"we warned you!\".</p>",
        "id": 270230064,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729574
    },
    {
        "content": "<p>Yeah, that's a common problem with rust. Hyrum's law is taken as gospel instead of a reason to break some legs.</p>",
        "id": 270230090,
        "sender_full_name": "The 8472",
        "timestamp": 1643729588
    },
    {
        "content": "<p>Saying \"X is unsupported\" is valid, it would fall back to \"assembler-specific behaviour\"</p>",
        "id": 270230128,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729600
    },
    {
        "content": "<p>Why even write specs if people can just force hands by making a popular lib relying on implementation details</p>",
        "id": 270230153,
        "sender_full_name": "The 8472",
        "timestamp": 1643729610
    },
    {
        "content": "<p>Sometimes we very carefully change X anyway, either because we don't think anyone will actually break, or because it's extremely important and <em>very few</em> projects will break.</p>",
        "id": 270230159,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729612
    },
    {
        "content": "<p>But we don't consider a comment or doc saying \"don't rely on X\" to be a complete defense against anyone relying on X <em>anyway</em>.</p>",
        "id": 270230292,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270230153\">said</a>:</p>\n<blockquote>\n<p>Why even write specs if people can just force hands by making a popular lib relying on implementation details</p>\n</blockquote>\n<p>That's an <em>excellent</em> question, and I find myself asking forms of that question every time the concept of a \"Rust spec\" comes up. ;)</p>",
        "id": 270230389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729704
    },
    {
        "content": "<p>That's kind to users, but it might be unkind to other implementations because they'd have to reproduce implementation details rather than matching the spec.</p>",
        "id": 270230458,
        "sender_full_name": "The 8472",
        "timestamp": 1643729724
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 270230559,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270230458\">said</a>:</p>\n<blockquote>\n<p>That's kind to users, but it might be unkind to other implementations because they'd have to reproduce implementation details rather than matching the spec.</p>\n</blockquote>\n<p>On balance, I'd prefer to be kind to users we actually have, and strict (strictness is not inherently unkind) with other implementations.</p>",
        "id": 270230577,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729753
    },
    {
        "content": "<p>Which is to say, I'd prefer a hypothetical spec to say \"do exactly this\" with as little wiggle-room as possible.</p>",
        "id": 270230657,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729769
    },
    {
        "content": "<p>I would actually much prefer that in this particular case</p>",
        "id": 270230744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729786
    },
    {
        "content": "<p>there should just be an asm grammar</p>",
        "id": 270230756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> other implementations is also a future rustc ;)</p>",
        "id": 270230864,
        "sender_full_name": "The 8472",
        "timestamp": 1643729816
    },
    {
        "content": "<p>In my case, my decision when it's docuemented as \"X is not stable\" is that I won't necessarily break X, but I won't necessarily adhere to X either.<br>\nIn some cases, I will introduce an option to deliberately break X.</p>",
        "id": 270230868,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> FWIW, if someone were to write up an asm grammar for the intersection-of-GNU-AS-and-LLVM that we support, I'd be <em>thrilled</em> to merge that.</p>",
        "id": 270230876,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729819
    },
    {
        "content": "<p>Suppose that we did that, but then LLVM and/or GNU AS got better behind our backs. Would we need to change the spec?</p>",
        "id": 270231026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270230864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> other implementations is also a future rustc ;)</p>\n</blockquote>\n<p>Or rustc w/ future target.</p>",
        "id": 270231127,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729883
    },
    {
        "content": "<p>Or, in this case, rustc w/ !LLVM backend.</p>",
        "id": 270231210,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231127\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270230864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> other implementations is also a future rustc ;)</p>\n</blockquote>\n<p>Or rustc w/ future target.</p>\n</blockquote>\n<p>Yes, when we make design decisions we have to think about future targets that might be supported, and whether we're closing off such targets. We do that regularly now.</p>",
        "id": 270231241,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729912
    },
    {
        "content": "<p>Sure, now. <em>Stares at usize</em>.</p>",
        "id": 270231349,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643729949
    },
    {
        "content": "<p>Example: we currently make it harder to write code that assumes 32-bit or 64-bit, because we <em>support</em> 16-bit and 128-bit; I'd love to see <code>let x: u64 = some_usize.into()</code> Just Work, but we are deferring that until we have the portability lint.</p>",
        "id": 270231359,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270230876\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> FWIW, if someone were to write up an asm grammar for the intersection-of-GNU-AS-and-LLVM that we support, I'd be <em>thrilled</em> to merge that.</p>\n</blockquote>\n<p>This would be great, but it needs a lot of requirements gathering and design work and I don't think it's possible to get done before the next stable</p>",
        "id": 270231441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643729978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231349\">said</a>:</p>\n<blockquote>\n<p>Sure, now. <em>Stares at usize</em>.</p>\n</blockquote>\n<p>Yes, that's an example. We have to make exactly that kind of decision there, where there are tradeoffs either way.</p>",
        "id": 270231459,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231441\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270230876\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> FWIW, if someone were to write up an asm grammar for the intersection-of-GNU-AS-and-LLVM that we support, I'd be <em>thrilled</em> to merge that.</p>\n</blockquote>\n<p>This would be great, but it needs a lot of requirements gathering and design work and I don't think it's possible to get done before the next stable</p>\n</blockquote>\n<p>I agree. But I also don't think it's a blocker.</p>",
        "id": 270231508,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643729999
    },
    {
        "content": "<p>We're <em>definitely</em> not going to be able to <em>implement</em> anything that parses and restricts <code>asm!</code> before the next stable, or likely before a half-dozen stables from now.</p>",
        "id": 270231646,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730030
    },
    {
        "content": "<p>Suppose we did all that work for the <em>next</em> stable. How would it not be a breaking change?</p>",
        "id": 270231647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643730031
    },
    {
        "content": "<p>I think that for asm!, either a limited subset is DR'd into the spec in now right before stable, or we need that list.</p>",
        "id": 270231720,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730063
    },
    {
        "content": "<p>(\"DRed\"?)</p>",
        "id": 270231745,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231647\">said</a>:</p>\n<blockquote>\n<p>Suppose we did all that work for the <em>next</em> stable. How would it not be a breaking change?</p>\n</blockquote>\n<p>Because we already said \"intersection of GNU AS and LLVM\", and if we translate that into \"specific list of what's supported by that intersection\", that's not a breaking change, that's just more complete documentation.</p>",
        "id": 270231772,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730090
    },
    {
        "content": "<p>Defect Report. C++ term for \"We hecked up on the published standard, so we're retroactively fixing that\".</p>",
        "id": 270231808,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231026\">said</a>:</p>\n<blockquote>\n<p>Suppose that we did that, but then LLVM and/or GNU AS got better behind our backs. Would we need to change the spec?</p>\n</blockquote>\n<p>If we had a complete list, I'd expect that we'd need to consider updating that list each time there's a new feature supported by both of those.</p>",
        "id": 270231913,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730133
    },
    {
        "content": "<p>I don't expect that to actually happen very often, and we could consider it when it happens.</p>",
        "id": 270231961,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730149
    },
    {
        "content": "<p>IMO (and clearly not exclusively my opinion) is that the semantics as-specified for asm is a defect because it's too restrictive on implementors.</p>",
        "id": 270231976,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231772\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231647\">said</a>:</p>\n<blockquote>\n<p>Suppose we did all that work for the <em>next</em> stable. How would it not be a breaking change?</p>\n</blockquote>\n<p>Because we already said \"intersection of GNU AS and LLVM\", and if we translate that into \"specific list of what's supported by that intersection\", that's not a breaking change, that's just more complete documentation.</p>\n</blockquote>\n<p>This ties our hands to support <em>everything</em> in GNU AS / LLVM, rather than everything sane that has a nonzero number of uses</p>",
        "id": 270231991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643730164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231976\">said</a>:</p>\n<blockquote>\n<p>IMO (and clearly not exclusively my opinion) is that the semantics as-specified for asm is a defect because it's too restrictive.</p>\n</blockquote>\n<p>Observation: your use of \"restrictive\" is using compiler-colored glasses here, because from the <em>user's</em> perspective it's <em>less</em> restrictive and the change you're proposing would be <em>more</em> restrictive.</p>",
        "id": 270232073,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730197
    },
    {
        "content": "<p>(just saw that you edited your message to that effect)</p>",
        "id": 270232143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730223
    },
    {
        "content": "<p>Yes, I am speaking as an implementor here, because right now that perspective outweighs my perspective as a user.</p>",
        "id": 270232169,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730236
    },
    {
        "content": "<p>Counterpoint: It gives the user more certainty that their code will actually be portable</p>",
        "id": 270232239,
        "sender_full_name": "The 8472",
        "timestamp": 1643730248
    },
    {
        "content": "<p>In the case of a more restrictive (from a users perspective) subset, I can always switch to using outline assembly, which I already do anyways (even in languages that have inline asm support, or that have inline asm \"support\").</p>",
        "id": 270232350,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231991\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231772\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270231647\">said</a>:</p>\n<blockquote>\n<p>Suppose we did all that work for the <em>next</em> stable. How would it not be a breaking change?</p>\n</blockquote>\n<p>Because we already said \"intersection of GNU AS and LLVM\", and if we translate that into \"specific list of what's supported by that intersection\", that's not a breaking change, that's just more complete documentation.</p>\n</blockquote>\n<p>This ties our hands to support <em>everything</em> in GNU AS / LLVM, rather than everything sane that has a nonzero number of uses</p>\n</blockquote>\n<p>Or \"everything that has a nonzero number of users by the time we finish documenting it\", which is a different statement.</p>",
        "id": 270232354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730292
    },
    {
        "content": "<p>Oh, is this a tree falls in the forest thing? It's not a spec break if no one noticed</p>",
        "id": 270232432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643730329
    },
    {
        "content": "<p>Probably the easiest set to stabilize now is \"labels+instructions in target-specific format\", though that may be too restrictive on users.</p>",
        "id": 270232483,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232432\">said</a>:</p>\n<blockquote>\n<p>Oh, is this a tree falls in the forest thing? It's not a spec break if no one noticed</p>\n</blockquote>\n<p>Lovely thing about not actually having a Rust spec; we <em>do</em> sometimes use a combination of crater and code searches to give ourselves confidence that nobody will notice a change. ;)</p>",
        "id": 270232489,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232483\">said</a>:</p>\n<blockquote>\n<p>Probably the easiest set to stabilize is now \"labels+instructions in target-specific format\", though that may be too restrictive on users.</p>\n</blockquote>\n<p>Substantially too restrictive, yes; there are quite a few directives people actually need.</p>",
        "id": 270232566,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730371
    },
    {
        "content": "<p>That's the upside of hyrum's law I suppose. But I don't like that tradeoff.</p>",
        "id": 270232569,
        "sender_full_name": "The 8472",
        "timestamp": 1643730372
    },
    {
        "content": "<p>Yeah, same.</p>",
        "id": 270232586,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232569\">said</a>:</p>\n<blockquote>\n<p>That's the upside of hyrum's law I suppose. But I don't like that tradeoff.</p>\n</blockquote>\n<p>I'm not suggesting it's ideal, it's just where we're at.</p>",
        "id": 270232597,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730386
    },
    {
        "content": "<p>Even if we <em>had</em> a spec, I still have no intention of using the spec to hit users over the head and say \"you're doing Rust wrong, it's OK that we broke you!\".</p>",
        "id": 270232646,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730409
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> FWIW, I also don't think we need a complete specification of asm grammar in order to improve anything here.</p>",
        "id": 270232709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730435
    },
    {
        "content": "<p>I think it'd help to just say \"here's the list of directives we support\".</p>",
        "id": 270232731,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730444
    },
    {
        "content": "<p>If it turns out someone relied on the one thing that is nearly impossible to implement, then we have the same situtation as it is now: You need llvm or GNU as, and if neither exists or can exist, you're SOL.</p>",
        "id": 270232794,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730470
    },
    {
        "content": "<p>that seems fine to me, assuming that we can rely on the base grammar being reasonably sane and specifiable at a future date</p>",
        "id": 270232819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643730482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232794\">said</a>:</p>\n<blockquote>\n<p>If it turns out someone relied on the one thing that is nearly impossible to implement, then we have the same situtation as it is now: You need llvm or GNU as, and if neither exists or can exist, you're SOL.</p>\n</blockquote>\n<p>Or someone would need to implement a new assembler-implementation library, and use that. Which on balance doesn't seem <em>harder</em> than implementing a complete Rust implementation...</p>",
        "id": 270232928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730510
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> If you wanted to look at the docs for LLVM and for GNU AS, and write down the subset of directives supported by both (and then we can prune out a couple like macro syntax), that seems like the primary issue here.</p>",
        "id": 270232953,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730523
    },
    {
        "content": "<p>Well, hitting users for its own sake is silly of course. But if there's a desirable implementation change permitted by a spec and the only thing that's blocking it is some non-spec-compliant user code... then yeah, that's what a spec is for and breaking legs should be ok. Being nice in my book means warning people about it, not not doing the thing.</p>",
        "id": 270232999,
        "sender_full_name": "The 8472",
        "timestamp": 1643730537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232646\">said</a>:</p>\n<blockquote>\n<p>Even if we <em>had</em> a spec, I still have no intention of using the spec to hit users over the head and say \"you're doing Rust wrong, it's OK that we broke you!\".</p>\n</blockquote>\n<p>IDK, people will rely on things that are explicitly said to not be stable. There are users that rely on repr(Rust), either deliberately or by accident.</p>",
        "id": 270233061,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232999\">said</a>:</p>\n<blockquote>\n<p>Well, hitting users for its own sake is silly of course. But if there's a desirable implementation change permitted by a spec and the only thing that's blocking it is some non-spec-compliant user code... then yeah, that's what a spec is for and breaking legs should be ok.</p>\n</blockquote>\n<p>People thinking a spec is an excuse to break people are <em>exactly</em> why I hope we don't have a spec anytime soon. ;)</p>",
        "id": 270233133,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730585
    },
    {
        "content": "<p>It's not an excuse. It's part of the purpose! Imo.<br>\nYou rely on users not doing things. Users rely on you doing what the spec says. Mutual obligations.</p>",
        "id": 270233349,
        "sender_full_name": "The 8472",
        "timestamp": 1643730644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270233061\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270232646\">said</a>:</p>\n<blockquote>\n<p>Even if we <em>had</em> a spec, I still have no intention of using the spec to hit users over the head and say \"you're doing Rust wrong, it's OK that we broke you!\".</p>\n</blockquote>\n<p>IDK, people will rely on things that are explicitly said to not be stable. There are users that rely on repr(Rust), either deliberately or by accident.</p>\n</blockquote>\n<p>Right, and if that's the case, we'll take care when changing it and make a <em>deliberate</em> decision based on the tradeoffs of breaking people vs improving something, rather than either saying \"we can't change it, people counted on it even though they shouldn't\" <em>or</em> saying \"we can just change it without worrying about it, they shouldn't have relied on it\".</p>",
        "id": 270233382,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730652
    },
    {
        "content": "<p>C++ doesn't even think that a spec is on-its-own an excuse to break people.<br>\nC++ actively tries to avoid breaking things it even doesn't guarantee, such as ABI.<br>\nHowever, it can be combined with a rationale purpose for breaking it.</p>",
        "id": 270233457,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270233349\">said</a>:</p>\n<blockquote>\n<p>It's not an excuse. It's part of the purpose!</p>\n</blockquote>\n<p>I think you're making my point for me. ;)</p>",
        "id": 270233460,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730671
    },
    {
        "content": "<p>(For example, when <code>std::string</code> was barred in C++11 from being CoW because C++ decided it wanted the stdlib to be thread safe)</p>",
        "id": 270233542,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730703
    },
    {
        "content": "<p>(Or when <code>noexcept</code> became type-level in C++17, and broke name mangling)</p>",
        "id": 270233744,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730752
    },
    {
        "content": "<p>It's not in-and-of itself an excuse, but it's a justification for when the breakage results in something that is <em>more</em> desirable than the status quo.</p>",
        "id": 270233960,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270233960\">said</a>:</p>\n<blockquote>\n<p>It's not in-and-of itself an excuse, but it's a justification for when the breakage results in something that is <em>more</em> desirable than the status quo.</p>\n</blockquote>\n<p>That I agree with entirely; that's exactly what we try to do in Rust.</p>",
        "id": 270234028,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730840
    },
    {
        "content": "<p>Even if we've said \"don't count on X\", when we see a reason we may want to change X, we'll look at the degree to which people are counting on X and make a <em>deliberate</em> decision, rather than just writing off any uses of X because we said \"don't count on X\".</p>",
        "id": 270234223,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730892
    },
    {
        "content": "<p>Sometimes we <em>do</em> go ahead and make the change, even if crater turns up half-a-dozen crates; we go work with the authors of those crates to get them fixed.</p>",
        "id": 270234312,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730919
    },
    {
        "content": "<p>Sometimes we don't, not just because something has been widely used, but even if it's used in a few places and we say \"yeah, that seems completely reasonable for someone to have done\".</p>",
        "id": 270234398,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643730956
    },
    {
        "content": "<p>If we say that the spec limits the guaranteed-to-be-supported directives and excludes a particular directive, then it becomes desirable that specific directive is definately <em>not</em> supported in a certain case (IE. because implementing it is unreasonable), then it should be reasonable to not support it.</p>",
        "id": 270234407,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643730959
    },
    {
        "content": "<p>I think that seems quite reasonable for asm!; we'd be going from \"LLVM / GNU AS\" to \"this explicit list of directives and grammar\", and it should presumably be possible to calibrate the list until it covers all the major players</p>",
        "id": 270234526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643730997
    },
    {
        "content": "<p>Well, I guess it's a difference between only assessing the desirability of the change vs. also assessing the impact of the breakage.<br>\nI'm concerned about the latter part because it creates some odd incentives, to get implementation-dependent code into more places so it becomes part of the spec.</p>",
        "id": 270234537,
        "sender_full_name": "The 8472",
        "timestamp": 1643731005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270234537\">said</a>:</p>\n<blockquote>\n<p>Well, I guess it's a difference between only assessing the desirability of the change vs. also assessing the impact of the breakage.<br>\nI'm concerned about the latter part because it creates some odd incentives, to get implementation-dependent code into more places so it becomes part of the spec.</p>\n</blockquote>\n<p>I acknowledge the incentives there, but generally speaking we're not assuming our users are <em>trying</em> to exploit things like that. ;)</p>",
        "id": 270234611,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731035
    },
    {
        "content": "<p>And if it seemed like someone was doing so intentionally, we'd likely ignore them for the purposes of evaluating breakage.</p>",
        "id": 270234654,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731051
    },
    {
        "content": "<p>Yes, when it's a close decision, the spec becomes the deciding vote, so to say. \"It's not supported, so we'll defer to breaking it here\".</p>",
        "id": 270234660,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731052
    },
    {
        "content": "<p>So, for the issue at hand here: does someone feel like they have the time and inclination to make a complete list of the intersection of directives supported by both GNU AS and LLVM AS? (Or, for that matter, a complete list of the directives supported by each would actually be more useful, and then it's not hard to intersect the two.)</p>",
        "id": 270234801,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731107
    },
    {
        "content": "<p>I would not want to do a complete list, nor do I think that the basic subset should support a complete list.</p>",
        "id": 270234868,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731138
    },
    {
        "content": "<p>We don't need a complete spec for each directive; I think it's reasonably safe to assume that if LLVM AS supports a directive that it supports all of that directive, to a first approximation.</p>",
        "id": 270234873,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that's not the only example, just the most extreme one. If it creates a general culture of reading the source and forming implicit assumptions on that it's bad too.</p>",
        "id": 270234876,
        "sender_full_name": "The 8472",
        "timestamp": 1643731142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270234868\">said</a>:</p>\n<blockquote>\n<p>I would not want to do a complete list, nor do I think that the basic subset should support a complete list.</p>\n</blockquote>\n<p>I didn't say that what we put in the docs would <em>be</em> the complete list; I asked if someone was willing to compile a complete list, from which we can deliberately decide what we want to exclude.</p>",
        "id": 270234968,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731178
    },
    {
        "content": "<p>In asking that way, I'm specifically saying \"the person who compiles the complete list should not be editorializing by removing items as they go; we'll do that after we have the list\".</p>",
        "id": 270235111,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731210
    },
    {
        "content": "<p><a href=\"https://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops\">https://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops</a></p>",
        "id": 270235194,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731225
    },
    {
        "content": "<p>We can probably start from that list.</p>",
        "id": 270235259,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731244
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 270235371,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731280
    },
    {
        "content": "<p>I do think that's a complete list of the <em>portable</em> ones for GNU AS, though I think there may also be target-specific ones that we need to know, too.</p>",
        "id": 270235453,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643731304
    },
    {
        "content": "<p>hah, there's a deprecated list at the bottom</p>",
        "id": 270235464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643731309
    },
    {
        "content": "<p>so the subset might not even be monotonically increasing over time</p>",
        "id": 270235560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643731330
    },
    {
        "content": "<p><a href=\"https://sourceware.org/binutils/docs/as/Machine-Dependencies.html#Machine-Dependencies\">https://sourceware.org/binutils/docs/as/Machine-Dependencies.html#Machine-Dependencies</a><br>\nHas all of the machine-specific directives and more.</p>",
        "id": 270235674,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731368
    },
    {
        "content": "<p>Note that some of the common directives aren't even totally portable, insofar as they have different behaviour depending on the target.</p>",
        "id": 270235770,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731398
    },
    {
        "content": "<p>I guess <code>.intel_syntax</code> is going to be among the supported directives? That will make grammar parsing <em>fun</em> (to borrow a phrase)</p>",
        "id": 270236170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643731541
    },
    {
        "content": "<p>Yes. Ideally, we don't necessarily support turning it off.</p>",
        "id": 270236303,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731566
    },
    {
        "content": "<p>would it end up having side effects on any compiler generated code placed after the asm! block?</p>",
        "id": 270236533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643731632
    },
    {
        "content": "<p>like, it might cause those compiler lines to be interpreted in the wrong syntax mode</p>",
        "id": 270236601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643731654
    },
    {
        "content": "<p>I might have the wrong mental model for how asm blocks are concatenated with compiler asm though</p>",
        "id": 270236789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643731689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270236601\">said</a>:</p>\n<blockquote>\n<p>like, it might cause those compiler lines to be interpreted in the wrong syntax mode</p>\n</blockquote>\n<p>Imagine even having assembly produced by the compiler.</p>",
        "id": 270236867,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731710
    },
    {
        "content": "<p>(So, in my case, no, it wouldn't. IDK about llvm, though <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span>)</p>",
        "id": 270237211,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731821
    },
    {
        "content": "<p>(<code>-s</code>? Nah, I'll just codegen then disassemble, what could go wrong)</p>",
        "id": 270237520,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643731947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270236170\">said</a>:</p>\n<blockquote>\n<p>I guess <code>.intel_syntax</code> is going to be among the supported directives? That will make grammar parsing <em>fun</em> (to borrow a phrase)</p>\n</blockquote>\n<p>I don't actually think we fully support <code>.intel_syntax</code> or <code>.att_syntax</code>, insofar as using those won't affect how we substitute in placeholders, so they're likely to break things if used in any asm block that has placeholders.</p>",
        "id": 270239691,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643732712
    },
    {
        "content": "<p>So those would be good examples of what we should document as not working.</p>",
        "id": 270239727,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643732728
    },
    {
        "content": "<p>Heh. That actually seems easier to support the way I want to implement asm, if I choose to support multiple asm dialects (which I will eventually need).</p>",
        "id": 270240854,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733138
    },
    {
        "content": "<p>(Since I ideally want to fill in placeholders <em>after</em> parsing the assembly into instructions)</p>",
        "id": 270241019,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733192
    },
    {
        "content": "<p>I was wondering about whether <code>\".asciz \\\"{}\\\"\"</code> is supposed to work (for, say, substituting a register class)</p>",
        "id": 270241190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733250
    },
    {
        "content": "<p>which would make things like the casing convention of registers observable</p>",
        "id": 270241271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733284
    },
    {
        "content": "<p>cursed, tbh.</p>",
        "id": 270241297,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733297
    },
    {
        "content": "<p>Agreed on \"cursed\". Valid, but ow.</p>",
        "id": 270241340,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643733312
    },
    {
        "content": "<p>or worse, <code>\".{}\"</code></p>",
        "id": 270241346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> My understanding is that <code>label_{}:</code> would work, for that matter.</p>",
        "id": 270241378,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643733327
    },
    {
        "content": "<p>(Tbh, I could probably still support that, by just printing the register name if it appears outside of an instruction as a direct (or indirect) operand.</p>",
        "id": 270241559,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733395
    },
    {
        "content": "<p>(Cursed af, though)</p>",
        "id": 270241582,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733407
    },
    {
        "content": "<p>I think that in an ideal fully parsed version of <code>asm!</code> these would work but only in certain approved positions (like that label interpolation)</p>",
        "id": 270241590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733410
    },
    {
        "content": "<p>the directive interpolation definitely shouldn't work</p>",
        "id": 270241658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733433
    },
    {
        "content": "<p>and the string interpolation should not support SQL injection ideally</p>",
        "id": 270241707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270241707\">said</a>:</p>\n<blockquote>\n<p>and the string interpolation should not support SQL injection ideally</p>\n</blockquote>\n<p>Heh</p>",
        "id": 270241764,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733467
    },
    {
        "content": "<p>I do use <code>.asciiz</code> with args like that for SystemTap SDT probes:<br>\n<a href=\"https://github.com/cuviper/rust-libprobe/blob/85202324218eae152d1c9dffa5ce37dfdc2a0e9b/src/platform/systemtap.rs#L116\">https://github.com/cuviper/rust-libprobe/blob/85202324218eae152d1c9dffa5ce37dfdc2a0e9b/src/platform/systemtap.rs#L116</a></p>",
        "id": 270241872,
        "sender_full_name": "cuviper",
        "timestamp": 1643733490
    },
    {
        "content": "<p>I don't think it does, unless you're on some weird architecture where the register names are \";.abort or something.</p>",
        "id": 270241991,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733531
    },
    {
        "content": "<p>Well, in that case you are using <code>concat!</code> so I guess asm doesn't have to worry about it</p>",
        "id": 270242061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733555
    },
    {
        "content": "<p>indeed that seems like a good way to allow for applications that require the more cursed kinds of interpolation</p>",
        "id": 270242164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733591
    },
    {
        "content": "<p>(Side note, among the directives I'd like to <em>not</em> be supported: <code>.abort</code> and <code>.error</code>)</p>",
        "id": 270242177,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733595
    },
    {
        "content": "<p>Why <code>.error</code>? That sounds useful</p>",
        "id": 270242307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733630
    },
    {
        "content": "<p>Sounds like a great way to ICE.</p>",
        "id": 270242408,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733667
    },
    {
        "content": "<p>well, the user asked for it</p>",
        "id": 270242427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733679
    },
    {
        "content": "<p>it should be a linker(?) error</p>",
        "id": 270242464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733697
    },
    {
        "content": "<p>Not a linker error.</p>",
        "id": 270242491,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733707
    },
    {
        "content": "<p><code>.error</code> is an assembler error.</p>",
        "id": 270242513,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733715
    },
    {
        "content": "<p>It should be roughly the same kind of error that you would get if the assembly string used nonexistent instructions</p>",
        "id": 270242676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733767
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">error</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\".error </span><span class=\"se\">\\\"</span><span class=\"s\">foo</span><span class=\"se\">\\\"</span><span class=\"s\">\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">foo</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">-</span>-&gt; <span class=\"o\">&lt;</span><span class=\"n\">source</span><span class=\"o\">&gt;</span>:<span class=\"mi\">3</span>:<span class=\"mi\">31</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\".error </span><span class=\"se\">\\\"</span><span class=\"s\">foo</span><span class=\"se\">\\\"</span><span class=\"s\">\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">                               </span><span class=\"o\">^</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"n\">note</span>: <span class=\"nc\">instantiated</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"n\">assembly</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">-</span>-&gt; <span class=\"o\">&lt;</span><span class=\"n\">inline</span><span class=\"w\"> </span><span class=\"n\">asm</span><span class=\"o\">&gt;</span>:<span class=\"mi\">2</span>:<span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"p\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"s\">\"foo\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"o\">^</span><span class=\"w\"></span>\n\n<span class=\"n\">error</span>: <span class=\"nc\">aborting</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270242744,
        "sender_full_name": "bjorn3",
        "timestamp": 1643733799
    },
    {
        "content": "<p>that's not a bad error</p>",
        "id": 270242773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733817
    },
    {
        "content": "<p>This is roughly how all errors (including syntax errors) in inline asm reported by llvm are formatted.</p>",
        "id": 270242890,
        "sender_full_name": "bjorn3",
        "timestamp": 1643733850
    },
    {
        "content": "<p>does that happen in cargo check or cargo build?</p>",
        "id": 270242917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643733863
    },
    {
        "content": "<p>I've probably tossed span information by that point (although I may want to keep a reduced version arround for plugins anyways, just so that SFINAE errors from C++ don't look like</p>\n<div class=\"codehilite\"><pre><span></span><code>add\n^^^ Cannot add types `Foo` and `Bar`. ADL-overload resolution on `operator+` failed\n</code></pre></div>",
        "id": 270243247,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643733976
    },
    {
        "content": "<p>Oh, I just noticed that it's pointing to the character in the string literal, that's cool</p>",
        "id": 270243397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643734028
    },
    {
        "content": "<p>Only during <code>cargo build</code>. <code>cargo check</code> doesn't pass any code to llvm.</p>",
        "id": 270245325,
        "sender_full_name": "bjorn3",
        "timestamp": 1643734592
    },
    {
        "content": "<p>I'd assume even with <code>--emit mir</code> (or higher) it wouldn't produce those errors either.</p>",
        "id": 270245449,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643734636
    },
    {
        "content": "<p>Correct. <code>--emit mir</code> and <code>--emit metadata</code> both produce MIR, but don't pass it to the codegen backend.</p>",
        "id": 270246130,
        "sender_full_name": "bjorn3",
        "timestamp": 1643734834
    },
    {
        "content": "<p><code>--emit llvm-ir</code> on the other hand probably would produce the error.</p>",
        "id": 270246308,
        "sender_full_name": "bjorn3",
        "timestamp": 1643734891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270243397\">said</a>:</p>\n<blockquote>\n<p>Oh, I just noticed that it's pointing to the character in the string literal, that's cool</p>\n</blockquote>\n<p>Yeah, I'm <em>really</em> impressed with the asm errors doing that.</p>",
        "id": 270246464,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643734934
    },
    {
        "content": "<p>That was implemented in <a href=\"https://github.com/rust-lang/rust/pull/72625\">https://github.com/rust-lang/rust/pull/72625</a>.</p>",
        "id": 270246965,
        "sender_full_name": "bjorn3",
        "timestamp": 1643735118
    },
    {
        "content": "<p>So, looking at the list at <a href=\"https://sourceware.org/binutils/docs/as/Pseudo-Ops.html\">https://sourceware.org/binutils/docs/as/Pseudo-Ops.html</a> (ignoring the architecture-specific ones for the moment, and ignoring which ones LLVM already doesn't support), I think it'd be reasonable to disallow <code>.altmacro</code>/<code>.noaltmacro</code>, <code>.list</code>/<code>.nolist</code>/<code>.sbttl</code>/<code>.title</code>/<code>.eject</code>, <code>.macro</code>/<code>.exitm</code>, <code>.mri</code>. And <em>maybe</em> also <code>.if</code>/<code>.else</code>/<code>.endif</code>/etc though I think those are fine.</p>",
        "id": 270250624,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643736312
    },
    {
        "content": "<p>Not going to fully commit to my answer here, but I <em>think</em> I can reasonably support the remaining ones. <br>\nIdeally, <code>.if</code> et. al would be excluded.</p>",
        "id": 270250855,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736402
    },
    {
        "content": "<p>I can probably give a final answer if not later today, then sometime tomorrow.</p>",
        "id": 270251282,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736555
    },
    {
        "content": "<p><code>.eject</code>, <code>.title</code> and <code>.sbttl</code> can all be ignored without changing semantics, so disallowing them doesn't really add much.</p>",
        "id": 270251338,
        "sender_full_name": "bjorn3",
        "timestamp": 1643736577
    },
    {
        "content": "<p><code>.section</code> directives are also <em>fun</em>, since currently I only hand an output stream for <code>.text</code> to the function codegen (for simplying JIT vs. AOT interface reasons).</p>",
        "id": 270251646,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> <code>.section</code> is definitely in the short list of directives I expect people to actively use and depend on.</p>",
        "id": 270251732,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643736752
    },
    {
        "content": "<p>It's very common, for instance, to switch to another section, emit a chunk of data, and <code>.popsection</code> or <code>.text</code> back.</p>",
        "id": 270251780,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643736772
    },
    {
        "content": "<p><code>.section</code> is needed for SystemTap as an example. (or rather <code>.pushsection</code>)</p>",
        "id": 270251792,
        "sender_full_name": "bjorn3",
        "timestamp": 1643736776
    },
    {
        "content": "<p>For instance, a section full of pointers to things.</p>",
        "id": 270251802,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643736779
    },
    {
        "content": "<p>Yeah, it's possible I could redesign that. It's just a question of how do I do that without needing to split the codegen for JIT vs. AOT.</p>",
        "id": 270252280,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270250624\">said</a>:</p>\n<blockquote>\n<p>So, looking at the list at <a href=\"https://sourceware.org/binutils/docs/as/Pseudo-Ops.html\">https://sourceware.org/binutils/docs/as/Pseudo-Ops.html</a> (ignoring the architecture-specific ones for the moment, and ignoring which ones LLVM already doesn't support), I think it'd be reasonable to disallow <code>.altmacro</code>/<code>.noaltmacro</code>, <code>.list</code>/<code>.nolist</code>/<code>.sbttl</code>/<code>.title</code>/<code>.eject</code>, <code>.macro</code>/<code>.exitm</code>, <code>.mri</code>. And <em>maybe</em> also <code>.if</code>/<code>.else</code>/<code>.endif</code>/etc though I think those are fine.</p>\n</blockquote>\n<p>of this list I can see that we're already using <code>.macro</code> in our codebase: <a href=\"https://github.com/enarx/enarx/blob/91d79e35b29f68ddffa60a305421fdc355ac424c/internal/shim-sev/src/main.rs#L189\">https://github.com/enarx/enarx/blob/91d79e35b29f68ddffa60a305421fdc355ac424c/internal/shim-sev/src/main.rs#L189</a></p>",
        "id": 270253241,
        "sender_full_name": "bstrie",
        "timestamp": 1643737259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> Ouch.</p>",
        "id": 270255660,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643738059
    },
    {
        "content": "<p>Hypothetically (not saying we're going to do this), if we ended up documenting <code>.macro</code> as not supported, 1) how likely would you be to stop using it, and 2) how painful would it be in your codebase overall?</p>",
        "id": 270255766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643738094
    },
    {
        "content": "<p>In my case, macros were one of the explicit things I contemplated as being the <em>most</em> difficult to support, along with conditional assembly.</p>",
        "id": 270255935,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643738161
    },
    {
        "content": "<p>Yeah, I agree that if we're going to not-support anything for reasons of implementation complexity, <code>.macro</code> is on the <em>top</em> of that list.</p>",
        "id": 270256174,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643738249
    },
    {
        "content": "<p>if it was the sole difference between being on nightly and being on stable, I'm confident that we would stop using it (though I haven't asked the person who owns this code). notably this is the one and only usage of any item in that list that I can find in this repo</p>",
        "id": 270256196,
        "sender_full_name": "bstrie",
        "timestamp": 1643738255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> I think by (1) I'm asking the question of \"if we documented it as not supported, but it still worked, would you consider that motivating enough to change it if it didn't come with a personal ask\". ;)</p>",
        "id": 270256354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643738309
    },
    {
        "content": "<p>\"documented\" here means with a warning?</p>",
        "id": 270258479,
        "sender_full_name": "The 8472",
        "timestamp": 1643738998
    },
    {
        "content": "<p>Probably documentation-only.</p>",
        "id": 270258652,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643739067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270258479\">said</a>:</p>\n<blockquote>\n<p>\"documented\" here means with a warning?</p>\n</blockquote>\n<p>Maybe not out of the gate.</p>\n<p>Might be a good idea to eventually have at least a portability warning for unsupported constructs, though.</p>",
        "id": 270258718,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643739095
    },
    {
        "content": "<p>Well, I think that depends on the precise definition of \"unsupported\". This is an application, not a library, and I think that distinction is worth calling out. Because if \"unsupported\" means \"nonportable\", then that's much more of a concern for a library than an application, since a library can assume much less about the contexts in which it is used than an application. Likewise, a nonportable library can cause forks in the ecosystem, but a nonportable application just causes annoyances for users of that application. And because as the developers of the application we're directly in touch with our users, that puts us closer to the problem than a library developer who might be several steps removed from the end-users, so we have more ability to respond if it turns out to be a problem in practice. So I can't say that we would necessarily remove it if it just meant \"your code might not be portable to other Rust implementations\".</p>\n<p>However, if \"unsupported\" meant \"undefined behavior\", then we would remove it, since our domain is security adjacent, and we care about passing code audits.</p>",
        "id": 270258923,
        "sender_full_name": "bstrie",
        "timestamp": 1643739186
    },
    {
        "content": "<p>I brought this topic up in the <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> meeting just now, and the general consensus was \"if someone writes up a list of directives, we'd be willing to review and merge a PR that adds that list to the reference or <code>asm!</code> docs\".</p>",
        "id": 270259241,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643739350
    },
    {
        "content": "<p>If someone else does the work to prepare the full list of directives in one place (ideally checking what the intersection of LLVM and GNU supports), I'm willing to do the work to review the list of directives and consider exclusions from that list.</p>",
        "id": 270259355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643739396
    },
    {
        "content": "<p>And then I'd review the resulting PR.</p>",
        "id": 270259361,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643739401
    },
    {
        "content": "<p>I can probably prepare the full list by tomorrow, though I'm too busy with uni to be able to compile that list today.</p>",
        "id": 270260891,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643740036
    },
    {
        "content": "<p>Not a huge rush, just ideally need to do it before stabilization.</p>",
        "id": 270261164,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643740146
    },
    {
        "content": "<p>And thank you.</p>",
        "id": 270261181,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643740154
    },
    {
        "content": "<p>Please feel free to include a separate list of what you don't think we should support (whether because you don't personally want to implement it or because you think it's a bad idea even if you <em>can</em> easily implement it), but please keep that list separate to allow for evaluation.</p>",
        "id": 270261294,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643740191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270261294\">said</a>:</p>\n<blockquote>\n<p>Please feel free to include a separate list of what you don't think we should support (whether because you don't personally want to implement it or because you think it's a bad idea even if you <em>can</em> easily implement it), but please keep that list separate to allow for evaluation.</p>\n</blockquote>\n<p>Yes, I will give them separately.</p>",
        "id": 270261413,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643740224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270236170\">said</a>:</p>\n<blockquote>\n<p>I guess <code>.intel_syntax</code> is going to be among the supported directives? That will make grammar parsing <em>fun</em> (to borrow a phrase)</p>\n</blockquote>\n<p><code>.intel_syntax</code> is only partially supported by LLVM. LLVM AS don't support <code>.intel_syntax prefix</code>.</p>",
        "id": 270269783,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643743377
    },
    {
        "content": "<p><code>.intel_syntax</code> and <code>.att_syntax</code> would also lead to unspecified behavior if not reset before the end of the asm block. For example llvm concatenates all global_asm!() blocks, which would leak the syntax specifier from one global asm block to another. Gcc directly adds inline asm to the emitted asm next to the codegened function contents.</p>",
        "id": 270271011,
        "sender_full_name": "bjorn3",
        "timestamp": 1643743835
    },
    {
        "content": "<p>Huh, I was under the impression that GCC at least reset some state at the end of inline asm blocks.</p>",
        "id": 270271146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643743881
    },
    {
        "content": "<p>Maybe it does? I can check.</p>",
        "id": 270271211,
        "sender_full_name": "bjorn3",
        "timestamp": 1643743906
    },
    {
        "content": "<p>It doesn't. Adding <code>__asm__ volatile(\".intel_syntax\");</code> caused a compile error due to the following instructions not being recognized.</p>",
        "id": 270272606,
        "sender_full_name": "bjorn3",
        "timestamp": 1643744424
    },
    {
        "content": "<p><a href=\"https://gcc.godbolt.org/z/v1v8vjhz8\">https://gcc.godbolt.org/z/v1v8vjhz8</a></p>",
        "id": 270272653,
        "sender_full_name": "bjorn3",
        "timestamp": 1643744449
    },
    {
        "content": "<p>(sorry for the funky layout. compiler explorer doesn't really work well on mobile)</p>",
        "id": 270272742,
        "sender_full_name": "bjorn3",
        "timestamp": 1643744489
    },
    {
        "content": "<p>I don't think GCC actually look at the asm. It just passes the text verbatim to GAS.</p>",
        "id": 270272752,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643744493
    },
    {
        "content": "<p>I recall an lwn article about gcc using the line count of inline asm to estimate inlining costs. I believe it resulted in adding a comment to an inline asm block in the linux kernel regressing performance due to a different inlining decision.</p>",
        "id": 270273009,
        "sender_full_name": "bjorn3",
        "timestamp": 1643744573
    },
    {
        "content": "<p>Wow, somehow I was attributing more semantic value to the comments GCC emits that show the start and end of inline assembly.</p>",
        "id": 270273427,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643744742
    },
    {
        "content": "<p>I didn't know it'd just break due to statefulness.</p>",
        "id": 270273448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643744751
    },
    {
        "content": "<p>The asm RFC specifically states that behavior is undefined if you don't reset the assembler to its original state.</p>",
        "id": 270296085,
        "sender_full_name": "Amanieu",
        "timestamp": 1643753248
    },
    {
        "content": "<p>TBH, seems like it should be IFNDR.</p>",
        "id": 270300865,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643755500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270260891\">said</a>:</p>\n<blockquote>\n<p>I can probably prepare the full list by tomorrow, though I'm too busy with uni to be able to compile that list today.</p>\n</blockquote>\n<p>Appologies, took longer than I thought.  I have a list of the GNU directives, but I need to check each of their validity in llvm.</p>",
        "id": 271719392,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644714512
    },
    {
        "content": "<p>Fortunately the reverse direction should be easier: there aren't that many LLVM-specific directives to check. :)</p>",
        "id": 271719705,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644715041
    },
    {
        "content": "<p>Thanks for working on this!</p>",
        "id": 271719710,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644715048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271719705\">said</a>:</p>\n<blockquote>\n<p>Fortunately the reverse direction should be easier: there aren't that many LLVM-specific directives to check. :)</p>\n</blockquote>\n<p>The issue is that it's <em>very</em> hard to find them. They aren't documented anywhere that either myself or someone else who I've had helping me could find.</p>",
        "id": 271725112,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644724095
    },
    {
        "content": "<p>They all appear to be on <a href=\"https://llvm.org/docs/Extensions.html\">https://llvm.org/docs/Extensions.html</a> .</p>",
        "id": 271725466,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644724725
    },
    {
        "content": "<p>That includes both LLVM-specific directives, and LLVM-specific extensions to existing directives.</p>",
        "id": 271725477,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644724752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271725466\">said</a>:</p>\n<blockquote>\n<p>They all appear to be on <a href=\"https://llvm.org/docs/Extensions.html\">https://llvm.org/docs/Extensions.html</a> .</p>\n</blockquote>\n<p>Hello, I'm the person who ended up compiling the list. Unfortunately, this page is next to useless; in fact, there is one easy way to prove no comprehensive list exists: <code>grep</code> for <code>intel_syntax</code> in the docs and you'll get exactly one hit, and it's in a completely unrelated area.</p>",
        "id": 271779802,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1644806445
    },
    {
        "content": "<p>I have a filtered list of directives that probably exist in both GAS and LLVM-AS, but it is not fully verified. It is, however, down to &lt;250 directives, so it should be easier to manually verify.</p>",
        "id": 271779815,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1644806506
    },
    {
        "content": "<p>I leave it with you for your consideration: <a href=\"/user_uploads/4715/hzSwQCg2KpIpt6wANgQlx4_z/result2.txt\">result2.txt</a></p>",
        "id": 271779861,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1644806529
    },
    {
        "content": "<p>(naming due to me doing a serious of automated passes on text globbed from the docs by <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span>)</p>",
        "id": 271779873,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1644806557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"396093\">@Ray Redondo</span> I was making the assumption that that page listed <em>only</em> the directives unique to LLVM and <em>not</em> in GAS, which would explain it not having <code>intel_syntax</code>.</p>",
        "id": 271785945,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644816099
    },
    {
        "content": "<p>Right; that doesn't help to get a master list, it only helps to widdle down a nonexistent LLVM list.</p>",
        "id": 271787256,
        "sender_full_name": "Ray Redondo",
        "timestamp": 1644817966
    },
    {
        "content": "<p>Alright. I've filtered the list of directives by invoking the assembler and checking which directives yield \"unknown directive\" (on llvm-mc) or \"unknown pseudo-op\" (on GAS), then using some bash magic to get the intersection of the files<br>\nThe list is <a href=\"/user_uploads/4715/5pWy8AvAQDBLkdIcYFIQuxrY/both-valid.txt\">both-valid.txt</a>. </p>\n<p>This may not be an exhausitve list, but it should be close to one. Note that this covers only directives available on x86 gas, as those were the only ones I could check. Notably, the <code>.thumb*</code> directives aren't included, because I don't have an arm assembler.</p>",
        "id": 271818375,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644841102
    },
    {
        "content": "<p>Side note, I realised a potential problem with doing <code>.intel_syntax noprefix</code>, but I'd like input from someone knowledgeable in gcc codegen (either gcc-rs or cg_gcc especially or otherwise). GNU AS does <em>not</em> support the <code>noprefix</code> option IIRC, so if the assembler in use <em>is</em> actually GNU AS, it would require translation on top of the emission of the directive.</p>",
        "id": 271821642,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644843215
    },
    {
        "content": "<p>wrt. lccc's xlangcodegen_x86 (and likely other direct code generators, which will share a lot of machinery), this is a preliminary categorized list based on an initial pass. I may amend this when I do a more comprehensive check, and as development progresses (it may become easier to support certain directives - this is a defensive ). <br>\n<a href=\"https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/BkBQQ0w19\">https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/BkBQQ0w19</a></p>",
        "id": 271823511,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644844269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271821642\">said</a>:</p>\n<blockquote>\n<p>Side note, I realised a potential problem with doing <code>.intel_syntax noprefix</code>, but I'd like input from someone knowledgeable in gcc codegen (either gcc-rs or cg_gcc especially or otherwise). GNU AS does <em>not</em> support the <code>noprefix</code> option IIRC, so if the assembler in use <em>is</em> actually GNU AS, it would require translation on top of the emission of the directive.</p>\n</blockquote>\n<p>cg_clif uses <code>.intel_syntax noprefix</code> just fine with gnu afaik: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/d4594457993600987b4370ab5b258d4276e12b37/src/inline_asm.rs#L405\">https://github.com/bjorn3/rustc_codegen_cranelift/blob/d4594457993600987b4370ab5b258d4276e12b37/src/inline_asm.rs#L405</a></p>",
        "id": 271826582,
        "sender_full_name": "bjorn3",
        "timestamp": 1644845913
    },
    {
        "content": "<p>Ah yeah. I also just found out I tested this at some point (or was doing something else).<br>\nWeirdly, I can't find this at all in the documentation. Or <code>.intel_syntax</code> at all for that matter.</p>",
        "id": 271827116,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644846224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271823511\">said</a>:</p>\n<blockquote>\n<p>wrt. lccc's xlangcodegen_x86 (and likely other direct code generators, which will share a lot of machinery), this is a preliminary categorized list based on an initial pass. I may amend this when I do a more comprehensive check, and as development progresses (it may become easier to support certain directives - this is a defensive ). <br>\n<a href=\"https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/BkBQQ0w19\">https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/BkBQQ0w19</a></p>\n</blockquote>\n<p><code>.code16</code> and <code>.code32</code> are required by <a href=\"https://github.com/rust-osdev/bootloader\">https://github.com/rust-osdev/bootloader</a> for bios support. It only uses them in <code>global_asm!()</code> if that helps. I think the <code>.bundle_*</code> directives wouldn't be too hard to implement. Especially as you may need to use an equivalent for loops to get better performance. <code>.incbin</code> may be nice to have for some use cases, though I suspect LTO breaks it anyway due to the current working directory of different rustc invocations being different. If so it should probably not be supported. <code>.abort</code> I also agree as the gnu as documentation mentions that it may not be supported one day. <code>.error</code> is not useful without <code>.if</code> or <code>.macro</code> I think. <code>.rept</code> could be emulated using a rust macro and <code>concat_str!()</code> I think.</p>",
        "id": 271827642,
        "sender_full_name": "bjorn3",
        "timestamp": 1644846456
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/91728\">https://github.com/rust-lang/rust/pull/91728</a> has already hit beta by the way FYI. Beta will be promoted to stable on the 24th, so only 10 days left for a decision I think.</p>",
        "id": 271827899,
        "sender_full_name": "bjorn3",
        "timestamp": 1644846597
    },
    {
        "content": "<p>Wait, 10 days? <br>\nFCP is what, 10 days? That's <em>fun</em>.</p>",
        "id": 271828095,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644846682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271827642\">said</a>:</p>\n<blockquote>\n<p><code>.code16</code> and <code>.code32</code> are required by <a href=\"https://github.com/rust-osdev/bootloader\">https://github.com/rust-osdev/bootloader</a> for bios support. It only uses them in <code>global_asm!()</code> if that helps. </p>\n</blockquote>\n<p>Yeah, that's <em>fun</em>. Currently my lists for global_asm vs. asm are the same, but they could easily be different.<br>\nThe main issue I have with <code>.code16</code> and <code>.code32</code> is that instruction collection and actual generation is two separate steps, and I'd have to track mode switches interleaved with instructions, labels, and raw bytes (from <code>.byte</code> et. al directives in assembly). For global_asm, which would presumably use a more primitive assembler, it would be easier to support the mode switch. For that matter, sections would be easier in that context, since it would be tied directly to the binary file emitter, rather than to a codegen that prepares the instructions, then is given a text section to encode it into.</p>",
        "id": 271829658,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644847347
    },
    {
        "content": "<p>(It's also not as easy as <em>just</em> tracking <code>.code16</code> vs. <code>.code32</code>in the generator as it has to switch addressing modes <em>for</em> the generation of instructions)</p>",
        "id": 271829747,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644847405
    },
    {
        "content": "<p>It may make sense to restrict <code>.code16</code> and <code>.code32</code> to <code>global_asm!()</code>, though it would probably seem like an arbitrary restriction to most people.</p>",
        "id": 271829859,
        "sender_full_name": "bjorn3",
        "timestamp": 1644847449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271821642\">said</a>:</p>\n<blockquote>\n<p>Side note, I realised a potential problem with doing <code>.intel_syntax noprefix</code>, but I'd like input from someone knowledgeable in gcc codegen (either gcc-rs or cg_gcc especially or otherwise). GNU AS does <em>not</em> support the <code>noprefix</code> option IIRC, so if the assembler in use <em>is</em> actually GNU AS, it would require translation on top of the emission of the directive.</p>\n</blockquote>\n<p>GNU AS supports <code>.intel_syntax noprefix</code>. I am not sure how you reached this conclusion but <code>noprefix</code> is the default if intel syntax is used (e.g. <code>-masm=intel</code>), and <code>prefix</code> is the default if AT&amp;T syntax is used. In fact, <code>.intel_syntax noprefix</code> and <code>.att_syntax prefix</code> are the common subset between GNU AS and LLVM AS, as LLVM as does not support <code>.intel_syntax prefix</code> or <code>.att_syntax noprefix</code>.</p>",
        "id": 271830159,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644847573
    },
    {
        "content": "<p>I was mostly checking from documentation: as I noted, I could not find <code>.intel_syntax [options]</code>.</p>",
        "id": 271830441,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644847696
    },
    {
        "content": "<p>A v. quick google gives: <a href=\"https://sourceware.org/binutils/docs/as/i386_002dVariations.html\">https://sourceware.org/binutils/docs/as/i386_002dVariations.html</a></p>",
        "id": 271830699,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644847801
    },
    {
        "content": "<p>(And another part of the GNU AS documentation states \"Register operands are always prefixed with ‘%’.\")<br>\nHuh. Well designed documentation.</p>",
        "id": 271830840,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644847851
    },
    {
        "content": "<p>I'm going to prepare a reference PR, taking from my first two lists, plus <code>.code16</code> and <code>.code32</code>. The PR can be changed, but getting this done quickly is probably a good idea.</p>",
        "id": 271843701,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644853329
    },
    {
        "content": "<p>Filed as a draft: <a href=\"https://github.com/rust-lang/reference/pull/1168\">https://github.com/rust-lang/reference/pull/1168</a></p>",
        "id": 271846122,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644854131
    },
    {
        "content": "<p>I don't think your hackmd doc contains all directives? E.g. <code>.fill</code> seems to be missing.</p>",
        "id": 271879185,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644868154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271879185\">said</a>:</p>\n<blockquote>\n<p>I don't think your hackmd doc contains all directives? E.g. <code>.fill</code> seems to be missing.</p>\n</blockquote>\n<p>Yeah, it's not exhaustive: anything I don't list is defensively under the last section. Although <code>.fill</code> is a silly omission <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>.</p>",
        "id": 271879451,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644868276
    },
    {
        "content": "<p>(Note that it's my opinion wrt. my implementation - the unseparated list is linked above)</p>",
        "id": 271879578,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644868335
    },
    {
        "content": "<p>BTW <a href=\"#narrow/stream/216763-project-inline-asm/topic/esi.20register.20on.20x86\">https://rust-lang.zulipchat.com/#narrow/stream/216763-project-inline-asm/topic/esi.20register.20on.20x86</a> currently has a scenario that requires the use of <code>.set</code> and <code>.if</code>.</p>",
        "id": 271880198,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644868673
    },
    {
        "content": "<p>Yeah... Heh.</p>",
        "id": 271880293,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644868708
    },
    {
        "content": "<p>For my personal use cases I think I need <code>.extern</code> and <code>.global</code> (only in global_asm), and a RISC-V arch specific <code>.option</code>.</p>",
        "id": 271880429,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644868793
    },
    {
        "content": "<p>Yeah, <code>.option</code> came up in the #os-dev channel of the community server: I'd find it has the same issues as <code>.code16</code>/<code>.code32</code>, in my case, I have to maintain that state twice, and getting them to agree is <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span>.</p>",
        "id": 271880880,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644869002
    },
    {
        "content": "<p>Without <code>.option</code> it is impossible to write some RISC-V code.</p>",
        "id": 271880981,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644869044
    },
    {
        "content": "<p>(It's very important even in non-global asm)</p>",
        "id": 271881018,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644869066
    },
    {
        "content": "<p>Oh fun. I hate having two sources of truth.</p>",
        "id": 271881037,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644869076
    },
    {
        "content": "<p>(lccc is designed over avoiding the left-hand/right-hand problem by never having more than one source of truth)</p>",
        "id": 271881184,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644869161
    },
    {
        "content": "<p>I'll go through the list you posted above, and see if there's any omissions that people will need in common assembly.</p>",
        "id": 271881255,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644869184
    },
    {
        "content": "<p>Thank you for working on this.</p>",
        "id": 271881268,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644869189
    },
    {
        "content": "<p>For example if you are trying to create some jump table with duff's device, you'll need to tell the assembler to not generate compressed instructions with <code>.option push; .option norvc</code> and then reset the state later with <code>.option pop</code></p>",
        "id": 271881338,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644869227
    },
    {
        "content": "<p>RISC-V (and some other archs) also have linker relaxation, which permits the linker to change your code after assembly (e.g. replace a two-instruction symbol address loading with a single offset from global pointer, if the symbol is placed into .sdata). And this sometimes need to be turned off via <code>.option push; .option norelax</code>. So it's kinda critical.</p>",
        "id": 271881544,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644869345
    },
    {
        "content": "<p>Yeah, I don't dispute that it's necessary... It's just... <em>fun</em>.</p>",
        "id": 271882950,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644870093
    },
    {
        "content": "<p>I just grepped through a crate that I'm working on and here's the list of asm directives I'm using:</p>\n<div class=\"codehilite\"><pre><span></span><code>.alt_entry\n.balign\n.cfi_endproc\n.cfi_escape\n.cfi_offset\n.cfi_sections\n.cfi_signal_frame\n.cfi_startproc\n.def\n.endef\n.equ\n.fnend\n.fnstart\n.globl\n.hidden\n.movsp\n.private_extern\n.save\n.scl\n.seh_endproc\n.seh_endprologue\n.seh_proc\n.seh_pushreg\n.seh_savereg\n.seh_setframe\n.seh_stackalloc\n.size\n.thumb\n.thumb_func\n.type\n</code></pre></div>",
        "id": 271887384,
        "sender_full_name": "Amanieu",
        "timestamp": 1644872373
    },
    {
        "content": "<p>Most of these are only used in <code>global_asm!</code> though.</p>",
        "id": 271887499,
        "sender_full_name": "Amanieu",
        "timestamp": 1644872408
    },
    {
        "content": "<p>Never heard of some of them. I assume many are platform-dependent?</p>",
        "id": 271887962,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644872619
    },
    {
        "content": "<p>Yea the seh_* ones are for x86_64 Windows. <code>fnstart</code>,<code>fnend</code>,<code>save</code>,<code>movsp</code>,<code>thumb</code>,<code>thumb_func</code> are ARM-specific. <code>scl</code>, <code>def</code> and <code>endef</code> are for specifying attributes of symbols on COFF (Windows) object files. <code>private_extern</code> and <code>alt_entry</code> are Darwin-specific.</p>",
        "id": 271888276,
        "sender_full_name": "Amanieu",
        "timestamp": 1644872751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271888276\">said</a>:</p>\n<blockquote>\n<p>Yea the seh_* ones are for x86_64 Windows. </p>\n</blockquote>\n<p>The seh_* ones were already excluded, where they not? I don't believe GNU AS supports them at all, thus they were excluded from the original Common Subset that was previously guaranteed support.</p>",
        "id": 271892105,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644874514
    },
    {
        "content": "<p>They are definitely supported: GCC emits them on win64.</p>",
        "id": 271893522,
        "sender_full_name": "Amanieu",
        "timestamp": 1644874993
    },
    {
        "content": "<p>It's not anywhere in the GNU AS documentation. I just grepped for <code>.seh_endproc</code> in my main list of all things that look like directives.</p>",
        "id": 271893721,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644875101
    },
    {
        "content": "<p><a href=\"https://sourceware.org/bugzilla/show_bug.cgi?id=20344\">https://sourceware.org/bugzilla/show_bug.cgi?id=20344</a></p>",
        "id": 271893852,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644875168
    },
    {
        "content": "<p>As I said before, well designed documentation.</p>",
        "id": 271893892,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644875196
    },
    {
        "content": "<p>(I can't find directives that aren't documented)</p>",
        "id": 271893960,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644875239
    },
    {
        "content": "<p>In any case, I'd imagine the seh stuff would be functionally equivalent to the cfi stuff, in terms of implementability.</p>",
        "id": 271894082,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644875288
    },
    {
        "content": "<p>Most of the ARM ones are also for CFI (ARM doesn't use DWARF CFI for unwinding).</p>",
        "id": 271897845,
        "sender_full_name": "Amanieu",
        "timestamp": 1644877184
    },
    {
        "content": "<p>Anything of the like is probably going to be the same or similar.</p>",
        "id": 271897976,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644877247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> are you ok with <code>.thumb</code>, <code>.thumb_func</code>,  <code>.alt_entry</code> being global_asm! only?</p>\n<p>I can't find any documentation at all on <code>.private_extern</code>, so I can't make any statements there.</p>",
        "id": 271989384,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644938551
    },
    {
        "content": "<p>I don't understand the motivation for special-casing global_asm!.</p>",
        "id": 271991469,
        "sender_full_name": "Amanieu",
        "timestamp": 1644939461
    },
    {
        "content": "<p>In normal inline asm you can use <code>.pushsection</code>/<code>.popsection</code> and write stuff to arbitrary sections. That gives you the same power as <code>global_asm!</code>.</p>",
        "id": 271991566,
        "sender_full_name": "Amanieu",
        "timestamp": 1644939502
    },
    {
        "content": "<p>I've noted how differently I handle <code>global_asm</code> vs. <code>asm</code> above. I have to generate asm when building a function, and I don't even have a binary file at that point (in fact, the current system, the IR is lowered into instructions before the output stream is even available)</p>",
        "id": 271992515,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644939959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/271991566\">said</a>:</p>\n<blockquote>\n<p>In normal inline asm you can use <code>.pushsection</code>/<code>.popsection</code> and write stuff to arbitrary sections. That gives you the same power as <code>global_asm!</code>.</p>\n</blockquote>\n<p>Also, that's not quite true.<br>\n<code>global_asm!</code>, you can assume will be generated exactly once.<br>\n<code>asm!</code> gives you no such power (in fact, it's possible that the output of <code>asm!</code> may not even exist at all)</p>",
        "id": 272015795,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949054
    },
    {
        "content": "<p>This means that you can't emit global symbols via <code>asm!</code>, so directives like <code>.globl</code>/<code>.global</code>/<code>.private_extern</code>, etc. are mostly nonsensical.</p>",
        "id": 272017100,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949608
    },
    {
        "content": "<p>I've updated the proposal to include more directives. I've also made the target-specific stuff and the asm vs. global_asm specific stuff more explicit.</p>",
        "id": 272017754,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644949889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272017100\">said</a>:</p>\n<blockquote>\n<p>This means that you can't emit global symbols via <code>asm!</code>, so directives like <code>.globl</code>/<code>.global</code>/<code>.private_extern</code>, etc. are mostly nonsensical.</p>\n</blockquote>\n<p>And yet, people will, and it'll mostly work.</p>",
        "id": 272018977,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644950422
    },
    {
        "content": "<p>Also, directives like <code>pushsection</code>/<code>popsection</code> can still be valid even if things are duplicated. For instance, if the issue is \"put the address of a label from this asm block into this special section\", if there are 5 copies of the asm block, you just add five addresses into the special section.</p>",
        "id": 272019079,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644950479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272018977\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272017100\">said</a>:</p>\n<blockquote>\n<p>This means that you can't emit global symbols via <code>asm!</code>, so directives like <code>.globl</code>/<code>.global</code>/<code>.private_extern</code>, etc. are mostly nonsensical.</p>\n</blockquote>\n<p>And yet, people will, and it'll mostly work.</p>\n</blockquote>\n<p>\"Mostly\"</p>",
        "id": 272019589,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644950704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272019079\">said</a>:</p>\n<blockquote>\n<p>Also, directives like <code>pushsection</code>/<code>popsection</code> can still be valid even if things are duplicated. For instance, if the issue is \"put the address of a label from this asm block into this special section\", if there are 5 copies of the asm block, you just add five addresses into the special section.</p>\n</blockquote>\n<p>Sure, and those are <em>fun</em>.</p>",
        "id": 272020193,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644950996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272019589\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272018977\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272017100\">said</a>:</p>\n<blockquote>\n<p>This means that you can't emit global symbols via <code>asm!</code>, so directives like <code>.globl</code>/<code>.global</code>/<code>.private_extern</code>, etc. are mostly nonsensical.</p>\n</blockquote>\n<p>And yet, people will, and it'll mostly work.</p>\n</blockquote>\n<p>\"Mostly\"</p>\n</blockquote>\n<p>The same issue exists in C code, where it's <em>possible</em> the compiler could duplicate an asm block.</p>",
        "id": 272022240,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644951823
    },
    {
        "content": "<p>People do it anyway and get the compiler to cooperate.</p>",
        "id": 272022353,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644951863
    },
    {
        "content": "<p><em>makes note to make option to make the compiler not cooperate</em></p>",
        "id": 272023043,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644952180
    },
    {
        "content": "<p><code>-Zhostile</code></p>",
        "id": 272023670,
        "sender_full_name": "Lokathor",
        "timestamp": 1644952460
    },
    {
        "content": "<p>In any case, it's already explicitly unsupported to rely on an <code>asm!</code> block being emitted exactly once, and implicitly unsupported to define any kind of symbols, especially symbols with external linkage.</p>",
        "id": 272027798,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644954265
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> taking a look at your list, here are the directives that we use that you haven't included:</p>\n<div class=\"codehilite\"><pre><span></span><code>.align\n</code></pre></div>",
        "id": 272028649,
        "sender_full_name": "bstrie",
        "timestamp": 1644954689
    },
    {
        "content": "<p>though .align is fine because you mention .balign</p>",
        "id": 272028782,
        "sender_full_name": "bstrie",
        "timestamp": 1644954729
    },
    {
        "content": "<p>... Why don't I have <code>.align</code> or <code>.short</code>.</p>\n<p>For <code>.macro</code>, that's one of the ones I'd really like to avoid, and <code>.set</code> heh...</p>",
        "id": 272028798,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644954739
    },
    {
        "content": "<p>and we've already discussed the infeasability of .macro</p>",
        "id": 272028818,
        "sender_full_name": "bstrie",
        "timestamp": 1644954745
    },
    {
        "content": "<p><code>.set</code>/<code>.equ</code> are probably fine.</p>",
        "id": 272028945,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644954811
    },
    {
        "content": "<p>Although I'd expect them not to not be guaranteed escape the <code>asm!</code> block.</p>",
        "id": 272029006,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644954842
    },
    {
        "content": "<p>For example, no:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\".equ a=2f;</span>\n<span class=\"s\">    2:</span>\n<span class=\"s\">        ...</span>\n<span class=\"s\">\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"jmp a\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272029387,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644955020
    },
    {
        "content": "<p>Although that wouldn't be too annoying.</p>",
        "id": 272029421,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644955035
    },
    {
        "content": "<p>Anyways, I've added all of those, except for <code>.macro</code>.</p>",
        "id": 272030134,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644955316
    },
    {
        "content": "<p>cool :)</p>",
        "id": 272031600,
        "sender_full_name": "bstrie",
        "timestamp": 1644956042
    },
    {
        "content": "<p>it does sort of suggest that we should do a broader survey of rust crates that use asm to see what directives they use in practice, if anyone has a spare copy of <a href=\"http://crates.io\">crates.io</a> lying around that they want to grep for <code>\"\\\"\\.[a-zA-Z_]\\+ \"</code> on</p>",
        "id": 272031796,
        "sender_full_name": "bstrie",
        "timestamp": 1644956144
    },
    {
        "content": "<p>Subsequent characters can also be <code>0-9</code>; e.g. <code>.code16</code>.</p>",
        "id": 272032717,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644956637
    },
    {
        "content": "<p>ah of course, that doesn't change anything in our case though</p>",
        "id": 272034222,
        "sender_full_name": "bstrie",
        "timestamp": 1644957363
    },
    {
        "content": "<blockquote>\n<p>Although I'd expect them not to not be guaranteed escape the <code>asm!</code> block.</p>\n</blockquote>\n<p>That would break the fallback scheme for inline asm anyway. If it were to jump to the second block, at the end of the second block it would return to the caller location of the first block as the saved return address hasn't changed.</p>",
        "id": 272039264,
        "sender_full_name": "bjorn3",
        "timestamp": 1644959735
    },
    {
        "content": "<p><code>.inst</code> is being used in Rust repo</p>",
        "id": 272051304,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644966497
    },
    {
        "content": "<p>Stdarch uses it for riscv I believe as some instructions aren't implemented in LLVM yet.</p>",
        "id": 272051379,
        "sender_full_name": "bjorn3",
        "timestamp": 1644966567
    },
    {
        "content": "<p>Oh fun.</p>",
        "id": 272051393,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644966586
    },
    {
        "content": "<p>That's just \"write bytes\" though, isn't it?</p>",
        "id": 272051403,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644966595
    },
    {
        "content": "<p>I think you can specify operands in addition to opcode</p>",
        "id": 272051562,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644966721
    },
    {
        "content": "<p>Ah, fun.</p>",
        "id": 272051652,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644966751
    },
    {
        "content": "<p>The RISC-V version of <code>.inst</code> can specify the encoding format, opcode, operands, and immediates; although this is not supported by LLVM AS so it couldn't be used in inline asm.</p>",
        "id": 272051673,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644966768
    },
    {
        "content": "<p>Anyways, it's functionally a \"write bytes\" directive, so I'd just chuck it in with the \"write bytes\" directives.</p>",
        "id": 272051709,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644966795
    },
    {
        "content": "<p>I guess you would need it if e.g. you used rust-level operands (instead of encoding them directly)</p>",
        "id": 272051744,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644966837
    },
    {
        "content": "<p><code>.db 0x31, 0xC0</code>&gt; <code>xor eax, eax</code></p>",
        "id": 272051855,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644966905
    },
    {
        "content": "<p>not really, you can encode relocation with <code>.inst</code></p>",
        "id": 272052297,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644967239
    },
    {
        "content": "<p>Hmm... True. Although, you can encode relocations with <code>.long</code> as well.</p>",
        "id": 272052335,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644967272
    },
    {
        "content": "<p>I think with <code>.inst</code> you can let the linker perform relaxation as well, so it's probably more powerful. But you are correct, just \"write bytes\" would need relocation.</p>",
        "id": 272052696,
        "sender_full_name": "Gary Guo",
        "timestamp": 1644967547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272052696\">said</a>:</p>\n<blockquote>\n<p>I think with <code>.inst</code> you can let the linker perform relaxation as well, so it's probably more powerful. But you are correct, just \"write bytes\" would need relocation.</p>\n</blockquote>\n<p>relaxations are just another form of relocation.</p>",
        "id": 272129019,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645024585
    },
    {
        "content": "<p>Global assembly seems pretty useless without ability to use many of the directives useful for function definitions (<code>.size</code>, <code>.type</code>, <code>.p2align</code>, though for the last one I guess <code>.align</code> is a good enough of a replacement). OTOH some of the directives (<code>.cfi_startproc</code> for example) are only useful when defining a function (can this be readily done outside of <code>global_asm!</code>?)</p>",
        "id": 272332851,
        "sender_full_name": "nagisa",
        "timestamp": 1645136468
    },
    {
        "content": "<p>/me looks at <code>.cantunwind</code> in their arm assembly and wonders if it has any value...</p>",
        "id": 272333023,
        "sender_full_name": "nagisa",
        "timestamp": 1645136538
    },
    {
        "content": "<p>If there are no other directives to add, would it be a good idea to get it approved?</p>",
        "id": 272427290,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645203638
    },
    {
        "content": "<p>I suppose it's reasonable, in practical terms it's not like any code will stop compiling, at least not until alternative Rust backends start becoming feasible. And the list can always be expanded.</p>",
        "id": 272428338,
        "sender_full_name": "bstrie",
        "timestamp": 1645204078
    },
    {
        "content": "<p>Yes, it's easier to expand this list than to shrink it.</p>",
        "id": 272428832,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645204290
    },
    {
        "content": "<p>I'll take a look at the list today, see if anything seems missing, and see about getting an approval started.</p>",
        "id": 272430919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645205362
    },
    {
        "content": "<p>I've checked through some of my older code and found uses of <code>.previous</code> which work in a similar way to <code>.popsection</code>.</p>",
        "id": 272433488,
        "sender_full_name": "Amanieu",
        "timestamp": 1645206543
    },
    {
        "content": "<p>yes i would expect .previous to work</p>",
        "id": 272436870,
        "sender_full_name": "Lokathor",
        "timestamp": 1645207941
    },
    {
        "content": "<p>I've now posted all the comments I think I need to post to the reference PR.</p>",
        "id": 272504136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645260304
    },
    {
        "content": "<p>Some additions to the directives list, some details about how we should list directives, and a couple of questions about whether LLVM supports certain directives.</p>",
        "id": 272504156,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645260342
    },
    {
        "content": "<p>As soon as those additions are processed, I'm happy to start an FCP. We should cover that in the next lang meeting, and once we've confirmed consensus we should go ahead and merge it. We can always adjust it later.</p>",
        "id": 272531437,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645292402
    },
    {
        "content": "<p>I haven't been following this discussion very closely so forgive me if the subject has already been discussed. Are there any plans to have a lint in <code>rustc</code> based on the pre-compiled list?</p>",
        "id": 272532385,
        "sender_full_name": "Urgau",
        "timestamp": 1645293515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327095\">@Urgau</span> That would require doing a substantial amount of parsing of the <code>asm!</code> block, which we don't have plans to do in the short term. At the moment this list is just intended as documentation of what's supported.</p>",
        "id": 272532425,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645293585
    },
    {
        "content": "<p>Okay but why substantial ? Aren't they always on a separate line ? And always begin with a \".\" ?<br>\nThe lint wouldn't need to understand the asm syntax it just need to recognize without ambiguity directives, no ?</p>",
        "id": 272532866,
        "sender_full_name": "Urgau",
        "timestamp": 1645294041
    },
    {
        "content": "<p>You can use <code>;</code> to separate instructions on the same line. In addition there is <code>//</code> for comments on all platforms in LLVM and also architecture dependent comment characters.</p>",
        "id": 272532940,
        "sender_full_name": "bjorn3",
        "timestamp": 1645294110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327095\">@Urgau</span> asm syntax has more complexity than that. Comments, line continuation, string constants, many ways that a . at the start of a line might not be a directive.</p>",
        "id": 272532974,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645294157
    },
    {
        "content": "<p>So for example <code>.db 1 // .illegal_directive</code> is fine, but <code>nop; .illegal_directive</code> is not.</p>",
        "id": 272532976,
        "sender_full_name": "bjorn3",
        "timestamp": 1645294159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Ah, right, I forgot about <code>;</code> as well.</p>",
        "id": 272532996,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645294181
    },
    {
        "content": "<p>I knew I was missing something obvious. Thanks.</p>",
        "id": 272533072,
        "sender_full_name": "Urgau",
        "timestamp": 1645294267
    },
    {
        "content": "<p>For extra fun, some assembly dialects use <code>;</code> to indicate the start of a comment like <code>//</code>.</p>",
        "id": 272533736,
        "sender_full_name": "Amanieu",
        "timestamp": 1645295068
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327095\">@Urgau</span> I wouldn't call it obvious; yours was a reasonable suggestion, and it has come up a few times before for the same reason.</p>",
        "id": 272534071,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645295444
    },
    {
        "content": "<p>I think only considering <code>//</code> a comment for the purpose of this lint would be fine. <code>//</code> works on all platforms in LLVM. I'm not sure it also works with gnu as, but cg_clif has code to strip it: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/f606a5807cc954dc9f01f5a943f8479bdee96e09/src/driver/aot.rs#L350-L355\">https://github.com/bjorn3/rustc_codegen_cranelift/blob/f606a5807cc954dc9f01f5a943f8479bdee96e09/src/driver/aot.rs#L350-L355</a></p>",
        "id": 272534178,
        "sender_full_name": "bjorn3",
        "timestamp": 1645295549
    },
    {
        "content": "<p><code>/*</code> comments also work, and span lines.</p>",
        "id": 272534291,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645295690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272532940\">said</a>:</p>\n<blockquote>\n<p>You can use <code>;</code> to separate instructions on the same line. In addition there is <code>//</code> for comments on all platforms in LLVM and also architecture dependent comment characters.</p>\n</blockquote>\n<p>Not always: Some architectures use <code>;</code> as a comment char.</p>",
        "id": 272534487,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645295887
    },
    {
        "content": "<p>I think my current w65 assembler in GNU AS does, since # is used to indicate immediates.</p>",
        "id": 272534501,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645295909
    },
    {
        "content": "<p>(I'm curious how lines would be separated on such platforms, other than newlines)</p>",
        "id": 272534714,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645296160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272504136\">said</a>:</p>\n<blockquote>\n<p>I've now posted all the comments I think I need to post to the reference PR.</p>\n</blockquote>\n<p>I committed some of the suggestions, and added comments. <br>\nI can work on sorting the list either later today or tomorrow (earlier morning, since I plan to stream work on lccc during the day tomorrow).</p>",
        "id": 272535176,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645296682
    },
    {
        "content": "<p>Thank you; will follow up later today or tomorrow.</p>",
        "id": 272540633,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645302479
    },
    {
        "content": "<p>I've sorted the lists and added <code>.intel_syntax</code>/<code>.att_syntax</code>.</p>\n<p>One note, I've called it undefined behaviour to leave the asm block in the wrong mode, but this is actually closer to Ill-formed, no diagnostic required (in that it makes running the entire program UB, not just specifically entering and leaving the asm block), because it could actually \"leak\" outside of the function and to code that can be executed without touching the asm block at all. I wonder if that should be changed for all the \"You must revert the state of the assembler back to the default\" UB.</p>",
        "id": 272592212,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645363533
    },
    {
        "content": "<p>One thing I thought of that might be nice to explore, but not right away, is making \"assembler-specific behaviour\" to \"implementation-defined behaviour\" from what it is currently (which I would assume is \"unspecified behaviour).<br>\nThis would require implementations to document any additional directives or additional syntax it supports (Note: rustc+llvm saying \"whatever llvm does\" would be valid documentation, albeit vague). I thought of this because, realistically, an implementation (if we define it as the tuple of: driver opetions, frontend+version, backend+version) likely would differ wildly between uses in what directives it supports.<br>\nWe could also call the behaviour of using operands in the wrong assembler mode implementation-defined, since I don't really see more than two options: syntactic interpolation(which breaks, but may be fixable), and semantic interpolation (which doesn't).</p>",
        "id": 272595974,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645367699
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I had been thinking of it as compile-time undefined, not runtime.</p>",
        "id": 272602557,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375102
    },
    {
        "content": "<p>As in, it's undefined what the emitted code does.</p>",
        "id": 272602610,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375165
    },
    {
        "content": "<p>Yeah, which, in C++ terms is usually called ill-formed, no diagnostic required.</p>",
        "id": 272602624,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645375193
    },
    {
        "content": "<p>(In particular, it implies that a diagnostic is permitted)</p>",
        "id": 272602678,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645375214
    },
    {
        "content": "<p>Sounds accurate, but also, in general I want to define whatever terms we're using, and not just borrow them from the C++ spec.</p>",
        "id": 272602701,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375253
    },
    {
        "content": "<p>And in the absence of a need for a different term, I had been just using things like \"must\" vs \"should\".</p>",
        "id": 272602780,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375331
    },
    {
        "content": "<p>Sure. This can probably be changed for an actual spec (I don't believe any documentation currently uses ill-formed in general anyways) just a note of how I've been thinking about it.</p>",
        "id": 272602781,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645375331
    },
    {
        "content": "<p>Fair enough. Definitely nothing wrong with learning from other specs. I just expect that our spec process will want to give careful consideration to how we want to relate to our community and similar, in the phrasings it uses and the strategies of definitions it uses.</p>",
        "id": 272602844,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375424
    },
    {
        "content": "<p>(Which, I also recognize, is a trade-off with familiarity from other specs. But one to consider, because I expect on balance the primary audience of our spec will be Rust people, more so than spec people.)</p>",
        "id": 272603032,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Regarding the syntax directives, I wanted to make sure: do you have any other reason not to add them, other than supporting the syntaxes they switch to (which we already have an option for)? Because they don't seem especially critical, I just added them because we effectively support them anyway and it didn't seem like it would hurt to document that.</p>",
        "id": 272603266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375880
    },
    {
        "content": "<p>Unrelated: commit <a href=\"https://github.com/rust-lang/reference/pull/1168/commits/d5ded80d639536a61009cedcb8f129c06b7ea14e\">https://github.com/rust-lang/reference/pull/1168/commits/d5ded80d639536a61009cedcb8f129c06b7ea14e</a> seems to have reverted a bunch of other changes.</p>",
        "id": 272603395,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645375998
    },
    {
        "content": "<p>No, I have no issues, as long as I'm not required to error on <code>{}</code> intel interpolations when switched to <code>.att_syntax prefix</code>.<br>\nThe main issue was not wanting to have to support at&amp;t syntax.</p>",
        "id": 272603405,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645376005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272603395\">said</a>:</p>\n<blockquote>\n<p>Unrelated: commit <a href=\"https://github.com/rust-lang/reference/pull/1168/commits/d5ded80d639536a61009cedcb8f129c06b7ea14e\">https://github.com/rust-lang/reference/pull/1168/commits/d5ded80d639536a61009cedcb8f129c06b7ea14e</a> seems to have reverted a bunch of other changes.</p>\n</blockquote>\n<p>Yeah, I'll fix that later. I've been using <a href=\"http://github.dev\">github.dev</a>, and it normally works fine, but apparently it does that.</p>",
        "id": 272603434,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645376039
    },
    {
        "content": "<p>As much as I would <em>like</em> it to be the case that other Rust compilers error in every case rustc does, in practice that isn't always going to be feasible, and this particular case doesn't seem especially harmful. :)</p>",
        "id": 272604162,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645376764
    },
    {
        "content": "<p>I would certainly like to <em>minimize</em> cases where error behavior diverges.</p>",
        "id": 272604202,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645376831
    },
    {
        "content": "<p>But it's less important than other things, most of the time, unless it actually meaningfully extends the language.</p>",
        "id": 272604219,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645376856
    },
    {
        "content": "<p>(TBH, erroring here would actually be not that much more difficult, in fact, it's more fiesible, since I could issue an error for <code>mov ${}, rax</code> in <code>.att_syntax</code> mode, whereas syntactic interpolations could not)</p>",
        "id": 272604238,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645376876
    },
    {
        "content": "<p>I think I've fixed the mess up in d5ded80.</p>",
        "id": 272624051,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645399559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> TIL that <code>.intel_syntax</code> seems to default to <code>noprefix</code>, and <code>.intel_syntax noprefix</code> seems to be redundant.</p>",
        "id": 272722262,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645468484
    },
    {
        "content": "<p>It is, yes. It's also technically noted as unsupported (in the current form). Should I remove that reference from earlier in the document, then (or should that be left to a different reference pr)?</p>",
        "id": 272722502,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645468677
    },
    {
        "content": "<p>Which reference?</p>",
        "id": 272722764,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645468831
    },
    {
        "content": "<p>Oh, do you mean the line <code> On x86, the `.intel_syntax noprefix` mode of GAS is used by default.</code>?</p>",
        "id": 272722917,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645468928
    },
    {
        "content": "<p>Yeah, that one.</p>",
        "id": 272722934,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645468939
    },
    {
        "content": "<p>I think that line should perhaps get tweaked to help people know that <code>noprefix</code> is the default for <code>.intel_syntax</code>, but not in this PR.</p>",
        "id": 272722940,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645468946
    },
    {
        "content": "<p>I think the only other question to settle in this PR is the current separation between directives valid in all asm and directives valid in global_asm.</p>",
        "id": 272722971,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645468971
    },
    {
        "content": "<p>When I read that section it wasn't clear to me which one was the default and how to set it back to the original behavior as required</p>",
        "id": 272723005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I don't think I understand your objection to limiting <code>asm</code> directives on the basis of two-pass assembly.</p>",
        "id": 272723073,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469049
    },
    {
        "content": "<p>The above section? Or the one indicating how it's supported in the PR?</p>",
        "id": 272723080,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645469051
    },
    {
        "content": "<p>I assume there isn't any convenient <code>.reset_asm_state</code> directive to call</p>",
        "id": 272723085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272723085\">said</a>:</p>\n<blockquote>\n<p>I assume there isn't any convenient <code>.reset_asm_state</code> directive to call</p>\n</blockquote>\n<p>Unfortunately no.</p>",
        "id": 272723092,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469059
    },
    {
        "content": "<p>the section in the PR about <code>.intel_syntax</code> and <code>.att_syntax</code></p>",
        "id": 272723120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469083
    },
    {
        "content": "<p>If there was such a reset directive, we'd probably auto-insert that at the end of every <code>.asm</code> block.</p>",
        "id": 272723128,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469089
    },
    {
        "content": "<p>if <code>.att_syntax</code> is the default, we could just auto insert that</p>",
        "id": 272723159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469119
    },
    {
        "content": "<p>along with any other directives where we can definitely determine the default state</p>",
        "id": 272723185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469141
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> <code>.intel_syntax</code> is the default, unless you use <code>options(att_syntax)</code>. But it seems a little painful to insert an additional amount of text for the assembler to process on the off chance that someone changed a setting that almost nobody changes.</p>",
        "id": 272723314,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469234
    },
    {
        "content": "<p>If we had a single reset, that would be worth doing, but without that, there are enough things to reset that we'd have to insert quite a few directives. And some of them aren't resettable in an \"absolute\" sense (e.g. which section we're in).</p>",
        "id": 272723346,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469266
    },
    {
        "content": "<p>also I've been resisting the urge to point out that <code>.</code> is asm state that isn't reset</p>",
        "id": 272723354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469273
    },
    {
        "content": "<p>As in, having a trailing <code>.</code> at the end of an asm block?</p>",
        "id": 272723413,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469292
    },
    {
        "content": "<p>no, <code>.</code> meaning the asm instruction pointer</p>",
        "id": 272723430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645469309
    },
    {
        "content": "<p>Ah.</p>",
        "id": 272723446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469317
    },
    {
        "content": "<p>True, and that probably needs to get addressed. Advancing the instruction pointer by inserting instructions seems fine, using <code>.org</code> seems likely to wreak havoc though.</p>",
        "id": 272723488,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645469351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272723073\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> I don't think I understand your objection to limiting <code>asm</code> directives on the basis of two-pass assembly.</p>\n</blockquote>\n<p>So, the way I'd translate inline asm in xlangcodegen-x86 (et. al) is to parse the assembly string when building the instruction stream and doing codegen on the other xir isntructions. This is the early pass, and doesn't have a few things, namely:</p>\n<ul>\n<li>It doesn't encode the instruction yet,</li>\n<li>It doesn't have a binary file or section to write to. Currently, a there's a vec of <code>Instruction(X86Instruction)</code> and <code>Label(String)</code>, where the former is an abstract representation of an x86 instruction, and the latter is a named label. There would also be <code>RawBytes(Vec&lt;u8&gt;)</code>. <br>\nAfter the early pass, the instruction stream produced from writing all of the blocks, expressions, targets, etc. is encoded where the output stream is known. One issue with, e.g. <code>.code16</code>, is that <code>.code16</code> needs to agree when the instruction is built vs. when it's generated, or you'd swap uses of 66h and 67h prefixes, then suddenly <code>.code16; mov ax, word ptr [bx+si]</code> gets encoded as <code>mov eax, dword ptr [rax]</code>.</li>\n</ul>",
        "id": 272723820,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645469576
    },
    {
        "content": "<p>Would it be possible to have an inline asm \"instruction\" where the inline asm is parsed only when actually emitting this instruction?</p>",
        "id": 272724332,
        "sender_full_name": "bjorn3",
        "timestamp": 1645469948
    },
    {
        "content": "<p>There is an inline asm instruction in xir, but like the other xir instructions, it would be handled during the early pass.</p>",
        "id": 272725108,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645470342
    },
    {
        "content": "<p>Why not treat the whole inline assembly as an opaque instruction all the way to the late pass. Then, after register allocation, substitute in register names and run an assembler separately over the inline assembly. That should get you a set of raw bytes that you can insert back in the original instruction stream.</p>",
        "id": 272726070,
        "sender_full_name": "Amanieu",
        "timestamp": 1645470927
    },
    {
        "content": "<p>Allows me to mark registers as \"Allocated\" for the length of the asm block and insert saving code before and after the assembly.</p>",
        "id": 272726251,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645471072
    },
    {
        "content": "<p>Sure, but you can do that at the granularity of a whole inline asm block at once. That's what all the <code>in</code>/<code>out</code> constraints are for.</p>",
        "id": 272726565,
        "sender_full_name": "Amanieu",
        "timestamp": 1645471260
    },
    {
        "content": "<p>Well, one of the main things is that it gets parsed into <code>X86Instruction</code>s anyways, since the output needs a <code>Section</code> (to write addresses). The labels would also be easier to handle in the first pass.</p>",
        "id": 272730188,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645473816
    },
    {
        "content": "<p>One other thing I also considered is that carrying the asm block into the writer requires carrying more information that's nominally useless (Specifically, it requires carrying expression stack information to satisfy unbounded constraints, and I think that's the kind of information that could very easily desync from pass 2).</p>",
        "id": 272738423,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645480414
    },
    {
        "content": "<p>Stack Desyncs are <em>fun</em>, and compound quickly arround opaque bounderies, such as jumps, and I'd also assume asm expressions (can you enter one asm block, jmp to a different one, then exit the second one, as long as you don't cross a function boundary?)</p>",
        "id": 272738573,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645480557
    },
    {
        "content": "<p>no, jumping between asm blocks is not allowed. gcc and clang have a way to do this for as long as you explicitly specify which asm block jumps to which. rust doesn't provide a way to allow this. it would also be hard to implement with the external assembler fallback implementation of inline asm.</p>",
        "id": 272739654,
        "sender_full_name": "bjorn3",
        "timestamp": 1645481459
    },
    {
        "content": "<p>Ight.</p>",
        "id": 272739669,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645481486
    },
    {
        "content": "<p>(Which means I can propagate stack values past an assembly block)</p>",
        "id": 272739688,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645481510
    },
    {
        "content": "<p><em>nod</em>, you can.</p>",
        "id": 272739693,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481519
    },
    {
        "content": "<p>Though they might get modified by the asm block, for instance.</p>",
        "id": 272739744,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481543
    },
    {
        "content": "<p>Long-term, I do hope we provide a simple version of what GCC/clang use <code>asm goto</code> for.</p>",
        "id": 272739756,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481555
    },
    {
        "content": "<p>But in a less general fashion.</p>",
        "id": 272739767,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481564
    },
    {
        "content": "<p>Less of an <code>asm goto</code>, more of an <code>asm if</code> or <code>asm match</code>.</p>",
        "id": 272739770,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481574
    },
    {
        "content": "<p>Well, I doubt it, since 90% of the stack is magic constant values (stack here is a virtual expression stack used by xir to pass operands to xir instructions, not the actual physical stack).</p>",
        "id": 272739813,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645481618
    },
    {
        "content": "<p>I see. That's a bit of a confusing conflation there. :)</p>",
        "id": 272739964,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272739744\">said</a>:</p>\n<blockquote>\n<p>Though they might get modified by the asm block, for instance.</p>\n</blockquote>\n<p>Also, correct me if I'm wrong, but IIRC, asm blocks are only allowed to modify inputs to the block, and globals.</p>",
        "id": 272739967,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645481753
    },
    {
        "content": "<p>If you don't pass <code>nostack</code>, you can modify things on the stack; you'd have to pass in an address or similar to <em>find</em> it with, but the compiler may not be tracking that you've done so.</p>",
        "id": 272740070,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481857
    },
    {
        "content": "<p>Or more generally, the compiler isn't doing full alias analysis to find out what you <em>might</em> access from an <code>asm</code> block.</p>",
        "id": 272740121,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481885
    },
    {
        "content": "<p>Well, the locals might not <em>be</em> on the hardware stack.</p>",
        "id": 272740143,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645481915
    },
    {
        "content": "<p>(Unless you've passed a pointer to them)</p>",
        "id": 272740147,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645481924
    },
    {
        "content": "<p>I'm not suggesting that <code>asm</code> can magically walk up the stack and modify something, just that we don't rule out that <code>asm</code> can get an address in a way that the compiler doesn't know about and use it for writing.</p>",
        "id": 272740175,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481965
    },
    {
        "content": "<p>Unless you pass <code>options(nostack)</code>.</p>",
        "id": 272740179,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645481970
    },
    {
        "content": "<p>As one random example, you <em>could</em> have a raw pointer to something on the stack, that you cast to an integer and stuff in a location somewhere, then run an asm block, then the thing on the stack is modified.</p>",
        "id": 272740282,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645482035
    },
    {
        "content": "<p>Sure, but the asm block needs to have access to the address.</p>",
        "id": 272740310,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645482074
    },
    {
        "content": "<p>Right, but the compiler might not have enough analysis to <em>know</em> that.</p>",
        "id": 272740317,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645482085
    },
    {
        "content": "<p>So it has to assume that such an access might happen, and not cache things in registers across an asm block.</p>",
        "id": 272740334,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645482107
    },
    {
        "content": "<p>That just goes to provenance, which is a whole can of worms, but suffice it to say, I think any good compiler already knows how to deal with escaped provenance.</p>",
        "id": 272740385,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645482136
    },
    {
        "content": "<p>But I highly doubt a compiler is unable to vaporise <code>x</code> entirely in the following code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"/*do some shenanigans*/\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Otherwise, that turns into a huge problem in that <code>asm</code> could be used inside a black_box function the compiler can't analyze. And in that case, we compiler devs love to be spooky and say that kills alias analysis entirely.</p>",
        "id": 272740506,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645482256
    },
    {
        "content": "<p>I agree in principle; the compiler <em>can</em> at least tell that a pointer to <code>x</code> has been passed somewhere-or-other and thus it can't make assumptions about <code>x</code> anymore across certain types of boundaries, even if it doesn't know that the somewhere-or-other is the <code>asm</code> block.</p>",
        "id": 272740564,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645482346
    },
    {
        "content": "<p>So in some manner, the asm block does need to get access to the address. Either:</p>\n<ul>\n<li>it's a global variable that isn't internal linkage (which basically doesn't happen for rust), or it's the same TU, which compilers already are ware can change,</li>\n<li>A pointer was given to the asm block, possibly indirectly, or</li>\n<li>A pointer to the local escaped (IE. was cast to an integer)<br>\nSo, there's nothing at all new here.</li>\n</ul>",
        "id": 272740656,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645482424
    },
    {
        "content": "<p>Any good optimizing compiler already knows how to deal with code it can't analyze.</p>",
        "id": 272740785,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645482557
    },
    {
        "content": "<p>I'm aware. I just didn't want to ignore the statement \"can propagate stack values past an assembly block\" without noting the unstated assumptions of what the compiler <em>does</em> have to handle.</p>",
        "id": 272740908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645482652
    },
    {
        "content": "<p>Well, it can propagate vstack values past an assembly block as long as the assembly block isn't a control flow destination.</p>",
        "id": 272741013,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645482737
    },
    {
        "content": "<p>Just to clarify, all <code>option(nostack)</code> does is allow the function to use the stack red zone on some platforms. Basically if you <em>don't</em> use <code>option(nostack)</code> then the asm block is allowed to allocate temporary stack space (the stack pointer must be restored before exiting the asm block).</p>",
        "id": 272741061,
        "sender_full_name": "Amanieu",
        "timestamp": 1645482810
    },
    {
        "content": "<p>It has nothing to do with arbitrary access to locals on the stack.</p>",
        "id": 272741065,
        "sender_full_name": "Amanieu",
        "timestamp": 1645482823
    },
    {
        "content": "<p>Which is the main thing I care about, because vstack desyncs issues compound at points where stack values are forced go from transparent (constant, temporary value, global/label/local address, etc.) to opaque. At those points I want to minimize the number of places that have to agree about the contents of the vstack, which would be very annoying if I have to handle assigning registers/constraints at output time (when the vstack is otherwise basically erased).</p>",
        "id": 272741332,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645483044
    },
    {
        "content": "<p>Honestly the simplest thing to do is to just treat an asm block like an opaque function call with a custom calling convention. This is what rustc does and also what LLVM does for the entire middle-end and most of the back-end.</p>",
        "id": 272741460,
        "sender_full_name": "Amanieu",
        "timestamp": 1645483163
    },
    {
        "content": "<p>I just attempted to poke rfcbot for an FCP, but it doesn't seem to have heard me: <a href=\"https://github.com/rust-lang/reference/pull/1168#issuecomment-1047274739\">https://github.com/rust-lang/reference/pull/1168#issuecomment-1047274739</a></p>",
        "id": 272741564,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483234
    },
    {
        "content": "<p>I don't think a full FCP is needed here. This is mainly clarifying the specification of asm!, not making an actual language/compiler change.</p>",
        "id": 272741724,
        "sender_full_name": "Amanieu",
        "timestamp": 1645483391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I've nominated it for tomorrow's lang meeting, and in practice I'm hoping it's a fast signoff with minimal objection.</p>",
        "id": 272741751,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483425
    },
    {
        "content": "<p>I do think, in principle, that it's a small and reasonably reversible change.</p>",
        "id": 272741807,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483452
    },
    {
        "content": "<p>So I don't think it has a hard requirement of an FCP.</p>",
        "id": 272741818,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483459
    },
    {
        "content": "<p>It just seemed like the easiest solution to make sure this gets handled. :)</p>",
        "id": 272741824,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483468
    },
    {
        "content": "<p>Unrelated: <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Could you trim trailing whitespace so that CI passes, please?</p>",
        "id": 272741851,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272741460\">said</a>:</p>\n<blockquote>\n<p>Honestly the simplest thing to do is to just treat an asm block like an opaque function call with a custom calling convention. This is what rustc does and also what LLVM does for the entire middle-end and most of the back-end.</p>\n</blockquote>\n<p>Even opaque function calls have to interact with the vstack, to recieve parameters, and push results. This is functionally doing exactly what llvm is doing, except I have ideas down the road to look at the asm and set hint attributes that soft-assume the asm block isn't doing things (soft-assume meaning the codegen may be pessimized if it does, rather than it being hard UB).</p>",
        "id": 272742051,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645483706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272741851\">said</a>:</p>\n<blockquote>\n<p>Unrelated: <span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> Could you trim trailing whitespace so that CI passes, please?</p>\n</blockquote>\n<p>Probably. I have no clue where the trailing whitespace is, but I'll look.</p>",
        "id": 272742064,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645483727
    },
    {
        "content": "<p>Yeah, style-check should really print line numbers.</p>",
        "id": 272742079,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272723820\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272723073\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> I don't think I understand your objection to limiting <code>asm</code> directives on the basis of two-pass assembly.</p>\n</blockquote>\n<p>So, the way I'd translate inline asm in xlangcodegen-x86 (et. al) is to parse the assembly string when building the instruction stream and doing codegen on the other xir isntructions. This is the early pass, and doesn't have a few things, namely:</p>\n<ul>\n<li>It doesn't encode the instruction yet,</li>\n<li>It doesn't have a binary file or section to write to. Currently, a there's a vec of <code>Instruction(X86Instruction)</code> and <code>Label(String)</code>, where the former is an abstract representation of an x86 instruction, and the latter is a named label. There would also be <code>RawBytes(Vec&lt;u8&gt;)</code>. <br>\nAfter the early pass, the instruction stream produced from writing all of the blocks, expressions, targets, etc. is encoded where the output stream is known. One issue with, e.g. <code>.code16</code>, is that <code>.code16</code> needs to agree when the instruction is built vs. when it's generated, or you'd swap uses of 66h and 67h prefixes, then suddenly <code>.code16; mov ax, word ptr [bx+si]</code> gets encoded as <code>mov eax, dword ptr [rax]</code>.</li>\n</ul>\n</blockquote>\n<p>So, I'm trying to process this, and I'm still not seeing why <code>.code16</code> is <em>more</em> an issue with asm than global_asm. It's additional state to track, certainly.</p>",
        "id": 272742088,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483762
    },
    {
        "content": "<p>It doesn't seem like a problem to leave instructions un-encoded, and wait to encode them until later.</p>",
        "id": 272742123,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483782
    },
    {
        "content": "<p>global_asm is handled different. It could basically pass right through to the output, whereas <code>asm!</code> can intervene in the xir expression stream and can have all the fun stuff.</p>",
        "id": 272742195,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645483831
    },
    {
        "content": "<p>Would it be possible to explain this in terms that don't assume I know anything about lccc's architecture, without having to explain lccc's architecture as a prerequisite? :)</p>",
        "id": 272742236,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483886
    },
    {
        "content": "<p>Deferring encoding of instructions <em>seems</em> like it addresses the issue.</p>",
        "id": 272742308,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645483935
    },
    {
        "content": "<p>If anything, doing this in two passes rather than one seems <em>easier</em>, not harder.</p>",
        "id": 272742362,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645484014
    },
    {
        "content": "<p>Well, it's caused by defferring. Basically, I have to ensure that I track the state changes like <code>.code16</code> twice - when I'm parsing the instructions and generating the abstract form where it produces 16-bit addresses, and then again when encoding and decides what prefixes to apply.</p>",
        "id": 272742971,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645484531
    },
    {
        "content": "<p>Tracking state changes in two places is a great way to have those two places disagree.</p>",
        "id": 272742986,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645484553
    },
    {
        "content": "<p>(Avoiding redundant state that can disagree is a design principle of lccc, and the many layers of the system are currently designed in that manner)</p>",
        "id": 272743041,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645484627
    },
    {
        "content": "<p>I definitely agree with only tracking it once.</p>",
        "id": 272743094,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645484649
    },
    {
        "content": "<p>So, why isn't it something that gets included <em>in</em> the abstract form?</p>",
        "id": 272743098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645484658
    },
    {
        "content": "<p>Calculating REX/VEX/EVEX/66/67 prefixes in general is a fun task in x86.</p>",
        "id": 272743179,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645484755
    },
    {
        "content": "<p>That general group is mostly something that the encoder needs to handle.</p>",
        "id": 272743245,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645484784
    },
    {
        "content": "<p>I think I understood that already. But that still doesn't tell me why you can't include \"this is in code16 mode\" as state attached to the abstract instructions.</p>",
        "id": 272743306,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645484871
    },
    {
        "content": "<p>Well really, it needs to be handled all at once.<br>\nThe encoder is the best place for that handling.</p>",
        "id": 272743316,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645484881
    },
    {
        "content": "<p>So, let me back up a step. I'm sure that there's a pile of reasoning you've already done about lccc that explains how \"The encoder is the best place for that handling.\" gives some obvious indication of what the problem is or where the impedance mismatch is. I don't have access to any of that reasoning, though, so from my perspective, that doesn't actually answer my question in any way.</p>",
        "id": 272743573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645485048
    },
    {
        "content": "<p>My response to \"I want to handle that state in one place, not two\" is \"that sounds like a good idea, so could you record code16 as state and handle it in one place, not two?\"</p>",
        "id": 272743611,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645485077
    },
    {
        "content": "<p>Well, this part of the infrastructure (the X86Instruction type, and the encoder) is actually in a different project, which is designed to be more generalized.<br>\nThe encoder needs to know mode information in the general case (some instructions are encoded differently, some can't be encoded, some do <em>fun</em> things the encoder needs to handle), and the way an out-of-line assembler (which would use the same infrastructure) or global_asm would work would be by setting the mode while producing and encoding the instructions. This works because the steps are interleaved.</p>",
        "id": 272743982,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645485406
    },
    {
        "content": "<p>(x86 is generally a mess, so generalizing stuff about it is a pain)</p>",
        "id": 272744004,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645485437
    },
    {
        "content": "<p>(Although, on the same infrastructure, one might wonder how the heck I'd deal with w65... and I'll cross that bridge when I come to it, which is either in the next couple of weeks, or next year)</p>",
        "id": 272744126,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645485562
    },
    {
        "content": "<p>TBH... It probably could. It just would make it annoying to construct the instructions in the majority of cases... Which it already is. And easily cause problems if you created an instruction in a mode it can't be encoded in, but eh.</p>",
        "id": 272744346,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645485837
    },
    {
        "content": "<p>Ok, I withdraw my objections regarding attribute control directives in <code>asm</code>.</p>",
        "id": 272744541,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645486023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272744346\">said</a>:</p>\n<blockquote>\n<p>And easily cause problems if you created an instruction in a mode it can't be encoded in, but eh.</p>\n</blockquote>\n<p>Which can arise today with existing assemblers as well, they just complain in weirder ways or give bad code. If your compiler can reliably say \"hey, I can't assemble this instruction in this mode\" rather than emitting garbage, that'll make it above average. ;)</p>",
        "id": 272745353,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645486848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272744541\">said</a>:</p>\n<blockquote>\n<p>Ok, I withdraw my objections regarding attribute control directives in <code>asm</code>.</p>\n</blockquote>\n<p>I really appreciate you taking the time to think through it and how it would work. If there was some critical issue where it created a fundamental limitation on otherwise reasonable compiler design, I'd very much want to know it; I just wasn't seeing it, and wasn't in the position to be able to.</p>",
        "id": 272745388,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645486909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272745353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272744346\">said</a>:</p>\n<blockquote>\n<p>And easily cause problems if you created an instruction in a mode it can't be encoded in, but eh.</p>\n</blockquote>\n<p>Which can arise today with existing assemblers as well, they just complain in weirder ways or give bad code. If your compiler can reliably say \"hey, I can't assemble this instruction in this mode\" rather than emitting garbage, that'll make it above average. ;)</p>\n</blockquote>\n<p>Wow...  Low bar. That could probably be implemented in maybe about 2 hours.. That being said, I do have other things to use said 2 hours on, so that's probably a \"Would be nice\" feature that I'd look into either in the next couple weeks or next year.</p>",
        "id": 272745524,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645487047
    },
    {
        "content": "<p>I mean, in general, even if you don't implement <code>.code16</code> at all, you'll compile 99.9% of Rust code; you just wouldn't be able to compile some random bits of firmware or kernels or similar.</p>",
        "id": 272745568,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645487135
    },
    {
        "content": "<p>So, in adding support for it, the amount of handling for \"you've used it wrong\" doesn't need to be <em>that</em> high.</p>",
        "id": 272745579,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645487161
    },
    {
        "content": "<p>Well, I also want to support i86-pc-elf (generally). Because that's a productive use of my time.</p>",
        "id": 272745650,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645487227
    },
    {
        "content": "<p>Unrelated to the above: I've fixed the trailing whitespace.</p>",
        "id": 272746146,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645487788
    },
    {
        "content": "<p>(And also unified the lists. I don't see anything else that's more complicated)</p>",
        "id": 272746172,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645487822
    },
    {
        "content": "<p>I've resolved the concern (which rfcbot should notice Any Day Now).</p>",
        "id": 272746203,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645487875
    },
    {
        "content": "<p>And I'll make sure we take a look at this tomorrow.</p>",
        "id": 272746243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645487890
    },
    {
        "content": "<p>Thanks again for working on this.</p>",
        "id": 272746300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645487969
    },
    {
        "content": "<p>Indeed. Thanks for helping get it in from the procedural side.<br>\nHopefully this is the last time something like this happens, and I only need to complain about how proposed rust features will be annoying to implement normally.</p>",
        "id": 272746431,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645488049
    },
    {
        "content": "<p>/me chuckles.</p>",
        "id": 272746463,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645488078
    },
    {
        "content": "<p>I mean you already have to handle all sorts of \"fun\" details like encoding disjoint between x86 and x86-64, tbh.</p>",
        "id": 272749608,
        "sender_full_name": "Jubilee",
        "timestamp": 1645491650
    },
    {
        "content": "<p>Yeah. Can't wait to support 32-bit outputs or 16-bit outputs.</p>",
        "id": 272753167,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645496253
    },
    {
        "content": "<p>Doing it uniformly is easy, though (just need to make sure to not use <code>RipRel</code> mode for loading global/label addresses <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> outside of long mode).</p>",
        "id": 272753382,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645496500
    },
    {
        "content": "<p>But yeah, yall rustc devs dodged quite a bullet by just using llvm.</p>",
        "id": 272754296,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645497697
    },
    {
        "content": "<p>BTW, what would the process be to add something to the list?<br>\nI was actually just informed of one that was missed that would be in a similar category as others listed: <code>.weak_reference</code> on Apple platforms.<br>\nObviously not a \"Oh heck, scramble everything\" problem, since it will still work, just curious, though.</p>",
        "id": 272895221,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645581661
    },
    {
        "content": "<p>File a PR I think.</p>",
        "id": 272911155,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645599315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272911155\">said</a>:</p>\n<blockquote>\n<p>File a PR I think.</p>\n</blockquote>\n<p>I assume against the reference, with an fcp?</p>",
        "id": 272969601,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645632324
    },
    {
        "content": "<p>Against the reference, yeah.</p>",
        "id": 272970265,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645632583
    },
    {
        "content": "<p>I do think this is the kind of thing for which an FCP is somewhat overkill. Really wishing we had the new rustbot process available.</p>",
        "id": 272970387,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645632636
    },
    {
        "content": "<p>The only thing I can really think is that adding to the list is irreversible, since it's stabilizing new guarantees. It also would be interesting in that it's instastable effectively - correct me if I'm wrong but T-lang doesn't currently have anything that becomes instastable.</p>",
        "id": 272970624,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645632751
    },
    {
        "content": "<p>(Lexical stuff, maybe?)</p>",
        "id": 272970727,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645632809
    },
    {
        "content": "<p>Nominally, it's not a huge deal how it's done from my end. Though I would like for there to be a way for interested parties (including myself) to know what's going on in that regard. Until then, though, I guess it's just another repo to check.</p>",
        "id": 272971969,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645633346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> It's not especially instant to add things, though; people have to notice. It seems like the FCP is more important if we add to the list of directives that aren't linted, for instance.</p>",
        "id": 272973216,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645633849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/272973216\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> It's not especially instant to add things, though; people have to notice. It seems like the FCP is more important if we add to the list of directives that aren't linted, for instance.</p>\n</blockquote>\n<p>Instant here is \"when it's added that's it, it's stable (no unstable feature, no buffer, except the nightly-stable buffer)\", not that it takes zero time to add.</p>",
        "id": 272973587,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645634022
    },
    {
        "content": "<p>That's really the main thing, I'm concerned about if the process is something else: That it's basically irreversible to add to the list.</p>",
        "id": 272974032,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645634212
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/reference/pull/1174\">https://github.com/rust-lang/reference/pull/1174</a><br>\nUh oh.</p>",
        "id": 273830506,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646237240
    },
    {
        "content": "<p>Argh.</p>",
        "id": 273839339,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646240382
    },
    {
        "content": "<p>argh</p>",
        "id": 273861799,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646248586
    }
]