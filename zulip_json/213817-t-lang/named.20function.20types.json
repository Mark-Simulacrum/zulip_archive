[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> I have a \"mostly done\" first draft of the named function type RFC:</p>\n<p><a href=\"https://rust-lang.github.io/impl-trait-initiative/RFCs/named-function-types.html\">https://rust-lang.github.io/impl-trait-initiative/RFCs/named-function-types.html</a></p>\n<p>I am somewhat pleased with this explanation of <a href=\"https://rust-lang.github.io/impl-trait-initiative/RFCs/named-function-types.html#early-vs-late-binding\">early vs late binding</a>.</p>",
        "id": 258605023,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845225
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>, relevant to impl trait</p>",
        "id": 258605034,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845232
    },
    {
        "content": "<p>also cc <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> for feedback on <a href=\"https://rust-lang.github.io/impl-trait-initiative/RFCs/named-function-types.html#top-level-functions\">this section of the shadowing discussion</a></p>",
        "id": 258605107,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845267
    },
    {
        "content": "<blockquote>\n<p>Change impl Trait in argument position so that it desugars to \"late-bound types\"</p>\n</blockquote>\n<p>Well, that's surprising. I'm imagining some <code>for&lt;T&gt; fn(T)</code>as an example where <code>T</code> would be \"late-bound\" (though, I'm not sure what this would mean semantically)</p>",
        "id": 258606058,
        "sender_full_name": "Jack Huey",
        "timestamp": 1634845703
    },
    {
        "content": "<p>I should add some text about this</p>",
        "id": 258606178,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845765
    },
    {
        "content": "<p>Note that I didn't change the definition of function <em>pointers</em></p>",
        "id": 258606186,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845771
    },
    {
        "content": "<p>I actually think there may be a nice fix for <a href=\"https://github.com/rust-lang/rust/issues/25680\">#25680</a> here</p>",
        "id": 258606225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845791
    },
    {
        "content": "<blockquote>\n<p>For every function my_function, define both a value and a type, except when there is already a type with that name.<br>\nAs a disambiguator, also export a type fn#my_function that can be used to unambiguously name the fndef type.</p>\n</blockquote>\n<p>Tbh I think just having fn#my_function would be better and less confusing</p>",
        "id": 258606285,
        "sender_full_name": "Jack Huey",
        "timestamp": 1634845804
    },
    {
        "content": "<p>Oh, I forgot to remove that</p>",
        "id": 258606301,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845812
    },
    {
        "content": "<p>I was planning on just moving towards making shadowing an error in Rust 2024</p>",
        "id": 258606323,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845822
    },
    {
        "content": "<p>I don't hate <code>fn#foo</code></p>",
        "id": 258606354,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845840
    },
    {
        "content": "<p>I don't love <code>SomeTrait::fn#foo</code></p>",
        "id": 258606367,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845847
    },
    {
        "content": "<p>ew yeah</p>",
        "id": 258606388,
        "sender_full_name": "Jack Huey",
        "timestamp": 1634845859
    },
    {
        "content": "<p>we could be inconsistent I suppose</p>",
        "id": 258606464,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634845899
    },
    {
        "content": "<p>Yeah, I mean, <code>SomeTrait::foo</code> is pretty clear what's going on; <code>foo</code> less so</p>",
        "id": 258606634,
        "sender_full_name": "Jack Huey",
        "timestamp": 1634845970
    },
    {
        "content": "<p>I guess, just <code>foo</code> isn't that weird</p>",
        "id": 258606726,
        "sender_full_name": "Jack Huey",
        "timestamp": 1634846010
    },
    {
        "content": "<p>it's worth noting that top-level fn items are the tricky ones w/r/t backwards compat</p>",
        "id": 258608100,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634846548
    },
    {
        "content": "<p>so we could just do <code>fn#foo</code> there to make our lives easier and decide in Rust 2024 if we care :)</p>",
        "id": 258608123,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634846557
    },
    {
        "content": "<p>The \"unless another type with tha tname already exists\" definitely sounded scary to me when I read it.</p>\n<p>This sounds like a great place to start with <code>fn#foo</code> and add sugar later.  (Rust 2024 just always having it make a type and an error to conflict sounds interesting, though would be hard to migrate.)</p>",
        "id": 258609771,
        "sender_full_name": "scottmcm",
        "timestamp": 1634847185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/258606225\">said</a>:</p>\n<blockquote>\n<p>I actually think there may be a nice fix for <a href=\"https://github.com/rust-lang/rust/issues/25680\">#25680</a> here</p>\n</blockquote>\n<p>no, I'm wrong (<a href=\"https://hackmd.io/I7RzhvQMTGKu_DM9yjxj0Q\">writeup</a>)</p>",
        "id": 258611328,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634847806
    },
    {
        "content": "<p>guessing you meant the infamous <a href=\"https://github.com/rust-lang/rust/issues/25860\">#25860</a></p>",
        "id": 258612320,
        "sender_full_name": "lqd",
        "timestamp": 1634848222
    },
    {
        "content": "<p>I'm excited about this direction :)</p>",
        "id": 258744556,
        "sender_full_name": "tmandry",
        "timestamp": 1634923598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/258609771\">said</a>:</p>\n<blockquote>\n<p>The \"unless another type with tha tname already exists\" definitely sounded scary to me when I read it.</p>\n<p>This sounds like a great place to start with <code>fn#foo</code> and add sugar later.  (Rust 2024 just always having it make a type and an error to conflict sounds interesting, though would be hard to migrate.)</p>\n</blockquote>\n<p>I would be fine with this for top-level functions, it seems clearer, but I agree with the above sentiments; for traits I really want to avoid having to type <code>SomeTrait::fn#foo</code></p>",
        "id": 258744892,
        "sender_full_name": "tmandry",
        "timestamp": 1634923737
    },
    {
        "content": "<p>I guess \"unless it already exists\" isn't as bad as my first thought.  Because we have the full set of items defined, so it's not some multi-stage process that can be informed by a bunch of things.</p>",
        "id": 258749051,
        "sender_full_name": "scottmcm",
        "timestamp": 1634925574
    },
    {
        "content": "<p>Why is <code>#</code> needed?</p>",
        "id": 258769058,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634934166
    },
    {
        "content": "<p>Can't use just write <code>fn foo</code>, <code>fn SomeTrait::foo</code>?</p>",
        "id": 258769084,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634934177
    },
    {
        "content": "<p>I think currently the syntax rule expects a <code>(</code> after <code>fn</code>, so this addition should be okay.</p>",
        "id": 258769135,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634934198
    },
    {
        "content": "<p>You could have a macro that expects whatever it wants after <code>fn</code>, but <code>fn#foo</code> is reserved in that regard.</p>",
        "id": 258778909,
        "sender_full_name": "cuviper",
        "timestamp": 1634939039
    },
    {
        "content": "<p>Is the identifier always raw here? e.g. if I have a <code>fn r#fn(...)</code>, would the named type be <code>fn#fn</code>?</p>",
        "id": 258779442,
        "sender_full_name": "cuviper",
        "timestamp": 1634939351
    },
    {
        "content": "<p>I like this approach in general, but there's a small thing though:  <code>dyn Trait</code> types currently must get all associated types specified, if associated functions have their types as associated types, this rule needs to be tweaked a little, i think. This will also affect the dyn safety checking.</p>",
        "id": 258802148,
        "sender_full_name": "Charles Lew",
        "timestamp": 1634962380
    },
    {
        "content": "<p>Sorry, can't check the proposal right now, but I'll certainly do it some time during the upcoming week.<br>\nThe summary looks like something from the \"over my dead body\" category.</p>",
        "id": 258823075,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1634995410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/258778909\">said</a>:</p>\n<blockquote>\n<p>You could have a macro that expects whatever it wants after <code>fn</code>, but <code>fn#foo</code> is reserved in that regard.</p>\n</blockquote>\n<p>I don't see how that is a problem? <code>fn</code>, here, could be perceived as some kind of scope-reduced <code>typeof</code>, whereby fetching the type of a given function \"item\" (even if just implemented as a namespace disambiguator)</p>\n<hr>\n<p>The proposal looks quite nice; I'm just a bit worried by the \"having an actual equally named type to be hard error\" to be an <em>extremely</em> harsh policy, even for a new edition. We'd have to see how it happens in practice, but I'd expect to be using <code>edition_2021! { … }</code> or something similar to sometimes opt out of that restriction, since I vaguely recall having needed to define functions with eponymous types</p>",
        "id": 258835777,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635012483
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/qV7g2C5B-qxYNedRnTipepn-/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/qV7g2C5B-qxYNedRnTipepn-/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/qV7g2C5B-qxYNedRnTipepn-/image.png\"></a></div><p>Does this mean that <code>fn#Foo</code> also won't work? If so, then why? And if no, I think the wording can be improved...</p>",
        "id": 258958232,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1635168357
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/impl-trait-initiative/RFCs/named-function-types.html#traits-and-trait-impls\">Traits and trait impls</a> is a little confusing. Especially the <code>baz</code> part -- it's easy to mix up it with <code>bar</code> and it seems like there is a typo in the comment:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"c1\">// The `Bar` supertrait defines an associated type `baz`, but implicitly:</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">// generate an associated type `baz.`</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><code>Bar</code> supertrait doesn't explicitly define <code>baz</code> type, so maybe it should be something like </p>\n<blockquote>\n<p>The <code>Bar</code> supertrait defines an associated <strong>fn</strong> <code>baz</code> <strong>and</strong> implicitly generate<strong>s</strong> an associated type <code>baz.</code></p>\n<p>nothing is generated for the <code>fn bar</code> here.</p>\n</blockquote>\n<p>?</p>",
        "id": 258959241,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1635168839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>, the macro issue is that someone could have two patterns, first for <code>$foo:ty</code> and second for <code>fn $foo:ident</code>. If we give new meaning to <code>fn foo</code> as a type, then we won't get to the second pattern anymore.</p>",
        "id": 258965837,
        "sender_full_name": "cuviper",
        "timestamp": 1635171726
    },
    {
        "content": "<p>We can try to rule that out with crater, but it's a risk.</p>",
        "id": 258965893,
        "sender_full_name": "cuviper",
        "timestamp": 1635171752
    },
    {
        "content": "<p>Wouldn't it be the same situation for any syntax addition?</p>",
        "id": 258968925,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635173073
    },
    {
        "content": "<p>2021 has reserved syntax, refusing to tokenize <code>any_ident#</code> at all, exactly so we can add things like this. If you want to use <code>fn#</code> in a macro now, you have to add whitespace.</p>",
        "id": 258973030,
        "sender_full_name": "cuviper",
        "timestamp": 1635174563
    },
    {
        "content": "<p>Raw identifiers lucked into a similar situation, because <code>r#</code> was previously only allowed to tokenize as the start of a raw string.</p>",
        "id": 258973316,
        "sender_full_name": "cuviper",
        "timestamp": 1635174661
    },
    {
        "content": "<p>I'm pretty sure that since <code>fn</code> is already a valid prefix of a type (<em>e.g.</em>, with <code>fn()</code>), this cannot happen with <code>$:ty</code> (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=84b4918649fe5ead098ec06f5ff48543\">Demo</a>). And perhaps even more surprisingly, the problem doesn't occur with <code>$:path</code> either (which would have been one to look for)</p>",
        "id": 258977280,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635176214
    },
    {
        "content": "<p>One thought I just had about this proposal: it seems worth considering whether it would need trickery for any future extensions to the trait system which permit overlapping trait impls or similar for traits with all methods that are uncallable (e.g., ones that can never be called due to taking <code>&amp;self</code> where Self is <code>!</code>).</p>\n<p>At a naive glance such an extension would mean that there's two separate source code definitions for what has to under the hood be the same type. I think today we don't run into trouble due to #[marker] traits needing to be literally empty, but we may not want that to hold eventually.</p>",
        "id": 258981723,
        "sender_full_name": "simulacrum",
        "timestamp": 1635178044
    },
    {
        "content": "<p>Oh interesting, I didn't realize that little bit of function pointer syntax would force it to match <code>:ty</code> only.</p>",
        "id": 258984127,
        "sender_full_name": "cuviper",
        "timestamp": 1635179097
    },
    {
        "content": "<p>One of the use cases of this proposal is making it possible to bound output lifetimes. While <code>fn</code> might work by itself, I think it looks extremely confusing to have a space in the middle of a path:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">SomeTrait</span><span class=\"o\">&gt;</span>::<span class=\"k\">fn</span> <span class=\"nf\">foo</span>::<span class=\"n\">Output</span>: <span class=\"nb\">Send</span>\n</code></pre></div>",
        "id": 259020305,
        "sender_full_name": "tmandry",
        "timestamp": 1635195806
    },
    {
        "content": "<p>Of course the goal is to not have to write this <code>fn</code> or <code>fn#</code> in normal code, hence creating an associated type of the same name as the function when we can.</p>",
        "id": 259020535,
        "sender_full_name": "tmandry",
        "timestamp": 1635195932
    },
    {
        "content": "<p>Another thing we can potentially use this for: bounding functions by <code>const</code></p>",
        "id": 259020714,
        "sender_full_name": "tmandry",
        "timestamp": 1635196021
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">takes_foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>::<span class=\"n\">foo</span>: <span class=\"nc\">const</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 259020968,
        "sender_full_name": "tmandry",
        "timestamp": 1635196138
    },
    {
        "content": "<p>We'd still want some way of stating implications (this function is const if another function is const), but this is one of the pieces of the puzzle, I think</p>",
        "id": 259021159,
        "sender_full_name": "tmandry",
        "timestamp": 1635196225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259020305\">said</a>:</p>\n<blockquote>\n<p>One of the use cases of this proposal is making it possible to bound output lifetimes. While <code>fn</code> might work by itself, I think it looks extremely confusing to have a space in the middle of a path:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">SomeTrait</span><span class=\"o\">&gt;</span>::<span class=\"k\">fn</span> <span class=\"nf\">foo</span>::<span class=\"n\">Output</span>: <span class=\"nb\">Send</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Could be <code>where (fn &lt;T as SomeTrait&gt;::foo)::Output: Send</code></p>",
        "id": 259021950,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635196672
    },
    {
        "content": "<p>Exactly! (but for using angle brackets to get <code>Output</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"k\">fn</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">SomeTrait</span><span class=\"o\">&gt;</span>::<span class=\"n\">foo</span><span class=\"o\">&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"> </span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"c1\">// or.</span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">SomeTrait</span><span class=\"o\">&gt;</span>::<span class=\"k\">fn</span>#<span class=\"n\">foo</span>::<span class=\"n\">Output</span><span class=\"w\"> </span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As I mentioned, the \"leading <code>fn </code> syntax\" would just be featuring the same syntax as that of <code>typeof</code>, but for the restricted targets, and being implemented as a namespace shenanigan.</p>\n<p>Incidentally, I'd love to see <code>fn() { foo }</code> in diagnostics become <code>fn foo</code>, with the latter being actual Rust <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259021159\">said</a>:</p>\n<blockquote>\n<p>We'd still want some way of stating implications (this function is const if another function is const), but this is one of the pieces of the puzzle, I think</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">T</span>::<span class=\"n\">foo</span>: <span class=\"o\">~</span><span class=\"k\">const</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"c1\">// or</span>\n<span class=\"w\">    </span><span class=\"n\">T</span>::<span class=\"k\">fn</span>#<span class=\"n\">foo</span>: <span class=\"o\">~</span><span class=\"k\">const</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>?</p>",
        "id": 259081252,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635246756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259081252\">said</a>:</p>\n<blockquote>\n<p>Incidentally, I'd love to see <code>fn() { foo }</code> in diagnostics become <code>fn foo</code>, with the latter being actual Rust <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n</blockquote>\n<p>One downside of this is that you will lose the type of the function in the printout. Although I have seen folks getting confused by type errors like <code>expected type \"fn(int) -&gt; int\", got type \"fn(int) -&gt; int {foo}\"</code> (where they miss or are confused by the <code>{foo}</code> and think that it should not be a type error), and <code>expected type \"fn(int) -&gt; int\", got type \"fn foo\"</code> will probably be confusing in a different way</p>",
        "id": 259085092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635249399
    },
    {
        "content": "<p>The <code>fn foo</code> syntax is interesting. I feel like the <code>fn</code> keyword might help people to learn what is going on.</p>",
        "id": 259107941,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635259788
    },
    {
        "content": "<p>I'm not sure about <code>&lt;fn T::foo&gt;::Output</code></p>",
        "id": 259107966,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635259797
    },
    {
        "content": "<p>I definitely think having a syntax we can print in errors is a big plus from this proposal.</p>",
        "id": 259108070,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635259818
    },
    {
        "content": "<p>I was not happy about the name resolution implications of the current proposal, so I see <code>fn &lt;path&gt;</code> as having an advantage there</p>",
        "id": 259108155,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635259862
    },
    {
        "content": "<p>I feel like a postfix syntax would be better :) but ...</p>",
        "id": 259108182,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635259874
    },
    {
        "content": "<p><code>foo::fn</code>... not so sure about <em>that</em></p>",
        "id": 259108192,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635259881
    },
    {
        "content": "<p>oh by \"postfix\" i thought you meant <code>foo#fn</code></p>",
        "id": 259225810,
        "sender_full_name": "kennytm",
        "timestamp": 1635334873
    },
    {
        "content": "<p>postfix <code>#fn</code> wouldn't work - it would conflict with raw identifiers and reserved keywords for functions named <code>r</code> and <code>k</code> respectively.</p>",
        "id": 259232031,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635338505
    },
    {
        "content": "<p>one alternative I haven't seen yet is to use <code>T::foo::fn</code>, <code>&lt;T as Trait&gt;::method::fn</code> and <code>bar::fn</code> as the path to the function type</p>",
        "id": 259238500,
        "sender_full_name": "oli",
        "timestamp": 1635341491
    },
    {
        "content": "<p>I like that idea, especially if you can get to the arguments and return type that way.</p>",
        "id": 259240342,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635342181
    },
    {
        "content": "<p>yeah, postfix <code>fn</code> is interesting</p>",
        "id": 259253632,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347126
    },
    {
        "content": "<p><code>foo::fn::Output</code></p>",
        "id": 259253657,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347139
    },
    {
        "content": "<p>we could even make <code>foo::return</code> as a \"shorthand sugar\" for that, I suppose</p>",
        "id": 259253681,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347147
    },
    {
        "content": "<p>one other thing....</p>",
        "id": 259253694,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347154
    },
    {
        "content": "<p>I didn't extend the RFC to talk about it yet, but I think that we will sometimes wind up with wanting to writing something like <code>&lt;foo::fn as FnOnce(T1, T2)&gt;::Output</code> -- i.e., specify types of the arguments <code>T1</code> and <code>T2</code></p>",
        "id": 259253865,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347199
    },
    {
        "content": "<p>given <code>fn</code>, we could have a sugar for that, e.g. <code>foo::fn(T1, T2)</code></p>",
        "id": 259253917,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347213
    },
    {
        "content": "<p>this is useful if there are late-bound types</p>",
        "id": 259253957,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347228
    },
    {
        "content": "<p>probably need to make a little hackmd with all the syntaxes</p>",
        "id": 259254029,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347259
    },
    {
        "content": "<p>This is only useful for \"late bound types\", right? Since early bound types will be earlier in the path</p>",
        "id": 259254183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635347300
    },
    {
        "content": "<p>it is only needed for late-bound types, at least</p>",
        "id": 259254226,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347317
    },
    {
        "content": "<p>it may be useful elsewhere</p>",
        "id": 259254238,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347323
    },
    {
        "content": "<p>depending how generous we want to get with inference, I guess</p>",
        "id": 259254286,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347342
    },
    {
        "content": "<p><a href=\"https://hackmd.io/WQUfas2jSiaeIv6EBPgtew\">named function type alternatives</a></p>",
        "id": 259254317,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635347354
    },
    {
        "content": "<p>anybody see anything missing from the above chart? <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 259258187,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635348783
    },
    {
        "content": "<p><code>Trait::fn::foo</code> to access the fn namespace.</p>",
        "id": 259259530,
        "sender_full_name": "The 8472",
        "timestamp": 1635349338
    },
    {
        "content": "<p>It's the same as the hash prefix one except that using # instead of :: doesn't seem necessary because fn already is a keyword and can't be used for path components.</p>",
        "id": 259259983,
        "sender_full_name": "The 8472",
        "timestamp": 1635349546
    },
    {
        "content": "<p>added it</p>",
        "id": 259260486,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635349773
    },
    {
        "content": "<p><code>typeof foo</code> could use turbofish to specify args, right? <code>(typeof foo::&lt;T&gt;)::Output</code></p>",
        "id": 259272184,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635354335
    },
    {
        "content": "<p>Or maybe <code>&lt;(typeof foo) as FnOnce(T1, T2)&gt;::Output</code></p>",
        "id": 259272311,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635354387
    },
    {
        "content": "<p>i think you'll write <code>&lt;typeof foo&gt;::Output</code> in the same way you'll need <code>&lt;(u8,)&gt;::stuff</code></p>\n<p>or maybe <code>typeof&lt;{foo}&gt;::Output</code></p>",
        "id": 259275223,
        "sender_full_name": "kennytm",
        "timestamp": 1635355549
    },
    {
        "content": "<p>does <code>typeof</code> address the ambiguity issue? e.g., what's the type of <code>Bar</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">foo</span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">typeof</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 259279983,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1635357507
    },
    {
        "content": "<p>the input to <code>typeof</code> is an expression, it is definitely referring to the function.</p>",
        "id": 259282490,
        "sender_full_name": "kennytm",
        "timestamp": 1635358446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259259983\">said</a>:</p>\n<blockquote>\n<p>It's the same as the hash prefix one except that using # instead of :: doesn't seem necessary because fn already is a keyword and can't be used for path components.</p>\n</blockquote>\n<p>Nice find! This is actually my favorite proposal</p>",
        "id": 259430730,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635445159
    },
    {
        "content": "<p>Having given this some thought, I think I've come to prefer \"fn path prefix\" (e.g., <code>fn::foo</code>)</p>",
        "id": 259871564,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777526
    },
    {
        "content": "<p>I like that it is syntactically distinct, which I think will help people to understand what this is</p>",
        "id": 259871598,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777544
    },
    {
        "content": "<p>(\"what is a <code>fn::X</code> type?\")</p>",
        "id": 259871605,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I'm a little concerned that that could mean something else: the function-level scope, which we might potentially provide access to.</p>",
        "id": 259871636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777570
    },
    {
        "content": "<p>I also like that it has a kind of \"intuitive\" feeling like <code>Trait::fn</code> is kind of a \"view\" on <code>Trait</code> that contains \"the fns in the trait\"</p>",
        "id": 259871639,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777572
    },
    {
        "content": "<p>Consider the possibility of disambiguating scopes when you declare a function within a function.</p>",
        "id": 259871677,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777593
    },
    {
        "content": "<p>This could be useful for other things we've thought about, such as being able to <code>where </code>&lt;T as Trait&gt;::fn::*::Output: Send`</p>",
        "id": 259871692,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777601
    },
    {
        "content": "<p>It <em>feels</em> like a parallel to <code>crate::</code> and <code>self::</code> and <code>super::</code>.</p>",
        "id": 259871732,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777604
    },
    {
        "content": "<p>That's true</p>",
        "id": 259871738,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777608
    },
    {
        "content": "<p>That's a downside :)</p>",
        "id": 259871746,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777612
    },
    {
        "content": "<p>I'm not saying we <em>shouldn't</em> use it for this, but we should consider if we never want a scope named <code>fn</code>.</p>",
        "id": 259871773,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777625
    },
    {
        "content": "<p>That's not a problem for something like <code>Trait::fn::...</code></p>",
        "id": 259871817,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777648
    },
    {
        "content": "<p>Just for a <code>fn::</code> that starts a path.</p>",
        "id": 259871829,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777658
    },
    {
        "content": "<p>I guess that <code>fn#</code> could be used in the same way</p>",
        "id": 259871837,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777665
    },
    {
        "content": "<p><code>Trait::fn#*::Output</code></p>",
        "id": 259871840,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777670
    },
    {
        "content": "<p>it's just \"line-noisy\"</p>",
        "id": 259871848,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777674
    },
    {
        "content": "<p>I don't think that's necessary. <code>Trait::fn::...::Output</code> is unambiguous.</p>",
        "id": 259871877,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777696
    },
    {
        "content": "<p>but in a way it \"groups\" better</p>",
        "id": 259871880,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> sure, but I'd like to have uniformity</p>",
        "id": 259871892,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777706
    },
    {
        "content": "<p>I don't think that using <code>Trait::fn::foo</code> for methods of a trait but something else for the types of free functions makes sense</p>",
        "id": 259871932,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777722
    },
    {
        "content": "<p>or, if we were going to do that, I'd probably make traits use <em>no</em> prefix</p>",
        "id": 259871997,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777744
    },
    {
        "content": "<p><del>e.g., <code>Trait::fn</code></del></p>\n<p>e.g., <code>Trait::some_fn</code></p>",
        "id": 259872006,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777751
    },
    {
        "content": "<p>Do you mean <code>Trait::foo</code>?</p>",
        "id": 259872032,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777766
    },
    {
        "content": "<p>yes, sorry</p>",
        "id": 259872054,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777775
    },
    {
        "content": "<p>For uniformity, I kinda like <code>Trait::foo::fn</code> and <code>foo::fn</code>.</p>",
        "id": 259872080,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777788
    },
    {
        "content": "<p>that feels strange to me, because <code>x::y</code> usually means that \"y is based on x\"</p>",
        "id": 259872122,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777810
    },
    {
        "content": "<p>\"Look at Trait, look at the foo function of Trait, look at the function type of foo\".</p>",
        "id": 259872170,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777836
    },
    {
        "content": "<p>Yeah but if there is an associated type named <code>foo</code>...</p>",
        "id": 259872246,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777850
    },
    {
        "content": "<p>I guess you can think of it like a group of two things that gets \"narrowed down\" by the <code>fn</code></p>",
        "id": 259872275,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777862
    },
    {
        "content": "<p>Also, in theory, that syntax would naturally extend into something like <code>Trait::foo::fn(Arg1, Arg2)</code>.</p>",
        "id": 259872313,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777879
    },
    {
        "content": "<p>(rather than <code>Trait::foo::fn as FnOnce(Arg1, Arg2) ...</code>)</p>",
        "id": 259872357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777900
    },
    {
        "content": "<p>Side note: I am always wondering what <a href=\"https://www.thefeedbackloop.xyz/stroustrups-rule-and-layering-over-time/\">Stroustroup's rule</a> implies. I definitely see it at work here, although I think that talking about the types of functions will (hopefully!) always be somewhat niche.</p>",
        "id": 259872403,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259872313\">said</a>:</p>\n<blockquote>\n<p>Also, in theory, that syntax would naturally extend into something like <code>Trait::foo::fn(Arg1, Arg2)</code>.</p>\n</blockquote>\n<p>yes, that is a plus.</p>",
        "id": 259872441,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635777932
    },
    {
        "content": "<p>If we just use <code>Trait::foo</code> and can do so unambiguously, we could do <code>Trait::foo: FnOnce(...)</code>. But it doesn't seem clear if we can do that unambiguously.</p>",
        "id": 259872550,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635777972
    },
    {
        "content": "<p>(In particular, I'm not sure whether Stroustroup's Rule suggests one should just \"give in\" and go for the loud syntax initially, or whether it means that the prudent designer should hold out for terse notation. My guess is that it's a mix: for things that are expected to be the \"new normal\", go for terse notation, even if it is scary. For things that will remain unusual, explicit syntax is ok.)</p>",
        "id": 259872596,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259872550\">said</a>:</p>\n<blockquote>\n<p>If we just use <code>Trait::foo</code> and can do so unambiguously, we could do <code>Trait::foo: FnOnce(...)</code>. But it doesn't seem clear if we can do that unambiguously.</p>\n</blockquote>\n<p>That is clear</p>",
        "id": 259872632,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778013
    },
    {
        "content": "<p>Oh?</p>",
        "id": 259872649,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635778023
    },
    {
        "content": "<p>However, we can't do it if there is an associated type that shadows it</p>",
        "id": 259872655,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778025
    },
    {
        "content": "<p>What is unclear is whether we could do it for free functions</p>",
        "id": 259872661,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778031
    },
    {
        "content": "<p>Ah, got it.</p>",
        "id": 259872668,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635778035
    },
    {
        "content": "<p>Regarding <code>fn::</code>, another possible use of it as a prefix: <code>|| { fn::return return_value_from_containing_function; }</code>.</p>",
        "id": 259872682,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635778046
    },
    {
        "content": "<p>If we did use it for a prefix, it seems perhaps suboptimal for it to have both a prefix and a suffix use?</p>",
        "id": 259872796,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778098
    },
    {
        "content": "<p>Not sure, but I could see people being confused, since the two uses have nothing in common.</p>",
        "id": 259872828,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778115
    },
    {
        "content": "<p>Fair.</p>",
        "id": 259873160,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635778261
    },
    {
        "content": "<p>Sigh!</p>",
        "id": 259873211,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635778298
    },
    {
        "content": "<p>if you want to refer to the type of a function in another module using prefix <code>fn</code> do you wear it like <code>module::fn::function</code> or <code>fn::module::function</code></p>",
        "id": 259892046,
        "sender_full_name": "kennytm",
        "timestamp": 1635786743
    },
    {
        "content": "<p>Would have to be the former, as you could have multiple fn types within a hierarchy.</p>",
        "id": 259908931,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635794924
    },
    {
        "content": "<p>I would be wary about overloading path syntax in this way - turbofish and similar constructs seem to be very confusing for users, and this would add more potential confusion. I would rather use some other syntax for combining fn with a name.</p>",
        "id": 259966228,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1635842558
    },
    {
        "content": "<p>E.g., (and a total strawman, really just pulling a sigil out of the air): fn#foo and Trait::fn#foo</p>",
        "id": 259966303,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1635842615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259871636\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> I'm a little concerned that that could mean something else: the function-level scope, which we might potentially provide access to.</p>\n</blockquote>\n<p>Those could also operate off variants of <code>fn</code>: I'd imagine using <code>self::fn::*</code> (or <code>fn::self::*</code>?) for those:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"bp\">self</span>::<span class=\"k\">fn</span>::<span class=\"n\">OOF</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"> </span><span class=\"c1\">// fails to compile! 👌</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">unreachable!</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// as well as:</span>\n<span class=\"w\">    </span><span class=\"k\">mod</span> <span class=\"nn\">macro_helper_module</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">super</span>::<span class=\"p\">{</span><span class=\"o\">*</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">fn</span>::<span class=\"o\">*</span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// maybe?</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// …</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Granted, that would <em>overload</em> <code>fn</code> since context would be enough to disambiguate, much like we overload <code>self</code>, when we come to think about it.</p>",
        "id": 259987027,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635855427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259966303\">said</a>:</p>\n<blockquote>\n<p>E.g., (and a total strawman, really just pulling a sigil out of the air): fn#foo and Trait::fn#foo</p>\n</blockquote>\n<p>(fwiw, these are listed as variants in the doc)</p>",
        "id": 260014000,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635867746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/259966228\">said</a>:</p>\n<blockquote>\n<p>I would rather use some other syntax for combining fn with a name.</p>\n</blockquote>\n<p>Hmm, this is making me think of <code>r#union</code> and <code>k#yeet</code> and such.</p>\n<p>I wonder if people would want <code>use fn#foo;</code> to pull in just the <code>fn</code> vs <code>use type#foo;</code> or something.</p>",
        "id": 260027673,
        "sender_full_name": "scottmcm",
        "timestamp": 1635873219
    },
    {
        "content": "<p>Isn't one of the issues that you can already have functions with the same name as associate (or free) types?</p>",
        "id": 260028163,
        "sender_full_name": "Connor Horman",
        "timestamp": 1635873434
    },
    {
        "content": "<p>yup, that's why <code>use foo::bar;</code> and <code>type bar = foo::bar;</code> do different things.</p>",
        "id": 260028709,
        "sender_full_name": "scottmcm",
        "timestamp": 1635873661
    },
    {
        "content": "<p>most commonly seen with the tuple-struct constructor</p>",
        "id": 260029091,
        "sender_full_name": "cuviper",
        "timestamp": 1635873808
    },
    {
        "content": "<p>The tables for each variant could use examples for chaining, i.e. foo::Output::bar::Output where foo and bar are both functions.<br>\nThis could reveal clunkiness of some variants.</p>",
        "id": 260029495,
        "sender_full_name": "The 8472",
        "timestamp": 1635873958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/260029495\">said</a>:</p>\n<blockquote>\n<p>The tables for each variant could use examples for chaining, i.e. foo::Output::bar::Output where foo and bar are both functions.</p>\n</blockquote>\n<p>i bet this will hit <a href=\"https://github.com/rust-lang/rust/issues/38078\">#38078</a> (ambiguous associated type).</p>",
        "id": 260034935,
        "sender_full_name": "kennytm",
        "timestamp": 1635876212
    },
    {
        "content": "<p>So, I had an epiphany when working with <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> yesterday</p>",
        "id": 260153737,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954447
    },
    {
        "content": "<p>which is that <code>fn</code> is highlighted as a keyword in hackmd presently</p>",
        "id": 260153754,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954455
    },
    {
        "content": "<p>and if you read </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span>#<span class=\"n\">foo</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 260153781,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954466
    },
    {
        "content": "<p>(also highlighted here!)</p>",
        "id": 260153788,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954470
    },
    {
        "content": "<p>it looks very good!</p>",
        "id": 260153791,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954473
    },
    {
        "content": "<p>I think I've decided I just like <code>fn#foo</code>, it solves all the problems</p>",
        "id": 260153854,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954484
    },
    {
        "content": "<p>It seems also ok to me to do <code>Trait::fn#foo</code></p>",
        "id": 260153880,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954496
    },
    {
        "content": "<p>and we can extend to <code>fn#*</code> in the future</p>",
        "id": 260153889,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635954501
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span>::<span class=\"n\">foo</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 260155013,
        "sender_full_name": "The 8472",
        "timestamp": 1635954952
    },
    {
        "content": "<p>I've read the draft (and the zulip discussion) and I disagree with all components of the proposal basically, they all are either functionally harmful, or don't fit into the existing language, or are short sighted, or go against precedents from other languages.</p>",
        "id": 260170802,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1635961523
    },
    {
        "content": "<p>I can elaborate, but I need to calm down first.<br>\nTLDR: C++ does everything right - <code>decltype</code> (<code>typeof</code>) for naming unnamed types + early bound parameters for argument-position <code>impl Trait</code>.</p>",
        "id": 260171049,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1635961632
    },
    {
        "content": "<p>Heh, tell us what you really think :)</p>",
        "id": 260173777,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635962778
    },
    {
        "content": "<p>I'd love to hear your case though!</p>",
        "id": 260173798,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1635962793
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> or others who are fans of typeof--</p>\n<p>I'd appreciate it if you would take a look at <a href=\"https://hackmd.io/@nikomatsakis/Hk0EwI-OF\">this document</a> and especially <a href=\"https://hackmd.io/@nikomatsakis/Hk0EwI-OF#Approach-2-typeof\">the discussion of typeof here</a>. I tried to do a thorough evaluation but I realize that perhaps people have had clever ideas for how to resolve some of the ergonomic pitfalls that I see. I'd appreciate any pointers or tips!</p>",
        "id": 261721545,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637104381
    },
    {
        "content": "<blockquote>\n<p>Why not offer any shorthands for the typeof syntax?</p>\n<p>For example, we might permit typeof(Widget::frob(_ as &amp;'a Widget)) or typeof(L::Log(_, _)): Send. But we weren’t sure what syntax to use, and there is the challenge is that these shorthands become part of the grammar for expressions</p>\n</blockquote>\n<p>Those are already part of expression grammar given destructuring assignment.</p>",
        "id": 261734086,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637113483
    },
    {
        "content": "<p>I personally don't like the idea of using <code>fn_name(arg_type)</code> to name the output type in alt 1, it'll make it hard to tell if something is a type or a const. The elision of <code>fn#</code> in where clause rule also feels ad hoc and inconsistent.</p>",
        "id": 261734283,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637113663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <br>\nI'll get to this thread again next week, most likely, it's in my todo list.</p>",
        "id": 261734469,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1637113885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/261734283\">said</a>:</p>\n<blockquote>\n<p>I personally don't like the idea of using <code>fn_name(arg_type)</code> to name the output type in alt 1, it'll make it hard to tell if something is a type or a const.</p>\n</blockquote>\n<p>To be fair, the types appearing in <code>fn(A, B)</code> and <code>impl Fn(A, B)</code> are also types surrounded by parens, so this is not without precedent.</p>",
        "id": 261736038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637115415
    },
    {
        "content": "<p>It's next to fn though, not a name of function.</p>",
        "id": 261739415,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637119669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> My only concern with typeof is if we want to have unnamed types that intentionally cannot be named.</p>",
        "id": 261745899,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637127684
    },
    {
        "content": "<p>For instance, if we have unnamed fields of structs/unions, without typeof those types can never appear anywhere else.</p>",
        "id": 261746039,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637127892
    },
    {
        "content": "<p>If we make an intentional decision that we don't want to have <em>unnameable</em> types, then typeof seems <em>great</em>.</p>",
        "id": 261746238,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637128201
    },
    {
        "content": "<p>You can name those types, though, in a constrained way using type_alias_impl_trait.</p>",
        "id": 261812604,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637167784
    },
    {
        "content": "<p>I'd like to offer some reasons I really dislike typeof:</p>\n<ul>\n<li>As mentioned in the hackmd, it sometimes requires materializing values, which tends to lead to something like C++'s declval (called value in the hackmd)- a weird \"function\" only usable in non-evaluated contexts. Related to this, it also tends to introduce a lot of duplication- copying expressions into this non-evaluated context and sometimes replacing bits of them with declval.<ul>\n<li>C++20 even adds new syntax to make the value materialization less weird (but not the duplication)- <code>requires</code> exprs can declare arbitrary \"parameters\" to materialize these values instead of using declval.</li>\n</ul>\n</li>\n<li>A major reason for this \"duplication into an unevaluted context\" is to extract intermediate/unnamed results from metaprogramming-style stuff built from overload resolution + template argument deduction/SFINAE + template/constexpr evaluation. This does not feel like it fits well with Rust's approach which gives more things concrete signatures and names using traits- IMO leveraging the existing Fn::Output or similar is more in line with existing idioms.</li>\n<li>In C++, decltype fits into the very linear/down-the-page flow of type information. In Rust, type information flows in more general graph shapes, such that <code>type T = impl Trait</code> fits the (or at least my) mental model much better- it binds a type variable which is \"elsewhere\" constrained in various ways by <em>actual</em> usage, rather than directly+immediately executing the compiler's metaprogramming machinery on an <em>unevaluated</em> (and thus often artificially invented) expression.</li>\n</ul>",
        "id": 261822416,
        "sender_full_name": "rpjohnst",
        "timestamp": 1637171828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/260153889\">said</a>:</p>\n<blockquote>\n<p>and we can extend to <code>fn#*</code> in the future</p>\n</blockquote>\n<p>I was flipping through the rfcs repo and saw <a href=\"https://github.com/rust-lang/rfcs/issues/3175\">https://github.com/rust-lang/rfcs/issues/3175</a>, which made me think of this thread.</p>\n<p><code>fn#</code> seems fine for functions, but I was wondering about other things -- what if this syntax were allowed for writing the names of other things too?  Like <code>Trait::fn#ASSOCIATED_CONST</code> or (if we ever get these) <code>Trait::fn#field_name</code>.  Or even without traits, it might be handy to be able to emit <code>&lt;$some_type&gt;::fn#bar</code> in a place that needs the type of the <code>bar</code> field on that type but where the macro doesn't actually have the type definition available.</p>\n<p>Which makes me wonder about instead perhaps picking something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Trait</span>::<span class=\"k\">type</span>#<span class=\"n\">foo</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262847431,
        "sender_full_name": "scottmcm",
        "timestamp": 1637977530
    },
    {
        "content": "<p>Regarding argument-position <code>impl Trait</code> (APIT) and late-bound generic parameters.<br>\n(Feel free to move to a separate thread since the APIT change was removed from the draft.)</p>\n<p>In rustc there are 522 result for the search <code>: impl \\w+</code>, from which <em>at least</em> 180 are used in public functions (34%).<br>\nThis goes against recommendation of not using APIT in public interfaces, because the users may need to pass the generic arguments explicitly.<br>\nThis is ok in rustc, because it's a controlled codebase and all crates can be changed together if necessary, but that's not my point.</p>\n<p>My point is that APIT is casually used as a simple sugar for single-use generic parameters, without any further thought.<br>\nI suggest the reality match these expectations and to not add any subtleties and surprises to this scheme.<br>\nThis approach is currently implemented and feature gated, the tracking issue is <a href=\"https://github.com/rust-lang/rust/issues/83701\">https://github.com/rust-lang/rust/issues/83701</a>, the implementation fit very naturally into the existing compiler.</p>\n<p>C++ used this generic parameter sugar approach for concepts in function parameter types (an APIT analogue) from the start, and I haven't seen any concerns or complaints about it.</p>",
        "id": 263815782,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638775754
    },
    {
        "content": "<p>I don't have anything agains experimenting with late-bound type parameters as a separate feature.<br>\nWe already have a surface syntax for them in function types <code>for&lt;'param&gt; fn(arg: &amp;'param u8)</code> and I can't see any reasons why it could not be extended to function items - <code>for&lt;'param&gt; fn(arg: &amp;'param u8) { ... }</code>, I already suggested this in <a href=\"https://github.com/rust-lang/rust/issues/42868#issuecomment-330602249\">https://github.com/rust-lang/rust/issues/42868#issuecomment-330602249</a>.</p>\n<p>Shifting the parameters from the type to the impl is an interesting idea.<br>\nC++ does a similar thing with \"generic closures\" (which would be nice to eventually have in Rust as well), except it shifts the generic even further on the <code>operator()</code> itself (aka <code>fn call(_mut,_once)</code> in Rust), because templates are checked lately there and <code>operator()</code> can have an arbitrary, possible generic, signature not dictated in advance by a trait.<br>\nThat's basically the same thing as the example in [link]:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Debug</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">arg</span>: <span class=\"nc\">T</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{};</span><span class=\"w\"> </span><span class=\"c1\">// Somehow</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"mi\">22_</span><span class=\"k\">u32</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// call once with `u32`</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"mi\">22_</span><span class=\"k\">i32</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// call again with `i32`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>What is worrying, however, is that parameters shifted to the <code>impl</code> are not the same thing as late bound lifetime parameters as they exist in the language now.<br>\nThey are still \"concrete\" early-bound parameters, just from a different item.<br>\nSo things like this won't work.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"o\">&lt;</span><span class=\"n\">Arg</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"n\">_arg</span>: <span class=\"nc\">Arg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"n\">_arg</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fnptr</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span>::<span class=\"n\">method</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Nope</span>\n<span class=\"w\">                                    </span><span class=\"c1\">// expected fn pointer `for&lt;'r&gt; fn(&amp;'r u8)`</span>\n<span class=\"w\">                                    </span><span class=\"c1\">//    found fn pointer `fn(&amp;u8)`</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fnptr</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span>::<span class=\"n\">method</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// But this is OK</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So maybe some different terminology should be used if we introduce some sugar for shifting generit parameters to impls, and maybe that sugar shouldn't use <code>for&lt;PARAMS&gt;</code> then.</p>",
        "id": 263815792,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638775768
    },
    {
        "content": "<hr>\n<p>Regarding path-like syntaxes for function types (<code>fn::something</code>).</p>\n<p>I think it's a pretty fundamental property of paths that if <code>path_prefix::segment</code> is a path, then the <code>path_prefix</code> is a path too, that means it goes through name resolution and points to some module.<br>\nIt's true for non-keyword path prefixes, and it's true for <code>crate::segment</code>, <code>self::segment</code>, etc too - single <code>crate</code> is a path pointing to the crate root module, single <code>self</code> is a path pointing to the current normal module (in type namespace).</p>\n<p>Is single <code>fn</code> a path pointing to some module in (the older versions) of this proposal? No.<br>\nI think that means it shouldn't use the path syntax either.<br>\n(This applies to other proposal suggesting paths as a syntax for other unrelated sugars.)</p>",
        "id": 263816366,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638776381
    },
    {
        "content": "<hr>\n<p>Oh, and anyone suggesting using <code>#</code> for any syntax not related to ~preprocessor has zero sense of style. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 263816947,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638776970
    },
    {
        "content": "<hr>\n<p>(I still have some comments to write about <code>typeof</code>, maybe later this week.)</p>",
        "id": 263817518,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638777506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/261822416\">said</a>:</p>\n<blockquote>\n<p>I'd like to offer some reasons I really dislike typeof:</p>\n<ul>\n<li>As mentioned in the hackmd, it sometimes requires materializing values, which tends to lead to something like C++'s declval (called value in the hackmd)- a weird \"function\" only usable in non-evaluated contexts. Related to this, it also tends to introduce a lot of duplication- copying expressions into this non-evaluated context and sometimes replacing bits of them with declval.<ul>\n<li>C++20 even adds new syntax to make the value materialization less weird (but not the duplication)- <code>requires</code> exprs can declare arbitrary \"parameters\" to materialize these values instead of using declval.</li>\n</ul>\n</li>\n<li>A major reason for this \"duplication into an unevaluted context\" is to extract intermediate/unnamed results from metaprogramming-style stuff built from overload resolution + template argument deduction/SFINAE + template/constexpr evaluation. This does not feel like it fits well with Rust's approach which gives more things concrete signatures and names using traits- IMO leveraging the existing Fn::Output or similar is more in line with existing idioms.</li>\n<li>In C++, decltype fits into the very linear/down-the-page flow of type information. In Rust, type information flows in more general graph shapes, such that <code>type T = impl Trait</code> fits the (or at least my) mental model much better- it binds a type variable which is \"elsewhere\" constrained in various ways by <em>actual</em> usage, rather than directly+immediately executing the compiler's metaprogramming machinery on an <em>unevaluated</em> (and thus often artificially invented) expression.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>As mentioned in the hackmd, it sometimes requires materializing values...</p>\n</blockquote>\n<p>This is true, but we can easily limit expressions inside <code>typeof</code> to paths resolving to functions for a start, then there will be not many values to materialize.<br>\nExtending the supported set of expressions inside of <code>typeof</code> (and giving more potential for value materialization tricks) is our choice, not necessity.</p>\n<blockquote>\n<p>A major reason for this \"duplication into an unevaluted context\" is to extract intermediate/unnamed results from metaprogramming-style stuff built from overload resolution + template argument deduction/SFINAE + template/constexpr evaluation. This does not feel like it fits well with Rust's approach which gives more things concrete signatures and names using traits- IMO leveraging the existing Fn::Output or similar is more in line with existing idioms.</p>\n</blockquote>\n<p>I don't think there's a conflict between these two approaches?<br>\n<code>Output</code> can be taken from a result of <code>typeof</code> as well.</p>\n<blockquote>\n<p>In C++, decltype fits into the very linear/down-the-page flow of type information. In Rust, type information flows in more general graph shapes, such that <code>type T = impl Trait</code> fits the (or at least my) mental model much better- it binds a type variable which is \"elsewhere\" constrained in various ways by <em>actual</em> usage, rather than directly+immediately executing the compiler's metaprogramming machinery on an <em>unevaluated</em> (and thus often artificially invented) expression.</p>\n</blockquote>\n<p>I don't see why there's a conflict with Rust type inference, and why <code>typeof</code> necessarily needs a unidirectional type inference, the body of <code>typeof</code> can be type-checked as a part of the larger context, like bodies of closures and <code>const { ... }</code> blocks.</p>",
        "id": 263839961,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638792083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/261721545\">said</a>:</p>\n<blockquote>\n<p>Hey <span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> or others who are fans of typeof--</p>\n<p>I'd appreciate it if you would take a look at <a href=\"https://hackmd.io/@nikomatsakis/Hk0EwI-OF\">this document</a> and especially <a href=\"https://hackmd.io/@nikomatsakis/Hk0EwI-OF#Approach-2-typeof\">the discussion of typeof here</a>. I tried to do a thorough evaluation but I realize that perhaps people have had clever ideas for how to resolve some of the ergonomic pitfalls that I see. I'd appreciate any pointers or tips!</p>\n</blockquote>\n<p>Maybe it's not a very clever idea, but is prettifying the use of <code>typeof</code> or analogues even necessary?  This is certainly not an operation for everyday use.<br>\nI wouldn't personally think about any sugar for it until the base feature is implemented and used for some months.</p>",
        "id": 263840315,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638792357
    },
    {
        "content": "<p>Thanks for that write-up, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span>, I'll take a look in detail later -- that said, I've personally \"moved on\" to preferring a different point in the design space (<a href=\"https://rust-lang.github.io/async-fundamentals-initiative/explainer/phase_1.html#naming-the-future-that-is-returned\">described here</a>).  I've been meaning to try and do some kind of update blog post to talk about the hows/whys (tl;dr -- the \"name the fn type\" is too hard to explain and cumbersome, this version seems simpler).</p>",
        "id": 264042820,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1638899595
    },
    {
        "content": "<p>In that regard, I still lean towards the shorthand form using <code>&lt;'_, '_, ...&gt;</code> to make it explicit there is a higher-order thing going on. With a hypothetical <code>'..</code> \"variadic ellipsis\", it would even allow something almost as concise as the suggested sugar: <code>P::request&lt;'..&gt; : Send</code></p>",
        "id": 264083388,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638916356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/named.20function.20types/near/264042820\">said</a>:</p>\n<blockquote>\n<p>a different point in the design space (<a href=\"https://rust-lang.github.io/async-fundamentals-initiative/explainer/phase_1.html#naming-the-future-that-is-returned\">described here</a>)</p>\n</blockquote>\n<p>Ah, so you are planning to make the associated type synthesized for \"RPIT in traits\" named after all.<br>\nShouldn't this affect <a href=\"https://github.com/rust-lang/rfcs/pull/3193\">https://github.com/rust-lang/rfcs/pull/3193</a> as well in that case?</p>",
        "id": 264108489,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1638935221
    },
    {
        "content": "<blockquote>\n<hr>\n<p>Regarding path-like syntaxes for function types (<code>fn::something</code>).</p>\n<p>I think it's a pretty fundamental property of paths that if <code>path_prefix::segment</code> is a path, then the <code>path_prefix</code> is a path too, that means it goes through name resolution and points to some module.<br>\nIt's true for non-keyword path prefixes, and it's true for <code>crate::segment</code>, <code>self::segment</code>, etc too - single <code>crate</code> is a path pointing to the crate root module, single <code>self</code> is a path pointing to the current normal module (in type namespace).</p>\n<p>Is single <code>fn</code> a path pointing to some module in (the older versions) of this proposal? No.<br>\nI think that means it shouldn't use the path syntax either.<br>\n(This applies to other proposal suggesting paths as a syntax for other unrelated sugars.)</p>\n</blockquote>\n<p>Could we do the converse: call the function type <code>function::fn</code>? This would nest a type inside a value, I don't know is the resolver allows for such a thing. Similarly, we could name the function's output type <code>function::Output</code>, either as a binding inside <code>function</code> or as sugar for <code>&lt;function as Fn&lt;_&gt;&gt;::Output</code>.</p>",
        "id": 264617815,
        "sender_full_name": "cjgillot",
        "timestamp": 1639308146
    }
]