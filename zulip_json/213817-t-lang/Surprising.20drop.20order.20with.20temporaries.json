[
    {
        "content": "<p>This example was recently shared on the subreddit, OP was surprised by the drop order: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=51d25e15b77bb5a1589dc92b325be80b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=51d25e15b77bb5a1589dc92b325be80b</a><br>\nThat's a bit subtle, but I <em>thought</em> that this would fix the problem:</p>\n<div class=\"codehilite\"><pre><span></span><code>let s = S {\n    a: { *cell.borrow_mut() + 1 },\n    b: { *cell.borrow_mut() + 2 },\n};\n</code></pre></div>\n<p>It doesn't, there is still a panic. What you need to do is something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>let s = S {\n    a: { let t = *cell.borrow_mut() + 1; t },\n    b: { let t = *cell.borrow_mut() + 2; t },\n};\n</code></pre></div>\n<p>I'm not concerned with the ergonomics of this, but I am concerned about how to teach this. I have some pretty considerable experience with Rust and I just read the section on drop scopes, but I can't figure out why the <code>RefMut</code> created in those braces persists past the close brace.</p>",
        "id": 274744768,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646856392
    },
    {
        "content": "<p>This is, I think, because the last expression in a block actually gets it's lifetime extended to the block itself. Or something like that. Basically there's something special here.</p>",
        "id": 274745209,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646856576
    },
    {
        "content": "<p>From <a href=\"https://doc.rust-lang.org/reference/destructors.html?highlight=drop#temporary-scopes\">https://doc.rust-lang.org/reference/destructors.html?highlight=drop#temporary-scopes</a>, isn't it \" A statement\"?</p>",
        "id": 274745321,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646856624
    },
    {
        "content": "<p>The former is one big expression with no sub-statements, while the latter has multiple sub-statements.  I assume that's part of it.</p>",
        "id": 274745438,
        "sender_full_name": "scottmcm",
        "timestamp": 1646856698
    },
    {
        "content": "<p>in the first, the smallest statement is the entire <code>let s</code>. In the second it's the <code>let t</code></p>",
        "id": 274745440,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646856699
    },
    {
        "content": "<p>So it sounds like the problem here is misunderstanding that the braces themselves have any meaning</p>",
        "id": 274747636,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646857600
    },
    {
        "content": "<p>Which is worse because the braces <em>do</em> have meaning different from parens sometimes (&lt;<a href=\"https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/#rust-has-dedicated-syntax-for-this\">https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/#rust-has-dedicated-syntax-for-this</a>&gt;), just not here.</p>",
        "id": 274747811,
        "sender_full_name": "scottmcm",
        "timestamp": 1646857684
    },
    {
        "content": "<p>This just seems nightmarish to teach, because apparently (unlike C++? Or maybe they're also wrong?) we can't talk about how the close brace is what causes destructors to run. It's the end of a...<br>\nstatement, <code>if</code>, <code>else</code>, <code>if</code> condition, match arm, <code>loop</code>, <code>for</code>, <code>while</code>, the <em>second</em> operand of a lazy boolean expression...</p>",
        "id": 274747981,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646857784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/213817-t-lang/topic/Surprising.20drop.20order.20with.20temporaries/near/274744768\">said</a>:</p>\n<blockquote>\n<p>That's a bit subtle, but I <em>thought</em> that this would fix the problem:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>let s = S {\n    a: { *cell.borrow_mut() + 1 },\n    b: { *cell.borrow_mut() + 2 },\n};\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>A thought: maybe open an issue to add a lint for this?  It would make sense to me to have a lint for \"you used braces but could just use parens because they'd do the same thing\".</p>\n<p>That doesn't solve the core issue, but might at least have helped you know that the change to braces wouldn't help.</p>",
        "id": 274749194,
        "sender_full_name": "scottmcm",
        "timestamp": 1646858396
    },
    {
        "content": "<p>In the same vein as that lint would be one for replacing the <code>{}</code> with <code>()</code> (or removing altogether):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">s</span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Note the same happens with <code>unsafe {}</code> and I'd bet <code>async</code> or <code>try</code>, although it's less likely someone would try those.</p>",
        "id": 274755359,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646861579
    },
    {
        "content": "<p>I personally would rather lean towards having scoped APIs on locks than trying to perform breaking changes on drop of temporaries: when drop order matters that much, then a scope ought to be used:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"nc\">cell</span><span class=\"p\">.</span><span class=\"n\">with_borrow_mut</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">it</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"nc\">cell</span><span class=\"p\">.</span><span class=\"n\">with_borrow_mut</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">it</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274842125,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646922653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Surprising.20drop.20order.20with.20temporaries/near/274747811\">said</a>:</p>\n<blockquote>\n<p>Which is worse because the braces <em>do</em> have meaning different from parens sometimes (&lt;<a href=\"https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/#rust-has-dedicated-syntax-for-this\">https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/#rust-has-dedicated-syntax-for-this</a>&gt;), just not here.</p>\n</blockquote>\n<p>It's not that inconsistent: <code>{ … }</code> acts like <code>identity(…)</code>, and I don't really see any \"end of statement\" for these two things:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"o\">*</span><span class=\"n\">cell</span><span class=\"p\">.</span><span class=\"n\">borrow_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">identity</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">cell</span><span class=\"p\">.</span><span class=\"n\">borrow_mut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I've personally found that a nice rule of thumb is that temporaries are dropped at <code>;</code>, or at the end of a <em>function body</em>; that the popular belief of \"at the end of any block\" is wrong.</p>\n<hr>\n<p>(now, the <code>false || &lt;expr&gt;</code> case, on the other hand, is <em>very</em> surprising (no <code>;</code>) ; I guess it was made to avoid the need for drop flags)</p>",
        "id": 274842692,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646922945
    },
    {
        "content": "<blockquote>\n<p>I personally would rather lean towards having scoped APIs on locks than trying to perform breaking changes on drop of temporaries: when drop order matters that much, then a scope ought to be used:</p>\n</blockquote>\n<p>I like those APIs (but breaking changes have AFAIK not been proposed above, just lints)</p>",
        "id": 274901434,
        "sender_full_name": "RalfJ",
        "timestamp": 1646949685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/213817-t-lang/topic/Surprising.20drop.20order.20with.20temporaries/near/274842692\">said</a>:</p>\n<blockquote>\n<p>(now, the <code>false || &lt;expr&gt;</code> case, on the other hand, is <em>very</em> surprising (no <code>;</code>) ; I guess it was made to avoid the need for drop flags)</p>\n</blockquote>\n<p>Why would it be surprising? It seems to act the same as <code>if false { &lt;expr&gt; } else { false }</code>, which has the same drop behavior. You can't lift the temporary out of the if statement without making it evaluate too early, so having the destructor being delayed past the scope seems very wrong to me.</p>",
        "id": 274908013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646953096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Surprising.20drop.20order.20with.20temporaries/near/274908013\">said</a>:</p>\n<blockquote>\n<p>You can't lift the temporary out of the if statement without making it evaluate too early</p>\n</blockquote>\n<p>There's <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=eae18f56dfc1ed5710a2c3ba53142fd1\">this</a> trick:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"nb\">String</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"n\">s</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"something else\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But it does make sense to me that a <code>let</code> inside the <code>then</code> block doesn't do that automatically.</p>",
        "id": 274910794,
        "sender_full_name": "scottmcm",
        "timestamp": 1646954884
    }
]