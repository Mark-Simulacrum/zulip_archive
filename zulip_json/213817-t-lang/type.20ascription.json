[
    {
        "content": "<p>Dear <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span>, I'd like to take people's temperature on type ascription syntax. I just re-read <a href=\"https://github.com/rust-lang/rfcs/issues/2623\">rfc#2623</a> and I was thinking that it might actually suggest a decent implementation path. So... are there outstanding concerns with <code>x: T</code> as type ascription syntax?</p>\n<p>I'm going to try a poll!</p>",
        "id": 213852443,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1603145220
    },
    {
        "content": "<p>/poll Type ascription syntax: what say you?</p>",
        "id": 213852460,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1603145229
    },
    {
        "content": "<p>I still feel mildly uncomfortable wrt to the effects type ascription has on readability etc -- in particular, it seems to require the <code>(expr): foo</code> pattern and given .await as something that has landed in the meantime, it seems like the wrong thing. IIRC, there's some parser recovery problems with it too.</p>\n<p>I have not read the RFC in detail, but I personally am unconvinced that type ascription is necessary. I sometimes want it, but often the extra <code>let</code> temporary wouldn't really hurt (and may even help).</p>",
        "id": 213853588,
        "sender_full_name": "simulacrum",
        "timestamp": 1603146000
    },
    {
        "content": "<p>I don't think type ascription is very often useful and I'd prefer to save the syntax for keyword args</p>",
        "id": 213855146,
        "sender_full_name": "boats",
        "timestamp": 1603146985
    },
    {
        "content": "<p>I feel with <code>let x: T</code> existing it's hard to pick any <em>other</em> syntax.</p>\n<p>That said, I've pondered making <code>x as T</code> be ascription in an edition change.  We're getting closer and closer to having everything it can do have more targeted library methods instead (<code>.cast()</code> on pointers, <code>transmute!</code>, <code>.into()</code>, etc).  So that would potentially open up that syntax instead.</p>",
        "id": 213862866,
        "sender_full_name": "scottmcm",
        "timestamp": 1603153125
    },
    {
        "content": "<p>At the very least, we could have a lint for \"you used <code>as</code> for something that isn't a simple ascription\", and use an edition to ramp it to warn.</p>",
        "id": 213863167,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603153344
    },
    {
        "content": "<p>clippy has this one, though it's allow-by-default right now:</p>\n<div class=\"codehilite\"><pre><span></span><code>warning: using a potentially dangerous silent `as` conversion\n --&gt; src/main.rs:3:13\n  |\n3 |     let _ = 123_i32 as u64;\n  |             ^^^^^^^^^^^^^^\n  |\n  = help: consider using a safe wrapper for this conversion\n</code></pre></div>",
        "id": 213863690,
        "sender_full_name": "scottmcm",
        "timestamp": 1603153765
    },
    {
        "content": "<p>I should go push on that <code>WrappingFrom</code> RFC...</p>",
        "id": 213863814,
        "sender_full_name": "scottmcm",
        "timestamp": 1603153885
    },
    {
        "content": "<p>I guess it's too late to suggest the solution used in lean, which is to make the parentheses in <code>(e: T)</code> a mandatory part of the syntax</p>",
        "id": 213868914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603160260
    },
    {
        "content": "<p>I use type ascription all the time in lean and miss it dearly in rust. But in particular it is definitely used to trigger coercions, in fact that's the main reason to put them in, and the RFC seems like it's going to kill non-trivial use of the type ascription operator</p>",
        "id": 213869077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603160434
    },
    {
        "content": "<p>I would be happy for <code>e as T</code> to take on the role of type ascription too. But clippy has an annoying lint for this: if you write <code>e as T</code> when you should have written <code>e: T</code> (or maybe <code>coerce e</code>? what the hell am I supposed to write!), it gives a warning saying you should write explicit temporaries, which is silly, as it makes coercion <em>more</em> verbose than just calling a function</p>",
        "id": 213869439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603160973
    },
    {
        "content": "<p>By the way a side benefit of mandatory parentheses is that it solves all the problems around associativity, given all the prefix and postfix operators in rust. It seems good to be explicit if you are type-ascribing an expression to say which part you are talking about</p>",
        "id": 213869777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603161401
    },
    {
        "content": "<p>Half the time I would want ascription, I'm at the end of an expression and having to wrap it in parens would be annoying.</p>",
        "id": 213879373,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603175607
    },
    {
        "content": "<p>why at the end of an expression? Use cases differ across languages, but I often find myself using type ascription in lean to key the type so I can call a method, i.e. <code>(e: T).method()</code></p>",
        "id": 213880070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603176335
    },
    {
        "content": "<p>in rust it's mostly when I want an explicit coercion, although occasionally it's more ergonomic than supplying type parameters (and I guess that's the use case most here are thinking about)</p>",
        "id": 213880198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603176463
    },
    {
        "content": "<p>If you are at the end of an expression, it seems like you would almost always have a place to put the type: if it is <code>let x = expr;</code> you can put the type on <code>x</code> instead of <code>expr</code> and if it's a return expression then the outer context is supplying the type. But when you are in the middle of an expression there isn't any place to put the type, especially if you are invoking a coercion because those have no syntax</p>",
        "id": 213880816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603177061
    },
    {
        "content": "<p>End of an expression, not end of a statement.</p>",
        "id": 213881321,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603177557
    },
    {
        "content": "<p>Cases where I want ascription include return-type inference within a chain, for instance.</p>",
        "id": 213881401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603177612
    },
    {
        "content": "<p>Forced parentheses have the same problem that <code>try!</code> did: it piles up on the front of the expression.</p>",
        "id": 213881450,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603177667
    },
    {
        "content": "<p>Suppose I want to write <code>A::b(...).c(...).d(...).e(...)</code>, except I need ascription in one or two places before a call.</p>",
        "id": 213881579,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603177787
    },
    {
        "content": "<p>I would have to go back to the start of the chain and add a(nother) layer of parens.</p>",
        "id": 213881633,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603177818
    },
    {
        "content": "<p>I don't see how you can do better than this with infix <code>e : T</code> or <code>e as T</code> though</p>",
        "id": 213881833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603178008
    },
    {
        "content": "<p>if it was <code>e.ascr(T)</code> then ok</p>",
        "id": 213881859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603178037
    },
    {
        "content": "<p>but that's kind of weird</p>",
        "id": 213881905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603178050
    },
    {
        "content": "<p>I think it's easier to use <code>let</code> in that situation though because it's very linear</p>",
        "id": 213881983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603178134
    },
    {
        "content": "<p>it's more annoying to use let when it turns your expression tree inside out</p>",
        "id": 213882000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603178155
    },
    {
        "content": "<p>... That gives me an idea...</p>",
        "id": 213882058,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603178186
    },
    {
        "content": "<p>/me tries something on the playground.</p>",
        "id": 213882070,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603178204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/213881859\">said</a>:</p>\n<blockquote>\n<p>if it was <code>e.ascr(T)</code> then ok</p>\n</blockquote>\n<p><code>e.as(T)</code>?</p>",
        "id": 213883294,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1603179085
    },
    {
        "content": "<p>is this the same as <code>e as T</code>, semantically?</p>",
        "id": 213883328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603179116
    },
    {
        "content": "<p>or is it only coercion</p>",
        "id": 213883374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603179128
    },
    {
        "content": "<p>I'm just suggesting a syntax without chaining problems here, not semantics.</p>",
        "id": 213883462,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1603179205
    },
    {
        "content": "<p>But there was a suggestion to turn <code>as</code> into a type ascription above.</p>",
        "id": 213883477,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1603179212
    },
    {
        "content": "<p>Couldn't get this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Ascribe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">ascribe</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Ascribe</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"foo\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">().</span><span class=\"n\">ascribe</span>::<span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dbg</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 213883480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603179215
    },
    {
        "content": "<p>Would be interesting if it were possible to have a chainable identity function that allows turbofish like that.</p>",
        "id": 213883585,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603179275
    },
    {
        "content": "<p>Yeah, I suppose it is more appropriate for the grammar to use turbofish than put the type in parens, although now it's getting a bit verbose</p>",
        "id": 213883701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603179364
    },
    {
        "content": "<p>but especially if both options are available, it seems like a decent tradeoff: either use the verbose but chainable syntax or the one that requires surrounding parens</p>",
        "id": 213883749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603179411
    },
    {
        "content": "<p>I was thinking of <code>x.as&lt;T&gt;</code> or <code>x.as::&lt;T&gt;</code></p>",
        "id": 213883798,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1603179449
    },
    {
        "content": "<p>for options that use \"as\" in the name, I think we would have to somehow unify this with <code>as</code> casting, because otherwise the disconnect would be too confusing</p>",
        "id": 213883896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603179528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> for the case of <code>into()</code>, you can use the following helper trait:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Into_</span><span class=\"w\"> </span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">into_</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span>: <span class=\"nb\">Into</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Into_</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"Hello, World!\"</span><span class=\"p\">.</span><span class=\"n\">into_</span>::<span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dbg</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>I have made my own attempt to have an <code>.as_::&lt;...&gt;()</code> helper, but since it kind of leads to a chain of inference Rust is still confused about it:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">As_</span><span class=\"w\"> </span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">as_</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"nc\">Is</span><span class=\"o\">&lt;</span><span class=\"n\">EqTo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">As_</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"s\">\"foo\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">().</span><span class=\"n\">as_</span>::<span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// still does not work</span>\n</code></pre></div>\n\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a4e160358b48c2c69bdd387d8654f2f2\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a4e160358b48c2c69bdd387d8654f2f2</a></li>\n</ul>\n<hr>\n<p>Back to the topic at hand, if inference / trait solving was made smart enough for <code>As_</code> above to work, it would already be a big win that would render type ascription kind of \"not that needed\".</p>\n<p>The one place where I would like and welcome type ascription is within patterns: that's where you can use type ascription to help make the code more readable (there is a reason IDEs already do this), and there even have been some suggestions that have built on top of it, such as enums with \"anonymous variants\" (not saying the suggestions have to necessarily be used, but it kind of shows the potential usefulness of ascription within patterns).</p>\n<p>And that is a case where \"adding its own binding\" does not lead to cleaner code.</p>",
        "id": 213897224,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1603188086
    },
    {
        "content": "<p>Addendum: another option, simpler than making <code>As_</code> work, is what I call \"copy the generic from trait position to method position\", which, with our previous example, would have been bundling the <code>into_</code> logic within the <code>Into</code> trait. The issue with that pattern at the moment, is that bounds such as <code>U : Is&lt;EqTo = T&gt;</code> lead <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=74e668546d7d220c58f157cdbb8cb025\">to type inference errors even when <code>T</code> is know</a>.<br>\nIf that last issue was solved, then library authors with generics parameters in trait position would be able to offer the chance to users to specify what that generic param is with an added generic param added to the method that needs to be <code>EqTo</code> the outer one.</p>\n<p>Not as pretty as a more general-purpose <code>.as_</code>, but may be simpler to implement, and in practice it could help a lot with most of these situations. But the lack-of-inference-leading-to-the-generic-param-<strong>needing</strong>-to-be-specified is a bummer in that regard</p>",
        "id": 213898668,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1603188999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/213862866\">said</a>:</p>\n<blockquote>\n<p>I feel with <code>let x: T</code> existing it's hard to pick any <em>other</em> syntax.</p>\n<p>That said, I've pondered making <code>x as T</code> be ascription in an edition change.  We're getting closer and closer to having everything it can do have more targeted library methods instead (<code>.cast()</code> on pointers, <code>transmute!</code>, <code>.into()</code>, etc).  So that would potentially open up that syntax instead.</p>\n</blockquote>\n<p>My opinion is that type ascription (as an expression which takes an expression and a type) doesn't carry its wait, and we should instead consider more limited locations in which a user can insert a type (similar to the ability to insert a type in let bindings and turbofishes today). I don't think we should come up with an alternative syntax for type ascription as is.</p>",
        "id": 213906880,
        "sender_full_name": "boats",
        "timestamp": 1603194737
    },
    {
        "content": "<p>Interesting thoughts. I too have some significant reservations about <code>x: T</code> syntax, and have long wanted it to be a more \"method like\" syntax (like <code>foo.as&lt;T&gt;</code>). I don't in general like \"open-ended\" types that don't have a closing delimiter (although we have that same problem with <code>as</code>). I do find I want it sometimes for calls to <code>collect</code> and other such cases. </p>\n<p>Is there a canonical list of the places where type ascription is desired? This might be another good thing to add to the lang-team design notes. =) In particular, if we were going to try and pursue more limited places for annotation, as <span class=\"user-mention\" data-user-id=\"256759\">@boats</span> suggested, it'd be useful to know what kinds of things people want to be able to annotate. The main one I know of is \"method return type\", which really seems to suggest to me that a general \"ascribe type of this expression\" is the best way to handle it. (I guess that another use case is triggering coercions to a <code>dyn</code> type?)</p>",
        "id": 213912273,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1603197664
    },
    {
        "content": "<p>Based on this thread I wonder if removing type ascription syntax for now would make sense.</p>",
        "id": 213912508,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1603197785
    },
    {
        "content": "<p>I've most wanted it in match heads, things like <code>match &amp;foo: &amp;str</code> seem clearer and more obvious to me than <code>match &amp;foo[..]</code> or <code>match &amp;*foo</code></p>",
        "id": 213914412,
        "sender_full_name": "boats",
        "timestamp": 1603198706
    },
    {
        "content": "<p>Though I'd also tbh like it even more if you could infer the deref coercion from the pattern type</p>",
        "id": 213914438,
        "sender_full_name": "boats",
        "timestamp": 1603198726
    },
    {
        "content": "<blockquote>\n<p>Suppose I want to write <code>A::b(...).c(...).d(...).e(...)</code>, except I need ascription in one or two places before a call.</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rfcs/issues/2522\">rfc#2522</a> introduced <code>A::b(...).c(...):U.d(...).e(...):X</code>, or with line breaks,</p>\n<div class=\"codehilite\"><pre><span></span><code>A::b(...)\n    .c(...): U\n    .d(...)\n    .e(...): X;\n</code></pre></div>\n\n\n<p>( but 2522 was postponed because of the 5 concerns in <a href=\"https://github.com/rust-lang/rfcs/pull/2522#issuecomment-415551732\">https://github.com/rust-lang/rfcs/pull/2522#issuecomment-415551732</a> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> )</p>",
        "id": 213935331,
        "sender_full_name": "kennytm",
        "timestamp": 1603207438
    },
    {
        "content": "<blockquote>\n<p>given <code>.await</code> as something that has landed in the meantime</p>\n<p>\"method like\" syntax (like <code>foo.as&lt;T&gt;</code>).</p>\n</blockquote>\n<p>What <em>prevents</em> <code>.as&lt;T&gt;</code>? There's an amount of precedent for not-method method-like things now with <code>.await</code> after all.</p>",
        "id": 213935748,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1603207614
    },
    {
        "content": "<p>should it be a fish for consistency with normal generic function calls <code>a.b::&lt;T&gt;().as::&lt;U&gt;()</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 213936058,
        "sender_full_name": "kennytm",
        "timestamp": 1603207758
    },
    {
        "content": "<p>I was also thinking that, but I know people keep trying to gut the fish.</p>",
        "id": 213936219,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1603207832
    },
    {
        "content": "<p>imo if the only difference between <code>a.as&lt;T&gt;</code> and <code>a as T</code> is operator precedence, it's better to fix the precedence than introducing a new syntax</p>\n<p>(also, strong oppose if <code>a.as&lt;T&gt;</code> and <code>a as T</code> are both valid and have different semantics)</p>",
        "id": 213936700,
        "sender_full_name": "kennytm",
        "timestamp": 1603208028
    },
    {
        "content": "<p>If we can make <code>as</code> do type ascription (with or without the <code>e.as&lt;T&gt;</code> notation), then I think we don't really need <code>e: T</code> type ascription. And <code>as</code> has been in rust forever so it's much easier to train people to use it for type ascription as compared to introducing a new syntax. (If <code>e.as&lt;T&gt;</code> syntax is introduced, then like <span class=\"user-mention silent\" data-user-id=\"125254\">kennytm</span> I think it <em>must</em> be a synonym for <code>e as T</code>.) But that might be tricky because if we don't actually know whether it's a type ascription or a coercion then the type inference problem becomes harder. Additionally, merging the two might cause a danger where something that was supposed to be a type ascription is in fact performing an <code>as</code> cast.</p>",
        "id": 213940506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603209714
    },
    {
        "content": "<p><code>.become&lt;T&gt;</code> :troll:</p>",
        "id": 213946353,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1603212281
    },
    {
        "content": "<p>Type casting: <code>x as T</code> or maybe <code>x.as&lt;T&gt;</code> or <code>x.as::&lt;T&gt;</code></p>\n<p>Type ascription: <code>x.type&lt;T&gt;</code> or <code>x.type::&lt;T&gt;</code></p>",
        "id": 213953245,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1603215212
    },
    {
        "content": "<p>I like <code>as</code> doing casts, and not merely type assertions. I realize that both of these can technically be described as \"type coercion\", but one is \"strong\" and the other is \"weak\". I would find it much harder to understand <em>why</em> someone wrote <code>as</code> if it was both a strong and weak coercion. I would rather <code>as</code> become more capable of casting non-primitive types than it became a type coercion in some cases.</p>",
        "id": 213958584,
        "sender_full_name": "Jubilee",
        "timestamp": 1603217463
    },
    {
        "content": "<p>That's absolutely fair.</p>",
        "id": 213967631,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603221746
    },
    {
        "content": "<p>I do use <code>as</code> casts when I really do want to forcibly cast a numeric type. And I generally want type ascription for cases where I'd like to get an error if what I'm doing would have required an <code>as</code>.</p>",
        "id": 213967697,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603221793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/213967697\">said</a>:</p>\n<blockquote>\n<p>I do use <code>as</code> casts when I really do want to forcibly cast a numeric type. And I generally want type ascription for cases where I'd like to get an error if what I'm doing would have required an <code>as</code>.</p>\n</blockquote>\n<p>My general thought here is that \"forcibly\" (lossy) cast should be a method, just like the lossless <code>From</code> is.  Because having syntax for the more-error-pront one but not for the information-preserving one seems backwards.  Hence <code>.wrapping_into()</code> (<a href=\"https://github.com/rust-lang/rfcs/pull/2484\">https://github.com/rust-lang/rfcs/pull/2484</a>) for every combination of integer types, for example.</p>",
        "id": 213984582,
        "sender_full_name": "scottmcm",
        "timestamp": 1603231016
    },
    {
        "content": "<p>One of the things noted in the portable SIMD group is that <code>as</code> makes casts very terse in math ops, which is very useful in many cases... in particular, the enum-&gt;integer casts that happen in a lot of embedded code is another place I've seen it used a lot. We were discussing it because of the tension between wanting adding an f32 to every lane in an f32x4 being explicit vs. being terse, basically \"should we impl Add&lt;f32&gt; for f32x4 or should we make that go through a type cast?\" The verbosity of method casts, and the fact that integers get to take a shortcut, was in the \"con\" pile for the type cast route.</p>",
        "id": 213999893,
        "sender_full_name": "Jubilee",
        "timestamp": 1603244671
    },
    {
        "content": "<p>Maybe it would make more sense to use <code>-&gt; T</code>. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 214097602,
        "sender_full_name": "Jubilee",
        "timestamp": 1603306556
    },
    {
        "content": "<p>Hey <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> -- I am reviewing <span class=\"user-mention\" data-user-id=\"328097\">@BN</span>'s excellent PR <a href=\"https://github.com/rust-lang/rust/issues/79730\">#79730</a>, which implements the \"type ascription coercion\" fix that has been blocking stabilization (although we recently had a conversation that suggests that people may have lukewarm feelings on ascription).</p>\n<p>In so doing, though, I had a thought. I wonder if it would make sense to just forbid type ascriptions on place expressions (i.e., lvalues). So for example this would be illegal:</p>\n<div class=\"codehilite\"><pre><span></span><code>let x = 22;\nuse(x: i32);\n</code></pre></div>\n<p>We would then say that type ascriptions <em>always</em> enable (implicit) coercions.</p>\n<p>This would sidestep the unsoundness, which was specific to a case like <code>&amp;mut (x: &amp;'a i32)</code>, where you are borrowing a place expression <em>and</em> ascribing it a type.</p>\n<p>There is also just relatively little reason to ascribe a type to a place expression, since you can always influence its type by ascribing the type on a local variable.</p>",
        "id": 219193685,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607425120
    },
    {
        "content": "<p>I will say that while I was on the fence for a time I am starting to get enthusiastic about the idea of stabilizing type ascription. I feel like the <code>: T</code> syntax is the only obvious one and the interactions around ascription come up constantly. Having a nice replacement for <code>as</code> as well as a nicer way to constrain things like <code>.collect(): T</code> would be great. My main concern though is that it is not a convenient syntax as part of method <em>chains</em> -- i.e., </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">bar</span><span class=\"p\">()</span>: <span class=\"nc\">T</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">baz</span><span class=\"p\">()</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Well, I guess that might actually parse ok, so long as we accept that <code>.</code> is not ever going to be part of type.</p>",
        "id": 219193834,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607425223
    },
    {
        "content": "<p>Could you modify that first example? Is <code>use</code> supposed to be a function call there?</p>",
        "id": 219198780,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607429080
    },
    {
        "content": "<p>/me is feeling very dumb, as in “um are function call argument expressions l-values... ? I would understand <code>x: i32 = 3;</code> or <code>&amp;x: i32</code>”</p>",
        "id": 219198945,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607429205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219198780\">said</a>:</p>\n<blockquote>\n<p>Could you modify that first example? Is <code>use</code> supposed to be a function call there?</p>\n</blockquote>\n<p>yes, sorrry</p>",
        "id": 219199396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607429585
    },
    {
        "content": "<p>I can't edit it now I think</p>",
        "id": 219199398,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607429588
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> place expressions (lvalues) are basically expressions of the form</p>\n<div class=\"codehilite\"><pre><span></span><code>PE = Local Variable\n    | PE.f\n    | *expr\n</code></pre></div>",
        "id": 219199428,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607429624
    },
    {
        "content": "<p>i.e., something that names a place in memory</p>",
        "id": 219199434,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607429630
    },
    {
        "content": "<p>or \"something that can appear on the left-hand side of an assignment\"</p>",
        "id": 219199481,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607429644
    },
    {
        "content": "<p>but I realize that, having said this, I want to think a bit more about the exact def'n as it applies here:)</p>",
        "id": 219199514,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607429670
    },
    {
        "content": "<p>For some reason I had thought it was sensitive to the context in the syntax-tree</p>",
        "id": 219199654,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607429794
    },
    {
        "content": "<p>I.e. of course <code>x</code> is an l-value. But is it still an l-value when it appears in <code>foo(x)</code>? I guess it depends on one’s grammar.</p>",
        "id": 219199682,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607429830
    },
    {
        "content": "<p>I guess also the emphasis is that its “something that <em>can</em> appear on the LHS”</p>",
        "id": 219199714,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607429865
    },
    {
        "content": "<p>(I clearly need to re-read the problem we’re trying to resolve by adding this restriction.)</p>",
        "id": 219199775,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607429893
    },
    {
        "content": "<p>I've also been confused by that <code>use</code>, <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span>, but the <code>&amp;mut (x: &amp;'a i32)</code> example hints at that <code>use</code> not representing a function call but a usage of the place (maybe <code>use_place!(x: i32)</code> would have made that clearer?)</p>\n<p>Also, to clarify these nuances, and regarding <code>&amp;mut (x: &amp;'a i32)</code> being forbidden: would <code>&amp;mut { x: &amp;'a i32 }</code> and <code>&amp;mut ({x}: &amp;'a i32)</code> be allowed? These would be performing a place-to-value conversion (?/coercion?/operation?) and then it would be similar to doing <code>&amp;mut identity::&lt;&amp;'a i32&gt;(x)</code> (modulo reborrowing _vs._ move due to type inference interactions).</p>",
        "id": 219199855,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607429968
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for not allowing ascription of place expressions.</p>",
        "id": 219200629,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607430499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219199654\">said</a>:</p>\n<blockquote>\n<p>For some reason I had thought it was sensitive to the context in the syntax-tree</p>\n</blockquote>\n<p>so-- whether something is <em>interpreted</em> as an lvalue is sensitive to its location, that is true. But the property I'm going for is what <em>could</em> be interpreted.</p>\n<p>In other words, the original type ascription proposal said that \"ascription can coerce but not in certain positions\". The reason for this was that it is inappropriate to coerce in an \"lvalue context\" (left-hand-side of an assignment, or borrow expression, but the borrow could be implicit due to autoref). I am proposing a different thing, which says \"ascription can always coerce but cannot be applied to place expressions\". This avoids the problem of lvalue contexts because those are only relevant to place expressions.</p>",
        "id": 219204725,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607433322
    },
    {
        "content": "<p>To answer <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>'s questions:</p>\n<ul>\n<li><code>&amp;mut (x: &amp;'a i32)</code> -- disallowed, because <code>x: &amp;'a i32</code> is disallowed in any context. </li>\n<li><code>&amp;mut { x: &amp;'a i32 }</code> -- as above.</li>\n<li><code>&amp;mut ({x}: &amp;'a i32)</code> -- allowed, because <code>{x}</code> is not equivalent to <code>x</code>. The former is not a place expression. <code>(x)</code> is, though.</li>\n</ul>",
        "id": 219204843,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607433405
    },
    {
        "content": "<p>In other words, <code>&amp;x</code> and <code> &amp;{x}</code> are not equivalent.</p>",
        "id": 219204864,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607433420
    },
    {
        "content": "<p>The latter is kind of equivalent to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">&amp;</span><span class=\"n\">tmp</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219204885,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607433437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> isn’t there a middle ground between the two positions you laid out above, namely: disallow ascription in l-value <em>contexts</em> rather than on all l-value expressions?</p>",
        "id": 219206367,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607434401
    },
    {
        "content": "<p>That seems like it directly addresses the problem, while not disallowing potentially useful things like <code>foo(x.y: i32)</code></p>",
        "id": 219206509,
        "sender_full_name": "pnkfelix",
        "timestamp": 1607434485
    },
    {
        "content": "<p>Hmm. Yes, that is an option too</p>",
        "id": 219206561,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607434517
    },
    {
        "content": "<p>And I guess that wouldn't be too hard to implement</p>",
        "id": 219206594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607434533
    },
    {
        "content": "<p>one challenge I see is that something like <code>(x:i32).y()</code> <em>might</em> be an lvalue context -- but actually we could enforce this rule <strong>after</strong> type-checking</p>",
        "id": 219206671,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607434563
    },
    {
        "content": "<p>when we know for sure</p>",
        "id": 219206675,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607434566
    },
    {
        "content": "<p>Hmm, I'm unsure exactly how to tell that something is an lvalue context.  The <code>&amp;(x:i32)</code> is the weirdest one that comes to mind -- I could imagine it as a place context (just annotating the type) or as an operand context (like in <code>&amp;(x+x)</code>).</p>",
        "id": 219237186,
        "sender_full_name": "scottmcm",
        "timestamp": 1607449075
    },
    {
        "content": "<p>I suppose that needing to type <code>&amp;({x}:i32)</code> isn't fun, but it might be rare enough to not care.</p>",
        "id": 219237292,
        "sender_full_name": "scottmcm",
        "timestamp": 1607449121
    },
    {
        "content": "<p>I like this plan rather a lot, because I also think \"is an lvalue\" is a good heuristic for where additional ascription is probably unwanted / unnecessary. Namely, if you're ascribing a named variable, it'd probably be better to add the ascription at the variable definition site, rather than at the usage site. However, I'm not sure how \"arbitrary\" it'd feel to users-- I don't think Rust users typically have a good mental model for what things are lvalues and what are not. This is slightly concerning to me, as it reminds me of the random-feeling rules for temporary lifetimes (though those are surprising in ways that can give runtime behavior, so I think this case is less concerning to me since it would only result in compile-time errors).</p>",
        "id": 219240908,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1607450864
    },
    {
        "content": "<p><code>nikomatsakis</code> wrote:</p>\n<blockquote>\n<p>This would sidestep the unsoundness, which was specific to a case like &amp;mut (x: &amp;'a i32), where you are borrowing a place expression and ascribing it a type.</p>\n</blockquote>\n<p>Can you explain why this is still necessary? I thought that only coercing type ascriptions inside coercion sites would have solved that problem. Also wouldn't forbidding type ascriptions on lvalues contradict this statement?</p>\n<blockquote>\n<p>I feel like the : T syntax is the only obvious one and the interactions around ascription come up constantly. Having a nice replacement for <code>as</code> ...</p>\n</blockquote>",
        "id": 219241318,
        "sender_full_name": "BN",
        "timestamp": 1607451072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328097\">BN</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219241318\">said</a>:</p>\n<blockquote>\n<p>I thought that only coercing type ascriptions inside coercion sites would have solved that problem. </p>\n</blockquote>\n<p>It will, I am proposing an alternative solution. The advantage is that it is easier to code. I am not sure if it's easier to <em>explain</em> to users though.</p>",
        "id": 219254096,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219240908\">said</a>:</p>\n<blockquote>\n<p>However, I'm not sure how \"arbitrary\" it'd feel to users</p>\n</blockquote>\n<p>Yes, this is the question</p>",
        "id": 219254123,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457479
    },
    {
        "content": "<p>One thing I was also thinking is that expressions like <code>foo(x).y</code> are technically \"lvalues\", but we could probably permit them to be coerced.</p>",
        "id": 219254190,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457501
    },
    {
        "content": "<p>So the set of expressions would probably be precisely those things that match this grammar:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">LV</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">LV</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">LV</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">LV</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219254291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457553
    },
    {
        "content": "<p>well...am I talking nonsense...that seems a bit fishy</p>",
        "id": 219254297,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457558
    },
    {
        "content": "<p>I think what I'm saying may technically be true but the reasoning is kind of sketchy</p>",
        "id": 219254304,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457566
    },
    {
        "content": "<p>in particular <code>&amp;foo(x).y</code> will create a temporary to store <code>foo(x)</code>, but it still seems weird to permit a coercion on the type of <code>&lt;tmp&gt;.y</code> that gets borrowed</p>",
        "id": 219254350,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607457591
    },
    {
        "content": "<p>Wait, I thought this was about lvalue \"sites\", not lvalue expressions. For the former, the context determines whether this is being used as an lvalue, as in <code>&amp;mut _</code> or <code>*_ = ...</code>. These are where lvalues are <em>required</em> and a temporary is used if the input is not already an lvalue. Erroring if type ascription is used here makes good sense to me. But now it sounds like you want to error on all lvalue expressions, even if they are being used as rvalues, and that sounds like it will cause a lot of false positives, for example <code>foo(x.bar: T)</code> or <code>(vec.x: u32) + (vec.y: u32)</code>, or just plain variable references as in:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">bar</span><span class=\"p\">((</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(Here I don't want to change the type of <code>x</code> and introduce unsafe on line 3, and I want to use coercion on line 2 because clippy gives me grief otherwise.)</p>",
        "id": 219298585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607490370
    },
    {
        "content": "<p>I think that the error that one gets for using type ascription at an lvalue site is also quite reasonably actionable: the error message just suggests to replace e.g. <code>&amp;mut (x: T)</code> with <code>&amp;mut {x: T}</code> and not much harm is done to the expression (and it's also reasonably explicit about borrowing a temporary, at least if one is familiar with the idiom <code>{x}</code> for moving).</p>",
        "id": 219298758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607490614
    },
    {
        "content": "<p>There seem to be 3 proposals on the table:</p>\n<ul>\n<li>Change semantics of ascription to disallow coercion in lvalue contexts</li>\n<li>Forbid ascription of \"place expressions\" altogether</li>\n<li>Forbid ascription of \"place expressions\" altogether in lvalue contexts</li>\n</ul>\n<p>(I am going to adopt the term <em>lvalue context</em> to refer to the expression <code>E</code> in assignments <code>E = ...</code>, borrows (<code>&amp;E</code>, <code>&amp;mut E</code>), and auto-ref'd method calls <code>E.foo()</code>. <em>Place expression</em> refers to an expression that references an existing place, which is also one that could appear on the left-hand side of an assignment. Note that the other lvalue contexts (besides assignment) accept arbitrary expressions, but they introduce temporaries if the expression is not a place expression.)</p>",
        "id": 219352073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607527958
    },
    {
        "content": "<p>I think the final semantics is probably the best one, honestly</p>",
        "id": 219352088,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1607527964
    },
    {
        "content": "<p>So if we wanted to use coercion to get a method call, that would be <code>{&amp;mut x: &amp;mut T}.foo()</code>?</p>",
        "id": 219352967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607528295
    },
    {
        "content": "<p>actually I'm not sure if that works now, does moving a mut reference always turn into a reborrow?</p>",
        "id": 219353323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607528427
    },
    {
        "content": "<p>hm, I could see scope for an exception specifically for the form <code>(x:T).foo()</code>, perhaps to control auto-deref? There are a few options for what to do there</p>",
        "id": 219354021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607528685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219353323\">said</a>:</p>\n<blockquote>\n<p>actually I'm not sure if that works now, does moving a mut reference always turn into a reborrow?</p>\n</blockquote>\n<p>Looks like it does? <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=13f65afe9c7a34dbef626f71919b6805\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=13f65afe9c7a34dbef626f71919b6805</a></p>\n<p>That's not what I was expecting to happen, though...</p>",
        "id": 219375009,
        "sender_full_name": "scottmcm",
        "timestamp": 1607537408
    },
    {
        "content": "<p>You have to have both a dereference and a move of either the resulting value or the reference to inhibit reborrowing, ie <code>&amp;mut *{x}</code> or <code>&amp;mut {*x}</code></p>",
        "id": 219386004,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1607542238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219352088\">said</a>:</p>\n<blockquote>\n<p>I think the final semantics is probably the best one, honestly</p>\n</blockquote>\n<p>Agreed.</p>\n<p>Then (sorry to go back at this, but to me, it's completely related to this \"place expressions\" _vs._ \"place expression in lvalue context\" distinction), <code>&amp;mut { x: &amp;'a i32 }</code> would be <em>allowed</em> (<em>i.e.</em>, there would be no distinction between <code>({ place }: ty)</code> and <code>{ place: ty }</code>), right? . Since we have a place expression <code>x: &amp;'a i32</code> which then, due to the braced block, leaves the \"lvalue context\" to become a value expression, which gets anonymous-local-promoted to become a place from which we can fetch a <code>&amp;mut</code>. As showcased by:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 219386415,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607542398
    },
    {
        "content": "<p>in your example, <code>x</code> has type <code>i32</code>, not <code>&amp;i32</code></p>",
        "id": 219388363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607543225
    },
    {
        "content": "<p>so <code>*(&amp;mut {x: &amp;i32}) += 42</code> would not be valid</p>",
        "id": 219388399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607543252
    },
    {
        "content": "<blockquote>\n<p>there would be no distinction between ({ place }: ty) and { place: ty }), right?</p>\n</blockquote>\n<p>With option 3, there would be a difference between these: <code>&amp;mut ({ place }: ty)</code> would not be allowed because the type ascription is in an lvalue context</p>",
        "id": 219388795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607543459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219354021\">said</a>:</p>\n<blockquote>\n<p>hm, I could see scope for an exception specifically for the form <code>(x:T).foo()</code>, perhaps to control auto-deref? There are a few options for what to do there</p>\n</blockquote>\n<p>Also, it's worth pointing out that adding an exception for method calls would not interfere with the generic rules of option 3 (or option 2) as it would only make some errors no longer an error, so it is safe to defer this choice to later as an \"ergonomics pass\" if the initial version is successful</p>",
        "id": 219389262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607543729
    },
    {
        "content": "<p>We call them place expression contexts in the reference, not lvalue contexts: <a href=\"https://doc.rust-lang.org/stable/reference/expressions.html#place-expressions-and-value-expressions\">https://doc.rust-lang.org/stable/reference/expressions.html#place-expressions-and-value-expressions</a></p>",
        "id": 219390756,
        "sender_full_name": "isHavvy",
        "timestamp": 1607544468
    },
    {
        "content": "<p>But yes, using a place expression in a value expression context creates a temporary.</p>",
        "id": 219390885,
        "sender_full_name": "isHavvy",
        "timestamp": 1607544543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/type.20ascription/near/219388363\">said</a>:</p>\n<blockquote>\n<p>in your example, <code>x</code> has type <code>i32</code>, not <code>&amp;i32</code></p>\n</blockquote>\n<p>I was demoing the temporaries behavior, with <code>&amp;i32</code>s it would have been a bit more annoying to write <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 219705474,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1607774682
    },
    {
        "content": "<p>I created <a class=\"stream\" data-stream-id=\"269230\" href=\"/#narrow/stream/269230-t-lang.2Ftype-ascription\">#t-lang/type-ascription</a> to work on the type ascription implementaton etc</p>",
        "id": 220681748,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1608637957
    }
]