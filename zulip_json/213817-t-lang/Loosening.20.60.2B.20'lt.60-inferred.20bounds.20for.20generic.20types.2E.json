[
    {
        "content": "<p>I have been following and discussing, for a while now, about the <code>-&gt; Box&lt;dyn Trait + 'lt&gt;</code> <em>vs.</em> <code>-&gt; Box&lt;impl Trait + 'lt&gt;</code> discrepancy, whereby the latter cannot be used to capture, say, a <code>&amp;'lt mut &amp;'long …</code> type (\"opaque type captures hidden lifetime which is not listed\" yadda yadda), whereas the former, <code>dyn</code>, is able to capture such a type, since <code>dyn</code>-erasure is allowed to erase bigger invariant lifetimes (something that existential types cannot do!).</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// Ok.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">s</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">l</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">it</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">s</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">l</span><span class=\"w\"> </span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// Error.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;'</span><span class=\"na\">s</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">l</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">it</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">s</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">l</span><span class=\"w\"> </span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Explanation: as per the RFC rules, the compiler generates:</span>\n<span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"o\">&lt;'</span><span class=\"na\">s</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;'</span><span class=\"na\">s</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">l</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">it</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">s</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">l</span><span class=\"w\"> </span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">Ret</span><span class=\"o\">&lt;'</span><span class=\"na\">s</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// which leads to:</span>\n<span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"o\">&lt;'</span><span class=\"na\">s</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">'????</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// No way to name the inner lifetime, hence the error.</span>\n</code></pre></div>\n<p>For the cases where we hit that situation, the issue can be dodged by nudging the compiler into adding a <code>&lt;'l&gt;</code> generic lifetime parameter to the existential type alias definition:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gi\">+ pub trait Dummy&lt;'lt&gt; {}</span>\n<span class=\"gi\">+ impl&lt;T : ?Sized&gt; Dummy&lt;'_&gt; for T {}</span>\n\n  fn bar&lt;'s, 'l&gt; (it: &amp;'s mut &amp;'l ())\n<span class=\"gd\">-   -&gt; Box&lt;impl Trait + 's&gt;</span>\n<span class=\"gi\">+   -&gt; Box&lt;impl Trait + 's + Dummy&lt;'l&gt;&gt;</span>\n  {\n</code></pre></div>\n<p>which fixes the issue.</p>\n<p>So the issue is not a big blocker <em>per se</em>, and yet it adds yet another discrepancy / difference between <code>dyn Trait</code> and (existential) <code>impl Trait</code>:</p>\n<ul>\n<li><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> It makes sense that <code>dyn Trait</code>s need to be <code>Box</code>ed or behind some other indirection since it is <code>?Sized</code>;</li>\n<li><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> it makes sense that the methods of a <code>dyn</code>-safe trait need to be non-generic in order to be embeddable within a virtual-method table.</li>\n<li><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> the above, in turn, leads to <code>dyn Trait</code> in argument position of a method to be the necessary tool to feature polymophism in <code>dyn</code>-safe fashion (<em>vs.</em>, say, <code>impl Trait</code> in argument position). So this makes sense as well (it's a bit annoying, but there is no nice way around it).</li>\n<li><span aria-label=\"question\" class=\"emoji emoji-2753\" role=\"img\" title=\"question\">:question:</span> It doesn't make that much sense (in the sense that it is a limitation expected to be eventually lifted, once the language details have been sorted out) that RPIT cannot be used in traits, where <code>-&gt; … dyn Trait</code> can. In that regard, it's quite nice to see all the efforts that are being put into it <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span>, combined with making the whole thing be <code>dyn Trait</code> friendly, kudos for that!  <span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span> </li>\n<li><span aria-label=\"x\" class=\"emoji emoji-274e\" role=\"img\" title=\"x\">:x:</span> It doesn't make sense, however, (in the sense that this too, eventually, ought to be fixed) that <code>dyn Trait + 'lt</code> and (existential) <code>impl Trait + 'lt</code> not behave the same. This is even aggravated by the fact it is hard to explain without delving too much into the details of invariance and these hidden existential type alias definitions.</li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>, mentioned the idea of having a <code>-&gt; impl&lt;'s, 'l&gt; Trait + 's</code> syntax, for instance, —which would indeed be way cleaner / less hacky than <code>Dummy&lt;'l&gt;</code>— but —besides that aesthetical aspect— we'd still be dealing with quite a complex signature: one that would be still tied to invariance and type alias unsugaring.</p>\n<p>My personal idea to tackle this was to make <code>impl Trait</code>, by default, capture all the lifetime parameters in scope: when returning a <code>impl Trait + 's</code>, I didn't see how it could hurt to have that existential type alias have <code>'l</code>, and any other lifetime parameter in scope for that matter, available to the definition (since it could just disregard them).</p>\n<p>That's the point where I have been for several weeks, where I was suspecting I had to be missing something (and thus asking in the gh issues or this very zulip about that), but never having a fully satisfactory answer.</p>\n<p>It turns out that a URLO thread (<a href=\"https://users.rust-lang.org/t/avoiding-heap-allocations-in-some-async-trait-methods/65644/29?u=yandros\">https://users.rust-lang.org/t/avoiding-heap-allocations-in-some-async-trait-methods/65644/29?u=yandros</a>) has managed to trigger a rehearse of all the notions involved in this situation, and with it, mentioned a seemingly tangential limitation but which I now realize is the reason why my proposal, as it stands down, cannot be fully applied.</p>\n<p>The limitation in question is that in Rust, in the same fashion that <code>struct Foo&lt;'lt&gt; …</code> yields a type which cannot be used beyond <code>'lt</code>, an existential <code>type Foo&lt;'lt&gt; = …;</code> carries the same \"curse\". And I personally find that it doesn't make that much sense for such a rule to be that adamant about existential type aliases: if we have <code>type Foo&lt;'lt&gt; = ();</code>, we do have that <code>Foo&lt;'lt&gt; : 'static</code> for any lifetime.</p>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=20cc5af67ee2469399d1f0b901626085\">Proof</a></li>\n</ul>\n<p>But if we have <code>type Foo&lt;'lt&gt; = impl 'static + Sized;</code>, we don't have <code>Foo&lt;'lt&gt; : 'static</code>!</p>\n<ul>\n<li>That is, thus, the limitation that my approach would run into: nowadays one can write <code>fn fut&lt;'s&gt; (s: &amp;'s str) -&gt; impl 'static + Future&lt;Output = ()&gt; { async {} }</code>, and with my change, this would be <code>-&gt; impl&lt;'s&gt; 'static + Future&lt;Output = ()&gt;</code>, which this limitation would thus render unusable beyond the <code>'s</code> region.</li>\n</ul>\n<p>But I'm pretty sure that this limitation is, in and of itself, a problematic one. And especially with generic_associated_types, which will definitely lead to \"overly\" generic existential type aliases where the lifetimes are disregarded for certain implementations, and this, in turn, will run into this limitation often enough for it not to be deemed long-term sustainable.</p>\n<p>So, for the remainder of this post, I'll assume that this limitation is actually a bug, and that it will thus, ultimately, be fixed.</p>\n<p>I'll thus assume we are in a situation where an <code>impl 'region_of_usability + …</code> type, no matter how it has been defined, is assumed to be fully usable within that <code>'region_of_usability</code>.</p>\n<p>In that case, if <code>impl&lt;'s&gt; Future… + 'static</code> did maintain it's <code>+ 'static</code>-ness, having introduced that <code>&lt;'s&gt;</code> parameter would thus not have been a breaking change, and thus we'd be able to apply my rule to all the <code>-&gt; impl 'lifetime + …</code> occurrences out there, which would mean that <code>-&gt; Box&lt;dyn Trait + 'lt&gt;</code> and <code>-&gt; Box&lt;impl Trait + 'lt&gt;</code> would both feature a consistent behavior: no more \"hidden lifetime\" errors (on top of nicer generic_associated_types specific impls).</p>\n<p>So all this leads to loosening the inferred lifetime bounds on generic existential type aliases —those with an explicit <code>+ 'region_of_usability</code>, at least—  being a clear improvement in the language, albeit I could imagine it being a technically / implementation-wise difficult one. But that's okay, there is no rush for this feature provided we aim to, ultimately, get it fixed.</p>\n<p>This only stands, of course, unless I have overlooked something in that regard: is there any reason a generic existential type with an explicit <code>+ 'region_of_usability</code> bound should be forced to be usable only within the intersection of its generic lifetime parameters?</p>",
        "id": 257093702,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1633972935
    }
]