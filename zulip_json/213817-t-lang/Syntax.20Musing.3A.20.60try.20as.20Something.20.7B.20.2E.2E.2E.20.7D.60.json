[
    {
        "content": "<p>I was reading and pondering past <code>try</code> &amp; <code>Try</code> conversations, and this post caught my eye particularly: <a href=\"https://github.com/rust-lang/rust/issues/70941#issuecomment-612167041\">https://github.com/rust-lang/rust/issues/70941#issuecomment-612167041</a></p>\n<p>I'd previously pondered <code>try: Whatever{}</code> and <code>try -&gt; Whatever {}</code>, but neither of them really excited me.  The former seems like <code>try{}:Whatever</code> and thus feels like <code>try{}</code> and <code>try:_{}</code> should be the same.  The latter seems like it'd imply a decision for <code>try fn foo() -&gt; Whatever</code> that I think we all want to sidestep for now.</p>\n<p>But <code>try as Whatever {}</code> is interesting to me because <code>$expr</code> and <code>$expr as _</code> already have different consequences in a way that <code>$expr: _</code> doesn't.  (I'm particularly thinking about how <code>Box::new(x)</code> sometimes ends up needing to be <code>Box::new(x) as _</code> to get the correct type inferred when it's in a context that's trying to coerce to a box-of-unsized.)</p>\n<p>We could then say that <code>?</code>-in-<code>try{}</code> <strong>does not</strong> do error conversion, but that you can opt into the conversion with <code>as</code>.  That would allow us to refactor <code>Try</code> to mean that a basic <code>try { (a?, b?) }</code> wouldn't need annotations if anywhere if <code>a</code> and <code>b</code> were both <code>Result&lt;_, SameError&gt;</code> or both <code>Option&lt;_&gt;</code>.  It wouldn't work if they were different, but that seems reasonable as then you'd need to specify the type to which they should both convert _somewhere_ anyway, and you could do that with <code>as</code> -- even just with <code>try as _ { (a?, b?) }</code> if it's clear from context, such as the return type.</p>\n<p>For a concrete example that this could be useful, I think both these try blocks wouldn't need the type annotation any more, nor an <code>as</code>: <a href=\"https://github.com/rust-lang/rust/blob/04f44fb9232dc960d213d0df4a203c387215a5ff/compiler/rustc_mir/src/borrow_check/nll.rs#L352-L364\">https://github.com/rust-lang/rust/blob/04f44fb9232dc960d213d0df4a203c387215a5ff/compiler/rustc_mir/src/borrow_check/nll.rs#L352-L364</a> .  Ditto for these three conceptual-<code>try</code>-<code>catch</code>es: <a href=\"https://github.com/rust-lang/rust/blob/04f44fb9232dc960d213d0df4a203c387215a5ff/compiler/rustc_codegen_ssa/src/back/linker.rs#L532-L576\">https://github.com/rust-lang/rust/blob/04f44fb9232dc960d213d0df4a203c387215a5ff/compiler/rustc_codegen_ssa/src/back/linker.rs#L532-L576</a></p>\n<p>(And since <code>try{}</code> blocks aren't stable, \"removing\" the conversion from <code>?</code> there can't break anyone like it would if we tried to do it everywhere.  It just tweaks the mental model of what's responsible for the conversion a bit.)</p>\n<p>Thoughts?</p>",
        "id": 209194585,
        "sender_full_name": "scottmcm",
        "timestamp": 1599337654
    },
    {
        "content": "<p>+1</p>",
        "id": 209195042,
        "sender_full_name": "Lokathor",
        "timestamp": 1599338404
    },
    {
        "content": "<p>oo Interesting</p>",
        "id": 209195340,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599338795
    },
    {
        "content": "<p>no type inference by default sounds nice</p>",
        "id": 209195352,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599338819
    },
    {
        "content": "<p>Another thought: this could help some cases with closures as well -- <code>|| { Ok(a? + b?) }</code> often doesn't work (unknown target error type), but <code>|| try { a? + b? }</code> _would_ work if the two variables already have the same error type.</p>\n<p>(So in a way this is the \"add a fallback in inference to use the identity <code>From::from</code> impl\", but done with syntax instead of trying to do it in the type system)</p>",
        "id": 209195366,
        "sender_full_name": "scottmcm",
        "timestamp": 1599338843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Syntax.20Musing.3A.20.60try.20as.20Something.20.7B.20.2E.2E.2E.20.7D.60/near/209195366\">said</a>:</p>\n<blockquote>\n<p>Another thought: this could help some cases with closures as well -- <code>|| { Ok(a? + b?) }</code> doesn't work (unknown target error type), but <code>|| try { a? + b? }</code> _would_ work if the two variables already have the same error type.</p>\n<p>(So in a way this is the \"add a fallback in inference to use the identity <code>From::from</code> impl\", but done with syntax instead of trying to do it in the type system)</p>\n</blockquote>\n<p>I would be <em>very</em> interested in this</p>",
        "id": 209195372,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599338864
    },
    {
        "content": "<p>as normally can apply coersions right?</p>",
        "id": 209195376,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599338873
    },
    {
        "content": "<p><a href=\"https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/35#note_405685772\">https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/35#note_405685772</a></p>",
        "id": 209195381,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599338878
    },
    {
        "content": "<p>this feels slightly different</p>",
        "id": 209195425,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599338896
    },
    {
        "content": "<p>Yes, <code>as</code> will do coercions as well as casts.</p>",
        "id": 209195441,
        "sender_full_name": "scottmcm",
        "timestamp": 1599338964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> I'm not sure I'm following the issue you're hitting here -- what I mention here wouldn't change that <code>From</code> is how result-errors get converted, just move around where it's happening (and where that detail is specified).  So if the trouble you're hitting is that you need multiple <code>From</code>s, this change wouldn't help you.</p>\n<p>(In the design meeting a while back we talked about possibly trying to restrict conversions in different ways, but the existing stable interconversions make any meaningful tweaks there quite difficult.)</p>",
        "id": 209195976,
        "sender_full_name": "scottmcm",
        "timestamp": 1599339870
    },
    {
        "content": "<p>the trouble I'm hitting is that I need <em>no</em> Froms</p>",
        "id": 209195983,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599339893
    },
    {
        "content": "<p>and <code>?</code> adds an intermediate type rust doesn't know how to infer</p>",
        "id": 209195994,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599339906
    },
    {
        "content": "<p>the thing about specialization is just me trying to work around that</p>",
        "id": 209196013,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599339933
    },
    {
        "content": "<p>actually I guess that would still end up with <code>YDBError</code> in the user variant of the enum ... so never mind, ignore me</p>",
        "id": 209196079,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599340005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> So, in this model, <code>try { foo()?; bar()?; ... }</code> won't work if foo and bar return different error types, but <code>try as _ { foo()?; bar()?; ... }</code> would?</p>",
        "id": 209197958,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599343987
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Exactly.  (Well, assuming there was enough context to infer the <code>_</code>.)</p>",
        "id": 209197969,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344035
    },
    {
        "content": "<p>That feels like it's kinda the reverse of what I usually want.</p>",
        "id": 209198008,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344067
    },
    {
        "content": "<p>I <em>do</em> typically need <code>?</code> to do type inference, and then I'd like <code>try</code> to attempt to know what type to convert to so I don't have the double-Into problem.</p>",
        "id": 209198032,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344126
    },
    {
        "content": "<p>The inference that causes problems isn't the one between <code>try</code> and <code>?</code>, it's the one between <code>try</code> and the return type of the current function.</p>",
        "id": 209198036,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344149
    },
    {
        "content": "<p>That's the one I'd like to opt out of if possible, but I don't know if that's reasonably possible.</p>",
        "id": 209198074,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344164
    },
    {
        "content": "<p>I almost feel like there should be a shorthand for \"<code>?</code> but don't do error conversion, just return the error as-is please\".</p>",
        "id": 209198087,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Still a thought-provoking idea, though. Still thinking about it.</p>",
        "id": 209198143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344311
    },
    {
        "content": "<p>So if I understand what you want, it's what would be <code>fn foo() -&gt; ... { try {  let x = try as _ { ... }; x? } }</code> in this model?  Because it's the <code>?</code> on the result of the <code>try</code> that's causing you issues?</p>",
        "id": 209198216,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344499
    },
    {
        "content": "<p>/me stares at that and tries to interpret.</p>",
        "id": 209198256,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344527
    },
    {
        "content": "<p>Sorry, you want the error conversion inside but not outside.</p>",
        "id": 209198260,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344544
    },
    {
        "content": "<p>Yeah, I think that <em>does</em> express what I mean.</p>",
        "id": 209198266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344579
    },
    {
        "content": "<p>Convert the error types inside the inner try, then use the same error type in the outer try as the function.</p>",
        "id": 209198271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344601
    },
    {
        "content": "<p>(I half-wish we'd just said \"no <code>?</code> unless you're in a <code>try</code>\" like we have \"no <code>.await</code> except in an <code>async</code>\", but that'd be way too much churn now.)</p>",
        "id": 209198273,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344613
    },
    {
        "content": "<p>(I also think that'd be painful in practice.)</p>",
        "id": 209198281,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344630
    },
    {
        "content": "<p>Obviously that wouldn't be a very appealing pattern in general, since it involves multiple levels of <code>try</code> to express one, but it's an accurate description of the behavior I'd like to have somehow, yes.</p>",
        "id": 209198324,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344669
    },
    {
        "content": "<p>(It'd probably require <code>try fn</code> to not be completely horrible, like <code>.await</code> would be painful without <code>async fn</code>.)</p>",
        "id": 209198325,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344670
    },
    {
        "content": "<p>It'd also require <code>try fn</code> to not do inference, which I think would be painful in common usage when there <em>isn't</em> an inner try block.</p>",
        "id": 209198333,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344713
    },
    {
        "content": "<p>Conversation topic: We could do an edition change to remove error-conversion from <code>?</code> and have the opt-in for it be to use a <code>try</code>.</p>",
        "id": 209198379,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344765
    },
    {
        "content": "<p>I was thinking about `baz()? else |error| { ... } yesterday in relation to the Try impl for Ordering</p>",
        "id": 209198382,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599344774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Syntax.20Musing.3A.20.60try.20as.20Something.20.7B.20.2E.2E.2E.20.7D.60/near/209198379\">said</a>:</p>\n<blockquote>\n<p>Conversation topic: We could do an edition change to remove error-conversion from <code>?</code> and have the opt-in for it be to use a <code>try</code>.</p>\n</blockquote>\n<p>I think the same problem applies there. If you're <em>not</em> using a try, you usually <em>do</em> want error conversion, I think.</p>",
        "id": 209198390,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344790
    },
    {
        "content": "<p><code>fn main() -&gt; anyhow::Result&lt;()&gt; { may_fail()?; may_fail_differently()?; Ok(()) }</code> is a common occurrence for me.</p>",
        "id": 209198394,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Have a github link to some code where you're doing the \"convert inside the try but not outside it\" semantic?  The <code>try</code>s I found in the compiler were all \"everything in here is <code>io::Result</code>\".</p>",
        "id": 209198407,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I don't have any code using <code>try</code>, since it isn't stable. Every time the pattern would come up, I end up working around it.</p>",
        "id": 209198454,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344903
    },
    {
        "content": "<p>/me tries to think of an example.</p>",
        "id": 209198457,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344918
    },
    {
        "content": "<p>(A conceptual try where the code is actually combinators or matches is fine -- I wasn't expecting a literal <code>try</code> in your code, but it's hard to search for conceptual try :P)</p>",
        "id": 209198467,
        "sender_full_name": "scottmcm",
        "timestamp": 1599344949
    },
    {
        "content": "<p>(Exactly; that's what's making it a challenge, because I don't have a mental index for \"places I wished I had try\".)</p>",
        "id": 209198480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599344994
    },
    {
        "content": "<p>Roughly speaking, one common pattern tends to be \"try doing some things that might fail; if they fail, on the way out I'd like to do XYZ cleanup akin to a <code>finally</code> block and then return the error, but I don't want to go write a bespoke RAII type\".</p>",
        "id": 209198609,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345196
    },
    {
        "content": "<p>I wanted try not to long ago so I could instrument all errors produced by a scope in a test after a cmd runner had been setup with context from that runner should an error happen</p>",
        "id": 209198660,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345320
    },
    {
        "content": "<p>but try doesn't really solve that problem for me completely because I can't apply that same context to panics produced inside that scope</p>",
        "id": 209198663,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345352
    },
    {
        "content": "<p>Oooh, right, that's another good one. <code>try { ... }.with_context(|| format!(...))?</code>.</p>",
        "id": 209198664,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345353
    },
    {
        "content": "<p>so I've been trying to think of some sort of thread local thing that is accessed by a custom panic hook to grab in scope context</p>",
        "id": 209198706,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345380
    },
    {
        "content": "<p>To avoid putting the <code>with_context</code> on all the <code>?</code>s individually, Josh?</p>",
        "id": 209198707,
        "sender_full_name": "scottmcm",
        "timestamp": 1599345393
    },
    {
        "content": "<p>Yes, exactly.</p>",
        "id": 209198709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345399
    },
    {
        "content": "<p>Hmm, that one's probably particularly awkward because method calls block inference today</p>",
        "id": 209198762,
        "sender_full_name": "scottmcm",
        "timestamp": 1599345487
    },
    {
        "content": "<p>Yeah, it'd be lovely if I didn't have to write <code>anyhow::Result&lt;...&gt;</code> there more than once.</p>",
        "id": 209198770,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345555
    },
    {
        "content": "<p>(I already have to write it in the function's return type.)</p>",
        "id": 209198771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345563
    },
    {
        "content": "<p>this function</p>",
        "id": 209198814,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345621
    },
    {
        "content": "<p><a href=\"https://github.com/ZcashFoundation/zebra/blob/main/zebra-test/src/command.rs#L270\">https://github.com/ZcashFoundation/zebra/blob/main/zebra-test/src/command.rs#L270</a></p>",
        "id": 209198815,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345623
    },
    {
        "content": "<p>used here <a href=\"https://github.com/ZcashFoundation/zebra/blob/main/zebra-test/src/command.rs#L209\">https://github.com/ZcashFoundation/zebra/blob/main/zebra-test/src/command.rs#L209</a></p>",
        "id": 209198818,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby</span> In the latter file, those function names and comments are confusing me, and I feel like I must be reading them wrong.</p>",
        "id": 209198824,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345713
    },
    {
        "content": "<p>and here <a href=\"https://github.com/ZcashFoundation/zebra/blob/main/zebrad/tests/acceptance.rs#L79\">https://github.com/ZcashFoundation/zebra/blob/main/zebrad/tests/acceptance.rs#L79</a></p>",
        "id": 209198863,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345741
    },
    {
        "content": "<p><code>assert_was_killed</code> returns an error if <code>self.was_killed()</code>, and Ok otherwise, but the comment seems to say the reverse.</p>",
        "id": 209198864,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345742
    },
    {
        "content": "<p>And vice versa for <code>assert_was_not_killed()</code>.</p>",
        "id": 209198865,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345753
    },
    {
        "content": "<p>that might be backwards</p>",
        "id": 209198866,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345758
    },
    {
        "content": "<p>I think our was_killed might also be backwards</p>",
        "id": 209198872,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345805
    },
    {
        "content": "<p>so it's cancelling eachother out</p>",
        "id": 209198876,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345816
    },
    {
        "content": "<p>lol</p>",
        "id": 209198877,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345816
    },
    {
        "content": "<p>Either one of those two explanations would make sense, thank you. :)</p>",
        "id": 209198878,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345819
    },
    {
        "content": "<p>don't read the logic, just the error handling!</p>",
        "id": 209198879,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345826
    },
    {
        "content": "<p>ll</p>",
        "id": 209198880,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345827
    },
    {
        "content": "<p>lol*</p>",
        "id": 209198881,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1599345831
    },
    {
        "content": "<p>AFAICT unless <code>with_context</code> becomes a trait call, that just can't work today -- if inference is supposed to be producing the <code>impl Try</code> type out of what's happening inside it, the compiler will stop and give up when it sees the method call.</p>",
        "id": 209198921,
        "sender_full_name": "scottmcm",
        "timestamp": 1599345867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> It's a trait method on a sealed trait that's implemented only for <code>Result&lt;T, anyhow::Error&gt;</code>.</p>",
        "id": 209198934,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599345950
    },
    {
        "content": "<p>Well, we're at the limit of my understanding of how inference works then -- I don't know if it needs to be on <code>Try</code> for it to be understood here.</p>",
        "id": 209198983,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346035
    },
    {
        "content": "<p>I could live with that case not working.</p>",
        "id": 209198987,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346061
    },
    {
        "content": "<p>I think I'd be more interested in having this work:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">cleanup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209199024,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346099
    },
    {
        "content": "<p>If the compiler does realize it's that, though, then <code>try as _ { }.with_context()?</code> would pick up the anyhow-ness from the <code>with_context</code>, though -- which would meet the \"don't want to type it twice\" goal.  (If perhaps be non-ideal in requiring the <code>as _</code> typing.)</p>",
        "id": 209199036,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346147
    },
    {
        "content": "<p>I think that's a rough approximation of around half the cases I want <code>try</code>.</p>",
        "id": 209199037,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346151
    },
    {
        "content": "<p>So cleanup that runs so long as it doesn't <code>panic</code>?</p>",
        "id": 209199042,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346195
    },
    {
        "content": "<p>Generally local cleanup, not \"before the program ends\" cleanup, yes.</p>",
        "id": 209199086,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346246
    },
    {
        "content": "<p>I'm just poking at the difference between it and</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">scopeguard</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">cleanup</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209199132,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346325
    },
    {
        "content": "<p>(borrow difference, perhaps?)</p>",
        "id": 209199134,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346349
    },
    {
        "content": "<p>The difference is that I haven't seen a generic implementation of <code>scopeguard!</code> before? ;)</p>",
        "id": 209199135,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346352
    },
    {
        "content": "<p>Also, sometimes I don't want to call the cleanup unless the block failed; if it succeeded I want to do something different.</p>",
        "id": 209199144,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346429
    },
    {
        "content": "<p>I've never used one, just sorta assumed it <a href=\"https://lib.rs/crates/scopeguard\">exists</a> :P</p>",
        "id": 209199177,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346443
    },
    {
        "content": "<p>Interesting.</p>",
        "id": 209199190,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346517
    },
    {
        "content": "<p>That might well work for some cases I want.</p>",
        "id": 209199192,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346545
    },
    {
        "content": "<p>Wouldn't help with the \"only on <code>Err</code> with a specific error, not on <code>Ok</code> or other <code>Err</code>\" case, but it'd help in other cases.</p>",
        "id": 209199231,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346570
    },
    {
        "content": "<p>But I guess the meta-question is the best way to enable/disable conversion in <code>?</code></p>",
        "id": 209199232,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346571
    },
    {
        "content": "<p>True. And whether we can do that in a backwards-compatible way.</p>",
        "id": 209199237,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346600
    },
    {
        "content": "<p>Hypothetical (horrible syntax, just a straw idea): <code>?</code> does conversions, <code>?=</code> doesn't.</p>",
        "id": 209199251,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346650
    },
    {
        "content": "<p>I think I ended up where I did with an implicit assumption that <code>try</code> seems like the only place to put it.</p>",
        "id": 209199252,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346652
    },
    {
        "content": "<p>Yeah, I just couldn't think of anything non-horrible, since so much of the fun of <code>?</code> is that it's short-and-sweet</p>",
        "id": 209199290,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346695
    },
    {
        "content": "<p>Yup.</p>",
        "id": 209199293,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346723
    },
    {
        "content": "<p>Another possibility would be to do some kind of \"smart inference\", where the compiler has enough information to know that something has been through two <code>?</code> conversions, so it should further constrain the \"middle\" type to be either the initial or final type.</p>",
        "id": 209199308,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599346783
    },
    {
        "content": "<p>I guess method-like opt-in/out would be possible -- <code>.bikeshed()?</code></p>",
        "id": 209199351,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346805
    },
    {
        "content": "<p>That might reduce to \"there's another Result-like type that doesn't error-convert\"</p>",
        "id": 209199364,
        "sender_full_name": "scottmcm",
        "timestamp": 1599346891
    },
    {
        "content": "<p>Huh.</p>",
        "id": 209199460,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347064
    },
    {
        "content": "<p>That seems feasible.</p>",
        "id": 209199461,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347070
    },
    {
        "content": "<p>Also, if only we had GATs and could get <code>Result</code> back without needing to use \"there's only on implementation of the trait for that type\" or \"we infer it from the context\"...</p>",
        "id": 209199463,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347078
    },
    {
        "content": "<p>Without exposing it outside of <code>std</code>, would specialization allow us to have a special <code>VerbatimWrapped</code> type that wraps a result such that <code>?</code> can only return that wrapped type?</p>",
        "id": 209199479,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347145
    },
    {
        "content": "<p>(Of course, at that point <code>Try</code> is even more just monads.)</p>",
        "id": 209199480,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347145
    },
    {
        "content": "<p><code>.verbatim()?</code> where <code>fn verbatim&lt;T&gt;(t: T) -&gt; VerbatimWrapped&lt;T&gt;</code> and <code>VerbatimWrapped&lt;T&gt;</code> always becomes <code>T</code> when passed through <code>?</code>.</p>",
        "id": 209199523,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347208
    },
    {
        "content": "<p>Hmm, this is going to take some more context...</p>",
        "id": 209199532,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347241
    },
    {
        "content": "<p>I was extending your method-like opt-out idea.</p>",
        "id": 209199535,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347253
    },
    {
        "content": "<p>(from me, sorry)</p>",
        "id": 209199536,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347260
    },
    {
        "content": "<p>Ah, got it.</p>",
        "id": 209199539,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347268
    },
    {
        "content": "<p>I'm been thinking of changing <code>Try</code> from something that splits <code>Result&lt;T, E&gt;</code> into <code>T</code> or <code>Result&lt;!, E&gt;</code> instead of <code>T</code> or <code>E</code>.</p>",
        "id": 209199580,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347293
    },
    {
        "content": "<p>That's fascinating. Do tell.</p>",
        "id": 209199582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347319
    },
    {
        "content": "<p>Because that allow us to keep the \"resultness\" of the error</p>",
        "id": 209199589,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347347
    },
    {
        "content": "<p><em>Ah</em>.</p>",
        "id": 209199591,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347355
    },
    {
        "content": "<p>So, then, <code>Try</code> on <code>Option&lt;T&gt;</code> would split it into <code>T</code> or <code>Option&lt;!&gt;</code>?</p>",
        "id": 209199598,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347386
    },
    {
        "content": "<p>Yup.</p>",
        "id": 209199601,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347396
    },
    {
        "content": "<p>And using <code>!</code> for this is convenient in that error conversion wouldn't need to handle the <code>Ok</code> part</p>",
        "id": 209199644,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347415
    },
    {
        "content": "<p>Without forcing people to make a bunch of newtypes.</p>",
        "id": 209199649,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347424
    },
    {
        "content": "<p><code>Option&lt;!&gt;</code> is a fun way to say \"None\". :)</p>",
        "id": 209199651,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347427
    },
    {
        "content": "<p>It's effectively a type-level value.</p>",
        "id": 209199655,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347437
    },
    {
        "content": "<p>(<code>Infallible</code> would be fine too -- it's not blocked on literally <code>!</code>)</p>",
        "id": 209199656,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347442
    },
    {
        "content": "<p>(Of course.)</p>",
        "id": 209199659,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347447
    },
    {
        "content": "<p>So, this would keep the \"shape\" of the result.</p>",
        "id": 209199667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347471
    },
    {
        "content": "<p>But this would mean that producing the full <code>impl Try</code> type again in <code>?</code> would know of the \"result-ness\"</p>",
        "id": 209199672,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347483
    },
    {
        "content": "<p>Yup.</p>",
        "id": 209199673,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347485
    },
    {
        "content": "<p>So we could use that to encourage it back to just being a Result again, rather that something more broad.</p>",
        "id": 209199676,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347511
    },
    {
        "content": "<p>And then, the automatic conversion just has to take the \"shape\" <code>Result&lt;!, E&gt;</code>, convert the <code>E</code>, and let the <code>!</code> become whatever the return type is because that path can't be taken.</p>",
        "id": 209199677,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347521
    },
    {
        "content": "<p>Which might not work perfectly, given that we have to support currently-stable interconversions, but if we did have a <code>.verbatim()?</code> that could turn it into a type internally that doesn't do those extra conversions</p>",
        "id": 209199722,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347564
    },
    {
        "content": "<p>So we could give the implementer of <code>Try</code> control over how much inference can happen?</p>",
        "id": 209199729,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347603
    },
    {
        "content": "<p>/me is fascinated.</p>",
        "id": 209199734,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347625
    },
    {
        "content": "<p>Yup, and the <code>!</code> avoids the unfortunate phantom(-ish) type parameters on the impls that were necessary in one of the other designs, where you ended up with <code>impl&lt;T, U, E, F&gt;</code> because you had to handle the oks changing too.</p>",
        "id": 209199737,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347639
    },
    {
        "content": "<p>In fact, you almost don't need some of the type parameters on <code>Try</code>, you only need them on the specific function.</p>",
        "id": 209199779,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347667
    },
    {
        "content": "<p>Splitting up the trait may also allow things like <code>Result&lt;T, !&gt;?</code> in a <code>-&gt; ()</code> method, while not allowing <code>()??????????</code>.</p>",
        "id": 209199797,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347717
    },
    {
        "content": "<p>I just don't know if this all will end up needing GATs or not</p>",
        "id": 209199846,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347801
    },
    {
        "content": "<p>I would <em>love</em> to see this working.</p>",
        "id": 209199848,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347804
    },
    {
        "content": "<p>(If you hadn't guessed, this playing with <code>Result&lt;!, E&gt;</code> is also the source of my other topic here about <code>feature(exhaustive_patterns)</code>.)</p>",
        "id": 209199862,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347880
    },
    {
        "content": "<p>The one where you can <code>match that_type { Err(e) =&gt; ... }</code> without an <code>Ok</code> branch?</p>",
        "id": 209199908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599347930
    },
    {
        "content": "<p>Yup.</p>",
        "id": 209199911,
        "sender_full_name": "scottmcm",
        "timestamp": 1599347944
    },
    {
        "content": "<p>Not a blocker, though -- the code being a bit less nice is ok (<code>Ok(v) =&gt; match v {}</code> works on stable with <code>Infallible</code>) since the most important part to me is the model in the type being right.</p>",
        "id": 209199958,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348020
    },
    {
        "content": "<p>So, issue 1 will be making this work without breaking existing code (possibly involving an edition boundary), and issue 2 will be making the <code>Try</code> trait work without new compiler features?</p>",
        "id": 209199974,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348117
    },
    {
        "content": "<p>I think (1) shouldn't actually too bad.</p>\n<p>As a sketch, maybe you have <code>impl&lt;T, E, F: From&lt;E&gt;&gt; FromErrorCarrier&lt;Result&lt;!, E&gt;&gt; for Result&lt;T, F&gt; { ... code that calls From::from ... }</code></p>",
        "id": 209200035,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348235
    },
    {
        "content": "<p>which would also allow <code>impl FromErrorCarrier&lt;Result&lt;!, !&gt;&gt; for ()</code> as mentioned earlier.</p>",
        "id": 209200080,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348279
    },
    {
        "content": "<p>The hard part is whether inference will flow in the correct direction and trying not to make it fragile (like <code>AsRef</code>) in the face of people adding new interconversions to their own types.</p>",
        "id": 209200133,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348371
    },
    {
        "content": "<p>Right. Because <code>Try</code> and the desugar of <code>?</code> isn't stable, but it's guaranteed to use <code>Into</code> and <code>From</code> impls if you provide them?</p>",
        "id": 209200150,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348450
    },
    {
        "content": "<p>The design meeting brought up a bunch of these -- Taylor pointed out a bunch of stable poll ones, and people are unfortunately even using option-to-result conversion in a few places even though we tried to keep the type unstable to prevent that.</p>",
        "id": 209200205,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348540
    },
    {
        "content": "<p>Sigh.</p>",
        "id": 209200210,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348562
    },
    {
        "content": "<p>Right.</p>",
        "id": 209200211,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348565
    },
    {
        "content": "<p>And right, the Result one in particular needs to go through <code>From</code>.</p>",
        "id": 209200214,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348569
    },
    {
        "content": "<p>With the benefit of hindsight: this is a good example that it can be a bad idea to do the \"stable interface to unstable desugaring\" thing, because people will find ways to rely on the desugaring.</p>",
        "id": 209200263,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348606
    },
    {
        "content": "<p>/me wishes that we'd just never stabilized the ability to use <code>?</code> on anything but <code>Result</code> until we had <code>Try</code> ready to stabilize.</p>",
        "id": 209200269,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348625
    },
    {
        "content": "<p>Yeah, another thing for the time machine list.</p>",
        "id": 209200298,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348708
    },
    {
        "content": "<p>In theory, we <em>could</em> change that over an edition, but that'd be disruptive.</p>",
        "id": 209200340,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348742
    },
    {
        "content": "<p>Actually, we might be able to arrange an edition break here.</p>",
        "id": 209200351,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348780
    },
    {
        "content": "<p>Given the modified carrier mechanism you're describing, though, we might theoretically be able to make the old behavior available as <code>.foo()?</code>...</p>",
        "id": 209200355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348785
    },
    {
        "content": "<p>We can use a different trait in different editions to desugar <code>?</code></p>",
        "id": 209200359,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348799
    },
    {
        "content": "<p>Right, that's what I mean.</p>",
        "id": 209200361,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348805
    },
    {
        "content": "<p>That's what I was saying would be disruptive.</p>",
        "id": 209200366,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348817
    },
    {
        "content": "<p>I think _just_ breaking the unintended interconversions might not be too bad.</p>",
        "id": 209200375,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348840
    },
    {
        "content": "<p>Insofar as if you're relying on <code>?</code> to work with some of the more unusual cases that came up in that design meeting, you might experience breakage across the edition.</p>",
        "id": 209200412,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> What would that look like? What would that break?</p>",
        "id": 209200416,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348854
    },
    {
        "content": "<p><code>option?</code> in <code>Result&lt;_, Box&lt;SomethingThatConvertsFromImplDebug&gt;&gt;</code>, I think.</p>",
        "id": 209200426,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Syntax.20Musing.3A.20.60try.20as.20Something.20.7B.20.2E.2E.2E.20.7D.60/near/209200340\">said</a>:</p>\n<blockquote>\n<p>In theory, we <em>could</em> change that over an edition, but that'd be disruptive.</p>\n</blockquote>\n<p>slightly offtopic, but isn't that a breaking change? what can be changed in an edition and what can't?</p>",
        "id": 209200435,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599348917
    },
    {
        "content": "<p>A bunch of the <code>Poll</code> ones are intentional, so I don't think we'd break those.  Just the ones that weren't supposed to work but did anyway.</p>",
        "id": 209200440,
        "sender_full_name": "scottmcm",
        "timestamp": 1599348949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> An edition is opt-in (via <code>edition = \"...\"</code> in <code>Cargo.toml</code> or equivalent rustc options), which means it <em>can</em> make breaking changes.</p>",
        "id": 209200479,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599348963
    },
    {
        "content": "<p>e.g. in <a href=\"https://github.com/rust-lang/rfcs/issues/2848#issuecomment-573472728\">https://github.com/rust-lang/rfcs/issues/2848#issuecomment-573472728</a> someone said removing a trait impl was breaking and couldn't be done even in an edition</p>",
        "id": 209200481,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599348966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> Both traits would exist and have impls in both editions.  The change would be how <code>?</code> desugars to one or the other.  (The library can't change between editions, but the frontend can.)</p>",
        "id": 209200483,
        "sender_full_name": "scottmcm",
        "timestamp": 1599349001
    },
    {
        "content": "<p>oh I see, you can change the <em>compiler</em> but not the <em>library</em></p>",
        "id": 209200495,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599349050
    },
    {
        "content": "<p>ok that makes sense</p>",
        "id": 209200497,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599349052
    },
    {
        "content": "<p>Right. We can change what things desugar to, but all the variations must be available in the library.</p>",
        "id": 209200543,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599349145
    },
    {
        "content": "<p>There's some discussion about how we might be able to change the implicit prelude that the compiler adds, and in that case, both preludes would exist and what'd vary by edition would be which prelude the compiler uses.</p>",
        "id": 209200549,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599349170
    },
    {
        "content": "<p>My usual example: We can't make <code>Range</code> not be an iterator, but we could change <code>..</code> to give a different type that's only <code>IntoIterator</code>, not <code>Iterator</code> itself.</p>",
        "id": 209200551,
        "sender_full_name": "scottmcm",
        "timestamp": 1599349196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> You can even have a macro from one edition expanded in code in the other edition, and the compiler decides how to desugar things based on the edition of the span.</p>",
        "id": 209200594,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599349207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Syntax.20Musing.3A.20.60try.20as.20Something.20.7B.20.2E.2E.2E.20.7D.60/near/209200594\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> You can even have a macro from one edition expanded in code in the other edition, and the compiler decides how to desugar things based on the edition of the span.</p>\n</blockquote>\n<p>wow, that's cool! Is that why <code>panic!</code> is a macro?</p>",
        "id": 209200597,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599349224
    },
    {
        "content": "<p>No, I think <code>panic!</code> is a macro because it accepts variable arguments, like <code>println!</code>, and the only way we currently have to do that is a macro.</p>",
        "id": 209200602,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599349258
    },
    {
        "content": "<p>Also, it does formatting, and a macro's the only way to check the format string at compile-time.  And it needs to call different traits depending on the format specifiers.</p>",
        "id": 209200650,
        "sender_full_name": "scottmcm",
        "timestamp": 1599349326
    },
    {
        "content": "<p>But anyway, I'll see if I can come up with a demo of the overall idea of a different (set of) <code>Try</code> trait(s).</p>",
        "id": 209200666,
        "sender_full_name": "scottmcm",
        "timestamp": 1599349422
    }
]