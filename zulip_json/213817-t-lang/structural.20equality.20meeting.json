[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> , are you preparing a write-up for Wednesday’s structural equality meeting?</p>",
        "id": 247346840,
        "sender_full_name": "pnkfelix",
        "timestamp": 1627398743
    },
    {
        "content": "<p>No, but that seems like a rather good idea</p>",
        "id": 247346969,
        "sender_full_name": "oli",
        "timestamp": 1627398804
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790\">My comment from last time</a> -- that was before the last meeting though. Not sure if we have a post-meeting writeup.</p>",
        "id": 247391365,
        "sender_full_name": "RalfJ",
        "timestamp": 1627419816
    },
    {
        "content": "<p>Hey <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> -- <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> and I were debating about delaying the meeting, since we'd like to do more work on the intro</p>",
        "id": 247474840,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627486355
    },
    {
        "content": "<p>Background: (I had intended to write it, but wound up getting busy, and <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> tried to pick up the ball)</p>",
        "id": 247474904,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627486390
    },
    {
        "content": "<p>Deferring to one of the design meetings next month seems fine. Should we wait for you to get back from vacation, or have the meeting while you're gone?</p>",
        "id": 247475143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627486517
    },
    {
        "content": "<p>Either is probably ok--</p>",
        "id": 247475283,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627486569
    },
    {
        "content": "<p>I won't be able to do the writeup until afterwards</p>",
        "id": 247475298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627486577
    },
    {
        "content": "<p>I'm on board, I think, with Ralf's design</p>",
        "id": 247475312,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627486584
    },
    {
        "content": "<p>Does the writeup include an explanation of valtrees for people who aren't familiar with them?</p>",
        "id": 247475542,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627486699
    },
    {
        "content": "<p>(I've seen the term many times, and I feel like I have a vague idea, but I'd like to have more than a vague idea.)</p>",
        "id": 247475560,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627486709
    },
    {
        "content": "<p>yes</p>",
        "id": 247475567,
        "sender_full_name": "oli",
        "timestamp": 1627486715
    },
    {
        "content": "<p>feedback on whether it is sufficient is very welcome tho</p>",
        "id": 247475598,
        "sender_full_name": "oli",
        "timestamp": 1627486730
    },
    {
        "content": "<p>I'll cancel the calendar invite</p>",
        "id": 247475897,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627486863
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> <a href=\"https://hackmd.io/Zrk3iPzOQDC5kOMC1B34_Q?both\">https://hackmd.io/Zrk3iPzOQDC5kOMC1B34_Q?both</a></p>",
        "id": 248499862,
        "sender_full_name": "oli",
        "timestamp": 1628180167
    },
    {
        "content": "<p>thanks</p>",
        "id": 248499897,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180182
    },
    {
        "content": "<p>the structure of the doc changed a bit since last time you saw it</p>",
        "id": 248499905,
        "sender_full_name": "oli",
        "timestamp": 1628180187
    },
    {
        "content": "<p>yeah let me take a moment to read it</p>",
        "id": 248499921,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180197
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> ping me when you're done</p>",
        "id": 248499954,
        "sender_full_name": "oli",
        "timestamp": 1628180215
    },
    {
        "content": "<p>do you want comments here, or via comments on doc, or via priv msg, or in separate topic?</p>",
        "id": 248499995,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180243
    },
    {
        "content": "<p>we can just do it here</p>",
        "id": 248500117,
        "sender_full_name": "oli",
        "timestamp": 1628180295
    },
    {
        "content": "<p>or comment on the doc if that is easier for you since you're reading it</p>",
        "id": 248500150,
        "sender_full_name": "oli",
        "timestamp": 1628180313
    },
    {
        "content": "<p>\"The TLDR is that we sometimes need to know that the <code>PartialEq</code> impl is equivalent to running the <code>PartialEq</code> impl of each field and using <code>&amp;&amp;</code> to combine the results.” ==&gt; <em>and</em> that the same property is applied recursively throughout all types involved in the comparison, right?</p>",
        "id": 248500238,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180374
    },
    {
        "content": "<p>no <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> sadly not</p>",
        "id": 248500678,
        "sender_full_name": "oli",
        "timestamp": 1628180594
    },
    {
        "content": "<p><code>StructuralEq</code> is a shallow property at present</p>",
        "id": 248500699,
        "sender_full_name": "oli",
        "timestamp": 1628180606
    },
    {
        "content": "<p>which causes all kinds of problems</p>",
        "id": 248500717,
        "sender_full_name": "oli",
        "timestamp": 1628180616
    },
    {
        "content": "<p>but the “need to know\"</p>",
        "id": 248500747,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180641
    },
    {
        "content": "<p>pattern matching can handle that (by falling back to <code>PartialEq</code> for runtime comparison)</p>",
        "id": 248500785,
        "sender_full_name": "oli",
        "timestamp": 1628180645
    },
    {
        "content": "<p>I think I understand that <code>StructuralEq</code> is shallow</p>",
        "id": 248500804,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180658
    },
    {
        "content": "<p>but const generics needs it recursively</p>",
        "id": 248500814,
        "sender_full_name": "oli",
        "timestamp": 1628180664
    },
    {
        "content": "<p>the same goes for the need to know</p>",
        "id": 248500832,
        "sender_full_name": "oli",
        "timestamp": 1628180677
    },
    {
        "content": "<p>but we still try to enforce it deeply, via the nature of how its used via <code>derive</code>, right?</p>",
        "id": 248500849,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180686
    },
    {
        "content": "<p>the fallback works just fine later in the deconstruction of the const</p>",
        "id": 248500861,
        "sender_full_name": "oli",
        "timestamp": 1628180692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248500849\">said</a>:</p>\n<blockquote>\n<p>but we still try to enforce it deeply, via the nature of how its used via <code>derive</code>, right?</p>\n</blockquote>\n<p>no</p>",
        "id": 248500869,
        "sender_full_name": "oli",
        "timestamp": 1628180697
    },
    {
        "content": "<p>Well in any case</p>",
        "id": 248500875,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180703
    },
    {
        "content": "<p>that paragraph says “we sometimes need to know\"</p>",
        "id": 248500927,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180730
    },
    {
        "content": "<p>it's literally expanding to <code>impl&lt;T&gt; StructuralEq for Type&lt;T&gt; {}</code>, no field bounds, no generic bounds</p>",
        "id": 248500929,
        "sender_full_name": "oli",
        "timestamp": 1628180731
    },
    {
        "content": "<p>if the need-to-know is itself recursive</p>",
        "id": 248500939,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180740
    },
    {
        "content": "<p>the sometimes is meant for the compiler</p>",
        "id": 248500943,
        "sender_full_name": "oli",
        "timestamp": 1628180742
    },
    {
        "content": "<p>then that should be reflected in what we write there</p>",
        "id": 248500966,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180751
    },
    {
        "content": "<p>which is what I was suggesting</p>",
        "id": 248500970,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180754
    },
    {
        "content": "<p>ok</p>",
        "id": 248500971,
        "sender_full_name": "oli",
        "timestamp": 1628180755
    },
    {
        "content": "<p>(its useful to then also note where we fail to enforce that)</p>",
        "id": 248501045,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248500929\">said</a>:</p>\n<blockquote>\n<p>it's literally expanding to <code>impl&lt;T&gt; StructuralEq for Type&lt;T&gt; {}</code>, no field bounds, no generic bounds</p>\n</blockquote>\n<p>Hmm. I did know that. but I thought it was still enforced somehow</p>",
        "id": 248501315,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180896
    },
    {
        "content": "<p>i.e. via special case code in the derive or something</p>",
        "id": 248501338,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180907
    },
    {
        "content": "<p>let me go look</p>",
        "id": 248501344,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628180912
    },
    {
        "content": "<p>so with the rewrite you just put in</p>",
        "id": 248502141,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181307
    },
    {
        "content": "<p>\"For pattern matching … We do not need to know that this property applies to the fields of whatever we are matching on … We can always fall back to … <code>PartialEq::eq</code> … \"</p>",
        "id": 248502205,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181349
    },
    {
        "content": "<p>the whole point I thought we tried to make with the StructuralEq trait</p>",
        "id": 248502272,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181368
    },
    {
        "content": "<p>was that the reason we <em>could</em> fallback in that manner</p>",
        "id": 248502283,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181373
    },
    {
        "content": "<p>no</p>",
        "id": 248502294,
        "sender_full_name": "oli",
        "timestamp": 1628181380
    },
    {
        "content": "<p>we can always fallback, that is perfectly safe</p>",
        "id": 248502311,
        "sender_full_name": "oli",
        "timestamp": 1628181390
    },
    {
        "content": "<p>was because the PartialEq was going to be forced to match up with the semantics</p>",
        "id": 248502317,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181392
    },
    {
        "content": "<p>i.e.</p>",
        "id": 248502326,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181397
    },
    {
        "content": "<p>that there was no potential for confusion</p>",
        "id": 248502341,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181402
    },
    {
        "content": "<p>where the PartialEq::eq would deviate from naive structural traversal</p>",
        "id": 248502366,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181413
    },
    {
        "content": "<p>(Except, I suppose, for floating point… sigh.)</p>",
        "id": 248502410,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181432
    },
    {
        "content": "<p>right, but we need this property in order to take apart e.g. <code>const FOO: (i32, i32) = (42, 43);</code> into a tuple pattern</p>",
        "id": 248502416,
        "sender_full_name": "oli",
        "timestamp": 1628181434
    },
    {
        "content": "<p>we will fall back for <code>(i32, NotStructEq)</code> only when we have taken apart the outer layer and then call <code>PartialEq</code> on the <code>NotStructEq</code> type</p>",
        "id": 248502477,
        "sender_full_name": "oli",
        "timestamp": 1628181475
    },
    {
        "content": "<p>because if a type implements <code>StructuralEq</code>, we know converting to a pattern will not cause any change in behaviour</p>",
        "id": 248502548,
        "sender_full_name": "oli",
        "timestamp": 1628181504
    },
    {
        "content": "<p>the breaking change would be to forbid <code>!StructuralEq</code> types from pattern matching in general, but I fear that ship has sailed</p>",
        "id": 248502591,
        "sender_full_name": "oli",
        "timestamp": 1628181536
    },
    {
        "content": "<p>i guess let me read the whole doc. I’ll stop trying to give feedback part way through</p>",
        "id": 248502638,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181572
    },
    {
        "content": "<p>(It probably would be good to give a concrete example of where match falls back to manually implemented <code>PartialEq</code> today. I think I know what this was talking about but I wouldn’t want to try to reconstruct it on the fly if asked.)</p>",
        "id": 248503311,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628181914
    },
    {
        "content": "<blockquote>\n<p>For pattern matching it is “sufficient” to know this for the type of a constant that we are pattern matching. </p>\n</blockquote>\n<p>why can we not start out with <em>just</em> always using <code>PartialEq</code> for consts</p>",
        "id": 248503945,
        "sender_full_name": "lcnr",
        "timestamp": 1628182222
    },
    {
        "content": "<p>i.e. why is it required for the root of a constant to be <code>StructuralEq</code> during pattern matching?</p>",
        "id": 248503991,
        "sender_full_name": "lcnr",
        "timestamp": 1628182247
    },
    {
        "content": "<p>because that is a breaking change</p>",
        "id": 248504095,
        "sender_full_name": "oli",
        "timestamp": 1628182314
    },
    {
        "content": "<p>we always used to destructure at least some constants</p>",
        "id": 248504161,
        "sender_full_name": "oli",
        "timestamp": 1628182327
    },
    {
        "content": "<p>if we stop doing it, you get errors because you are missing match arms</p>",
        "id": 248504185,
        "sender_full_name": "oli",
        "timestamp": 1628182343
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>works on stable</p>",
        "id": 248504356,
        "sender_full_name": "oli",
        "timestamp": 1628182417
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248504358,
        "sender_full_name": "lcnr",
        "timestamp": 1628182419
    },
    {
        "content": "<p>yeah, but my example does not</p>",
        "id": 248504386,
        "sender_full_name": "lcnr",
        "timestamp": 1628182429
    },
    {
        "content": "<p>and as long as we destructure constants for types which implement <code>StructuralEq</code></p>",
        "id": 248504430,
        "sender_full_name": "lcnr",
        "timestamp": 1628182443
    },
    {
        "content": "<p>we don't break anything as currently only these types are allowed</p>",
        "id": 248504491,
        "sender_full_name": "lcnr",
        "timestamp": 1628182458
    },
    {
        "content": "<p>so we could allow constants of types which only implement <code>PartialEq</code>, strictly allowing more code to compile and making <code>StructuralEq</code> only relevant for exhaustiveness checking (from the perspective of the user)</p>",
        "id": 248504591,
        "sender_full_name": "lcnr",
        "timestamp": 1628182509
    },
    {
        "content": "<p>interesting, seems we already did the breaking change: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c37b56c9d6788539d9448e486ab02f1b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c37b56c9d6788539d9448e486ab02f1b</a></p>",
        "id": 248504693,
        "sender_full_name": "oli",
        "timestamp": 1628182557
    },
    {
        "content": "<p>there's still a future incompat lint, but also a hard error</p>",
        "id": 248504775,
        "sender_full_name": "oli",
        "timestamp": 1628182578
    },
    {
        "content": "<p>anyway, yea looks like we could make it recursive and just fall back to <code>PartialEq</code> at the top level</p>",
        "id": 248504897,
        "sender_full_name": "oli",
        "timestamp": 1628182647
    },
    {
        "content": "<p>will u update the doc, or should i?</p>",
        "id": 248505420,
        "sender_full_name": "lcnr",
        "timestamp": 1628182820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248504693\">said</a>:</p>\n<blockquote>\n<p>interesting, seems we already did the breaking change: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c37b56c9d6788539d9448e486ab02f1b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c37b56c9d6788539d9448e486ab02f1b</a></p>\n</blockquote>\n<p>sorry, when did you think that code worked?</p>",
        "id": 248505716,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628182926
    },
    {
        "content": "<p>(or at least, I’m having trouble finding a version on godbolt that accepted it, or simple variations of it I made to address nits from older compilers…)</p>",
        "id": 248506016,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183046
    },
    {
        "content": "<p>hmm... let me look at the tests, we have <em>something</em> that used to work, but it is really subtle</p>",
        "id": 248506075,
        "sender_full_name": "oli",
        "timestamp": 1628183079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> biggest feedback on doc that I haven’t already given: If you can, you should stake out a position, preferably early on, about what solution (or set of solutions) we should adopt. Its great to give an overview of the design space, but it also can really help the conversation if we start off with some clue as to what the expert prefers.</p>",
        "id": 248506153,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183116
    },
    {
        "content": "<p>its not like it commits us. It just can help direct conversation</p>",
        "id": 248506193,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183138
    },
    {
        "content": "<p>ah yes, it compiles if you manually implement <code>Eq</code> and <code>PartialEq</code> in broken ways</p>",
        "id": 248506265,
        "sender_full_name": "oli",
        "timestamp": 1628183163
    },
    {
        "content": "<p>of course, if you literally have not idea what is best, then I guess you can say that. but its better to then figure out what questions you would want to answer in order to know what would be best</p>",
        "id": 248506299,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248506265\">said</a>:</p>\n<blockquote>\n<p>ah yes, it compiles if you manually implement <code>Eq</code> and <code>PartialEq</code> in broken ways</p>\n</blockquote>\n<p>ah of course</p>",
        "id": 248506322,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183177
    },
    {
        "content": "<p>yea, I have solutions spread out through the doc, I will merge them into one chapter</p>",
        "id": 248506359,
        "sender_full_name": "oli",
        "timestamp": 1628183194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248506265\">said</a>:</p>\n<blockquote>\n<p>ah yes, it compiles if you manually implement <code>Eq</code> and <code>PartialEq</code> in broken ways</p>\n</blockquote>\n<p>but don’t you also have to also add a wildcard or other arm to to cover the <code> &amp;&amp;(true, &amp;&amp;Foo)</code> case, because the exhaustiveness checker could not figure that out?</p>",
        "id": 248506640,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183331
    },
    {
        "content": "<p>or at least, that’s what I observe via godbolt for rust 1.50.0</p>",
        "id": 248506765,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183394
    },
    {
        "content": "<p>or no, the version I get that’s accepted on 1.50.0 is also accepted on 1.54.0. So never mind.</p>",
        "id": 248506864,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628183432
    },
    {
        "content": "<blockquote>\n<p>make <code>StructuralEq</code> recursive, unsafe </p>\n</blockquote>\n<p>what's the reason to make <code>StructuralEq</code> unsafe? I opted against that in my proposal as incorrect impls should just cause surprising, but not undefined behavior</p>",
        "id": 248507915,
        "sender_full_name": "lcnr",
        "timestamp": 1628183957
    },
    {
        "content": "<p>yea, I don't like that option, just listing it</p>",
        "id": 248508140,
        "sender_full_name": "oli",
        "timestamp": 1628184054
    },
    {
        "content": "<p>the third option is the one I like</p>",
        "id": 248508150,
        "sender_full_name": "oli",
        "timestamp": 1628184058
    },
    {
        "content": "<blockquote>\n<ol start=\"3\">\n<li>hard error on using types that don’t have a derived PartialEq + Eq impl in patterns</li>\n</ol>\n</blockquote>\n<p>a recursively derived <code>PartialEq + Eq</code> impl?</p>",
        "id": 248508550,
        "sender_full_name": "lcnr",
        "timestamp": 1628184215
    },
    {
        "content": "<p>yes</p>",
        "id": 248508803,
        "sender_full_name": "oli",
        "timestamp": 1628184328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248508140\">said</a>:</p>\n<blockquote>\n<p>yea, I don't like that option, just listing it</p>\n</blockquote>\n<p>It's not that i don't like that option (though i might), but that I don't understand it</p>",
        "id": 248509821,
        "sender_full_name": "lcnr",
        "timestamp": 1628184838
    },
    {
        "content": "<p>i.e. it seems to me like however I imagine that proposal, it's made worse by <code>StructuralEq</code> being unsafe</p>",
        "id": 248509946,
        "sender_full_name": "lcnr",
        "timestamp": 1628184891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248509946\">said</a>:</p>\n<blockquote>\n<p>i.e. it seems to me like however I imagine that proposal, it's made worse by <code>StructuralEq</code> being unsafe</p>\n</blockquote>\n<p>if it were safe and you could implement it, it would not be better? Not sure I understand your point XD</p>",
        "id": 248520290,
        "sender_full_name": "oli",
        "timestamp": 1628189793
    },
    {
        "content": "<p><code>StructuralEq</code> being unsafe without any safety requirements is nonsense</p>",
        "id": 248524296,
        "sender_full_name": "lcnr",
        "timestamp": 1628191652
    },
    {
        "content": "<p>so there would have to be some way to implement <code>StructuralEq</code> and be unsound</p>",
        "id": 248524338,
        "sender_full_name": "lcnr",
        "timestamp": 1628191676
    },
    {
        "content": "<p>and except the compiler being able to assume that partialeq is equal to structural eq and using partialeq impls even though the const was considered during exhaustiveness checking I can't think of reasons to have these as safety requirements</p>",
        "id": 248524548,
        "sender_full_name": "lcnr",
        "timestamp": 1628191784
    },
    {
        "content": "<p>and doing that seems worse than just not doing it</p>",
        "id": 248524657,
        "sender_full_name": "lcnr",
        "timestamp": 1628191823
    },
    {
        "content": "<p>i was thinking about const generics. if you end up with two different constants that are equal, that sounds problematic</p>",
        "id": 248542515,
        "sender_full_name": "oli",
        "timestamp": 1628200579
    },
    {
        "content": "<p>const generics also uses structural equality though?</p>",
        "id": 248585552,
        "sender_full_name": "lcnr",
        "timestamp": 1628239636
    },
    {
        "content": "<p>i don't think that the following causing a panic is a soundness concern</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"nc\">WeirdType</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248585639,
        "sender_full_name": "lcnr",
        "timestamp": 1628239684
    },
    {
        "content": "<p>(I quite like my proposal - <a href=\"https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA\">https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA</a> - that's why I've made it)</p>\n<p>This proposal pretty much boils down to</p>\n<blockquote>\n<ol>\n<li>do nothing, lazy fallback (keep complex fragile system with some surprising behaviour)</li>\n</ol>\n</blockquote>\n<p>except that it's actually (imo) nicely defined and fairly straightforward to understand (at least once we've added better docs to that proposal)</p>",
        "id": 248585855,
        "sender_full_name": "lcnr",
        "timestamp": 1628239888
    },
    {
        "content": "<p>As I don't think 3. is feasable (nor do i like it too much) I want to only compare it with \"2. eager fallback\" here</p>",
        "id": 248585997,
        "sender_full_name": "lcnr",
        "timestamp": 1628239990
    },
    {
        "content": "<p><del>The way 1. and 2. differ is that 1. allows some types to participate in exhaustiveness checking which simply use <code>PartialEq</code> with proposal 2</del></p>",
        "id": 248586624,
        "sender_full_name": "lcnr",
        "timestamp": 1628240431
    },
    {
        "content": "<p>The way 1. and 2. differ is that 1. would have more unreachable pattern warnings when using a constant after an ordinary pattern.</p>",
        "id": 248586978,
        "sender_full_name": "lcnr",
        "timestamp": 1628240734
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">NonStructuralEq</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">NonStructuralEq</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">other</span>: <span class=\"nc\">NonStructuralEq</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">NonStructuralEq</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">_</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"> </span><span class=\"c1\">// Warns with proposal 1, doesn't warn with proposal 2</span>\n<span class=\"w\">        </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">_</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248587249,
        "sender_full_name": "lcnr",
        "timestamp": 1628240903
    },
    {
        "content": "<p>My complaint with your proposal is that it allows <code>other: *const i32</code>, which means we can't eagerly convert to valtree</p>",
        "id": 248590342,
        "sender_full_name": "oli",
        "timestamp": 1628243295
    },
    {
        "content": "<p>I'd be fine declaring that const-&gt;pat is not the same as runtime equality if the user declares this explicitly, but I want eager conversion to valtrees so we don't have to maintain two systems for deconstructing constants (one for generating valtrees, one for taking apart <code>ConstValue</code> allocations)</p>",
        "id": 248590533,
        "sender_full_name": "oli",
        "timestamp": 1628243422
    },
    {
        "content": "<p>oh tbh we could implement the valtree generation in terms of the system taking apart <code>ConstValue</code>, so it's probably not as bad, but still..</p>",
        "id": 248590565,
        "sender_full_name": "oli",
        "timestamp": 1628243453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248500699\">said</a>:</p>\n<blockquote>\n<p><code>StructuralEq</code> is a shallow property at present</p>\n</blockquote>\n<p><em>at present</em>, yes, but I think there's no good reason for this and we should fix that</p>",
        "id": 248604132,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248524296\">said</a>:</p>\n<blockquote>\n<p><code>StructuralEq</code> being unsafe without any safety requirements is nonsense</p>\n</blockquote>\n<p>why would there be no safety requirements? in my proposals there always were very precise safety requirements... I guess I need to figure out how much of that made it into <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>'s document ;)</p>",
        "id": 248604405,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253186
    },
    {
        "content": "<p>none made it in XD</p>",
        "id": 248604452,
        "sender_full_name": "oli",
        "timestamp": 1628253225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248590565\">said</a>:</p>\n<blockquote>\n<p>oh tbh we could implement the valtree generation in terms of the system taking apart <code>ConstValue</code>, so it's probably not as bad, but still..</p>\n</blockquote>\n<p>yeah I agree, valtrees should <em>replace</em> the current \"destructure const\" stuff</p>",
        "id": 248604455,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248604452\">said</a>:</p>\n<blockquote>\n<p>none made it in XD</p>\n</blockquote>\n<p>hm I guess I'd appreciate a comparison with <a href=\"https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790\">https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790</a> then. it does no good to ignore prior work. ;)</p>",
        "id": 248604533,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253275
    },
    {
        "content": "<blockquote>\n<p>RalfJ wants either 2/3 as far as @oli-obk can tell</p>\n</blockquote>\n<p>I think it'd be something like 2: check if the type implements <code>StrucutralEq</code> (which is an unsafe trait with precise safety requirements); if yes build valtree, else treat opaquely.</p>",
        "id": 248604713,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253395
    },
    {
        "content": "<p>implementing <code>StrucutralEq</code> roughly corresponds to \"PartialEq + Eq is derived (recursively)\", except it's a semantic condition, not a syntactic one</p>",
        "id": 248604770,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253443
    },
    {
        "content": "<p>(it must essentially <em>behave like</em> the derived impl, but it doesn't actually have to be literally derived)</p>",
        "id": 248604806,
        "sender_full_name": "RalfJ",
        "timestamp": 1628253475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248604533\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248604452\">said</a>:</p>\n<blockquote>\n<p>none made it in XD</p>\n</blockquote>\n<p>hm I guess I'd appreciate a comparison with <a href=\"https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790\">https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790</a> then. it does no good to ignore prior work. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I didn't ignore it. I declared the trait to be unsafe after all</p>",
        "id": 248605551,
        "sender_full_name": "oli",
        "timestamp": 1628253983
    },
    {
        "content": "<p>the point lcnr makes is that it doesn't have to be. We can just go with post monomorphization errors and odd behaviour if the user breaks the contract, but there is no unsoundness</p>",
        "id": 248605595,
        "sender_full_name": "oli",
        "timestamp": 1628254022
    },
    {
        "content": "<p>yeah I read the text now, sorry for commenting too early</p>",
        "id": 248605781,
        "sender_full_name": "RalfJ",
        "timestamp": 1628254126
    },
    {
        "content": "<p>I left some comments in the hackmd :D</p>",
        "id": 248605792,
        "sender_full_name": "RalfJ",
        "timestamp": 1628254133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248605595\">said</a>:</p>\n<blockquote>\n<p>the point lcnr makes is that it doesn't have to be. We can just go with post monomorphization errors and odd behaviour if the user breaks the contract, but there is no unsoundness</p>\n</blockquote>\n<p>unsoundness is always close when discussing exhaustiveness checking. so at the least we need to guarantee that if a pattern works via valtrees and is considered for exhaustiveness, then rustc emits its own comparison code.<br>\nit would be unsound to treat a const in a pattern like a valtree but later call <code>PartialEq::eq</code> at runtime.</p>",
        "id": 248605974,
        "sender_full_name": "RalfJ",
        "timestamp": 1628254266
    },
    {
        "content": "<p>other than that... yeah I think this might not lead to UB in the literal sense. but it \"breaks the language\" in the sense of pattern matching disagreeing with <code>==</code> and in the sense of post-monomorphization errors (alongside all the technical debt we'll accumulate to ensure those are reasonably clear for users)</p>",
        "id": 248606128,
        "sender_full_name": "RalfJ",
        "timestamp": 1628254343
    },
    {
        "content": "<p>\"breaks the language\" already kind of happens when hash/eq disagree, or when deref is not reliably returning the same thing</p>",
        "id": 248606522,
        "sender_full_name": "oli",
        "timestamp": 1628254607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248605974\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248605595\">said</a>:</p>\n<blockquote>\n<p>the point lcnr makes is that it doesn't have to be. We can just go with post monomorphization errors and odd behaviour if the user breaks the contract, but there is no unsoundness</p>\n</blockquote>\n<p>unsoundness is always close when discussing exhaustiveness checking. so at the least we need to guarantee that if a pattern works via valtrees and is considered for exhaustiveness, then rustc emits its own comparison code.<br>\nit would be unsound to treat a const in a pattern like a valtree but later call <code>PartialEq::eq</code> at runtime.</p>\n</blockquote>\n<p>yea, if you can convert to a valtree, you get a full conversion to a pattern</p>",
        "id": 248606597,
        "sender_full_name": "oli",
        "timestamp": 1628254663
    },
    {
        "content": "<blockquote>\n<p>We can just go with post monomorphization errors</p>\n</blockquote>\n<p>My proposal would not result in post mono errors</p>",
        "id": 248607373,
        "sender_full_name": "lcnr",
        "timestamp": 1628255056
    },
    {
        "content": "<p>as <strong>the compiler itself</strong> can prevent any <code>StructuralEq</code> impl (which are a shallow requirement in my proposal) which does not result in a valid val tree</p>",
        "id": 248607420,
        "sender_full_name": "lcnr",
        "timestamp": 1628255093
    },
    {
        "content": "<p>so types which implement deep <code>StructuralEq</code> are always representable as a val tree, their structural equality might however disagree with the <code>PartialEq</code> impl, which is not required for soundness</p>",
        "id": 248607562,
        "sender_full_name": "lcnr",
        "timestamp": 1628255167
    },
    {
        "content": "<p>we need a recursive <code>StructuralEq</code> for const generics</p>",
        "id": 248607818,
        "sender_full_name": "RalfJ",
        "timestamp": 1628255323
    },
    {
        "content": "<p>are you suggesting we have two slightly different notions and have to explain both of them to everyone? that's a lot of extra complexity, and I see insufficient benefit from doing so.</p>",
        "id": 248607864,
        "sender_full_name": "RalfJ",
        "timestamp": 1628255345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248607864\">said</a>:</p>\n<blockquote>\n<p>are you suggesting we have two slightly different notions and have to explain both of them to everyone? that's a lot of extra complexity, and I see insufficient benefit from doing so.</p>\n</blockquote>\n<p>my suggestion is <a href=\"https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA\">https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA</a></p>",
        "id": 248607941,
        "sender_full_name": "lcnr",
        "timestamp": 1628255397
    },
    {
        "content": "<p>so yes, my suggestion uses two different traits, one for shallow and one for deep \"val tree-ness\"/\"structural equality\"</p>",
        "id": 248608052,
        "sender_full_name": "lcnr",
        "timestamp": 1628255437
    },
    {
        "content": "<p>May i ask a question though... Why not just use <code>impl const PartialEq</code> or <code>impl const Eq</code> for  const generics? Are there some cons for this approach?</p>",
        "id": 248608083,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628255449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248608083\">said</a>:</p>\n<blockquote>\n<p>May i ask a question though... Why not just use <code>impl const PartialEq</code> or <code>impl const Eq</code> for  const generics? Are there some cons for this approach?</p>\n</blockquote>\n<p>how should we deal with non-reflexive <code>PartialEq</code> impls in that case? i.e. if <code>a == a</code> returns <code>false</code></p>",
        "id": 248608133,
        "sender_full_name": "lcnr",
        "timestamp": 1628255477
    },
    {
        "content": "<p>it doesnt work for <code>const_evaluatable_checked</code> where we need equality between expressions which are too generic to evaluate i.e. <code>N + 1</code></p>",
        "id": 248608138,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1628255479
    },
    {
        "content": "<p>Emit a warning or something?</p>",
        "id": 248608247,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628255526
    },
    {
        "content": "<p>If it matters, the compiler can check it, right?</p>",
        "id": 248608274,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628255540
    },
    {
        "content": "<p>we probably have to hard error in that case</p>",
        "id": 248608280,
        "sender_full_name": "lcnr",
        "timestamp": 1628255544
    },
    {
        "content": "<p>but also</p>",
        "id": 248608305,
        "sender_full_name": "lcnr",
        "timestamp": 1628255564
    },
    {
        "content": "<p>if 2 variables are equal using <code>PartialEq</code> but not equal in behavior</p>",
        "id": 248608334,
        "sender_full_name": "lcnr",
        "timestamp": 1628255578
    },
    {
        "content": "<p>we can easily get unsoundness</p>",
        "id": 248608378,
        "sender_full_name": "lcnr",
        "timestamp": 1628255595
    },
    {
        "content": "<p>yea, <code>const PartialEq</code> does not give us the guarantees we want.</p>",
        "id": 248608388,
        "sender_full_name": "oli",
        "timestamp": 1628255599
    },
    {
        "content": "<p>by using one value in one case and another value in another case, e.g. causing us to end up with 2 different assoc types for the same type</p>",
        "id": 248608437,
        "sender_full_name": "lcnr",
        "timestamp": 1628255619
    },
    {
        "content": "<p>Ok, but if the guarantee can be checked via the valtree approach</p>",
        "id": 248608819,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628255801
    },
    {
        "content": "<p>Maybe just use valtree approach as the \"regular result\" and emit warnings and errors when the const impls of PartialEq and Eq \"cheats\"?</p>",
        "id": 248608950,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628255865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248605974\">said</a>:</p>\n<blockquote>\n<p>it would be unsound to treat a const in a pattern like a valtree but later call <code>PartialEq::eq</code> at runtime.</p>\n</blockquote>\n<p>yeah, but doing that seems really undesirable to me which is my reason why I don't think we should make it <code>unsafe</code></p>",
        "id": 248608984,
        "sender_full_name": "lcnr",
        "timestamp": 1628255879
    },
    {
        "content": "<p>I don't think we ever <strong>want</strong> to do that, nor do i expect us to accidentally do that due to some bug or sth</p>",
        "id": 248609173,
        "sender_full_name": "lcnr",
        "timestamp": 1628255956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248590533\">said</a>:</p>\n<blockquote>\n<p>I'd be fine declaring that const-&gt;pat is not the same as runtime equality if the user declares this explicitly, but I want eager conversion to valtrees so we don't have to maintain two systems for deconstructing constants (one for generating valtrees, one for taking apart <code>ConstValue</code> allocations)</p>\n</blockquote>\n<p>So I think this is the big difference between our proposals. Keeping the best-effort scheme that deconstructs all kinds of constants as far as possible, vs generating a valtree, if that fails, do an opaque comparison, if it succeeds, infallibly convert to a pattern</p>",
        "id": 248609200,
        "sender_full_name": "oli",
        "timestamp": 1628255968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248609173\">said</a>:</p>\n<blockquote>\n<p>I don't think we ever <strong>want</strong> to do that, nor do i expect us to accidentally do that due to some bug or sth</p>\n</blockquote>\n<p>same</p>",
        "id": 248609208,
        "sender_full_name": "oli",
        "timestamp": 1628255972
    },
    {
        "content": "<p>the logic is such as that you either deconstruct, or you generate an opaque constant</p>",
        "id": 248609274,
        "sender_full_name": "oli",
        "timestamp": 1628255996
    },
    {
        "content": "<p>you can't have something deconstructable that generates an opaque constant</p>",
        "id": 248609351,
        "sender_full_name": "oli",
        "timestamp": 1628256011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248609200\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248590533\">said</a>:</p>\n<blockquote>\n<p>I'd be fine declaring that const-&gt;pat is not the same as runtime equality if the user declares this explicitly, but I want eager conversion to valtrees so we don't have to maintain two systems for deconstructing constants (one for generating valtrees, one for taking apart <code>ConstValue</code> allocations)</p>\n</blockquote>\n<p>So I think this is the big difference between our proposals. Keeping the best-effort scheme that deconstructs all kinds of constants as far as possible, vs generating a valtree, if that fails, do an opaque comparison, if it succeeds, infallibly convert to a pattern</p>\n</blockquote>\n<p>yes (though from a backcompat perspective these two things are actually equivalent)</p>",
        "id": 248609491,
        "sender_full_name": "lcnr",
        "timestamp": 1628256082
    },
    {
        "content": "<p>though my proposal results in more helpful warnings :p so it's better uwu</p>",
        "id": 248609617,
        "sender_full_name": "lcnr",
        "timestamp": 1628256129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span>  \"cheats\" would mean \"returns true but can be differentiated somehow\". I don't think it's possible to statically assert that 2 different values do not result in some different result somewhere</p>",
        "id": 248609792,
        "sender_full_name": "lcnr",
        "timestamp": 1628256213
    },
    {
        "content": "<p>For impl selection, comparison must be performed? By generating a valtree, comparing its structure and leaf nodes bit representation to another valtree, or something like this.</p>",
        "id": 248610462,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628256515
    },
    {
        "content": "<p>I'm imaging use cases like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"s\">\"hello\"</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">unreachable!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"s\">\"world\"</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Foo</span>::<span class=\"o\">&lt;</span><span class=\"s\">\"world\"</span><span class=\"o\">&gt;</span>::<span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248611221,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628256879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248611221\">said</a>:</p>\n<blockquote>\n<p>I'm imaging use cases like this:</p>\n</blockquote>\n<p>that will work using structural equality/val trees</p>\n<p>i don't fully understand  your first question <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> But yes, to know whether an impl applies you have to compare any const parameters, which we want to do by comparing their val trees (and currently do in a fragile way by destructuring their allocation)</p>",
        "id": 248611698,
        "sender_full_name": "lcnr",
        "timestamp": 1628257102
    },
    {
        "content": "<p>I split this into 2 traits because:</p>\n<ul>\n<li>I want to destructure values as much as possible to get better warnings and code which is easier to optimize</li>\n</ul>",
        "id": 248612033,
        "sender_full_name": "lcnr",
        "timestamp": 1628257260
    },
    {
        "content": "<ul>\n<li>verifying that the shallow notion of structural equality holds is pretty much trivial while doing it for the deep one is not</li>\n</ul>",
        "id": 248612130,
        "sender_full_name": "lcnr",
        "timestamp": 1628257317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248612130\">said</a>:</p>\n<blockquote>\n<ul>\n<li>verifying that the shallow notion of structural equality holds is pretty much trivial while doing it for the deep one is not</li>\n</ul>\n</blockquote>\n<p>I thought we'd just need to throw <code>StructuralEq</code> bounds for the field's types on the generated impl of <code>StructuralEq</code>?</p>",
        "id": 248612460,
        "sender_full_name": "oli",
        "timestamp": 1628257467
    },
    {
        "content": "<p>(I do believe that it's necessary to allow the user to manually assert that their type uses structural equality, e.g. when using some <code>PhantomData</code> which means that they can't use the derived <code>PartialEq</code>)</p>",
        "id": 248612471,
        "sender_full_name": "lcnr",
        "timestamp": 1628257473
    },
    {
        "content": "<p>I just want to say maybe user annotation(<code>StructuralEq</code>) is not that necessary for const generic use case... Maybe the intention may be better expressed with something like <code>impl const PartialEq</code> or something.</p>",
        "id": 248612506,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628257496
    },
    {
        "content": "<p>yes, I wanted to ex<br>\n<span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248612460\">said</a>:</p>\n<blockquote>\n<p>I thought we'd just need to throw <code>StructuralEq</code> bounds for the field's types on the generated impl of <code>StructuralEq</code>?</p>\n</blockquote>\n<p>wanted to expand on that rn <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>  yes, when the user implements <code>StructuralEq</code> the compiler could check that all fields implement <code>StructuralEq</code>, error, and recommend the potentially missing generic bounds</p>",
        "id": 248612801,
        "sender_full_name": "lcnr",
        "timestamp": 1628257659
    },
    {
        "content": "<p>oh heh... <em>that</em> is what you mean</p>",
        "id": 248613145,
        "sender_full_name": "oli",
        "timestamp": 1628257814
    },
    {
        "content": "<p>doing that is <em>bad</em> though</p>",
        "id": 248613173,
        "sender_full_name": "lcnr",
        "timestamp": 1628257837
    },
    {
        "content": "<p>yea I don't care about user defined impls, if they screw them up, they get weird errors and behaviour, and we can add lints and other helpers, but that is just nice, not necessary for the \"recursive\" feature</p>",
        "id": 248613179,
        "sender_full_name": "oli",
        "timestamp": 1628257840
    },
    {
        "content": "<p>like, structural eq is kinda boring as a trait, so there probably won't be weird bounds or sth</p>",
        "id": 248613230,
        "sender_full_name": "lcnr",
        "timestamp": 1628257870
    },
    {
        "content": "<p>if your type implements <code>StructuralEq</code> we assume it can be destructured recursively all the way</p>",
        "id": 248613287,
        "sender_full_name": "oli",
        "timestamp": 1628257895
    },
    {
        "content": "<p>but we still have the issue that if your type depend on some other crate, you first have to update that crate to implement <code>StructuralEq</code> for your type</p>",
        "id": 248613365,
        "sender_full_name": "lcnr",
        "timestamp": 1628257927
    },
    {
        "content": "<p>you may have complex bounds if field types are associated types of generic parameters</p>",
        "id": 248613392,
        "sender_full_name": "oli",
        "timestamp": 1628257939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248613365\">said</a>:</p>\n<blockquote>\n<p>but we still have the issue that if your type depend on some other crate, you first have to update that crate to implement <code>StructuralEq</code> for your type</p>\n</blockquote>\n<p>if you implement it without your fields actually having a <code>StructuralEq</code> impl, you are asserting that they are, with all the semver and similar issues that implies</p>",
        "id": 248613477,
        "sender_full_name": "oli",
        "timestamp": 1628257981
    },
    {
        "content": "<p>that is fine imo</p>",
        "id": 248613497,
        "sender_full_name": "oli",
        "timestamp": 1628257987
    },
    {
        "content": "<blockquote>\n<p>you are asserting that they are</p>\n</blockquote>\n<p>but they aren't? If your field doesn't implement <code>StructuralEq</code> and <code>StructuralEq</code> impls are \"deep\", that doesn#t seem to work?</p>",
        "id": 248613633,
        "sender_full_name": "lcnr",
        "timestamp": 1628258048
    },
    {
        "content": "<p>well... we don't need the trait to deconstruct values of the type. We need the trait in order to do so without PME</p>",
        "id": 248613723,
        "sender_full_name": "oli",
        "timestamp": 1628258099
    },
    {
        "content": "<p>or like, do you then assert: Hey my field might not be <code>StructuralEq</code>, but I've looked at it and it seems to fulfill these requirements. Causing bugs if the crate I use later changes their <code>PartialEq</code> impl</p>",
        "id": 248613732,
        "sender_full_name": "lcnr",
        "timestamp": 1628258101
    },
    {
        "content": "<p>yea, pretty much. I mean what other option do we have?</p>",
        "id": 248613791,
        "sender_full_name": "oli",
        "timestamp": 1628258136
    },
    {
        "content": "<p>that does require you to look at your fields</p>",
        "id": 248613797,
        "sender_full_name": "lcnr",
        "timestamp": 1628258139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248613791\">said</a>:</p>\n<blockquote>\n<p>yea, pretty much. I mean what other option do we have?</p>\n</blockquote>\n<p>shallow <code>StructuralEq</code> :p (<code>StructuralMatch</code> in my proposal)</p>",
        "id": 248613841,
        "sender_full_name": "lcnr",
        "timestamp": 1628258160
    },
    {
        "content": "<p>with deep <code>StructuralEq</code> automatically implemented by the compiler</p>",
        "id": 248613937,
        "sender_full_name": "lcnr",
        "timestamp": 1628258194
    },
    {
        "content": "<p>ok hold up, we're going in circles</p>",
        "id": 248613956,
        "sender_full_name": "oli",
        "timestamp": 1628258204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248613791\">said</a>:</p>\n<blockquote>\n<p>yea, pretty much. I mean what other option do we have?</p>\n</blockquote>\n<p>then I guess, what other option for which issue exactly? <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 248614431,
        "sender_full_name": "lcnr",
        "timestamp": 1628258413
    },
    {
        "content": "<p>I believe we all agree that we need to be able to convert constants to valtrees for const generics. Now, my current view is that we want to guarantee this works by having a trait (<code>StructuralEq</code>) on types that say \"this type satsifies this\". It has nothing to do with <code>PartialEq</code>, but it is nice if the behaviour matches. If the user manually implements <code>StructuralEq</code> and the valtree conversion fails, then you get a PME. We could prevent the PME, but that would require the compiler to check the <code>StructuralEq</code> correctness. The user may have a <code>struct IsJustAnInt(*const i32)</code> that they are sure will never contain pointers, so they impl <code>StructuralEq</code> for it. the static compiler check would fail, but valtree conversion would work</p>",
        "id": 248614451,
        "sender_full_name": "oli",
        "timestamp": 1628258421
    },
    {
        "content": "<p>I believe most of our disagreements/confusion/circles come from pattern matching</p>",
        "id": 248614504,
        "sender_full_name": "oli",
        "timestamp": 1628258441
    },
    {
        "content": "<p>In patterns, if the user \"lied\" with their manual <code>StructuralEq</code> impl, we will get behaviour changes where a constant that gets destructured does <em>not</em> behave like the <code>PartialEq</code> impl. We also need to maintain the current infrastructure for partially taking apart constants until we can't anymore due to <code>!StructuralEq</code> things.</p>",
        "id": 248614986,
        "sender_full_name": "oli",
        "timestamp": 1628258654
    },
    {
        "content": "<p>The compiler can aggressively deconstruct constants to values without caring about <code>StructuralEq</code> in two ways: </p>\n<ol>\n<li>convert to valtree, then to pattern or if conversion failed, fall back to <code>PartialEq</code> and </li>\n<li>deconstruct the constant level by level as far as possible, fall back to <code>PartialEq</code> once not possible, error if no <code>PartialEq</code> impl</li>\n</ol>\n<p>these both have some problems</p>\n<ol>\n<li>has the problem that it falls back to <code>PartialEq</code> even if we could do some partial deconstruction and thus get nicer exhaustiveness handling</li>\n<li>has the problem that we need to keep the allocation based const deconstructor and depending on values of \"as far as possible\", we may change the behaviour when compared to <code>PartialEq</code></li>\n</ol>",
        "id": 248615679,
        "sender_full_name": "oli",
        "timestamp": 1628259015
    },
    {
        "content": "<blockquote>\n<p>We could prevent the PME</p>\n</blockquote>\n<p>strongly believe s/could/should.</p>\n<blockquote>\n<p>The user may have a <code>struct IsJustAnInt(*const i32)</code></p>\n</blockquote>\n<p>uh, i don't like that <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>   I understand why that would work, but having a val tree node of type <code>*const i32</code>, even if it was created using <code>2 as *const i32</code> seems weird.</p>\n<p>But yes, I agree with that summary for const generics <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 248616445,
        "sender_full_name": "lcnr",
        "timestamp": 1628259387
    },
    {
        "content": "<p>ok, so... you say we should validate that the manual impl could have been defined recursively?</p>",
        "id": 248616547,
        "sender_full_name": "oli",
        "timestamp": 1628259442
    },
    {
        "content": "<blockquote>\n<p>We also need to maintain the current infrastructure for partially taking apart constants until we can't anymore due to <code>!StructuralEq</code> things.</p>\n</blockquote>\n<p>not necessarily, do we? If implementing <code>StructuralEq</code> is a proof that the value can be fully converted to a val tree this wouldn't be the case, would it? If we just use <code>PartialEq</code></p>",
        "id": 248616667,
        "sender_full_name": "lcnr",
        "timestamp": 1628259497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248616547\">said</a>:</p>\n<blockquote>\n<p>ok, so... you say we should validate that the manual impl could have been defined recursively?</p>\n</blockquote>\n<p>We should only allow types in constants if the compiler knows that all values of that type are a representable as a val tree. I didn't yet think about how that should work if we only have 1 trait. With 2 traits that feels straightforward</p>",
        "id": 248616793,
        "sender_full_name": "lcnr",
        "timestamp": 1628259583
    },
    {
        "content": "<p>what does PME stand for?</p>",
        "id": 248617010,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259689
    },
    {
        "content": "<p>post monomorphization error</p>",
        "id": 248617024,
        "sender_full_name": "oli",
        "timestamp": 1628259695
    },
    {
        "content": "<p>thanks</p>",
        "id": 248617032,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248606522\">said</a>:</p>\n<blockquote>\n<p>\"breaks the language\" already kind of happens when hash/eq disagree, or when deref is not reliably returning the same thing</p>\n</blockquote>\n<p>to be clear: We don’t require that the relevant traits in these cases are <code>unsafe</code> either, for better or for worse. Right?</p>",
        "id": 248617143,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248616667\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>We also need to maintain the current infrastructure for partially taking apart constants until we can't anymore due to <code>!StructuralEq</code> things.</p>\n</blockquote>\n<p>not necessarily, do we? If implementing <code>StructuralEq</code> is a proof that the value can be fully converted to a val tree this wouldn't be the case, would it? If we just use <code>PartialEq</code></p>\n</blockquote>\n<p>this is option 2 for patterns, which you didn't want, because we have less useful exhaustiveness stuff</p>",
        "id": 248617180,
        "sender_full_name": "oli",
        "timestamp": 1628259754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617143\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248606522\">said</a>:</p>\n<blockquote>\n<p>\"breaks the language\" already kind of happens when hash/eq disagree, or when deref is not reliably returning the same thing</p>\n</blockquote>\n<p>to be clear: We don’t require that the relevant traits in these cases are <code>unsafe</code> either, for better or for worse. Right?</p>\n</blockquote>\n<p>Ralf had an argument for making <code>StructuralEq</code> unsafe, but lcnr and I don't share his view XD And he later admitted we could avoid making <code>StructuralEq</code> unsafe</p>",
        "id": 248617257,
        "sender_full_name": "oli",
        "timestamp": 1628259792
    },
    {
        "content": "<p>Ralf was arguing that <code>Eq</code>, <code>Hash</code>, and <code>Deref</code>/<code>DerefMut</code> should be made <code>unsafe trait</code> ?</p>",
        "id": 248617323,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259835
    },
    {
        "content": "<p>(its definitely a debate that we’ve gone through in the past. I just figured that ship has sailed at this point.)</p>",
        "id": 248617406,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259858
    },
    {
        "content": "<p>no, that was me saying since they aren't unsafe, neither does <code>StructuralEq</code> need to be</p>",
        "id": 248617417,
        "sender_full_name": "oli",
        "timestamp": 1628259864
    },
    {
        "content": "<p>it's not a safety thing</p>",
        "id": 248617430,
        "sender_full_name": "oli",
        "timestamp": 1628259873
    },
    {
        "content": "<p>it's just surprising</p>",
        "id": 248617434,
        "sender_full_name": "oli",
        "timestamp": 1628259877
    },
    {
        "content": "<p>okay. Yes.</p>",
        "id": 248617448,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248616793\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248616547\">said</a>:</p>\n<blockquote>\n<p>ok, so... you say we should validate that the manual impl could have been defined recursively?</p>\n</blockquote>\n<p>We should only allow types in constants if the compiler knows that all values of that type are a representable as a val tree. I didn't yet think about how that should work if we only have 1 trait. With 2 traits that feels straightforward</p>\n</blockquote>\n<p>I thought we only needed two traits to have the shallow <code>StructuralMatch</code> for patterns?</p>",
        "id": 248617522,
        "sender_full_name": "oli",
        "timestamp": 1628259915
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>it is a safety thing, if <code>StructuralEq</code> were an unsafe trait, you could use that knowledge during sorting or something to know that the impl is deterministic :p</p>\n</div></div>",
        "id": 248617525,
        "sender_full_name": "lcnr",
        "timestamp": 1628259915
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617257\">said</a>:</p>\n<blockquote>\n<p>Ralf had an argument for making them unsafe, but lcnr and I don't share his view XD And he later addmitted we could avoid making them unsafe</p>\n</blockquote>\n<p>(the word “them” was and remains unclear to me in the above.)</p>",
        "id": 248617545,
        "sender_full_name": "pnkfelix",
        "timestamp": 1628259922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617545\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617257\">said</a>:</p>\n<blockquote>\n<p>Ralf had an argument for making them unsafe, but lcnr and I don't share his view XD And he later addmitted we could avoid making them unsafe</p>\n</blockquote>\n<p>(the word “them” was and remains unclear to me in the above.)</p>\n</blockquote>\n<p>fixed</p>",
        "id": 248617695,
        "sender_full_name": "oli",
        "timestamp": 1628259976
    },
    {
        "content": "<p>yes, <br>\n<span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617522\">said</a>:</p>\n<blockquote>\n<p>I thought we only needed two traits to have the shallow <code>StructuralMatch</code> for patterns?</p>\n</blockquote>\n<p>that's the reason i started out with 2 traits, but a lot of my recent grumbling about structural equality used these 2 traits. So I figured out how to do it in this case. I don't think that 2 traits are necessary to know that val trees always work, but I know that 2 traits are good enough for that</p>",
        "id": 248617859,
        "sender_full_name": "lcnr",
        "timestamp": 1628260069
    },
    {
        "content": "<blockquote>\n<p>this is option 2 for patterns, which you didn't want, because we have less useful exhaustiveness stuff</p>\n</blockquote>\n<p>yeah, was confused because that sentence was outside of the 2 different ways, so that's more of a formatting complaint</p>",
        "id": 248618039,
        "sender_full_name": "lcnr",
        "timestamp": 1628260158
    },
    {
        "content": "<p>so... all in all, modulo details that we are all flexible on, the question is whether we keep better exhaustiveness errors but also keep the deconstruction of constants, or whether we treat all constants that aren't <em>guaranteed</em> recursively <code>StructuralEq</code> as opaque and thus lose some exhaustivness quality.</p>",
        "id": 248618540,
        "sender_full_name": "oli",
        "timestamp": 1628260401
    },
    {
        "content": "<blockquote>\n<p>has the problem that we need to keep the allocation based const deconstructor</p>\n</blockquote>\n<p>I don't know how much of a pain supporting a partial val tree conversion is. That's something you've implemented. In case it is annoying I don't mind going with your proposal as long as we</p>\n<ul>\n<li>prevent types from being structural eq which have valid values which are not convertable to a val tree</li>\n<li>allow users to manually assert that structural equality can be used without requiring <code>unsafe</code></li>\n</ul>\n<p>i think we (<del>me and</del> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <em>and me</em><span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span>) pretty much agree on the rest already <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 248618607,
        "sender_full_name": "lcnr",
        "timestamp": 1628260438
    },
    {
        "content": "<p>it is somewhat annoying to keep around. There are two queries (deref and destructure), which we don't want anyone to use except for const_to_pat</p>",
        "id": 248618935,
        "sender_full_name": "oli",
        "timestamp": 1628260595
    },
    {
        "content": "<p>valtree duplicates that logic, and it is hard to share stuff between them, but we could share a bit more</p>",
        "id": 248618990,
        "sender_full_name": "oli",
        "timestamp": 1628260632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248613477\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248613365\">said</a>:</p>\n<blockquote>\n<p>but we still have the issue that if your type depend on some other crate, you first have to update that crate to implement <code>StructuralEq</code> for your type</p>\n</blockquote>\n<p>if you implement it without your fields actually having a <code>StructuralEq</code> impl, you are asserting that they are, with all the semver and similar issues that implies</p>\n</blockquote>\n<p>i also don't want to allow this ^^ and with this I am happy with structural equality for the first time since knowing about it</p>",
        "id": 248620832,
        "sender_full_name": "lcnr",
        "timestamp": 1628261586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248612033\">said</a>:</p>\n<blockquote>\n<p>I split this into 2 traits because:</p>\n<ul>\n<li>I want to destructure values as much as possible to get better warnings and code which is easier to optimize</li>\n</ul>\n</blockquote>\n<p>why do you think this will lead to better warnings or code that is easier to optimize?</p>\n<p>we <em>know</em> it will lead to a more complicated rustc (-&gt; more bugs) and more things to learn for users (2 traits). that outweighs the things you list IMO.</p>",
        "id": 248621214,
        "sender_full_name": "RalfJ",
        "timestamp": 1628261814
    },
    {
        "content": "<p><del>what's a \"PME\"?</del></p>",
        "id": 248621358,
        "sender_full_name": "RalfJ",
        "timestamp": 1628261887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617430\">said</a>:</p>\n<blockquote>\n<p>it's not a safety thing<br>\nit's just surprising</p>\n</blockquote>\n<p>surprising quickly leads to unsafety.<br>\nalso if you read my document there I discuss the angle of future compatibility: if we cant enforce requirements on <code>StructuralEq</code> then just adding an <code>impl StrucutralEq for T</code> can change the behavior of existing code without any warning or so. So basically adding that impl becomes a breaking change.</p>",
        "id": 248621786,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262090
    },
    {
        "content": "<blockquote>\n<ul>\n<li>prevent types from being structural eq which have valid values which are not convertable to a val tree</li>\n<li>allow users to manually assert that structural equality can be used without requiring unsafe</li>\n</ul>\n</blockquote>\n<p>I dont like either of that TBH.^^ I think there is a chance to establish a meaningful abstraction here and we should use it. But <code>StructuralEq</code> cant be a meaningful abstraction if it is safe.<br>\nAlso the \"prevent\" part basically means this would be like <code>Copy</code> -- the compiler double-checks that you are not implementing the trait in ways you are not supposed to. But the need for <code>unsafe impl Copy</code> is discussed every now and then. No need to repeat that story here. Sometimes the user needs this control, and I think we should give it to them.</p>",
        "id": 248622177,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248607941\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248607864\">said</a>:</p>\n<blockquote>\n<p>are you suggesting we have two slightly different notions and have to explain both of them to everyone? that's a lot of extra complexity, and I see insufficient benefit from doing so.</p>\n</blockquote>\n<p>my suggestion is <a href=\"https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA\">https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA</a></p>\n</blockquote>\n<p>wow that has 3 traits where I think 1 is enough. oO<br>\nbut I think you and oli made some progress, so did that change?</p>",
        "id": 248622464,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248618935\">said</a>:</p>\n<blockquote>\n<p>it is somewhat annoying to keep around. There are two queries (deref and destructure), which we don't want anyone to use except for const_to_pat</p>\n</blockquote>\n<p>and they are messy, too... I think all of this <a href=\"https://github.com/rust-lang/rust/blob/1f94abcda6884893d4723304102089198caa0839/compiler/rustc_mir/src/const_eval/eval_queries.rs#L119\">try_as_immediate</a> mess is just there to support old-skool const → pat conversion.</p>",
        "id": 248622949,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248621214\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248612033\">said</a>:</p>\n<blockquote>\n<p>I split this into 2 traits because:</p>\n<ul>\n<li>I want to destructure values as much as possible to get better warnings and code which is easier to optimize</li>\n</ul>\n</blockquote>\n<p>why do you think this will lead to better warnings or code that is easier to optimize?</p>\n<p>we <em>know</em> it will lead to a more complicated rustc (-&gt; more bugs) and more things to learn for users (2 traits). that outweighs the things you list IMO.</p>\n</blockquote>\n<p>better warnings: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796</a></p>\n<p>code that is easier to optimize: we can destructure more constants which means we have more stuff which does not call <code>PartialEq</code>(which is opaque for optimizations)</p>\n<blockquote>\n<p>more things to learn for users (2 traits)</p>\n</blockquote>\n<p>I am doubtful that this is necessarily true, 2 simple traits are better than one complex one.</p>",
        "id": 248623015,
        "sender_full_name": "lcnr",
        "timestamp": 1628262688
    },
    {
        "content": "<blockquote>\n<p>better warnings: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796</a></p>\n</blockquote>\n<p>if this uses <code>PartialEq</code> comparison, the 2nd arm actually is reachable with \"evil\" implementations...</p>",
        "id": 248623190,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262760
    },
    {
        "content": "<blockquote>\n<p>code that is easier to optimize: we can destructure more constants which means we have more stuff which does not call PartialEq(which is opaque for optimizations)</p>\n</blockquote>\n<p>it's usually available for inlining. I'm sorry I wont believe this claim without benchmarks. also I think we can find better ways to improve perf here if it is needed; ways that do not introduce extra complexity onto our users.</p>",
        "id": 248623230,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248623190\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>better warnings: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796</a></p>\n</blockquote>\n<p>this uses <code>PartialEq</code> comparison, the 2nd arm actually is reachable with \"evil\" implementations...</p>\n</blockquote>\n<p>no? the first branch is an actual pattern which are always treated as, well, a pattern</p>",
        "id": 248623418,
        "sender_full_name": "lcnr",
        "timestamp": 1628262857
    },
    {
        "content": "<blockquote>\n<p>I am doubtful that this is necessarily true, 2 simple traits are better than one complex one.</p>\n</blockquote>\n<p>it's 1 simple trait though. ;) well that's subjective but you literally also have a <code>StructuralEq</code> trait with, as far as I can say, the same basic semantics. so if your 2 traits are simple then my 1 trait is definitely simple.</p>",
        "id": 248623427,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248623418\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248623190\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>better warnings: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796</a></p>\n</blockquote>\n<p>this uses <code>PartialEq</code> comparison, the 2nd arm actually is reachable with \"evil\" implementations...</p>\n</blockquote>\n<p>no?</p>\n</blockquote>\n<p>sorry I meant to say \"<em>if</em> this uses <code>PartialEq</code> comparison\"</p>",
        "id": 248623454,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262880
    },
    {
        "content": "<p>which I guess it does? for the 2nd field</p>",
        "id": 248623464,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262884
    },
    {
        "content": "<p>since destructuring will fail?</p>",
        "id": 248623476,
        "sender_full_name": "RalfJ",
        "timestamp": 1628262891
    },
    {
        "content": "<p>for the first branch to not get triggered here, no matter what trait <code>Foo</code> implements is a breaking change, isn't it?</p>",
        "id": 248623729,
        "sender_full_name": "lcnr",
        "timestamp": 1628262975
    },
    {
        "content": "<p>I was imagining a <code>impl PartialEq for NonStructuralEq</code> that returns <code>false</code> on the first call and <code>true</code> on the 2nd</p>",
        "id": 248623813,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263020
    },
    {
        "content": "<p>but this match doesn'T care about <code>NonStructuralEq</code> at all?</p>",
        "id": 248623858,
        "sender_full_name": "lcnr",
        "timestamp": 1628263041
    },
    {
        "content": "<p>...?</p>",
        "id": 248623879,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263053
    },
    {
        "content": "<p>it uses a wildcard</p>",
        "id": 248623885,
        "sender_full_name": "lcnr",
        "timestamp": 1628263056
    },
    {
        "content": "<p>well no matter what you do you'll not always be consistent with the <code>PartialEq</code> impl</p>",
        "id": 248624104,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263158
    },
    {
        "content": "<p>so matching needs its completely separate complicated set of rules</p>",
        "id": 248624113,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263167
    },
    {
        "content": "<p>i think non constant patterns are always structural?</p>",
        "id": 248624269,
        "sender_full_name": "lcnr",
        "timestamp": 1628263228
    },
    {
        "content": "<p>i don't think that's changeable</p>",
        "id": 248624284,
        "sender_full_name": "lcnr",
        "timestamp": 1628263238
    },
    {
        "content": "<p>matching against <code>FOO</code> should behave the same as inlining <code>FOO</code> there</p>",
        "id": 248624368,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263285
    },
    {
        "content": "<p>that's the <em>definition</em> of <code>const</code></p>",
        "id": 248624375,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263289
    },
    {
        "content": "<p>it acts as if the definition was inlined everywhere</p>",
        "id": 248624398,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248624375\">said</a>:</p>\n<blockquote>\n<p>that's the <em>definition</em> of <code>const</code></p>\n</blockquote>\n<p><em>simplified definition</em></p>",
        "id": 248624435,
        "sender_full_name": "lcnr",
        "timestamp": 1628263322
    },
    {
        "content": "<p>because it definitely does not act that way</p>",
        "id": 248624508,
        "sender_full_name": "lcnr",
        "timestamp": 1628263337
    },
    {
        "content": "<p>well <a href=\"https://github.com/rust-lang/const-eval/blob/master/const.md\">not simplified by a lot</a></p>",
        "id": 248624556,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263361
    },
    {
        "content": "<p>that's for terms, not patterns, of course</p>",
        "id": 248624604,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263390
    },
    {
        "content": "<p>this compiles</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">NonStructuralEq</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">NonStructuralEq</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(PartialEq)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">other</span>: <span class=\"nc\">NonStructuralEq</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">NonStructuralEq</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">_</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">_</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248624624,
        "sender_full_name": "lcnr",
        "timestamp": 1628263397
    },
    {
        "content": "<p>but IMO the same should be true for patterns</p>",
        "id": 248624636,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263399
    },
    {
        "content": "<p>yes, so? that's just using <code>FOO</code> as a term...?</p>",
        "id": 248624687,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263426
    },
    {
        "content": "<p>you cannot allow the usage of <code>PartialEq</code> for constants in patterns while also requiring constants to behave in the same way as if they were written inline</p>",
        "id": 248624746,
        "sender_full_name": "lcnr",
        "timestamp": 1628263444
    },
    {
        "content": "<p>you can't put <code>_</code> into a const</p>",
        "id": 248624795,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263461
    },
    {
        "content": "<p>so I think you are wrong</p>",
        "id": 248624804,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263465
    },
    {
        "content": "<p>this is not what I am saying</p>",
        "id": 248624849,
        "sender_full_name": "lcnr",
        "timestamp": 1628263495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248623190\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>better warnings: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796</a></p>\n</blockquote>\n<p>if this uses <code>PartialEq</code> comparison, the 2nd arm actually is reachable with \"evil\" implementations...</p>\n</blockquote>\n<p>please reconsider that statement, which is what I am talking about here</p>",
        "id": 248624929,
        "sender_full_name": "lcnr",
        "timestamp": 1628263528
    },
    {
        "content": "<p>your example doesnt demonstrate your claim.<br>\nthis pattern is rightfully rejected: <code>Foo { value: true, other: NonStructuralEq(true) }</code></p>",
        "id": 248624961,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263551
    },
    {
        "content": "<p>that's what inlining <code>FOO</code> would give you</p>",
        "id": 248625027,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263565
    },
    {
        "content": "<p>so we currently cant even compare the two alternatives as one doesnt compile</p>",
        "id": 248625060,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263587
    },
    {
        "content": "<p>this is because there are conflicting expectations -- when you write explicit literals you expect field-by-field matching; when you write a <code>const</code> you might expect <code>PartialEq</code> comparison. When they disagree we have a mess.</p>",
        "id": 248625134,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263633
    },
    {
        "content": "<p>but if we allow (safe) <code>impl StructuralEq</code> then it's very easy for this mess to arise, and that mess can make it very hard to reason about what your code does (which is where safety comes in)</p>",
        "id": 248625570,
        "sender_full_name": "RalfJ",
        "timestamp": 1628263814
    },
    {
        "content": "<p>can we take a step back?</p>",
        "id": 248625668,
        "sender_full_name": "lcnr",
        "timestamp": 1628263858
    },
    {
        "content": "<p>because there is a fundamental misunderstanding here and I don't know where exactly</p>",
        "id": 248625694,
        "sender_full_name": "lcnr",
        "timestamp": 1628263877
    },
    {
        "content": "<ul>\n<li>we want to allow constants in patterns using their <code>PartialEq</code> impl, even if they don't implement <code>StructuralEq</code>. or more accurately, pretty much agreed on that because of backcompat concerns</li>\n</ul>",
        "id": 248625754,
        "sender_full_name": "lcnr",
        "timestamp": 1628263911
    },
    {
        "content": "<ul>\n<li>currently explicit patterns use field-by-field /structural matching</li>\n</ul>",
        "id": 248625969,
        "sender_full_name": "lcnr",
        "timestamp": 1628264004
    },
    {
        "content": "<p>do you want this to compile in the future?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">NonStructuralEq</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">NonStructuralEq</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(PartialEq)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"n\">NonStructuralEq</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"n\">NonStructuralEq</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248626471,
        "sender_full_name": "lcnr",
        "timestamp": 1628264211
    },
    {
        "content": "<hr>\n<blockquote>\n<p>Also the \"prevent\" part basically means this would be like Copy -- the compiler double-checks that you are not implementing the trait in ways you are not supposed to. But the need for unsafe impl Copy is discussed every now and then. No need to repeat that story here. Sometimes the user needs this control, and I think we should give it to them.</p>\n</blockquote>\n<p>No one wants <code>unsafe impl Sized</code> as far as I can tell. :p</p>\n<p>I only want the compiler to prevent things which are known to not/never be valid val trees, e.g. extern types and pointers (ignoring int2ptr casts and what not, because imo we should not not use structural equality in that case). </p>\n<hr>",
        "id": 248628003,
        "sender_full_name": "lcnr",
        "timestamp": 1628264879
    },
    {
        "content": "<p><del>guess we need shallow destructuring anyways</del> (or values which implement <code>StructuralEq</code> but have non val tree values, which afaict is something you want, and i really don't <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> )</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Sum</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Eq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">Eek</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">TheConst</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">UnusedByTheConst</span><span class=\"p\">(</span><span class=\"n\">Sum</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">THE_CONST</span>: <span class=\"nc\">Eek</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Eek</span>::<span class=\"n\">TheConst</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Eek</span>::<span class=\"n\">UnusedByTheConst</span><span class=\"p\">(</span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">THE_CONST</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Hello\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Eek</span>::<span class=\"n\">UnusedByTheConst</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Gbye\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>edit: alright, I am back at my proposal of shallow and deep structural equality, i dislike ralfs notion that a type implementing <code>StructuralEq</code> may have values that are not representable using val trees, as long as all values of that type which can be represented as val trees have a <code>PartialEq</code> impl which agrees with valtree comparisons.</p>",
        "id": 248628706,
        "sender_full_name": "lcnr",
        "timestamp": 1628265149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248622464\">said</a>:</p>\n<blockquote>\n<p>wow that has 3 traits where I think 1 is enough. oO<br>\nbut I think you and oli made some progress, so did that change?</p>\n</blockquote>\n<p>project const generics has some open discussion about requiring some additional explicit opt in to allow your type as a const parameter type so that we don't add some new backcompat hazard there: <a href=\"https://github.com/rust-lang/project-const-generics/issues/6\">https://github.com/rust-lang/project-const-generics/issues/6</a></p>",
        "id": 248629346,
        "sender_full_name": "lcnr",
        "timestamp": 1628265446
    },
    {
        "content": "<p>so that's the reason for the 3rd trait</p>",
        "id": 248629368,
        "sender_full_name": "lcnr",
        "timestamp": 1628265455
    },
    {
        "content": "<p>that one isn't too related to the rest of the structural match discussion</p>",
        "id": 248629395,
        "sender_full_name": "lcnr",
        "timestamp": 1628265471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248621786\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248617430\">said</a>:</p>\n<blockquote>\n<p>it's not a safety thing<br>\nit's just surprising</p>\n</blockquote>\n<p>surprising quickly leads to unsafety.<br>\nalso if you read my document there I discuss the angle of future compatibility: if we cant enforce requirements on <code>StructuralEq</code> then just adding an <code>impl StrucutralEq for T</code> can change the behavior of existing code without any warning or so. So basically adding that impl becomes a breaking change.</p>\n</blockquote>\n<p>do you have a link here? I expected \"my document\" to mean your github summary but wasn't able to figure out what you meant wrt future compatibility. This is already an issue with auto ref specialization and stuff. And yes, when incorrectly implementing <code>StructuralEq</code> you can break some code in rare edge cases, but this shoud pretty much (i might even say will)  never happen.</p>",
        "id": 248629938,
        "sender_full_name": "lcnr",
        "timestamp": 1628265672
    },
    {
        "content": "<blockquote>\n<p>do you want this to compile in the future?</p>\n</blockquote>\n<p>No. But I think it'd be reasonable if the user could add <code>unsafe impl StructuralEq for NonStructuralEq {}</code> and then it compiles.</p>",
        "id": 248631731,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266433
    },
    {
        "content": "<blockquote>\n<p>No one wants unsafe impl Sized as far as I can tell. <span aria-label=\"p\" class=\"emoji emoji-1f17f\" role=\"img\" title=\"p\">:p:</span> </p>\n</blockquote>\n<p>fair. ;) but that's not really the same kind of thing.</p>",
        "id": 248631745,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266441
    },
    {
        "content": "<p>sizedness is inherently syntactic, <code>Copy</code> and <code>StructuralEq</code> are (or at least can be) semantic</p>",
        "id": 248631854,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266482
    },
    {
        "content": "<blockquote>\n<p>i dislike ralfs notion that a type implementing StructuralEq may have values that are not representable using val trees, as long as all values of that type which can be represented as val trees have a PartialEq impl which agrees with valtree comparisons.</p>\n</blockquote>\n<p>that's just one of two very similar alternatives, and it is the one I like less</p>",
        "id": 248631971,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266536
    },
    {
        "content": "<p>the one I prefer is that a type implementing StructuralEq must have all of its values successfully convert to valtrees</p>",
        "id": 248632027,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266561
    },
    {
        "content": "<p>the other one you quoted is just a clutch that could make <code>f32</code>/<code>f64</code> StructuralEq</p>",
        "id": 248632084,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248629395\">said</a>:</p>\n<blockquote>\n<p>that one isn't too related to the rest of the structural match discussion</p>\n</blockquote>\n<p>it seems related though... backcompat hazards apply to patterns as well</p>",
        "id": 248632156,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266622
    },
    {
        "content": "<p>I guess in terms of backcompat it'd have been best if <code>StructuralEq</code> would have to be <code>derive</code>d explicitly</p>",
        "id": 248632225,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266655
    },
    {
        "content": "<blockquote>\n<p>do you have a link here? I expected \"my document\" to mean your github summary but wasn't able to figure out what you meant wrt future compatibility. This is already an issue with auto ref specialization and stuff. And yes, when incorrectly implementing StructuralEq you can break some code in rare edge cases, but this shoud pretty much (i might even say will) never happen.</p>\n</blockquote>\n<p>sorry, I meant <a href=\"https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA\">https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA</a></p>",
        "id": 248632414,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248631731\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>do you want this to compile in the future?</p>\n</blockquote>\n<p>No. But I think it'd be reasonable if the user could add <code>unsafe impl StructuralEq for NonStructuralEq {}</code> and then it compiles.</p>\n</blockquote>\n<p>wait, don't you want the second option for patterns from <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=277e02bb19cf25cea62922b610807484\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=277e02bb19cf25cea62922b610807484</a>?</p>",
        "id": 248632428,
        "sender_full_name": "lcnr",
        "timestamp": 1628266764
    },
    {
        "content": "<blockquote>\n<p>but this shoud pretty much (i might even say will) never happen.</p>\n</blockquote>\n<p>I'd say the same about the code where your better warnings kick in, though ;)</p>",
        "id": 248632464,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266781
    },
    {
        "content": "<p>\"the second option\"?</p>",
        "id": 248632556,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266807
    },
    {
        "content": "<p><a href=\"https://hackmd.io/Zrk3iPzOQDC5kOMC1B34_Q#Pattern-matching-on-constants\">https://hackmd.io/Zrk3iPzOQDC5kOMC1B34_Q#Pattern-matching-on-constants</a> 2.</p>",
        "id": 248632569,
        "sender_full_name": "lcnr",
        "timestamp": 1628266818
    },
    {
        "content": "<p>my preferred option is not on that list</p>",
        "id": 248632617,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266856
    },
    {
        "content": "<p>but it's similar to 2 I think</p>",
        "id": 248632621,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266862
    },
    {
        "content": "<p>it's: check if the type implements <code>StructuralEq</code>, if yes create valtree and proceed, else treat opaquely</p>",
        "id": 248632665,
        "sender_full_name": "RalfJ",
        "timestamp": 1628266889
    },
    {
        "content": "<ol>\n<li>we have a bunch of future compat warnings or even no warning at all, where there is some non structural match type in a const in a pattern.</li>\n</ol>",
        "id": 248632687,
        "sender_full_name": "lcnr",
        "timestamp": 1628266904
    },
    {
        "content": "<ol start=\"2\">\n<li>we can't turn all of those into hard errors (which is why we decided against the third option here afaict)</li>\n</ol>",
        "id": 248632782,
        "sender_full_name": "lcnr",
        "timestamp": 1628266933
    },
    {
        "content": "<ol start=\"3\">\n<li>you don't want this <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248626471\">this</a> to compile</li>\n</ol>",
        "id": 248632884,
        "sender_full_name": "lcnr",
        "timestamp": 1628266979
    },
    {
        "content": "<p>wait sorry</p>",
        "id": 248632979,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267026
    },
    {
        "content": "<p>there's like a bazillion proposals here and what I want is not always what we can get with backcompat in mind ;)</p>",
        "id": 248633078,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267046
    },
    {
        "content": "<p>if the consensus is that we do want to allow constants of non-strucutral-eq types in patterns (because we cant take that back -- did we crater this?), then your example will compile of course. I dont necessarily <em>want</em> this but I guess I have to live with it.^^</p>",
        "id": 248633218,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248632665\">said</a>:</p>\n<blockquote>\n<p>it's: check if the type implements <code>StructuralEq</code>, if yes create valtree and proceed, else treat opaquely</p>\n</blockquote>\n<p>that's exactly option 2</p>",
        "id": 248633225,
        "sender_full_name": "oli",
        "timestamp": 1628267105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248633225\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248632665\">said</a>:</p>\n<blockquote>\n<p>it's: check if the type implements <code>StructuralEq</code>, if yes create valtree and proceed, else treat opaquely</p>\n</blockquote>\n<p>that's exactly option 2</p>\n</blockquote>\n<p>not really, option 2 doesnt involve StrucutralEq at all</p>",
        "id": 248633259,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267119
    },
    {
        "content": "<p>well... the derives imply that</p>",
        "id": 248633301,
        "sender_full_name": "oli",
        "timestamp": 1628267138
    },
    {
        "content": "<p>you are presupposing things about a trait where 3 people have 4 opinions on how and when it should be implementable or derived implicitly^^</p>",
        "id": 248633397,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267165
    },
    {
        "content": "<p>that's why I didn't add the trait</p>",
        "id": 248633468,
        "sender_full_name": "oli",
        "timestamp": 1628267201
    },
    {
        "content": "<p>and mentioned exactly what I mean</p>",
        "id": 248633481,
        "sender_full_name": "oli",
        "timestamp": 1628267206
    },
    {
        "content": "<p>right and that's why there is a (small) difference</p>",
        "id": 248633543,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267227
    },
    {
        "content": "<p>not even the ability to let users stably use <code>StructuralEq</code> at all</p>",
        "id": 248633546,
        "sender_full_name": "oli",
        "timestamp": 1628267231
    },
    {
        "content": "<p>since under my proposal, someone can do <code>unsafe impl StrucutralEq</code> and then it would (try to) cosntruct a valtree, and hard error (PME) if that fails</p>",
        "id": 248633598,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267255
    },
    {
        "content": "<p>sure</p>",
        "id": 248633628,
        "sender_full_name": "oli",
        "timestamp": 1628267270
    },
    {
        "content": "<p>but that is possible in the future with my proposal</p>",
        "id": 248633650,
        "sender_full_name": "oli",
        "timestamp": 1628267281
    },
    {
        "content": "<p>indeed</p>",
        "id": 248633695,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267285
    },
    {
        "content": "<p>there's the obvious variant of my proposal where we dont (yet) allow the user to write <code>unsafe impl StrucutralEq</code></p>",
        "id": 248633774,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267321
    },
    {
        "content": "<p>and then it coincides with one of your proposals I think</p>",
        "id": 248633833,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267349
    },
    {
        "content": "<p>can you edit in your extension as a sub bullet of option 2?</p>",
        "id": 248634326,
        "sender_full_name": "oli",
        "timestamp": 1628267547
    },
    {
        "content": "<p>\"affects exhaustiveness warnings\" it only affects dead arm warnings, right?</p>",
        "id": 248634480,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267609
    },
    {
        "content": "<p>exhaustiveness is a hard error, not a warning...</p>",
        "id": 248634497,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248634326\">said</a>:</p>\n<blockquote>\n<p>can you edit in your extension as a sub bullet of option 2?</p>\n</blockquote>\n<p>done</p>",
        "id": 248634623,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248634480\">said</a>:</p>\n<blockquote>\n<p>\"affects exhaustiveness warnings\" it only affects dead arm warnings, right?</p>\n</blockquote>\n<p>there are no exhaustiveness warnings <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> yes, warnings that an arm is not needed for exhaustiveness</p>",
        "id": 248634693,
        "sender_full_name": "lcnr",
        "timestamp": 1628267698
    },
    {
        "content": "<p>exhaustiveness figures out the dead arm, and then that warns, so yea</p>",
        "id": 248634809,
        "sender_full_name": "oli",
        "timestamp": 1628267751
    },
    {
        "content": "<p>everyone is correct, only I am using the wrong words again <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 248634839,
        "sender_full_name": "oli",
        "timestamp": 1628267762
    },
    {
        "content": "<p>yeah I know the code is shared between exhaustiveness analysis and dead arm warnings</p>",
        "id": 248634890,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267767
    },
    {
        "content": "<p>words are hard. we should stop using them. ;)</p>",
        "id": 248634940,
        "sender_full_name": "RalfJ",
        "timestamp": 1628267788
    },
    {
        "content": "<p>We do not intend to change the behavior or non const patterns here, do we?</p>",
        "id": 248635814,
        "sender_full_name": "lcnr",
        "timestamp": 1628268186
    },
    {
        "content": "<p>because I am still a bit hung up on<br>\n<span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248623190\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>better warnings: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c5c74a76dbe1c2527be6fd3aee1cc796</a></p>\n</blockquote>\n<p>if this uses <code>PartialEq</code> comparison, the 2nd arm actually is reachable with \"evil\" implementations...</p>\n</blockquote>",
        "id": 248635896,
        "sender_full_name": "lcnr",
        "timestamp": 1628268227
    },
    {
        "content": "<p>or wait</p>",
        "id": 248635972,
        "sender_full_name": "lcnr",
        "timestamp": 1628268245
    },
    {
        "content": "<p>aaaaaaaa</p>",
        "id": 248636039,
        "sender_full_name": "lcnr",
        "timestamp": 1628268279
    },
    {
        "content": "<p>god damn it</p>",
        "id": 248636042,
        "sender_full_name": "lcnr",
        "timestamp": 1628268282
    },
    {
        "content": "<p>you are not saying that the first branch ignores <code>value: true</code> if the <code>Foo::partial_eq</code> impl is evil</p>",
        "id": 248636286,
        "sender_full_name": "lcnr",
        "timestamp": 1628268382
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> i still don't fully understand what you mean here <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>.</p>",
        "id": 248636369,
        "sender_full_name": "lcnr",
        "timestamp": 1628268427
    },
    {
        "content": "<p>So, the reason that we don't warn with proposal 2 is that our pattern is actually reachable and calls <code>PartialEq</code> for <code>Foo</code></p>",
        "id": 248636458,
        "sender_full_name": "lcnr",
        "timestamp": 1628268474
    },
    {
        "content": "<p>which the compiler doesn't reason about, so it doesn't know that this pattern doesn't trigger</p>",
        "id": 248636560,
        "sender_full_name": "lcnr",
        "timestamp": 1628268510
    },
    {
        "content": "<p>now, an impl of <code>PartialEq</code> for <code>Foo</code> which does not care about <code>value</code> or might actually cause that branch to be taken</p>",
        "id": 248636620,
        "sender_full_name": "lcnr",
        "timestamp": 1628268543
    },
    {
        "content": "<p>which afaict is what you're saying here</p>",
        "id": 248636645,
        "sender_full_name": "lcnr",
        "timestamp": 1628268561
    },
    {
        "content": "<p>yeah I should have worked this out in more detail, sorry (kind of in a rush and on the road -- or rather, rail -- most of today)</p>",
        "id": 248637443,
        "sender_full_name": "RalfJ",
        "timestamp": 1628268884
    },
    {
        "content": "<p>but I think there's a way to implement <code>PartialEq</code> for <code>Foo</code> that makes the 2nd arm reachable, right?</p>",
        "id": 248637484,
        "sender_full_name": "RalfJ",
        "timestamp": 1628268902
    },
    {
        "content": "<p>absolutely</p>",
        "id": 248637518,
        "sender_full_name": "lcnr",
        "timestamp": 1628268916
    },
    {
        "content": "<p>like, making it always return <code>true</code></p>",
        "id": 248637562,
        "sender_full_name": "RalfJ",
        "timestamp": 1628268939
    },
    {
        "content": "<p>it just wasn't related to what i wanted to say wrt the difference between proposal 1 and 2, so I simply misinterpreted your comment</p>",
        "id": 248637587,
        "sender_full_name": "lcnr",
        "timestamp": 1628268949
    },
    {
        "content": "<p>that impl is even pure and satisfies all the axioms of <code>PartialEq</code>, so its actually entirely reasonable</p>",
        "id": 248637600,
        "sender_full_name": "RalfJ",
        "timestamp": 1628268953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248637587\">said</a>:</p>\n<blockquote>\n<p>it just wasn't related to what i wanted to say wrt the difference between proposal 1 and 2, so I simply misinterpreted your comment</p>\n</blockquote>\n<p>ah okay. multi-layered confusion. fun.^^</p>",
        "id": 248637683,
        "sender_full_name": "RalfJ",
        "timestamp": 1628268982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248632027\">said</a>:</p>\n<blockquote>\n<p>the one I prefer is that a type implementing StructuralEq must have all of its values successfully convert to valtrees</p>\n</blockquote>\n<p>doesn't that one not work because of enums?</p>",
        "id": 248637973,
        "sender_full_name": "lcnr",
        "timestamp": 1628269105
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5d05d4b52be8d04d76ab426eabfd2d2f\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5d05d4b52be8d04d76ab426eabfd2d2f</a></p>",
        "id": 248638020,
        "sender_full_name": "lcnr",
        "timestamp": 1628269121
    },
    {
        "content": "<p>to slowly remove the rest of my remaining confusion wrt patterns</p>",
        "id": 248638096,
        "sender_full_name": "lcnr",
        "timestamp": 1628269160
    },
    {
        "content": "<p>I dont understand what the problem is with that example?</p>",
        "id": 248651254,
        "sender_full_name": "RalfJ",
        "timestamp": 1628275152
    },
    {
        "content": "<p>is it that this should be rejected?</p>",
        "id": 248651315,
        "sender_full_name": "RalfJ",
        "timestamp": 1628275195
    },
    {
        "content": "<p>the match is not exhaustive if the const is treated opaquely</p>",
        "id": 248651377,
        "sender_full_name": "RalfJ",
        "timestamp": 1628275210
    },
    {
        "content": "<p>so yeah this should really be rejected...</p>",
        "id": 248651393,
        "sender_full_name": "RalfJ",
        "timestamp": 1628275217
    },
    {
        "content": "<p>there's not even a warning :(</p>",
        "id": 248651495,
        "sender_full_name": "RalfJ",
        "timestamp": 1628275266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting/near/248651393\">said</a>:</p>\n<blockquote>\n<p>so yeah this should really be rejected...</p>\n</blockquote>\n<p>i think we explicitly worked to not reject that, that's the reason we have a controlflow based structural match check</p>",
        "id": 248654447,
        "sender_full_name": "lcnr",
        "timestamp": 1628276543
    },
    {
        "content": "<p>it would be interesting to have crater results for that, because I don't really know what we can break and what's relied on</p>",
        "id": 248654585,
        "sender_full_name": "lcnr",
        "timestamp": 1628276617
    }
]