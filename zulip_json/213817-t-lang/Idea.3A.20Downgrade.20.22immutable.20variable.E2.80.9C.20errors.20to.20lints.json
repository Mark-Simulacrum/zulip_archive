[
    {
        "content": "<p>From language perspective, it seems the \"immutable variable\" concept is just customary, and it doesn't really bring semantic difference value. I'm curious why these are not deny-by-default lints...</p>",
        "id": 262919037,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638091509
    },
    {
        "content": "<p>If someone disables such a lint, it will likely cause confusion for the reader of the code. This may be used by a malicious entity to it's advantage.</p>",
        "id": 262919102,
        "sender_full_name": "bjorn3",
        "timestamp": 1638091659
    },
    {
        "content": "<p>I think this is the morally right thing to do, but would be a huge violation of ‘social’ backwards compatibility, so it’s impossible to do for rust at this stage.</p>",
        "id": 262919895,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638093120
    },
    {
        "content": "<p>Hmm, I suppose that people who dislike the distinction could mark everything as <code>mut</code>, since that one's just a lint.</p>",
        "id": 262922605,
        "sender_full_name": "scottmcm",
        "timestamp": 1638097551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> What precisely do you mean by \"semantic difference value\"?</p>",
        "id": 262941649,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638124179
    },
    {
        "content": "<p>To me it seems like the same kind of difference as \"you can't mutate through an immutable reference\" or \"you can't just assign a u8 to a u64\". People rely on that kind of distinction.</p>",
        "id": 262941710,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638124234
    },
    {
        "content": "<p>This is about local mutable bindings, not references. Basically, forgetting the <code>mut</code> in <code>let mut x = 0;</code> shouldn't be a hard compiler error (IMO, and others; but it's definitely not a widely held opinion)</p>",
        "id": 262943957,
        "sender_full_name": "isHavvy",
        "timestamp": 1638127325
    },
    {
        "content": "<p>I personally do think it should be, but I'd love to understand why others don't.</p>",
        "id": 262944042,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638127469
    },
    {
        "content": "<p>My usual heuristic for whether something should be deny instead of warn is \"is this something that you need to fix before it's worth bothering to run your unit tests?\".  I can't actually think of a time when they \"hey, you need the <code>mut</code> here\" has caught a bug for me -- in fact, it's the other way around that I can remember helping, as when I put the <code>mut</code> there but forgot to actually modify it I did something more obviously wrong.</p>\n<p>That said, I think this hits my \"look, just fix it; it's not that hard\" heuristic first.  It's a small change, and it's only in one place.  And it's not <em>that</em> hard to usually remember to put it in the first place.  (In <code>let mut sum = 0;</code> and <code>let mut v = vec![];</code> you're very obviously <em>thinking</em> about making an accumulator.)  I think this is especially true now that even without rust-analyser or other RLS integration, relatively-basic text editors can get the structured suggestions from rustc.  Sublime, for example, is very much more a text editor than an IDE, but even it has been able to offer this for years now:<br>\n<a href=\"/user_uploads/4715/EAK_gTZL-mjc8IlZ-vJJtoXG/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/EAK_gTZL-mjc8IlZ-vJJtoXG/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/EAK_gTZL-mjc8IlZ-vJJtoXG/image.png\"></a></div><p>That said, different style might hit this more often.  People more willing to shadow things probably hit this much less.</p>",
        "id": 262946980,
        "sender_full_name": "scottmcm",
        "timestamp": 1638131883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262944042\">said</a>:</p>\n<blockquote>\n<p>I personally do think it should be, but I'd love to understand why others don't.</p>\n</blockquote>\n<p>I could see the rational since one can always <code>let mut var = var;</code> or equivalently, <code>{ var }</code>, to get unlinted access.<br>\nIn the ownership =&gt; unique access =&gt; shared access logic, it could seem weird to have the ownership not grant you the unique access capabilities unless you opt into them (\"Having to opt-in could be opt-out\"). Don't get me wrong, I think we all agree that it should at the very least warn, and given Rust's history, even deny by default. But it being <code>#[allow]</code>able is not a crazy thing either.</p>\n<p>I personally find that a nice example of this friction is when going from <code>f: impl FnOnce()</code> to <code>f: impl FnMut()</code>, for instance, and needing to add <code>mut</code> to the binding of <code>f</code>. Or, similarly, going from <code>f: &amp;mut dyn FnMut()</code> to <code>f: impl FnMut()</code> and, again, requiring that <code>mut</code> on it.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// Error, missing `mut`</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// OK</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"cm\">/* else { { f }() } */</span><span class=\"w\"> </span><span class=\"c1\">// Also OK.</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// where</span>\n<span class=\"k\">fn</span> <span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// OK</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That being said, I agree with <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> that it would be weird, from a social (or \"advertised\", I'd say), point of view, since not mixing mutable w/ immutable, in the grand scheme of things (one conflating owned access with borrowed access), is one of the main <code>trait</code>s of Rust. That is, I'd hate for a beginner to see that <code>let v = vec!{]; v.push(42);</code> triggers an error suggesting, on the one hand, to use <code>let mut v</code>, but on the other hand, that they \"just\" silence the lint with an <code>#[allow()]</code>. That would be a regression, teachability-wise. So if a way to loosen the requirements every once in a while were to be needed, it shouldn't be one suggested by Rust diagnostics, for sure.</p>\n<ul>\n<li>In practice, the only places that may need that kind of generality are macros, and, there, <code>#[allow(unused_mut)] let mut var = ...</code> does the job very well already, as <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> pointed out.</li>\n</ul>\n<p>All this to say that I can see the appeal in the suggestion, and I do agree that <code>mut binding</code> being required for <code>&amp;uniq</code> access is just a lint, conceptually; but we can't <code>#[deny]</code> it's one of the lints at the core of the Rust philosophy, so we can<code>#[allow]</code> for it to be special and remain mandatory <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 262952106,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638138823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262919102\">said</a>:</p>\n<blockquote>\n<p>If someone disables such a lint, it will likely cause confusion for the reader of the code. This may be used by a malicious entity to it's advantage.</p>\n</blockquote>\n<p>Note that <em>some</em> cases could go the other way around:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">allowed</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">password</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">allowed</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">password</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"s\">\"correct one\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">allowed</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// ...</span>\n<span class=\"n\">check</span><span class=\"p\">(</span><span class=\"n\">user_password</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// ...</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">allowed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Do something privileged</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9e2c6deb10e89cde4c473e31b0c9b1f5\">Playground</a></li>\n<li>Although this one would be fixed by explicit closure captures (<code>let allowed = ...; ... move(mut allowed) |p| ...</code></li>\n</ul>\n<p>(Aside: curiously, <code>allowed &amp;= false;</code> and <code>allowed = allowed &amp; false;</code> <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6a38fd453110a254efdd1b15ec193fe5\">don't trigger the same lints</a>?)</p>",
        "id": 262952981,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638140270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262946980\">said</a>:</p>\n<blockquote>\n<p>I can't actually think of a time when they \"hey, you need the <code>mut</code> here\" has caught a bug for me</p>\n</blockquote>\n<p>I occasionally get saved by the \"you need a <code>mut</code>\" error, mostly in deeply nested closures where I've temporarily forgotten what my accumulator variable is because I've named all my variables meaningless single letter names.   If all variables were mutable by default, I'd probably very quickly spotted the bug at runtime, but catching it at compile time is nice.   I also share your experience where the \"you forgot to modify this mutable variable\" is more often useful.</p>\n<p>A question for people who want this error to be a lint:  Do you want this to be a lint so you can turn it into a warning?  Or because you want to suppress it entirely?   (For me personally, I would be OK if this error became a warning, but I think it would be an unpleasant surprise if I found myself working in a code base that disables it entirely)</p>",
        "id": 262954670,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1638142492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span></p>\n<blockquote>\n<p>My usual heuristic for whether something should be deny instead of warn is \"is this something that you need to fix before it's worth bothering to run your unit tests?\"</p>\n</blockquote>\n<p>I think this is a valuable heuristic. I do think \"tried to write to a non-mutable binding\" is something I'd want to fix before running unit tests, but I can understand how it'd be nice to know if your tests pass or fail while still not treating your development as \"done\".</p>",
        "id": 262962333,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638154416
    },
    {
        "content": "<blockquote>\n<p>A question for people who want this error to be a lint: Do you want this to be a lint so you can turn it into a warning? Or because you want to suppress it entirely? </p>\n</blockquote>\n<p>Both. I want to temporarily turn it into a warning, when i'm actively working on a function, and haven't decided whether i will need to mutably borrow it or not yet.</p>\n<p>I want to be able to suppress it together with other <code>unused</code> lints, in a function scope, when the function is obviously unfinished, and has a <code>todo!()</code> in the code.</p>",
        "id": 262965140,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638158690
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> I get why you'd want to suppress the warning for <code>mut</code> not being necessary in unfinished code. Why the reverse? Under what circumstances would having an unnecessary <code>mut</code> naturally happen as part of unfinished code?</p>",
        "id": 262965178,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638158755
    },
    {
        "content": "<p>I'm happy to clear up all warnings before i upload code to github. Just want to reduce struggle when hacking the code.</p>",
        "id": 262965274,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638158875
    },
    {
        "content": "<p>I feel like I might be missing a critical piece of this. How I've read this is that this is a suggestion for when you try to mutate an immutable variable, it would be a lint rather than an error? Wouldn't making it not an error mean that you could ignore immutability?</p>",
        "id": 262965418,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638159067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262965178\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> I get why you'd want to suppress the warning for <code>mut</code> not being necessary in unfinished code. Why the reverse? Under what circumstances would having an unnecessary <code>mut</code> naturally happen as part of unfinished code?</p>\n</blockquote>\n<p>When removing a mutable borrow, for example, commenting out a function call.</p>",
        "id": 262966341,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638160503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252217\">Khionu Sybiern</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262965418\">said</a>:</p>\n<blockquote>\n<p>I feel like I might be missing a critical piece of this. How I've read this is that this is a suggestion for when you try to mutate an immutable variable, it would be a lint rather than an error? Wouldn't making it not an error mean that you could ignore immutability?</p>\n</blockquote>\n<p>Yes, <a href=\"http://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/\">this link</a> provides some dated previous discussions on this topic.</p>",
        "id": 262966507,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638160800
    },
    {
        "content": "<p>Quoting the related parts:</p>\n<blockquote>\n<p>But don’t we need mut for safety?</p>\n</blockquote>\n<blockquote>\n<p>No, we don’t. Rust programs would be equally sound if you just declared all bindings as mut. The compiler is perfectly capable of tracking which locals are being mutated at any point in time – precisely because they are local to the current function. What the type system really cares about is uniqueness.</p>\n</blockquote>\n<blockquote>\n<p>The value I see in the current mut rules, and I won’t deny there is value, is primarily that they help to declare intent. That is, when I’m reading the code, I know which variables may be reassigned. On the other hand, I spend a lot of time reading C++ code too, and to be honest I’ve never noticed this as a major stumbling block. (Same goes for the time I’ve spent reading Java, JavaScript, Python, or Ruby code.)</p>\n</blockquote>",
        "id": 262966579,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638160920
    },
    {
        "content": "<p>This is fascinating. I thought that mutability was essential to Rust's guarantees. If Rust were younger, I might agree with the author, though I do like the idea of reducing the error to a lint.</p>",
        "id": 262969463,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638165005
    },
    {
        "content": "<p>From that article:</p>\n<blockquote>\n<p>One where you have three reference types: &amp;, &amp;uniq, and &amp;mut. (As I wrote, this is in fact the type system we have today, at least from the borrow checker’s point of view.)</p>\n</blockquote>\n<p>Is this still true?  AFAIK it's not, since <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/enum.TyKind.html#variant.Ref\"><code>TyKind::Ref</code></a> is only <code>Mutability::{Mut, Not}</code>.  (Though MIR borrowck could also maintain a third kind itself somehow, maybe?  I just figure it'd exist in the internal type system if it was used, even the user-exposed one didn't have it.)</p>\n<p>The article is also talking about the system at the time being \"an issue\" for unboxed closures, and I wonder if the article predates the FnOnce/Fn/FnMut creation...</p>",
        "id": 262972950,
        "sender_full_name": "scottmcm",
        "timestamp": 1638169612
    },
    {
        "content": "<p>indeed it's a very early article back in 2014. Not meant to reference it as a whole, just provide some background info from it :)</p>",
        "id": 262980340,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638176104
    },
    {
        "content": "<p>For <code>&amp;uniq</code> there's <a href=\"https://doc.rust-lang.org/stable/reference/types/closure.html#unique-immutable-borrows-in-captures\">https://doc.rust-lang.org/stable/reference/types/closure.html#unique-immutable-borrows-in-captures</a> though</p>",
        "id": 262980600,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638176242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262944042\">said</a>:</p>\n<blockquote>\n<p>I personally do think it should be, but I'd love to understand why others don't.</p>\n</blockquote>\n<p>the compiler telling me \"hey you forgot to put mut\" has never saved me, i just add the <code>mut</code> and press Up and Enter in the terminal to restart whatever i wanted to happen. If the compiler just automatically edited the file to change <code>let</code> to <code>let mut</code> any time i didn't have it and tried to change the variable anyway then my rust programming friction would go down.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262941710\">said</a>:</p>\n<blockquote>\n<p>To me it seems like the same kind of difference as \"you can't mutate through an immutable reference\" or \"you can't just assign a u8 to a u64\". People rely on that kind of distinction.</p>\n</blockquote>\n<p>Here I'd like to just reiterate the point that if the compiler simply considered every single <code>let</code> as <code>let mut</code> and didn't warn on unused mut then not a single rust program would become unsound or break in any way at all. It really is just a lint quality check.</p>",
        "id": 263025935,
        "sender_full_name": "Lokathor",
        "timestamp": 1638200928
    },
    {
        "content": "<p>I've definitely had cases where the fix was not \"add mut\". Sometimes the fix has been to remove the mutation (because I realized that I'm not mutating the thing I want to be), or to get rid of a local copy of something and capture a <code>ref mut</code> binding to the original.</p>",
        "id": 263030108,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638202556
    },
    {
        "content": "<p>I've also had those cases, they certainly do exist, but never have I had those cases and tried the other thing before just adding mut first and telling the toolchain to just get on with it.</p>",
        "id": 263032104,
        "sender_full_name": "Lokathor",
        "timestamp": 1638203319
    },
    {
        "content": "<p>I had one of those fairly recently, where mutating the local copy rather than the original would have led to a hard-to-find bug. And not all code has simple testsuites.</p>",
        "id": 263032393,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638203442
    },
    {
        "content": "<p>I'm not arguing that the common case is wrong. In most cases, adding mut is the right answer.</p>",
        "id": 263032449,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638203470
    },
    {
        "content": "<p>so what we clearly need is <code>cargo dothing --mutfix</code> and it'll automatically add mut where necessary</p>",
        "id": 263032697,
        "sender_full_name": "Lokathor",
        "timestamp": 1638203583
    },
    {
        "content": "<p>More seriously, I've often wanted for this and other \"i'm not done shut up already\" type lints such as 'unused' related stuff to all only fire on a cargo publish or on a release build, but leave me alone on debug builds and check builds.</p>",
        "id": 263033335,
        "sender_full_name": "Lokathor",
        "timestamp": 1638203856
    },
    {
        "content": "<p>This is an interesting topic because it's hard (at least for me) to place this diagnostic on the \"correctness vs style\" spectrum.</p>",
        "id": 263033376,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1638203875
    },
    {
        "content": "<p>This is also part of my current processing. I think it might be interesting to try this in practice and see how that goes? But it's a pretty big thing to simply \"try\".</p>",
        "id": 263033873,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638204082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I think I would still want these on a build, but I could see a case for making them warnings if you're building as part of <code>test</code>.</p>",
        "id": 263033998,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638204130
    },
    {
        "content": "<p>I wouldn't want the resulting binary to be in the same place where I could mistake it for a possibly complete one, but I can definitely see the argument for completing the compile if we can guess a resolution and that resolution would make errors go away, and then trying tests. Or at least having an option for that.</p>",
        "id": 263034221,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638204244
    },
    {
        "content": "<p>at the risk of introducing a distracting tangent, I sometimes enjoy the small bits of friction (like \"you're missing a <code>mut</code>) when developing, as it makes me slow down a minute and think about what I'm writing.  I don't mention this to necessarily defend the current behavior, but it's part of the reason why I don't mind it.</p>",
        "id": 263035098,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1638204640
    },
    {
        "content": "<p>Interesting!</p>",
        "id": 263036034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638205081
    },
    {
        "content": "<p>I think I have a similar feeling but for a different reason:</p>",
        "id": 263036136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638205107
    },
    {
        "content": "<p>Having little reminders that the compiler is watching out for me and preventing whole classes of errors makes me feel like I can go <em>faster</em> rather than <em>slower</em>. If you're driving a car with broken seatbelts, you might drive slower because you feel less safe. :)</p>",
        "id": 263036216,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638205150
    },
    {
        "content": "<p>When the compiler doesn't feel like it has my back, it makes me much less comfortable while coding.</p>",
        "id": 263036364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638205203
    },
    {
        "content": "<p>(I write most C code much slower than I write Rust because I feel like I'm constantly doing the compiler's job in my head.)</p>",
        "id": 263036511,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638205231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/263033998\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> I think I would still want these on a build, but I could see a case for making them warnings if you're building as part of <code>test</code>.</p>\n</blockquote>\n<p>stuff i work on nearly never works with <code>test</code> in the first place, so it would need to also work with a dev profile <code>build</code> or i wouldn't even be able to take advantage of the difference.</p>",
        "id": 263039317,
        "sender_full_name": "Lokathor",
        "timestamp": 1638206416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/263032697\">said</a>:</p>\n<blockquote>\n<p>so what we clearly need is <code>cargo dothing --mutfix</code> and it'll automatically add mut where necessary</p>\n</blockquote>\n<p>There's already a structured suggestion that <code>cargo fix</code> <em>could</em> apply, I think it's just not marked \"so obviously the fix that it should be done automatically\" AFAIK.</p>\n<p>Do you not use an editor that has a button or key combination to apply the compiler's suggestion?  (Like I screenshotted in <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262946980\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/262946980</a> )</p>",
        "id": 263065375,
        "sender_full_name": "scottmcm",
        "timestamp": 1638218646
    },
    {
        "content": "<p>I use VS Code and RA but RA is very slow and often just flakes out entirely, so maybe a third or more of my errors i can only see if i actually <code>cargo build</code> in the terminal</p>\n<p>(that is, when editing manically to the point where i care about the 1s slowdown of typing <code>mut</code>, then the terminal-only error ratio goes quite high)</p>",
        "id": 263065797,
        "sender_full_name": "Lokathor",
        "timestamp": 1638218906
    },
    {
        "content": "<p>Actually now that you mention it i also don't think i know how to make the editor apply suggestions, i can't remember ever doing that.</p>",
        "id": 263066284,
        "sender_full_name": "Lokathor",
        "timestamp": 1638219173
    },
    {
        "content": "<p>I don't know if r-a gets in the way of it -- I'm pretty sure I'm not using it.  I think I'm just getting this from an editor plugin that reads the json output from rustc.</p>",
        "id": 263066676,
        "sender_full_name": "scottmcm",
        "timestamp": 1638219371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/263066284\">said</a>:</p>\n<blockquote>\n<p>Actually now that you mention it i also don't think i know how to make the editor apply suggestions, i can't remember ever doing that.</p>\n</blockquote>\n<p>In VSCode, you can put your cursor on the variable declaration and press <code>Ctrl+.</code> and then select the \"make this binding mutable\" action</p>",
        "id": 263087376,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1638232411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/263065797\">said</a>:</p>\n<blockquote>\n<p>I use VS Code and RA but RA is very slow and often just flakes out entirely, so maybe a third or more of my errors i can only see if i actually <code>cargo build</code> in the terminal</p>\n<p>(that is, when editing manically to the point where i care about the 1s slowdown of typing <code>mut</code>, then the terminal-only error ratio goes quite high)</p>\n</blockquote>\n<p>I'd like to hear more about this.   In this manic editing mode, I'm guessing you're just trying to get code from head-to-keyboard as quickly as possible.  My initial thought is:  while editing in this mode, you probably have a bunch of errors (type errors, borrowck errors, typos, etc) that can't be suppressed and that you have to go back to clean-up later.  In practice, do these other errors generally outnumber the \"missing <code>mut</code>\" errors?  Or does \"missing mut\" make up an appreciable portion of those errors?   Or maybe you don't actually make any of these types errors ;)</p>",
        "id": 263088346,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1638232952
    },
    {
        "content": "<p>RA is usually fine on small amounts of stuff, it's large amounts of stuff when trouble starts. Sometimes it'll stop responding in a particular tab or something, at which point I just use <code>cargo watch</code> instead. That it can detect filesystem changes, redo the build, and show the errors in the terminal, all very quickly. but then you're only looking at usually one error at a time because of how huge the ascii diagrams get. So you fix that one thing and wait one build turnaround loop to see the next one thing.</p>",
        "id": 263090307,
        "sender_full_name": "Lokathor",
        "timestamp": 1638234291
    },
    {
        "content": "<p>So, an aspect of this that I think we're not directly asking: how important is immutability-by-default to Rust as a standalone element of the language? I think it's been well demonstrated that we can have all guarantees without it, but immutability does weigh a lot on thinking through a program, with pros and cons.</p>",
        "id": 263092886,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638236903
    },
    {
        "content": "<p>i think that shared references vs unique references are a big huge honking part of the language, but i don't think that mutable and immutable bindings are a big deal at all.</p>",
        "id": 263093583,
        "sender_full_name": "Lokathor",
        "timestamp": 1638237645
    },
    {
        "content": "<p>Wonder if this would be worth a community survey?</p>",
        "id": 263100937,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638246751
    },
    {
        "content": "<p>Like, immutability was a means to an end before this, so it would be good to get a feel for how valued it is.</p>",
        "id": 263101138,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638246983
    },
    {
        "content": "<p>Can you clarify what you mean by \"immutability was a means to an end before this\"?</p>",
        "id": 263102590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638248979
    },
    {
        "content": "<p>I think it has always been a means to an end, but it'd be reasonable to ask \"what end\". I do think it's a property people (including myself) desire as a means of constraining programs to make them easier to reason about.</p>",
        "id": 263102654,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638249034
    },
    {
        "content": "<p>In my mind, it's been more of a requirement of the ownership model</p>",
        "id": 263102686,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638249099
    },
    {
        "content": "<p>So, <code>&amp;mut</code> vs <code>&amp;</code> is definitely part of the ownership model.</p>",
        "id": 263102692,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638249117
    },
    {
        "content": "<p>But to me, <code>mut</code> has never been about the ownership model, any more than <code>const</code> was in C.</p>",
        "id": 263102734,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638249132
    },
    {
        "content": "<p>It's a mechanism to constrain the use of a variable: \"assuming this program compiles, you can safely assume this thing won't get mutated through this binding\".</p>",
        "id": 263102743,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638249174
    },
    {
        "content": "<p>well, except of course that you can't assume that</p>",
        "id": 263106293,
        "sender_full_name": "Lokathor",
        "timestamp": 1638253886
    },
    {
        "content": "<p>because we have so many interior mutability variations</p>",
        "id": 263106314,
        "sender_full_name": "Lokathor",
        "timestamp": 1638253909
    },
    {
        "content": "<p>OK, granted. I'll expand to \"you can safely assume this thing won't get mutated in ways it considers mutation\" then. :)</p>",
        "id": 263106360,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638253945
    },
    {
        "content": "<p>Well, sure, but then we're back to \"you have to pay close attention\"</p>",
        "id": 263106752,
        "sender_full_name": "Lokathor",
        "timestamp": 1638254488
    },
    {
        "content": "<p>I would propose that you would have to pay <em>closer</em> attention if mutability as a distinction didn't exist.</p>",
        "id": 263106928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638254684
    },
    {
        "content": "<p>So it still adds substantial value despite the occasional exception of interior mutability.</p>",
        "id": 263106938,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638254702
    },
    {
        "content": "<p>I can admit that it may have caught a bug a non-zero number of times in my rust programming life</p>",
        "id": 263107040,
        "sender_full_name": "Lokathor",
        "timestamp": 1638254839
    },
    {
        "content": "<p>but i think the false positive rate is north of 98%</p>",
        "id": 263107043,
        "sender_full_name": "Lokathor",
        "timestamp": 1638254852
    },
    {
        "content": "<p>As someone who had comparatively little experience with other programming languages before Rust, little enough that even just a couple years have meant my experience with those other languages has been smothered by my Rust experience, I kinda simply don't have the reflex to write <code>let</code> when I mean <code>let mut</code>: they are distinct operations, in my mind. I also dislike the idea because if I do not miss my guess, it would expand the ways in which <code>let</code> is a special case on an irrefutable pattern match.</p>",
        "id": 263204630,
        "sender_full_name": "Jubilee",
        "timestamp": 1638304531
    },
    {
        "content": "<p>Putting on my someone-who-sometimes-teaches-Rust hat on: The fact that <code>mut</code> is overloaded to mean two different things feels like an unforced error. Explaining ownership/borrowing is complicated enough <em>without</em> this wrinkle. On the other hand, I really like immutable-by-default! Had I been more involved pre-1.0, I might have advocated for a split like <code>let NAME = ...</code> and <code>var NAME = ...</code>.</p>",
        "id": 263205604,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1638305024
    },
    {
        "content": "<p>I also like immutable by default. I just want the option to temporarily opt-out when I'm making experimental changes. I don't consider <code>let mut</code> to be an operation at all. I affix the <code>mut</code> to the binding, not the <code>let</code>. Like, <code>let</code> itself is not a special case since it applies to all patterns.</p>\n<p>But yes, if you feel like it works better for you as an error always, then you can keep it an error.</p>\n<p>On <code>let vs. var</code>, that also doesn't work because the <code>mut</code> affixes to the bindings, not the <code>let</code> (e.g. <code>let (mut x, y) = (1, 2);</code>).</p>",
        "id": 263209503,
        "sender_full_name": "isHavvy",
        "timestamp": 1638306745
    },
    {
        "content": "<p>I mean, I <em>guess</em>.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// (x, y) = 6, 5</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 263212277,
        "sender_full_name": "Jubilee",
        "timestamp": 1638308173
    },
    {
        "content": "<p>So most of my missing mut errors are where the problem is complex and i need to stop and start naming things to keep them clear, then using the thing as the next step maybe mutates it but that information doesn't backflow though my brain so i don't write it down ahead of time and then rust gets grumpy at me and then i get grumpy at rust. In other words, this is only a problem for me in the <em>most</em> complicated of cases, precisely when rust should not be giving me extra problems to try and think about.</p>\n<p>Here's a concrete example that I dealt with just an hour ago: I have some \"pixels\" which is a slice of data i need to iterate in chunks and also i need to mark which chunk number i'm on. Okay let's name that iteration process we're going to do for this line:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">line_it</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">pixels</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">chunks_exact_mut</span><span class=\"p\">(</span><span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">pixel_format</span><span class=\"p\">.</span><span class=\"n\">bytes_per_pixel</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">enumerate</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">r_x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">r_x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Okay, right, now I match on which filter tag that came with this line of pixels and i find which filter is being used this line and for this particular filter say i need to grab one pixel off the front and after that then I'll be comparing pairs of pixels as I go down the line. Okay, so let's get that one pixels.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">reduced_x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a_pixel</span><span class=\"p\">)</span>: <span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">line_it</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Oh, no, sorry! you did it wrong! You didn't put mut on the iterator you named name before! -10 points, interrupt your thought flow, go back and fix it before you can keep working.</p>\n<p>(And then of course it turns out that <code>a_pixel</code> is also supposed to be <code>mut a_pixel</code> too, that's a <code>let</code> moment where you have to put the <code>mut</code> nested in the right spot inside of the pattern, a fun alternate fiddly thing.)</p>\n<p>Dealing with the unimportant fiddly stuff when i'm working on a very picky problem with lots of branching cases, telling me that i need to stop what i'm thinking about and rewind my brain and think about some previous step a second time, it doesn't help me. Every once in a long long while i'd maybe like to be clear to future me that something absolutely doesn't change for the rest of a scope or something, but i'd rather mark that rare case.</p>",
        "id": 263217797,
        "sender_full_name": "Lokathor",
        "timestamp": 1638311137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296643\">isHavvy</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/263209503\">said</a>:</p>\n<blockquote>\n<p>On <code>let vs. var</code>, that also doesn't work because the <code>mut</code> affixes to the bindings, not the <code>let</code> (e.g. <code>let (mut x, y) = (1, 2);</code>).</p>\n</blockquote>\n<p>I imagine that <code>var</code> would become the keyword you affix to bindings. So, in fact, instead of <code>let NAME = ...</code> and <code>var NAME = ...</code> I'd be very happy with <code>let NAME = ...</code> and <code>let var NAME = ...</code>. My particular bone to pick is really just with the overloading of <code>mut</code> to mean two different things.</p>\n<p>(In fact, what would <em>really</em> make me happy is is ditching <code>&amp;mut</code> in favor of <code>&amp;uniq</code>. It takes <em>so</em> much needless mental energy when trying to teach rust to say \"unique reference\" when <code>&amp;mut</code> is what's on the screen. If we did that, I'd be perfectly happy with <code>let mut</code>. Let's not derail this topic with this digression though.)</p>",
        "id": 263234789,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1638323260
    },
    {
        "content": "<p>Is it possible to ban certain <code>allow</code>'s in <a href=\"http://crates.io\">crates.io</a>? Like many here, I think of the missing mut error as \"morally\" a lint, but a top level <code>allow(missing_mut)</code> is very hazardous to code review (whether it was deliberate or not), so I think we should try to limit it to local / unfinished work, and in particular not allow it in published crates.</p>",
        "id": 263235300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638323679
    },
    {
        "content": "<p>I just say variables are functionally guarded by a compiler-controlled RwLock, tbh.<br>\nThis especially jives with NLL semantics, since the \"uniqueness\" of the mutable reference is less clear from reading the text, whereas the control flow (and the implicit idea of \"releasing\" it when \"done\" with it) remains obvious.</p>",
        "id": 263236392,
        "sender_full_name": "Jubilee",
        "timestamp": 1638324693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> since you can publish code that doesn't even build, blocking a publish based on lints seems inconsistent</p>",
        "id": 263237371,
        "sender_full_name": "Lokathor",
        "timestamp": 1638325898
    },
    {
        "content": "<p>at least <code>cargo publish</code> builds... I suppose you mean some way to use the <a href=\"http://crates.io\">crates.io</a> API directly without cargo</p>",
        "id": 263237488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638326022
    },
    {
        "content": "<p>In that case I would modify the suggestion to mean that <code>cargo publish</code> should check for such lints (possibly with override since it's not airtight anyway)</p>",
        "id": 263237592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638326114
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>C:\\Users\\Daniel&gt;cargo publish --help\ncargo.exe-publish\nUpload a package to the registry\n\nUSAGE:\n    cargo.exe publish [OPTIONS]\n\nOPTIONS:\n    -q, --quiet                     No output printed to stdout\n        --index &lt;INDEX&gt;             Registry index URL to upload the package to\n        --token &lt;TOKEN&gt;             Token to use when uploading\n        --no-verify                 Don&#39;t verify the contents by building them\n//...\n</code></pre></div>",
        "id": 263237619,
        "sender_full_name": "Lokathor",
        "timestamp": 1638326152
    },
    {
        "content": "<p>Imo, that's a bit out of scope for this idea</p>",
        "id": 263237669,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638326169
    },
    {
        "content": "<p>uh, well, while I don't like Mario's plan, I think that it's a fair mitigation to ponder while discussing this topic.</p>\n<p>I just don't think it's a mitigation that should be used</p>",
        "id": 263237710,
        "sender_full_name": "Lokathor",
        "timestamp": 1638326227
    },
    {
        "content": "<p>Fair enough. If the crates don't even build then there could be missing mut errors in them already today, so it doesn't make much difference.</p>",
        "id": 263238000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638326550
    },
    {
        "content": "<p>I think the real question is:  \"Should they have to pass <code>--no-verify</code>?\"</p>",
        "id": 263238033,
        "sender_full_name": "Jubilee",
        "timestamp": 1638326623
    },
    {
        "content": "<p>I would assume that most crates on <a href=\"http://crates.io\">crates.io</a> build though, or at least that's my impression, especially considering that crater exists</p>",
        "id": 263238058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638326643
    },
    {
        "content": "<p>i think crater detects when builds/tests go from pass to fail, but I don't know if fail to different fail is tracked.</p>",
        "id": 263238693,
        "sender_full_name": "Lokathor",
        "timestamp": 1638327474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Idea.3A.20Downgrade.20.22immutable.20variable.E2.80.9C.20errors.20to.20lints/near/263237592\">said</a>:</p>\n<blockquote>\n<p>In that case I would modify the suggestion to mean that <code>cargo publish</code> should check for such lints (possibly with override since it's not airtight anyway)</p>\n</blockquote>\n<p><code>cargo publish</code> building with <code>deny(warnings)</code> by default sounds like a nice change to me.  Then there'd just be an <code>--allow-warnings</code> or something like there's <code>--allow-dirty</code> and whatever.  Publish time seems like a good place for a small \"you should have fixed or allowed the warnings before now\" speedbump -- for <em>all</em> warnings.</p>\n<p>(But I agree it's off-topic for this thread.)</p>",
        "id": 263739951,
        "sender_full_name": "scottmcm",
        "timestamp": 1638663844
    },
    {
        "content": "<p>I've been musing on this thread some more, and while I'm still not convinced that downgrading the error is always the right choice, I'm starting to wonder if it's a place where we could tease out a subset.</p>\n<p>The place the <code>mut</code> has always felt the most useless to me is flipping back and forth between <code>f: impl FnMut(T)</code> and <code>mut f: impl FnMut(T)</code> in the function parameter list depending whether I'm calling it or passing it along.</p>\n<p>How have others felt about that one?  Any thoughts whether that's something about <code>FnMut</code> or something about parameters or it's specific to the combination?</p>",
        "id": 263740208,
        "sender_full_name": "scottmcm",
        "timestamp": 1638664262
    },
    {
        "content": "<p>I am not sure how best to demonstrate it, but I have hit similar issues to that <code>FnMut</code> one where I need to write either <code>x: &amp;mut T</code> or <code>mut x: &amp;mut T</code> depending on how I use <code>x</code>, because some operations might need to take <code>&amp;mut x</code> to satisfy a trait bound or if a reborrow is necessary. It has always felt very arbitrary whether rust is going to make me make the binding mutable or not.</p>",
        "id": 263741508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638666383
    },
    {
        "content": "<p>I can generalize on this a little bit actually. The distinction between <code>let x: i32</code> and <code>let mut x: i32</code> is much more useful to me than the distinction between <code>let x: &amp;mut i32</code> and <code>let mut x: &amp;mut i32</code>. I guess this is because, most of the time, when reasoning about mutability in a function local way, changing <code>x</code> is not significantly different from changing <code>*x</code>. Both of those mostly parse as \"<code>x</code> has changed\"</p>",
        "id": 263741948,
        "sender_full_name": "Jake",
        "timestamp": 1638667163
    },
    {
        "content": "<p>Hmm, I think I feel a bit differently there because <code>let mut x: &amp;mut i32</code> to me is a big flashing warning sign that something funky is going on, because repointing a local to a different mutable reference has such intense borrowck consequences.</p>",
        "id": 263742742,
        "sender_full_name": "scottmcm",
        "timestamp": 1638668198
    },
    {
        "content": "<p><code>mut p: Pin&lt;&amp;mut …&gt;</code> so as to be able to <code>p.as_mut()</code>-reborrow would be one of the most churn-heavy ones</p>",
        "id": 263743016,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638668544
    },
    {
        "content": "<p>I'm talking about cases where you aren't actually trying to change the pointer to something else, it just comes up as a side effect of the \"(im)mutability is transitive\" rule. I will have to watch out for real world examples, but here's a toy example showing some of the variations that can come up:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Bar</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">ex1</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// borrows x</span>\n<span class=\"k\">fn</span> <span class=\"nf\">ex2</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">).</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// borrows x</span>\n<span class=\"k\">fn</span> <span class=\"nf\">ex3</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">}.</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// moves x</span>\n<span class=\"k\">fn</span> <span class=\"nf\">ex4</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">}.</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// moves a reborrow of x</span>\n<span class=\"k\">fn</span> <span class=\"nf\">ex5</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">).</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// borrows a reborrow of x</span>\n<span class=\"k\">fn</span> <span class=\"nf\">ex6</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// borrows a reborrow of x</span>\n</code></pre></div>\n<p>I find <code>ex5</code> in particular surprising, but most of them you can understand after a bit of thought. This kind of <code>&amp;mut &amp;mut T</code> thing comes up sometimes when dealing with <code>Write</code> adaptors or when passing <code>FnMut</code> objects into recursive functions, or when you want to reborrow a <code>Option&lt;&amp;mut T&gt;</code> parameter</p>",
        "id": 263743028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638668567
    },
    {
        "content": "<p>Oh, because that trait is taking <code>&amp;mut &amp;mut T</code>?</p>",
        "id": 263744713,
        "sender_full_name": "scottmcm",
        "timestamp": 1638671369
    }
]