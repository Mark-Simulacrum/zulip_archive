[
    {
        "content": "<p>I'm preparing a documentation PR for the stabilization of the naked attribute. The naked attribute RFC requires that a naked function must never be inlined; it characterizes this as an implicit <code>#[inline(never)]</code>. And yet the reference has this note regarding the inline attribute:</p>\n<blockquote>\n<p>Note: #[inline] in every form is a hint, with no requirements on the language to place a copy of the attributed function in the caller.</p>\n</blockquote>\n<p>I think the \"in every form\" bit might be an error, and was probably intended only to apply to every form <em>except</em> <code>#[inline(never)]</code>, but I wanted to make sure. Is <code>#[inline(never)]</code> guaranteed to never inline the function? If so, I'll make a PR fixing this in the reference.</p>",
        "id": 270032604,
        "sender_full_name": "bstrie",
        "timestamp": 1643636666
    },
    {
        "content": "<p>I would think that <code>#[inline(never)]</code> is the exception to the rule. However, it may be possible that operations outside of the control of rustc or llvm may perform the inlining.</p>",
        "id": 270034432,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643637387
    },
    {
        "content": "<p>I don't think inline(never) should guarantee it absolutely never will get inlined.</p>\n<p>Maybe it's worth instead saying what is actually necessary for a naked function, which presumably is that the asm is entered into as-if (roughly) a call instruction had just occurred? It feels weird to define it as \"some optimization did not occur\" to me, rather than positively in terms of what must happen.</p>",
        "id": 270034446,
        "sender_full_name": "simulacrum",
        "timestamp": 1643637391
    },
    {
        "content": "<p>Although that raises the question of what \"a call instruction\" means.</p>",
        "id": 270034558,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643637431
    },
    {
        "content": "<p>Sure, but the same \"what is inlining\" question arises, if you want to guarantee it doesn't happen -- say, if my optimizer knows that the assembly in that naked function has no side effects, can I delete the call? (It could be viewed as a form of inlining)</p>",
        "id": 270034787,
        "sender_full_name": "simulacrum",
        "timestamp": 1643637518
    },
    {
        "content": "<p>Possibly. The asm would need the \"pure\" attribute, because implementations aren't allowed to make assumptions about the content of the asm declaration, beyond the declarations.</p>",
        "id": 270035115,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643637629
    },
    {
        "content": "<p>As specified, the assembly within a naked function disallows the <code>pure</code> option</p>",
        "id": 270036273,
        "sender_full_name": "bstrie",
        "timestamp": 1643638083
    },
    {
        "content": "<p>Ok, so then the compiler can't remove it because the compiler isn't allowed to be smart about the actual contents of the assembly declaration.</p>",
        "id": 270036393,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643638142
    },
    {
        "content": "<p>Whatever the output of this discussion may be, it ought to be relevant w.r.t. stuff such as <a href=\"https://github.com/rustwasm/wasm-bindgen/blob/232d94e6b50975e342f9308684effa99591da845/src/closure.rs#L346-L349\">https://github.com/rustwasm/wasm-bindgen/blob/232d94e6b50975e342f9308684effa99591da845/src/closure.rs#L346-L349</a></p>",
        "id": 270036447,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643638167
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span>)<br>\nI wonder if that snippet ought to have been using an <code>extern</code> declaration, if its purpose is to be hijacked <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> I guess the lack of generic <code>extern</code> is the problem, here, but I could envision that being easier to overcome in some specific scenarios than guaranteeing <em>all</em> the <code>inline(never)</code>s to be enforced;</p>",
        "id": 270036851,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643638328
    },
    {
        "content": "<p>Just wanted to note that this is not possible to guarantee for <code>nvptx64-nvidia-cuda</code> for the rust-cuda project because OptiX (hardware raytracing) requires that all functions be inlined no matter what</p>",
        "id": 270038738,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643639127
    },
    {
        "content": "<p>not that its actually observable because reg vs spilled is not observable in PTX because ptx uses virtual registers and you cannot query the local memory stack pointer</p>",
        "id": 270038878,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643639176
    },
    {
        "content": "<p>But making such a guarantee would be weird when optix is like \"hey, function calls, yeah we don't do that here thanks\"</p>",
        "id": 270038912,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643639197
    },
    {
        "content": "<p><code>#[inline(never)]</code> can't be guaranteed. LLVM propagates information both into (if an argument is always the same LLVM removes the argument and puts the fixed value in the function body) and out of (for example if it is pure, reads memory, writes memory, ...) such functions. This means that LLVM will for example optimize away a call to an <code>#[inline(never)]</code> function if it sees that it is pure and the return value is unused.</p>",
        "id": 270038983,
        "sender_full_name": "bjorn3",
        "timestamp": 1643639225
    },
    {
        "content": "<p>Ah yeah, constant propagation duplicates. Though it still does perform a function call.</p>",
        "id": 270039261,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643639317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/270039261\">said</a>:</p>\n<blockquote>\n<p>Ah yeah, constant propagation duplicates. Though it still does perform a function call.</p>\n</blockquote>\n<p>This is not guaranteed. For example see <a href=\"https://rust.godbolt.org/z/PPb1P9vjj\">https://rust.godbolt.org/z/PPb1P9vjj</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[inline(never)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">add_1_2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">example:</span><span class=\"err\">:</span><span class=\"nl\">add_1_2:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">mov</span><span class=\"w\">     </span><span class=\"no\">al</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">ret</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270039508,
        "sender_full_name": "bjorn3",
        "timestamp": 1643639413
    },
    {
        "content": "<p>LLVM propagated the arguments into the <code>add</code> and then propagated the return value out of the <code>add</code>.</p>",
        "id": 270039588,
        "sender_full_name": "bjorn3",
        "timestamp": 1643639445
    },
    {
        "content": "<p>Hmm... Yay.</p>",
        "id": 270039698,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643639495
    },
    {
        "content": "<p>Calling <code>add</code> with two different sets of arguments will cause calls though. <a href=\"https://rust.godbolt.org/z/T5r3KPq5d\">https://rust.godbolt.org/z/T5r3KPq5d</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[inline(never)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">add_1_2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">add_2_2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">example:</span><span class=\"err\">:</span><span class=\"nl\">add:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">lea</span><span class=\"w\">     </span><span class=\"no\">eax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"no\">rdi</span><span class=\"w\"> </span><span class=\"err\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">ret</span><span class=\"w\"></span>\n\n<span class=\"nl\">example:</span><span class=\"err\">:</span><span class=\"nl\">add_1_2:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">mov</span><span class=\"w\">     </span><span class=\"no\">edi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">jmp</span><span class=\"w\">     </span><span class=\"no\">example</span><span class=\"p\">::</span><span class=\"no\">add</span><span class=\"w\"></span>\n\n<span class=\"nl\">example:</span><span class=\"err\">:</span><span class=\"nl\">add_2_2:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">mov</span><span class=\"w\">     </span><span class=\"no\">edi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">jmp</span><span class=\"w\">     </span><span class=\"no\">example</span><span class=\"p\">::</span><span class=\"no\">add</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270039742,
        "sender_full_name": "bjorn3",
        "timestamp": 1643639515
    },
    {
        "content": "<p>(I swear, if clang breaks any kind of libc the same way...)</p>",
        "id": 270039800,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643639524
    },
    {
        "content": "<p>This seems to only affect pure functions, though, which was established to not apply to <code>#[naked]</code> functions.</p>",
        "id": 270039889,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643639564
    },
    {
        "content": "<p>I think it would be fine to say that naked functions will have their callstack setup as if there was a regular call to them according to the specified abi, but not guarantee that the code is physically not part of the caller.</p>",
        "id": 270040128,
        "sender_full_name": "bjorn3",
        "timestamp": 1643639645
    },
    {
        "content": "<p>Gcc duplicates <code>add</code> if it is called multiple times. It const propagates the arguments into add, but the result not out of add. <a href=\"https://gcc.godbolt.org/z/G4cx7xnf6\">https://gcc.godbolt.org/z/G4cx7xnf6</a></p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">\"stdint.h\"</span><span class=\"cp\"></span>\n\n<span class=\"n\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">noinline</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"k\">static</span><span class=\"w\"> </span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">add_1_2</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">add_2_2</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">add.constprop.0:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">mov</span><span class=\"w\">     </span><span class=\"no\">eax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">ret</span><span class=\"w\"></span>\n<span class=\"nl\">add.constprop.1:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">mov</span><span class=\"w\">     </span><span class=\"no\">eax</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">ret</span><span class=\"w\"></span>\n<span class=\"nl\">add_1_2:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">jmp</span><span class=\"w\">     </span><span class=\"no\">add.constprop.1</span><span class=\"w\"></span>\n<span class=\"nl\">add_2_2:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nf\">jmp</span><span class=\"w\">     </span><span class=\"no\">add.constprop.0</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270040883,
        "sender_full_name": "bjorn3",
        "timestamp": 1643639926
    },
    {
        "content": "<p>Regarding to the naked function though, I think in this case <code>#[inline(never)]</code> (or LLVM noinline) should actually be guaranteed noinline, since optimizer can't see through naked function.</p>",
        "id": 270048146,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643642564
    },
    {
        "content": "<p><code>inline(never)</code> isn't always respected by LLVM, IIRC.  I recall seeing something get inlined despite it when the function is simple enough.</p>",
        "id": 270091819,
        "sender_full_name": "scottmcm",
        "timestamp": 1643657848
    },
    {
        "content": "<p>But yeah, the question has the core problem that what it doesn't isn't \"observable\" in the abstract machine, so defining what it should guarantee is hard.</p>",
        "id": 270091941,
        "sender_full_name": "scottmcm",
        "timestamp": 1643657891
    },
    {
        "content": "<p>There is one situation where inlining has observable side effects: when capturing a backtrace. The <code>backtrace</code> crate  actually relies on this to strip a fixed number of \"internal\" frames from backtraces: <a href=\"https://github.com/rust-lang/backtrace-rs/blob/6b13969dae31b45dd6dd45515f0c326f2bab2de0/src/capture.rs#L138\">https://github.com/rust-lang/backtrace-rs/blob/6b13969dae31b45dd6dd45515f0c326f2bab2de0/src/capture.rs#L138</a></p>",
        "id": 270097526,
        "sender_full_name": "Amanieu",
        "timestamp": 1643660047
    },
    {
        "content": "<p>Regarding naked functions, I would argue that these exist outside of the normal inlining rules anyways. It's impossible for LLVM to inline them anyways since the inline assembly contains a return instruction.</p>",
        "id": 270098043,
        "sender_full_name": "Amanieu",
        "timestamp": 1643660252
    },
    {
        "content": "<p>It could still get tail-call-inlined, right? (instead of a jmp, just append the assembly blob), presuming the caller sets up an as-if fresh stack frame, essentially?</p>",
        "id": 270098337,
        "sender_full_name": "simulacrum",
        "timestamp": 1643660339
    },
    {
        "content": "<p>iow the assembly may not be after the (potentially mangled) symbol name for the function, so to speak</p>",
        "id": 270098423,
        "sender_full_name": "simulacrum",
        "timestamp": 1643660375
    },
    {
        "content": "<p>I suppose that would work if the naked function was only ever called from a single place and its address is never taken. But in that case you probably didn't need a naked function in the first place and could've done the same thing using plain inline asm.</p>",
        "id": 270100025,
        "sender_full_name": "Amanieu",
        "timestamp": 1643661026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/270097526\">said</a>:</p>\n<blockquote>\n<p>There is one situation where inlining has observable side effects: when capturing a backtrace.</p>\n</blockquote>\n<p>I'm using <em>Observable</em> in the spec sense, here -- backtraces are not considered observable in the language definition, because otherwise inlining in general wouldn't be a legal optimization.</p>",
        "id": 270103876,
        "sender_full_name": "scottmcm",
        "timestamp": 1643662844
    },
    {
        "content": "<p>I don't think we should disallow duplicating naked <code>#[inline(never)]</code> functions given that gcc can duplicate <code>#[inline(never)]</code> in certain cases as shown in one of my previous messages.</p>",
        "id": 270106422,
        "sender_full_name": "bjorn3",
        "timestamp": 1643663882
    },
    {
        "content": "<p>That is likely to break some code which exports symbols from a naked function. I'd rather just disallow all optimizations on naked functions: if it turns out to be a problem with LLVM then we can switch to lowering naked functions to <code>global_asm!</code> instead.</p>",
        "id": 270107306,
        "sender_full_name": "Amanieu",
        "timestamp": 1643664244
    },
    {
        "content": "<p>We definitely do duplicate naked functions under some circumstances.</p>",
        "id": 270107659,
        "sender_full_name": "tm",
        "timestamp": 1643664386
    },
    {
        "content": "<p>For example when they are generic, but that seems to hard to avoid regardless.</p>",
        "id": 270107768,
        "sender_full_name": "tm",
        "timestamp": 1643664444
    },
    {
        "content": "<p>Sure, but in that case we would just lower to a separate <code>global_asm!</code> per instantiation.</p>",
        "id": 270108606,
        "sender_full_name": "Amanieu",
        "timestamp": 1643664793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/270107306\">said</a>:</p>\n<blockquote>\n<p>That is likely to break some code which exports symbols from a naked function. I'd rather just disallow all optimizations on naked functions: if it turns out to be a problem with LLVM then we can switch to lowering naked functions to <code>global_asm!</code> instead.</p>\n</blockquote>\n<p>does the global_asm route also address the case where the same crate gets linked in twice under different versions?</p>",
        "id": 270565108,
        "sender_full_name": "bstrie",
        "timestamp": 1643901530
    },
    {
        "content": "<p>We can include the mangled name of the naked function as part of the global asm if the naked function had a mangled name. If not, <code>#[no_mangle]</code> on a regular function would already give problems when trying to link multiple versions.</p>",
        "id": 270566443,
        "sender_full_name": "bjorn3",
        "timestamp": 1643902064
    },
    {
        "content": "<p>would this also suffice to allow named asm labels in naked functions without the risk of collisions?</p>",
        "id": 270581567,
        "sender_full_name": "bstrie",
        "timestamp": 1643907611
    },
    {
        "content": "<p>currently the state of named asm labels in naked functions is a bit confused... a comment in the test at <a href=\"https://github.com/rust-lang/rust/blob/8b7853fe1f87a40ceaddf63aa404817bbfa69676/src/test/ui/asm/named-asm-labels.rs\">https://github.com/rust-lang/rust/blob/8b7853fe1f87a40ceaddf63aa404817bbfa69676/src/test/ui/asm/named-asm-labels.rs</a> suggests that named labels are <em>supposed</em> to work in naked functions, but also in the file there's a test case that ensures that named labels <em>don't</em> work in naked functions</p>",
        "id": 270582623,
        "sender_full_name": "bstrie",
        "timestamp": 1643907943
    },
    {
        "content": "<p>Named labels can break with LTO due to conflicts between crates. For this reason I think they should be allowed for neither naked functions nor regular functions.</p>",
        "id": 270596695,
        "sender_full_name": "bjorn3",
        "timestamp": 1643913415
    },
    {
        "content": "<p>It seems plausble that you could make it work for #[no_mangle] naked functions. But I also don't think it sounds that useful honestly</p>",
        "id": 270648292,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643933888
    },
    {
        "content": "<p>one case where duplication could be problematic is SYS_rseq, which requires you provide the kernel with some addresses and offsets of labels inside some your function (this function basically must be written in assembly in practice). Then, if/when the kernel suspends a thread while its executing, it calls the code located at those labels in certain ways.</p>\n<p>It would be very broken if this was duplicated. I don't really think this would be convenient (an perhaps not even possible) to write as a naked function though, -- I think it would be very hard to get the offsets of the labels inside your function and such to stick in the little descriptor object you need to give to the kernel. so honestly i would do this using global_asm, or an external assembler.</p>",
        "id": 270650749,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643935421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/270098337\">said</a>:</p>\n<blockquote>\n<p>It could still get tail-call-inlined, right? (instead of a jmp, just append the assembly blob), presuming the caller sets up an as-if fresh stack frame, essentially?</p>\n</blockquote>\n<p>would this be okay? asm! explicitly allows code patching and forbids the compiler from assuming these instructions will be executed, so i'm not sure.</p>",
        "id": 270651126,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643935672
    },
    {
        "content": "<p>i guess it might still be okay technically. but it's not that clear to me. i would be too scared to do this if i were a compiler.</p>",
        "id": 270651324,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643935801
    },
    {
        "content": "<p>You can still use numbered labels, just not named ones. Numbered labels should be enough for SYS_rseq, right?</p>",
        "id": 270704110,
        "sender_full_name": "bjorn3",
        "timestamp": 1643975758
    },
    {
        "content": "<p>As the person that wrote that comment it isn't entirely accurate, I was missing some info then. I don't believe the bit about naked functions is entirely true and the comment should mention the other reasons.</p>",
        "id": 270744002,
        "sender_full_name": "asquared31415",
        "timestamp": 1643994628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/270704110\">said</a>:</p>\n<blockquote>\n<p>You can still use numbered labels, just not named ones. Numbered labels should be enough for SYS_rseq, right?</p>\n</blockquote>\n<p>oh, sure. the thing you'd want a named label for is the descriptor object, i think?</p>",
        "id": 270751937,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643998440
    },
    {
        "content": "<p>I wouldn't expect that to be necessary.</p>",
        "id": 270752372,
        "sender_full_name": "bjorn3",
        "timestamp": 1643998629
    },
    {
        "content": "<p>you're probably right, although i don't quite follow. after work i can come up with a snippet that shows what i think is needed, so you can correct me. regardless, i dont really think its a dealbreaker if you cant use really use naked with sys_rseq in practice, since its pretty obscure, and should work fine with global_asm anyway.</p>",
        "id": 270752861,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643998867
    },
    {
        "content": "<p>Continuing the discussion as suggested in <a href=\"https://github.com/rust-lang/rust/issues/90957#issuecomment-1041578558\">https://github.com/rust-lang/rust/issues/90957#issuecomment-1041578558</a>...</p>",
        "id": 272154675,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645034756
    },
    {
        "content": "<p>I'm concerned about allowing naked functions to be inlined. I don't think it is functionality that users want, and believe that it may silently break seemingly valid code. At the very least, it would be good to provide more precise semantics for what is being guaranteed. Since naked functions can observe their own program counter (PC) value, that seems like a good way to define inlining semantics.</p>\n<p>One possible set of guarantees:</p>\n<ol>\n<li>All invocations of a single naked function should start at the same PC.</li>\n<li>That PC should be located within the section specified by `#[link_section].</li>\n<li>And the PC should match the address of the naked function itself, if it is ever taken.</li>\n</ol>",
        "id": 272156990,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645035640
    },
    {
        "content": "<blockquote>\n<p>and believe that it may silently break seemingly valid code.</p>\n</blockquote>\n<p>Like what kind of code? If <code>#[link_section]</code> is used inlining requires both caller and callee to be in the same section anyway afaik. For naked functions without <code>#[link_section]</code> inlining into functions without <code>#[link_section]</code> should be fine. It just has to ensure that the stack and registers are setup as if a call for the specified ABI happens.</p>",
        "id": 272157458,
        "sender_full_name": "bjorn3",
        "timestamp": 1645035845
    },
    {
        "content": "<p>I don't think we can ever guarantee naked functions not being duplicated. If a function is used by an <code>#[inline]</code> function, the function currently gets exported from the crate. It may in some cases be beneficial to instead codegen the function multiple times to not export it. For example not exporting may allow omitting usage of the GOT when calling into the function. Or it may allow the function to not be codegened at all if the <code>#[inline]</code> function is never used.</p>",
        "id": 272157777,
        "sender_full_name": "bjorn3",
        "timestamp": 1645035998
    },
    {
        "content": "<p>Also it seems generic naked functions are accepted. For generic functions it is impossible to prevent duplication. <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=d61607ee17a484bb8f52bf15e9e4259c\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=d61607ee17a484bb8f52bf15e9e4259c</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(naked_functions)]</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[naked]</span><span class=\"w\"></span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">noreturn</span><span class=\"p\">));</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>::<span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code><span class=\"c\">; [...]</span>\n<span class=\"c\">; playground::foo</span>\n<span class=\"c\">; Function Attrs: naked noinline nonlazybind uwtable</span>\n<span class=\"k\">define</span><span class=\"w\"> </span><span class=\"k\">internal</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"vg\">@_ZN10playground3foo17h2eb24d36e2583c01E</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">unnamed_addr</span><span class=\"w\"> </span><span class=\"vg\">#0</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!6</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"nl\">start:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"k\">asm</span><span class=\"w\"> </span><span class=\"k\">sideeffect</span><span class=\"w\"> </span><span class=\"k\">alignstack</span><span class=\"w\"> </span><span class=\"k\">inteldialect</span><span class=\"w\"> </span><span class=\"s\">\"\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"~{dirflag},~{fpsr},~{flags},~{memory}\"</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!14</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">!srcloc</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!15</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">unreachable</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!14</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c\">; playground::foo</span>\n<span class=\"c\">; Function Attrs: naked noinline nonlazybind uwtable</span>\n<span class=\"k\">define</span><span class=\"w\"> </span><span class=\"k\">internal</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"vg\">@_ZN10playground3foo17h62d0bb9f942b39abE</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">unnamed_addr</span><span class=\"w\"> </span><span class=\"vg\">#0</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!16</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"nl\">start:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"k\">asm</span><span class=\"w\"> </span><span class=\"k\">sideeffect</span><span class=\"w\"> </span><span class=\"k\">alignstack</span><span class=\"w\"> </span><span class=\"k\">inteldialect</span><span class=\"w\"> </span><span class=\"s\">\"\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"~{dirflag},~{fpsr},~{flags},~{memory}\"</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!20</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">!srcloc</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!15</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">unreachable</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!20</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c\">; [...]</span>\n</code></pre></div>",
        "id": 272158418,
        "sender_full_name": "bjorn3",
        "timestamp": 1645036284
    },
    {
        "content": "<p>Also, preventing inlining is still impossible on some targets, as noted above.</p>",
        "id": 272159161,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645036649
    },
    {
        "content": "<p>Good point about the generic naked functions, that's an important intended use case</p>",
        "id": 272177023,
        "sender_full_name": "bstrie",
        "timestamp": 1645044923
    },
    {
        "content": "<p>It does suggest that the language in the reference should focus less on \"inlining\" and more on \"duplication\"</p>",
        "id": 272177160,
        "sender_full_name": "bstrie",
        "timestamp": 1645044967
    },
    {
        "content": "<p>since obviously the setting-up-the-callstack concern should go without saying as it's required for correctness and completely out of the user's control</p>",
        "id": 272177295,
        "sender_full_name": "bstrie",
        "timestamp": 1645045038
    },
    {
        "content": "<p>and that the duplication concern applies to all asm in every context, either via asm in any function or asm in generic naked functions or global_asm in LTO'd multi-version-of-the-same-crate projects</p>",
        "id": 272177464,
        "sender_full_name": "bstrie",
        "timestamp": 1645045101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/272157458\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>and believe that it may silently break seemingly valid code.</p>\n</blockquote>\n<p>Like what kind of code? If <code>#[link_section]</code> is used inlining requires both caller and callee to be in the same section anyway afaik. For naked functions without <code>#[link_section]</code> inlining into functions without <code>#[link_section]</code> should be fine. It just has to ensure that the stack and registers are setup as if a call for the specified ABI happens.</p>\n</blockquote>\n<p>Any kind of self modifying code is going to behave very strangely when duplicated. On many architectures reading the program counter is just a matter of <code>lea  rax, [rip]</code>, <code>auipc x1, 0</code> or similar. And once the PC is stored in a general purpose register, there's many ways to have code break if a register's value isn't what the programmer assumed. Another example I can imagine is to perform some potentially trapping instruction in a naked function and assume that the resulting fault will have the address of the function.</p>\n<p>All of these can probably be avoided or worked around. However, having them compile without errors or warnings, while leaving open the possibility of a later compiler version breaking them<br>\n feels like a foot-gun.</p>",
        "id": 272178900,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645045810
    },
    {
        "content": "<p>I didn't realize that generic naked functions were allowed, but given that Rust in general monomorphizes them, that feels like much like opting-in to duplicate versions of your function</p>",
        "id": 272179374,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645046085
    },
    {
        "content": "<p>Comparing function pointers doesn't really work even without inline asm ir inlining. We mark all functions as their address not being relevant in he LLVM ir. This means LLVM is allowed to deduplicate functions. (see for example <a href=\"https://github.com/rust-lang/rust/issues/54685\">#54685</a>)</p>",
        "id": 272179693,
        "sender_full_name": "bjorn3",
        "timestamp": 1645046264
    },
    {
        "content": "<p>As for using a trapping function and then assuming anything about the address of the function 1. how do you know it is in the naked function and not in the function after it? 2. there is an optimization that outlines part of a function (for example cold code), so assuming a function is always contiguous is wrong.</p>",
        "id": 272180042,
        "sender_full_name": "bjorn3",
        "timestamp": 1645046430
    },
    {
        "content": "<p>Surely we can assume that a single asm! block is always contiguous (like would be present in a naked function)?</p>",
        "id": 272180147,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645046485
    },
    {
        "content": "<p>Maybe.</p>",
        "id": 272180253,
        "sender_full_name": "bjorn3",
        "timestamp": 1645046537
    },
    {
        "content": "<p>Self modifying code should probably not be done anyway. The text section is likely readonly, antivirus may trigger on it and it is in general hard to understand. One if the few valid use cases of self modifying code I think is the tracing/live patching infrastructure of the linux kernel, but that works by having all code that can be modified registered in a single section I believe. That works fine even when duplicating functions I assume.</p>",
        "id": 272180705,
        "sender_full_name": "bjorn3",
        "timestamp": 1645046656
    },
    {
        "content": "<p>smc is <em>fun</em>.</p>",
        "id": 272181257,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645046768
    },
    {
        "content": "<p>Another thing against self modifying code. It is relatively slow as it requires flushing the instruction cache.</p>",
        "id": 272181449,
        "sender_full_name": "bjorn3",
        "timestamp": 1645046865
    },
    {
        "content": "<p>There are read-many, write-rarely tradeoffs that can make it valuable. I think the linux kernel has some strategically placed NOPs that can be patched.</p>",
        "id": 272181601,
        "sender_full_name": "The 8472",
        "timestamp": 1645046928
    },
    {
        "content": "<p>Oh, you mentioned that.</p>",
        "id": 272181626,
        "sender_full_name": "The 8472",
        "timestamp": 1645046944
    },
    {
        "content": "<p>I've been imagining that \"do weird stuff in OS kernels\" being one of the main target uses for naked functions</p>",
        "id": 272181644,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645046955
    },
    {
        "content": "<p>JITs too. Java does something similar for polymorphic callsites.</p>",
        "id": 272181686,
        "sender_full_name": "The 8472",
        "timestamp": 1645046979
    },
    {
        "content": "<p>Javascript jits moved away from it for perf reasons I believe.</p>",
        "id": 272181822,
        "sender_full_name": "bjorn3",
        "timestamp": 1645047029
    },
    {
        "content": "<p>Wasn't that more about W^X restrictions?</p>",
        "id": 272181938,
        "sender_full_name": "The 8472",
        "timestamp": 1645047099
    },
    {
        "content": "<p>Yeah, switching away from inline caches had a small but measurable impact on spidermonkey. <a href=\"https://jandemooij.nl/blog/wx-jit-code-enabled-in-firefox/#performance\">https://jandemooij.nl/blog/wx-jit-code-enabled-in-firefox/#performance</a></p>",
        "id": 272182180,
        "sender_full_name": "The 8472",
        "timestamp": 1645047222
    },
    {
        "content": "<p>Anyway, point is that people do these kinds of things in real applications.</p>",
        "id": 272182264,
        "sender_full_name": "The 8472",
        "timestamp": 1645047260
    },
    {
        "content": "<p>Yeah. And I don't know specifically about those cases, but I'd expect many implementations using of self modifying code that wouldn't work so well if a function was modified but later calls to that function invoked a duplicate (unmodified) version instead</p>",
        "id": 272183907,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645048169
    },
    {
        "content": "<p>Maybe naked or inline(never) don't have to guarantee that and another annotation would be needed to tell LLVM that the address of that function matters.</p>",
        "id": 272184134,
        "sender_full_name": "The 8472",
        "timestamp": 1645048277
    },
    {
        "content": "<p>The converse would be making <code>#[naked]</code>default to telling LLVM that the address matters, and if desired, adding a new annotation for naked functions to say that the address doesn't matter</p>",
        "id": 272185154,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645048817
    },
    {
        "content": "<p>that'd be less orthogonal because that annotation then wouldn't be useful on other functions because those already default to that.</p>",
        "id": 272187370,
        "sender_full_name": "The 8472",
        "timestamp": 1645049905
    },
    {
        "content": "<p>agreed that I can imagine use cases for the ability to say \"never duplicate this function, and produce an error if we can't guarantee that will happen for whatever reason\", but also agreed that this feature seems like it could exist as a separate attribute apart from naked functions</p>",
        "id": 272262504,
        "sender_full_name": "bstrie",
        "timestamp": 1645106330
    },
    {
        "content": "<p>I think that would just be ill-formed everywhere.<br>\nI don't believe there's a way to tell either llvm or gcc not to duplicate function callsites.</p>",
        "id": 272264192,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645107056
    },
    {
        "content": "<p>Not sure if it was mentioned before but one of the reasons we have this note in the reference IIRC is because LLVM can look at the body of the function without inlining it and e.g. replace the call with the result of comptime computation anyway (this is an optimization distinct from inlining). Strictly speaking there was no inlining but in practice it is indistinguishable from inlining.</p>",
        "id": 272328850,
        "sender_full_name": "nagisa",
        "timestamp": 1645134455
    },
    {
        "content": "<p>It's one of the reasons I'm pretty against trying to guarantee lack of inlining -- it feels like we're not actually going to succeed at knowing what that means. The 'must have the right call ABI' rule, for example, is something that you can pretty well understand, and seems unlikely to be broken by LLVM.</p>\n<p>It doesn't get into non-duplication though, which I'm not sure we can readily guarantee with LLVM or other backends, personally.</p>",
        "id": 272329620,
        "sender_full_name": "simulacrum",
        "timestamp": 1645134836
    },
    {
        "content": "<p>For NVPTX/CUDA/whatever, the \"all functions are <code>#[inline(always)]</code>\" just means it's de facto incorrect to ever use a <code>#[naked]</code> function on NVPTX that depends on it not being inlined, as <code>#[naked]</code> depends on you writing an <code>unsafe</code> function and calling it correctly to begin with. If you don't know the call ABI of the system you are writing for, you can only write a naked function correctly by blind luck, and if that call ABI says \"lol inline is always\", then that's a rule you get to abide by. It's not Rust's job then, it's yours, we can only try to be friendly about mentioning your name is Sisyphus.</p>\n<p>But if the entire purpose of the RFC is to prevent functions from being inlined or otherwise duplicated, so they definitely are called once and only once every time they are called, and LLVM never promises that it won't const-fold either the naked function or the call to the function, and generic monomorphization is viewed as defeating the \"once and only once\" call rule, and the RFC itself seems to say one of the points is to enable generic monomorphization (or macro expansion), then it seems we are at a loss, honestly. We might want to go back to the drawing board and say \"what are the actual desirables obtained by that promise?\"</p>",
        "id": 272548824,
        "sender_full_name": "Jubilee",
        "timestamp": 1645311729
    },
    {
        "content": "<p>I personally don't think that guaranteeing a lack of duplication is a primary use case for naked functions. Rather, I think it was just something that several people though would be nice to have, if we could have it, but it increasingly seems like we can't. I don't see it as being a blocker for naked functions, especially since this introduces no new problems that don't already exist (either in any other asm contexts in Rust, or in naked functions in other languages)</p>",
        "id": 272605619,
        "sender_full_name": "bstrie",
        "timestamp": 1645378450
    },
    {
        "content": "<p>Also it seems like the only downsides to the lack of this guarantee is that users of certain crates that contain asm with certain properties might get unexpected linker errors in certain contexts/configurations, which may be frustrating but as a failure mode seems neither catastrophic nor especially common</p>",
        "id": 272605717,
        "sender_full_name": "bstrie",
        "timestamp": 1645378589
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 272609985,
        "sender_full_name": "Jubilee",
        "timestamp": 1645383675
    },
    {
        "content": "<p>Don't know that it's generally possible to have it, though.</p>",
        "id": 272610427,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645384222
    },
    {
        "content": "<p>To me, the biggest concern is that there's no checks to see if a naked function is safe to duplicate. This seemingly goes against Rust's stability guarantees: normally you can be reasonably confident that if your code compiles and runs properly, that it will continue to do so in future rustc versions. A naked function that won't link when duplicated (or worse behaves differently at runtime when duplicated!) could work fine with one rustc version but break in the next due to differences in optimization</p>",
        "id": 272619423,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645394392
    },
    {
        "content": "<p>Thus even if only 1% of naked functions would actually rely on the \"no duplication\" feature, all uses benefit because the programmer doesn't have to manually verify whether or not the asm block is impacted</p>",
        "id": 272619611,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1645394501
    },
    {
        "content": "<p>I think we should have an option to codegen all <code>asm!</code> and <code>global_asm!</code> blocks in ways that may break them if they don't follow the rules. That could be by duplicating them, outlining each asm! block outside naked functions, splitting or merging global_asm! blocks across codegen units or other ways.</p>",
        "id": 272620458,
        "sender_full_name": "bjorn3",
        "timestamp": 1645395439
    },
    {
        "content": "<p>A bit like the layout randomization option.</p>",
        "id": 272620473,
        "sender_full_name": "bjorn3",
        "timestamp": 1645395467
    },
    {
        "content": "<blockquote>\n<p>normally you can be reasonably confident that if your code compiles and runs properly, that it will continue to do so in future rustc versions</p>\n</blockquote>\n<p>Sadly when it comes to supporting arbitrary asm, the guarantees start to largely be out of Rust's hands; instead Rust should look to introduce standard APIs that prevent people from needing to resort to asm in common cases (e.g. <code>std::hint::black_box</code>)</p>\n<blockquote>\n<p>or worse behaves differently at runtime when duplicated!</p>\n</blockquote>\n<p>Can you come up with any scenario that exhibits this? Global symbols should just lead to linker errors.</p>\n<blockquote>\n<p>Thus even if only 1% of naked functions would actually rely on the \"no duplication\" feature</p>\n</blockquote>\n<p>Do any other languages with naked functions provide a guarantee that naked functions are not duplicated? I'm curious what kind of experience are causing people to hold this assumption. Currently no asm in Rust makes any no-duplication guarantees.</p>",
        "id": 272718020,
        "sender_full_name": "bstrie",
        "timestamp": 1645465526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/272620473\">said</a>:</p>\n<blockquote>\n<p>A bit like the layout randomization option.</p>\n</blockquote>\n<p>Yes, this sounds like a fun idea</p>",
        "id": 272718035,
        "sender_full_name": "bstrie",
        "timestamp": 1645465537
    },
    {
        "content": "<blockquote>\n<p>Sadly when it comes to supporting arbitrary asm, the guarantees start to largely be out of Rust's hands; instead Rust should look to introduce standard APIs that prevent people from needing to resort to asm in common cases (e.g. std:<span aria-label=\"hint\" class=\"emoji emoji-1f5dd\" role=\"img\" title=\"hint\">:hint:</span>:black_box)</p>\n</blockquote>\n<p>Indeed. This is part of what <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/asm!.20and.20backends</a> was about: asm support can vary wildly.</p>\n<blockquote>\n<p>Do any other languages with naked functions provide a guarantee that naked functions are not duplicated? I'm curious what kind of experience are causing people to hold this assumption. Currently no asm in Rust makes any no-duplication guarantees.</p>\n</blockquote>\n<p>I could not find the documentation from clang or gcc on naked but I remember seeing it previously and IIRC, it didn't make any guarantees about not inlining anything. However, msvc, where the attribute originated actually, has this in it's documentation</p>\n<blockquote>\n<p>The compiler cannot generate an inline function for a function marked with the naked attribute, even if the function is also marked with the __forceinline keyword.</p>\n</blockquote>\n<p><a href=\"https://docs.microsoft.com/en-us/cpp/cpp/naked-cpp?view=msvc-170\">https://docs.microsoft.com/en-us/cpp/cpp/naked-cpp?view=msvc-170</a><br>\nSo there is precedent for naked implying strict noinline.</p>",
        "id": 272719652,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645466572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/is.20inline.28never.29.20guaranteed.3F/near/272718020\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>or worse behaves differently at runtime when duplicated!</p>\n</blockquote>\n<p>Can you come up with any scenario that exhibits this? Global symbols should just lead to linker errors.</p>\n</blockquote>\n<p>A trivial example is a self modifying function that overwrites its own code the first time it is called. Normally, you'd expect the first call to that function to behave one way, and then all subsequent calls to behave differently. But if there are N copies of the function included in the binary, then you can observe up to N calls that behave the original way</p>",
        "id": 273692277,
        "sender_full_name": "Jonathan Behrens",
        "timestamp": 1646161001
    }
]