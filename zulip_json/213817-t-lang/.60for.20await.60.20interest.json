[
    {
        "content": "<p>It seems like there's renewed interest in <code>for await</code> and I'd love to hear more</p>",
        "id": 238517687,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842460
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span></p>",
        "id": 238517709,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842470
    },
    {
        "content": "<p>I think the example being given was that it's nice for writing <code>async gen fn</code>s  that just pass through values from child streams which have been modified somehow?</p>",
        "id": 238517818,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842515
    },
    {
        "content": "<p>That is one case, but it isn't <em>necessary</em> for it</p>",
        "id": 238517918,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842542
    },
    {
        "content": "<p>e.g. you could write a map as <code>async gen { for await x in child { yield x + 1 } }</code></p>",
        "id": 238517932,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842549
    },
    {
        "content": "<p>right, you could do this with a <code>while let Some(x) = child.next().await { ... }</code></p>",
        "id": 238517978,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842572
    },
    {
        "content": "<p>Which I think is true generally of <code>for await</code>'s usage from what I've seen</p>",
        "id": 238518056,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842598
    },
    {
        "content": "<p>For me the main impetus is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?} {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which could be written as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?} {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238518088,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842620
    },
    {
        "content": "<p>so auto-pinning and a more familiar syntax than <code>while let</code>, which is what a naïve programmer trying async/await would do</p>",
        "id": 238518223,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842663
    },
    {
        "content": "<p>Could that be written as <code>for await (a, b) in zip(foo(), bar())</code>, or is there any reason that wouldn't work and you need a separate <code>let</code>?</p>",
        "id": 238518315,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620842704
    },
    {
        "content": "<p>We could instead just _parse_ and suggest the right code</p>",
        "id": 238518317,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842706
    },
    {
        "content": "<p>you can already write that today as </p>\n<div class=\"codehilite\"><pre><span></span><code>   zip(foo(), bar()).for_each(|a, b| async move {\n       println!(&quot;{:?} {:?}&quot;, a, b)\n    }).await;\n</code></pre></div>",
        "id": 238518327,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> yes, it could be, which we can't with the <code>while let</code> version (was trying to keep the changes minimal to compare directly)</p>",
        "id": 238518418,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842750
    },
    {
        "content": "<p>but that is one of the potential benefits</p>",
        "id": 238518432,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> You can write almost any for loop as a <code>for_each</code>, but if you do, you lose the ability to do things like early-return or break or <code>?</code>.</p>",
        "id": 238518469,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620842764
    },
    {
        "content": "<p>or replace <code>Pin::new_unchecked</code> with <code>pin_mut!(s)</code> if you're just saving characters</p>",
        "id": 238518488,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842766
    },
    {
        "content": "<p>i thought the point was more that you didn’t want to have to think about pin in the first place</p>",
        "id": 238518531,
        "sender_full_name": "pnkfelix",
        "timestamp": 1620842785
    },
    {
        "content": "<p><code>pin_mut!</code> is yet another crate people have to learn about it, and it's \"interaction with <code>Pin</code>\", which I'mtrying to minimize</p>",
        "id": 238518587,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842809
    },
    {
        "content": "<p>Suppose the body of the loop is <code>println!(\"{:?} {:?} =&gt; {:?}\", a, b, somefunc(a, b)?)</code>.</p>",
        "id": 238518590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620842810
    },
    {
        "content": "<p>(which it sounds like <code>for_each</code> accomplishes, at other costs)</p>",
        "id": 238518600,
        "sender_full_name": "pnkfelix",
        "timestamp": 1620842813
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I do think that seems to be the trend, but I'm not convinced it's a good idea</p>",
        "id": 238518603,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842815
    },
    {
        "content": "<p>I think people need to learn about and understand <code>Pin</code></p>",
        "id": 238518627,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842825
    },
    {
        "content": "<p>If they're writing async code, they will need to use / interact with it</p>",
        "id": 238518663,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842840
    },
    {
        "content": "<p>I've written a lot of async code over the last year or so. I didn't understand Pin at all (other than conceptually) until very recently, when I read <a href=\"https://fasterthanli.me/articles/pin-and-suffering\">https://fasterthanli.me/articles/pin-and-suffering</a> .</p>",
        "id": 238518752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620842876
    },
    {
        "content": "<p>I dunno, it seems like there is a middle tier audience that could get away with not interacting with it (Pin) if we provided enough sugar</p>",
        "id": 238518762,
        "sender_full_name": "pnkfelix",
        "timestamp": 1620842881
    },
    {
        "content": "<p>For me, seeing <code>Pin</code> in a type was the warning sign for \"you have delved too deep, look for a higher-level function\".</p>",
        "id": 238518913,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620842924
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> Possibly? But I think that's the same audience that I don't want to trick into writing accidentally-serialized code via offering <code>for await</code></p>",
        "id": 238518920,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I think that's bad and that we should work to change that</p>",
        "id": 238518956,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842940
    },
    {
        "content": "<p>People are scared of <code>Pin</code> and there's a culture around it that it's some kind of demon</p>",
        "id": 238518985,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842953
    },
    {
        "content": "<p>I wouldn't go that far. But it's definitely something I didn't understand, and that didn't stop me from writing lots of async code.</p>",
        "id": 238519027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620842970
    },
    {
        "content": "<p>and we need to make it more friendly and welcoming rather than tell people that they've gone down a wrong path</p>",
        "id": 238519033,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620842972
    },
    {
        "content": "<p>there are lots of things in rust that have \"fame\" of being hard to use whether deservedly or not, <code>Pin</code> deserves it</p>",
        "id": 238519062,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620842989
    },
    {
        "content": "<p>(at the very least it seems like we risk Monad:Haskell::Pin:Rust, in terms of perception from outside communty, and perhaps beginners...)</p>",
        "id": 238519084,
        "sender_full_name": "pnkfelix",
        "timestamp": 1620842996
    },
    {
        "content": "<p>not because it is hard on its own, but in how it interacts with the rest of the language</p>",
        "id": 238519132,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620843006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238519084\">said</a>:</p>\n<blockquote>\n<p>(at the very least it seems like we risk Monad:Haskell::Pin:Rust)</p>\n</blockquote>\n<p>\"A Pin is like a burrito\"</p>",
        "id": 238519151,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843014
    },
    {
        "content": "<p>\"learning pin\" here can just be \"know that you need to type .boxed() sometimes\"</p>",
        "id": 238519181,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843026
    },
    {
        "content": "<p>The async ecosystem has done an excellent job of providing higher-level functions that let people use async without thinking about Pin at all.</p>",
        "id": 238519189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238519151\">said</a>:</p>\n<blockquote>\n<p>\"A Pin is like a burrito\"</p>\n</blockquote>\n<p>you may be onto something here...</p>",
        "id": 238519283,
        "sender_full_name": "pnkfelix",
        "timestamp": 1620843071
    },
    {
        "content": "<p>That's great, I guess? That hasn't been at all my experience</p>",
        "id": 238519288,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843076
    },
    {
        "content": "<p>And when I say that Pin was a sign I was looking at the wrong function, I mean things like \"Ah, I don't want to be looking at <code>AsyncRead::poll_read</code>, I want to be looking at <code>AsyncReadExt::read</code>\".</p>",
        "id": 238519315,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843092
    },
    {
        "content": "<p>Every Rust developer using <code>async</code> I've spoken with has some story about \"oh yeah there's this weird pin thing I had to go figure out\"</p>",
        "id": 238519332,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843100
    },
    {
        "content": "<p>Poll was also a sign I was at the wrong level.</p>",
        "id": 238519339,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238519332\">said</a>:</p>\n<blockquote>\n<p>Every Rust developer using <code>async</code> I've spoken with has some story about \"oh yeah there's this weird pin thing I had to go figure out\"</p>\n</blockquote>\n<p>I'm not suggesting we shouldn't fix that, but it isn't \"fixing\" that to say \"let's force everyone to learn Pin sooner\".</p>",
        "id": 238519491,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843159
    },
    {
        "content": "<p>If you never write your own futures or streams by hand, or use <code>select</code>, or use methods like <code>next</code>, then I can see how you would avoid it a lot of the time I  guess?</p>",
        "id": 238519519,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843176
    },
    {
        "content": "<p>I'm not arguing to force people to learn it</p>",
        "id": 238519546,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843192
    },
    {
        "content": "<p>I know you're not. I'm making the point that many people get by <em>without</em> touching it, and that's not a bug.</p>",
        "id": 238519573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843205
    },
    {
        "content": "<p>I'm arguing that adding a language feature that guides people in the wrong direction is not worth it if the payoff is just \"you don't have to write <code>pin_mut!(x)</code> now\"</p>",
        "id": 238519594,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843214
    },
    {
        "content": "<p>In particular, a major use case for generators here would be \"here's a way to write and process streams without thinking about pin\", and it seems like one of your arguments against that is that people <em>could</em> write it if they learn about pin.</p>",
        "id": 238519720,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843256
    },
    {
        "content": "<p>esp. since I think the case that <em>is</em> more ergonomic today (e.g. <code>.for_each_concurrent</code>) is the type of thing we want to point people towards</p>",
        "id": 238519727,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843260
    },
    {
        "content": "<p>Sorry, to clarify, this conversation is not about generators, but about <code>for await</code> syntax</p>",
        "id": 238519776,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843297
    },
    {
        "content": "<p>I think the same argument applies there; <code>for await</code> has the same benefit.</p>",
        "id": 238519831,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843319
    },
    {
        "content": "<p>The two are related, but I think my opinions are being confused: I think we <em>do</em> want generator syntax at some point, but I think we <em>should not ever</em> have <code>for await</code> syntax</p>",
        "id": 238519882,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843340
    },
    {
        "content": "<p>Clarifying question:<br>\n<span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238519594\">said</a>:</p>\n<blockquote>\n<p>I'm arguing that adding a language feature that guides people in the wrong direction is not worth it if the payoff is just \"you don't have to write <code>pin_mut!(x)</code> now\"</p>\n</blockquote>\n<p>By \"wrong direction\" here, you're talking about \"serial rather than parallel\", rather than \"not thinking about pin\"?</p>",
        "id": 238519896,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843348
    },
    {
        "content": "<p>Correct</p>",
        "id": 238519912,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843356
    },
    {
        "content": "<p>Just out of curiosity, doesnt <code>.for_each_concurrent</code> treat a <code>Stream</code> as a <code>Vec&lt;impl Future&gt;</code>?</p>",
        "id": 238519951,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620843364
    },
    {
        "content": "<p>I think that iterating over streams serially is usually the wrong choice</p>",
        "id": 238519965,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> So, on a different note, what do you think of the idea of us having a future <code>parallel for</code> syntax?</p>",
        "id": 238520000,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843385
    },
    {
        "content": "<p>^^ I'm not sure what you mean by <code>Vec&lt;impl Future&gt;</code>, sorry</p>",
        "id": 238520002,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> if we had a native syntax for expressing concurrent async processing of streams, I would be much less concerned about also having <code>for await</code></p>",
        "id": 238520099,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843430
    },
    {
        "content": "<p>/me would love to be able to write (specifics of syntax aside) <code>parallel for x in some_iter { let y = func(x)?; otherfunc(y)?; }</code></p>",
        "id": 238520134,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843453
    },
    {
        "content": "<p>That said, I do think there are a lot of thorny questions around how <code>concurrent for</code> would work (but I'd love to discuss them!)</p>",
        "id": 238520169,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843461
    },
    {
        "content": "<p>It's really painful today to deal with the interaction between iterator combinators and <code>?</code>.</p>",
        "id": 238520241,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843485
    },
    {
        "content": "<p>That sounds really nice, yes!</p>",
        "id": 238520259,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843493
    },
    {
        "content": "<p>Though there're a lot of details (where does the threadpool / task pool come from etc.)</p>",
        "id": 238520289,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843506
    },
    {
        "content": "<p>Oh, <em>absolutely</em>.</p>",
        "id": 238520303,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843513
    },
    {
        "content": "<p>No argument there.</p>",
        "id": 238520317,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843521
    },
    {
        "content": "<p>but yes, if we had that feature then I'd feel much less wary about <code>for await</code></p>",
        "id": 238520347,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843534
    },
    {
        "content": "<p>So, let me ask a different question:</p>",
        "id": 238520408,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843559
    },
    {
        "content": "<p>Many <code>for</code> loops today could be written to go faster using Rayon and <code>.par_iter()</code>. Is it bad that the most natural language syntax is <code>for</code>, which processes things serially?</p>",
        "id": 238520500,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843593
    },
    {
        "content": "<p>Why is <code>for await</code> different than <code>for</code> in this way?</p>",
        "id": 238520571,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843606
    },
    {
        "content": "<p>(other than the inertia of \"we already have <code>for</code> but we don't have <code>for await</code>\")</p>",
        "id": 238520586,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843621
    },
    {
        "content": "<p>If we had <code>while let</code> today, but somehow didn't have <code>for</code> yet, would you argue against adding <code>for</code>?</p>",
        "id": 238520625,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843637
    },
    {
        "content": "<p>Great question! I actually do think there's a significant difference between async and non-async code here</p>",
        "id": 238520670,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843661
    },
    {
        "content": "<p>most of the synchronous code I write is not expected to be long-running or interestingly-blocking</p>",
        "id": 238520864,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843739
    },
    {
        "content": "<p>FWIW, C# recently added <code>IAsyncEnumerable</code> and corresponding <code>await foreach</code>: <a href=\"https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8\">https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8</a></p>",
        "id": 238520879,
        "sender_full_name": "scottmcm",
        "timestamp": 1620843752
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> That's helpful precedent-- do you know how it interacts with folks <code>await</code>ing inside the body of the loop?</p>",
        "id": 238521052,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238520864\">said</a>:</p>\n<blockquote>\n<p>most of the synchronous code I write is not expected to be long-running or interestingly-blocking</p>\n</blockquote>\n<p>That's definitely a difference between our experiences. Much of my synchronous code <em>is</em>, and most of my asynchronous code is more event-driven quick-response.</p>",
        "id": 238521069,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843848
    },
    {
        "content": "<blockquote>\n<p>event-driven quick-response</p>\n</blockquote>\n<p>right, this is exactly the model I\"m talking about: you want things to run concurrently because it's likely that you'll get events spread out over a wide range of time, with not much \"work\" to do in the middle</p>",
        "id": 238521179,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843901
    },
    {
        "content": "<p>Can you say more about that? I feel like your offhand mention of \"<code>await</code>ing inside the body of the loop\" is a critical insight; that's starting to make much more sense.</p>",
        "id": 238521287,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620843944
    },
    {
        "content": "<p>contrasted with synchronous code, which is usually not blocked on external events. it happens sometimes, but certainly the vast majority of the synchronous <code>for</code> loops I've written do not reach out to the internet</p>",
        "id": 238521294,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620843947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238521052\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> That's helpful precedent-- do you know how it interacts with folks <code>await</code>ing inside the body of the loop?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">await</span> <span class=\"nf\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">item</span> <span class=\"k\">in</span> <span class=\"n\">RangeAsync</span><span class=\"p\">(</span><span class=\"m\">10</span><span class=\"p\">,</span> <span class=\"m\">3</span><span class=\"p\">))</span>\n  <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">Write</span><span class=\"p\">(</span><span class=\"n\">item</span> <span class=\"p\">+</span> <span class=\"s\">\" \"</span><span class=\"p\">);</span> <span class=\"c1\">// Prints 10 11 12</span>\n</code></pre></div>\n<p>desugars to</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"n\">IAsyncEnumerator</span><span class=\"p\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">&gt;</span> <span class=\"n\">e</span> <span class=\"p\">=</span> <span class=\"n\">RangeAsync</span><span class=\"p\">(</span><span class=\"m\">10</span><span class=\"p\">,</span> <span class=\"m\">3</span><span class=\"p\">).</span><span class=\"n\">GetAsyncEnumerator</span><span class=\"p\">();</span>\n<span class=\"k\">try</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">MoveNextAsync</span><span class=\"p\">())</span> <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">Write</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">Current</span> <span class=\"p\">+</span> <span class=\"s\">\" \"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"k\">finally</span> <span class=\"p\">{</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">e</span> <span class=\"p\">!=</span> <span class=\"k\">null</span><span class=\"p\">)</span> <span class=\"k\">await</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">DisposeAsync</span><span class=\"p\">();</span> <span class=\"p\">}</span>\n</code></pre></div>\n<p>and <code>await e</code> in the body is part of the same state machine.</p>",
        "id": 238521299,
        "sender_full_name": "scottmcm",
        "timestamp": 1620843951
    },
    {
        "content": "<p>oh, sorry, to clarify, I mean if there were an <code>await Console.Write(...);</code></p>",
        "id": 238521453,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> Would it be accurate to say your biggest concern here is that if the body of the loop has an <code>await</code>, you want multiple iterations to be waiting in parallel rather than in series?</p>",
        "id": 238521524,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Yeah, the <code>.await</code> in the body of the loop is the critical reason why I don't want <code>for await</code>-- (or possibly I want a version which always lints on an <code>.await</code> in its body?).</p>",
        "id": 238521528,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844044
    },
    {
        "content": "<p>^^ right, if I'm iterating over an async stream of websites to <code>GET</code> request from, I want to make each <code>GET</code> request as soon as the website name is available</p>",
        "id": 238521628,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844084
    },
    {
        "content": "<p>I don't want to wait for the <code>GET</code> request for the previous website to finish before I start on the next element</p>",
        "id": 238521693,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238521453\">said</a>:</p>\n<blockquote>\n<p>oh, sorry, to clarify, I mean if there were an <code>await Console.Write(...);</code></p>\n</blockquote>\n<p>Then it'd be</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">MoveNextAsync</span><span class=\"p\">())</span> <span class=\"p\">{</span> <span class=\"k\">await</span> <span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteAsync</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">Current</span> <span class=\"p\">+</span> <span class=\"s\">\" \"</span><span class=\"p\">);</span> <span class=\"p\">}</span>\n</code></pre></div>\n<p>(and yes, it wouldn't pull the next thing from the async iterator until the body finished.)</p>",
        "id": 238521695,
        "sender_full_name": "scottmcm",
        "timestamp": 1620844100
    },
    {
        "content": "<p>So, I definitely agree that's an issue. I also think it's an issue in <em>most</em> async code. I'd love to not have to write <code>join</code> or similar to be able to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xv</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">yv</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">xv</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">yv</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238521787,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> ah, okay, shucks-- I was hoping maybe there was something clever. I'd be curious to hear user reports about the feature (positive or negative) especaily if they mention that</p>",
        "id": 238521843,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844156
    },
    {
        "content": "<p>I'd love to be able to automatically translate that into a graph-based parallel execution that awaits <code>x()</code> and <code>y()</code> in parallel before running <code>func</code>.</p>",
        "id": 238521848,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that sounds fancy!</p>",
        "id": 238521879,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844173
    },
    {
        "content": "<p>I've seen research languages that could do exactly that.</p>",
        "id": 238521923,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844188
    },
    {
        "content": "<p>Dependency graphs from seemingly linear control-flow.</p>",
        "id": 238521944,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844196
    },
    {
        "content": "<p>Oh yeah, I think it's possible, and it seems like the kind of thing I would like, but I don't quite know how to make it work in Rust today</p>",
        "id": 238522023,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844212
    },
    {
        "content": "<p>I'd love to chat more about that idea</p>",
        "id": 238522032,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844217
    },
    {
        "content": "<p>If you ignore the issue of side effects, it's really straightforward. :)</p>",
        "id": 238522033,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844217
    },
    {
        "content": "<p>lol</p>",
        "id": 238522047,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844223
    },
    {
        "content": "<p>And one way to ignore the issue of side-effects is to let the programmer <em>tell</em> you that they don't care if things run in parallel.</p>",
        "id": 238522101,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844243
    },
    {
        "content": "<p>Rust is already way better than C# for that, actually, since <code>let (xy, yv) = join!(x(), y()).await;</code> works.</p>\n<p>(The C# version of <code>join!</code> is <code>Task.WhenAll</code>, which isn't variadic so is a pain to use if the futures return non-unit.)</p>",
        "id": 238522139,
        "sender_full_name": "scottmcm",
        "timestamp": 1620844261
    },
    {
        "content": "<p>So, rather than (or in addition to) <code>parallel for</code>, I'd love to have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">parallel</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xv</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">yv</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">xv</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">yv</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238522211,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844287
    },
    {
        "content": "<p>that sounds cool!</p>",
        "id": 238522260,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844302
    },
    {
        "content": "<p>And because it appears in a <code>parallel</code> block, you're <em>telling</em> the compiler that it's allowed to run anything in parallel that doesn't have a data dependency.</p>",
        "id": 238522281,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844310
    },
    {
        "content": "<p>That would be the moral equivalent of rising <code>join!</code> to a lang construct, right?</p>",
        "id": 238522388,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1620844335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> That plus compiler-assisted data-dependency analysis, yeah.</p>",
        "id": 238522436,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844354
    },
    {
        "content": "<p>also to super nitpick: I think we're talking about concurrency, not parallelism in the <code>async</code> case</p>",
        "id": 238522456,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> Heh. I completely understand that nitpick, but I'd also say that it's the job of your async runtime to make sure your concurrent code <em>is</em> parallel whenever doing so would be a performance improvement. ;)</p>",
        "id": 238522633,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> oh but that's an important distinction here! whether or not the code runs as part of the current async task vs. spawning a new task</p>",
        "id": 238522765,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844455
    },
    {
        "content": "<p><code>.for_each_concurrent</code> does not spawn new tasks</p>",
        "id": 238522811,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844469
    },
    {
        "content": "<p>it executes within the current task, concurrently</p>",
        "id": 238522826,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844479
    },
    {
        "content": "<p>so you will get concurrency, but not parallelism</p>",
        "id": 238522841,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844486
    },
    {
        "content": "<p>That is, generally speaking, almost never going to be what I want. :)</p>",
        "id": 238522899,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844507
    },
    {
        "content": "<p>Interesting! Do you feel the same way about <code>join!</code>? (that it isn't what you want?)</p>",
        "id": 238523018,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844550
    },
    {
        "content": "<p>or <code>select</code> or any of the other \"do two things at once\" primitives that don't spawn separate tasks</p>",
        "id": 238523140,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844585
    },
    {
        "content": "<p>With respect to <code>join!</code>, what I more often feel is \"I should really use join, but I'm not going to bother, because it's much easier to just write straight-line code that runs <code>.await</code> repeatedly\".</p>",
        "id": 238523150,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844589
    },
    {
        "content": "<p>But to answer your actual question: I <em>wish</em> that I didn't have to make the distinction, and that I could more transparently run things in parallel.</p>",
        "id": 238523305,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844652
    },
    {
        "content": "<p>It's interesting to me that your use-case doesn't care about whether or not tasks run concurrently, but you would care that they run in parallel?</p>",
        "id": 238523336,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844669
    },
    {
        "content": "<p>Something I was doing in C# the other day:</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">await</span> <span class=\"nf\">using</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">tracker</span> <span class=\"p\">=</span> <span class=\"k\">new</span> <span class=\"n\">TaskTracker</span><span class=\"p\">(</span><span class=\"n\">Concurrency</span><span class=\"p\">))</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"kt\">var</span> <span class=\"n\">entry</span> <span class=\"k\">in</span> <span class=\"n\">fileNames</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">await</span> <span class=\"n\">tracker</span><span class=\"p\">.</span><span class=\"n\">TrackAsync</span><span class=\"p\">(</span><span class=\"n\">ProcessSingleEntry</span><span class=\"p\">(</span><span class=\"n\">entry</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Delegating the \"finish waiting on everything\" to the <code>IAsyncDisposable</code>, and <code>TrackAsync</code> only blocks when there are \"too many\" futures running already, to avoid one such loop starving others.  (And would be fine if the loop were <code>await foreach</code>.)</p>\n<p>But that's of course way easier in C# where tasks run in the background and everything is always boxed so types aren't an issue either :P</p>\n<p>How does one do that kind of thing in Rust today, Taylor?</p>",
        "id": 238523419,
        "sender_full_name": "scottmcm",
        "timestamp": 1620844687
    },
    {
        "content": "<p>I didn't say I don't care, I said that I sometimes can't be bothered until a profile tells me that I should bother, because it's syntactically noisy. :)</p>",
        "id": 238523420,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844687
    },
    {
        "content": "<p>For some of my async code, there's enough complexity there already that simplicity is more important than concurrency.</p>",
        "id": 238523527,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844741
    },
    {
        "content": "<p>oh interesting-- I think we have very different defaults there</p>",
        "id": 238523555,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844748
    },
    {
        "content": "<p>This is a recent development for me: <a href=\"https://mobile.twitter.com/josh_triplett/status/1316634750669344768\">https://mobile.twitter.com/josh_triplett/status/1316634750669344768</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://mobile.twitter.com/josh_triplett/status/1316634750669344768\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/0e87f45dbbd509b633dff4f4364ee0d54a2ef45e/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313136303234393937303231353039363332312f61367873334f6f475f6e6f726d616c2e6a7067\"></a><p>I love TWiR's quote of the week this week: \"Just because Rust allows you to write super cool non-allocating zero-copy algorithms safely, doesn’t mean every algorithm you write should be super cool, zero-copy and non-allocating.\"\n\nThis resonates with me in <a href=\"https://twitter.com/rustlang\">@rustlang</a> lately. 🧵 <a href=\"https://t.co/0X2jIMXbbG\">https://twitter.com/ThisWeekInRust/status/1316600316356247554</a></p><span>- Josh Triplett (@josh_triplett)</span></div></div>",
        "id": 238523737,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> <code>FuturesUnordered</code> is the building block for all of that kind of thing today. You can append futures to it, and it will act as a stream of all the results as they are available</p>",
        "id": 238523752,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844829
    },
    {
        "content": "<p>that's how <code>.for_each_concurrent(MAX_NUMBER_OF_CONCURRENT_TASKS, |item| async move { ... }).await</code> works</p>",
        "id": 238523814,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> So, how today would you write the equivalent of <code>for_each_parallel</code>?</p>",
        "id": 238523887,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> you mean how would I write that <code>for-each_concurrent</code> loop, but with the children actually running in separate tasks?</p>",
        "id": 238523945,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> I want to ask that question slightly more generally, because \"separate tasks\" is an implementation detail. How would you write that if you want to make sure they <em>can</em> take advantage of a multi-core CPU?</p>",
        "id": 238524046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620844952
    },
    {
        "content": "<p>where \"can take advantage of\" means \"the bodies of my loop can run on multiple cores at once\"</p>",
        "id": 238524137,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620844995
    },
    {
        "content": "<p>Yes, precisely.</p>",
        "id": 238524151,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845003
    },
    {
        "content": "<p>I'd use <code>spawn_with_handle</code> inside the bodies of the <code>for_each_concurrent</code></p>",
        "id": 238524186,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845022
    },
    {
        "content": "<p><a href=\"https://docs.rs/futures/0.3.15/futures/task/trait.SpawnExt.html#method.spawn_with_handle\">https://docs.rs/futures/0.3.15/futures/task/trait.SpawnExt.html#method.spawn_with_handle</a></p>",
        "id": 238524201,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845029
    },
    {
        "content": "<p>(Was just searching for that.)</p>",
        "id": 238524277,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845054
    },
    {
        "content": "<p>(or whatever the version is for <code>tokio</code> or <code>async-std</code> or whatever I'm using-- these APIs are all duplicated all over the place like crazy right now, which makes this all a mess)</p>",
        "id": 238524284,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845056
    },
    {
        "content": "<p>Yeah, I'd really love to see some of the common bits standardized at this point, but that's another topic.</p>",
        "id": 238524322,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845071
    },
    {
        "content": "<p>So, effectively, you'd have a bunch of bits of the <em>same</em> task running concurrently, that are each awaiting values from separate tasks running in parallel?</p>",
        "id": 238524438,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845121
    },
    {
        "content": "<p>Yes</p>",
        "id": 238524481,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845138
    },
    {
        "content": "<p>I think that's roughly how I'd have written it as well, modulo spelling <code>spawn_with_handle</code> as <a href=\"https://docs.rs/smol/1.2.5/smol/fn.unblock.html\"><code>unblock</code></a> iff I'm doing non-trivial computation as well.</p>",
        "id": 238524710,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845216
    },
    {
        "content": "<p>Though in practice, I rarely care that these loops run in parallel when I'm writing async code: non-blocking is much more important to my uses of <code>async</code> than \"this loop body must be able to run on multiple CPUs at once\"</p>",
        "id": 238524712,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> yes, there's a difference between how you'd treat CPU-blocking code, for sure</p>",
        "id": 238524813,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845256
    },
    {
        "content": "<p>My <code>async</code> usages have rarely involved CPU-intensive code</p>",
        "id": 238524869,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845277
    },
    {
        "content": "<p>I generally find that I'm mixing both in one program.</p>",
        "id": 238524987,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845311
    },
    {
        "content": "<p>Or rather, CPU-intensive code was always delegated to a separate blocking pile of code in a separate module or something</p>",
        "id": 238525030,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845328
    },
    {
        "content": "<p>^^ interesting</p>",
        "id": 238525044,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238525030\">said</a>:</p>\n<blockquote>\n<p>Or rather, CPU-intensive code was always delegated to a separate blocking pile of code in a separate module or something</p>\n</blockquote>\n<p>Right, that doesn't tend to be the case for me.</p>",
        "id": 238525071,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845346
    },
    {
        "content": "<p>I also currently have some cases where I'm mixing threads with async code, the former for blocking and the latter for non-blocking.</p>",
        "id": 238525123,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845367
    },
    {
        "content": "<p>Yeah, it sounds like <code>unblock</code> is what you'd want in those cases, then</p>",
        "id": 238525189,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845396
    },
    {
        "content": "<p>It's been really useful to me that <code>flume</code> has both sync and async versions of its send and recv functions.</p>",
        "id": 238525197,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845400
    },
    {
        "content": "<p>I sometimes have a thread calling <code>send</code> and a task calling <code>recv_async</code>.</p>",
        "id": 238525283,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845417
    },
    {
        "content": "<p>but still <code>for_each_concurrent(... unblock...)</code>, not <code>for_each(...unblock...)</code></p>",
        "id": 238525292,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845419
    },
    {
        "content": "<p>Right, that makes sense.</p>",
        "id": 238525327,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845429
    },
    {
        "content": "<p>Okay, I've gotta hop off for now, but thanks for chatting-- this was interesting!</p>",
        "id": 238525393,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620845455
    },
    {
        "content": "<p>Likewise!</p>",
        "id": 238525419,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620845464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238520571\">said</a>:</p>\n<blockquote>\n<p>Why is <code>for await</code> different than <code>for</code> in this way?</p>\n</blockquote>\n<p>The other piece I'd add to this is whether <code>for.await</code> being not what you want (because it should use <code>.for_each_concurrent</code>) is substantially different from <code>let x = x().await; let y = y().await;</code> being not what (because it should use <code>join!</code>).</p>\n<p>It seems to me like <code>.await</code> is pretty blatantly \"behave non-concurrently for _this_ function\", and thus that happening for the loop as well is par for the course, even if it's sometimes (or often) not what's actually wanted.</p>",
        "id": 238525701,
        "sender_full_name": "scottmcm",
        "timestamp": 1620845592
    },
    {
        "content": "<p>I started a thread for <code>parallel { ... }</code> at <a href=\"#narrow/stream/213817-t-lang/topic/parallel.2Fconcurrent.20blocks.20for.20async\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/parallel.2Fconcurrent.20blocks.20for.20async</a> .</p>",
        "id": 238529604,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620847153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60for.20await.60.20interest/near/238521923\">said</a>:</p>\n<blockquote>\n<p>I've seen research languages that could do exactly that.</p>\n</blockquote>\n<p>also with Simon Marlow's Haxl in Haskell (e.g. <a href=\"https://youtu.be/sT6VJkkhy0o?t=805\">https://youtu.be/sT6VJkkhy0o?t=805</a>)</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"sT6VJkkhy0o\" href=\"https://youtu.be/sT6VJkkhy0o?t=805\"><img src=\"https://uploads.zulipusercontent.net/efdbb5c7c8fcc55eda5f44c441305f9dd40c86af/68747470733a2f2f692e7974696d672e636f6d2f76692f735436564a6b6b6879306f2f64656661756c742e6a7067\"></a></div>",
        "id": 238531358,
        "sender_full_name": "lqd",
        "timestamp": 1620848006
    },
    {
        "content": "<blockquote>\n<p>It seems to me like .await is pretty blatantly \"behave non-concurrently for _this_ function\", and thus that happening for the loop as well is par for the course, even if it's sometimes (or often) not what's actually wanted.</p>\n</blockquote>\n<p>It's possible that folks would intuit that behavior correctly, but it might not occur to them why it isn't actually the thing that they want. I think we should try to design APIs that push folks to think about which version they want (<code>for await</code> vs. <code>for await concurrent</code> or whatever), rather than offering an easy, more discoverable built-in language feature for the option that (I think) is less likely to be what users want.</p>",
        "id": 238541298,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620852219
    },
    {
        "content": "<p>It's possible that a common option would be to <code>for await</code> with a body that is just a <code>task_pool.push(async move { ... });</code>, and we would recommend that as a pattern, but I personally think that is less ergonomic than <code>my_stream.for_each_concurrent(...)</code>.</p>",
        "id": 238541488,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620852302
    },
    {
        "content": "<p>^ <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span></p>",
        "id": 238541523,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620852316
    },
    {
        "content": "<p>Of course, we also still have to deal with the separate question of syntax and <code>?</code>-handling</p>",
        "id": 238541968,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1620852498
    },
    {
        "content": "<p>I think, unfortunately, that</p>\n<blockquote>\n<p>but it might not occur to them why it isn't actually the thing that they want.</p>\n</blockquote>\n<p>is just part of <code>await</code>.  It's not uncommon at all for me to give PR feedback saying things like \"you probably don't want <code>(await FooAsync(), await BarAsync())</code>\".  So I'm not sure this is really a <em>new</em> problem to <code>for.await</code>.</p>",
        "id": 238547512,
        "sender_full_name": "scottmcm",
        "timestamp": 1620854990
    }
]