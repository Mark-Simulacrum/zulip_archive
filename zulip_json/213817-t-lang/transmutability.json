[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> recently touched based with me about next steps for a transmutability RFC. This proposal is the result of that conversation: <a href=\"https://jswrenn.github.io/transmutation-foundation\">https://jswrenn.github.io/transmutation-foundation</a></p>",
        "id": 225921653,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1612996204
    },
    {
        "content": "<p>iirc <code>Neglect { &lt;field&gt;: &lt;value&gt;, ..v }</code> doesn't work outside the local crate when <code>Neglect</code> is <code>#[non_exhaustive]</code></p>",
        "id": 225922748,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612996773
    },
    {
        "content": "<p>In the auditing chapter, the use of <code>transmute!(v, Neglect { validity })</code> should be <code>unsafe</code>, right?</p>",
        "id": 225923988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612997467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> That new proposal looks good to me! The const <code>Neglect</code> in particular I think is a nice change</p>",
        "id": 225924706,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1612997809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/225922748\">said</a>:</p>\n<blockquote>\n<p>iirc <code>Neglect { &lt;field&gt;: &lt;value&gt;, ..v }</code> doesn't work outside the local crate when <code>Neglect</code> is <code>#[non_exhaustive]</code></p>\n</blockquote>\n<p>I noticed that. Is that limitation just an over-zealous lint? There isn't any stability hazard there that I can see.</p>",
        "id": 225924998,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1612997959
    },
    {
        "content": "<p>functional update syntax should work even for non_exhaustive</p>",
        "id": 225926775,
        "sender_full_name": "Lokathor",
        "timestamp": 1612998916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/225924998\">said</a>:</p>\n<blockquote>\n<p>I noticed that. Is that limitation just an over-zealous lint? There isn't any stability hazard there that I can see.</p>\n</blockquote>\n<p>This is the classic \"FRU doesn't work like everyone expects\".</p>\n<p>The desugar moves all the fields that aren't mentioned, and <code>non_exhaustive</code> doesn't promise that those will be public.</p>",
        "id": 225927371,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999235
    },
    {
        "content": "<p>oh, just impl Copy on the type then?</p>",
        "id": 225927477,
        "sender_full_name": "Lokathor",
        "timestamp": 1612999301
    },
    {
        "content": "<p>I don't think that fixes it.  Copy can still have private fields.</p>",
        "id": 225927566,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999345
    },
    {
        "content": "<p>but update syntax should work even with private fields. shouldn't it? That's how the raw-window-handle crate works</p>",
        "id": 225927688,
        "sender_full_name": "Lokathor",
        "timestamp": 1612999431
    },
    {
        "content": "<p>(For example, it can be copy but maintain in invariant between the private field and the public one, which could be violated by FRU)</p>",
        "id": 225927753,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999448
    },
    {
        "content": "<p>No, FRU syntax doesn't work with inaccessible fields.</p>",
        "id": 225927767,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999467
    },
    {
        "content": "<p>If it did, you could <code>Vec { .. }</code> in safe code for a double-free.</p>",
        "id": 225927810,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999484
    },
    {
        "content": "<p>i... what. but there is not a source there</p>",
        "id": 225927852,
        "sender_full_name": "Lokathor",
        "timestamp": 1612999512
    },
    {
        "content": "<p>Sorry, I meant <code>Vec { ..v }</code>.</p>",
        "id": 225927876,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999526
    },
    {
        "content": "<p>ah, Hmm.</p>",
        "id": 225928026,
        "sender_full_name": "Lokathor",
        "timestamp": 1612999606
    },
    {
        "content": "<p>I'd definitely like to see someone pick up changing the desugaring as an edition change, though.  People seem continually surprised by it.</p>",
        "id": 225928066,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999627
    },
    {
        "content": "<p>Here's a macro that does what you probably wish FRU does: <a href=\"https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/7?u=scottmcm\">https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/7?u=scottmcm</a></p>",
        "id": 225928096,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999652
    },
    {
        "content": "<p>Might also work to add <code>const fn</code> builder functions for <code>Neglect</code> for each field.</p>",
        "id": 225928136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1612999677
    },
    {
        "content": "<p>Could also check where Esteban is on their RFC (<a href=\"https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/75?u=scottmcm\">https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/75?u=scottmcm</a>)</p>",
        "id": 225928310,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999753
    },
    {
        "content": "<p>Since that's about <code>Neglect { alignment: true, .. }</code>.</p>\n<p>Though I guess that doesn't solve the <code>non_exhaustive</code> problem</p>",
        "id": 225928352,
        "sender_full_name": "scottmcm",
        "timestamp": 1612999792
    },
    {
        "content": "<p>i guess the problem is that the source value isn't forgotten</p>",
        "id": 225928502,
        "sender_full_name": "Lokathor",
        "timestamp": 1612999870
    },
    {
        "content": "<p>Is the example here right? I think as written it's not sound under any formulation, <a href=\"https://jswrenn.github.io/transmutation-foundation/unresolved-src-visibility.html\">https://jswrenn.github.io/transmutation-foundation/unresolved-src-visibility.html</a></p>\n<p>The example and its name make more sense as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">as_bytes</span><span class=\"o\">&lt;'</span><span class=\"na\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">t</span> <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">t</span> <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">T</span>: <span class=\"nc\">upstream</span>::<span class=\"n\">POD</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"p\">{</span><span class=\"n\">slice</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">size_of</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or something like, that, rather than going fromf &amp;T to a slice of size_of::&lt;T&gt;() T's in a function named as_bytes</p>",
        "id": 225928866,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613000090
    },
    {
        "content": "<p>Whoops, yep, as-written that snippet is a compile error. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 225929204,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613000283
    },
    {
        "content": "<p>it may also be worth considering a multi-trait approach rather than a const generics approach- e.g. a trait for each individual property, plus trait aliases for \"check everything\" and \"check everything except _\"</p>",
        "id": 225931086,
        "sender_full_name": "rpjohnst",
        "timestamp": 1613001427
    },
    {
        "content": "<p>that also naturally solves the ordering stuff (traits were essentially designed to do that, even more so than structs) but doesn't hit <code>non_exhaustive</code> problems.</p>",
        "id": 225931134,
        "sender_full_name": "rpjohnst",
        "timestamp": 1613001466
    },
    {
        "content": "<p>the tradeoff would be that you can no longer be generic over different values for <code>Neglect</code></p>",
        "id": 225931516,
        "sender_full_name": "rpjohnst",
        "timestamp": 1613001713
    },
    {
        "content": "<p>The <code>#[non_exhaustive] + FRU</code> issue strikes me as a minor ergonomic hiccup with a lot of possible resolutions. We <em>could</em> do nothing about it (you can start with <code>Neglect::NOTHING</code> and just set fields one-by-one), or resolve it with the builder pattern, or a macro, or even something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">NOTHING</span>: <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">alignment</span><span class=\"w\">   </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lifetimes</span><span class=\"w\">   </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">validity</span><span class=\"w\">    </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">visibility</span><span class=\"w\">  </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ALIGNMENT</span>:  <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">alignment</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"bp\">Self</span>::<span class=\"n\">Nothing</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LIFETIMES</span>:  <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">lifetimes</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"bp\">Self</span>::<span class=\"n\">Nothing</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LIFETIMES</span>:  <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">validity</span>:  <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"bp\">Self</span>::<span class=\"n\">Nothing</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VISIBILITY</span>: <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">validity</span>:  <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"bp\">Self</span>::<span class=\"n\">Nothing</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">alignment</span><span class=\"w\">   </span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">alignment</span><span class=\"w\">  </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">alignment</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">lifetimes</span><span class=\"w\">   </span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">lifetimes</span><span class=\"w\">  </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">lifetimes</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">validity</span><span class=\"w\">    </span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">validity</span><span class=\"w\">   </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">validity</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">visibility</span><span class=\"w\">  </span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">visibility</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">visibility</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...which would allow you to write, e.g., <code>Neglect::ALIGNMENT + Neglect::VALIDITY</code>. I think that's looks even nicer than FRU.</p>",
        "id": 225932570,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613002449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> That seems reasonable.</p>",
        "id": 225932929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613002751
    },
    {
        "content": "<p>Another possibility would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">NOTHING</span>: <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">alignment</span><span class=\"w\">   </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lifetimes</span><span class=\"w\">   </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">validity</span><span class=\"w\">    </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">visibility</span><span class=\"w\">  </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">alignment</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">alignment</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And then you could write <code>Neglect::NOTHING.alignment()</code></p>",
        "id": 225933062,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613002859
    },
    {
        "content": "<p>Slick! I'll be sure to add an entry in \"Unresolved Questions\" for these possibilities.</p>",
        "id": 225933232,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613002976
    },
    {
        "content": "<p>FWIW, I'm <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> on either of the above possibilities (as long as they're tested and confirmed to work), to avoid having to sort out FRU as a prerequisite.</p>",
        "id": 225933273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613003014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/225927753\">said</a>:</p>\n<blockquote>\n<p>(For example, it can be copy but maintain in invariant between the private field and the public one, which could be violated by FRU)</p>\n</blockquote>\n<p>If the field is public, how can it be used for an invariant?</p>",
        "id": 226023539,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1613063119
    },
    {
        "content": "<p>Good point.  That was a bad example from me.</p>",
        "id": 226029487,
        "sender_full_name": "scottmcm",
        "timestamp": 1613065450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> this is an awesome write up! It’s looking really great! In the example <a href=\"https://jswrenn.github.io/transmutation-foundation/scope-safety.html\">about scope</a> shouldn’t the NonZeroU32::new function check that v isn’t zero? I think it’s important to point out that because it’s local to the type it can see private details and is obligated to respect invariants while the non-local variant has no idea what the invariants of the type are and can’t be expected to respect them.</p>",
        "id": 226066547,
        "sender_full_name": "rylev",
        "timestamp": 1613081931
    },
    {
        "content": "<p>Also, is “unsound” the right term. As written the non local function is just as sound as the local, but of course this can change at any point if the implement of the type changes. It’s not “stably” sound.</p>",
        "id": 226066755,
        "sender_full_name": "rylev",
        "timestamp": 1613082061
    },
    {
        "content": "<p>I know we’ve been back and forth on what words to use for these concepts because there doesn’t seem to be a clearly defined definition that’s used universally, but I think it’s important to make this as clear as possible</p>",
        "id": 226066918,
        "sender_full_name": "rylev",
        "timestamp": 1613082148
    },
    {
        "content": "<p>they're both unsound</p>",
        "id": 226072315,
        "sender_full_name": "Lokathor",
        "timestamp": 1613085283
    },
    {
        "content": "<p>instead of speaking of soundness, try just saying \"allowed\" or \"disallowed\"</p>",
        "id": 226072384,
        "sender_full_name": "Lokathor",
        "timestamp": 1613085326
    },
    {
        "content": "<p>uh, just for the visibility example i mean</p>",
        "id": 226072493,
        "sender_full_name": "Lokathor",
        "timestamp": 1613085383
    },
    {
        "content": "<p>I know this is off topic, but is there any reason it never got changed, besides inertia?</p>",
        "id": 226083512,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1613093795
    },
    {
        "content": "<p>that the word never got changed? It's a fine word, people just use it wrong sometimes. Every word gets used wrong sometimes.</p>",
        "id": 226143163,
        "sender_full_name": "Lokathor",
        "timestamp": 1613140291
    },
    {
        "content": "<p>Oh, I meant FRU. I thought I had a quote there.</p>",
        "id": 226172994,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1613152516
    },
    {
        "content": "<p>I've updated <a href=\"https://jswrenn.github.io/transmutation-foundation/introduction.html\">the proposal</a> to account (I think) for everyone's feedback.</p>",
        "id": 226272341,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613255066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/225933273\">said</a>:</p>\n<blockquote>\n<p>FWIW, I'm <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> on either of the above possibilities (as long as they're tested and confirmed to work), to avoid having to sort out FRU as a prerequisite.</p>\n</blockquote>\n<p>I opted for the <code>Add</code> impl, since I think the meaning of the resulting code is more self-evident; consider:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Neglect</span>::<span class=\"n\">NOTHING</span><span class=\"p\">.</span><span class=\"n\">alignment</span><span class=\"p\">().</span><span class=\"n\">validity</span><span class=\"p\">()</span><span class=\"w\"></span>\n</code></pre></div>\n<p>vs:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Neglect</span>::<span class=\"n\">ALIGNMENT</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Neglect</span>::<span class=\"n\">VALIDITY</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 226272356,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613255099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> Sounds good. I think the builder methods could be made more self-explanatory, if we renamed Nothing, but the add approach seems fine to me.</p>",
        "id": 226290455,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613287433
    },
    {
        "content": "<p>Glad to hear it. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Besides the extra <code>NOTHING</code>, something that tips the scales towards <code>+</code> for me is that there's a clearer mapping from syntax to semantics. <code>+</code> is pretty universally understood as an operator for combining things, and <code>.</code> provides a mechanism for accessing things. With the builder method approach, however, combination and access are _very_ syntactically similar:</p>\n<ul>\n<li><code>NEGLECT.validity()</code> extends <code>NEGLECT</code> with <code>validity: true</code></li>\n<li><code>NEGLECT.validity</code> produces the <code>validity</code> field of <code>NEGLECT</code></li>\n</ul>",
        "id": 226313913,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613321354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224872\">@rylev</span> I also <a href=\"https://jswrenn.github.io/transmutation-foundation/scope-mechanism.html\">tweaked the example</a> and added the clarification that:</p>\n<blockquote>\n<p>It's generally unsound to construct instances of types for which you do not have a constructor.</p>\n</blockquote>\n<p>I say \"generally\" because, as you pointed out, that particular example was <em>potentially</em> sound <em>at snapshot in time</em>, assuming you've done your diligence to ensure that conjuring up a constructor cannot possibly lead to memory unsafety. With relation to the broader proposal: if you neglect the visibility check, you're promising to the compiler that you're doing that due diligence.</p>",
        "id": 226314148,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613321753
    },
    {
        "content": "<p>Minor bikeshed: I'd say <code>|</code>, not <code>+</code>, because that's how it's combining things internally anyway, and people are used to that for flags enums in lots of languages.  (<code>Neglect::ALIGNMENT + Neglect::ALIGNMENT</code> would be a silly thing to write, but a half adder does XOR, not OR.)</p>",
        "id": 226320883,
        "sender_full_name": "scottmcm",
        "timestamp": 1613331451
    },
    {
        "content": "<p>Yeah, it looks like <code>|</code> makes more sense here (there's even a clippy lint that will warn about doing <code>|</code> in an impl of <code>Add</code>/<code>AddAssign</code>, IIRC)</p>",
        "id": 226380335,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1613393752
    },
    {
        "content": "<p>I'm not so sure. Certainly <code>|</code> or <code>||</code> is more familiar to anyone who's done bit manipulation, but I think it might confuse people who aren't accustomed to manipulating bitsets. Consider that it's also useful to turn <em>off</em> options in some circumstances. A <code>Sub</code> impl provides a more natural surface syntax for doing so — <code>NEGLECT - Neglect::ALIGNMENT</code> — than the bit-manipulation equivalent.</p>",
        "id": 226413783,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613411588
    },
    {
        "content": "<p>I see that the documention mentions that const generic default parameters aren't yet available, but it does seem like you could sidestep the whole pseudo-bitflags issue by leveraging that instead. <code>trait Foo&lt;Src, Scope, const Alignment: bool = false, const Lifetimes: bool = false, const Validity: bool = false, const Visibility: bool = false&gt;</code>. Is it worth waiting for this to work (it doesn't need to be stable) before comitting to an API?</p>",
        "id": 226427262,
        "sender_full_name": "bstrie",
        "timestamp": 1613421110
    },
    {
        "content": "<p>I don't <em>think</em> so. The ergonomic cost and safety risk of having to correctly thread <em>N</em> const arguments strikes me as very high. (Consider if you messed up the order while threading these arguments through an impl; you'd inadvertently turn off the wrong static checks.)</p>\n<p>I don't think the issue of what operator to provide is all that significant. We could provide both. Or, we could even provide neither <a href=\"https://jswrenn.github.io/transmutation-foundation/neglect-combining.html#alternative-minimalism\">as described here</a>.</p>",
        "id": 226430550,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613423551
    },
    {
        "content": "<p>Is the reason behind the polarity of <code>Neglect</code> documented somewhere? I.e. why not <code>Validate</code> with all the booleans flipped</p>",
        "id": 226430975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613423941
    },
    {
        "content": "<p>Are you imagining that the starting point would be <code>Validate::ALL</code>? Then you'd <code>-</code> the checks you wanted to turn off? E.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Validate</span>::<span class=\"n\">ALL</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">Validate</span>::<span class=\"n\">ALIGNMENT</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">Validate</span>::<span class=\"n\">VALIDITY</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 226431388,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613424285
    },
    {
        "content": "<p>yeah</p>",
        "id": 226431392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613424291
    },
    {
        "content": "<p>since it is in some sense the more obvious way to state things, I assume it was avoided for a reason</p>",
        "id": 226431425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613424321
    },
    {
        "content": "<p>The polarity is, in part, a holdover from when <code>Neglect</code> was represented as a defaulted type parameter. With that representation, it was crucial the that the default wouldn't ever need to be changed if additional neglectable checks were ever added. \"Neglect nothing\" provided that stable default.</p>\n<p>I can think of two aesthetic/ergonomic considerations, though:</p>\n<p>First: turning off static checks should <em>scream</em> \"I need to verify this property myself.\" I think the appearance of the word <code>neglect</code> is alarming in a way that \"validate\" isn't. If the polarity goes the other way, the occurrence of <code>Validate::ALIGNMENT</code> actually means that alignment <em>isn't</em> validated.</p>\n<p>Second: the ergonomics of neglect might be slightly better than validate. Contrast this:   </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Validate</span>::<span class=\"n\">ALL</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">Validate</span>::<span class=\"n\">ALIGNMENT</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">Validate</span>::<span class=\"n\">VALIDITY</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...with: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Neglect</span>::<span class=\"n\">ALIGNMENT</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Neglect</span>::<span class=\"n\">VALIDITY</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Most of the time, <code>Validate::ALL</code> is just extra line noise.</p>",
        "id": 226433127,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613425684
    },
    {
        "content": "<p>Another good name for <code>Neglect</code> might be <code>Assume</code>, since you're enumerating the properties that the compiler can assume to be true when checking the soundness of a transmute.</p>",
        "id": 226849623,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1613670139
    },
    {
        "content": "<p><code>Bypass</code><br>\n<code>Skip</code></p>",
        "id": 226861771,
        "sender_full_name": "Lokathor",
        "timestamp": 1613674803
    },
    {
        "content": "<p><code>Unchecked</code> the term \"unchecked\" is often used to connote something is not verified by the compiler.</p>",
        "id": 226864960,
        "sender_full_name": "rylev",
        "timestamp": 1613676023
    },
    {
        "content": "<p>I like \"assume\" because it has the connotation that you're telling it to assume something without checking.</p>",
        "id": 226866076,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613676475
    },
    {
        "content": "<p>\"without checking\" also sounds like Unchecked though</p>",
        "id": 226870239,
        "sender_full_name": "Lokathor",
        "timestamp": 1613678145
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/stable/std/?search=unchecked\">https://doc.rust-lang.org/stable/std/?search=unchecked</a><br>\n<a href=\"https://doc.rust-lang.org/stable/std/?search=assume\">https://doc.rust-lang.org/stable/std/?search=assume</a></p>",
        "id": 226870475,
        "sender_full_name": "rylev",
        "timestamp": 1613678243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224872\">rylev</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/226870475\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/stable/std/?search=unchecked\">https://doc.rust-lang.org/stable/std/?search=unchecked</a><br>\n<a href=\"https://doc.rust-lang.org/stable/std/?search=assume\">https://doc.rust-lang.org/stable/std/?search=assume</a></p>\n</blockquote>\n<p>From that search stems the fact that <strong><code>unchecked</code> is used when there are checked alternatives / counterparts</strong>; so it could make sense to use stuff like <code>Unchecked::Alignment</code> given how not giving that parameter will (statically) check the alignment; that being said, the fact the checks only operate statically actually make me lean in the other direction, actually: for instance, if you want to cast a <code>&amp;[u8; 2]</code> to a <code>&amp;[u16; 1]</code>, then you'd need to manually check the alignment and then <code>Assume::Alignment</code> since there would be no checked counterpart (IIUC, the runtime-checked counterparts <em>a la</em> <code>bytemuck</code> would be downstream users of this foundation).</p>",
        "id": 226872302,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1613678984
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>: what should we do to push things forward? Should the RFC be updated? Is the proposal far enough along that we should start getting an unstable implementation in the compiler?</p>",
        "id": 228312285,
        "sender_full_name": "rylev",
        "timestamp": 1614635402
    },
    {
        "content": "<p>My feeling is that the current RFC should be closed, rather than updated. Then, this proposal should probably be reformulated to fit the format of an RFC (or an MCP) and submitted as such.</p>",
        "id": 228315377,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614636639
    },
    {
        "content": "<p>Any thoughts on starting implementation? There does seem to be parts of the proposal that aren’t too controversial and/or can be changed quickly</p>",
        "id": 228317122,
        "sender_full_name": "rylev",
        "timestamp": 1614637308
    },
    {
        "content": "<p>It seems like the most important starting point for the implementation is the compiler-supplied underlying trait, with lots of tests to demonstrate that it implements the rules as designed. Layers atop that can be demonstrated atop the resulting try builds and later nightlies.</p>",
        "id": 228319215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614638212
    },
    {
        "content": "<p>As for next steps, I think it's up to this group whether it makes sense to update or rewrite the RFC. But either way, I think that the team will want to evaluate the new version standalone, together with the various clear explanations I've seen from this group and the recent documents.</p>",
        "id": 228319987,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614638555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224872\">rylev</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/228312285\">said</a>:</p>\n<blockquote>\n<p>Is the proposal far enough along that we should start getting an unstable implementation in the compiler?</p>\n</blockquote>\n<p>T-compiler would have to approve it, of course, but I think making the \"needs to be in the compiler\" trait part as available as unstable soon -- even before a new RFC is posted, perhaps -- makes a ton of sense.</p>\n<p>Then it would be possible to have playground demos or similar of the wrapper proposals</p>",
        "id": 228322268,
        "sender_full_name": "scottmcm",
        "timestamp": 1614639680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> Do you want to ask <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a> if the think an MCP would be appropriate for getting the go-ahead on an unstable safe transmute <code>BikeshedIntrinsicFrom</code> in the compiler? I can help here if you want.</p>",
        "id": 228410873,
        "sender_full_name": "rylev",
        "timestamp": 1614692582
    },
    {
        "content": "<p>Just to confirm: are MCP's the right tool for this? The <a href=\"https://forge.rust-lang.org/compiler/mcp.html\">docs</a> stress that they're mostly for non-user-facing changes.</p>",
        "id": 228460554,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614709697
    },
    {
        "content": "<p>Yes, because the RFC will be the user-facing side of this.  Right now it's just adding an implementation detail.</p>\n<p>(This is like adding an intrinsic, even if that intrinsic is something that might be exposed stably in the future.)</p>",
        "id": 228473837,
        "sender_full_name": "scottmcm",
        "timestamp": 1614714662
    },
    {
        "content": "<p>Great!</p>",
        "id": 228477070,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614715852
    },
    {
        "content": "<p>How much of <a href=\"https://jswrenn.github.io/transmutation-foundation/\">the mdbook</a> should go into the MCP vs being linked?</p>",
        "id": 228482482,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614717875
    },
    {
        "content": "<p>My guess is that it would include only the parts relevant to <code>BikeshedIntrinsicFrom</code>, like \"When is a transmutation well-defined and safe?\", but with everything about muckable and other such things only referenced.  But you might want to start a t-compiler thread about it -- I'm just extrapolating from things I've seen, as I haven't made one nor can I second them.</p>",
        "id": 228484279,
        "sender_full_name": "scottmcm",
        "timestamp": 1614718658
    },
    {
        "content": "<p>In my experience MCPs tend to be focused on the actual proposal with relevant context in adjacent documents.</p>",
        "id": 228558842,
        "sender_full_name": "rylev",
        "timestamp": 1614762658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224872\">@rylev</span> how's this: <a href=\"https://github.com/jswrenn/transmutation-foundation/blob/main/MCP.md\">https://github.com/jswrenn/transmutation-foundation/blob/main/MCP.md</a></p>",
        "id": 228818885,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614880287
    },
    {
        "content": "<p>Awesome! I would add a short sentence at the very beginning saying this is part of the safe transmute working group's investigation and link to the RFC</p>",
        "id": 228820110,
        "sender_full_name": "rylev",
        "timestamp": 1614880745
    },
    {
        "content": "<p>I'm not sure that the level of detail is needed. After all, it's not really about whether they thing the design is a good one. It's more a request \"the safe transmute WG thinks this is the right direction, but we'd like to experiment in the compiler\"</p>",
        "id": 228820530,
        "sender_full_name": "rylev",
        "timestamp": 1614880858
    },
    {
        "content": "<p>Nit: add Debug/Clone/Copy/Default for Assume</p>",
        "id": 228826071,
        "sender_full_name": "Lokathor",
        "timestamp": 1614882845
    },
    {
        "content": "<p><code>Clone</code> and <code>Copy</code> are no-brainers (just added them!), but <code>Default</code> is debatable. <code>Assume::NOTHING</code> is clearer than <code>Assume:default()</code>. Also, I don't think <code>Default</code> can be used in a const context, which is where <code>Assume</code> is mostly going to be used.</p>",
        "id": 228828705,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614883836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224872\">rylev</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/228820110\">said</a>:</p>\n<blockquote>\n<p>Awesome! I would add a short sentence at the very beginning saying this is part of the safe transmute working group's investigation and link to the RFC</p>\n</blockquote>\n<p>Done! I didn't add the link to the RFC in that intro sentence, though, since it's not really required reading and the <em>volume</em> of reading is pretty overwhelming. There's a link to it at the end.</p>",
        "id": 228829026,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614883962
    },
    {
        "content": "<p>I included the explanations because  <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/228319987\">mentioned</a> them as important:</p>\n<blockquote>\n<p>As for next steps, I think it's up to this group whether it makes sense to update or rewrite the RFC. But either way, I think that the team will want to evaluate the new version standalone, together with the various clear explanations I've seen from this group and the recent documents.</p>\n</blockquote>\n<p>I <em>think</em> the explanations I included are more so along the lines of \"why does this bit need to exist\" (which might be important for review), rather than \"what's the optimal form this bit should exist in\". </p>\n<p>I've added a note marking the transition from proposal to explanation.</p>",
        "id": 228829169,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614884012
    },
    {
        "content": "<p>I'm going to go ahead and file the MCP! I can always trim the explanation out if need be. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p><strong><em>kapow!</em></strong> <a href=\"https://github.com/rust-lang/compiler-team/issues/411\">https://github.com/rust-lang/compiler-team/issues/411</a></p>",
        "id": 228829650,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614884186
    },
    {
        "content": "<p>Nice to see movement here. :)<br>\nI assume this is preliminary, but I wondered one thing about the API surface: why overload <code>+</code> and <code>-</code>, not <code>|</code> and <code>&amp;</code> and <code>!</code>? After all, the behavior is more like the bit operations than the arithmetic.<br>\nIn particular, while <code>bool</code> does not implement <code>+</code>, if it would then the mathematically \"normal\" thing to do (in my experience) would be to make this \"addition modulo 2\", ie. <code>true+true == false</code>. In that sense the proposed <code>+</code> for <code>Assume</code> behaves in unexpected ways.<br>\nTo make this point more concrete, I think when <code>+</code> and <code>-</code> are both defined, one can reasonably expect that <code>a+b-b == a</code>. (Algebraically speaking, this means <code>+</code> and <code>-</code> form a group. It is very uncommon to use <code>+</code> and <code>-</code> for operations that do not form a group. I know floating point types dont technically satisfy this, but they do \"up to rounding and NaN\".) For <code>Assume</code>, this condition is violated. I dont think libstd should do operator overloading like this.</p>",
        "id": 228915159,
        "sender_full_name": "RalfJ",
        "timestamp": 1614933631
    },
    {
        "content": "<p>I was gonna mention that bit ops may not read as well as good old \"hand-waved set operations\" such as <code>+</code> (for union) and <code>-</code> (for <code>\\</code>), since not every Rust programmer is necessarily acquainted with bit-ops.</p>\n<p>That being said, the case of quasi-forwarding a generic <code>&lt;const ASSUMPTIONS: Assume&gt;</code> parameter makes it so having the sigils ops showcase \"group semantics\" that actually do not hold may indeed be a footgun (although a somewhat realistic example of it being confusing would be nice to have for this discussion). Because of that, I now think that using <code>|</code> and <code>&amp;!</code>, even if it slightly hinders the readability, is the least dangerous course of action in the long term.</p>\n<p>Also, we may consider that <a href=\"https://doc.rust-lang.org/stable/std/collections/struct.HashSet.html#trait-implementations\">the impls on <code>std</code>'s <code>HashSet</code></a>  (and <code>BTreeSet</code>) may be have already set a precedent: have <code>And</code>, <code>Or</code>, <code>Xor</code>, and <code>Sub</code>, but no <code>Add</code>. Having <code>Or</code> and <code>Sub</code> (but no <code>Add</code>) seems like a good compromise indeed, since the op I was most worried about among the non-bitops-savy people was <code>&amp;!</code>.</p>",
        "id": 228951668,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614950604
    },
    {
        "content": "<p>I also think it may be disproportionately likely that someone using safe-transmute (and especially with an assume parameter) will be familiar with bit operations.</p>",
        "id": 228992184,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614965388
    },
    {
        "content": "<p>Previous conversation about <code>|</code>: <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/226320883\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/transmutability/near/226320883</a></p>",
        "id": 228997601,
        "sender_full_name": "scottmcm",
        "timestamp": 1614967481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> happy to bikeshed on this. My bias is towards APIs that make some intuitive sense when read aloud. Admittedly, this is a matter of personal preference. I don't do a lot of bit manipulation.</p>\n<p>How should the statement \"assume all properties except alignment\" translate into syntax?</p>\n<ol>\n<li>\n<p><code>Assume::ALL &amp; !Assume::ALIGNMENT</code> reads as \"assume all properties and not alignment\".<br>\n    Not too shabby! I doubt that people who don't do bit manipulation will intuitively come up with this arrangement of operators, but at least they won't be mislead if they encounter it in source code and simply read it aloud.</p>\n</li>\n<li>\n<p><code>Assume::ALL - Assume::ALIGNMENT</code> reads as \"assume all properties, minus alignment\"<br>\n    This is close to our target statement. Won't confuse bit-manip folks, but might confuse algebraists.</p>\n</li>\n</ol>\n<p>How should the statement \"assume alignment and validity\" translate into syntax?</p>\n<ol>\n<li>\n<p><code>Assume::ALIGNMENT | Assume::VALIDITY</code> reads as \"assume alignment or validity\"<br>\n    Yikes. That is <em>very</em> misleading if you aren't accustomed to bit manipulation.</p>\n</li>\n<li>\n<p><code>Assume::ALIGNMENT &amp; Assume::VALIDITY</code> reads as \"assume alignment and validity\"<br>\n    This has the opposite problem: it matches out target statement exactly, but will confuse anyone accustomed bit manipulation.</p>\n</li>\n<li>\n<p><code>Assume::ALIGNMENT + Assume::VALIDITY</code> reads as \"assume alignment plus validity\"<br>\n    This is close to our target statement. Won't confuse bit-manip folks, but might confuse algebraists. </p>\n</li>\n</ol>\n<p>In this toss-ups, <code>+</code> and <code>-</code> strike a balance between intelligibility when read aloud, and not confusing people who are used to thinking about bit manipulation.</p>\n<p>This might confuse people who think of <code>+</code> as meaning \"addition modulo 2\", but that is already <em>not</em> the normal meaning of <code>+</code> in Rust. On the bare number types, <code>+</code> and <code>-</code> provide partial arithmetic. On <code>Wrapping&lt;T&gt;</code>, they provide wrapping arithmetic. My explanation of <code>+</code> and <code>-</code> on <code>Assume</code> for these folks would be: just think of it as a saturating addition, or saturating sub.</p>\n<p>(Since <code>+</code> and <code>-</code> <em>aren't</em> defined on bare booleans, so hopefully the preconception that <code>+</code> and <code>-</code> on them would be wrapping is rare.)</p>",
        "id": 228997613,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614967488
    },
    {
        "content": "<p><code>|</code> for meaning \"both\" is a widespread convention, though.  Even has a built-in attribute for it in C#: <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags\">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags</a></p>",
        "id": 228997934,
        "sender_full_name": "scottmcm",
        "timestamp": 1614967609
    },
    {
        "content": "<p>Speaking as someone who intends to offer the easy interface on top of this intrinsic-y interface: bit ops would be totally fine to work with internally.</p>",
        "id": 228999504,
        "sender_full_name": "Lokathor",
        "timestamp": 1614968214
    },
    {
        "content": "<p>Sure. When you're thinking in terms of bit flags, it's the natural operator to use.</p>\n<p>But the risks of misuse here are unequal enough that I think we'd do well to consider departing from that precedent:</p>\n<ul>\n<li>If we provide <code>+</code> instead of <code>|</code> we run the risk that people used to bit manipulation might reach for <code>|</code>, and would get an error message that it isn't defined for <code>Assume</code>(and perhaps a recommendation to use <code>+</code> instead!). The consequence is irritation.</li>\n<li>If we provide <code>|</code> instead of <code>+</code>, we run the risk that people who <strong>aren't</strong> used to bit manipulation might read \"Neglect::ALIGNMENT | Neglect::VALIDITY\" aloud and get a <em>very</em> wrong impression. The consequence is, potentially, inadvertent unsoundness. </li>\n</ul>\n<p>The cognitive load of learning the arith ops vs the bit ops is unequal, too:</p>\n<ul>\n<li>The arithmetic route requires two operators: <code>+</code> and <code>-</code>, covering adding and removing assumptions, respectively.</li>\n<li>The arithmetic route requires three operators: <code>&amp;</code>, <code>|</code> and <code>!</code>. The <code>!</code> operator isn't useful in isolation, so learning how to remove assumptions would require learning to correctly compose two operators, instead of one.</li>\n</ul>",
        "id": 228999817,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614968330
    },
    {
        "content": "<p>if you want the combinations to read aloud well, you should offer named methods that do the thing you want.</p>\n<p>bikeshed time:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">except_for</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bits_to_clear</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">bits_to_clear</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 228999893,
        "sender_full_name": "Lokathor",
        "timestamp": 1614968364
    },
    {
        "content": "<p>Assume::ALL.except_for(Assume::ALIGNMENT)</p>",
        "id": 228999974,
        "sender_full_name": "Lokathor",
        "timestamp": 1614968404
    },
    {
        "content": "<p>What would the named method be for adding an assumption?</p>",
        "id": 229000059,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614968427
    },
    {
        "content": "<p>and_also</p>",
        "id": 229000110,
        "sender_full_name": "Lokathor",
        "timestamp": 1614968448
    },
    {
        "content": "<p>that's the magic of bikeshed time jack! just make up anything on the spot, whatever feels good</p>",
        "id": 229000209,
        "sender_full_name": "Lokathor",
        "timestamp": 1614968480
    },
    {
        "content": "<p>haha. sure. i was absolutely committing entrapment by prodding you on this. I would have guessed <code>and</code>, which has some obvious potential for confusion. <code>and_also</code> isn't too shabby.</p>",
        "id": 229000537,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614968607
    },
    {
        "content": "<p>however, i think you mean:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Assume</span>::<span class=\"n\">ALL</span><span class=\"p\">.</span><span class=\"n\">yeet</span><span class=\"p\">(</span><span class=\"n\">Assume</span>::<span class=\"n\">ALIGNMENT</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 229000598,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614968635
    },
    {
        "content": "<p>yeet is obviously a future keyword so we shouldn't use it for methods.</p>",
        "id": 229001186,
        "sender_full_name": "Lokathor",
        "timestamp": 1614968840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I do think the \"read aloud\" problem is important here.</p>",
        "id": 229002839,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969436
    },
    {
        "content": "<p>I don't mind \"this is only familiar to people who have used bit operations\". I do mind \"this is actively harmful and illogical to people who haven't used bit operations\".</p>",
        "id": 229002926,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/228999817\">said</a>:</p>\n<blockquote>\n<p>But the risks of misuse here are unequal enough that I think we'd do well to consider departing from that precedent:</p>\n</blockquote>\n<p>I think one can easily get the problems in the other way arriving from simd or linear algebra, though.  The common definition for <code>+</code> on something like a struct with <code>x/y/z</code> or <code>r/g/b</code> fields would be mapping the operator over those fields -- see all the complaints about <code>+</code> on <code>String</code> because it doesn't work like that -- and the fact that this wouldn't be doing that gets back to all the things that Ralf was talking about.</p>",
        "id": 229003004,
        "sender_full_name": "scottmcm",
        "timestamp": 1614969492
    },
    {
        "content": "<p>I think that rules out &amp; because it reads differently than its bit-op meaning.</p>",
        "id": 229003070,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969518
    },
    {
        "content": "<p>And I would lean against | because it will actively confuse people who don't know bit ops.</p>",
        "id": 229003141,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969548
    },
    {
        "content": "<p>If we suppose that the various assume flags are in fact numeric bit flags (which they aren't), + is actually valid to combine them.</p>",
        "id": 229003217,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969591
    },
    {
        "content": "<p>So it makes sense to both groups, and I don't think it's <em>wrong</em> for either.</p>",
        "id": 229003304,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229003217\">said</a>:</p>\n<blockquote>\n<p>If we suppose that the various assume flags are in fact numeric bit flags (which they aren't), + is actually valid to combine them.</p>\n</blockquote>\n<p>Until you add something twice and it carries into a different flag...</p>",
        "id": 229003308,
        "sender_full_name": "scottmcm",
        "timestamp": 1614969616
    },
    {
        "content": "<p>Sure, but I don't think people will assume that about assume.</p>",
        "id": 229003461,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969687
    },
    {
        "content": "<p>Pondering: is it possible that the negative phrasing here (<code>Neglect::NONE</code> vs <code>Enforce::EVERYTHING</code>) is making this more difficult?</p>",
        "id": 229003469,
        "sender_full_name": "scottmcm",
        "timestamp": 1614969689
    },
    {
        "content": "<p>\"assume\" seems clearer than \"neglect\" here.</p>",
        "id": 229003622,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614969744
    },
    {
        "content": "<p>When this was trait \"addition\" the neglect direction made sense, as there's no trait subtraction.  But maybe the other phrasing could help with naming things</p>",
        "id": 229003734,
        "sender_full_name": "scottmcm",
        "timestamp": 1614969803
    },
    {
        "content": "<p>(Though of course for the MCP naming is largely irrelevant)</p>",
        "id": 229003754,
        "sender_full_name": "scottmcm",
        "timestamp": 1614969815
    },
    {
        "content": "<p>Hm, I don't <em>think</em> reversing polarity changes much in this regard? You still end up with situations where you need to add or remove a static check, so you still need a syntax for doing that. The meaning of the syntax just gets reversed.</p>",
        "id": 229004214,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1614970009
    },
    {
        "content": "<p>Well, the issue you brought up with the \"reading\" being opposite of the bit operator sense of <code>|</code> and <code>&amp;</code> would be fixed by a polarity change</p>",
        "id": 229059465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615000961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229002926\">said</a>:</p>\n<blockquote>\n<p>I don't mind \"this is only familiar to people who have used bit operations\". I do mind \"this is actively harmful and illogical to people who haven't used bit operations\".</p>\n</blockquote>\n<p>how's that any worse than <code>if a &amp;&amp; b { X }</code> being read aloud as \"X is done under conditions a and b\", which most non-mathematically minded people say when they really mean <code>if a || b { X }</code>? There is, sadly, in common speech a confusion of \"union\" and \"and\", despite the fact that logically, \"union = or\" and \"intersection = and\". (I guess the underlying issue here is that \"and\" has a logical meaning of intersection but an arithmetic meaning of \"combining things\".) But given that we already use <code>||</code> to mean \"or\" aka \"union\", I don't think we should use <code>+</code> to also mean \"union\". That's just very confusing to anyone who does think in mathematical/logical terms, which programmers are more likely to do that the average person.<br>\nI don't think there is a way to make the \"common speech interpretation of the operation said out aloud\" always match what actually happens, because common speech is internally inconsistent. So absent that I'd prefer to at least be mathematically/logically consistent: if both <code>+</code> and <code>-</code> exist, the latter should be the inverse of the former.</p>\n<p>As was mentioned above, some people already get confused by <code>+</code> on strings, I think this is worse (at least we don't have <code>-</code> on strings, and <code>+</code> on strings forms a monoid so the notation makes some mathemetical sense).</p>",
        "id": 229088319,
        "sender_full_name": "RalfJ",
        "timestamp": 1615028164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229003217\">said</a>:</p>\n<blockquote>\n<p>If we suppose that the various assume flags are in fact numeric bit flags (which they aren't), + is actually valid to combine them.</p>\n</blockquote>\n<p>they dont behave like numeric bit flags at all though as <code>-</code> shows, so this is saying \"if we suppose an actively wrong mental model then ...\", which I don't think is a good argument.</p>",
        "id": 229088374,
        "sender_full_name": "RalfJ",
        "timestamp": 1615028252
    },
    {
        "content": "<p>is there some reason that <code>*</code> hasn't been proposed?</p>",
        "id": 229111402,
        "sender_full_name": "oliver",
        "timestamp": 1615049087
    },
    {
        "content": "<p>I'd like to observe that this seems like the height (or perhaps, the depths) of bikeshedding.</p>",
        "id": 229112600,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615050166
    },
    {
        "content": "<p>At this point, arguments have been made; let's leave it to the group what to propose.</p>",
        "id": 229112696,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615050248
    },
    {
        "content": "<p>at least that's not obvious to me anyway</p>",
        "id": 229113797,
        "sender_full_name": "oliver",
        "timestamp": 1615051193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281739\">@oliver</span> We need syntax for: </p>\n<ol>\n<li>adding an assumption to the set of assumptions</li>\n<li>removing an assumption from the set of assumptions</li>\n</ol>\n<p>Which one of those would <code>*</code> correspond to?</p>",
        "id": 229124962,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615061202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Do you have any objections to using <code>|</code> for adding assumptions and <code>-</code> for removing assumptions?</p>",
        "id": 229126405,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615062464
    },
    {
        "content": "<p><code>*</code> is well-known for multiplication over a type and <code>\\</code> is known for removing elements</p>",
        "id": 229127039,
        "sender_full_name": "oliver",
        "timestamp": 1615062984
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I think if we're going to assume that people understand <code>-</code> to remove assumptions, we might as well use <code>+</code> to add assumptions.</p>",
        "id": 229127168,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615063145
    },
    {
        "content": "<p>I personally agree, but having <code>|</code> and <code>-</code> is the compromise <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/228951668\">suggested</a> by <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> to match <code>HashSet</code>, which defines <code>|</code> and <code>-</code>, but <em>not</em> <code>+</code>.</p>",
        "id": 229127377,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063301
    },
    {
        "content": "<p>Ah, I didn't realize that was the motivation.</p>",
        "id": 229127451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615063342
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>'s criticism was:</p>\n<blockquote>\n<p>if both <code>+</code> and <code>-</code> exist, the latter should be the inverse of the former.</p>\n</blockquote>\n<p>...so this might be only a problem posed by the <em>coexistence</em> of <code>+</code> and <code>-</code>.</p>",
        "id": 229127476,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063378
    },
    {
        "content": "<p>That one I don't understand; I feel like they <em>are</em> inverses.</p>",
        "id": 229127503,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615063400
    },
    {
        "content": "<p><code>X + Y - Y</code> is X.</p>",
        "id": 229127510,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615063415
    },
    {
        "content": "<p>I think the difference is with the over/underflow conditions? For <code>+</code> and <code>-</code> to be true inverses, they need to behave like wrapping arithmetic. On <code>Assume</code>, they behave like saturating arithmetic.</p>",
        "id": 229127655,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063530
    },
    {
        "content": "<p>Sure.</p>",
        "id": 229127737,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615063604
    },
    {
        "content": "<p>To me, that's not that weird, but <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 229127844,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229127510\">said</a>:</p>\n<blockquote>\n<p><code>X + Y - Y</code> is X.</p>\n</blockquote>\n<p>it's not though. If <code>X</code> is all-true and <code>Y</code> is all-true then <code>X+Y-Y</code> is all-false.<br>\nSo, they are definitely not inverses in any sense of the word I can imagine.</p>",
        "id": 229127991,
        "sender_full_name": "RalfJ",
        "timestamp": 1615063781
    },
    {
        "content": "<p>That's the wrapping vs. saturating distinction, right?</p>",
        "id": 229128079,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229127039\">said</a>:</p>\n<blockquote>\n<p><code>*</code> is well-known for multiplication over a type and <code>\\</code> is known for removing elements</p>\n</blockquote>\n<p>sure, but multiplication corrsponds to <code>&amp;</code>, so I don't see how that helps. and yes <code>\\</code> would be great but we don't have that operator in Rust.</p>",
        "id": 229128080,
        "sender_full_name": "RalfJ",
        "timestamp": 1615063859
    },
    {
        "content": "<p>that's a shame :(</p>",
        "id": 229128106,
        "sender_full_name": "oliver",
        "timestamp": 1615063873
    },
    {
        "content": "<p>/me files an RFC to add <code>\\</code></p>",
        "id": 229128126,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128079\">said</a>:</p>\n<blockquote>\n<p>That's the wrapping vs. saturating distinction, right?</p>\n</blockquote>\n<p>you mean in the sense that saturating arithmetic also fails to be a group?</p>",
        "id": 229128129,
        "sender_full_name": "RalfJ",
        "timestamp": 1615063904
    },
    {
        "content": "<p><code>*</code> for multiplication over sets of types*</p>",
        "id": 229128137,
        "sender_full_name": "oliver",
        "timestamp": 1615063912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> yep.</p>",
        "id": 229128183,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063925
    },
    {
        "content": "<p>probably still off*</p>",
        "id": 229128194,
        "sender_full_name": "oliver",
        "timestamp": 1615063930
    },
    {
        "content": "<p>yes. I am not sure what the right algebraic structure is to describe saturating arithmetic.</p>",
        "id": 229128221,
        "sender_full_name": "RalfJ",
        "timestamp": 1615063965
    },
    {
        "content": "<p>Currently, all of the primitive numeric types implement partial arithmetic (panic on underflow and overflow), so they also fail to be a group, right?</p>",
        "id": 229128255,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615063997
    },
    {
        "content": "<p>unlike modular arithmetic, I have not seen it (saturating arithmetic) come up in formal math/CS</p>",
        "id": 229128256,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128255\">said</a>:</p>\n<blockquote>\n<p>Currently, all of the primitive numeric types implement partial arithmetic (panic on underflow and overflow), so they also fail to be a group, right?</p>\n</blockquote>\n<p>they are a partial group</p>",
        "id": 229128261,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064013
    },
    {
        "content": "<p>Huh, gotcha.</p>",
        "id": 229128349,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229126405\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Do you have any objections to using <code>|</code> for adding assumptions and <code>-</code> for removing assumptions?</p>\n</blockquote>\n<p>no objections other than a vague sense of weirdness. I think when I saw those I would be like \"hu, what's going on here\" and read the docs, which is probably the intended result. ;)</p>",
        "id": 229128381,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064071
    },
    {
        "content": "<p>I was not even aware our HashSet overloads operations, and I am not sure I'd use them in code I write</p>",
        "id": 229128441,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064124
    },
    {
        "content": "<p>Wouldn't you react similarly if you reached for <code>|</code> and got an error message that it wasn't defined?</p>",
        "id": 229128449,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064132
    },
    {
        "content": "<p>(just like I wouldnt use <code>+</code> on strings)</p>",
        "id": 229128450,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128449\">said</a>:</p>\n<blockquote>\n<p>Wouldn't you react similarly if you reached for <code>|</code> and got an error message that it wasn't defined?</p>\n</blockquote>\n<p>honestly I wouldnt usually reach for overloaded operators, I'd reach for named methods</p>",
        "id": 229128471,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064156
    },
    {
        "content": "<p>I don't have any objections to also supply named methods for these operations, for those with that preference.</p>",
        "id": 229128567,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064233
    },
    {
        "content": "<p>it's not like I fundamentally dislike operator overloading, in my research I am using unicode operator notation for all sorts of things -- but then we use <code>∪</code> for union and  <code>∖</code> for difference, we'd never overload the arithmetic operators like that ;)</p>",
        "id": 229128590,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064278
    },
    {
        "content": "<p>but of course in Rust we don't have that option</p>",
        "id": 229128659,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064305
    },
    {
        "content": "<p><em>yet</em> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 229128673,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064331
    },
    {
        "content": "<p>which is why I reach for named things as the next best option. C++ <code>std::cout &lt;&lt; foo</code> showed what can happen when you push operator overloading too far ;)</p>",
        "id": 229128675,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128673\">said</a>:</p>\n<blockquote>\n<p><em>yet</em> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>nopenopenope</p>",
        "id": 229128678,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615064342
    },
    {
        "content": "<p>hahahaha.</p>",
        "id": 229128704,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064350
    },
    {
        "content": "<p>I've used Haskell codebases with arbitrary Unicode operators, and even just arbitrary ASCII operators. Nope nope nope.</p>",
        "id": 229128715,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615064378
    },
    {
        "content": "<p>:trollface:</p>",
        "id": 229128721,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064396
    },
    {
        "content": "<p>It worked in the Haskell world where a substantial fraction of packages had someone's thesis as their documentation. ;)</p>",
        "id": 229128726,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615064401
    },
    {
        "content": "<p>Josh Triplett has <em>seen</em> things, man.</p>",
        "id": 229128791,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615064428
    },
    {
        "content": "<p>yeah in case of the research I mentioned above that would be my thesis ;)</p>",
        "id": 229128827,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128827\">said</a>:</p>\n<blockquote>\n<p>yeah in case of the research I mentioned above that would be my thesis ;)</p>\n</blockquote>\n<p>I deeply appreciate that a substantial part of your work is making your results accessible to a broad audience.</p>",
        "id": 229128880,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615064492
    },
    {
        "content": "<p>In any case, as tempted as I've occasionally been, I think the general consensus is strongly against arbitrary overloadable operators.</p>",
        "id": 229128952,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615064539
    },
    {
        "content": "<p>but anyway, back on topic -- if having <code>+</code>and <code>-</code> violate the axioms of a (partial) group is considered acceptable, e.g. for use in a \"saturating semantics\", then so be it. it's a line being crossed but it's not the end of the world and I'll get used to it. I just wanted to make sure that this is a deliberate move. :)</p>",
        "id": 229128964,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128880\">said</a>:</p>\n<blockquote>\n<p>I deeply appreciate that a substantial part of your work is making your results accessible to a broad audience.</p>\n</blockquote>\n<p><span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> but you can't mean my thesis with that, I'd call it many things but not broadly accessible ;)</p>",
        "id": 229129085,
        "sender_full_name": "RalfJ",
        "timestamp": 1615064669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229129085\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128880\">said</a>:</p>\n<blockquote>\n<p>I deeply appreciate that a substantial part of your work is making your results accessible to a broad audience.</p>\n</blockquote>\n<p><span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> but you can't mean my thesis with that, I'd call it many things but not broadly accessible ;)</p>\n</blockquote>\n<p>I mean your work in general. You're focused heavily on practical applications, clear semantics, <em>understanding</em>, and meeting people where they are; that puts you in the top tier of formal-methods folks.</p>",
        "id": 229129628,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615065180
    },
    {
        "content": "<p>put me down with jack: pro-operators. everything <em>can</em> be used wrong, i trust people to be sensible (or their crates will just be unpopular and their download count won't <span aria-label=\"rocket\" class=\"emoji emoji-1f680\" role=\"img\" title=\"rocket\">:rocket:</span><span aria-label=\"rocket\" class=\"emoji emoji-1f680\" role=\"img\" title=\"rocket\">:rocket:</span><span aria-label=\"rocket\" class=\"emoji emoji-1f680\" role=\"img\" title=\"rocket\">:rocket:</span>).</p>",
        "id": 229129752,
        "sender_full_name": "Lokathor",
        "timestamp": 1615065279
    },
    {
        "content": "<p>that said, for this assume thing, start with word methods only, no + or | or anything like that</p>",
        "id": 229129789,
        "sender_full_name": "Lokathor",
        "timestamp": 1615065323
    },
    {
        "content": "<p>I think I have a good enough understanding of the tradeoffs of each approach to write something that adequately contrasts them, which will be useful for the libs team if this proposal is ever RFC'd. For now, it's almost a moot point.</p>\n<p>I'm going to keep the MCP as-is for now, but when it comes to implementation, we can even do silly things like implement <em>all</em> of the different proposals just so we can play around with how they feel in practice. Of course we'll need to eventually whittle that down, but that's a long way off.</p>",
        "id": 229129806,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615065348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I would have done that in the MCP if the ergonomics of calling methods in const-generic positions weren't <em>so</em> bad. Brevity and clarity go hand-in-hand when it comes to types.</p>",
        "id": 229129896,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615065432
    },
    {
        "content": "<p>it's kinda bad, usually you can define the ones you want and use named values:</p>\n<p>const Foo: t = complicated.expression().here();<br>\nthing::&lt;Foo&gt;(x);</p>",
        "id": 229129979,
        "sender_full_name": "Lokathor",
        "timestamp": 1615065509
    },
    {
        "content": "<p>It gets especially rough in <code>where</code> bounds, and when some aspect of the expression is a variable (e.g., <code>ASSUME + Assume::ALIGNMENT</code>). In those cases, you need to define a <code>const fn</code> in the surrounding scope, and introduce indirection into your <code>where</code> bound.</p>",
        "id": 229130175,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615065706
    },
    {
        "content": "<p>as with most of programming, the only thing worse than const generics is not having const generics.</p>",
        "id": 229130283,
        "sender_full_name": "Lokathor",
        "timestamp": 1615065796
    },
    {
        "content": "<p>those are all just limitations of the current implementation though, right? should that really inform API design?</p>",
        "id": 229130367,
        "sender_full_name": "RalfJ",
        "timestamp": 1615065868
    },
    {
        "content": "<p>I'm just commenting on the aesthetics, not whether or not you <em>can</em> call const methods in const generic positions (as far as I'm aware: you can).</p>",
        "id": 229130419,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1615065937
    },
    {
        "content": "<p>for Nightly: yes absolutely it should inform, we must always live in the world we have.</p>\n<p>for stabilization: probably not, if we can wait a bit to get a better api.</p>",
        "id": 229130427,
        "sender_full_name": "Lokathor",
        "timestamp": 1615065956
    },
    {
        "content": "<p>fair</p>",
        "id": 229130486,
        "sender_full_name": "RalfJ",
        "timestamp": 1615065980
    },
    {
        "content": "<p>we're also, for example, doing some un-nice temporary things in the simd-wg until stuff gets fixed in rustc/llvm/cranelift.</p>",
        "id": 229130528,
        "sender_full_name": "Lokathor",
        "timestamp": 1615066047
    },
    {
        "content": "<p>There's also my plan for <code>Try</code>: propose something, change it to something completely different names, then just go to a libs meeting and say \"so what should it be, folks?\" <span aria-label=\"smirk\" class=\"emoji emoji-1f60f\" role=\"img\" title=\"smirk\">:smirk:</span></p>",
        "id": 229151278,
        "sender_full_name": "scottmcm",
        "timestamp": 1615087104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/229128256\">said</a>:</p>\n<blockquote>\n<p>unlike modular arithmetic, I have not seen it (saturating arithmetic) come up in formal math/CS</p>\n</blockquote>\n<p>FWIW I have seen saturating arithmetic come up in formal math, and it's <code>+</code> and <code>-</code>. In this case I would describe the operators more like set operators but I don't think <code>∪</code> and <code>\\</code> are an option. The correct cancellation equation is <code>A + B - B = A - B</code> BTW, this is just like on sets. It is cancellative on the assumption that B is disjoint from A: <code>B &amp; A = 0 -&gt; A + B - B = A</code></p>",
        "id": 229151645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615087493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Yeah, but we were on to you, hence the response of \"here are some criteria, you come back with new names\". ;)</p>",
        "id": 229170326,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615106920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>The correct cancellation equation is A + B - B = A - B</p>\n</blockquote>\n<p>This does not hold for saturating arithmetic: take A = 10 and B = 2 and use u32 saturating arithmetic.<br>\nSo I dont think it is the right equation.</p>",
        "id": 229176686,
        "sender_full_name": "RalfJ",
        "timestamp": 1615113224
    },
    {
        "content": "<p>Also, the term \"cancellative\" in my world usually refers to <code>A + B = A + C → B = C</code> (which is weaker than actually having an inverse) so I am a bit confused by your use of the term. ;)</p>",
        "id": 229176795,
        "sender_full_name": "RalfJ",
        "timestamp": 1615113289
    },
    {
        "content": "<blockquote>\n<p>This does not hold for saturating arithmetic: take A = 10 and B = 2 and use u32 saturating arithmetic. So I dont think it is the right equation.</p>\n</blockquote>\n<p>That's true, but this isn't any old saturating arithmetic, it's a boolean algebra</p>",
        "id": 229180431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615116736
    },
    {
        "content": "<p>I mean cancellation only in the sense that it is a simplification of a cancellation equation. Obviously neither boolean algebras nor saturating semirings are cancellative in the full sense, although most have something approximating a cancellation law, like this one</p>",
        "id": 229180636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615116953
    },
    {
        "content": "<p>with saturating u32 the cancellation law holds under some messy inequality side conditions</p>",
        "id": 229180709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615117013
    },
    {
        "content": "<blockquote>\n<p>That's true, but this isn't any old saturating arithmetic, it's a boolean algebra</p>\n</blockquote>\n<p>sure it is, but in programming we usually write <code>|</code> and <code>&amp;</code> for the boolean operations. that's the entire point. ;)</p>",
        "id": 229180827,
        "sender_full_name": "RalfJ",
        "timestamp": 1615117165
    },
    {
        "content": "<p>Personally, I would be fine with either <code>|</code> and <code>&amp;!</code> or <code>+</code> and <code>-</code>. Although if this is going to have the full suite of boolean operators then there are some terms you can make that aren't just \"assume none + these enumerated things\", like \"assume everything except this\" (i.e. if you just use <code>!</code>). If only <code>+</code> and <code>-</code> are exposed then you can't write these, which may or may not be considered a good thing</p>",
        "id": 229181457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615117712
    },
    {
        "content": "<p>Personally I would be very surprised that + and - had boolean semantics. I would rather use &amp; and | for that - if you've never seen them before it will hopefully make you go read the docs, and if you have I don't think you'd be confused about the behavior</p>",
        "id": 229200413,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1615135171
    },
    {
        "content": "<p>That said, being consistent with HashSet also sounds nice</p>",
        "id": 229200564,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1615135281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/225927371\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/transmutability/near/225924998\">said</a>:</p>\n<blockquote>\n<p>I noticed that. Is that limitation just an over-zealous lint? There isn't any stability hazard there that I can see.</p>\n</blockquote>\n<p>This is the classic \"FRU doesn't work like everyone expects\".</p>\n<p>The desugar moves all the fields that aren't mentioned, and <code>non_exhaustive</code> doesn't promise that those will be public.</p>\n</blockquote>\n<p>Why does this mean that <code>Foo { public, ..rest() }</code> shouldn't work when <code>Foo</code> is <code>#[non_exhaustive]</code>? I'm failing to see the hazard myself.</p>",
        "id": 240901455,
        "sender_full_name": "Sergio",
        "timestamp": 1622530727
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">public</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">private</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">rest</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">todo!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">foo</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">public</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">rest</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0451</span><span class=\"p\">]</span>: <span class=\"nc\">field</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">private</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"err\">`</span><span class=\"n\">foo</span>::<span class=\"n\">Foo</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">private</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">src</span><span class=\"o\">/</span><span class=\"n\">main</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">12</span>:<span class=\"mi\">24</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">public</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">rest</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\">                        </span><span class=\"o\">^^^^^^</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">private</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">private</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>#[non_exhaustive]</code> doesn't guarantee that <code>struct Foo { pub public: u8 }</code> doesn't turn into <code>struct Foo { pub public: u8, private: u8 }</code>, which would break FRU.</p>",
        "id": 240905473,
        "sender_full_name": "bjorn3",
        "timestamp": 1622533569
    }
]