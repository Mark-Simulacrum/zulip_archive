[
    {
        "content": "<p>I have an RFC draft on refining trait interfaces in implementations: <a href=\"https://rust-lang.github.io/async-fundamentals-initiative/RFC/refined_impls.html\">https://rust-lang.github.io/async-fundamentals-initiative/RFC/refined_impls.html</a></p>",
        "id": 275871279,
        "sender_full_name": "tmandry",
        "timestamp": 1647643322
    },
    {
        "content": "<p>feedback is welcome</p>",
        "id": 275871288,
        "sender_full_name": "tmandry",
        "timestamp": 1647643325
    },
    {
        "content": "<p>(cross posted from <a href=\"#narrow/stream/187312-wg-async/topic/refined.20trait.20impls\">this stream in #wg-async</a>)</p>",
        "id": 275871321,
        "sender_full_name": "tmandry",
        "timestamp": 1647643355
    },
    {
        "content": "<p>Has syntax like the following that allows users to not repeat function signatures on trait impls ever been discussed for Rust (obviously bikesheddable)?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">TraitA</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">TypeB</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">_</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Note that this does not increase the amount of inference, because the actual function signature can still be known from the trait and function name.</p>\n<p>If this is still something that is on the table, then I think the interaction of these features should be considered, to make sure they're compatible in whatever form we envision them</p>",
        "id": 275873962,
        "sender_full_name": "Jake",
        "timestamp": 1647645490
    },
    {
        "content": "<p>Good point <span class=\"user-mention\" data-user-id=\"310518\">@Jake</span>, it's not clear how that would interact with this proposal. I'm thinking the answer has to be that the <code>_</code> resolves to the concrete type for that feature to be useful.</p>",
        "id": 275877821,
        "sender_full_name": "tmandry",
        "timestamp": 1647649258
    },
    {
        "content": "<p>I guess one alternative is to use <code>-&gt; _</code> inside of trait impls as a shortcut to mean \"whatever the trait says\" and not do any inference. But then I don't think it should be allowed outside of trait impls.</p>",
        "id": 275877919,
        "sender_full_name": "tmandry",
        "timestamp": 1647649357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275877919\">said</a>:</p>\n<blockquote>\n<p>I guess one alternative is to use <code>-&gt; _</code> inside of trait impls as a shortcut to mean \"whatever the trait says\" and not do any inference. But then I don't think it should be allowed outside of trait impls.</p>\n</blockquote>\n<p>Sorry, I should have been more clear. Yes, this is exactly what I'm suggesting the feature could look like</p>",
        "id": 275877931,
        "sender_full_name": "Jake",
        "timestamp": 1647649385
    },
    {
        "content": "<p>Ah, after rereading your question it was clear, I was just pattern matching against another proposal I've seen to let <code>_</code> mean \"inferred return type\" (like <code>impl Trait</code> but without the opaqueness)</p>",
        "id": 275878005,
        "sender_full_name": "tmandry",
        "timestamp": 1647649453
    },
    {
        "content": "<p>Ah, I see. Yeah, the only problem that this feature would solve is that \"trait method signatures are inherently unnecessary and occasionally annoying to write\"</p>",
        "id": 275878049,
        "sender_full_name": "Jake",
        "timestamp": 1647649509
    },
    {
        "content": "<p>My concern is specifically about how the where clauses would be chosen for the <code>(..) -&gt; _</code> case once more than one possible set of where clauses is allowed</p>",
        "id": 275878110,
        "sender_full_name": "Jake",
        "timestamp": 1647649564
    },
    {
        "content": "<p>For that specific issue I could imagine requiring the user to write <code>where ...</code> or something like that.</p>",
        "id": 275878183,
        "sender_full_name": "tmandry",
        "timestamp": 1647649682
    },
    {
        "content": "<p>That said, this feature feels a bit too hypothetical/underspecified to me to include in the RFC</p>",
        "id": 275878229,
        "sender_full_name": "tmandry",
        "timestamp": 1647649708
    },
    {
        "content": "<p>Yeah, I agree it shouldn't be in the RFC, I'd just like to check that we're not accidentally preventing ourselves from adding this feature in the future</p>",
        "id": 275878237,
        "sender_full_name": "Jake",
        "timestamp": 1647649733
    },
    {
        "content": "<p>It's not clear to me that it is okay to just remove any of the where clauses from the trait in the impl.<br>\ni.e. a trait fn <code>fn foo&lt;T: Trait&lt;Assoc = u32&gt;&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code><br>\nimplemented as <code>fn foo&lt;T: Trait&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code> is not compatible with the trait definition</p>",
        "id": 275879686,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1647651381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> I wonder if it'd be worth trying to determine some common cases where the wider bounds would not be desired.</p>\n<p>For example, <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8f5d2ab7562c499160576187fd5e6b6f\">this compiles today</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Extend</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">extend</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">unimplemented!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But it's not obvious to me that <code>Foo.extend(\"hello\")</code> compiling with that <code>impl</code> is good.</p>",
        "id": 275879687,
        "sender_full_name": "scottmcm",
        "timestamp": 1647651382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275879686\">said</a>:</p>\n<blockquote>\n<p>It's not clear to me that it is okay to just remove any of the where clauses from the trait in the impl.<br>\ni.e. a trait fn <code>fn foo&lt;T: Trait&lt;Assoc = u32&gt;&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code><br>\nimplemented as <code>fn foo&lt;T: Trait&gt;(&amp;self) -&gt; &lt;T as Trait&gt;::Assoc</code> is not compatible with the trait definition</p>\n</blockquote>\n<p>Interesting.. but I actually think it is compatible. Callers through the trait interface will have to prove the <code>&lt;T as Trait&gt;::Assoc = u32</code> bound, and the refined interface promises that <code>&lt;T as Trait&gt;::Assoc</code> will be returned, so we know the return type will be correct. Callers through the impl interface will be able to use and get back any type for <code>&lt;T as Trait&gt;::Assoc</code></p>",
        "id": 275881071,
        "sender_full_name": "tmandry",
        "timestamp": 1647653012
    },
    {
        "content": "<p>oh right yes..its far too late for me to be thinking about type system stuff <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 275881134,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1647653095
    },
    {
        "content": "<p>A key point that seems to trip people up here is that where clauses are always proven by the caller. They don't exist to bind the function implementation</p>",
        "id": 275881140,
        "sender_full_name": "tmandry",
        "timestamp": 1647653105
    },
    {
        "content": "<p>(fwiw, I wasted several hours during the design phase of this RFC because I forgot that)</p>",
        "id": 275881231,
        "sender_full_name": "tmandry",
        "timestamp": 1647653199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275879687\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> I wonder if it'd be worth trying to determine some common cases where the wider bounds would not be desired.</p>\n</blockquote>\n<p>This seems like a good idea. I haven't spent much time thinking about that. Part of me wants to defer to crawling <a href=\"http://crates.io\">crates.io</a> and looking at actual examples</p>",
        "id": 275881347,
        "sender_full_name": "tmandry",
        "timestamp": 1647653389
    },
    {
        "content": "<p>That specific example is interesting but I'm not sure what to take away from it. Maybe functions that unconditionally panic should be given more scrutiny, because there may be no way to actually implement them... but it also seems unlikely that those functions would be <code>pub</code> in a published crate / something with semver constraints</p>",
        "id": 275881488,
        "sender_full_name": "tmandry",
        "timestamp": 1647653559
    },
    {
        "content": "<p>Yeah, any single-method trait is far less likely to do something like this, I agree.  But coming from Java-like languages it's very common to have interfaces that just <code>throw new NotSupportedException()</code> in shipped code, so while that's probably less common in Rust, it doesn't seem completely unlikely.</p>\n<p>One piece of that example I do think is interesting is that the the trait's generic type ends up completely unused.  I don't know if that could be a heuristic -- for lifetimes it's common to not use them, but for a type parameter is seems potentially more unusual, especially when the argument <em>is</em> used in the trait definition.</p>\n<p>Another thing that came to mind: how would provided implementations of things work with this?  Suppose I wrote </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Should the <code>nth</code> also be considered <code>const fn</code>?</p>",
        "id": 275883310,
        "sender_full_name": "scottmcm",
        "timestamp": 1647656014
    },
    {
        "content": "<p>Related to refined trait impls, there is an intersection with <code>generic_associated_types</code> which seems quite important for that feature to be more user-friendly: the <code>type Assoc&lt;'a&gt; where Self : 'a</code> kind of associated types, could be filled with a refined implementation that does not care about the <code>Self : 'a</code> bound on <code>'a</code>, similar to the loosened bounds for methods.</p>",
        "id": 275929537,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1647723791
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20'a.60.3F/near/273480813\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/When.20do.20GATs.20implementations.20need.20.60Self.3A.20'a.60.3F/near/273480813</a> for more info/context</p>",
        "id": 275929544,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1647723828
    },
    {
        "content": "<p>I find the use of \"more specific\" to refer to impling <code>fn method(impl Foo + Bar)</code> as <code>fn method(impl Foo)</code> mildly annoying. That's going more general, since the types that implement <code>Foo</code> are a superset of those that implement  <code>Foo + Bar</code>.</p>\n<p>The use of \"more specific\" for return types makes sense though.</p>",
        "id": 275951584,
        "sender_full_name": "matt1992",
        "timestamp": 1647758416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/refined.20trait.20impls/near/275883310\">said</a>:</p>\n<blockquote>\n<p>Another thing that came to mind: how would provided implementations of things work with this?  Suppose I wrote </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Should the <code>nth</code> also be considered <code>const fn</code>?</p>\n</blockquote>\n<p>That is a good question and instance of a more general problem. I could imagine having some kind of annotation like <code>const(where const Self::next)</code> for this. You could also use that for methods of generic types. Related to the <code>~const</code> we have today (I always forget what that means)</p>",
        "id": 276120532,
        "sender_full_name": "tmandry",
        "timestamp": 1647900539
    },
    {
        "content": "<p>Opened the RFC PR: <a href=\"https://github.com/rust-lang/rfcs/issues/3245\">rust-lang/rfcs#3245</a></p>",
        "id": 276220511,
        "sender_full_name": "tmandry",
        "timestamp": 1647968217
    },
    {
        "content": "<p>Hmm, I've just realized that where refined impls <em>w.r.t.</em> bounds are accepted today, making call sites suddenly start using the looser function signatures can lead to type inference errors:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">EqTo</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">EqTo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">assoc</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span>: <span class=\"nc\">Is</span><span class=\"o\">&lt;</span><span class=\"n\">EqTo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// refined impl</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">assoc</span><span class=\"o\">&lt;</span><span class=\"n\">__</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">_check</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// and what if we just had `T : ?Sized`?</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>::<span class=\"n\">assoc</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I know type inference errors are acceptable provided crater shows they're low impact, but since I haven't seen that mentioned in the RFC, at least not super-explicitly, I think it could deserve a mention in the Drawbacks section.</p>",
        "id": 276338076,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1648044452
    }
]