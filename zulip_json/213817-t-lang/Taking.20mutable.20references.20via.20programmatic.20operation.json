[
    {
        "content": "<p>I had an idea yesterday for an operation that I think makes sense and would be sound, but isn't currently possible in Rust. I'm trying to figure out the exact semantics and whether I'm missing anything that would make it unsound.</p>",
        "id": 182596071,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575491701
    },
    {
        "content": "<p>How mutable references work today:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// cannot touch x here</span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// prints 20</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182596101,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575491724
    },
    {
        "content": "<p>But you can't, today, write a <em>function</em> with the same semantics as the operation <code>&amp;mut x</code>.</p>",
        "id": 182596131,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575491750
    },
    {
        "content": "<p>Hypothetical:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">get_mut_ref</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// cannot touch x here.</span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// prints 20</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182596186,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575491765
    },
    {
        "content": "<p>The semantics I'm looking for would also allow writing a function that could return a mutable reference of a <em>different</em> type that was still tied to the owned value it mutably-referenced.</p>",
        "id": 182596271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575491832
    },
    {
        "content": "<p>I'm a bit confused -- isn't this already true of all methods that take <code>&amp;mut self</code> and return <code>&amp;mut U</code>?</p>",
        "id": 182596352,
        "sender_full_name": "simulacrum",
        "timestamp": 1575491883
    },
    {
        "content": "<p>For instance:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">get_mut_ref_to_bytes</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// cannot touch x here.</span>\n<span class=\"w\">        </span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// assuming little-endian for the sake of example</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// prints 20</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182596359,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575491886
    },
    {
        "content": "<p>(e.g., for your last example, <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=0aebe3e2d489b2a645b836f2d9b49a1e\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=0aebe3e2d489b2a645b836f2d9b49a1e\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=0aebe3e2d489b2a645b836f2d9b49a1e</a>)</p>",
        "id": 182596614,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Wait, that's legal?</p>",
        "id": 182596658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492091
    },
    {
        "content": "<p>You can consume <code>&amp;mut self</code> and return <code>&amp;mut OtherType</code>?</p>",
        "id": 182596679,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492106
    },
    {
        "content": "<p>My understanding is yes, for sure. (Indeed, this is a frequent <em>pain</em> point)</p>",
        "id": 182596749,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492126
    },
    {
        "content": "<p>Do the lifetime semantics actually work just like you have a <code>&amp;mut</code> referencing that owned type?</p>",
        "id": 182596753,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492129
    },
    {
        "content": "<p>the lifetime of both <code>&amp;mut</code> is the same</p>",
        "id": 182596775,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492142
    },
    {
        "content": "<p>And you <em>can't</em> mutably reference the original type anymore, because that would alias? Because it seems like the <code>transmute</code> you show produces aliased <code>&amp;mut</code> values which would be UB...</p>",
        "id": 182596805,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492160
    },
    {
        "content": "<p>it does not, because it consumes the previous <code>&amp;mut</code> (or so I understand it)</p>",
        "id": 182596846,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492181
    },
    {
        "content": "<p>I didn't know you could \"consume\" a <code>&amp;mut</code>.</p>",
        "id": 182596864,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492192
    },
    {
        "content": "<p>That's useful, and if that's the semantic, that's incredibly helpful. Is there somewhere I could read more about that semantic and verify?</p>",
        "id": 182596900,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492211
    },
    {
        "content": "<p>I'm a bit confused, I guess</p>",
        "id": 182596911,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492220
    },
    {
        "content": "<p>Damn, that's a pretty cool way to have bit/byte fiddling.</p>",
        "id": 182596915,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575492221
    },
    {
        "content": "<p>Like, which semantic is this?</p>",
        "id": 182596919,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492225
    },
    {
        "content": "<p>On a basic level, <code>&amp;mut T</code> does not implement Copy, so it is moved. Reborrows make that slightly complicated though.</p>",
        "id": 182596926,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575492230
    },
    {
        "content": "<p>This is in the context of the \"safe transmute\" proposal.</p>",
        "id": 182596931,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> The standard mutable reference semantic. \"You can only take a mutable reference to a value you own, once you've taken a mutable reference you can't use the original until you drop that mutable reference, once you drop that mutable reference you can use the original owned value again\".</p>",
        "id": 182597054,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492291
    },
    {
        "content": "<p>so I think that's not really how I'd say that (it's sort of a \"beginners view\" imo)</p>",
        "id": 182597103,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492321
    },
    {
        "content": "<p>there's no difference between <code>Foo&lt;'a, T&gt;</code> and <code>&amp;mut T</code></p>",
        "id": 182597162,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492358
    },
    {
        "content": "<p>(modulo GATs not being a thing)</p>",
        "id": 182597211,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492367
    },
    {
        "content": "<p>I thought the difference was that you can have more than one <code>&amp;T</code> or <code>Foo&lt;'a, T&gt;</code> at a time, but not more than one <code>&amp;mut T</code>?</p>",
        "id": 182597257,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492398
    },
    {
        "content": "<p>well, <code>&amp;mut T</code> is basically just an owned T</p>",
        "id": 182597304,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492424
    },
    {
        "content": "<p>borrow check only cares about the lifetime, not the type</p>",
        "id": 182597314,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492435
    },
    {
        "content": "<p>So what prevents having a <code>&amp;mut T</code> and a <code>&amp;T</code> to the same <code>T</code> at the same time?</p>",
        "id": 182597429,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492484
    },
    {
        "content": "<p><em>Creating</em> a (shared or mutable) reference is a special operation that the borrow checker understands to create what's internally called a \"loan\" of the place (which can itself be shared or mutable/exclusive), but this loan is linked to a <em>lifetime</em> <code>'a</code> and thus to all values whose type contains <code>'a</code>, regardless of what that type is.</p>",
        "id": 182597484,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575492512
    },
    {
        "content": "<p>this is actually sort of why a signature like <code>fn(&amp;mut T) -&gt; &amp;U</code> is really painful, too</p>",
        "id": 182597667,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492617
    },
    {
        "content": "<p>A nice resource for this might be <a href=\"https://nikomatsakis.github.io/rust-belt-rust-2019/\" target=\"_blank\" title=\"https://nikomatsakis.github.io/rust-belt-rust-2019/\">https://nikomatsakis.github.io/rust-belt-rust-2019/</a></p>",
        "id": 182597674,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575492623
    },
    {
        "content": "<p>🤯</p>",
        "id": 182597683,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575492629
    },
    {
        "content": "<p>as borrow check doesn't know that you've \"lost\" the mutable ref</p>",
        "id": 182597684,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492631
    },
    {
        "content": "<p>OK. So once you <em>have</em> a mutable/exclusive loan of the location, you can safely and without UB turn it into a <em>different</em> mutable/exclusive loan of the location?</p>",
        "id": 182597699,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Ah. So <code>fn foo(&amp;mut T) -&gt; &amp;T</code> kinda gives you a non-mut reference \"backed\" by an exclusive loan?</p>",
        "id": 182597744,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492679
    },
    {
        "content": "<p>correct, so long as that \"turn it into\" is a move-like operation (i.e., happens once)</p>",
        "id": 182597753,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492684
    },
    {
        "content": "<p>Yes</p>",
        "id": 182597755,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492686
    },
    {
        "content": "<p>Does the compiler actually <em>enforce</em> that it's a move-like operation? Or do you just have to never touch self again once you've transmuted?</p>",
        "id": 182597790,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492721
    },
    {
        "content": "<p><a href=\"https://github.com/rust-embedded/wg/blob/master/rfcs/0377-mutex-trait.md#the-rust-standard-library-mutex-uses-self-for-the-lock-method-why-choose-mut-self\" target=\"_blank\" title=\"https://github.com/rust-embedded/wg/blob/master/rfcs/0377-mutex-trait.md#the-rust-standard-library-mutex-uses-self-for-the-lock-method-why-choose-mut-self\">https://github.com/rust-embedded/wg/blob/master/rfcs/0377-mutex-trait.md#the-rust-standard-library-mutex-uses-self-for-the-lock-method-why-choose-mut-self</a> may also be interesting for you to read (sort of tangentially related)</p>",
        "id": 182597791,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492721
    },
    {
        "content": "<blockquote>\n<p>Does the compiler actually <em>enforce</em> that it's a move-like operation? Or do you just have to never touch self again once you've transmuted?</p>\n</blockquote>\n<p>In the case, I showed, yes -- mem::transmute cannot be called more than once, you'll get a \"use after move\"</p>",
        "id": 182597869,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492772
    },
    {
        "content": "<p>Ah, because you're \"moving\" <code>&amp;mut self</code>?</p>",
        "id": 182597895,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492788
    },
    {
        "content": "<p>exactly</p>",
        "id": 182597901,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492794
    },
    {
        "content": "<p>Same semantics as \"consuming\" any other owned value?</p>",
        "id": 182597902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492797
    },
    {
        "content": "<p><code>transmute</code> moves its argument and <code>&amp;mut T</code> isn't Copy so I <em>think</em> it should be fine? But I am never sure where reborrows can happen so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 182597903,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575492797
    },
    {
        "content": "<p>So, wait a moment...</p>",
        "id": 182597934,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492811
    },
    {
        "content": "<p>to my knowledge we never reborrow in a function call that takes a non-reference type, but I may be wrong about that (e.g., around <code>impl AsRef</code>)</p>",
        "id": 182597981,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492839
    },
    {
        "content": "<p>What happens if I write:</p>\n<div class=\"codehilite\"><pre><span></span>let x: &amp;mut T = &amp;mut some_t_I_own;\nfoo(x); // takes &amp;mut T\nbar(x); // takes &amp;mut T\n</pre></div>",
        "id": 182598033,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492862
    },
    {
        "content": "<p>Does <code>bar(x)</code> fail to compile because <code>foo(x)</code> consumed <code>x</code>?</p>",
        "id": 182598050,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> So we could have <code>u32::as_mut_le_bytes</code> and it would be entirely safe?</p>",
        "id": 182598064,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575492892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> If that code works, then it's because it was reborrowed (i.e. <code>&amp;mut *x</code> was inserted) at the call sites</p>",
        "id": 182598110,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575492919
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> I don't think <code>as_mut_le_bytes</code> is implementable unless you're on an le platform. ;)</p>",
        "id": 182598128,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492937
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> Ah.</p>",
        "id": 182598137,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492944
    },
    {
        "content": "<p>OK then.</p>",
        "id": 182598143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492946
    },
    {
        "content": "<p>Well, I have a safe transmute proposal to rewrite then!</p>",
        "id": 182598155,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492956
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> So we could have <code>u32::as_mut_le_bytes</code> and it would be entirely safe?</p>\n</blockquote>\n<p>Well, I mean, yes, but it's unlikely to be what you want</p>",
        "id": 182598159,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492958
    },
    {
        "content": "<p>Thank you very much for the help!</p>",
        "id": 182598169,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492960
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Ah yes true, we could have <code>u32::as_mut_ne_bytes</code> though.</p>",
        "id": 182598221,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575492971
    },
    {
        "content": "<p>there's actually an issue to that effect, let me try to dig that up</p>",
        "id": 182598247,
        "sender_full_name": "simulacrum",
        "timestamp": 1575492985
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> I'm planning to spell that just <code>as_mut_bytes</code>. ;)</p>",
        "id": 182598268,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575492996
    },
    {
        "content": "<p>(or possibly <code>as_bytes_mut</code>)</p>",
        "id": 182598287,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575493007
    },
    {
        "content": "<p>I guess if there's only one method omitting <code>ne</code> would be fine. Though I would wonder if it's also possible to have it always work for a specific endianness?</p>",
        "id": 182598424,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575493087
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/64464\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64464\">https://github.com/rust-lang/rust/issues/64464</a></p>",
        "id": 182598442,
        "sender_full_name": "simulacrum",
        "timestamp": 1575493104
    },
    {
        "content": "<p>Is it possible to create a slice that goes in reverse of another slice?</p>",
        "id": 182598929,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575493368
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>| 0 | 1 | 2| 3 | 4 |\n      &lt;--------\n</pre></div>",
        "id": 182598986,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1575493398
    },
    {
        "content": "<blockquote>\n<p>Hypothetical: </p>\n</blockquote>\n<p>What am I missing? <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e595e943b7fa16f4cce4e728603d5870\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e595e943b7fa16f4cce4e728603d5870\">This just works</a>.</p>",
        "id": 182598999,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493409
    },
    {
        "content": "<p>No -- that issue mentions as such, slices always go \"forwards\"</p>",
        "id": 182599023,
        "sender_full_name": "simulacrum",
        "timestamp": 1575493425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> was not aware/misunderstanding something, I think</p>",
        "id": 182599098,
        "sender_full_name": "simulacrum",
        "timestamp": 1575493452
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> No, slices have to go forwards.</p>",
        "id": 182599136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575493478
    },
    {
        "content": "<p>Reading the whole thread. In C++ T&amp; aren't values, but in Rust, a <code>&amp;mut T</code> is just a normal value, and you can just move it around. Maybe that was causing the confusion?</p>",
        "id": 182599159,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493501
    },
    {
        "content": "<p>I think the cause of confusion is thinking of references as more special than they are, not realizing the generality of lifetime variables. A common mistake sadly encouraged by almost all of our documentation.</p>",
        "id": 182599313,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575493575
    },
    {
        "content": "<p>I definitely didn't have any confusion with C++ references, since I'm not a C++ developer. ;)</p>",
        "id": 182599329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575493587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> I didn't quite expect it <code>&amp;mut T</code> itself to have \"move\" semantics, and thus didn't realize this worked without mutable aliasing. I also didn't realize that a function from <code>&amp;mut self</code> to <code>&amp;mut U</code> would preserve the exclusivity of the borrow (or really <em>anything</em> about the borrow, if it used transmute).</p>",
        "id": 182599342,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575493603
    },
    {
        "content": "<p>I find useful to think of <code>&amp;mut T</code> as just <code>type MutRef = &amp;mut T;</code></p>",
        "id": 182599425,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493651
    },
    {
        "content": "<p>That's definitely the semantic I <em>wanted</em>, but it somehow felt too good to be true that it actually worked that way.</p>",
        "id": 182599599,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575493691
    },
    {
        "content": "<p>If you mentally replace it everywhere with <code>MutRef</code>, it looks like just a normal type name, and same rules applies</p>",
        "id": 182599601,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493693
    },
    {
        "content": "<p>(to be fully correct you need to add the life-time, but...)</p>",
        "id": 182599628,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493711
    },
    {
        "content": "<p>FWIW I had this aha moment at some point as well</p>",
        "id": 182599690,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493752
    },
    {
        "content": "<p>I don't know why but I also though that references were more special than they are (in C++ they are, and I came with a C++ background, so probably just extrapolated that to Rust).</p>",
        "id": 182599734,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575493785
    },
    {
        "content": "<p>Building on <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>'s suggestion, I would describe <code>&amp;mut</code> as <code>struct MutRef&lt;'a, T&gt;(*mut T, PhantomInvariant&lt;'a&gt;);</code> with some syntactic sugar. Except we don't have <code>PhantomInvariant</code>. (Can it even be defined without involving <code>&amp;mut</code>?)</p>",
        "id": 182599817,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575493812
    },
    {
        "content": "<p>I think so -- via trait objects</p>",
        "id": 182599928,
        "sender_full_name": "simulacrum",
        "timestamp": 1575493882
    },
    {
        "content": "<p>in particular IIRC <code>dyn Trait&lt;'a&gt;</code> is invariant over the <code>'a</code> because it could be <code>&amp;'a mut ()</code> internally or so</p>",
        "id": 182599981,
        "sender_full_name": "simulacrum",
        "timestamp": 1575493916
    },
    {
        "content": "<p>oh right</p>",
        "id": 182600079,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575493952
    },
    {
        "content": "<p>The confusion I had was that I assumed <code>&amp;mut T</code> being passed to a <code>&amp;mut T</code> parameter had something to do with <code>T</code> (or more to the point with the implicit lifetime <code>'a</code> in the <code>&amp;'a mut T</code>, and wasn't just completely opaque, because the compiler would need to track something something lifetimes.</p>",
        "id": 182600189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575494026
    },
    {
        "content": "<p>This is a major improvement in my understanding. :)</p>",
        "id": 182600200,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575494035
    },
    {
        "content": "<p><code>PhantomData&lt;Cell&lt;&amp;'a ()&gt;&gt;</code> is also invariant over the <code>'a</code> IIRC</p>",
        "id": 182600290,
        "sender_full_name": "lqd",
        "timestamp": 1575494074
    },
    {
        "content": "<p>(I think it certainly <em>can</em> -- with re-borrowing -- but that's sort of handwavy since there's no good reference to my knowledge when reborrowing can or can't occur</p>",
        "id": 182600364,
        "sender_full_name": "simulacrum",
        "timestamp": 1575494103
    },
    {
        "content": "<blockquote>\n<p>PhantomData&lt;Cell&lt;&amp;'a ()&gt;&gt; is also invariant over the 'a IIRC</p>\n</blockquote>\n<p>Yes that's correct.</p>",
        "id": 182600638,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575494285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> for reference, <code>bytemuck</code> already lets you cast <code>&amp;mut T</code> and <code>&amp;mut [T]</code> between the Pod types.</p>",
        "id": 182631244,
        "sender_full_name": "Lokathor",
        "timestamp": 1575527036
    },
    {
        "content": "<p>One other question on this, now that I understand mutable references a little better:<br>\nIs it legal, and semantically correct, to consume a mutable reference, produce a non-mutable reference with the same loan, then transmute that to a mutable reference with the same loan, and return that?</p>",
        "id": 182636773,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575533281
    },
    {
        "content": "<p>For instance, could I go from <code>&amp;mut T</code> to <code>&amp;T</code> to <code>&amp;U</code> to <code>&amp;mut U</code>, within a method that consumes a <code>&amp;mut T</code> and returns a <code>&amp;mut U</code>?</p>",
        "id": 182636843,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575533337
    },
    {
        "content": "<p>Not legal under stacked borrows I believe, or if there's a way to do it, it greatly depends on how exactly go from one reference type to another. But this has nothing to do with lifetimes, just with the principle that making a mutable reference from a shared one plays havoc with aliasing rules we want to have.</p>",
        "id": 182638327,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575534895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> Oh, interesting. In that case, I have a follow-on question...</p>",
        "id": 182638464,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535040
    },
    {
        "content": "<p>This is related to <a href=\"https://internals.rust-lang.org/t/pre-rfc-v2-safe-transmute/11431/1\" target=\"_blank\" title=\"https://internals.rust-lang.org/t/pre-rfc-v2-safe-transmute/11431/1\">https://internals.rust-lang.org/t/pre-rfc-v2-safe-transmute/11431/1</a></p>",
        "id": 182638509,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535083
    },
    {
        "content": "<p>Suppose I have a trait that provides a function from <code>&amp;T</code> to <code>&amp;U</code>, which is a safe wrapper around <code>std::mem::transmute</code> with requirements that ensure it's safe.</p>",
        "id": 182638556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535119
    },
    {
        "content": "<p>Suppose I also have traits that provide safe functions from <code>&amp;T</code> to and from byte slices.</p>",
        "id": 182638567,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535138
    },
    {
        "content": "<p>I'd like to have this function (inside the <code>ToBytes</code> trait):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">cast_mut</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">FromBytes</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">FromBytesError</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">Self</span>: <span class=\"nc\">FromAnyBytes</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/*...*/</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182638627,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535189
    },
    {
        "content": "<p>The <code>FromBytes</code> trait provides a method from <code>&amp;[u8]</code> to <code>&amp;T</code>.</p>",
        "id": 182638695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535227
    },
    {
        "content": "<p>It doesn't provide a method to get a <code>&amp;mut T</code> because that's not safe without additional guarantees (namely those enforced by <code>cast_mut</code> above).</p>",
        "id": 182638715,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535251
    },
    {
        "content": "<p>Does that make that function un-implementable, even though it otherwise has all the requirements it needs to do so safely?</p>",
        "id": 182638818,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535327
    },
    {
        "content": "<p>It would be possible to have <code>cast_mut</code> transmute directly from <code>&amp;mut Self</code> to <code>&amp;mut T</code> without going via <code>T::from_bytes</code>, but that would require <code>T: FromAnyBytes</code> rather than <code>T: FromBytes</code>, which would exclude types like <code>bool</code> that need to validate the bytes first.</p>",
        "id": 182638958,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575535468
    },
    {
        "content": "<p>Couldn't you downgrade the &amp;mut Self to &amp;Self, try the FromBytes cast, and if it succeeds do the transmute from self to &amp;mut T directly, ignoring the &amp;T you got from FromBytes?</p>",
        "id": 182639479,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575536068
    },
    {
        "content": "<p>Alternatively, have FromBytes provide the validation separately from the cast (presumably the cast could then be a provided method)</p>",
        "id": 182639517,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1575536109
    },
    {
        "content": "<p>...we could, yes. That seems <em>wasteful</em>, but that would work.</p>",
        "id": 182639525,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575536117
    },
    {
        "content": "<p>I guess if it gets inlined the waste won't actually matter.</p>",
        "id": 182639543,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575536144
    },
    {
        "content": "<p>And factoring out the validation seems nice, too.</p>",
        "id": 182639827,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575536401
    },
    {
        "content": "<p>Is there a way to have a trait method that you <em>can't</em> override, and can only take the default implementation of? Or would that require having a sealed trait that's implemented for the unsealed trait?</p>",
        "id": 182639902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575536439
    },
    {
        "content": "<p>Josh I think your whole plan is fundamentally a bad path</p>",
        "id": 182639977,
        "sender_full_name": "Lokathor",
        "timestamp": 1575536515
    },
    {
        "content": "<p>casting should always be cheap</p>",
        "id": 182640043,
        "sender_full_name": "Lokathor",
        "timestamp": 1575536532
    },
    {
        "content": "<p>if you let user logic in that's a bad time</p>",
        "id": 182640050,
        "sender_full_name": "Lokathor",
        "timestamp": 1575536540
    },
    {
        "content": "<p><code>core::mem::transmute</code> is unsafe because it's too permissive, but it's fundamentally the correct design from an API usage perspective</p>",
        "id": 182640266,
        "sender_full_name": "Lokathor",
        "timestamp": 1575536749
    },
    {
        "content": "<p>unfortunately it's 2am my zone, so if you want more you'll have to catch me again some time</p>",
        "id": 182640364,
        "sender_full_name": "Lokathor",
        "timestamp": 1575536845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Casting <em>should</em> always be cheap, yes. But, for instance, if the options are \"you can't safely cast a byte to bool\" or \"you can cast a byte to bool with a single check to make sure the byte is 0 or 1\", I'll take the latter.</p>",
        "id": 182640709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575537205
    },
    {
        "content": "<p>Casting from bytes to <code>u32</code> should optimize down to no code, because any possible bytes are a valid <code>u32</code>.</p>",
        "id": 182640774,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575537249
    },
    {
        "content": "<p>Casting from bytes to <code>bool</code> has to either validate or be unsafe.</p>",
        "id": 182640782,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575537262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> It's 1am my time as well, and I'm going to sleep too. We can talk more another time; I'd very much like to get your feedback.</p>",
        "id": 182641023,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575537512
    },
    {
        "content": "<blockquote>\n<p>For instance, could I go from &amp;mut T to &amp;T to &amp;U to &amp;mut U, within a method that consumes a &amp;mut T and returns a &amp;mut U?</p>\n</blockquote>\n<p>You can't go from <code>&amp;</code> to <code>&amp;mut</code>, but you can go from <code>&amp;mut -&gt; usize  (or (usize,usize))-&gt; &amp;mut</code>.</p>",
        "id": 182642624,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575538983
    },
    {
        "content": "<blockquote>\n<p>Casting from bytes to u32 should optimize down to no code, because any possible bytes are a valid u32.</p>\n</blockquote>\n<p>Is that so? You can't safely cast a <code>MaybeUninit&lt;u32&gt;</code> to an <code>u32</code> (or at least, not today), because not all bitpatterns that the storage of an u32 can take are valid for u32.</p>",
        "id": 182642723,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> Yes, that's so. These traits specifically support casting from <code>&amp;[u8]</code>, which is necessarily already initialized.</p>",
        "id": 182642891,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539203
    },
    {
        "content": "<p>Also, yes, all bit patterns that the storage of a <code>u32</code> can take are valid for <code>u32</code>. The problem with <code>MaybeUninit</code> is the UB of reading uninitialized memory. That doesn't apply to <code>[u8]</code>.</p>",
        "id": 182642940,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539265
    },
    {
        "content": "<blockquote>\n<p>Also, yes, all bit patterns that the storage of a u32 can take are valid for u32.</p>\n</blockquote>\n<p>This is wrong, or at least, this is not the case today. For example, the 0xUU bitpattern isn't valid for u32.</p>",
        "id": 182642990,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539296
    },
    {
        "content": "<p>I'm talking about real machines with real bits. :P</p>",
        "id": 182643006,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539313
    },
    {
        "content": "<p>Ah, I was talking about Rust.</p>",
        "id": 182643014,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539329
    },
    {
        "content": "<p>Not the LLVM abstract model and the concept of \"undef\", which, again, <em>doesn't apply to <code>[u8]</code></em>.</p>",
        "id": 182643031,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539348
    },
    {
        "content": "<p>I didn't say anything about LLVM.</p>",
        "id": 182643056,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539396
    },
    {
        "content": "<p>If you have a <code>[u8]</code> and it points to unitialized memory, you've <em>already</em> done something wrong. The operation from <code>&amp;[u8]</code> to <code>&amp;u32</code> doesn't do anything wrong.</p>",
        "id": 182643105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539414
    },
    {
        "content": "<p>0xUU isn't a bit pattern.</p>",
        "id": 182643127,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539430
    },
    {
        "content": "<blockquote>\n<p>If you have a [u8] and it points to unitialized memory, you've already done something wrong. The operation from &amp;[u8] to &amp;u32 doesn't do anything wrong.</p>\n</blockquote>\n<p>That's correct.</p>",
        "id": 182643139,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539444
    },
    {
        "content": "<blockquote>\n<p>0xUU isn't a bit pattern.</p>\n</blockquote>\n<p>What's the bitpattern of <code>MaybeUninit::&lt;u8&gt;::uninit()</code> ?</p>",
        "id": 182643182,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539499
    },
    {
        "content": "<p>Something in the range 0x00 to 0xFF and you don't know what.</p>",
        "id": 182643261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539558
    },
    {
        "content": "<p>I'm not (today) attempting to have an argument about the UB of reading uninitialized memory.</p>",
        "id": 182643278,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539578
    },
    {
        "content": "<blockquote>\n<p>Something in the range 0x00 to 0xFF and you don't know what.</p>\n</blockquote>\n<p>This is incorrect.</p>",
        "id": 182643306,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539605
    },
    {
        "content": "<p>Please don't attempt to define the words I'm using. Feel free to define words you're using.</p>",
        "id": 182643408,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539662
    },
    {
        "content": "<p>Let's try this again. It's 1:53am. I have <em>zero</em> interest in hearing yet another treatise on UB.</p>",
        "id": 182643412,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539669
    },
    {
        "content": "<p>I use the rust abstract machine definitions, which defines all rust bits as being 0, 1, or U.</p>",
        "id": 182643445,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539718
    },
    {
        "content": "<p>I'm talking about hardware, and bit patterns that can <em>actually appear in memory</em>, and a cast operation that goes from <code>&amp;[u8]</code> to <code>&amp;T</code>. So I don't have to care about uninitialized memory, thankfully.</p>",
        "id": 182643446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539719
    },
    {
        "content": "<p>Please take it to a thread that's about uninitialized memory. Not everyone talking about bit patterns in actual memory is talking about an abstract machine.</p>",
        "id": 182643548,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575539763
    },
    {
        "content": "<p>Your assumption that <code>MaybeUninit::&lt;u8&gt;::uninit()</code> is a bit pattern in range 0x00 and 0xFF is wrong, and would mean that:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>is a safe operation, and that </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">assume_init</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">assume_init</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>never panics. Yet the <code>.assume_init()</code> is UB, and anything can happen.</p>",
        "id": 182643649,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575539809
    },
    {
        "content": "<p>Please stop trying to redefine the terms I'm using, and please stop assuming I don't understand Rust just because I'm not using the terms you prefer.</p>",
        "id": 182643919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575540025
    },
    {
        "content": "<p>Bytes in memory always have a value. The Rust abstract machine defines the behavior of the compiler, not the hardware. And for the purposes of this thread, I don't <em>care</em> about uninitialized memory because I'm dealing with <code>[u8]</code>.</p>",
        "id": 182643957,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575540073
    },
    {
        "content": "<p><a href=\"#narrow/stream/213817-t-lang/topic/Taking.20mutable.20references.20via.20programmatic.20operation/near/182642891\" title=\"#narrow/stream/213817-t-lang/topic/Taking.20mutable.20references.20via.20programmatic.20operation/near/182642891\">I agreed with you on the first line of this conversation that for <code>[u8]</code> there is no problem</a>.  Yet you keep repeating that all bitpatterns are valid for <code>u32</code>, which I think is incorrect for the purpose of designing a safe transmute trait which appears to be your goal.</p>",
        "id": 182645371,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575541365
    },
    {
        "content": "<blockquote>\n<p>I'm not using the terms you prefer.</p>\n</blockquote>\n<p>I'm using the terms most people talking about this have agreed on and that we have in writing. If everybody defines these terms to mean something differently, communication becomes really hard.</p>",
        "id": 182645521,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575541498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> wrote:</p>\n<blockquote>\n<p>there's no difference between <code>Foo&lt;'a, T&gt;</code> and <code>&amp;mut T</code></p>\n</blockquote>\n<p>by the way: This is not quite true. Namely, <code>Foo</code> may be <em>covariant</em> or <em>invariant</em> with respect to  <code>T</code>, while <code>&amp;'a mut T</code> is always invariant with respect to <code>T</code>.  (The variance of <code>Foo</code> is based inferred on the ADT-definition of <code>Foo</code>; there's currently no way to declare variance explicitly.)</p>",
        "id": 182647910,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575543408
    },
    {
        "content": "<p>(See <a href=\"https://doc.rust-lang.org/nightly/nomicon/phantom-data.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nomicon/phantom-data.html\">https://doc.rust-lang.org/nightly/nomicon/phantom-data.html</a> for variances)</p>",
        "id": 182663205,
        "sender_full_name": "centril",
        "timestamp": 1575555803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> in case you haven read it, <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>'s <a href=\"https://www.ralfj.de/blog/2019/07/14/uninit.html\" target=\"_blank\" title=\"https://www.ralfj.de/blog/2019/07/14/uninit.html\">https://www.ralfj.de/blog/2019/07/14/uninit.html</a> is a good read</p>",
        "id": 182663347,
        "sender_full_name": "centril",
        "timestamp": 1575555895
    },
    {
        "content": "<p>Also relevant:<br>\n- <a href=\"https://arxiv.org/abs/1903.00982\" target=\"_blank\" title=\"https://arxiv.org/abs/1903.00982\">https://arxiv.org/abs/1903.00982</a><br>\n- <a href=\"https://aaronweiss.us/pubs/popl19-src-oxide-slides.pdf\" target=\"_blank\" title=\"https://aaronweiss.us/pubs/popl19-src-oxide-slides.pdf\">https://aaronweiss.us/pubs/popl19-src-oxide-slides.pdf</a></p>",
        "id": 182663886,
        "sender_full_name": "centril",
        "timestamp": 1575556279
    },
    {
        "content": "<p>I don't think that safe transmuting uninit to init was ever on the table, or being proposed.<br>\nIn the absence of a freeze intrinsic, that's clearly abstract machine UB.<br>\nWe are pre-supposing that you have initialized memory in one type and want it in a new type.<br>\nThe problem of uninitialized memory is an entirely different beast to attack, in some other topic elsewhere.</p>",
        "id": 182706002,
        "sender_full_name": "Lokathor",
        "timestamp": 1575581108
    },
    {
        "content": "<p>That said, accidentally reading uninit memory <em>is a valid concern</em>, which absolutely limits which types can be part of any particular safe-casting framework, for example <code>#[repr(C)]struct Ex {a: u16, b:u8}</code> <strong>can't</strong> be safe cast to <code>[u8;4]</code> even though the size/align would otherwise allow it, because you'd be exposing an uninit byte in the index 3 position of the output array.</p>",
        "id": 182710072,
        "sender_full_name": "Lokathor",
        "timestamp": 1575583624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> That's why the <code>ToBytes</code> type we proposed doesn't allow implementations for that type, because it contains padding (at the end).</p>",
        "id": 182710967,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575584258
    },
    {
        "content": "<p>We're carefully defining the semantics to <em>avoid</em> reading uninitialized memory, rather than attempting to define semantics <em>for</em> reading uninitialized memory.</p>",
        "id": 182711034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575584286
    },
    {
        "content": "<p>Right, that was an, \"in gnzlbg's defense they've partly got a point\" sort of note ;3</p>",
        "id": 182715461,
        "sender_full_name": "Lokathor",
        "timestamp": 1575588448
    },
    {
        "content": "<blockquote>\n<p>Not the LLVM abstract model and the concept of \"undef\", which, again, <em>doesn't apply to <code>[u8]</code></em>.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  of course it does? I do not understand why you bring up <code>u8</code> as if it was a special case. It is not.</p>\n<blockquote>\n<p>I'm talking about real machines with real bits. :P</p>\n</blockquote>\n<p>So you are writing assembly code then? Because if you are writing Rust, real machines don't matter. (Well yeah I know I am exaggerating but it's not entirely wrong either.)</p>",
        "id": 182836444,
        "sender_full_name": "RalfJ",
        "timestamp": 1575709819
    },
    {
        "content": "<blockquote>\n<p>Bytes in memory always have a value. The Rust abstract machine defines the behavior of the compiler, not the hardware.</p>\n</blockquote>\n<p>True. But as long as you are writing Rust code, it is fundamentally impossible to use hardware-level concepts to reason about your code.</p>",
        "id": 182836464,
        "sender_full_name": "RalfJ",
        "timestamp": 1575709883
    },
    {
        "content": "<p>So if you want to make an argument about how your Rust code behaves, the <em>only option</em> you have is the Rust Abstract machine. A safe function that transmutes <code>MaybeUninit&lt;u8&gt;</code> to <code>u8</code> is unsound, can cause UB on the Rust Abstract Machine, and can lead to real bugs in the compiled program. It is of upmost importance that a safe transmute proposal avoids such transmutes.</p>",
        "id": 182836467,
        "sender_full_name": "RalfJ",
        "timestamp": 1575709912
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://github.com/rust-embedded/wg/blob/master/rfcs/0377-mutex-trait.md#the-rust-standard-library-mutex-uses-self-for-the-lock-method-why-choose-mut-self\" target=\"_blank\" title=\"https://github.com/rust-embedded/wg/blob/master/rfcs/0377-mutex-trait.md#the-rust-standard-library-mutex-uses-self-for-the-lock-method-why-choose-mut-self\">https://github.com/rust-embedded/wg/blob/master/rfcs/0377-mutex-trait.md#the-rust-standard-library-mutex-uses-self-for-the-lock-method-why-choose-mut-self</a> may also be interesting for you to read (sort of tangentially related)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>  that is <em>really weird</em>... why would one ever use <code>Mutex&lt;RefCell&lt;T&gt;&gt;</code>? That's two layers of interior mutability...<br>\nNot sure I buy the deadlock-safety argument; we can still create deadlocks through inconsistent lock ordering.<br>\nAnd then I can also still reentrantly acquire the same mutex with their <code>&amp;mut &amp;Mutex</code> scheme so how does it even help...?</p>\n<p><span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span> </p>\n<blockquote>\n<p>Except we don't have PhantomInvariant. (Can it even be defined without involving &amp;mut?)</p>\n</blockquote>\n<p>Alternative def.n: <code>type PhantomInvariant&lt;'a&gt; = fn(&amp;'a ()) -&gt; &amp;'a ()</code></p>",
        "id": 182836468,
        "sender_full_name": "RalfJ",
        "timestamp": 1575709919
    },
    {
        "content": "<p>First of all, my point was that once you have a &amp;[u8] (or some other type that isn't MaybeUninit) you have real memory that can't be uninitialized (or you've done something undefined).</p>\n<p>Second, I'm extremely done with this thread, with the \"Rust Abstract Machine\", and with formal methods in general.</p>",
        "id": 182836593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575710085
    },
    {
        "content": "<blockquote>\n<p>Second, I'm extremely done with this thread, with the \"Rust Abstract Machine\", and with formal methods in general.</p>\n</blockquote>\n<p>Well that's not very helpful. LLVM (and every C compiler) is full of soundness bugs because of such an attitude. I hope we can avoid Rust repeating all the same mistakes.</p>",
        "id": 182836609,
        "sender_full_name": "RalfJ",
        "timestamp": 1575710137
    },
    {
        "content": "<blockquote>\n<p>First of all, my point was that once you have a &amp;[u8] (or some other type that isn't MaybeUninit) you have real memory that can't be uninitialized (or you've done something undefined).</p>\n</blockquote>\n<p>Such an argument can be made on the R-AM just fine, and I agree for the case of <code>u8</code>. Not sure what you mean by \"real\", but the safety invariant of <code>u8</code> rules out uninitialized bit patterns. However that's not true for every type; e.g. <code>(u8, u16)</code> does contain an uninitialized byte and thus a transmute from <code>(u8, u16)</code> to <code>[u8; 4]</code> is UB.</p>",
        "id": 182836671,
        "sender_full_name": "RalfJ",
        "timestamp": 1575710252
    },
    {
        "content": "<p>(This is assuming our current conservative rules, see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\">https://github.com/rust-lang/unsafe-code-guidelines/issues/71</a>. But even if that transmute is not UB any more one day it is still unsafe.)</p>",
        "id": 182836722,
        "sender_full_name": "RalfJ",
        "timestamp": 1575710303
    },
    {
        "content": "<p>I feel like we're retreading previous territory. I'm aware that padding is an issue, the proposal in the thread I previously linked to goes to great lengths to address that.</p>",
        "id": 182836878,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575710602
    },
    {
        "content": "<blockquote>\n<p>I feel like we're retreading previous territory. I'm aware that padding is an issue, the proposal in the thread I previously linked to goes to great lengths to address that.</p>\n</blockquote>\n<p>Great! Sorry for not having read up on the entire context. I was mostly reacting to individual statements here that (at least without context) are thoroughly incompatible with the UCG's view of this -- in particular the part about \"real machines\" and \"<code>0xUU</code> isnt a bit pattern\". Some of this is likely \"just\" temrinology, but then figuring out terminology is a big part of formally defining anything.<br>\nI misunderstood what you mean by \"undef doesnt apply to [u8]\"; sorry for that.</p>",
        "id": 182837116,
        "sender_full_name": "RalfJ",
        "timestamp": 1575710987
    },
    {
        "content": "<p>It's alright. I'm a bit frustrated at the moment and it isn't your fault. I'm not dismissing formal methods, I just don't always want to have every discussion about code behavior forced into formal methods.</p>",
        "id": 182837490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1575711569
    }
]