[
    {
        "content": "<p>I'd like to make a separate thread to make my case for using <a href=\"https://github.com/rust-lang/rfcs/pull/2884\">RFC #2884</a>, aka unsized returns, for RPIT-in-dyn-trait and by extension dyn async traits.</p>\n<p>Niko's rationale for the current RPIT-in-dyn-trait design is to enable library writers to write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">count</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">AsyncIterator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and have that code be used in no_std envs.</p>\n<p>The big constraints are:</p>\n<ul>\n<li>Library writers must write their code \"naturally\"; they will write code as generic as possible, and not worry about implementation details.</li>\n<li>Embedded developers must be able to use libraries without allocating anything. They may not even have an allocator.</li>\n<li>These two constraints must be compatible. Eg embedded developers shouldn't have to ask library writers to add an allocator-less version.</li>\n</ul>\n<p>To satisfy those, the design adds a new \"adapter\" concept. Adapter are like magic HKTs that can take a trait <code>MyTrait</code>, and produce a wrapper type <code>MyTraitWrapper</code> that, for every RPIT method of <code>MyTrait</code>, implements a wrapper method with basically the RPIT's vtable, plus a custom destructor. The main use-case of that adapter concept is the <code>#[dyner::inline_adapter]</code> attribute, which, applied to <code>AsyncIterator</code>, gives us <code>InlineAsyncIterator</code>, which is an iterator that stores the return value of the <code>next()</code> call in a preallocated slot.</p>",
        "id": 276396414,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648067754
    },
    {
        "content": "<hr>\n<p>Josh's big objection to this is that this pattern is basically encouraging lots of hidden allocations that aren't clear when looking at either the call site or the callee code. Eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AsyncIterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyRange</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">30</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">range</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">do_thing</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">AsyncIterator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">do_thing_with_my_range</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">do_thing</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">MyRange</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">10</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Looking at the code of all three functions, there's no sign that any of the code allocates anywhere, even though it creates boxes for every call to <code>.next()</code>.</p>\n<p>Even if we edited <code>do_thing_with_my_range</code> to add an explicit boxing adapter, <code>.next()</code> is the call that allocates, and yet there's no indication at either the call site or in <code>next()</code>'s implementation that memory is allocated.</p>\n<p>Josh points out that this is bad, because allocator calls are non-trivial things, and developers may want strong guarantees that they can control where the allocator is called. Allocations can panic, can be expensive cache-wise, etc. Some people get <em>really</em> nervous when the compiler starts adding hidden allocations.</p>",
        "id": 276396538,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648067803
    },
    {
        "content": "<hr>\n<p>My own objection to the proposed design is that the whole \"adapter\" machinery seems very complex, and yet it only covers very specific use-cases.</p>\n<p>The \"inline adapter\" only works for <code>&amp;mut self</code> methods that return a type with a borrow on self. This is the case for <code>AsyncIterator::next()</code>, but it may not be the case for other trait methods, eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_printable</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">call_three_times</span><span class=\"p\">(</span><span class=\"n\">obj</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{a} {b} {c}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>My understanding is that the implemented workaround is using a cell, and the second call to <code>get_printable</code> panics, but... let's be honest, this is a horrifying hack. If we're not fine with inserting silent allocations, I can't imagine we're fine with inserting random panics because the allocation strategy of your caller didn't like that you called the same <code>&amp;self</code> method twice.</p>",
        "id": 276396692,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648067873
    },
    {
        "content": "<hr>\n<p>Instead, I propose that we ask developers who want their async code to be maximally portable to write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">count</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AsyncIterator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We can add <code>InlineAsyncIterator</code> as a special type, implemented with existing concepts (and some unsafe code), and skip most of the dynx / adapter machinery.</p>\n<p>Embedded developers who want no allocation and to avoid generic bloat can then write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">invoke_count</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">AsyncIterator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">count</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">InlineDynAsyncIterator</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>For non-async RPIT methods, we can use the syntax in RFC 2884:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_printable</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">call_three_times</span><span class=\"p\">(</span><span class=\"n\">obj</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{a} {b} {c}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Doing it that way, the main advantage is we can use different allocation strategies, and it's obvious which one we're using:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">call_three_times</span><span class=\"p\">(</span><span class=\"n\">obj</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SmallBox</span>::<span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SmallBox</span>::<span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SmallBox</span>::<span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{a} {b} {c}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">call_three_times</span><span class=\"p\">(</span><span class=\"n\">obj</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">arena</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MyGrowingArena</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">SOME_VALUE</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">arena</span><span class=\"p\">.</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">arena</span><span class=\"p\">.</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">arena</span><span class=\"p\">.</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{a} {b} {c}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276396740,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648067883
    },
    {
        "content": "<p>Sounds good so far. Could you show what <code>call_three_times</code> looks like if you take <code>&amp;mut impl AsyncIterator</code> and want to be maximally general?</p>",
        "id": 276397306,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648068154
    },
    {
        "content": "<p>The body is the same</p>",
        "id": 276397331,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068165
    },
    {
        "content": "<p>It's literally just changing a keyword</p>",
        "id": 276397343,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068174
    },
    {
        "content": "<p>Doesn't that mean that your maximally portable code is deciding for its caller whether to box or not?</p>",
        "id": 276397355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648068181
    },
    {
        "content": "<p>Wait, no, I thought you were talking about count</p>",
        "id": 276397384,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068206
    },
    {
        "content": "<p>Right, count is easier. What should call_three_times do to let its caller decide how to handle the return values?</p>",
        "id": 276397451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648068239
    },
    {
        "content": "<blockquote>\n<p>Allocations can panic, can be expensive cache-wise, etc.</p>\n</blockquote>\n<p>Worse, some low-implementation-complexity allocators take locks on every allocation to be thread-safe, they don't have thread-local pools. I think older versions of musl do that for example. If this is called frequently that can be really bad for concurrent code... which you expect in the context of async.</p>",
        "id": 276397541,
        "sender_full_name": "The 8472",
        "timestamp": 1648068268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/RPIT.20in.20dyn.20Traits.20-.20Unsized.20returns/near/276397451\">said</a>:</p>\n<blockquote>\n<p>Right, count is easier. What should call_three_times do to let its caller decide how to handle the return values?</p>\n</blockquote>\n<p>It can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">call_three_times</span><span class=\"p\">(</span><span class=\"n\">obj</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">get_printable</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{a} {b} {c}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276397657,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068329
    },
    {
        "content": "<p>But then the given <code>impl MyTrait</code> must be non-dyn</p>",
        "id": 276397784,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068377
    },
    {
        "content": "<p>Is that a restriction we can place?</p>",
        "id": 276397811,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648068397
    },
    {
        "content": "<p>Eeeh... kinda. Right now the language conflates \"is dyn\" with \"is Sized\".</p>",
        "id": 276397862,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068429
    },
    {
        "content": "<p>It does seem like it'd solve the problem, since then the caller can decide how to turn a <code>dyn</code> into an <code>impl</code> while handling the return values.</p>",
        "id": 276397866,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648068430
    },
    {
        "content": "<p>(Though it doesn't give many options to the caller in doing so.)</p>",
        "id": 276397910,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648068456
    },
    {
        "content": "<p>I mean... that makes sense? In non-async, non-RPIT code you usually don't worry about how the functions you're calling allocate memory for their internals.</p>",
        "id": 276398034,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068505
    },
    {
        "content": "<p>Like, if you're calling <code>find_path_with_astar(my_graph)</code>, you usually don't expect to control whether the A* implementation is using Vecs or VecDequeues.</p>",
        "id": 276398272,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068616
    },
    {
        "content": "<p>The broader point I'm making is that, given this trait declaration:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_printable</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><strong>there isn't any feasible way to pass <code>&amp;dyn MyTrait</code> to a function, and have that function use it, while guaranteeing that no dynamic allocation will ever be made.</strong></p>",
        "id": 276398565,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068739
    },
    {
        "content": "<p>You can make it so that there are <em>few</em> allocations, which is often good enough in embedded. You can use an arena. You can force the code that's making the allocation to use <code>Box::new_with</code> or whatever to make it clear that allocations are happening.</p>",
        "id": 276398734,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068822
    },
    {
        "content": "<p>But the <code>fn method() -&gt; impl Display;</code> API and the <code>fn call_three_times(obj: &amp;dyn MyTrait)</code> API, taken together, make it so that the program has no way to determine statically how much memory will be needed ahead of time.</p>",
        "id": 276398935,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648068906
    },
    {
        "content": "<p>Whether sized or unsized return types are used for <code>dyn</code> has to be decided for each method on the trait. For async you would (pretty much always) want to use a sized return type with a dynx-like mechanism, whereas for other use cases you might want to use unsized returns. With that said I think the two approaches are compatible and can co-exist</p>",
        "id": 276400861,
        "sender_full_name": "tmandry",
        "timestamp": 1648069724
    }
]