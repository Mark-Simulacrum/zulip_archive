[
    {
        "content": "<p>FYI, here's a PR waiting for FCP to be started. :)<br>\n<a href=\"https://github.com/rust-lang/rust/pull/85769\">https://github.com/rust-lang/rust/pull/85769</a><br>\n<a href=\"https://github.com/rust-lang/rust/pull/85769#issuecomment-854363720\">Stabilization report</a></p>",
        "id": 242694729,
        "sender_full_name": "RalfJ",
        "timestamp": 1623740509
    },
    {
        "content": "<p>FWIW I am a bit surprised that this is not being discussed a bit more</p>\n<blockquote>\n<p>However, this will still let us write code like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">random</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which would be the first stable const fn that is not guaranteed to behave deterministically at run-time.<br>\nThis function certainly has UB when called at compile-time, but whether it has UB when called at run-time <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">is unclear</a>.</p>\n</blockquote>\n<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> y'all did see this part of the stabilization report, right?</p>",
        "id": 245413979,
        "sender_full_name": "RalfJ",
        "timestamp": 1625818525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I saw it, but now that you mention it... :)</p>",
        "id": 245420349,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625822575
    },
    {
        "content": "<p>I guess that I felt comfortable with it because I think we want to get to a place where as much of the language is <code>const fn</code> as possible</p>",
        "id": 245420404,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625822606
    },
    {
        "content": "<p>and we already agreed that this will include some UB</p>",
        "id": 245420415,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625822614
    },
    {
        "content": "<p>but I agree that this is a milestone worthy of discussion</p>",
        "id": 245420454,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625822636
    },
    {
        "content": "<p>Though as <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> pointed out, a <em>safe</em> <code>const fn() -&gt; usize</code> would have to be const-unsound to be non-deterministic.<br>\nThis would still be enough to use <code>const fn</code> as a guarantee that other code can rely on.<br>\nHowever, it would <em>not</em> be enough for the compiler to perform optimizations based on the fact that a function is <code>const fn</code> -- but that seems highly speculative anyway.</p>",
        "id": 245470894,
        "sender_full_name": "RalfJ",
        "timestamp": 1625850860
    },
    {
        "content": "<p>So maybe this is no as big a milestone as I thought it is (the milestone is coming though, if we want to tackle <code>const_fn_float</code> some day^^)</p>",
        "id": 245470950,
        "sender_full_name": "RalfJ",
        "timestamp": 1625850891
    },
    {
        "content": "<p>I would love for the compiler to be able to figure out when most const functions are in fact pure functions, and therefore can participate in things like CSE.</p>",
        "id": 245471008,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625850926
    },
    {
        "content": "<p>if the compiler can \"see\" the function, it can analyze its body to check for this (but then it can do that for all functions, not just for <code>const fn</code>).<br>\nif this is supposed to be possible even for <code>const fn</code> about which we know <em>nothing</em> except for their type... then I think this makes const heap allocations pretty much impossible.^^</p>",
        "id": 245472699,
        "sender_full_name": "RalfJ",
        "timestamp": 1625851784
    },
    {
        "content": "<p>Is this just about optimization?</p>",
        "id": 245491815,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861542
    },
    {
        "content": "<p>Because in principle we could propagate up flags and things, too</p>",
        "id": 245491826,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861553
    },
    {
        "content": "<p>e.g., we analyze it within the crate and propagate a \"pure\" hint</p>",
        "id": 245491839,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861560
    },
    {
        "content": "<p>it feels nice to me that this is something we do equally for both fn and not fn</p>",
        "id": 245491876,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861576
    },
    {
        "content": "<p>is it still the case that nondeterminism requires unsafe <em>at some point in the stack</em>?</p>",
        "id": 245491903,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861596
    },
    {
        "content": "<p>presumably yes</p>",
        "id": 245491913,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861602
    },
    {
        "content": "<p>\"yes and\"</p>\n<p><code>ptr as usize</code> is safe but not yet allowed in const fn, so we'd have to never allow it in const fn in the future</p>\n<p>union transmutation was hoped to some day be fully safe in some cases if the fields are statically known. It can still potentially allow many safe transmutes without allowing pointer transmutes though.</p>",
        "id": 245495591,
        "sender_full_name": "Lokathor",
        "timestamp": 1625863561
    },
    {
        "content": "<blockquote>\n<p>ptr as usize is safe but not yet allowed in const fn</p>\n</blockquote>\n<p>indeed, and for this reason I don't intend to ever allow it in <code>const fn</code>... I think we can provide APIs for \"the typical things people do with ptr-int-casts\" that are fully deterministic and hence can be provided at const-time as well. But that's <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F\">a separate discussion</a>.</p>",
        "id": 245536679,
        "sender_full_name": "RalfJ",
        "timestamp": 1625903951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> wrote</p>\n<blockquote>\n<p>I'm definitely talking about a sound analysis. Setting aside the current CTFE architecture for a moment, isn't this possible by tracking abstract pointers even when they're stored in ints, and doing symbolic evaluation on them while treating the abstract pointer value as opaque? For a first pass, this could just error out the moment you do something that depends on the value of the pointer other than the bits determined by its alignment; that alone would be enough to handle usage of the low-bits, for instance.</p>\n</blockquote>\n<p>I think you are misunderstanding what this analysis needs to do. When you actually <em>run</em> CTFE code, we can already reliably detect when you are doing something that would depend on the actual physical base address of a pointer, and we stop evaluation. This is insufficient.</p>",
        "id": 245536790,
        "sender_full_name": "RalfJ",
        "timestamp": 1625904108
    },
    {
        "content": "<p>Going back to the example</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">random</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>if you ever actually run this code <em>at compile-time</em>, it will error. But that does not solve the problem. The problem, as stated above, is that this</p>\n<blockquote>\n<p>would be the first stable const fn that is not guaranteed to <em>behave deterministically at run-time</em></p>\n</blockquote>",
        "id": 245536856,
        "sender_full_name": "RalfJ",
        "timestamp": 1625904176
    },
    {
        "content": "<p>basically, what you are suggesting is a <em>dynamic</em> analysis. it happens when the code is run. This \"running the code\" happens at compile-time as part of CTFE, but that doesn't make it any less dynamic. (When you run Python code in an interpreter, that's \"dynamic\". The same is true when you run Rust code in an interpreter, and that's exactly what CTFE does.)</p>",
        "id": 245536943,
        "sender_full_name": "RalfJ",
        "timestamp": 1625904298
    },
    {
        "content": "<p>what we'd need to avoid the problem is a <em>static</em> analysis that <em>looks at the code without running it</em> and determines if, with any possible input, this code might ever be in the business of \"leaking\" information about the physical base address of a pointer. I don't think that is realistic to do.</p>",
        "id": 245536965,
        "sender_full_name": "RalfJ",
        "timestamp": 1625904345
    },
    {
        "content": "<p>I understood that this analysis needed to look at runtime behavior. I was talking about doing static compile-time analysis of potential runtime behavior through symbolic evaluation.</p>\n<p>I may well still be misunderstanding, of course.</p>",
        "id": 245558537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625933009
    },
    {
        "content": "<p>I misunderstood then, sorry.<br>\nThat might work for simple cases, where a lot of stuff happens in a single function, but cannot work once work is factored into multiple functions... like, you couldn't even do something like this in a <code>const fn</code></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">load</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because another function might call this function in a way that <code>ptr</code> actually points to a pointer so we are doing a ptr-to-int transmute here.<br>\nI think trying to static analyze our way out of this will not work. This is just not the kind of thing static analyses are good at. It's the kind of thing type systems are good at, but we're talking about unsafe code so that is not an option either.</p>",
        "id": 245559443,
        "sender_full_name": "RalfJ",
        "timestamp": 1625934222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stabilize.20const_fn_transmute.2C.20const_fn_union/near/245536679\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>ptr as usize is safe but not yet allowed in const fn</p>\n</blockquote>\n<p>indeed, and for this reason I don't intend to ever allow it in <code>const fn</code>... I think we can provide APIs for \"the typical things people do with ptr-int-casts\" that are fully deterministic and hence can be provided at const-time as well. But that's <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F\">a separate discussion</a>.</p>\n</blockquote>\n<p>It seems highly likely if <code>ptr as usize</code> is forbidden from const fn, but <code>transmute</code>ing ptr -&gt; usize and vice versa isn't, people will do the latter. we already saw this when ptr deref is disallowed, where we got <code>transmute</code> of raw ptr to reference (in const/static initializers, not const fn).</p>\n<p>the difference being is that it looks like transmute integer -&gt; ptr is <em>always</em> UB, according to <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286</a></p>",
        "id": 245589192,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625981153
    },
    {
        "content": "<blockquote>\n<p>It seems highly likely if ptr as usize is forbidden from const fn, but transmuteing ptr -&gt; usize and vice versa isn't, people will do the latter.</p>\n</blockquote>\n<p>Yes I am aware. I don't really know a way to avoid this though. ptr-to-int casts <em>cannot</em> be a safe operation in CTFE, and I feel like allowing them only unsafely with a very bespoke set of rules sets us up for even more surprises than disallowing them outright. <a href=\"https://github.com/rust-lang/rust/issues/87020\">#87020</a> adds a very explicit note about this in the error saying that you cannot cast a ptr to an int:</p>\n<div class=\"codehilite\"><pre><span></span><code>   = note: at compile-time, pointers do not have an integer value\n   = note: avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n</code></pre></div>\n<p>I think teaching people is the best we can do here. if you have any further suggestions for how we could teach them, I am all ears. :)<br>\nnote that rustc is pretty good at catching you when you try to still do these transmutes despite all these warnings.</p>",
        "id": 245603558,
        "sender_full_name": "RalfJ",
        "timestamp": 1626004710
    },
    {
        "content": "<blockquote>\n<p>the difference being is that it looks like transmute integer -&gt; ptr is always UB, according to <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">https://github.com/rust-lang/unsafe-code-guidelines/issues/286</a></p>\n</blockquote>\n<p>yeah and then there's that, which is a mostly unresolved discussion since we don't yet know how LLVM will resolve this problem^^ (and that's hoping they resolve it at all...)</p>",
        "id": 245603582,
        "sender_full_name": "RalfJ",
        "timestamp": 1626004775
    },
    {
        "content": "<blockquote>\n<p>= note: at compile-time, pointers do not have an integer value<br>\n= note: avoiding this restriction via <code>transmute</code>, <code>union</code>, or raw pointers leads to compile-time undefined behavior</p>\n</blockquote>\n<p>this is good, but I think a similar message should be emitted on direct transmutes as well. I'm aware we can't catch every case, but catching the likely to happen ones would probably help a lot.</p>",
        "id": 245625217,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1626035730
    },
    {
        "content": "<p>transmute with a target type of pointer or array of pointers should warn, yeah</p>",
        "id": 245650831,
        "sender_full_name": "Lokathor",
        "timestamp": 1626072819
    },
    {
        "content": "<p>You mean like a targeted lint or so?</p>",
        "id": 245674128,
        "sender_full_name": "RalfJ",
        "timestamp": 1626089781
    },
    {
        "content": "<p>yeah, and it doesn't have to be perfect but any warning is probably better than none</p>",
        "id": 245708776,
        "sender_full_name": "Lokathor",
        "timestamp": 1626106247
    },
    {
        "content": "<p>sure, that does not seem unreasonable</p>",
        "id": 245710624,
        "sender_full_name": "RalfJ",
        "timestamp": 1626106855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  With regard to the link you mentioned in <a href=\"https://github.com/rust-lang/rust/issues/85769\">#85769</a>, such a lint already exists, correct? You would just like to see something a bit more detailed?</p>",
        "id": 245720492,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626111582
    },
    {
        "content": "<p>I don't think such a lint exists</p>",
        "id": 245721320,
        "sender_full_name": "RalfJ",
        "timestamp": 1626111953
    },
    {
        "content": "<p>we have other transmute lints I think? Or am I thinking about clippy?</p>",
        "id": 245721389,
        "sender_full_name": "oli",
        "timestamp": 1626111970
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(const_fn_transmute)]</span><span class=\"w\"></span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">x</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"s\">\"\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is this not what you're referring to? This currently errors with <code>error[E0080]: it is undefined behavior to use this value</code>.</p>",
        "id": 245722049,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626112264
    },
    {
        "content": "<p>yeah but that's not a lint</p>",
        "id": 245722447,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112419
    },
    {
        "content": "<p>that's a dynamic check during CTFE</p>",
        "id": 245722463,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112428
    },
    {
        "content": "<p>a lint would be a static check before CTFE even starts</p>",
        "id": 245722491,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112439
    },
    {
        "content": "<p>it would error on</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">x</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"s\">\"\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>even if this crate never calls that fn inside a  <code>const</code></p>",
        "id": 245722567,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112458
    },
    {
        "content": "<p>Ahh I see. You'd like to reject (or warn?) the transmute itself.</p>",
        "id": 245722699,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626112527
    },
    {
        "content": "<p>I'll be honest â€” I've never implemented a lint and have near zero idea on how they're done. I'll check the dev guide, but got any pointers in the right direction?</p>",
        "id": 245722771,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626112559
    },
    {
        "content": "<p>you could check what existing lints to, e.g. <a href=\"https://github.com/rust-lang/rust/blob/3a24abd22fd25c836d8b4d75ff46c833f9c3934c/compiler/rustc_lint/src/builtin.rs#L2414\">https://github.com/rust-lang/rust/blob/3a24abd22fd25c836d8b4d75ff46c833f9c3934c/compiler/rustc_lint/src/builtin.rs#L2414</a></p>",
        "id": 245723027,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112674
    },
    {
        "content": "<p>that one actually also needs to look for <code>transmute</code> to it's probably a good template :)</p>",
        "id": 245723126,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112702
    },
    {
        "content": "<p>I'll take a look. <code>rustc_lint</code> is aware of types I presume? Otherwise this would be quite difficult.</p>",
        "id": 245723219,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626112745
    },
    {
        "content": "<p>yes, it works on HIR which is fully typed</p>",
        "id": 245723465,
        "sender_full_name": "RalfJ",
        "timestamp": 1626112842
    },
    {
        "content": "<p>Awesome. I'll look at implementing a lint later today.</p>",
        "id": 245723548,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626112886
    },
    {
        "content": "<p>Great. :) Feel free to ask if you need any help!</p>",
        "id": 245723996,
        "sender_full_name": "RalfJ",
        "timestamp": 1626113083
    },
    {
        "content": "<p>(I might not be super responsive, but if you ask on Zulip there's always more people that can help :)</p>",
        "id": 245724031,
        "sender_full_name": "RalfJ",
        "timestamp": 1626113101
    },
    {
        "content": "<p>however probably best to open a new zulip topic for this, since the implementation details of the lint do not really pertain to the stabilization discussion</p>",
        "id": 245724094,
        "sender_full_name": "RalfJ",
        "timestamp": 1626113129
    },
    {
        "content": "<p>Sounds good.</p>",
        "id": 245724429,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626113263
    },
    {
        "content": "<p>Note that there definitely is a clippy lint</p>",
        "id": 245808649,
        "sender_full_name": "oli",
        "timestamp": 1626174548
    },
    {
        "content": "<p>you may want to use it as inspiration</p>",
        "id": 245808663,
        "sender_full_name": "oli",
        "timestamp": 1626174555
    },
    {
        "content": "<p>Lint should be warn or deny by default?</p>",
        "id": 245889996,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626210871
    },
    {
        "content": "<p>/me personally would think \"deny\".</p>",
        "id": 245896067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626214185
    },
    {
        "content": "<p>(Or, ideally, something that can't be turned off.)</p>",
        "id": 245896085,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626214198
    },
    {
        "content": "<p>(That would draw a line so we can decide about such handling later.)</p>",
        "id": 245896132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626214208
    },
    {
        "content": "<p>I tried \"forbid\" but it wouldn't let me. Dunno if that's just because it's a lint and not a proper error.</p>",
        "id": 245896158,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626214225
    },
    {
        "content": "<p>I'm not sure you can have a forbid-by-default lint.</p>",
        "id": 245896227,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626214281
    },
    {
        "content": "<p>That'd be a nice way to handle hard-errors.</p>",
        "id": 245896234,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626214285
    },
    {
        "content": "<p>Like I said I tried at first but the compiler complained. Presumably that restriction would be possible to lift if desired, though.</p>",
        "id": 245896263,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626214311
    },
    {
        "content": "<p>that's strange, I thought I used forbid-by-default lints for crater runs in the past... but maybe this is a more recent change</p>",
        "id": 245927678,
        "sender_full_name": "RalfJ",
        "timestamp": 1626247653
    },
    {
        "content": "<p>I wouldn't know. It seems like an odd restriction, as forbid-by-default has its purposes (like right here!)</p>",
        "id": 245927895,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626247834
    },
    {
        "content": "<p>OTOH I think deny-by-default is strong enough</p>",
        "id": 245930322,
        "sender_full_name": "RalfJ",
        "timestamp": 1626249681
    },
    {
        "content": "<p>it's also what we do for the invalid_values lint, for example</p>",
        "id": 245930335,
        "sender_full_name": "RalfJ",
        "timestamp": 1626249690
    },
    {
        "content": "<p>I'm assuming you mean the overflowing_literals, but I honestly find it odd that that's not forbidden. There is no _possible_ way that that's what's intended in the same way that there's no way to do this soundly.</p>",
        "id": 245930840,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626250080
    },
    {
        "content": "<p>To be clear I'm fine with deny by default here, I would just strongly prefer forbid.</p>",
        "id": 245930912,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626250117
    },
    {
        "content": "<p>no I mean invalid_values</p>",
        "id": 245934825,
        "sender_full_name": "RalfJ",
        "timestamp": 1626253267
    },
    {
        "content": "<p>oh, invalid_value. looks like I failed to properly use plural...<br>\nadded in <a href=\"https://github.com/rust-lang/rust/pull/63346\">https://github.com/rust-lang/rust/pull/63346</a></p>",
        "id": 245934994,
        "sender_full_name": "RalfJ",
        "timestamp": 1626253374
    },
    {
        "content": "<p>Well the rest of my message is still relevant.</p>",
        "id": 245974121,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626275704
    },
    {
        "content": "<p>And for this there's no back compatibility concern</p>",
        "id": 245974144,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626275717
    },
    {
        "content": "<p>it's similar to <code>invalid_value</code> in the sense that both are about UB</p>",
        "id": 246325307,
        "sender_full_name": "RalfJ",
        "timestamp": 1626528979
    },
    {
        "content": "<p>so by the same argument we should make <code>invalid_value</code> forbid-by-default, i.e., a hard error</p>",
        "id": 246325310,
        "sender_full_name": "RalfJ",
        "timestamp": 1626528993
    },
    {
        "content": "<p>I'm not fundamentally disagreeing with your argument, I am just pointing out that deny-by-default is consistent here. :)</p>",
        "id": 246325318,
        "sender_full_name": "RalfJ",
        "timestamp": 1626529016
    },
    {
        "content": "<p>personally I dont have a terribly strong opinion on deny vs forbid here</p>",
        "id": 246325328,
        "sender_full_name": "RalfJ",
        "timestamp": 1626529041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> so I saw <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span>'s tweet here:</p>\n<p><a href=\"https://twitter.com/pcwalton/status/1417023289893953536\">https://twitter.com/pcwalton/status/1417023289893953536</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/pcwalton/status/1417023289893953536\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/106ebf871f7e16a9c776d347794ede671c46a992/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3631393038383731382f747769747465722d69636f6e5f6e6f726d616c2e6a706567\"></a><p>Why is \"const fn\" so tricky to implement in Rust? Because it absolutely must be deterministic: identical inputs must *always* produce identical outputs. Otherwise the compiler could think two arrays have equal length when they don't, breaking memory safety.</p><span>- Patrick Walton (@pcwalton)</span></div></div><p>which raises an interesting point that I don't think has come up in this discussion. That is, determinism isn't just about things like <em>CSE</em>, of course, it's also about \"when can we decide that two consts are equal\". I'm beginning to have mild second thoughts about moving forward here until we've squared away the \"equality story\", especially around const generics, where we are likely to have incomplete knowledge of the const expression in question.</p>",
        "id": 246426749,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626681929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> the equality story is basically the valtree story</p>",
        "id": 246426827,
        "sender_full_name": "RalfJ",
        "timestamp": 1626681972
    },
    {
        "content": "<p>I know</p>",
        "id": 246426837,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626681980
    },
    {
        "content": "<p>I don't see how that is changed by transmute and union <em>in <code>const fn</code></em></p>",
        "id": 246426843,
        "sender_full_name": "RalfJ",
        "timestamp": 1626681984
    },
    {
        "content": "<p>we already allow transmute and union in <code>const</code>/<code>static</code></p>",
        "id": 246426851,
        "sender_full_name": "RalfJ",
        "timestamp": 1626681992
    },
    {
        "content": "<p>Hmm. The question I am trying to answer is, how much do we have to be able to evaluate a <code>const fn</code> before we can determine that its <em>output</em> will be equal?</p>",
        "id": 246426932,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682056
    },
    {
        "content": "<p>Also, is part of the \"safety burden\" of a const fn that its output is deterministic?</p>",
        "id": 246426947,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682076
    },
    {
        "content": "<p>I think I disagree with <span class=\"user-mention\" data-user-id=\"384014\">@Patrick Walton</span> here -- determinism <em>of CTFE evaluation</em> is not a limiting factor. Even Miri is fully deterministic in its default settings!</p>",
        "id": 246426950,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682079
    },
    {
        "content": "<p>so <code>-Zunleash-the-miri-inside-of-you</code> does not break determinism</p>",
        "id": 246427010,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682113
    },
    {
        "content": "<p>what makes extending CTFE so hard is our strong safety guarantees</p>",
        "id": 246427051,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682152
    },
    {
        "content": "<p>if we were okay with checking things \"when the const gets evaluated\" (post-monomorphization errors), things would be <em>a lot</em> easier</p>",
        "id": 246427075,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stabilize.20const_fn_transmute.2C.20const_fn_union/near/246426947\">said</a>:</p>\n<blockquote>\n<p>Also, is part of the \"safety burden\" of a const fn that its output is deterministic?</p>\n</blockquote>\n<p>there are two similar but very distinct questions here:</p>\n<ul>\n<li>is compile-time evaluation deterministic? that is typically rather easy to ensure. (we recently had trouble here with a PR that turned OOM ICEs into nicer errors since that can introduce non-determinism, but I think this is the first time we had such trouble.)</li>\n<li>is \"calling a <code>const fn</code>\" <em>at runtime</em> deterministic?</li>\n</ul>",
        "id": 246427210,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682273
    },
    {
        "content": "<p>I think there is a third question</p>",
        "id": 246427232,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682301
    },
    {
        "content": "<p>Well, maybe there isn't :) I'm trying to phrase it</p>",
        "id": 246427300,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stabilize.20const_fn_transmute.2C.20const_fn_union/near/246426932\">said</a>:</p>\n<blockquote>\n<p>Hmm. The question I am trying to answer is, how much do we have to be able to evaluate a <code>const fn</code> before we can determine that its <em>output</em> will be equal?</p>\n</blockquote>\n<p>so I dont know all the plans here, but so far the equality story only concerns the final value that comes out of evaluation, right? <code>const fn</code> is irrelevant for that.</p>",
        "id": 246427306,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682352
    },
    {
        "content": "<p>this is kind of the point I am raising</p>",
        "id": 246427317,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682363
    },
    {
        "content": "<p>are there plans for reasoning like \"<code>a == b</code> and hence <code>f(a) == f(b)</code>\"?</p>",
        "id": 246427333,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682376
    },
    {
        "content": "<p>I'm not sure I like that, but it may be too late to change it</p>",
        "id": 246427334,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682376
    },
    {
        "content": "<p>I mean, if you consider something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">}])</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246427363,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682412
    },
    {
        "content": "<p>(or whatever syntax we use there)</p>",
        "id": 246427383,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682439
    },
    {
        "content": "<p>you definitely need the ability to think about whether <code>(A + 1) == (A + 1)</code>, right?</p>",
        "id": 246427434,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682455
    },
    {
        "content": "<p>I don't think we can do such reasoning for all types (if <code>a</code>, <code>b</code> are mutable references there are side-effects here that make such equational reasoning... dubious), but if e.g. <code>a</code>, <code>b</code> are of integer type then I think this is easily given with all the extensions we are currently considering</p>",
        "id": 246427472,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682484
    },
    {
        "content": "<p>since it is again a <em>compile-time</em> evaluation property</p>",
        "id": 246427484,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682498
    },
    {
        "content": "<p>well, if they come out from a <code>const fn</code>...</p>",
        "id": 246427496,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682505
    },
    {
        "content": "<p>and there is no non-determinism that could possibly make <code>f(4)</code> different from <code>f(4)</code></p>",
        "id": 246427502,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682509
    },
    {
        "content": "<p>...right, this is what I was thinking. Instead what we have to worry about is that <code>f(4)</code> might <em>result in a value that isn't an actual usize</em></p>",
        "id": 246427530,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682538
    },
    {
        "content": "<p>the only hard question is \"what happens when you run a <code>const fn</code> at runtime\", which is irrelevant for this \"congruence\" property -- so congruence is 'easy'</p>",
        "id": 246427531,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682541
    },
    {
        "content": "<p>(that the compiler can \"use')</p>",
        "id": 246427538,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682544
    },
    {
        "content": "<p>e.g., a transmute from a pointer</p>",
        "id": 246427544,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682548
    },
    {
        "content": "<p>yeah but we'd catch that during valtree construcion</p>",
        "id": 246427556,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682558
    },
    {
        "content": "<p>well we already catch it during const validation</p>",
        "id": 246427598,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682565
    },
    {
        "content": "<p>right. at monomorphization time.</p>",
        "id": 246427601,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682566
    },
    {
        "content": "<p>well, this is the whole \"evaluatable\" debate</p>",
        "id": 246427604,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682573
    },
    {
        "content": "<p>in any case, good, I am satisfied.</p>",
        "id": 246427616,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682591
    },
    {
        "content": "<p>compile-time UB is only caught at monomorphization time, yes</p>",
        "id": 246427617,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682595
    },
    {
        "content": "<p>not really much of a way around that I think, but I don't think it's a problem</p>",
        "id": 246427626,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682606
    },
    {
        "content": "<p>we really need to have a good \"overall design doc\" here</p>",
        "id": 246427642,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682622
    },
    {
        "content": "<p>to capture these sorts of points</p>",
        "id": 246427650,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682629
    },
    {
        "content": "<p>I am thinking about what form I think that should take</p>",
        "id": 246427664,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682641
    },
    {
        "content": "<p>for just const-eval we have <a href=\"https://github.com/rust-lang/const-eval/\">https://github.com/rust-lang/const-eval/</a></p>",
        "id": 246427675,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682647
    },
    {
        "content": "<p>we don't have much for the interaction with const generics since I am not deeply familiar with const generics</p>",
        "id": 246427686,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stabilize.20const_fn_transmute.2C.20const_fn_union/near/246427675\">said</a>:</p>\n<blockquote>\n<p>for just const-eval we have <a href=\"https://github.com/rust-lang/const-eval/\">https://github.com/rust-lang/const-eval/</a></p>\n</blockquote>\n<p>it may just be that I need to sit down read this more deeply :)</p>",
        "id": 246427749,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stabilize.20const_fn_transmute.2C.20const_fn_union/near/246427686\">said</a>:</p>\n<blockquote>\n<p>we don't have much for the interaction with const generics since I am not deeply familiar with const generics</p>\n</blockquote>\n<p>ok; this strikes me as an important part of the equation too</p>",
        "id": 246427758,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682710
    },
    {
        "content": "<p>We were working on a \"const generics vision doc\", in my view, const-eval + const-generics are (for users) kind of \"one feature\". I'd like to pursue that with you and <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>, but not this minute. :)</p>",
        "id": 246427796,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682756
    },
    {
        "content": "<p>Thanks for clarifying things with me!</p>",
        "id": 246427823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682790
    },
    {
        "content": "<p>yeah I didnt/dont really have the capacity to be closely enough involved with const generics</p>",
        "id": 246427944,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682892
    },
    {
        "content": "<p>I was hoping valtrees could be a nice interface between the const-eval world and the const-generic world -- the way I envision them, nothing can really go wrong any more once you have a valtree :D</p>",
        "id": 246427972,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682919
    },
    {
        "content": "<p>but this congruence reasoning throws a wrench into that plan...</p>",
        "id": 246428036,
        "sender_full_name": "RalfJ",
        "timestamp": 1626682945
    }
]