[
    {
        "content": "<p>Does anyone happen to know what the status of <code>let Pattern else { ... }</code> / inverse <code>if let Pattern { ... }</code> statements is? (Or, what people have been calling them, if anything?) Has this ever been RFC'd? They would be very useful for avoiding both <code>unwrap</code> and overly zealous indentation.</p>",
        "id": 234894839,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618595382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> The last status I'm aware of is \"the RFC was postponed some time ago and we didn't pick it up again yet\".</p>",
        "id": 234894921,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595410
    },
    {
        "content": "<p>It desperately needs a champion.</p>",
        "id": 234894935,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595420
    },
    {
        "content": "<p>I would love to see it happen.</p>",
        "id": 234894975,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595435
    },
    {
        "content": "<p>Mind to find me the RFC? I am unsure what to search for</p>",
        "id": 234894989,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618595439
    },
    {
        "content": "<p>I care a lot about this, much more than my other topic</p>",
        "id": 234895022,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618595454
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/pull/1303\">https://github.com/rust-lang/rfcs/pull/1303</a> is the original RFC. Looking for others...</p>",
        "id": 234895105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595492
    },
    {
        "content": "<p>Also see <a href=\"#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/let.20.2E.2E.2E.20else</a> for an extensive recent discussion.</p>",
        "id": 234895183,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595523
    },
    {
        "content": "<p>Hmm should this topic be merged with that one? It's a little hard to follow what end feeling was of that thread. I'm not sure why I didn't see that topic, maybe the subject is less clear</p>",
        "id": 234896499,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596034
    },
    {
        "content": "<p>I don't think it should be merged, no.</p>",
        "id": 234896720,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596116
    },
    {
        "content": "<p>I think the primary open question in that thread was how we should handle the bindings. One proposal was to make <code>let Some(x) = expr() else { ... }</code> allow assigning to <code>x</code> in the <code>else { ... }</code>. I personally prefer just requiring that the <code>else { ... }</code> diverge (typically via <code>return</code> or <code>break</code>).</p>",
        "id": 234897059,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596226
    },
    {
        "content": "<p>Mm. Ok well, I'm coming into this with slightly more assumptions than I think are held in that thread. (I have not yet read the old RFC).</p>\n<p>My clueless assumptions are:</p>\n<ul>\n<li>Syntax should be exactly opposite of <code>if let</code>, in terms of how <code>if else</code> conditionals in general work. (hence <code>let pattern else {}</code>)</li>\n<li>Scoping should be exactly opposite (any assignment from this statement being invisible to the inner block)</li>\n</ul>",
        "id": 234897352,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> The latter I agree with; any bindings from the pattern should not be visible inside the <code>else</code>.</p>",
        "id": 234897529,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596407
    },
    {
        "content": "<p>What I mean by the latter point is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">option</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">// not visible</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234897560,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596425
    },
    {
        "content": "<p>Having <code>else</code> be different would be confusing.</p>",
        "id": 234897594,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596439
    },
    {
        "content": "<p>For the former, I'd be expecting <code>let Pattern = expr else { ... }</code> as the syntax. What would <code>let Pattern else { ... }</code> mean without something to bind the pattern to?</p>",
        "id": 234897668,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596481
    },
    {
        "content": "<p>So therefore:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">option</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">// also not visible</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234897748,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234894935\">said</a>:</p>\n<blockquote>\n<p>It desperately needs a champion.</p>\n</blockquote>\n<p>Yeah, I think it's reached the point where there are a bunch of known questions that need decisions.</p>\n<p>It might just need someone to write an RFC that has a bunch of good Rationale &amp; Alternatives sections that make decisions for each of those things and justify them.</p>\n<p>Bindings (where are they in scope), syntax (shift-reduce conflicts or things like <code>unless</code>), types (such as whether the else block needs to be <code>!</code> or <code>()</code> or can return values), and general feature scoping (does it need to allow access to the value in the <code>else</code> somehow) are the core things that come to mind.</p>\n<p>I think there's a couple reasonable design points in there, though I also agree there's a definite undercurrent in favour of one of them.</p>",
        "id": 234897766,
        "sender_full_name": "scottmcm",
        "timestamp": 1618596509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> Yeah, that's the syntax I'd expect. (And also the formatting I'd expect, which is something the RFC should cover.)</p>",
        "id": 234897849,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234897668\">said</a>:</p>\n<blockquote>\n<p>For the former, I'd be expecting <code>let Pattern = expr else { ... }</code> as the syntax. What would <code>let Pattern else { ... }</code> mean without something to bind the pattern to?</p>\n</blockquote>\n<p>Sorry, this is correct, I wasn't quite sure how to describe it.</p>",
        "id": 234897859,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596547
    },
    {
        "content": "<p>What would it mean for the else block to return a value? This is a good question, I guess in most cases for where I'd use this, it would be in early returns, but I think some of <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>'s examples in the other thread _may_ have had returns?</p>",
        "id": 234898168,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596693
    },
    {
        "content": "<p>This is probably <em>way</em> too cute, but it could be <code>let Some(x) = y else { 4 };</code>.</p>\n<p>(I think that if that were going to be a realistic option it'd be the <code>let Some(x) = y else { x = 4 };</code> version.)</p>",
        "id": 234898406,
        "sender_full_name": "scottmcm",
        "timestamp": 1618596798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> There was a proposal in the other thread to allow something like <code>let Some(x) = expr() else { x = ... }</code>.</p>",
        "id": 234898419,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596805
    },
    {
        "content": "<p>That's just <code>unwrap_or_else(|| {})</code> though</p>",
        "id": 234898454,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596821
    },
    {
        "content": "<p>No argument there.</p>",
        "id": 234898497,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596842
    },
    {
        "content": "<p>I think allowing that would be a complicated addition for what wouldn't be the common case of <code>let ... else</code>.</p>",
        "id": 234898589,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234898454\">said</a>:</p>\n<blockquote>\n<p>That's just <code>unwrap_or_else()</code> though</p>\n</blockquote>\n<p>Only for <code>Option</code>.  To me the point of this feature is for things like matching syntax trees the way clippy does, for which one doesn't have all those extra methods</p>",
        "id": 234898591,
        "sender_full_name": "scottmcm",
        "timestamp": 1618596865
    },
    {
        "content": "<p>The problem with <code>unwrap_or_else()</code> here is that you cannot cause a return in the other scope from it.</p>",
        "id": 234898614,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618596873
    },
    {
        "content": "<p>In any case, my preference would be to <em>start</em> by requiring that the <code>else</code> must diverge, and we could always extend it later.</p>",
        "id": 234898661,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596901
    },
    {
        "content": "<p>(TBH, for <code>Option</code> specifically I would really like something like C#'s <code>??</code> operator: <code>let x = some_opt() ☃ (calculate() + default());</code> or  <code>let x = some_opt() ☃ continue;</code> or whatever.)</p>",
        "id": 234898789,
        "sender_full_name": "scottmcm",
        "timestamp": 1618596944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234898661\">said</a>:</p>\n<blockquote>\n<p>In any case, my preference would be to <em>start</em> by requiring that the <code>else</code> must diverge, and we could always extend it later.</p>\n</blockquote>\n<p>I think shadowing means that we'd need some extra restrictions if we really wanted to leave the door open.</p>\n<p>For example,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"x was {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would break if the uninitialized <code>x</code> started to be in-scope.</p>",
        "id": 234899063,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597063
    },
    {
        "content": "<p>_If_ we wanted <code>else</code> to return I think this would be better syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// where this is an implicit return of the same type as `y`.</span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234899135,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597085
    },
    {
        "content": "<p>Oh, and another very silly syntax question: should this require a <code>;</code> (like <code>let</code>) or not (like most things that end in <code>}</code>).</p>",
        "id": 234899198,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234898789\">said</a>:</p>\n<blockquote>\n<p>(TBH, for <code>Option</code> specifically I would really like something like C#'s <code>??</code> operator: <code>let x = some_opt() ☃ (calculate() + default());</code> or  <code>let x = some_opt() ☃ continue;</code> or whatever.)</p>\n</blockquote>\n<p>Honestly, I would love to have a general-purpose mechanism for a lambda to return/continue/break in the containing scope, and then we could do that with <code>unwrap_or_else</code>.</p>",
        "id": 234899255,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597138
    },
    {
        "content": "<p>I was assuming it was like a <code>let</code> delcaration</p>",
        "id": 234899262,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597143
    },
    {
        "content": "<p>I was as well; I think it needs a <code>;</code>.</p>",
        "id": 234899287,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234899135\">said</a>:</p>\n<blockquote>\n<p>_If_ we wanted <code>else</code> to return I think this would be better syntax:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// where this is an implicit return of the same type as `y`.</span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't think that quite works because I could do <code>else { None }</code>, which wouldn't fix the problem, and that can't be detected with just the (current) type system.</p>",
        "id": 234899293,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234899063\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234898661\">said</a>:</p>\n<blockquote>\n<p>In any case, my preference would be to <em>start</em> by requiring that the <code>else</code> must diverge, and we could always extend it later.</p>\n</blockquote>\n<p>I think shadowing means that we'd need some extra restrictions if we really wanted to leave the door open.</p>\n<p>For example,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"x was {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would break if the uninitialized <code>x</code> started to be in-scope.</p>\n</blockquote>\n<p>True. We could error on the use of <code>x</code> in that scope, but that would make some uses more difficult.</p>",
        "id": 234899344,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597186
    },
    {
        "content": "<p>oh, right</p>",
        "id": 234899347,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234899287\">said</a>:</p>\n<blockquote>\n<p>I was as well; I think it needs a <code>;</code>.</p>\n</blockquote>\n<p>Can you elaborate on why?</p>\n<p>Not saying you're wrong, just that it's not obvious to me.</p>",
        "id": 234899535,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597255
    },
    {
        "content": "<p>It would keep it the closest to being like a regular <code>let </code>statement.</p>",
        "id": 234899615,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597287
    },
    {
        "content": "<p>Whereas <code>if let</code> is kept similar to an <code>if</code> statement</p>",
        "id": 234899639,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597304
    },
    {
        "content": "<p>I could also argue that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is more like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which doesn't use a <code>;</code>.</p>",
        "id": 234899868,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597399
    },
    {
        "content": "<p>Suggestion for how we could do shadowing in the future, because it seems very strange to me that anything on the left side of the <code>else</code> would be assignable:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234899884,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597409
    },
    {
        "content": "<p>actually that probably can't work, hmm</p>",
        "id": 234900071,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234899884\">said</a>:</p>\n<blockquote>\n<p>because it seems very strange to me that anything on the left side of the <code>lese</code> would be assignable</p>\n</blockquote>\n<p>Well, <code>let x;</code> is assignable.  So it'd behave like that, to me.</p>",
        "id": 234900078,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234900078\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234899884\">said</a>:</p>\n<blockquote>\n<p>because it seems very strange to me that anything on the left side of the <code>lese</code> would be assignable</p>\n</blockquote>\n<p>Well, <code>let x;</code> is assignable.  So it'd behave like that, to me.</p>\n</blockquote>\n<p>Not during the assignment:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">option</span><span class=\"p\">.</span><span class=\"n\">unwrap_or_else</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"cm\">/* oops */</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234900204,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597555
    },
    {
        "content": "<p>And I think it'd be important for it to work for multiple values too, like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Color</span>::<span class=\"n\">RGB</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_color_override</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">255</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">255</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">whatever</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234900252,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597565
    },
    {
        "content": "<p>I'd like that to work but I'd also like it to have different syntax</p>",
        "id": 234900558,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597713
    },
    {
        "content": "<p><code>or else</code> or <code>else assign</code> or... <em>something</em></p>",
        "id": 234900596,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597730
    },
    {
        "content": "<p>Usually I find myself like Josh in the position of wanting to not shadow and do an early return</p>",
        "id": 234900657,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618597764
    },
    {
        "content": "<p>But practically, it might be best to spec this as a desugar, and see if we can live with the variable scoping that falls out from that.</p>\n<p>Like could we just get away with saying that <code>let PAT = EXPR else { ALT }</code> → <code>let FREE_VARS_TUPLE = if let PAT = EXPR { FREE_VARS_TUPLE } else { let _never: ! = { ALT }; match _never {} }</code>?</p>\n<p>That might be the easiest way to teach it and to avoid any weird surprises: like was done for <code>?</code>, it's just a handy shorthand for the way one would write it today.</p>",
        "id": 234900867,
        "sender_full_name": "scottmcm",
        "timestamp": 1618597848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> My rationale for the <code>;</code> is that <code>let ...</code> is a let, just as <code>if ...</code> is an if. <code>if let</code> doesn't get a semicolon because <code>if</code> doesn't. <code>let ... else</code> gets a semicolon because it's just an optional extension to <code>let</code> which gets a semicolon.</p>",
        "id": 234901151,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597991
    },
    {
        "content": "<p>To write our your example today would be like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Color</span>::<span class=\"n\">RGB</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_color</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which, under <code>let FREE_VARS_TUPLE = if let PAT = EXPR { FREE_VARS_TUPLE } else { let _never: ! = { ALT }; match _never {} }</code> would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Color</span>::<span class=\"n\">RGB</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_color</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I think?</p>",
        "id": 234901373,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618598089
    },
    {
        "content": "<p>The <code>let _never: ! =</code> part there is forcing it to diverge, so it can't do my color example.</p>",
        "id": 234901463,
        "sender_full_name": "scottmcm",
        "timestamp": 1618598125
    },
    {
        "content": "<p>oh ah</p>",
        "id": 234901505,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618598142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Your proposed desugar seems fine. That would likely commit us to not allowing access to any of the variables in FREE_VARS_TUPLE, which is fine by me but would mean we couldn't in the future change that.</p>",
        "id": 234901533,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598160
    },
    {
        "content": "<p>I think additional syntax could allow it easily enough though</p>",
        "id": 234901621,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618598184
    },
    {
        "content": "<p>I don't know if that color example is actually important.  I could probably be convinced either way by a well-written RFC <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 234901623,
        "sender_full_name": "scottmcm",
        "timestamp": 1618598186
    },
    {
        "content": "<p>Hmm</p>",
        "id": 234901685,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618598224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234901151\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> My rationale for the <code>;</code> is that <code>let ...</code> is a let, just as <code>if ...</code> is an if. <code>if let</code> doesn't get a semicolon because <code>if</code> doesn't. <code>let ... else</code> gets a semicolon because it's just an optional extension to <code>let</code> which gets a semicolon.</p>\n</blockquote>\n<p>I think I'm just stuck on <em>why</em> <code>if</code> doesn't.  As far as I can tell the rule is \"you don't have to put semicolons after <code>}</code>s (unless you care about the value of the expression)\", but this isn't an expression, so...</p>",
        "id": 234901909,
        "sender_full_name": "scottmcm",
        "timestamp": 1618598325
    },
    {
        "content": "<p>That's a fair consideration. But I'm less concerned about \"why <code>if</code> doesn't\" in this context, and more observing that <code>let</code> does.</p>",
        "id": 234902116,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598427
    },
    {
        "content": "<p>My rationale is primarily that <code>let ... else</code> should act like an extension of <code>let</code>.</p>",
        "id": 234902152,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598440
    },
    {
        "content": "<p>I'm assuming you'd agree that <code>let</code> <em>should</em> have a semicolon.</p>",
        "id": 234902178,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598462
    },
    {
        "content": "<p>And I think it's more important for <code>let ... else</code> to be consistent with <code>let</code> than it is important to override that with \"but it ends in a <code>}</code>\".</p>",
        "id": 234902231,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598503
    },
    {
        "content": "<p>Syntactically, the else seems like a part of the let. <code>let $pattern = $expr [ else { $stmts } ] ;</code>. It'd seems <em>more</em> complex to me, from a language-understanding point of view, to make that <code>let $pattern = $expr $( ; $| else { $stmts } $)</code>. (<code>$</code> here meaning \"this is metasyntax, not syntax\".)</p>",
        "id": 234902556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598660
    },
    {
        "content": "<p>Honestly if you're not diverging in the <code>else</code> branch then you should really be using <code>match</code> instead.</p>",
        "id": 234902711,
        "sender_full_name": "Amanieu",
        "timestamp": 1618598737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Agreed.</p>",
        "id": 234902750,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618598756
    },
    {
        "content": "<p>Reading back old RFC comments but translated to 2021:<br>\nIn the case of <code>Option</code>/<code>Result</code> (including the other scope) this is the same as <code>Try</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Even in the opposite case:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">ok_or_else</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"cm\">/* something */</span><span class=\"p\">))</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234903468,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618599078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234902178\">said</a>:</p>\n<blockquote>\n<p>I'm assuming you'd agree that <code>let</code> <em>should</em> have a semicolon.</p>\n</blockquote>\n<p>Absolutely, but it also doesn't syntactically end with a <code>}</code>, so it needs <em>a</em> marker to know that it's the end.  (I don't really care whether it's a semicolon, other than that it already is.  If it was a <code>,</code> that'd be fine too, since the <code>let</code> isn't an expression so doesn't need to follow expression rules for statements.)</p>\n<p>TBH, <code>loop</code> (and <code>if</code> and ...) needs the semicolon \"more\" (in a sense) than let-else would, because of the ol' <code>loop{}-loop{}</code> ambiguity.  (Which let-else doesn't have, because the end of the else is unambiguously the end of the statement.)</p>",
        "id": 234904107,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599392
    },
    {
        "content": "<p>Hmm, at work we have <em>at least</em> one instance of the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Thing</span>::<span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">WrapError</span><span class=\"p\">(</span><span class=\"n\">eyre</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234904374,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618599517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234903468\">said</a>:</p>\n<blockquote>\n<p>Reading back old RFC comments but translated to 2021:<br>\nIn the case of <code>Option</code>/<code>Result</code> (including the other scope) this is the same as <code>Try</code>:</p>\n</blockquote>\n<p>Notably, with the variable scoping rules that we've been discussing here, you <em>cannot</em> describe <code>?</code> in terms of <code>let else</code>.</p>",
        "id": 234904609,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599614
    },
    {
        "content": "<p>This would then sugar as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Thing</span>::<span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">WrapError</span><span class=\"p\">(</span><span class=\"n\">eyre</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">));</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234904629,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618599624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Could you elaborate?</p>",
        "id": 234904733,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618599668
    },
    {
        "content": "<p>It'd be <code>let Thing::A(x) = y else { ... }</code>.</p>",
        "id": 234904766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618599687
    },
    {
        "content": "<p>Oh, oops, thanks (edited).</p>",
        "id": 234904784,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618599701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234904733\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> Could you elaborate?</p>\n</blockquote>\n<p>The problem is that it doesn't return <code>y</code>, it returns the value of the <code>Err</code> variant.</p>",
        "id": 234905151,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599852
    },
    {
        "content": "<p>Which I guess could technically be pulled out, but without typestate you end up needing an <code>Ok</code> arm inside the <code>else</code>, at which point using <code>let else</code> is materially worse than using <code>match</code>.</p>",
        "id": 234905220,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599885
    },
    {
        "content": "<p>The usual (if not exactly correct) explanation of <code>let y = x?;</code> is <code>let y = match x { Ok(v) =&gt; v, Err(e) =&gt; return Err(e.into()) };</code>.</p>\n<p>But with <code>let else</code> that'd end up being something like</p>\n<div class=\"codehilite\"><pre><span></span><code>let y = Ok(x)\nelse {\n    match x {\n        Ok(_) =&gt; unreachable!(),\n        Err(e) =&gt; return Err(e.into()),\n    }\n}\n</code></pre></div>\n<p>which is materially worse than the <code>match</code>.</p>",
        "id": 234905461,
        "sender_full_name": "scottmcm",
        "timestamp": 1618599998
    },
    {
        "content": "<p>Why would we want to describe <code>?</code> in terms of <code>let else</code>?</p>",
        "id": 234905724,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618600123
    },
    {
        "content": "<p>That's why in the other thread I was spitballing</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234905737,
        "sender_full_name": "scottmcm",
        "timestamp": 1618600128
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234905813,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618600182
    },
    {
        "content": "<p>(Do we allow <code>else</code> to be followed by an <code>if</code> here?)</p>",
        "id": 234905838,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618600201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20Pattern.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234905724\">said</a>:</p>\n<blockquote>\n<p>Why would we want to describe <code>?</code> in terms of <code>let else</code>?</p>\n</blockquote>\n<p>I don't know, but I thought that's what your earlier \"this is the same as Try\" post was discussing, though.</p>",
        "id": 234905892,
        "sender_full_name": "scottmcm",
        "timestamp": 1618600210
    },
    {
        "content": "<p>Oh I meant that our examples thus far could be modeled via <code>ok_or_else</code> + <code>?</code>.</p>",
        "id": 234905959,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618600238
    },
    {
        "content": "<p><code>else match</code> isn't a thing for <code>if</code> statements either, I think?</p>",
        "id": 234906238,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618600377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> I think we shouldn't extend this just so that it can be used to desugar <code>?</code>, because we already have a desugaring for <code>?</code> that works.</p>",
        "id": 234906650,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600572
    },
    {
        "content": "<p>I can understand how it would work, but it feels far more complex to me.</p>",
        "id": 234906687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600590
    },
    {
        "content": "<p>That said, <code>else match { ... }</code> could be introduced in the future <em>if</em> we want to do so, and that wouldn't be incompatible with an <code>else { ... }</code> that must diverge.</p>",
        "id": 234907058,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618600786
    },
    {
        "content": "<p>Regular if-else requires a block and IMO this should require a block too for consistency.</p>",
        "id": 234909355,
        "sender_full_name": "nagisa",
        "timestamp": 1618601888
    },
    {
        "content": "<p>another question- what if we don't require the <code>else</code> block to diverge, but just let the pattern bindings be possibly-uninitialized if it doesn't? i.e. if those bindings are never used then we don't report an error; if they are used then we report an error the same way as e.g. <code>let x; if EXPR { x = 3 }; use(x)</code></p>",
        "id": 234928489,
        "sender_full_name": "rpjohnst",
        "timestamp": 1618610803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234928489\">said</a>:</p>\n<blockquote>\n<p>another question- what if we don't require the <code>else</code> block to diverge, but just let the pattern bindings be possibly-uninitialized if it doesn't? i.e. if those bindings are never used then we don't report an error; if they are used then we report an error the same way as e.g. <code>let x; if EXPR { x = 3 }; use(x)</code></p>\n</blockquote>\n<p>What would the advantage of this be?</p>",
        "id": 234929957,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618611704
    },
    {
        "content": "<p>Assuming the else block has no way to initialize the bindings, that means that <code>let Some((x, y, z)) = bla else { foo() };</code> or similar will always make all the bindings in the pattern inaccessible, in which case it may as well be <code>let Some((_, _, _)) = bla else { foo() };</code> which can also be written as <code>if let Some((_, _, _)) = bla {} else { foo() }</code>, so let-else is useless here. You can't even assign to <code>x,y,z</code> like you would with <code>let (x, y, z);</code> because they are possibly already initialized and they aren't mutable bindings.</p>",
        "id": 234956555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618631152
    },
    {
        "content": "<p>FWIW I think let-else should require a semicolon. It is a statement, and all statements require a semicolon after them. The only time semicolons are optional is for expressions that are also (ignore-)statements, which end in a brace. The semicolon in <code>let x = if cond {};</code> is not optional even though it ends in a brace.</p>",
        "id": 234956655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618631254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234909355\">said</a>:</p>\n<blockquote>\n<p>Regular if-else requires a block and IMO this should require a block too for consistency.</p>\n</blockquote>\n<p>I agree with that in general, but here I'm actually using it as something different from what <code>else { match</code> would do -- this match would need to desugar into the same match as the one implied by the <code>let</code> to be able to omit the <code>Ok</code> arm without needing typestate.</p>\n<p>That said, I'm mentioning more for the sake of exploring the space (\"what might it be if it does need to be able to look at other variants?\") than as something that I really think is necessary for the feature.</p>",
        "id": 234958359,
        "sender_full_name": "scottmcm",
        "timestamp": 1618633353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/234956655\">said</a>:</p>\n<blockquote>\n<p>FWIW I think let-else should require a semicolon. It is a statement, and all statements require a semicolon after them. The only time semicolons are optional is for expressions that are also (ignore-)statements, which end in a brace. The semicolon in <code>let x = if cond {};</code> is not optional even though it ends in a brace.</p>\n</blockquote>\n<p>I feel like the precedent of \"don't need a semicolon after a brace\" is pretty strong:</p>\n<h2>No brace, so semicolon</h2>\n<div class=\"codehilite\"><pre><span></span><code>struct Foo;\nstruct Foo(i32);\ntype Foo = i32;\nconst FOO: u32 = 4;\nmod foo;\npub use foo::bar;\n</code></pre></div>\n<h2>Ends in brace, so no semicolon</h2>\n<div class=\"codehilite\"><pre><span></span><code>struct Foo { x: i32 }\nmod foo { ... }\nfn foo() { ... }\nimpl Foo { ... }\ntrait Foo { ... }\n</code></pre></div>",
        "id": 234958485,
        "sender_full_name": "scottmcm",
        "timestamp": 1618633562
    },
    {
        "content": "<p>All of those examples are items though</p>",
        "id": 234959826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618635163
    },
    {
        "content": "<p>The following does not compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 234959980,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618635362
    },
    {
        "content": "<p>Any RFC I write for this will include a trailing semicolon.</p>",
        "id": 234960054,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1618635417
    },
    {
        "content": "<p>The counter-argument is that <code>let x = {};</code> and <code>let x = if cond {};</code> have required semicolons because they are composite objects, and <code>let x = expr;</code> requires a semicolon because it doesn't itself end in a brace, even though <code>expr</code> might. By contrast <code>let x = expr else { expr* }</code> is a single thing, and braces are a required part of that thing, so it's okay to leave off the semicolon. I don't agree with this reasoning because it depends essentially on let-else being a single \"thing\", which seems incidental. If we think of it as <code>let x = expr (optional_trailing_thing)?;</code> then there is no brace to be seen</p>",
        "id": 234960382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618635745
    },
    {
        "content": "<p>I don't think of it as \"optional trailing thing\", because it fundamentally changes what patterns are allowed.  For example, there's no reason to ever put the trailing part on <code>let x = expr</code>, because that's an irrefutable pattern.  And <code>let Some(x) = expr</code> the trailing thing isn't <em>optional</em>.</p>",
        "id": 234960841,
        "sender_full_name": "scottmcm",
        "timestamp": 1618636286
    },
    {
        "content": "<p>that seems more like a type checking concern than syntax though</p>",
        "id": 234961134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618636613
    },
    {
        "content": "<p>as far as syntax is concerned a <code>let</code> may or may not have an <code>else</code> after it</p>",
        "id": 234961150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618636645
    },
    {
        "content": "<p>in the same way that a <code>match</code> can have zero or more branches, even though the types will generally determine the number of branches (assuming only simple matches)</p>",
        "id": 234961218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618636713
    },
    {
        "content": "<p>Reading back through the old RFC, this comment is interesting, as it suggests the part after the else could be any expression rather than a block: </p>\n<p><a href=\"https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144975266\">https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144975266</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// default value?!</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"s\">\"no error\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Token</span><span class=\"p\">(</span><span class=\"n\">TokenLiteral</span>::<span class=\"nb\">String</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">token</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"s\">\"string token expected\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 236100147,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619391469
    },
    {
        "content": "<p>It is not syntactically ambiguous but today I believe it'd probably be a mistake for consistency reasons.</p>",
        "id": 236100527,
        "sender_full_name": "nagisa",
        "timestamp": 1619391771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> no rush, but I’d love to hear an elaboration</p>",
        "id": 236103004,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619394370
    },
    {
        "content": "<p>Although it is a pretty easy argument to only allow a block for consistency with <code>if let</code>.</p>",
        "id": 236103165,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619394532
    },
    {
        "content": "<p>It's for consistency with else of if-else.</p>",
        "id": 236103753,
        "sender_full_name": "nagisa",
        "timestamp": 1619395110
    },
    {
        "content": "<p>If people see <code>let x = y else z;</code> they will naturally expect that <code>if a {} else b</code> should work too.</p>",
        "id": 236103783,
        "sender_full_name": "nagisa",
        "timestamp": 1619395187
    },
    {
        "content": "<p>Agreed</p>",
        "id": 236104253,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619395657
    },
    {
        "content": "<p>Does anyone in this thread have the bandwidth and inclination to push this forward, perhaps by proposing a lang MCP? I'd be happy to provide guidance for anyone interested in doing so.</p>",
        "id": 236119000,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619411608
    },
    {
        "content": "<p>I want to but it may be a couple weeks</p>",
        "id": 236196889,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619451517
    },
    {
        "content": "<p>Why an MCP and not an RFC? I was planning to write an updated RFC with argument answers from here.</p>",
        "id": 236197004,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619451568
    },
    {
        "content": "<p>That may potentially be reasonable, but I want to account for the fact that the previous efforts in this area weren't postponed for lack of interest, but for lack of available bandwidth. So at a minimum, even if the right next step is an updated RFC, I think it would be important to confirm with the rest of the language team that an updated RFC would be something we'd be prepared to consider at this time.</p>",
        "id": 236213700,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619458516
    },
    {
        "content": "<p>I'm hopeful that it would be, but I would hate to see a bunch of work go into updating the RFC if the bandwidth isn't available to review it.</p>",
        "id": 236213749,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619458537
    },
    {
        "content": "<p>If you mean <a href=\"https://forge.rust-lang.org/compiler/mcp.html\">https://forge.rust-lang.org/compiler/mcp.html</a> - that seems unsuitable? Or does the language team have it's own MCPs?</p>",
        "id": 236246138,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619471914
    },
    {
        "content": "<p>Perhaps <a href=\"https://github.com/rust-lang/lang-team/issues/new?assignees=&amp;labels=major-change%2C+T-lang&amp;template=project_proposal.md&amp;title=%28My+project+proposal%29\">https://github.com/rust-lang/lang-team/issues/new?assignees=&amp;labels=major-change%2C+T-lang&amp;template=project_proposal.md&amp;title=%28My+project+proposal%29</a></p>",
        "id": 236249720,
        "sender_full_name": "scottmcm",
        "timestamp": 1619473401
    },
    {
        "content": "<p>I don't see how this deserves it's own Zulip topic and whatnot. That seems more heavyweight for this change rather than lightweight...</p>",
        "id": 236249998,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619473554
    },
    {
        "content": "<p>Another question, based on some code I saw in the old RFC - What would be the behavior of:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Enum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And potentially also:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Enum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This case really seems quite confusing... (Maybe it should be disallowed?)</p>",
        "id": 236919830,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619827906
    },
    {
        "content": "<p>Personally I take the 'ab' example as being a compile error, and the 'c' branch in the 'abc' example to be the divergent branch.</p>\n<p>This would be fine syntax wise (I think?) but it may be hard to teach / introduce people to / have people read code with it.</p>",
        "id": 236919972,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619828049
    },
    {
        "content": "<p>I would say make them both invalid and require/suggest <code>let Enum(x) = (if y { a } else { b }) else { c };</code></p>",
        "id": 236920302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619828391
    },
    {
        "content": "<p>Ah, we can't make the first one invalid</p>",
        "id": 236920361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619828422
    },
    {
        "content": "<p>The first one can never be validly interpreted as <code>let Enum(x) = (if y { a }) else { b };</code> because <code>()</code> is not an enum</p>",
        "id": 236920493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619828528
    },
    {
        "content": "<p>so it should always be interpreted as <code>let Enum(x) = (if y { a } else { b });</code>, and I don't think there are any options for hinting the other pattern</p>",
        "id": 236920531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619828596
    },
    {
        "content": "<p><code>let Pattern(x) = y;</code> isn't valid though <em>(well, see below)</em>, which would have to make the 'ab' example invalid if <code>if y { a } else { b }</code> always has to be interpreted as <code>(if y { a } else { b })</code></p>\n<p>I also don't think that <code>let Enum(x) = (if y { a }) else { b };</code> can ever be valid? isn't the return of <code>if expr block</code> without an <code>else</code> always <code>()</code>?<br>\n<em>(I don't actually know, but I assume it must be unit because I don't know what else it could be.)</em></p>",
        "id": 236921161,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619829194
    },
    {
        "content": "<p>(Ok theoretically it could be <code>Option</code> because <code>Some</code> and <code>None</code> map to <code>if expr block;</code>, but I as far as I am aware, that isn't a thing which exists.)</p>",
        "id": 236921292,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619829274
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0317]: `if` may be missing an `else` clause\n --&gt; src/main.rs:2:13\n  |\n2 |     let x = if true { 1 };\n  |             ^^^^^^^^^^-^^\n  |             |         |\n  |             |         found here\n  |             expected `()`, found integer\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n</code></pre></div>\n<p>Yeah, my assumptions appear correct.</p>",
        "id": 236921415,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619829386
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0005]: refutable pattern in local binding: `None` not covered\n   --&gt; src/main.rs:2:9\n    |\n2   |     let Some(x) = Some(1);\n    |         ^^^^^^^ pattern `None` not covered\n    |\n    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `Option&lt;i32&gt;`\nhelp: you might want to use `if let` to ignore the variant that isn&#39;t matched\n    |\n2   |     if let Some(x) = Some(1) { /* */ }\n</code></pre></div>\n<p>TIL you can do that with single variant enums. The following compiles, to my surprise:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Only</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Only</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Only</span>::<span class=\"n\">Only</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Only</span>::<span class=\"n\">Only</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 236921608,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619829624
    },
    {
        "content": "<p>Maybe this is identical to what you said and I just didn't understand it. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 236921745,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619829788
    },
    {
        "content": "<p>Niko's suggestion (from <a href=\"https://github.com/rust-lang/rfcs/pull/1303#issuecomment-188526691\">https://github.com/rust-lang/rfcs/pull/1303#issuecomment-188526691</a>) of requiring <code>else return</code> or <code>else continue</code> or <code>else break</code> would probably solve that <code>else {} else {}</code> (which was cited as one of the reasons the lang team at the time moved to postpone the old rfc: <a href=\"https://github.com/rust-lang/rfcs/pull/1303#issuecomment-183437307\">https://github.com/rust-lang/rfcs/pull/1303#issuecomment-183437307</a>), but conflicts with the other things in this thread about why <code>else</code> should always be followed by a block.</p>",
        "id": 236923359,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619831313
    },
    {
        "content": "<p>A potential issue with that proposal is that not every diverging statement is a <code>return</code>, <code>continue</code>, or <code>break</code> but rather anything which returns <code>!</code>.</p>",
        "id": 236923987,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619831915
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/236921161\">said</a>:</p>\n<blockquote>\n<p><code>let Pattern(x) = y;</code> isn't valid though <em>(well, see below)</em>, which would have to make the 'ab' example invalid if <code>if y { a } else { b }</code> always has to be interpreted as <code>(if y { a } else { b })</code></p>\n</blockquote>\n<p>Note that syntactic disambiguation has to happen at parse time, before types are available. Besides single variant enums, tuple structs also have exactly the same syntax, so we can't be sure that the user didn't mean <code>let Struct(x) = (if y { a } else { b });</code>, which is valid and stable</p>",
        "id": 236926187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619834190
    },
    {
        "content": "<p>My point is that even if we knew that it is a refutable pattern, there is still no way <code>let Some(x) = if y { a } else { b };</code> can be correct. If we interpret it as <code>let Some(x) = (if y { a } else { b });</code> then it's a let binding on a refutable pattern, which is invalid, and if we interpret it as <code>let Some(x) = (if y { a }) else { b };</code> then it's a type error because <code>if y { a }</code> has type <code>()</code>, not <code>Option&lt;_&gt;</code>. Conceivably we can have a smart error message here, but I would be inclined to always interpret this case as <code>let Some(x) = (if y { a } else { b });</code> with the other interpretation only appearing in error hints</p>",
        "id": 236926341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619834395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/236923987\">said</a>:</p>\n<blockquote>\n<p>A potential issue with that proposal is that not every diverging statement is a <code>return</code>, <code>continue</code>, or <code>break</code> but rather anything which returns <code>!</code>.</p>\n</blockquote>\n<p>This is not a significant problem, since you can always write <code>else return panic!()</code>, although it is a little bit misleading.</p>",
        "id": 236926516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619834522
    },
    {
        "content": "<p>Makes sense. I've come around to it having to be <code>let Some(x) = (if y { a } else { b });</code> and not a compile error. (Although in most cases the compiler will <em>then</em> tell you <code>error[E0005]: refutable pattern in local binding: ...</code>)</p>",
        "id": 236926568,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619834551
    },
    {
        "content": "<p>Right, and for the <code>else {} else {}</code> issue requiring parentheses seems like the most natural solution (we already have a precedent of doing this inside if-conditions)</p>",
        "id": 236926646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619834616
    },
    {
        "content": "<p>And yes this is true, with Niko's proposal from the RFC, you could write <code>else return function_which_returns_never()</code>.</p>",
        "id": 236926666,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619834637
    },
    {
        "content": "<blockquote>\n<p>(we already have a precedent of doing this inside if-conditions)</p>\n</blockquote>\n<p>I don't think I've seen this, could you provide or link to an example? (I also don't know what I'd search for that?)</p>",
        "id": 236926750,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619834678
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is a parse error</p>",
        "id": 236926759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619834703
    },
    {
        "content": "<p>Wait, do you mean <code>if (if ...) ...</code>?</p>",
        "id": 236926762,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619834705
    },
    {
        "content": "<p>wait no that's the wrong example</p>",
        "id": 236926804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619834747
    },
    {
        "content": "<p>Ah, here it is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 236927338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619835186
    },
    {
        "content": "<p>here's a version of the syntax ambiguity inside an if condition</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">bla</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}.</span><span class=\"n\">bla</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 236927459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619835294
    },
    {
        "content": "<p>The following compiles (somewhat surprisingly):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sc\">'a'</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sc\">'b'</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 236927512,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619835350
    },
    {
        "content": "<p>The issue seems to be mainly around struct literals used with <code>{}</code> syntax inside the condition of a match, if, or while</p>",
        "id": 236927594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619835402
    },
    {
        "content": "<p>I guess nested if statements are okay because of the <code>if if</code></p>",
        "id": 236927633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619835463
    },
    {
        "content": "<p>The difference between my example there and <code>if ... let</code> is <code>else { } { } else {}</code> vs <code>else {} else {}</code>.</p>",
        "id": 236927639,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619835472
    },
    {
        "content": "<p>(And the presence of <code>if</code>.)</p>",
        "id": 236927697,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1619835492
    },
    {
        "content": "<p>Ooh, this is actually ambiguous:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Bla</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">ops</span>::<span class=\"n\">Add</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bla</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">())</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Bla</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 236928032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619835779
    },
    {
        "content": "<p>My thinking on these examples is that we should always prefer the interpretation which doesn't use let-else, and if it matches the <code>let pat = expr else block</code> grammar but not the <code>let pat = expr</code> grammar then it should still be rejected if <code>expr</code> ends in a <code>}</code>, unless it is a block expression (and in this case we recommend putting <code>expr</code> in parentheses)</p>",
        "id": 236928545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619836217
    },
    {
        "content": "<p>Looking at the expr grammar, the ones that end in <code>}</code> are: <code>{ }</code>, <code>unsafe { }</code>, <code>const { }</code>, <code>async { }</code>, <code>for ... { }</code>, <code>while ... { }</code>, <code>loop { }</code>, <code>if ... (else if...) { }</code>, <code>match ... { }</code>, <code>Struct { }</code>, <code>macro! { }</code>.</p>\n<p>If we don't ban their use at the end of <code>expr</code> in <code>let pat = expr else block</code>, then we are essentially committing to never allowing <code>else</code> to follow the expression. At the very least <code>if</code> needs to be banned, but I think that for future growth it would be best to ban all of them except for blocks, unsafe/const/async, and maybe struct literals.</p>",
        "id": 236929250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619836808
    },
    {
        "content": "<p>So, our conclusion at the time was that we weren't worried about if returning (), and didn't think that would come up in existing code.</p>",
        "id": 236942064,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1619849170
    },
    {
        "content": "<p>Is that why the <code>else {} else {}</code> case seemed to be the only one mentioned in the RFC (if memory serves)?</p>",
        "id": 237245447,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1620083908
    },
    {
        "content": "<p>So at work we have a bunch of both <code>if let Some(x) = y { .. }</code> code, but we also have a large state machine which uses enums for a kind of variadic overloading, and there is a lot of <code>if let Enum::Type(...) = y { ... big statement ... } else { /* this is an error */}</code> code. I'd like to try a refactoring pass to gauge the existing cited solutions (such as <code>let x = if let T(x) = y { x } else { ... };</code>, which i always forget about. I'll try to collect the results of that into some form that can be shared in an RFC. The plan was to do that this week but I may not get to it this week and I'm off next week so this might still be a few weeks until RFC is written up.</p>",
        "id": 237245790,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1620084161
    },
    {
        "content": "<p>Writing some words - are <code>if let</code> and <code>let else</code> <em>statements</em> or are they  <em>expressions</em>?</p>",
        "id": 240877418,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622501412
    },
    {
        "content": "<p>Oh, <code>if let</code> is an expression because it can return things, right?</p>",
        "id": 240877558,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622501633
    },
    {
        "content": "<p><code>if let ...</code> is an expression, <code>let ... else { ... }</code> is a statement</p>",
        "id": 240877651,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1622501713
    },
    {
        "content": "<p>like how <code>let a = 23;</code> is a statement</p>",
        "id": 240877667,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1622501748
    },
    {
        "content": "<p>I wrote most of an updated RFC for this, if anyone would like to review it. I still need to gather some examples and copy edit it a bunch.</p>\n<p><a href=\"https://github.com/Fishrock123/rfcs/blob/2b92ef583be8521ec9506cb11d99a02963ffb398/text/0000-let-else.md\">https://github.com/Fishrock123/rfcs/blob/2b92ef583be8521ec9506cb11d99a02963ffb398/text/0000-let-else.md</a></p>",
        "id": 240884629,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622509729
    },
    {
        "content": "<p>I have largely preferred <code>match</code> as the existing counterpoint example, as I've never seen <code>if let { assignment ] else { }</code> in real code, but I've seen <code>match</code> with early return quite a lot, and there was a servo example in the old rfc too.</p>",
        "id": 240884791,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622509890
    },
    {
        "content": "<p>Looks quite good! I'd maybe spend less space on examples of the current situation in the Examples section, instead showing some further examples of the new situation, like maybe with <code>Result</code> and another enum (<code>std::task::Poll</code>?)</p>\n<p>For the drawbacks (diverging blocks), maybe talk about what diagnostics could do make this more friendly to less experienced users. Maybe the word \"diverging\" should be used less, instead using \"return/continue/break\" more?</p>\n<p>There's a broken link to <code>original-rfc</code> and a few typos: proceding, guarenteed, Fundimentally, Varient. But in general I think this is definitely of high enough quality to become an actual rfcs repo PR.</p>",
        "id": 240902424,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1622531459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> As I mention in my comment on the old RFC: <a href=\"https://github.com/rust-lang/rfcs/pull/1303#issuecomment-840744369\">https://github.com/rust-lang/rfcs/pull/1303#issuecomment-840744369</a> , the syntax should be <code>let PATTERN = EXPRESSION_WITHOUT_BLOCK else BLOCK</code>. The \"expression without block\" syntactic class is defined at <a href=\"https://doc.rust-lang.org/reference/expressions.html#expressions\">https://doc.rust-lang.org/reference/expressions.html#expressions</a> . Among other things, this also makes sure to disallow <code>if let</code> in your expression position, which this draft RFC seems to overlook.</p>",
        "id": 240971030,
        "sender_full_name": "bstrie",
        "timestamp": 1622566257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> Ah, thanks. Does that still allow e.g. <code>let foo = unsafe { bar } else { qux };</code> to be written with parenthesis as <code>let foo = (unsafe { bar }) else { qux };</code>?</p>\n<p>The draft implicitly considers <code>if let else</code> in the expression position to be equivalent to <code>if else</code>. I could clarify that, but I'm also not sure it really matters, since it is essentially the same.</p>",
        "id": 240974411,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622567754
    },
    {
        "content": "<p><code>let Enum:V(a) = (if let Some(b) { b.get_enum() } else { some_fallback() }) else { return make_an_error(); };</code> is somewhat convoluted but doesn't seem invalid.</p>",
        "id": 240974840,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622567957
    },
    {
        "content": "<p>Clippy should probably suggest against putting conditionals in the expression though, due do how it once again separates the <code>let</code> assignment conditional from the <code>else</code> block, like stated in the draft RFC.</p>\n<p>(though, the same thing can be said for <code>if else</code> nested within the expression position of <code>if let</code>.)</p>",
        "id": 240975014,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622568024
    },
    {
        "content": "<blockquote>\n<p>Does that still allow e.g. let foo = unsafe { bar } else { qux }; to be written with parenthesis as let foo = (unsafe { bar }) else { qux };?</p>\n</blockquote>\n<p>Yes it would, <code>(unsafe { bar })</code> is a GroupedExpression, which in the category of ExpressionWithoutBlock</p>\n<blockquote>\n<p>The draft implicitly considers if let else in the expression position to be equivalent to if else.</p>\n</blockquote>\n<p>Sure, still worth clarifying though (and they are technically separate expression classes, both ExpressionWithBlock).</p>",
        "id": 240975494,
        "sender_full_name": "bstrie",
        "timestamp": 1622568250
    },
    {
        "content": "<p>As an aside, I think <span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span>'s suggestion of <code>ExpressionWithoutBlock</code> (rather than excluding only <code>if</code>/<code>if let</code>) is especially reasonable for loops, since there have for a long time been proposals floating around for <code>else</code> on various loop types, so it's more backwards compatible to exclude those just in case.</p>\n<p>And while it would be unambiguous for some block types like <code>unsafe</code>, it seems bad for human readers to encounter <code>let pat = some_block { ... } else { ... }</code> and not know how to parse it if they aren't yet familiar with the particular <code>some_block</code> type in question.</p>",
        "id": 240977526,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622569139
    },
    {
        "content": "<p>Yeah, I also like the suggestion of <code>ExpressionWithoutBlock</code> now that I have some understanding of <code>GroupedExpression</code>. (these details are all new to me!)</p>",
        "id": 240977877,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622569311
    },
    {
        "content": "<p>Thanks for redrafting this RFC, by the way. I can't believe it's been almost 6 years since I started arguing for this feature. :P</p>",
        "id": 240978265,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622569456
    },
    {
        "content": "<p>Hmm, not to devolve into bikeshedding, but the <code>try</code> keyword was <em>not</em> available when the original RFC was drafted, and now is (in 2018 edition and newer). So we <em>could</em> suggest <code>try let ... = ... else { ... }</code> to match more closely with Swift's <code>guard let</code>, but some people might dislike this overloading of <code>try</code>.</p>",
        "id": 240979375,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622569988
    },
    {
        "content": "<p>Though I'm not sure where else <code>try</code> is even used, maybe just <a href=\"https://doc.rust-lang.org/nightly/unstable-book/language-features/try-blocks.html\">this unstable feature</a>?</p>",
        "id": 240979540,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622570045
    },
    {
        "content": "<p>I personally think it would be quite clear that <code>try let</code> is distinct from <code>try { ... }</code> blocks, and I'm not bothered that <code>try let</code> would not be directly related to the <code>Try</code> trait, but I'm sure opinions will differ.</p>",
        "id": 240979842,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622570193
    },
    {
        "content": "<p>the current status of the <code>try</code> keyword is so vague and confusing that it really ought to just be punted back to the RFC process, IMO. probably best to ignore that quagmire for now and mention it as an alternative</p>",
        "id": 240980120,
        "sender_full_name": "bstrie",
        "timestamp": 1622570313
    },
    {
        "content": "<p>I'll note it as an alternative, but this RFC attempts to keep maximum consistency with existing language features first and foremost.</p>",
        "id": 240980931,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622570662
    },
    {
        "content": "<p>I agree with that motivation for simply listing it as an alternative, but <code>try let</code> is <em>more</em> consistent with existing languages I'm familiar with.</p>",
        "id": 240982340,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622571274
    },
    {
        "content": "<p>(I meant <em>rust</em> language features that already exist.)</p>",
        "id": 240982456,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622571314
    },
    {
        "content": "<p>Ah, well then I think it's very highly subjective. :P</p>",
        "id": 240982533,
        "sender_full_name": "Scott Olson",
        "timestamp": 1622571352
    },
    {
        "content": "<p>I still think <code>unless let Some(x) = x { continue }</code> is the <em>most</em> consistent, but I understand that people don't like that one :P</p>",
        "id": 240986965,
        "sender_full_name": "scottmcm",
        "timestamp": 1622573346
    },
    {
        "content": "<p><code>unless</code> isn't even an existing keyword though (which isn't necessarily a bad thing but isn't how I am aiming at this)</p>",
        "id": 240987603,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622573651
    },
    {
        "content": "<p>Well, I suspect that it could be contextual in the <code>unless let</code> case, but yes, it certainly would need to a proper keyword for <code>unless x &gt; 0 { continue }</code> to also work.</p>",
        "id": 240987759,
        "sender_full_name": "scottmcm",
        "timestamp": 1622573758
    },
    {
        "content": "<p>rather than <code>unless let</code> I'll speculatively bikeshed for <code>if not let</code>, so that we can replace <code>!</code> with <code>not</code> and start reclaiming the sigils :P Python/C++-style <code>and</code> and <code>or</code>, here we come!</p>",
        "id": 241062382,
        "sender_full_name": "bstrie",
        "timestamp": 1622575306
    },
    {
        "content": "<p>How does this interact with <a href=\"https://rust-lang.github.io/rfcs/2497-if-let-chains.html\"><code>if-let-chains</code></a>?</p>\n<p>If you’re eventually able to write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"cm\">/* else { ... } */</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then people will be confused if there is no way to do the same thing in a let-else statement (or whatever it’s going to be called).</p>\n<p>You can’t allow</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because with ordinary <code>let</code>, the <code>&amp;&amp;</code> binds weaker, so this will (try to) be parsed</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Not 100% sure if this can’t be rectified at all, but it looks pretty bad. This would be another major advantage of <code>unless</code> (or <code>if not</code> or similar), which can “just” work</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241081102,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622584729
    },
    {
        "content": "<p>Doing these with <code>if !let …</code>, it could look like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and/or</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_not_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241081857,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622585181
    },
    {
        "content": "<p>a binding introduced that far to the right seems kind of hard to read to me</p>",
        "id": 241082018,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1622585302
    },
    {
        "content": "<p>That’s kind-of the case with ordinary let-chains as-well. Better formatting would probably put each condition of a long chain on a separate line.</p>",
        "id": 241082077,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622585357
    },
    {
        "content": "<p>So roughly following the line-breaking and indentation of the let-chain RFC, it looks like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_not_baz</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_not_baz</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241082243,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622585477
    },
    {
        "content": "<p>Haha, <code>unless</code> is precisely the right length to make all the <code>let</code>s align!</p>",
        "id": 241082275,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622585507
    },
    {
        "content": "<p>Good question, this has not been discussed before I think.</p>",
        "id": 241082400,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622585606
    },
    {
        "content": "<p>Are \"ordinary let-chains\" a thing which exists?</p>",
        "id": 241082415,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622585624
    },
    {
        "content": "<p>They are a thing for which an accepted RFC exists, as linked above. Currently (AFAIK) they only exists in the parser in order “to make <code>if let PAT = EXPR &amp;&amp; ..</code> a possible option for Rust 2018”.</p>\n<p>Well, that was 3 years ago, seems like someone overestimated the time it takes to implement. No need to “rush” it into edition 2018 in retrospect. (Of course I wasn’t involved, so I don’t actually know if there was any “rushing” involved).</p>",
        "id": 241082667,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622585765
    },
    {
        "content": "<p>I don't know if theoretical let-else-chaining really makes sense. The reason for if-let-chaining is to condense multiple conditions together and avoid rightward drift, but there's no rightward drift with let-else. If you want to put multiple new variables in scope, you can just do multiple let-elses.</p>",
        "id": 241082730,
        "sender_full_name": "bstrie",
        "timestamp": 1622585842
    },
    {
        "content": "<p>I see an RFC for \"if let chains\", but not \"let chains\".</p>",
        "id": 241082918,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586003
    },
    {
        "content": "<p>Ah, I’m sorry, I abbreviated if-let-chains to let-chains to save a few letters of typing.</p>",
        "id": 241082974,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586033
    },
    {
        "content": "<p>They also cover <code>while let</code> chains, so if-let-chains is not 100% accurate terminology anyway</p>",
        "id": 241083002,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586066
    },
    {
        "content": "<p>well, <code>while</code> is just a <code>loop-if</code> statement :P</p>",
        "id": 241083023,
        "sender_full_name": "bstrie",
        "timestamp": 1622586099
    },
    {
        "content": "<p>So I think this would technically be possible to support with an edition change to how existing irrefutable patterns for <code>let</code> are parsed.</p>\n<p>But also I don't see the value, as <span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> noted above. In common cases where you are making errors for these it is better to have unique error messages per failure case.</p>",
        "id": 241083097,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586141
    },
    {
        "content": "<p>I will note something in future possibilities though, and maybe also open questions.</p>",
        "id": 241083129,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586161
    },
    {
        "content": "<p>Just saying, I’ll <em>guarantee</em> that people will ask for it once both if-let-chains and let-else are a thing in stable Rust.</p>",
        "id": 241083168,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586190
    },
    {
        "content": "<p>You can use them to avoid repetition of the same else block.</p>",
        "id": 241083216,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280891\">Frank Steffahn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241083216\">said</a>:</p>\n<blockquote>\n<p>You can use them to avoid repetition of the same else block.</p>\n</blockquote>\n<p>Yes, but also in the case of <code>Result&lt;&gt;</code> this will almost certainly result in a worse program.</p>\n<p>It seems acceptable for <code>Option</code> I suppose. Also, there are some cases where you want to chain in <code>if let</code> which do not include multiple <code>let</code> assignments (I forget off the top of my head if that exists already today). However, let-else is not an <code>if</code> expression in any other way either...</p>",
        "id": 241083525,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586456
    },
    {
        "content": "<p>Also, I personally consider (some form of) guards an essential part of (fallible) patterns. You can do a few fancy things without any guards like e.g. using range-patterns or slice patterns, but as soon as there’s a bit of complexity involved, you won’t want to miss your <code>PAT if GUARD =&gt; …</code> in <code>match</code> expressions or <code>matches!</code> macros. Admitted, <code>if let</code> doesn’t _directly_ support guards, the nicest way to do something like guards in <code>if let</code> or <code>while let</code> patterns is with a <code>&amp;&amp;</code>, as soon as if-let-chains are a thing (so <code>if let PAT = EXPR &amp;&amp; GUARD { ... }</code>). Before that (i.e. currently) you can make do with another nested <code>if</code> (so: <code>if let PAT = EXPR { if GUARD { ... } }</code>) for <code>if let</code> and you can use <code>break</code> for <code>while let</code> (i.e. <code>while let PAT = EXPR { if !GUARD { break; } ... }</code>).</p>",
        "id": 241083648,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586493
    },
    {
        "content": "<p>That is to say, would the following make sense?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">thing</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241083701,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586529
    },
    {
        "content": "<p>Maybe <code>if let</code> <em>should</em> support guards?</p>",
        "id": 241083772,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586583
    },
    {
        "content": "<p>If you know a reasonably syntax for guards in <code>if let</code> ;-)</p>\n<p>I think the <code>&amp;&amp; GUARD</code> option from if-let-chains is pretty nice already.</p>",
        "id": 241083861,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241083701\">said</a>:</p>\n<blockquote>\n<p>That is to say, would the following make sense?</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">thing</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, basically. Except for the fact that the <code>&amp;&amp;</code> binding weaker than <code>let</code> still feels weird. And that a single <code>return;</code> is such a simple block that it probably wouldn’t hurt anyone if they needed to repeat it.</p>",
        "id": 241083951,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622586709
    },
    {
        "content": "<p><code>&amp;&amp; GUARD</code> is weird because <code>let PATTERN = EXPR</code> isn't otherwise an expression, and doesn't evaluate to anything, so the operator order is pretty funky, but I guess it is what it is ...</p>",
        "id": 241084003,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622586729
    },
    {
        "content": "<p>Anyways, I haven’t thought through this all that much so far, I just had the idea that if-let-chains could be relevant to this discussion when discovering this thread today. I guess it’s at the very least worth a mention as a thing to consider / an alternative option / a future possibility / whatever in the RFC. Some more practical code examples (which I don’t currently have) wouldn’t hurt either before discussing this in too much more detail, especially to aid answering the question if this would be all that useful.</p>",
        "id": 241084546,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622587175
    },
    {
        "content": "<p>I'm having a hard time thinking of a circumstance where a let-else chain would be useful. An if-let chain is useful because you're steadily refining the data: you have an Option, now you have a Some, now you have a struct, is the struct field equal to something, and so on. But the conditions in a let-else chain would exist in the <em>absence</em> of any new data to refine, yes? It feels like you'd be saying \"diverge when this one thing false, but only if this other, completely unrelated thing is also false\", which doesn't feel especially common.</p>",
        "id": 241084552,
        "sender_full_name": "bstrie",
        "timestamp": 1622587181
    },
    {
        "content": "<p>Most of the rust code I've written is on the level of <code>Result</code>s and not <code>Option</code>s, code at work that would fit into this general sort of pattern never would anyways because we always want to have distinguishable error messages when possible.</p>",
        "id": 241085369,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622587766
    },
    {
        "content": "<p>That is to say, to me, if-let-chain is an antipattern <strong>except</strong> with <code>Option</code>, and I'd rather suggest against it entirely.</p>",
        "id": 241085448,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622587806
    },
    {
        "content": "<p>Another point would probably be refactoring.<br>\nSuppose you start with</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// LOTS OF CODE HERE</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// A BIT OF CODE, ALWAYS DIVERGING</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then you could always remove the depth of indentation of <code>LOTS OF CODE</code> by refactoring into</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// A BIT OF CODE, ALWAYS DIVERGING</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// LOTS OF CODE HERE</span>\n</code></pre></div>\n<p>Prohibiting unless-let-chains in the presence of a stable language feature for if-let-chains makes refactoring harder</p>\n<p>(The above argument of course assumes that if-let-chains are going to become a thing at all.)</p>\n<hr>\n<p>but my main point is just on the general usefulness of guards.</p>\n<p>I can do </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">@</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">..=</span><span class=\"mi\">10</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is also possible. Similarly</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">@</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">..=</span><span class=\"mi\">10</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and eventually</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>will work.</p>\n<p>But while</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">@</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">..=</span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"o\">....</span><span class=\"w\"></span>\n</code></pre></div>\n<p>can be used, there’s no alternative way using a guard except for</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">EXPR</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* duplicate the code */</span><span class=\"w\"> </span><span class=\"o\">....</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"o\">....</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(The main point of guards then, as mentioned, are cases where there is <em>no</em> magical compiler-provided alternative like range patterns.)</p>",
        "id": 241086220,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622588309
    },
    {
        "content": "<p>ah ok, I see the semantics that you're going for now</p>",
        "id": 241087349,
        "sender_full_name": "bstrie",
        "timestamp": 1622589163
    },
    {
        "content": "<p>if we want this to be the perfect inverse of <code>if-let</code> even taking chaining into account, then I resubmit <code>if not let</code> with 25% less facetiousness</p>",
        "id": 241087494,
        "sender_full_name": "bstrie",
        "timestamp": 1622589308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280891\">Frank Steffahn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241081102\">said</a>:</p>\n<blockquote>\n<p>You can’t allow</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because with ordinary <code>let</code>, the <code>&amp;&amp;</code> binds weaker, so this will (try to) be parsed</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>If we suggest that pattern-matching <code>let</code> statements be changed to have an operator precedence which matches if-let-chain in an edition, that seems like it can be overcome without too much trouble.</p>\n<p>We can suggest the following would be possible for 2018 edition:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">is_baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">yay</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241088669,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622590310
    },
    {
        "content": "<p>Note that if-let-chain also required edition changes</p>",
        "id": 241088742,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622590345
    },
    {
        "content": "<p>It's a bit odd that only the first <code>let</code> is not in parentheses there</p>",
        "id": 241094248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622595206
    },
    {
        "content": "<p>Oh, good catch. Hrm. Yeah.</p>",
        "id": 241095041,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622595970
    },
    {
        "content": "<p>Ok so thinking about this if-let-chaining problem more, I don't think it is actually an issue, because all existing possibilities of this are errors aside from a single case which would be added in this RFC and therefore could be avoided.</p>\n<p>Consider the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">maybe</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">has_thing</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">maybe</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">has_thing</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This will always be an error regardless, because <code>&amp;&amp;</code> only operates on booleans.</p>\n<p>But, you say, you can pattern-match booleans! This is true:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But this is  certainly not useful: You've re-invented a worse <code>if</code>.<br>\nIt may also be an error anyways because there is no actual assignment happening.</p>\n<p>Also, this doesn't work today either, in ways which probably leave the door open for us:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0005]: refutable pattern in local binding: `false` not covered\n --&gt; src/main.rs:5:9\n  |\n5 |     let true = a &amp;&amp; b;\n  |         ^^^^ pattern `false` not covered\n  |\n  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant\n</code></pre></div>",
        "id": 241095416,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622596348
    },
    {
        "content": "<p>Unless I'm missing something compiler-level, it seems fair to just reject <code>let true = a &amp;&amp; b else { }</code> due to ambiguity, and  leave the door open for if-let-chaining style <code>&amp;&amp;</code> chaining.</p>",
        "id": 241095527,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622596449
    },
    {
        "content": "<p>Updated RFC draft (including if-let-else, a practical refactor, etc): <a href=\"https://github.com/Fishrock123/rfcs/blob/let-else/text/0000-let-else.md\">https://github.com/Fishrock123/rfcs/blob/let-else/text/0000-let-else.md</a></p>\n<p>I'm hoping to be able to PR this tomorrow (maybe)?</p>",
        "id": 241297349,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622657516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I think it would be helpful if the reference-level explanation gave an <em>exact</em> desugaring, rather than just alluding to if let or match.</p>",
        "id": 241311839,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622664076
    },
    {
        "content": "<p>(You can still use pseudo-syntax to handle <code>(all, the, bindings)</code> of a pattern.)</p>",
        "id": 241311976,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622664124
    },
    {
        "content": "<p>But it'd be nice to have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code><span class=\"sb\">`let pattern = expr else { diverging_expr }`</span> desugars to <span class=\"sb\">`let (each, binding) = match expr { pattern =&gt; (each, binding), _ =&gt; { diverging_expr } };`</span>\n</code></pre></div>",
        "id": 241312146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622664223
    },
    {
        "content": "<p>Ok, added that (a bit more formatted).</p>",
        "id": 241316566,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622666373
    },
    {
        "content": "<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// The RFC proposes boolean matches like this be either:</span>\n<span class=\"c1\">// - Made into a compile error, or</span>\n<span class=\"c1\">// - Made to be parsed like if-let-chains: `(true = a) &amp;&amp; b`</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>AFAIK, let chains like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>parse as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and <em>not</em> as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241318637,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622667315
    },
    {
        "content": "<p>As demonstrated by</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// --&gt; `let` expressions in this position are experimental</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// --&gt; `let` expressions in this position are experimental</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// -&gt; error: expected one of `)`, `,`, `...`, `..=`, `..`, or `|`, found `=`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 241319068,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1622667551
    },
    {
        "content": "<p>Oh, second time I've made that mistake huh.</p>\n<p>Hmm, what would be the equivalent? Is <code>(let true = a) &amp;&amp; b</code> a problem?</p>",
        "id": 241320147,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622668122
    },
    {
        "content": "<p>You might not be able to write it manually, but does that matter to internals?</p>",
        "id": 241320228,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622668165
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">subpage_layer_info</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">layer_properties</span><span class=\"p\">.</span><span class=\"n\">subpage_layer_info</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">subpage_layer_info</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">subpage_layer_info</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is equivalent to this much simpler let-else statement:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">subpage_layer_info</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">layer_properties</span><span class=\"p\">.</span><span class=\"n\">subpage_layer_info</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>There is an extra dereference in the first code block, so I think this isn't true. I don't know what the types are but it seems like the field should be copy, so that you could write <code>let Some(subpage_layer_info) = layer_properties.subpage_layer_info ...</code> instead</p>",
        "id": 241346955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622693891
    },
    {
        "content": "<p>Rather than saying \"this block must diverge\", it might be more understandable to say that the type of the expression in the block is <code>!</code>, so it must early exit using <code>return</code>, <code>continue</code> or similar (unless you had a value of type <code>!</code> lying around, I suppose, in which case what are you doing with your life)</p>",
        "id": 241347164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622694272
    },
    {
        "content": "<p>It could panic, for instance.</p>",
        "id": 241349581,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622697656
    },
    {
        "content": "<p>Or exit the process, or similar.</p>",
        "id": 241349590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622697675
    },
    {
        "content": "<p>Could also say that its result is uninhabited, to avoid the <code>!</code> mention.</p>\n<p>So you get something like <code>let Some(x) = opt else BLOCK;</code> → </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">BLOCK</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to leverage existing \"things that don't need arms in <code>match</code>\" understanding.</p>",
        "id": 241359553,
        "sender_full_name": "scottmcm",
        "timestamp": 1622707576
    },
    {
        "content": "<p>We don't need to hide from <code>!</code>, right? It already exists on stable in functions <code>fn foo() -&gt; ! { &lt;what type is expected here?&gt; }</code></p>",
        "id": 241360146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622708040
    },
    {
        "content": "<p>In fact, you can even get types with <code>!</code> in other positions on stable, although they are unnameable:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">))</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"nb\">Err</span><span class=\"p\">(()));</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">r</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// r: Result&lt;!, ()&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Err</span><span class=\"p\">(())</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I think it's not possible to avoid the conclusion that <code>!</code> is a type</p>",
        "id": 241360396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622708181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241346955\">said</a>:</p>\n<blockquote>\n<p>There is an extra dereference in the first code block, so I think this isn't true. I don't know what the types are but it seems like the field should be copy, so that you could write <code>let Some(subpage_layer_info) = layer_properties.subpage_layer_info ...</code> instead</p>\n</blockquote>\n<p>That example was taken from the old RFC; I've removed it in favor of the practical refactor example which shows the same thing and uses code which I am actually familiar with.</p>\n<p>I already mentioned <code>!</code> in the reference explanation but I'll also add it to the summary.</p>",
        "id": 241424209,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622741237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241359553\">said</a>:</p>\n<blockquote>\n<p>Could also say that its result is uninhabited, to avoid the <code>!</code> mention.</p>\n<p>So you get something like <code>let Some(x) = opt else BLOCK;</code> → </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">BLOCK</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to leverage existing \"things that don't need arms in <code>match</code>\" understanding.</p>\n</blockquote>\n<p>I don't understand this, could you clarify what you're trying to get at here?</p>",
        "id": 241427912,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622742654
    },
    {
        "content": "<p>I guess it could be phrased as \"does it need to return <code>!</code>, or can it return something uninhabited-but-not-<code>!</code> like <code>std::convert::Infallible</code>?\"</p>",
        "id": 241432416,
        "sender_full_name": "scottmcm",
        "timestamp": 1622744766
    },
    {
        "content": "<p>For example, &lt;<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ae5b6a7a44e83c2ad8350af8b578e04a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ae5b6a7a44e83c2ad8350af8b578e04a</a>&gt;</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">convert</span>::<span class=\"n\">TryFrom</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">demo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">u64</span>::<span class=\"n\">try_from</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">).</span><span class=\"n\">unwrap_err</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>fails with </p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0308]: mismatched types\n --&gt; src/lib.rs:3:5\n  |\n2 | fn demo(x: u32) -&gt; ! {\n  |                    - expected `!` because of return type\n3 |     u64::try_from(x).unwrap_err()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `!`, found enum `Infallible`\n  |\n  = note: expected type `!`\n             found enum `Infallible`\n</code></pre></div>",
        "id": 241432658,
        "sender_full_name": "scottmcm",
        "timestamp": 1622744897
    },
    {
        "content": "<p>so <code>let _: ! = { BLOCK };</code> and <code>match ({BLOCK}) {}</code> in the desugaring would have different behaviour.</p>",
        "id": 241432742,
        "sender_full_name": "scottmcm",
        "timestamp": 1622744951
    },
    {
        "content": "<p>I don't think there is any precedent for returning something uninhabited-but-not-<code>!</code> and having it coerce to <code>!</code> or any other uninhabited type. Only <code>!</code> is magic like that</p>",
        "id": 241432750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622744954
    },
    {
        "content": "<p>Isn't <a class=\"stream\" data-stream-id=\"259160\" href=\"/#narrow/stream/259160-t-lang.2Fproject-never-type\">#t-lang/project-never-type</a>  working on fixing that, or am I mistaken on how <code>!</code> is intended to interact with Infallible / empty enums?</p>",
        "id": 241432778,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622744977
    },
    {
        "content": "<p><code>!</code> is special, because it has the coercion-to-anything.  I don't know that a general <code>enum Never {}</code> is expected to have that magic coercion.</p>",
        "id": 241432902,
        "sender_full_name": "scottmcm",
        "timestamp": 1622745016
    },
    {
        "content": "<p>is \"uninhabited\" even a language concept? There is \"<code>match x {}</code> typechecks\" as an approximation but coercion doesn't come into it</p>",
        "id": 241432935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745039
    },
    {
        "content": "<p>What would having the return type be <code>enum Uninhabited {}</code> get us over <code>!</code>?</p>",
        "id": 241433309,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622745205
    },
    {
        "content": "<p>Also <code>match ({BLOCK}) {}</code> would cause type inference problems</p>",
        "id": 241433344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745226
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// typechecks</span>\n<span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// type annotations needed</span>\n</code></pre></div>",
        "id": 241433746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241433309\">said</a>:</p>\n<blockquote>\n<p>What would having the return type be <code>enum Uninhabited {}</code> get us over <code>!</code>?</p>\n</blockquote>\n<p>Well, for example, it might let things like <code>Result&lt;!, !&gt;</code> work, which show up as residuals in the <code>?</code> stuff.</p>",
        "id": 241434206,
        "sender_full_name": "scottmcm",
        "timestamp": 1622745607
    },
    {
        "content": "<p>Does <code>match x {}</code> even work for that?</p>",
        "id": 241434250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745634
    },
    {
        "content": "<p>Do enums with all options being <code>!</code> not coerce to <code>!</code>?</p>",
        "id": 241434324,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622745681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241433746\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// typechecks</span>\n<span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// type annotations needed</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Part of me says that you <em>should</em> have to specify a type on <code>foo</code> there, since presumably that's the point of it being generic instead of just being <code>-&gt;</code> itself.</p>",
        "id": 241434326,
        "sender_full_name": "scottmcm",
        "timestamp": 1622745682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241434250\">said</a>:</p>\n<blockquote>\n<p>Does <code>match x {}</code> even work for that?</p>\n</blockquote>\n<p>Only with <a href=\"https://doc.rust-lang.org/nightly/unstable-book/language-features/exhaustive-patterns.html\">https://doc.rust-lang.org/nightly/unstable-book/language-features/exhaustive-patterns.html</a></p>",
        "id": 241434371,
        "sender_full_name": "scottmcm",
        "timestamp": 1622745705
    },
    {
        "content": "<p>Also, <code>Result&lt;!, !&gt;</code> doesn't coerce to <code>enum Uninhabited {}</code>... I... think?</p>",
        "id": 241434441,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622745727
    },
    {
        "content": "<p>I don't think either result in my example is incorrect, I just think that in the <code>let .. else { &lt;block&gt; }</code> it should act like the body of <code>bar</code></p>",
        "id": 241434498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745758
    },
    {
        "content": "<p>(Also I'm having trouble figuring out how <code>Result&lt;!, &gt;</code> would even exist from <code>?</code>, links to examples would probably helpful if we want to go down this rabbit hole</p>",
        "id": 241434695,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622745851
    },
    {
        "content": "<p>Only <code>!</code> has coercions to any type, and I don't think project-never-type plans to change that</p>",
        "id": 241434709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745857
    },
    {
        "content": "<p>so if you wanted to use <code>MyVoid</code> in a let-else you would need to add <code>match ... {}</code></p>",
        "id": 241434783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745904
    },
    {
        "content": "<p>at least, with my suggestion with the <code>let x: ! = BLOCK</code> desugaring</p>",
        "id": 241434859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622745941
    },
    {
        "content": "<p>If <code>Result&lt;!, !&gt;</code> implemented <code>Into&lt;!&gt;</code>, you could just write <code>else { x.into() }</code> which doesn't seem so bad</p>",
        "id": 241435079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622746043
    },
    {
        "content": "<p>which also seems like a reasonably generic way for a custom type to indicate that it is uninhabited</p>",
        "id": 241435308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622746150
    },
    {
        "content": "<p>We could maybe desugar into anything which returns <code>Into&lt;!&gt;</code>, but... idk I'm not quite seeing the value?</p>",
        "id": 241435419,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622746201
    },
    {
        "content": "<p>I think that genericity in the result type will just lead to type inference pains, because the type of a diverging expression is often unconstrained</p>",
        "id": 241435642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622746288
    },
    {
        "content": "<p>and if you have a custom uninhabited type, you will generally be either an <code>.into()</code> or <code>match _ {}</code> away from regaining that generality anyway</p>",
        "id": 241435922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622746395
    },
    {
        "content": "<p>I think project-never-type is working on changing type inference so that unconstrained types default to <code>!</code> where possible, so maybe my <code>baz</code> example will typecheck then, but it seems unnecessary to rely on that</p>",
        "id": 241436165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622746508
    },
    {
        "content": "<p>It's not at all clear to me why the diverging expression needs to have any type other than <code>!</code>.</p>",
        "id": 241437754,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622747214
    },
    {
        "content": "<p>Ok folks, RFC PR is up: <a href=\"https://github.com/rust-lang/rfcs/pull/3137\">https://github.com/rust-lang/rfcs/pull/3137</a></p>",
        "id": 241439782,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622748208
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I posted a few nits and additional verbiage, almost all of it as GitHub suggestions for simplicity.</p>",
        "id": 241442265,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622749339
    },
    {
        "content": "<p>Apart from those, I think this is ready for review.</p>",
        "id": 241442275,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622749346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/241437754\">said</a>:</p>\n<blockquote>\n<p>It's not at all clear to me why the diverging expression needs to have any type other than <code>!</code>.</p>\n</blockquote>\n<p>I agree: <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>, on top of not everybody being aquainted with pattern-matching against empty enums (or <code>!</code>; but we still have the issue of it not covering all uninhabited types), we also need to take into account consistency with how other parts of the language treat <code>!</code> <em>vs.</em> other uninhabited types. Indeed, even though the <code>!</code> type is still unstable, we've had diverging functions for a while, <strong>as well as borrowck / dropck featuring special behavior for diverging blocks</strong>. Consider, for instance:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">enum</span> <span class=\"nc\">Void</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"cm\">/* with `type Void = !;` it passes */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Void</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Error, `it` was moved into the `if` body.</span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c9929b02b0a32febd10b78ec12ab1747\">Playground</a></li>\n</ul>\n<p>We can see that Rust does not really infer that having an instance of an uninhabited type such as empty enums means that that code path is unreachable. Granted, it could be made smarter <em>there</em>, and thus, also at the RFC level, but I think that so doing should be general. In other words, I think that the above snippet failing to compile but the following one passing would be <em>inconsistent</em> and thus not as useful:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span>::<span class=\"o\">&lt;</span><span class=\"n\">Void</span><span class=\"o\">&gt;</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I thus think that if somebody were to produce something like the <code>Infallible</code> in your example, then they'd be the ones expected to <code>match … {}</code>-wrap their value; it should be rare enough not to be a problem.</p>",
        "id": 241517316,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1622803112
    },
    {
        "content": "<p>I don’t understand what this comment is saying regarding “divergent <em>patterns</em>”, my understanding is that it would allow for a refutable pattern, is there a potential difference there internally with let-else? Anyone understand these semantics well enough to clarity? <a href=\"https://github.com/rust-lang/rfcs/pull/3137#issuecomment-854973177\">https://github.com/rust-lang/rfcs/pull/3137#issuecomment-854973177</a></p>",
        "id": 241590435,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1622839354
    },
    {
        "content": "<p>Yeah, I agree with your answer there: this is just about allowing refutable patterns in <code>let</code> bindings, provided they are followed by a diverging <em>block</em> (there are no \"diverging patterns\" anywhere). And we do have the notion of divergence in the language already, with <code>-&gt; !</code> returning functions, as well as my previous example regarding dropck or borrowck.</p>\n<p>The whole PR ought to talk about it being <em>sugar</em>, and thus, with very explicit semantics:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">pat</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">expr</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">block</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>being sugar for</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">pat</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">expr</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"n\">pat</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">pat</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* this branch must be reachable; \"#[deny(unreachable_patterns)]\"-like */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">block</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"cm\">/* ensuring the block must diverge */</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(modulo the <code>&lt;pat&gt;</code> ordeal being more subtle <em>w.r.t.</em> destructuring and rebinding stuff).</li>\n</ul>",
        "id": 241646644,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1622913590
    },
    {
        "content": "<p>And if you need to show that the pattern is pervasive, feel free to look at <a href=\"https://grep.app/search?q=if%20let%20.%2A%20%7B%20%5Ba-zA-Z_%5D%5Cw%2A%20%7D%20else%20%7B%20return&amp;regexp=true&amp;filter[lang][0]=Rust\">https://grep.app/search?q=if%20let%20.%2A%20%7B%20%5Ba-zA-Z_%5D%5Cw%2A%20%7D%20else%20%7B%20return&amp;regexp=true&amp;filter[lang][0]=Rust</a></p>\n<ul>\n<li>With common panics added: <a href=\"https://grep.app/search?q=if%20let%20.%2B%20%5C%7B%20%5Cw%2B%20%5C%7D%20else%20%7B%20%28%3F%3Areturn%7Cpanic%5C%21%7Cunreachable%5C%21%29&amp;regexp=true&amp;case=true&amp;filter[lang][0]=Rust\">https://grep.app/search?q=if%20let%20.%2B%20%5C%7B%20%5Cw%2B%20%5C%7D%20else%20%7B%20%28%3F%3Areturn%7Cpanic%5C%21%7Cunreachable%5C%21%29&amp;regexp=true&amp;case=true&amp;filter[lang][0]=Rust</a></li>\n</ul>",
        "id": 241647076,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1622914147
    },
    {
        "content": "<p>(which is a subset of the usages of this pattern, more precisely, a subset of <code>let … = if let … { var } else { return</code> happening <em>on the same line</em> (else <a href=\"http://grep.app\">grep.app</a> misses it))</p>",
        "id": 241647145,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1622914246
    },
    {
        "content": "<p>I've nominated the RFC for lang team discussion.</p>",
        "id": 241927945,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623162472
    },
    {
        "content": "<p>Is this diverging block type-check de-sugaring with <code>!</code> also invalid within the rust compiler itself?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">nope</span>: <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* diverging expr */</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">nope</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(I am unsure if the rust compiler bypasses public stable on some lang feature or not)</p>",
        "id": 242097810,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623258002
    },
    {
        "content": "<p>it can use arbitrary unstable features internally</p>",
        "id": 242124966,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1623270427
    },
    {
        "content": "<p>I assume that let..else won't actually be implemented as a macro-style desugaring though, but would instead stick around until HIR for diagnostic reasons. The desugaring is just a \"just-so\" story for documentation purposes. So the only worry about using unstable notation is if it is not familiar to users, and in this case I think using <code>let nope: ! = ...</code> is clearer than the typechecker hack I posted on the issue</p>",
        "id": 242131094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623273234
    },
    {
        "content": "<p>Hard to say.  It could well disappear in AST-&gt;HIR lowering, and just use <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/enum.DesugaringKind.html\"><code>DesugaringKind</code></a> to report diagnostics differently (like <code>?</code> and <code>try{}</code> and <code>for{}</code> and such do).</p>\n<p>If it can be done as a desugar it'd definitely be preferable, to me, since it avoids needing to specifically add type checking rules and name resolution rules and such -- much nicer to have it just fall out of existing rules from the desugar.</p>",
        "id": 242134900,
        "sender_full_name": "scottmcm",
        "timestamp": 1623274999
    },
    {
        "content": "<p>Given how all match-likes seem to get desugared to <code>match</code> in AST-&gt;HIR, it makes sense for let-else to get desugared there as well</p>",
        "id": 242135340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623275226
    },
    {
        "content": "<p>it's not clear whether the unusual scoping here presents any problems. I see that <code>hir::Local</code> still has a <code>Pat</code>, so I guess it is still doing pattern matching. Adding an optional else branch there seems doable</p>",
        "id": 242135769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623275460
    },
    {
        "content": "<p>As much as I'd also like to implement this feature if some version of this RFC is accepted, this is all a little beyond me. (I understand the general AST-&gt;HIR-&gt;MIR concept but little in concrete detail)</p>",
        "id": 242143713,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623281448
    },
    {
        "content": "<p>I'm curious where the MCP process sits with respect to the RFC. Does the RFC have to be accepted before the unstable feature is added?</p>",
        "id": 242143971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623281659
    },
    {
        "content": "<p>I think an MCP is how something can be added to the compiler as unstable without having an RFC for it.  Basically, if you're not trying to put it on stabilization path, you can convince compiler that it won't be to annoying to have the code in the compiler.</p>\n<p>Whereas you don't need an MCP if there was an RFC, but of course you do still need to pass code review and such.</p>",
        "id": 242145332,
        "sender_full_name": "scottmcm",
        "timestamp": 1623282904
    },
    {
        "content": "<p>So if the RFC was accepted and then implemented, does that mean there would never be a feature flag for it? Just missing in one version and then stable in the next?</p>",
        "id": 242145595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623283161
    },
    {
        "content": "<p>Nope, it still goes in unstable, then needs another FCP for the stabilization (even with an RFC).</p>",
        "id": 242146131,
        "sender_full_name": "scottmcm",
        "timestamp": 1623283588
    },
    {
        "content": "<p>Everyone does their best in RFCs, but it's happened before and will happen again that once something is implemented, it turns out not to be as good as hoped, and gets changed again or removed.</p>",
        "id": 242146284,
        "sender_full_name": "scottmcm",
        "timestamp": 1623283751
    },
    {
        "content": "<p>Does <code>return;</code> (with a semicolon) return <code>!</code>, or does it have to be without the semicolon?</p>",
        "id": 242642441,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623696425
    },
    {
        "content": "<p><code>return</code> is an expression with type <code>!</code>, the semicolon doesn't have an effect because the code never \"gets\" to it. it's like the difference between <code>panic!()</code> and <code>panic!();</code>, or the difference between <code>return</code> and <code>return break break return break return</code>. Though in some contexts the semicolon may be syntactically required, e.g. <code>let x: ! = return;</code> requires a semicolon because of the <code>let</code>.</p>",
        "id": 242643690,
        "sender_full_name": "bstrie",
        "timestamp": 1623696981
    },
    {
        "content": "<p>Ok good, I was worried that somehow that would end up being <code>()</code> instead.</p>",
        "id": 242646242,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623698263
    },
    {
        "content": "<p>I do wonder if we shouldn't just recommend that let-else supersede if-let-chains, since that topic is apparently so complex that no one has worked on it in 3 years and seems to conflict with the approach here.</p>",
        "id": 242647160,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623698687
    },
    {
        "content": "<p>If wonder if, were <code>&amp;&amp;</code> to already be implemented, would we prefer the much more complex <code>||</code> idea? I dunno. Unknowable, I suppose.</p>",
        "id": 242647218,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623698721
    },
    {
        "content": "<p>So, I genuinely think that if-let chains are still quite valuable, and I want them regularly.</p>",
        "id": 242647450,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623698830
    },
    {
        "content": "<p>I don't think they're as high a priority as let-else.</p>",
        "id": 242647472,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623698839
    },
    {
        "content": "<p>But I do often want <code>if let Pat(x) = expr() &amp;&amp; cond(x) &amp;&amp; let OtherPat(y) = anotherfunc(x)</code>.</p>",
        "id": 242647605,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623698892
    },
    {
        "content": "<p>I'm pretty sure <code>return;</code> evaluates to <code>()</code> no? as in the the semicolon is significant for the return type of a block here</p>",
        "id": 242647907,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1623699055
    },
    {
        "content": "<p>I do wonder if we should think more about how they mix.  I tried find some nice let-else examples in clippy, but they seemed to be mostly wanting the chain.</p>",
        "id": 242647911,
        "sender_full_name": "scottmcm",
        "timestamp": 1623699057
    },
    {
        "content": "<p>But they also often had <code>else { continue }</code> or similar, so being able to do both might be nice.</p>",
        "id": 242647977,
        "sender_full_name": "scottmcm",
        "timestamp": 1623699086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300586\">Lukas Wirth</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/242647907\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure <code>return;</code> evaluates to <code>()</code> no? as in the the semicolon is significant for the return type of a block here</p>\n</blockquote>\n<p><code>let x: ! = { return; };</code> works, which it wouldn't if <code>return;</code> was <code>()</code> rather than <code>!</code>, although of course I'm using the unstable never_type feature and it's possible that the type inference might change before stabilization for the sake of backcompat</p>",
        "id": 242648219,
        "sender_full_name": "bstrie",
        "timestamp": 1623699233
    },
    {
        "content": "<p>Oh, I tried this in a function like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which doesn't type check.  Interesting that this differs in that case</p>",
        "id": 242648572,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1623699382
    },
    {
        "content": "<p>oh wait I'm dumb of course this doesn't work here <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Ye now this make sense</p>",
        "id": 242648616,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1623699410
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Would you ever want:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Enum</span>::<span class=\"n\">Var1</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">anyhow</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Bad x\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Complex.</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As elaborated on in <a href=\"https://github.com/rust-lang/rfcs/pull/3137#issuecomment-860883577\">https://github.com/rust-lang/rfcs/pull/3137#issuecomment-860883577</a></p>",
        "id": 242650782,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623700424
    },
    {
        "content": "<p>I don't think I'd ever want <code>if let Pat(x) = expr() || </code> in general, for the same reason that I don't want to use <code>if !let Pat(x)</code> instead of <code>let</code>-<code>else</code>.</p>",
        "id": 242652636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623701299
    },
    {
        "content": "<p>It's absolutely possible for the compiler to figure out the rules for which bindings apply where.</p>",
        "id": 242652659,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623701310
    },
    {
        "content": "<p>It's not, on the other hand, straightforward for the <em>human</em> to figure out those rules in arbitrary code.</p>",
        "id": 242652687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623701324
    },
    {
        "content": "<p>I like <code>if let ... &amp;&amp; cond &amp;&amp; let ... </code> because the bindings all build on each other one after another, and each one exists after the corresponding part of the expression.</p>",
        "id": 242652741,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623701361
    },
    {
        "content": "<p>We talked about <code>||</code> back when we talked about <code>if</code>-<code>let</code> chains, and I had the same thought back then: we could, but we shouldn't.</p>",
        "id": 242652792,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623701393
    },
    {
        "content": "<p>I do think that same thing was much more difficult to write without <code>||</code>, and wasn't much clearer. I have no evidence that the kind of code where this is applicable is at all prevalent or good practice though.</p>",
        "id": 242666524,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623709546
    },
    {
        "content": "<p>Also just noting that if-let-chains also has problems if <code>&amp;&amp;</code> is ever overload-able.</p>",
        "id": 242667834,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623710508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/242667834\">said</a>:</p>\n<blockquote>\n<p>Also just noting that if-let-chains also has problems if <code>&amp;&amp;</code> is ever overload-able.</p>\n</blockquote>\n<p>I think that depends on how it's overloadable.  If <code>a &amp;&amp; b</code> desugars to something like <code>match Something::something(a)</code>, then the binding lifetimes could still be clear.</p>",
        "id": 242670122,
        "sender_full_name": "scottmcm",
        "timestamp": 1623712144
    },
    {
        "content": "<p>Like <code>a &amp;&amp; b</code> is <code>if let false = a { false } else { b }</code>, so if it was allowed on Options as <code>if let None = a { None } else { b }</code> that feels like it'd still work fine for bindings.</p>",
        "id": 242670264,
        "sender_full_name": "scottmcm",
        "timestamp": 1623712250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> Could you please add <code>let</code>-<code>else</code>-<code>else</code> to the \"future possibilities\" section, with the explanation that it could be added as a future extension?</p>",
        "id": 242822531,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623809492
    },
    {
        "content": "<p>I’ve been meaning to, will try to get to it tomorrow or Thursday.</p>",
        "id": 242823370,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623810470
    },
    {
        "content": "<p>No rush.</p>",
        "id": 242823445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623810525
    },
    {
        "content": "<p>Just asking because once that's present, I'm inclined to try proposing FCP.</p>",
        "id": 242823448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623810535
    },
    {
        "content": "<p>(That and the comment I made about prohibiting <code>if let pat = expr else { ... diverge ... } { ... }</code>.)</p>",
        "id": 242823758,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623810895
    },
    {
        "content": "<p>That would need to be explicitly included because if-let is not a let statement, but I can note it anyways.</p>",
        "id": 242824435,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623811717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/242823758\">said</a>:</p>\n<blockquote>\n<p>(That and the comment I made about prohibiting <code>if let pat = expr else { ... diverge ... } { ... }</code>.)</p>\n</blockquote>\n<p>How does that parse? It looks like an <code>if let</code> but it's missing a body</p>",
        "id": 242825360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623812784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Which of these were you suggesting?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243097661,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623971720
    },
    {
        "content": "<p>I really don't like this. I would rather have <code>||</code> in pattern matching - even if <code>||</code>-patterns could be refutable, such as still needing let-else:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243097940,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623971940
    },
    {
        "content": "<p>I presume you mean the former, this reads... eeeeh, ok I guess:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243098247,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623972145
    },
    {
        "content": "<p>Alternative is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 243098294,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623972190
    },
    {
        "content": "<p>Ok, RFC has gotten another round of updates.</p>",
        "id": 243100800,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1623974399
    },
    {
        "content": "<p>So, I definitely don't want to do either; it's just an issue of recording an alternative.</p>",
        "id": 243265430,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624131405
    },
    {
        "content": "<p>If we were going to do either, I would prefer the braces. But I don't think we should do either of those. :)</p>",
        "id": 243265512,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624131533
    },
    {
        "content": "<p>Can I still make minor updates / corrections under the proposed fcp / disposition-merge?</p>",
        "id": 243597252,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1624410572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> Absolutely. Feel free to make minor updates, corrections, or for that matter incorporations of other \"alternative approaches\".</p>",
        "id": 243599240,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624412910
    },
    {
        "content": "<p>If you make any non-minor changes or corrections that you think would affect our review, please do call our attention to them.</p>",
        "id": 243599250,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624412925
    },
    {
        "content": "<p>Me again. I think the RFC needs to address type annotations. They seem to be disallowed but I don't know if that's intentional?</p>",
        "id": 243695986,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1624474110
    },
    {
        "content": "<p>I guess the rule should be the same as for let: <code>let PAT (: TY)? = EXPR else BLOCK;</code></p>",
        "id": 243700683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624476526
    },
    {
        "content": "<p>although really this should be handled by type ascriptions in patterns so you get this automatically</p>",
        "id": 243700785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624476596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360405\">Cameron Steffen</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/243695986\">said</a>:</p>\n<blockquote>\n<p>Me again. I think the RFC needs to address type annotations. They seem to be disallowed but I don't know if that's intentional?</p>\n</blockquote>\n<p>I'd guess that's an accident of not having an exact grammar for existing let statements.</p>",
        "id": 243708230,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624480187
    },
    {
        "content": "<p>let-else should absolutely allow type annotations.</p>",
        "id": 243708313,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624480214
    },
    {
        "content": "<p>Interestingly, <code>if let</code> <em>doesn't</em> allow type annotations there</p>",
        "id": 243711672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624481703
    },
    {
        "content": "<p>Type annotations are a bit weird here, since it's <code>let Some(x): Option&lt;i32&gt; =</code> not <code>let x: Option&lt;i32&gt; =</code>.</p>",
        "id": 243714082,
        "sender_full_name": "scottmcm",
        "timestamp": 1624483020
    },
    {
        "content": "<p>I might be tempted to leave ascription off of this for now, and wait for internal ascription, so it could be <code>let Some(x: i32) =</code>, which is way nicer.</p>",
        "id": 243714314,
        "sender_full_name": "scottmcm",
        "timestamp": 1624483082
    },
    {
        "content": "<p>I thought of that, but maybe that would be unnecessary crippling let-else.</p>",
        "id": 243716029,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1624484011
    },
    {
        "content": "<p>Can I volunteer to implement this?</p>",
        "id": 243807500,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1624550347
    },
    {
        "content": "<p>By all means, if you've got the bandwidth.</p>",
        "id": 243807576,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624550380
    },
    {
        "content": "<p>I would love to see this in nightly soon.</p>",
        "id": 243807608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624550393
    },
    {
        "content": "<p>I might just have an MVP already :)</p>",
        "id": 243807782,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1624550452
    },
    {
        "content": "<p>I was hoping to implement it as well as having written the RFC, not sure if I mentioned that. (I’d need help for it for sure though)</p>",
        "id": 243929529,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1624634152
    },
    {
        "content": "<p>I figured it would probably be simple enough for my first substantial contribution to rustc, since I at least  understand the problem space now <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 243930193,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1624634461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I think you get first dibs since you put in the work for the RFC. Here is what I have so far if you want to use it. <a href=\"https://github.com/camsteffen/rust/tree/let-else\">https://github.com/camsteffen/rust/tree/let-else</a></p>",
        "id": 244033112,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1624739701
    },
    {
        "content": "<p>i plan to spend some time tomorrow morning responding to RFC comments and making RFC updates. i’ve been off this week so that was why there was extra delays</p>",
        "id": 244089571,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1624835109
    },
    {
        "content": "<blockquote>\n<p>If the pattern does not match, the expression is not consumed, and so any existing variables from the surrounding scope are<br>\naccessible as they would normally be.</p>\n</blockquote>\n<p>I'm not sure if someone missed this, but can someone confirm this would indeed be possible?</p>",
        "id": 244215115,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1624921142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360405\">@Cameron Steffen</span> I'll be honest: I don't really understand very much at all about that code.</p>\n<p>I may not have time right now anyways, so as much as I'd like to, if you have time I say go for an MVP</p>",
        "id": 244217368,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1624923013
    },
    {
        "content": "<p>well I think we're waiting for it to get merged for now anyways</p>",
        "id": 244219073,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1624924758
    },
    {
        "content": "<p>A somewhat non-trivial update may need to be made: disallow patterns which produce no bindings: <a href=\"https://github.com/rust-lang/rfcs/pull/3137#issuecomment-874228689\">https://github.com/rust-lang/rfcs/pull/3137#issuecomment-874228689</a></p>",
        "id": 244955130,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625502910
    },
    {
        "content": "<p>I added a comment in that regard; while I think it's unusual, I don't think we should prohibit it.</p>",
        "id": 244955612,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625503307
    },
    {
        "content": "<p>Does anyone have links about the implications / requirements for introducing a keyword ala <code>guard</code>? I don't really want to make the case for a new keyword but I'd like to at least know what it would take.</p>",
        "id": 244965406,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625511422
    },
    {
        "content": "<p>Well, it would be part of an RFC introducing a new language feature and discussion settling on a new keyword being the best  way to do that. a keyword is more of a byproduct. In the past keywords were reserved preemptively because they might be useful, but iirc that was changed with the editions system where new editions would serve as the point where new keywords could be introduced if needed.</p>",
        "id": 244966910,
        "sender_full_name": "The 8472",
        "timestamp": 1625512759
    },
    {
        "content": "<p>Not an entirely serious suggestion, but just reading the RFC and the discussion about the syntax, what about the following? Using <code>match</code> here might make it more clear that pattern matching is going on.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">pat</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// Transforms into</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pat</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">pat</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pat</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 244968028,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1625513790
    },
    {
        "content": "<p>one thing that I hadn't considered yet is that pattern binding is being extended to allow <code>(a, b) = foo;</code>, <em>without</em> a <code>let</code> being involved, and I wonder how that interacts with all this</p>",
        "id": 244968598,
        "sender_full_name": "bstrie",
        "timestamp": 1625514348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> Link(s)?</p>",
        "id": 244968682,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625514403
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2909-destructuring-assignment.md\">https://github.com/rust-lang/rfcs/blob/master/text/2909-destructuring-assignment.md</a></p>",
        "id": 244968783,
        "sender_full_name": "bstrie",
        "timestamp": 1625514506
    },
    {
        "content": "<p>worth noting that this is intended to only allow a hand-picked subset of the pattern syntax on the LHS</p>",
        "id": 244968820,
        "sender_full_name": "bstrie",
        "timestamp": 1625514562
    },
    {
        "content": "<p>Note that it's technically a subset of expression syntax on the LHS; it doesn't use the pattern grammar.</p>",
        "id": 244970230,
        "sender_full_name": "scottmcm",
        "timestamp": 1625515771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> 's suggestion wouldn't be extremely disruptive, but it's worth nothing that <code>let</code> already always indicates a pattern matching context, and maybe it's not necessary to further emphasize that pattern matching is going on. Rather than emphasizing that pattern matching is happening, I think that what needs emphasizing is that a refutable pattern is allowed, which is what the proposed <code>else</code> is for, and while I'm not completely without misgivings WRT <code>else</code> I also don't exactly dislike it.</p>",
        "id": 244970613,
        "sender_full_name": "bstrie",
        "timestamp": 1625516130
    },
    {
        "content": "<p>I am convinced now that the equivalent of if-let-chains should be ensured to be compatible with this feature, and though I see some language in the RFC indicating that it is probably compatible, I'd like someone more sure to weigh in</p>",
        "id": 244970729,
        "sender_full_name": "bstrie",
        "timestamp": 1625516222
    },
    {
        "content": "<p>Sure, though <code>let</code>’s patterns is irrefutable where as <code>match</code> implies some pattern that has two or more variants</p>",
        "id": 244970773,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1625516268
    },
    {
        "content": "<p>well it's refutable unless it's an <code>if let</code>. maybe we should have indicated that that form allows refutable patterns by having the syntax <code>if let? pat</code>, and then we could have done <code>let? pat</code> here</p>",
        "id": 244970884,
        "sender_full_name": "bstrie",
        "timestamp": 1625516375
    },
    {
        "content": "<p>but then again that wouldn't help with the destructuring assignment RFC, where there's no <code>let</code> in sight at all</p>",
        "id": 244971010,
        "sender_full_name": "bstrie",
        "timestamp": 1625516450
    },
    {
        "content": "<p>if people are worried that it's too easy to overlook the <code>else</code> then there's still the option of <code>else return</code>, which would syntactically disambiguate this from <code>if</code></p>",
        "id": 244973248,
        "sender_full_name": "bstrie",
        "timestamp": 1625518267
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> having only given it brief thought, I don't think there should be any reason that this feature wouldn't also be applicable to destructuring assignment with the same syntax, i.e. <code>(a, b) = foo else {</code> (although with the same restrictions about what <code>foo</code> can be). I don't think that also needs to be a part of this proposal, but it is worth mentioning in the future work section.</p>",
        "id": 244974495,
        "sender_full_name": "bstrie",
        "timestamp": 1625519368
    },
    {
        "content": "<p>This also re-opens questions about if-let-chains, because the previous premise was that it didn't make sense without a starting <code>let</code>, however then one could imagine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 244974648,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625519512
    },
    {
        "content": "<p>(I personally am a not a big fan of that decoupled destructuring, but, oh well i guess.)</p>",
        "id": 244974717,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625519563
    },
    {
        "content": "<p>This all makes <code>||</code> pattern-expressions (whatever you want to call that, the counterpart to if-let-chain &amp;&amp;) seem like more of a potential idea in the back of my brain ...</p>",
        "id": 244974815,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625519655
    },
    {
        "content": "<p>hm, that's a good point, but also that problem probably also exists for if-let chains as well, and I don't know if anyone's considered that yet. we may need to leave it as an unresolved question, to be resolved before stabilization can occur</p>",
        "id": 244974927,
        "sender_full_name": "bstrie",
        "timestamp": 1625519793
    },
    {
        "content": "<p>I feel like destructuring assignment would need an <code>if let</code>-style expression, too, if it’s supposed to be supported in a <code>let else</code>-style statement. <code>if let</code>-style means: basically just <em>some</em> way to use refutable patterns and <em>some</em> way check for success. There’s always the question of how failure works for this, I’d personally assume a “match everything first, then write everything” strategy to be the most natural, where it’s “all or nothing” regarding on which assignments happened if only some parts of the pattern match. (The alternative could be some form of left-to-right progression, stopping at the first failure, but leaving everything up to that point assigned.)</p>\n<p>This becomes harder / impossible with an <code>if let</code>-chain-style expression though, because one would expect subsequent parts of the chain to be able to “see” previous results. </p>\n<p>I don’t feel like this extension to desctucturing assignment is best discussed in a <code>let else</code>-style context first because that would already be combining multiple things IMO. I do however think that some “sanity check” on whether there’s any sensible way to adapt the syntax from <code>let</code> to destructuring assignment is reasonable.</p>",
        "id": 244975669,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1625520648
    },
    {
        "content": "<p>I suppose it's too late to make assignment expressions evaluate to bool instead of unit, and indicate whether their pattern matched :P</p>",
        "id": 244975904,
        "sender_full_name": "bstrie",
        "timestamp": 1625520944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I agree that it's worth listing an extra keyword as an alternative, even though we don't want to go that way.</p>",
        "id": 244995981,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625547870
    },
    {
        "content": "<p>With the new reserved syntax proposal, adding a keyword would be as simple as using <code>k#guard</code> for now, and then introducing the new keyword in a future edition.</p>",
        "id": 244995995,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625547916
    },
    {
        "content": "<p>Assignment expressions evaluating to unit (instead of e.g. bool) is needed to making writing <code>if x = 42</code> instead of <code>if x == 42</code> a compilation error. Avoiding the <code>==</code> vs <code>=</code> bug is a great feature of Rust that we’ll never want to remove. <span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span></p>",
        "id": 245028615,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1625573133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span>  yes, that occurred to me after I sent that. I think that argument alone suffices to guarantee that we can safely ignore destructuring assignment ever working with these conditional-like refutable pattern matching forms</p>",
        "id": 245056055,
        "sender_full_name": "bstrie",
        "timestamp": 1625585605
    },
    {
        "content": "<p>at least, not unless we want to replace <code>=</code> with something else :P</p>",
        "id": 245056097,
        "sender_full_name": "bstrie",
        "timestamp": 1625585626
    },
    {
        "content": "<p>So I've been trying to consider the interaction between let-else and if-let-chaining (or more generally, refutable-let chaining). One of the issues with the if-let chaining RFC was the interaction with <code>&amp;&amp;</code>. Specifically, <code>&amp;&amp;</code> has higher precedence than <code>=</code>, so while the whole point of that RFC was to allow you to do <code>if let Some(y) = x &amp;&amp; foo</code>, this naturally gets parsed as <code>if let Some(y) = (x &amp;&amp; foo)</code>. This was resolved by making <code>=</code> bind more tightly than <code>&amp;&amp;</code> <em>only</em> in <code>if</code> contexts. Thus <code>if let x = y &amp;&amp; z</code> has a different parse than <code>let x = y &amp;&amp; z</code>. That's already kind of a hack. If this were extended to let-else, then that would mean <code>let x = y &amp;&amp; z</code> has a different parse than <code>let x = y &amp;&amp; z else</code>, compounding the hack. Furthermore, while the RFC suggests that at first <code>let x = y &amp;&amp; z else</code> would just become a syntax error until the details are worked out (which is how <code>if let x = y &amp;&amp; z</code> was treated, and remains to this day), unlike if-let, let-else has to use unbounded lookahead to determine whether it's in a <code>let</code> or a let-else context, which I believe Rust has tried to avoid.</p>",
        "id": 245057899,
        "sender_full_name": "bstrie",
        "timestamp": 1625586380
    },
    {
        "content": "<p>if-let-chains feels like it should use different syntax than <code>&amp;&amp;</code>, honestly.</p>",
        "id": 245062188,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625587957
    },
    {
        "content": "<p>I recommend you read the if-let-chain RFC, it goes over many options and includes survey results from users. People intuitively like <code>&amp;&amp;</code>, but there's no doubt that it causes some problems. Swift uses <code>,</code> for this.</p>",
        "id": 245062426,
        "sender_full_name": "bstrie",
        "timestamp": 1625588066
    },
    {
        "content": "<p>It does feel unsurprising to me that a survey would say \"well <code>&amp;&amp;</code> seems reasonable\", so I'm unsure how much weight to give it if there are troubles that it causes.</p>\n<p>I recall arguing in favour of <code>,</code> at the time.  Interesting to know that's what Swift uses.</p>\n<p>I forget, does if-let-chain allow nesting <code>||</code>s in parens?  If that's supposed to work, it would be harder to find something to fit with <code>,</code>.</p>",
        "id": 245069591,
        "sender_full_name": "scottmcm",
        "timestamp": 1625591471
    },
    {
        "content": "<p>the if-let-chain RFC does not specify behavior for <code>||</code>, but does deliberately leave the door open for that syntax in the future</p>",
        "id": 245069694,
        "sender_full_name": "bstrie",
        "timestamp": 1625591520
    },
    {
        "content": "<p>I fear that I am drawing the conclusion that the \"proper\" way to solve this RFC might be to introduce a broader notion of a refutable let somehow, which would impact all existing <code>if let</code> in the wild. Something like <code>let? pat = expr</code> or <code>let try pat = expr</code> or <code>let pat =? expr</code> or <code>let pat match? expr</code>. It's not like such a mass syntax migration hasn't happened before (with <code>dyn Trait</code>), and it could be mechanically automated, but still...</p>",
        "id": 245070203,
        "sender_full_name": "bstrie",
        "timestamp": 1625591761
    },
    {
        "content": "<p>(although with the upside that if such a \"refutable pattern\" construct was an expression that returned bool, it would subsume the <code>matches!</code> macro)</p>",
        "id": 245070519,
        "sender_full_name": "bstrie",
        "timestamp": 1625591904
    },
    {
        "content": "<p>We've long discussed the possibility of just <code>is</code>, like <code>if y is Some(x) {</code>.</p>\n<p>If we can figure out how the scoping for that should be, I'd love to have it.  (With shadowing and such I suspect the exact details will end up being relied upon.)</p>",
        "id": 245070809,
        "sender_full_name": "scottmcm",
        "timestamp": 1625592067
    },
    {
        "content": "<p>I don't think that works for this RFC though, which really wants a <code>let</code> somewhere in order to re-use the existing notion of \"we're introducing a binding into this scope\", and if you're using <code>let</code> you want the bindings on the left, not on the right</p>",
        "id": 245070903,
        "sender_full_name": "bstrie",
        "timestamp": 1625592113
    },
    {
        "content": "<p>I also think there's a good argument against <code>,</code> for <code>&amp;&amp;</code>, since in <code>match</code> we use <code>,</code> after match arms to indicate the exact opposite, \"if you <em>didn't</em> match the previous, then try this\". So then <code>,</code> is closer to <code>||</code></p>",
        "id": 245071759,
        "sender_full_name": "bstrie",
        "timestamp": 1625592522
    },
    {
        "content": "<p>The syntax is being stressed to the breaking point here. I'm beginning to understand the appeal of just forfeiting and using s-expressions :P</p>",
        "id": 245072130,
        "sender_full_name": "bstrie",
        "timestamp": 1625592672
    },
    {
        "content": "<p>btw <span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I commend you for sticking through with all this so far, the RFC process is often not for the faint of heart and this is a difficult one for being your first RFC ever (although maybe you suspected that it would be difficult after reading the original RFC :P )</p>",
        "id": 245074105,
        "sender_full_name": "bstrie",
        "timestamp": 1625593537
    },
    {
        "content": "<p>I'll try to read through the if-let-chains rfc in detail at some point. My offhand though is something like <code>x then y</code> rather than <code>x &amp;&amp; y</code>. Though I am sure polling will probably should most people find <code>&amp;&amp;</code> the most natural from other languages.</p>",
        "id": 245074693,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625593811
    },
    {
        "content": "<p>And thanks yeah. I did suspect this would be quite debated, but it ended up being less debated in ways that I expected and more in ways I didn't suspect (maybe I made a good enough base argument? not sure!)</p>\n<p>It certainly not my first open source rodeo though, although it may be the largest so far. :P</p>",
        "id": 245074822,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625593892
    },
    {
        "content": "<p>I will note that I didn't really have a strong sense of direction for the language syntax-wise outside of the existing syntax, so I am mostly neutral to proposals like a more flexible <code>guard</code>, for better or worse.</p>",
        "id": 245075183,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625594048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> FWIW, this is reminding me strongly of my own first RFC, for <code>union</code>. They both have that quality of \"this touches so many things and needs to document all the interactions\".</p>",
        "id": 245076604,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625594632
    },
    {
        "content": "<p>Also, you're doing a <em>great</em> job of capturing all those interactions and alternatives and similar.</p>",
        "id": 245076631,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625594643
    },
    {
        "content": "<p>We just discussed the RFC in today's lang meeting.</p>",
        "id": 245076674,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625594650
    },
    {
        "content": "<p>We generally felt like most of the questions should be settled by going ahead with an implementation and letting people experiment.</p>",
        "id": 245076715,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625594674
    },
    {
        "content": "<p>We did feel, though, that the RFC needs to capture a few of these under \"unresolved questions\" rather than just \"alternatives\", because \"unresolved questions\" become checkboxes on the tracking/stabilization thread.</p>",
        "id": 245076797,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625594714
    },
    {
        "content": "<p>I was actually wondering about that</p>",
        "id": 245076851,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625594740
    },
    {
        "content": "<p>Which ones, specifically?</p>\n<p>Aside from the recent <code>guard</code> discussion, which should I suppose be in there in some form</p>",
        "id": 245077335,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625594986
    },
    {
        "content": "<p>I could get behind a <code>then</code> proposal to replace <code>&amp;&amp;</code> in these contexts, although that doesn't suggest what <code>||</code> might be (if people want it, which I'm not sure?), and it's sure to trigger a fresh round of bikeshedding</p>",
        "id": 245077551,
        "sender_full_name": "bstrie",
        "timestamp": 1625595090
    },
    {
        "content": "<p>other languages do have \"pipelining operators\" of that sort, although this would need to be pretty different from those if the idea was ever to generalize it</p>",
        "id": 245077793,
        "sender_full_name": "bstrie",
        "timestamp": 1625595195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I think the most important unresolved question is the interaction with if-let chains; it's clear that neither this feature nor that feature should be stabilized without considering the other</p>",
        "id": 245077975,
        "sender_full_name": "bstrie",
        "timestamp": 1625595258
    },
    {
        "content": "<p>fortunately if-let chains do not look to be stabilizing any time soon, so there's at least no time pressure</p>",
        "id": 245078085,
        "sender_full_name": "bstrie",
        "timestamp": 1625595313
    },
    {
        "content": "<p><code>elsewise</code> of course</p>",
        "id": 245079734,
        "sender_full_name": "The 8472",
        "timestamp": 1625596106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> So, unresolved questions shouldn't necessarily have a <em>specific</em> alternative or proposal in mind. Rather, unresolved questions needs to capture the high-level problems, like \"do we need an introducer syntax rather than just <code>let</code>\".</p>",
        "id": 245080099,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625596272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/245077335\">said</a>:</p>\n<blockquote>\n<p>Which ones, specifically?</p>\n</blockquote>\n<p>My thought was a general one about \"how's the readability of this in practice?\" to encompass various things like the \"does it need an introducer keyword?\" and such.</p>",
        "id": 245080168,
        "sender_full_name": "scottmcm",
        "timestamp": 1625596310
    },
    {
        "content": "<p>Or \"are there too many special-case exceptions (e.g. interaction with if-let)\".</p>",
        "id": 245080429,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625596426
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360405\">@Cameron Steffen</span> </p>\n<blockquote>\n<p>I suggest we disallow match, if (let) else, while and try blocks from being at the trailing position of the initializer. </p>\n</blockquote>\n<p>Any idea what the grammar for that would be like?</p>",
        "id": 245209251,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625676398
    },
    {
        "content": "<p>I'm not sure if you could (easily) put a formal grammar on it. But implementation-wise I think it is as simple as traversing through any unary or binary operators and then looking at the expression kind.</p>",
        "id": 245209795,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1625676615
    },
    {
        "content": "<p>You're just looking to avoid anything that takes a braced block?</p>",
        "id": 245210751,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625677062
    },
    {
        "content": "<p>I think we could allow <code>loop {}</code> or <code>const {}</code></p>",
        "id": 245212015,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1625677602
    },
    {
        "content": "<p>but maybe \"anything with a braced block\" is a better approach. it's simpler.</p>",
        "id": 245212978,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1625678055
    },
    {
        "content": "<p>Yeah, I think disallowing anything with a braced block is more consistent. You can always write <code>= { ... loop {} ... }</code>.</p>",
        "id": 245215275,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625679110
    },
    {
        "content": "<p>is there a difference between this and the already-existing restriction on if condition expressions?</p>",
        "id": 245220707,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625681715
    },
    {
        "content": "<p>i guess we do allow some trailing {}s in if conditions so this is probably a larger set of restrictions?</p>",
        "id": 245220936,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625681801
    },
    {
        "content": "<p>What is the list of things prohibited in if conditions?</p>",
        "id": 245221882,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625682237
    },
    {
        "content": "<p>I know structs are weird in if conditions, e.g. <code>if Foo{} == Foo{} {</code> has to be written <code>if (Foo{}) == (Foo{}) {</code></p>",
        "id": 245232950,
        "sender_full_name": "bstrie",
        "timestamp": 1625687293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> if conditions only disallow structs. And operator expressions containing structs (this is not properly documented in the reference, I just noticed).<br>\nother things with blocks, e.g. something like <code>if if true { true } else { false } { foo() }</code> work fine</p>",
        "id": 245340549,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1625763319
    },
    {
        "content": "<p>ah, thanks for the clarification- at that point, would it make sense to aim for using the same set of restrictions in both places, or is there a technical difference between <code>if bla {</code> and <code>let ... = bla else {</code> (e.g. presence or absense of a keyword between the bla and then {) that means we want different restrictions?</p>",
        "id": 245342498,
        "sender_full_name": "rpjohnst",
        "timestamp": 1625764217
    },
    {
        "content": "<p>There isn't necessarily a technical difference, but we have a compatibility requirement for <code>if</code> (which already exists) that we don't have for let-else (because it doesn't exist yet).</p>",
        "id": 245343269,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625764601
    },
    {
        "content": "<p>I think \"prohibit anything that takes a braced block\" is a sensible rule for <em>any</em> new construct that itself accepts an expression and has a braced block that immediately follows the expression.</p>",
        "id": 245343310,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625764630
    },
    {
        "content": "<p>If we add any <code>newthing expr { ... }</code>, I think we should place the same restriction on <code>expr</code>.</p>",
        "id": 245343343,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625764652
    },
    {
        "content": "<p>I wonder about <code>, else</code>...</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It solves any grammar problems, I'm not sure how much it helps with readability. I guess it's kind of random, doesn't have much precedent. Not sure if that was discussed already though so I thought I'd throw it out.</p>",
        "id": 245348993,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625767370
    },
    {
        "content": "<p><code>, else</code> has been proposed but has not been talked about to any extensive degree: <a href=\"https://github.com/rust-lang/rfcs/pull/3137#issuecomment-866252458\">https://github.com/rust-lang/rfcs/pull/3137#issuecomment-866252458</a></p>\n<p>I personally am neutral on it, I don't feel like I have a grasp on the kind of language impact of that kind of entirely new syntax.</p>",
        "id": 245356776,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625770931
    },
    {
        "content": "<p>I think the sensible question to ask: are there other similar keyword places that could also eventually benefit from <code>, keyword</code>?</p>",
        "id": 245357028,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625771064
    },
    {
        "content": "<p>Yeah. My take on all of this is that I would like to be able to experiment.</p>",
        "id": 245357034,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771066
    },
    {
        "content": "<p>One thing I'm wondering about</p>",
        "id": 245357041,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771071
    },
    {
        "content": "<p>Maybe it makes sense to prototype in a procedural macro?</p>",
        "id": 245357045,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771076
    },
    {
        "content": "<p>It might be fun to be able to switch between variants</p>",
        "id": 245357060,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771085
    },
    {
        "content": "<p>Not sure how easy it is to do this sort of thing with <code>syn</code> though</p>",
        "id": 245357066,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771091
    },
    {
        "content": "<p>A macro already exists, and has for 5-6 years</p>",
        "id": 245357068,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625771092
    },
    {
        "content": "<p><a href=\"https://crates.io/crates/guard\">https://crates.io/crates/guard</a></p>",
        "id": 245357103,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625771105
    },
    {
        "content": "<p>Heh, ok, I probably knew that at one point</p>",
        "id": 245357105,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771106
    },
    {
        "content": "<p>but does it offer more variants? maybe we could alter it...</p>",
        "id": 245357129,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771115
    },
    {
        "content": "<p>(I don't think it does any enforcement on edge cases mind you)</p>",
        "id": 245357149,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625771125
    },
    {
        "content": "<p>oh, that's not the macro I had in mind</p>",
        "id": 245357150,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771126
    },
    {
        "content": "<p>I was thinking more like <code>#[guarded_let(variant_name)]</code> as a decorator on the fn</p>",
        "id": 245357195,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771145
    },
    {
        "content": "<p>so that you can use it <em>naturally</em></p>",
        "id": 245357207,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771151
    },
    {
        "content": "<p>we could of course just implement the feature that way to start</p>",
        "id": 245357217,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771157
    },
    {
        "content": "<p>so e.g. you might write</p>",
        "id": 245357277,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771169
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[guarded_let]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// read configuration from a certain environment variable</span>\n<span class=\"w\">    </span><span class=\"c1\">// do nothing if the variable is missing</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">env</span>::<span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s\">\"FOO\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"FOO = {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[guarded_let(comma)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// read configuration from a certain environment variable</span>\n<span class=\"w\">    </span><span class=\"c1\">// do nothing if the variable is missing</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">env</span>::<span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s\">\"FOO\"</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"FOO = {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245357313,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771194
    },
    {
        "content": "<p>Yeah that would be a step up in prototype improvement for UX</p>",
        "id": 245357336,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625771210
    },
    {
        "content": "<p>anyway, as I said, to me the high order bit is wanting to play with it. I'm not sure how much doubt I have about the right approach.</p>",
        "id": 245357347,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771219
    },
    {
        "content": "<p>let...else still feels pretty \"right\" to me</p>",
        "id": 245357366,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771228
    },
    {
        "content": "<blockquote>\n<p>I think \"prohibit anything that takes a braced block\" is a sensible rule for any new construct that itself accepts an expression and has a braced block that immediately follows the expression.</p>\n</blockquote>\n<p>Is this specific enough to update the RFC with or do I need some kind of grammar for this?</p>",
        "id": 245363779,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625774358
    },
    {
        "content": "<p>I think that this should not be implemented as a syntax restriction in the grammar, but it is possible to do so analogously to EXPRESSION-WITHOUT-BLOCK; you just have to make sure that operators like <code>-t</code> and <code>e - t</code> use a EXPR-DOESNT-END-IN-BRACE in the right argument.</p>\n<p>A simpler approach is just to say that the expression can't end in a brace unless that brace comes from a [list valid alternatives here: <code>{ expr }</code> and <code>const { expr }</code>? bikeshedding is required], and implement it as a post processing stage after parsing the grammar <code>let PAT = EXPR else { BLOCK };</code> with longest-match rules (meaning that <code>let PAT = if c { e1 } else { e2 };</code> is not parsed as a let-else and causes no warnings, which must be the case because of backward compatibility).</p>",
        "id": 245379377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625782922
    },
    {
        "content": "<p>FWIW I think comma would cause <em>human</em> parsing difficulties: when you're reading an expression, a comma makes you expect more expression.</p>",
        "id": 245385419,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625787793
    },
    {
        "content": "<p>/me terrible proposal: <code>ELSE { }</code>, in all caps</p>",
        "id": 245386460,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625788834
    },
    {
        "content": "<p>We have unicode identifiers now, clearly we need unicode keywords. <code>ᴇʟsᴇ {}</code></p>",
        "id": 245388809,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625791564
    },
    {
        "content": "<p>We should convince unicode to add an emoji of someone throwing a ball so we can use it as the solution to the <code>yeet</code> keyword debate.</p>",
        "id": 245390400,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1625793283
    },
    {
        "content": "<p>(╯°□°)╯︵ ┻━┻ operator</p>",
        "id": 245391515,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625794770
    },
    {
        "content": "<p>Should we delay RFC bot’s merge so I can address some of the recommended updates? Sorry I’ve been a bit busy</p>",
        "id": 245466521,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625848819
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I added a quick note to the thread.</p>",
        "id": 245467283,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849251
    },
    {
        "content": "<p>If you have time to work on that today, I think we can just wait for it before merging the RFC. If you need some additional time to not feel rushed, I can register a concern on your behalf.</p>",
        "id": 245467322,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849282
    },
    {
        "content": "<p>I will not be at my computer most of today</p>",
        "id": 245467428,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1625849318
    },
    {
        "content": "<p>No problem. I'll register a concern then.</p>",
        "id": 245467453,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849335
    },
    {
        "content": "<p>Done.</p>",
        "id": 245467573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849395
    },
    {
        "content": "<p>How about <code>let PAT = EXPR ? { BLOCK };</code>. Think of it as a custom try bailout.</p>",
        "id": 245552824,
        "sender_full_name": "The 8472",
        "timestamp": 1625926825
    },
    {
        "content": "<p>That seems ambiguous, given that the question mark could legitimately just apply to the expression.</p>",
        "id": 245555760,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625929787
    },
    {
        "content": "<p>The parser couldn't actually know which case applied until it saw the opening curly brace.</p>",
        "id": 245555821,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625929810
    },
    {
        "content": "<p>And in theory we might actually want to use that syntax for a custom try handler.</p>",
        "id": 245555847,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625929833
    },
    {
        "content": "<p>(which would then make that entirely ambiguous)</p>",
        "id": 245555856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625929844
    },
    {
        "content": "<p>That also looks more like an expr production than a statement, i.e. <code>EXPR ? { BLOCK }</code> should be a thing</p>",
        "id": 245581470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625967320
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 245612523,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626017467
    },
    {
        "content": "<p>RFC updated. <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> could you review and unblock my own concern?</p>",
        "id": 245904356,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626220570
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/pull/3137#issuecomment-879476671\">https://github.com/rust-lang/rfcs/pull/3137#issuecomment-879476671</a></p>",
        "id": 245904372,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626220600
    },
    {
        "content": "<p>Reading...</p>",
        "id": 245907052,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223223
    },
    {
        "content": "<p>Ah, one clarification on something...</p>",
        "id": 245907175,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I think it's actually OK to have <code>let PAT = { braced expr } else { diverge };</code>.</p>",
        "id": 245907195,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223377
    },
    {
        "content": "<p>Based on the lang team consensus, the thing we wanted to avoid was <code>let PAT = some_construct_with { braces } else { diverge };</code>.</p>",
        "id": 245907217,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223410
    },
    {
        "content": "<p>loop, for, while, if, etc.</p>",
        "id": 245907219,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223418
    },
    {
        "content": "<p>The issue being that <code>some_construct_with { braces } else { diverge }</code> feels like it groups together, which seems confusing.</p>",
        "id": 245907273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223449
    },
    {
        "content": "<p>So, nothing that ends in <code>}</code> <em>and doesn't start with <code>{</code></em> unless it's wrapped in parentheses or braces.</p>",
        "id": 245907304,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223495
    },
    {
        "content": "<p>I like the suggested change of <code>1. May not end with a `}` unless this brace is the terminating brace of a [`BlockExpression`][block-expr].</code>.</p>",
        "id": 245907347,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223554
    },
    {
        "content": "<p>Just posted a comment. I think, with the suggested additional changes merged in, this LGTM.</p>",
        "id": 245907602,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626223807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/245907347\">said</a>:</p>\n<blockquote>\n<p>I like the suggested change of <code>1. May not end with a `}` unless this brace is the terminating brace of a [`BlockExpression`][block-expr].</code>.</p>\n</blockquote>\n<hr>\n<p>I’m not sure if this is optimal. Looking at something like the following example as a human</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Constructor</span><span class=\"p\">(</span><span class=\"n\">field</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam</span>\n<span class=\"w\">    </span><span class=\"c1\">// nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat,</span>\n<span class=\"w\">    </span><span class=\"c1\">// sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.</span>\n<span class=\"w\">    </span><span class=\"c1\">// Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</span>\n<span class=\"w\">    </span><span class=\"c1\">// Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor</span>\n<span class=\"w\">    </span><span class=\"c1\">// invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.</span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd</span>\n<span class=\"w\">    </span><span class=\"c1\">// gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</span>\n<span class=\"w\">    </span><span class=\"n\">baz</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam</span>\n<span class=\"w\">    </span><span class=\"c1\">// nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat,</span>\n<span class=\"w\">    </span><span class=\"c1\">// sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.</span>\n<span class=\"w\">    </span><span class=\"c1\">// Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</span>\n<span class=\"w\">    </span><span class=\"c1\">// Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor</span>\n<span class=\"w\">    </span><span class=\"c1\">// invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.</span>\n<span class=\"w\">    </span><span class=\"n\">qux</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd</span>\n<span class=\"w\">    </span><span class=\"c1\">// gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</span>\n<span class=\"w\">    </span><span class=\"n\">baz</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</span>\n<span class=\"w\">    </span><span class=\"c1\">// Lorem ipsum dolor sit amet, consetetur sadipscing elitr.</span>\n<span class=\"w\">    </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>A reader could have the following thought process:</p>\n<ul>\n<li>A <code>let</code> statement, but might be <code>let … else</code>, I don’t know if <code>Constructor(field)</code> is irrefutable.</li>\n<li>It ends with <code>} else { … };</code> block that diverges, still could be either</li>\n<li>It starts with <code>let … = {</code>, so it might be a block and thus <code>let … else</code></li>\n<li><strong><em>reading through the whole thing…</em></strong> <span aria-label=\"unamused\" class=\"emoji emoji-1f612\" role=\"img\" title=\"unamused\">:unamused:</span> </li>\n<li>Ah, it’s <code>let</code> and not <code>let … else</code>, because even though it starts with <code>{</code> and ends with <code>}</code> it’s actually <code>{ block } + some_construct_with { braces } else { block }</code></li>\n</ul>\n<p>I’m not sure what you guys are thinking but IMO this is <em>way too difficult</em> to tell <code>let</code> from <code>let else</code>.</p>\n<hr>\n<p>I like the idea that for some <code>let … = … else { … }</code>, the presence of absence of <code>}</code> immediately before the <code>else</code> could unambiguously indicate whether it’s <code>let</code> or <code>let-else</code>.  I think it’s hard enough that you’ll have to</p>\n<ol>\n<li>search for the corresponding <code>;</code></li>\n<li>if there’s a block, parse backwards to see it it’s an <code>else</code></li>\n<li>check for <code>}</code></li>\n</ol>\n<p>in order to tell <code>let</code> from <code>let-else</code> reliably as a human reader. Let’s not introduce further exceptions with counter-exceptions to this.</p>\n<p>Everything with a block just needs some parentheses then, including a block itself. It’s the syntactic price to pay in order to (ab)use <code>else</code> in an entirely new way. I’m personally probably still preferring a prefix keyword like <code>unless</code> that doesn’t need the <code>else</code>, but that’s a different topic.</p>",
        "id": 245949299,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626263635
    },
    {
        "content": "<p>To be fair, anyone who writes code that obtuse should be fired. But I am totally okay with taking out the exception for block expressions, which was suggested by @camsteffen . I just posted a list of 11 grammar productions ending in <code>}</code> on the RFC; pick your favorite subset</p>",
        "id": 245954531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626266880
    },
    {
        "content": "<p>That example would fail \"unless this brace is the terminating brace of a BlockExpression\" as far as I can tell.</p>",
        "id": 245970811,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626274425
    },
    {
        "content": "<p>Might need some clearer phrasing, like \"BlockExpression that spans the entire expr of the let-else\".</p>",
        "id": 245971065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626274532
    },
    {
        "content": "<p>I think the <code>} + if</code> is clear enough. That is not very nice code with or without let else. Maybe we should have a clippy lint for <code>\\n} binop</code>.</p>",
        "id": 245985690,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626280881
    },
    {
        "content": "<p>The long example above is exactly why I would like some keyword for this instead of (or in addition to) else.</p>",
        "id": 245987750,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626281730
    },
    {
        "content": "<p>We can all agree it’s an extreme example, but it’s an example we spent attention on. Reading a normal code base I know already, I’ll not read each and every line, I’ll fly over it looking for the overall meaning or some specific part, and a specific keyword is a very powerful indicator whereas else alone would just become confusing in a normal function, especially if there was an if earlier for which I didn’t see the end</p>",
        "id": 245988218,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626281938
    },
    {
        "content": "<p>I think it's possible to write spaghetti with many different constructs already.</p>",
        "id": 245988582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626282082
    },
    {
        "content": "<p>I don't know that we should add syntactic salt just to make that harder, when it also makes practical usage more annoying.</p>",
        "id": 245988663,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626282120
    },
    {
        "content": "<p>Another random idea. <code>let pat match expr else expr</code>. Note the absence of a <code>=</code></p>",
        "id": 245991246,
        "sender_full_name": "The 8472",
        "timestamp": 1626283229
    },
    {
        "content": "<p>I think I would personally prefer for parenthesis to be required in this case:</p>\n<div class=\"codehilite\"><pre><span></span><code>let PATTERN = ({ ... }) else { ... };\n</code></pre></div>",
        "id": 245991866,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626283509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/245907217\">said</a>:</p>\n<blockquote>\n<p>Based on the lang team consensus, the thing we wanted to avoid was <code>let PAT = some_construct_with { braces } else { diverge };</code>.</p>\n</blockquote>\n<p>I think we should move forward with that. We can re-evaluate disallowing any block before stabilization.</p>",
        "id": 245994308,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626284562
    },
    {
        "content": "<p>If we disallow <code>let PAT = unsafe { ... } else { ... }</code> then there's no way to have an unsafe expr without either including <code>else</code> into the unsafe block or introducing an intermediate <code>let</code> which defeats the purpose of using this construct that way in the fist place.</p>",
        "id": 246010029,
        "sender_full_name": "nagisa",
        "timestamp": 1626291915
    },
    {
        "content": "<p><code>let PAT = (unsafe { ... }) else { ... }</code> should do it</p>",
        "id": 246010358,
        "sender_full_name": "bstrie",
        "timestamp": 1626292074
    },
    {
        "content": "<p>ah right ^^</p>",
        "id": 246010371,
        "sender_full_name": "nagisa",
        "timestamp": 1626292080
    },
    {
        "content": "<p>You could argue that <code>unsafe {}</code> is still \"just a block\". Perhaps we could disambiguate \"types of blocks\" from \"language constructs with braces, other than blocks\".</p>",
        "id": 246012649,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626293077
    },
    {
        "content": "<p>the grammar in the reference does, it's called \"ExpressionWithBlock\"</p>",
        "id": 246015037,
        "sender_full_name": "bstrie",
        "timestamp": 1626294247
    },
    {
        "content": "<p><code>-unsafe { }</code> is <code>GroupedExpression</code>, though.</p>",
        "id": 246020492,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626296596
    },
    {
        "content": "<p>No it isn't. <code>GroupedExpression = \"(\" InnerAttribute* Expression \")\"</code> (<a href=\"https://doc.rust-lang.org/reference/expressions/grouped-expr.html\">https://doc.rust-lang.org/reference/expressions/grouped-expr.html</a>)</p>",
        "id": 246020615,
        "sender_full_name": "nagisa",
        "timestamp": 1626296634
    },
    {
        "content": "<p>I think using <code>ExpressionWithoutBlock</code> here makes sense and we can expand as people express frustrations with certain <code>ExpressionWithBlock</code> alternatives.</p>",
        "id": 246021002,
        "sender_full_name": "nagisa",
        "timestamp": 1626296748
    },
    {
        "content": "<p>Ohhh those are operator expressions. Huh ok that makes thing easier then. We can just say <code>ExpressionWithoutBlock</code> in that case then?</p>",
        "id": 246021277,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626296831
    },
    {
        "content": "<p>Oh, no, that does not make things easier, under those rules <code>-unsafe { }</code> would still be allowed.</p>",
        "id": 246021499,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626296895
    },
    {
        "content": "<p>Yeah, with a LazyBooleanExpression exception.</p>",
        "id": 246021520,
        "sender_full_name": "nagisa",
        "timestamp": 1626296902
    },
    {
        "content": "<p>Or I guess with generic <code>OperatorExpression</code> exception?</p>",
        "id": 246021677,
        "sender_full_name": "nagisa",
        "timestamp": 1626296953
    },
    {
        "content": "<p><code>StructExpression</code>s are also considered <code>ExpressionWithoutBlock</code></p>",
        "id": 246021694,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626296958
    },
    {
        "content": "<p>Hm, I would say that this is perhaps a grammar definition error, in this specific case.</p>",
        "id": 246021906,
        "sender_full_name": "nagisa",
        "timestamp": 1626297021
    },
    {
        "content": "<p>(technically it isn't, but the intent is clearly different)</p>",
        "id": 246022116,
        "sender_full_name": "nagisa",
        "timestamp": 1626297087
    },
    {
        "content": "<p>So, are we comfortable with not requiring GroupedExpression for something like <code>let 42 = unsafe { ... } + 0 else { ... }</code>?</p>",
        "id": 246022298,
        "sender_full_name": "nagisa",
        "timestamp": 1626297159
    },
    {
        "content": "<p>Or more obnoxiously:</p>\n<p><code>let 42 = if cond { ... } else { ... } + 0 else { ... }</code>?</p>",
        "id": 246022710,
        "sender_full_name": "nagisa",
        "timestamp": 1626297283
    },
    {
        "content": "<p>(I think both should be allowed, on the grounds that they aren't ambiguous)</p>",
        "id": 246022782,
        "sender_full_name": "nagisa",
        "timestamp": 1626297320
    },
    {
        "content": "<p>Yes, because you cannot write <code>if cond { } + 0 else { }</code>.</p>",
        "id": 246022792,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626297329
    },
    {
        "content": "<p>Similarly, <code>match { } + 0 else { }</code> doesn't seem like it would ever make sense</p>",
        "id": 246022919,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626297383
    },
    {
        "content": "<p>But I don't know what to do about prefix operators. And if you allow postfix operators but disallow prefix operators, then there's a sort of… arbitrary-looking restrictions from the user's view IMO.</p>",
        "id": 246022921,
        "sender_full_name": "nagisa",
        "timestamp": 1626297385
    },
    {
        "content": "<p>Can we infer from the following that it will always be let-else even if <code>match x { } else { }</code> were to become a thing?</p>\n<p><code>let Some(x) = match x { ... } else { ... };</code></p>",
        "id": 246023043,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626297468
    },
    {
        "content": "<p>From Rust's grammar/parser standpoint making a request of \"must not end with a curly brace\" is pretty weird.</p>",
        "id": 246023067,
        "sender_full_name": "nagisa",
        "timestamp": 1626297480
    },
    {
        "content": "<p>(I think we can likely infer it is let-else off of the pattern infer unless it's infallible anyways?)</p>",
        "id": 246023203,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626297544
    },
    {
        "content": "<p>I think I'd be fine with limiting it to ExpressionWithoutBlock, and letting anything else be the domain of a lint.</p>",
        "id": 246023539,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626297743
    },
    {
        "content": "<p>A lint could, after the fact, handle things like \"you have an expression ending in a brace that isn't a braced block\".</p>",
        "id": 246023556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626297759
    },
    {
        "content": "<p>In a way that's more of a pain in the grammar.</p>",
        "id": 246023578,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626297771
    },
    {
        "content": "<p>I was also thinking of suggesting just changing it back to <code>ExpressionWithoutBlock</code> for the first rule... And maybe adding the inference question as an unresolved question...</p>",
        "id": 246023736,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626297848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Problem <em>is</em> that <code>ExpressionWithoutBlock</code> allows for ambiguous grammar if we decide to in the future add an <code>else</code> to other blocky expressions.</p>",
        "id": 246024097,
        "sender_full_name": "nagisa",
        "timestamp": 1626298063
    },
    {
        "content": "<p>like for example: <code>-if foo { bar } else { baz }</code> (note the <code>-</code>) is a valid <code>ExpressionWithoutBlock</code>.</p>",
        "id": 246024190,
        "sender_full_name": "nagisa",
        "timestamp": 1626298104
    },
    {
        "content": "<p>Though I guess in that situation <code>else</code> branch is necessary either way, because otherwise the expression doesn't always produce a value for <code>-</code> to negate...</p>",
        "id": 246024270,
        "sender_full_name": "nagisa",
        "timestamp": 1626298161
    },
    {
        "content": "<p>I guess a better example is loops here: <code>-while true { ... }</code> is a valid <code>ExpressionWithoutBlock</code>.</p>",
        "id": 246024388,
        "sender_full_name": "nagisa",
        "timestamp": 1626298215
    },
    {
        "content": "<p>ah good point, I hadn't considered how those expressions compose</p>",
        "id": 246024480,
        "sender_full_name": "bstrie",
        "timestamp": 1626298273
    },
    {
        "content": "<p>But then again, I'm wondering if that's not a bug in our grammar, really.</p>",
        "id": 246024533,
        "sender_full_name": "nagisa",
        "timestamp": 1626298306
    },
    {
        "content": "<p>It shouldn't be difficult to express these situations in slightly more non-terminals.</p>",
        "id": 246024638,
        "sender_full_name": "nagisa",
        "timestamp": 1626298340
    },
    {
        "content": "<p>My concern is somewhat that its gonna be hard to also check for this after the fact if we decide to just allow <code>Expression</code> and then in a validation pass later on discard undesirable combinations.</p>",
        "id": 246024742,
        "sender_full_name": "nagisa",
        "timestamp": 1626298396
    },
    {
        "content": "<p>Actually, that makes this case ambiguous today:<br>\n<code>let Some(x) = *if { a } else { /* ? */ }</code>;</p>",
        "id": 246025022,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626298555
    },
    {
        "content": "<p>Looks like we do some specialized handling for <code>if</code> at least <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=235b1e7612fb3b1c4501ed1d36146c3f\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=235b1e7612fb3b1c4501ed1d36146c3f</a> which contradicts <a href=\"https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions\">the reference</a>.</p>",
        "id": 246025126,
        "sender_full_name": "nagisa",
        "timestamp": 1626298602
    },
    {
        "content": "<p>But I feel like it's not truely ambiguous? The match needs the <code>if</code> to return, and the pattern is failliable</p>",
        "id": 246025158,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626298626
    },
    {
        "content": "<p>(Not super surprising, given that reference is a best-effort document)</p>",
        "id": 246025194,
        "sender_full_name": "nagisa",
        "timestamp": 1626298652
    },
    {
        "content": "<p>I was wondering, if you don't mind me chiming in, since the else block is required to diverge. Would it make sense to instead require the else to be followed by a return expression?<br>\nAs in <code>let PAT = expr else return expr</code>, then one could also use a block like <code>let PAT = expr else return { ... }</code> etc, this would resolve the ambiguity problems right? Though whether people would like that requirement is another question of course</p>",
        "id": 246025217,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1626298670
    },
    {
        "content": "<p><code>let () = *if true { &amp;() } else { /* ??? */ };</code> would be a truly onerous case</p>",
        "id": 246025222,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626298676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300586\">@Lukas Wirth</span> We don't require that it returns, only that it diverges. For example, it might panic, or use the exit function, or similar.</p>",
        "id": 246025295,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626298716
    },
    {
        "content": "<p>Yes I know but then you could just write <code>return panic!()</code> was my thought</p>",
        "id": 246025340,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1626298754
    },
    {
        "content": "<p>Might as well just use a different keyword then, I'd wager</p>",
        "id": 246025369,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626298779
    },
    {
        "content": "<p>Though then the question is whether that just makes code more confusing or not</p>",
        "id": 246025389,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1626298793
    },
    {
        "content": "<p>Having to write return when you're not actually returning seems even more confusing to me.</p>",
        "id": 246025398,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626298797
    },
    {
        "content": "<p>ye, understandable</p>",
        "id": 246025412,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1626298803
    },
    {
        "content": "<p>I'd rather either <code>guard let else</code> or <code>let otherwise</code> compared to <code>let else return</code></p>",
        "id": 246025477,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626298824
    },
    {
        "content": "<p>I'm not sure <code>guard let</code> is a valid option as it'd require infinite look-ahead AFAICT.</p>",
        "id": 246025880,
        "sender_full_name": "nagisa",
        "timestamp": 1626299103
    },
    {
        "content": "<p>I'm not a fan of guard let, but why would it require more than a token of look ahead?</p>",
        "id": 246025972,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626299162
    },
    {
        "content": "<p>that is at <code>⸘</code> in <code>guard let = if { ... } ⸘ else { ... }</code> you won't know if you're parsing <code>else</code>  for the <code>if ... else ...</code> or for the <code>guard let</code>. And deciding that requires parsing the entirety of <code>else { ... }</code>.</p>",
        "id": 246026101,
        "sender_full_name": "nagisa",
        "timestamp": 1626299225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246024270\">said</a>:</p>\n<blockquote>\n<p>Though I guess in that situation <code>else</code> branch is necessary either way, because otherwise the expression doesn't always produce a value for <code>-</code> to negate...</p>\n</blockquote>\n<p>You can make that example work if you use <code>+</code> instead: <code>Foo + if cond { expr }</code> can typecheck if <code>Foo</code> implements <code>Add&lt;()&gt;</code> and can have any type you like</p>",
        "id": 246032093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626303122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246025222\">said</a>:</p>\n<blockquote>\n<p><code>let () = *if true { &amp;() } else { /* ??? */ };</code> would be a truly onerous case</p>\n</blockquote>\n<p>To reiterate what I said earlier: this presents no parsing difficulties for the compiler, because it uses longest match rules to pair the <code>else</code>, so this will always be parsed as a let statement. It is only if you have some trailing else after the expression is done, e.g. <code>let () = *(if true { &amp;() }) else { /* ??? */ };</code> or <code>let () = *if true { &amp;() } else { bla } else { /* ??? */ };</code>, that it will be parsed as a let-else; then, once it is determined to be a let-else, the grammar restrictions are applied, which would cause the second example to be rejected because the final brace in the expression is not coming from a member of the (undetermined pending bikeshedding) list of whitelisted expression productions.</p>",
        "id": 246032610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626303506
    },
    {
        "content": "<p>I don't think <code>ExpressionWithoutBlock</code> should be used for this RFC. It approximates what we want but it is intended for different purposes and it doesn't really work here.</p>",
        "id": 246033010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626303757
    },
    {
        "content": "<p>Also, I don't know if this has been mentioned yet, but invisible grouping should also count as parentheses and should be allowed. That is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"cp\">$e</span>:<span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cp\">$e</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(())</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>produces this after macro expansion:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(())</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where <code>&lt;e&gt;</code> is \"invisible grouping\", which acts like parentheses but has no actual token (the angle brackets are for illustration). When we analyze the parse tree for this expression, we will see a grouping expression with no tokens at the top level, and so allow it without peeking past the grouping.</p>",
        "id": 246033562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626304150
    },
    {
        "content": "<p>I feel like the main value of a dedicated keyword would be that there’s no need for the syntactically problematic <code>else</code> at all. Since people seem to suggest <code>guard let …</code> to still come with <code>else</code>, maybe <code>unless</code> is the better keyword after all. <code>unless let Some(x) = foo() { … }</code> doesn’t need the <code>else</code>. The only downside to current let-else proposals might be that it’s less clear that the construct introduces bindings in its containing scope, something that previously only statements starting with <code>let</code> as well as statement macro invocation could to.</p>",
        "id": 246077237,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626345829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span> I think that construct is the most compelling alternative I've seen. I still prefer let-else because it feels more like a natural extension of let to me, but having only one keyword \"unless\" is an improvement over other alternative syntax proposals.</p>",
        "id": 246102129,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626359346
    },
    {
        "content": "<p>Not having a keyword between an expression and <code>{}</code> is somewhat ambiguous but we can apply the same treatment as for <code>if</code> and since that's already done, it'd be easy to apply it here too.</p>",
        "id": 246103059,
        "sender_full_name": "nagisa",
        "timestamp": 1626359685
    },
    {
        "content": "<p>shed colour: <code>maybe let Everyone = use() { rust?(); }</code></p>",
        "id": 246103384,
        "sender_full_name": "nagisa",
        "timestamp": 1626359824
    },
    {
        "content": "<p>\"maybe\" will confuse a lot of Haskell programmers. :)</p>",
        "id": 246103497,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626359873
    },
    {
        "content": "<p>Also, I think it doesn't introduce the construct in a fashion that reads like a description. <code>if let x = e { ... }</code> feels like a natural description of when the block is run. \"maybe\" in that context seems ambiguous about when the block is run.</p>",
        "id": 246103787,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626359999
    },
    {
        "content": "<p>\"for\" and \"while\" and \"if\" all describe how the block is used. So does \"unless\", for that matter.</p>",
        "id": 246103903,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360036
    },
    {
        "content": "<p>If we're introducing a different keyword, I don't see why it wouldn't make it more sense to have it between expression and the block either way.</p>",
        "id": 246104236,
        "sender_full_name": "nagisa",
        "timestamp": 1626360183
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> I agree. I would prefer that. I just don't think we need a new keyword.</p>",
        "id": 246104347,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360234
    },
    {
        "content": "<p>We could put it in suffix position, like perl or ruby do <code>{ return Err(\"\") } unless let Some(x) = foo();</code></p>",
        "id": 246104351,
        "sender_full_name": "The 8472",
        "timestamp": 1626360236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> That would really hide the binding.</p>",
        "id": 246104444,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360261
    },
    {
        "content": "<p>depends on how you newline</p>",
        "id": 246104484,
        "sender_full_name": "The 8472",
        "timestamp": 1626360282
    },
    {
        "content": "<p>Most of the time, the error handling code is less interesting than the binding and the expression, so it shouldn't be in a more prominent position than the binding and the expression.</p>",
        "id": 246104517,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360293
    },
    {
        "content": "<p>It has the advantage of being less confusing with and/or patterns and let chains that may follow, the error case would be clearly separate from all that</p>",
        "id": 246105010,
        "sender_full_name": "The 8472",
        "timestamp": 1626360514
    },
    {
        "content": "<p><code>unless</code> can also trivially support let-chains the same way that <code>if</code> does, in particular using <code>unless</code> with a boolean as a guard/assertion with custom error behavior could be useful.</p>\n<p><code>unless condition() { … }</code> would be like <code>if !condition() { … }</code> except you immediately know that the block <code>{ … }</code> is diverging (so you can skip it when reading the code and still know that <code>condition()</code> is <em>true</em> after the <code>unless</code> statement). </p>\n<p><code>unless condition() { panic!(…) }</code> would be similar to <code>assert!(condition())</code>.</p>",
        "id": 246105033,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626360527
    },
    {
        "content": "<p>I feel like it would be confusing to allow let-chains in unless. Would the semantic be that you run the diverging block if any of the bindings fail? Does each binding have the previous binding in scope? Which bindings does the block have in scope?</p>",
        "id": 246105300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360654
    },
    {
        "content": "<blockquote>\n<p>Would the semantic be that you run the diverging block if any of the bindings fail?</p>\n</blockquote>\n<p>yes, or any of the boolean guards</p>\n<blockquote>\n<p>Does each binding have the previous binding in scope?</p>\n</blockquote>\n<p>yes</p>\n<blockquote>\n<p>Which bindings does the block have in scope?</p>\n</blockquote>\n<p>no bindings</p>",
        "id": 246105404,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626360705
    },
    {
        "content": "<p>Hmmm. So, one advantage of unless would be if you want to have exactly the same failure handling for multiple bindings.</p>",
        "id": 246105542,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360754
    },
    {
        "content": "<p>That said, most of the time I find that I want different failure handling for each binding, if only because I need a different error message.</p>",
        "id": 246105608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360784
    },
    {
        "content": "<p>then chaining might not be the right choice? it only makes sense if you want to condense a lot of conditions into one happy path</p>",
        "id": 246105673,
        "sender_full_name": "The 8472",
        "timestamp": 1626360816
    },
    {
        "content": "<p>basically</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">CHAIN</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">DIVERGING_BLOCK</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">SUBSEQUENT</span><span class=\"w\"></span>\n<span class=\"n\">STATEMENTS</span><span class=\"w\"></span>\n<span class=\"c1\">// end of containing block</span>\n</code></pre></div>\n<p>would be the same as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">CHAIN</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">SUBSEQUENT</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">STATEMENTS</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">DIVERGING_BLOCK</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(note that unlike <code>if</code>, <code>unless</code> is a statement, not an expression)</p>",
        "id": 246105802,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626360878
    },
    {
        "content": "<p>I've found many times that I do want chaining within an if-let, but in those cases, I don't typically want to diverge in the else.</p>",
        "id": 246105941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360937
    },
    {
        "content": "<p>But in any case, I do feel like unless has become the leading alternative contender.</p>",
        "id": 246106040,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626360970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I have this Swift example of a long chain where the divergence is the same for all failures: I get one « None », I return a « None » <a href=\"https://github.com/poliorcetics/ffn-dl/blob/c9aec0e7c8b52fa92434a949dbf443d01886a7f5/Sources/ffn-dl/Sites/Fanfiction.net/FFNStory.swift#L76\">https://github.com/poliorcetics/ffn-dl/blob/c9aec0e7c8b52fa92434a949dbf443d01886a7f5/Sources/ffn-dl/Sites/Fanfiction.net/FFNStory.swift#L76</a></p>",
        "id": 246144585,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626377838
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Swift\"><pre><span></span><code>    <span class=\"k\">guard</span> <span class=\"kd\">let</span> <span class=\"nv\">head</span> <span class=\"p\">=</span> <span class=\"n\">doc</span><span class=\"p\">.</span><span class=\"n\">head</span><span class=\"p\">,</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">url</span> <span class=\"p\">=</span> <span class=\"kc\">Self</span><span class=\"p\">.</span><span class=\"n\">_site</span><span class=\"p\">.</span><span class=\"n\">findCanonicalUrl</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">:</span> <span class=\"n\">head</span><span class=\"p\">)?.</span><span class=\"n\">makeChapterURL</span><span class=\"p\">(</span><span class=\"k\">for</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">),</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">body</span> <span class=\"p\">=</span> <span class=\"n\">doc</span><span class=\"p\">.</span><span class=\"n\">body</span><span class=\"p\">,</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">title</span> <span class=\"p\">=</span> <span class=\"n\">findTitle</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">:</span> <span class=\"n\">body</span><span class=\"p\">),</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">author</span> <span class=\"p\">=</span> <span class=\"n\">Author</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">:</span> <span class=\"n\">doc</span><span class=\"p\">,</span> <span class=\"n\">withFinder</span><span class=\"p\">:</span> <span class=\"kc\">Self</span><span class=\"p\">.</span><span class=\"n\">site</span><span class=\"p\">.</span><span class=\"n\">authorFinder</span><span class=\"p\">),</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">summary</span> <span class=\"p\">=</span> <span class=\"n\">findSummary</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">:</span> <span class=\"n\">body</span><span class=\"p\">),</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">tokens</span> <span class=\"p\">=</span> <span class=\"n\">findTokens</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">:</span> <span class=\"n\">body</span><span class=\"p\">),</span>\n      <span class=\"kd\">let</span> <span class=\"nv\">universe</span> <span class=\"p\">=</span> <span class=\"n\">Universe</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">:</span> <span class=\"n\">doc</span><span class=\"p\">,</span> <span class=\"n\">withFinder</span><span class=\"p\">:</span> <span class=\"kc\">Self</span><span class=\"p\">.</span><span class=\"n\">site</span><span class=\"p\">.</span><span class=\"n\">universeFinder</span><span class=\"p\">)</span>\n      <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">nil</span>\n    <span class=\"p\">}</span>\n</code></pre></div>",
        "id": 246144743,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626377900
    },
    {
        "content": "<p>Since I'm in a failable initializer like <code>Self::new() -&gt; Option&lt;Self&gt;</code> I cannot return anything but an <code>Option</code> and panicking is not the answer here so all preconditions are checked at once and return the same thing if even only one of them fails.</p>",
        "id": 246145221,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626378134
    },
    {
        "content": "<p>Note that <code>body</code> is also used after it was successfully bound (<code>let body = doc.body, let title = findTitle(in: body),</code>)</p>",
        "id": 246145297,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626378173
    },
    {
        "content": "<p>that one particular case seems better covered by <code>?</code></p>",
        "id": 246150682,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626380846
    },
    {
        "content": "<p>That’s true, Swift doesn’t have that, I forgot about it in my comparison</p>",
        "id": 246151976,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626381521
    },
    {
        "content": "<p>unless let has a surprising symmetry with if let and while let</p>",
        "id": 246183162,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626409056
    },
    {
        "content": "<p>and resolves the introducer syntax question</p>",
        "id": 246183303,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626409318
    },
    {
        "content": "<p>This feels like a game-changer for me. And I don't feel that let chains would be confusing. It's very much like if let but the scope of the bindings is flipped.</p>",
        "id": 246183913,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626410275
    },
    {
        "content": "<p>Isn't this just circling back to the original <code>if !let</code> proposal?</p>",
        "id": 246184813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626411538
    },
    {
        "content": "<p>Subtle, but I think <code>if !let</code> is too much like <code>if let</code> and it's harder to see that the scope of the bindings is different.</p>",
        "id": 246185295,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626412083
    },
    {
        "content": "<p>While I like the idea of <code>unless</code> as a swapped <code>if</code>, which is useful in particular for asserts, if (let) expressions are expressions, not statements, so <code>unless let</code> being a statement would break the symmetry (and also make things more confusing if <code>unless cond { expr }</code> and <code>unless cond { expr } else { expr }</code> become a thing)</p>",
        "id": 246185410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626412261
    },
    {
        "content": "<p>There is a bit of a comprehension obstacle with the word \"unless\". In English we typically say, \"unless something unusual happens, do the normal thing\". When you map that onto Rust, you might get \"unless this variable happens to match the pattern, do the normal thing and <code>panic</code>\". In other words, the word\"unless\" may invoke a misconception that matching the pattern is <em>exceptional</em> and underlying block is the normal case. I don't think this is a blocker, but something to voice.</p>",
        "id": 246185597,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626412554
    },
    {
        "content": "<p>I do think <code>unless let pat = expr { ... }</code> is better than <code>if !let pat = expr else { ... }</code> or <code>let pat = expr, else</code> or some of the other alternative proposals. I still don't think it's better than <code>let pat = expr else { ... }</code>.</p>",
        "id": 246188823,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626416978
    },
    {
        "content": "<p>(actually the <code>unless let</code> proposal doesn't have an <code>else</code>. I forget if <code>if !let</code> does)</p>",
        "id": 246188930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626417096
    },
    {
        "content": "<p>(Ah, sorry, correcting.)</p>",
        "id": 246189541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626417681
    },
    {
        "content": "<p>I do think <code>let else</code> is the most <em>immediately</em> intuitive. But <code>unless let</code> has an advantage of fewer syntactic special cases and it's the most similar to existing constructs. I wonder if <code>unless let</code> would feel the most \"at home\" in the language given the opportunity to adjust to it.</p>",
        "id": 246215237,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626437776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360405\">@Cameron Steffen</span> I appreciate the distinction you're making. I'll grant that <code>unless let</code> might be easier to parse. But I personally feel <code>let else</code> will be easier for humans to work with.</p>",
        "id": 246244088,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626451888
    },
    {
        "content": "<p>And I feel fairly certain that <code>let else</code> will be parseable.</p>",
        "id": 246244112,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626451905
    },
    {
        "content": "<p>I think <code>let</code> ... <code>else</code> will feel like a natural extension of <code>let</code>.</p>",
        "id": 246244198,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626451930
    },
    {
        "content": "<blockquote>\n<p>I personally feel <code>let else</code> will be easier for humans to work with.</p>\n</blockquote>\n<p>Yeah, I can see that for sure.</p>",
        "id": 246245541,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626452579
    },
    {
        "content": "<blockquote>\n<p>I personally feel <code>let else</code> will be easier for humans to work with.</p>\n</blockquote>\n<p>I don’t agree at all (for honesty: I only have my Swift experience and empirical evidence of this, nothing more complete).</p>\n<p>Having a keyword like « unless » right at the start helps me ignore a whole block very quickly when I’m interested in the happy path of a method. An « else » that I must find later on is long compared to this.</p>\n<p>Also, « unless let = …» could be an expression, just one returning « ! », just like a regular « let o = if cond { happy path } else { break out of scope/block } » is in the « else » case today</p>",
        "id": 246263134,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626461107
    },
    {
        "content": "<p>Though I don’t know when « let x = unless let y = … { } » would be useful so maybe making it an expression is useless anyway</p>",
        "id": 246263876,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626461505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360405\">Cameron Steffen</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246215237\">said</a>:</p>\n<blockquote>\n<p>But <code>unless let</code> has an advantage of fewer syntactic special cases</p>\n</blockquote>\n<p>It's worth noting that <code>unless let</code> would need a similar syntactic special case as <code>if</code> conditions, namely you can't put <code>Foo { ... }</code> in there without additional parentheses. It's a special case shared with <code>if</code> and <code>if let</code> and <code>while</code> so you can argue that it's less special, but it's still not the entire <code>expr</code> grammar like it says on the tin</p>",
        "id": 246274959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626467622
    },
    {
        "content": "<blockquote>\n<p>Also, « unless let = …» could be an expression, just one returning « ! », just like a regular « let o = if cond { happy path } else { break out of scope/block } » is in the « else » case today</p>\n</blockquote>\n<p>If it's an expression, it can't contribute bindings to the enclosing block. So this isn't an option</p>",
        "id": 246275206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626467754
    },
    {
        "content": "<p>While it’s true that <code>unless let</code> needs syntactic restrictions, too, this is an entirely different story because these restrictions are the same as for <code>if let</code> and <code>if</code> and <code>while</code> and <code>for</code> (after the <code>in</code>) and <code>match</code>, in other words – super common and the same throughout the language. Furthermore the syntactic restrictions are clear from the first word of the statement. You write <code>unless</code> and you know there will be restrictions. OTOH, <code>let</code> (without <code>else</code>) is free of restrictions, yet we’re “extending” it  with an <code>else</code> syntax that tells you after the fact that – <em>by the way there were syntactic restrictions in the thing you’ve just written</em>.</p>\n<p>In my opinion it’s clear that <code>unless let</code> is syntactically superior to <code>let … else</code>. The only potential disadvantage is that <code>unless</code> might not feel ideal to some native English speakers. I mean – programming languages don’t exactly read like English poetry anyways, so I guess everyone would get used to it really quickly – but of course there’s also the option to discuss other alternatives for the keyword. I could come up with</p>\n<ul>\n<li><code>guard</code>, but without the <code>else</code> – although that might read like it’s guarding the thing in the block, not the code that follows it</li>\n<li><code>ensure</code>, or something else that sound somewhat similar to <code>assert</code> – I think the fact that the subsequent block describes the “error”/“failure” case is only just about as confusing as writing <code>foo.expect(\"error message\")</code> is. You get used to it. <code>ensure</code> is probably a less common variable name than <code>guard</code> so it’s perhaps nicer as a new keyword?</li>\n<li>For the mathematicians among us, I suppose “<a href=\"https://en.wikipedia.org/wiki/Without_loss_of_generality\"><code>wlog</code></a>” could be a superb choice of keyword. I mean, just look at this:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">sorted_array_of</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">wlog</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">sorted_array_of</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">wlog</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">sorted_array_of</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>okay, that was a boolean example and not doing <code>wlog let</code>, but <code>wlog let</code> just sounds so nice, too <strong>/S</strong></p>",
        "id": 246316382,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626515695
    },
    {
        "content": "<p>I don't think that any expression restrictions that can be solved by adding a couple parentheses are a problem in practice. It might give you pause the first time it comes up but it's really no big deal, and the white lie that all expressions are accepted in that position will go unchallenged most of the time, because you have to bend over backwards to hit the restriction - the body of a let-else is supposed to be short, otherwise it defeats the purpose of putting the else branch near the binding and you would be better off to use a match or an auxiliary binding for the scrutinee. This restriction is very much intended as a compiler-driven readability aid in any case.</p>",
        "id": 246318279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626518544
    },
    {
        "content": "<p>the only block expression I find likely to appear in that position in practice is <code>unsafe { ... }</code></p>",
        "id": 246318357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626518719
    },
    {
        "content": "<p>No question that <code>unless let</code> just \"fits in\" with existing syntax better than other options. But the special cases of <code>let else</code> are just rare enough to be tolerable. Because I think it would just be bad style to write something like <code>let ..  = match .. else ..</code>. In all likelihood it's better to just use <code>let .. = match</code> or introduce an intermediate binding. I think a similar thing could be said about the other special cases. So then I think it just comes down to human readability and intuitiveness. But it's hard for me to decide that either one is clearly better than the other in this regard (I keep going back and forth in my mind). Either one will just take some getting used to. I find myself going back to <code>unless let</code> just to avoid the additional special cases in syntax. Because people <em>will</em> bump into those cases <em>occasionally</em> and it will be a hindrance.</p>\n<p><code>unless let</code> feels more blatantly different where <code>let else</code> just blends in more. It feels like <code>let</code> meets <code>if else</code>. So I think the important question is whether or not the blatant differentness of <code>unless</code> is a good thing. I'm thinking that it actually is a good thing because it requires a divergent block - that is different from any other construct. So I guess I am kinda leaning to <code>unless let</code>, but I still think that <code>let else</code> would be okay.</p>\n<blockquote>\n<p>I don't think that any expression restrictions that can be solved by adding a couple parentheses are a problem in practice.</p>\n</blockquote>\n<p>This is just a style thing but I have strong reservations about this. Rust usually goes the extra mile to <em>avoid</em> the need for parenthesis. I know we're just talking about special cases, but <code>let else</code> would lower the bar to some degree with regard to how common it is for parenthesis to be required. So I think we should tread carefully there.</p>",
        "id": 246339613,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626549705
    },
    {
        "content": "<p>If we do have <code>unless let</code>, we also get <code>unless &lt;cond&gt; { ... }</code>, right? as an alternative to <code>if !cond { ... }</code>?</p>",
        "id": 246345857,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626558023
    },
    {
        "content": "<p>I <em>personally</em> find <code>if !....</code> quite hard to process</p>",
        "id": 246345860,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626558033
    },
    {
        "content": "<p>e.g. <code>if !foo.is_empty() { .. }</code> kind of hurts my head</p>",
        "id": 246345863,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626558046
    },
    {
        "content": "<p>compared to <code>if foo.is_not_empty() { </code></p>",
        "id": 246345866,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626558053
    },
    {
        "content": "<p><code>unless foo.is_empty() { .. }</code> is probably easier for me, though I don't have experience to back that up</p>",
        "id": 246345872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626558065
    },
    {
        "content": "<p>I still, I think, lean towards \"let else\", but I wouldn't be opposed to implementing both as an experiment :)</p>",
        "id": 246346603,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626559218
    },
    {
        "content": "<p><code>unless let Ok(x) = .... {</code> does not \"say\" to me that <code>x</code> is bound in the statements that follow, though</p>",
        "id": 246346624,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626559241
    },
    {
        "content": "<p>That's <em>exactly</em> my concern as well. <code>unless let</code> doesn't feel like a binding statement for the following code; <code>let ... else</code> does.</p>",
        "id": 246347056,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626560020
    },
    {
        "content": "<p>Since it's just supposed to desugar to match anyway why not make the match syntax more compact?</p>\n<p><code>let match { (Some(foo), Ok(bar)) ; _ =&gt; return } = expr;</code><br>\n<code>let match expr { (Some(foo), Ok(bar)) ; _ =&gt; return };</code></p>\n<p>Or closer to <code>&lt;control flow keyword&gt; let pattern = expr</code>:</p>\n<p><del><code>match let { (Some(foo), Ok(bar)) ; _ =&gt; return } = expr;</code></del> edit, forget about this one, scoping is differnet compared to if/while let after all.</p>",
        "id": 246347122,
        "sender_full_name": "The 8472",
        "timestamp": 1626560149
    },
    {
        "content": "<p>The RFC just doesn't go far enough with the \"Assign to outer scope from match\" alternative.</p>",
        "id": 246347165,
        "sender_full_name": "The 8472",
        "timestamp": 1626560185
    },
    {
        "content": "<blockquote>\n<p>I personally find <code>if !....</code> quite hard to process</p>\n</blockquote>\n<p>Yes yes yes, <code>!</code> is horrible to read</p>\n<blockquote>\n<p><code>unless let</code> doesn't feel like a binding statement</p>\n</blockquote>\n<p>Question of habit I suppose, I never saw anyone complain about it in Swift</p>",
        "id": 246348692,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626562917
    },
    {
        "content": "<blockquote>\n<p>If we do have <code>unless let</code>, we also get <code>unless &lt;cond&gt; { ... }</code>, right? as an alternative to <code>if !cond { ... }</code>?</p>\n</blockquote>\n<p>So, I think the <code>guard</code> keyword (without <code>else</code>) makes since IFF we also have that feature. I used to think that feature doesn't fit in Rust, but it makes more since now without <code>else</code>.</p>\n<blockquote>\n<blockquote>\n<p><code>unless let</code> doesn't feel like a binding statement</p>\n</blockquote>\n<p>Question of habit I suppose, I never saw anyone complain about it in Swift</p>\n</blockquote>\n<p>I think <code>guard</code> is better in that regard too? It says \"guarding a condition/binding for following statements\".</p>",
        "id": 246349657,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626564487
    },
    {
        "content": "<p>It would be nice to have a consensus between <code>unless</code> and <code>guard</code> so that we only have two options to implement :)</p>",
        "id": 246349728,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626564644
    },
    {
        "content": "<p><code>unless</code> or <code>guard</code> seem very readable to me, <code>let/else</code> already seems like a nightmare worthy of <code>!</code> for review</p>",
        "id": 246349742,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626564698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360405\">Cameron Steffen</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246349728\">said</a>:</p>\n<blockquote>\n<p>It would be nice to have a consensus between <code>unless</code> and <code>guard</code> so that we only have two options to implement <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>No opinion on that ^^ either is fine to me</p>",
        "id": 246349787,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626564740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246345860\">said</a>:</p>\n<blockquote>\n<p>I <em>personally</em> find <code>if !....</code> quite hard to process, e.g. <code>if !foo.is_empty() { .. }</code> kind of hurts my head. <code>unless foo.is_empty() { .. }</code> is probably easier for me, though I don't have experience to back that up</p>\n</blockquote>\n<p>Anecdotally, I recently moved to the new version of lean which has gained an <code>unless</code> keyword which means just what you think it does (there is no <code>unless let</code> though), and I use it by preference over <code>if !cond</code> whenever possible. It is best suited when there is only one branch and I don't want to write <code>if cond {} else { block }</code> or <code>if !cond { block }</code>, and the block is often but not always diverging (it's great for asserts).</p>",
        "id": 246355973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626576594
    },
    {
        "content": "<p>The problem I see is that:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would be very analogous, but the scope of <code>x</code> in</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would really not be.</p>",
        "id": 246428015,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682928
    },
    {
        "content": "<p>However, I suppose if you wrote an <code>else</code>, that would help</p>",
        "id": 246428038,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682948
    },
    {
        "content": "<p>but then it's weird</p>",
        "id": 246428048,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682954
    },
    {
        "content": "<p>Still, maybe you get used to it.</p>",
        "id": 246428061,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626682969
    },
    {
        "content": "<p>While I have never programmed in a language with something like <code>unless</code> or <code>until</code>, I do find it very confusing when I have to read code using such \"negated conditionals\" -- I think mostly that was Perl code, so mayb'e it's a perl thing and not an <code>unless</code> thing, but still I consider these kind of implicit negations to be a big hurdle to readability. I'd also say it adds unnecessary redundancy to the language.</p>",
        "id": 246428236,
        "sender_full_name": "RalfJ",
        "timestamp": 1626683118
    },
    {
        "content": "<p>my only gripe with <code>if !foo.is_empty() { .. }</code> is that the <code>!</code> is at the wrong end of the chain, but <code>if foo.is_empty().not()</code> is great IMO :D sadly it requires an import</p>",
        "id": 246428345,
        "sender_full_name": "RalfJ",
        "timestamp": 1626683176
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246428345\">said</a>:</p>\n<blockquote>\n<p>my only gripe with <code>if !foo.is_empty() { .. }</code> is that the <code>!</code> is at the wrong end of the chain, but <code>if foo.is_empty().not()</code> is great IMO :D sadly it requires an import</p>\n</blockquote>\n<p>For some reason this reminds me of the scene in indiana jones where the coin with directions to the treasure has an addendum on the other side that adds a negation</p>",
        "id": 246429472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626683996
    },
    {
        "content": "<p>we add all sorts of things to the end of such chains that are extremely relevant -- it's standard method call syntax</p>",
        "id": 246430388,
        "sender_full_name": "RalfJ",
        "timestamp": 1626684618
    },
    {
        "content": "<p><code>unless</code> actually has the same problem as <code>if !...</code> here -- for non-trivial conditions, the negation is way removed from what it actually negates</p>",
        "id": 246430452,
        "sender_full_name": "RalfJ",
        "timestamp": 1626684678
    },
    {
        "content": "<p>I think it has more to do with english grammar, but \"unless foo is empty\" reads a lot better than either \"if not foo is empty\" or worse, \"if foo is empty... not\"</p>",
        "id": 246430563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626684742
    },
    {
        "content": "<p>\"unless &lt;very long sentence&gt; is empty\" IMO reads quite badly since, again, the negation is so removed from what it negates</p>",
        "id": 246430681,
        "sender_full_name": "RalfJ",
        "timestamp": 1626684835
    },
    {
        "content": "<p>the natural thing would be \"if &lt;foo&gt; is not empty\", which is very close to <code>&lt;foo&gt;.is_empty().not()</code></p>",
        "id": 246430739,
        "sender_full_name": "RalfJ",
        "timestamp": 1626684847
    },
    {
        "content": "<p>maybe it's also a \"what's your mother tongue\" thing: \"unless foo is empty\" has no translation into German that sounds even remotely natural -- other than \"if foo is not empty\"</p>",
        "id": 246430935,
        "sender_full_name": "RalfJ",
        "timestamp": 1626684991
    },
    {
        "content": "<p>Isn't german known for its long relative clauses? You need a lot of stack space</p>",
        "id": 246431115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626685125
    },
    {
        "content": "<p>well, \"unless\" is English stacking in ways that not even German dares to do ;)</p>",
        "id": 246431293,
        "sender_full_name": "RalfJ",
        "timestamp": 1626685227
    },
    {
        "content": "<p>(english can be just as bad but people don't normally write like that anymore)</p>",
        "id": 246431327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626685255
    },
    {
        "content": "<p>(postfix-\"unless\" has a fairly natural translation to German but that's not what we are talking about here)</p>",
        "id": 246431354,
        "sender_full_name": "RalfJ",
        "timestamp": 1626685274
    },
    {
        "content": "<p>I’d like to reiterate that while <code>unless …</code> and <code>if !…</code> might seem similar, and some cases of boolean <code>unless</code> can already be expressed with <code>if !</code> in the same way, the proposed <code>unless</code> is fundamentally different from <code>if</code> in that</p>\n<ul>\n<li>it’s a statement, <strong><em>not</em></strong> an expression</li>\n<li>it does not support an <code>else</code> branch at all</li>\n<li>the following block <strong><em>must</em></strong> diverge</li>\n<li><code>unless let</code> allows for bindings that are in scope <em>after</em> the statement</li>\n</ul>\n<p>At least these are the rules that I would give an <code>unless</code>/<code>guard</code>/<code>ensure</code>/<code>wlog</code> statement</p>",
        "id": 246432668,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626686272
    },
    {
        "content": "<p>For me it is exactly these features that make <code>unless let</code> undesirable compared to <code>let ... else</code>. I want it to look like a variation on <code>let</code>, not a variation on <code>unless</code>, because it shares more features with the former than the latter. (One can argue that <code>unless</code> doesn't actually exist in rust, but I think there is enough conceptual baggage from other languages and english itself that its meaning as swapped if is not very malleable.)</p>",
        "id": 246433178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626686689
    },
    {
        "content": "<blockquote>\n<p>I want it to look like a variation on let, not a variation on unless</p>\n</blockquote>\n<p>did you mean \"not a variation on <code>if</code>\"? If yes then I agree.</p>",
        "id": 246435341,
        "sender_full_name": "RalfJ",
        "timestamp": 1626688214
    },
    {
        "content": "<p>No, I mean a variation on <code>unless</code>, that is the construction <code>unless cond { block } else { block }</code> for flipped-if that does not exist in rust but conceivably could exist and does exist in english and other computer languages</p>",
        "id": 246436336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626688868
    },
    {
        "content": "<p>That is, I don't want <code>unless let pat = expr { block }</code> to look too much like <code>unless cond { block }</code> because it badly completes the analogy square with <code>if let pat = expr { block }</code> and <code>if cond { block }</code></p>",
        "id": 246436451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626688951
    },
    {
        "content": "<p>ah I see, makes sense</p>",
        "id": 246438533,
        "sender_full_name": "RalfJ",
        "timestamp": 1626690522
    },
    {
        "content": "<p>I think the <code>unless bool</code> feature does not carry its weight unless it requires a divergent block. And that requirement would only make sense if <code>unless</code> is changed to <code>guard</code>.</p>",
        "id": 246462242,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626705151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246436451\">said</a>:</p>\n<blockquote>\n<p>… <code>unless let pat = expr { block }</code> to look too much like <code>unless cond { block }</code></p>\n</blockquote>\n<p>I would want <em>precisely</em> this relationship in order to enable the possibility that both <code>unless let pat = expr { block }</code> and <code>unless cond { block }</code> will, eventually, just both be special cases of <code>unless LET_CHAIN { block }</code>. But I don’t really care – at all – about the choice of keyword. The choice <code>guard</code> is fine, too. I do care about the absence of the <code>else</code> because the <code>else</code> seems like a syntactic nightmare, and I’d want a prefix keyword anyways because it makes things much more clear for the reader. </p>\n<p>An example using a boolean version, depending on the choice of keyword, would look like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"s\">\"too small\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">handle_nonempty</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"s\">\"too small\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">handle_nonempty</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I feel like maybe I’m starting to prefer <code>guard</code>, too.</p>",
        "id": 246477998,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626712166
    },
    {
        "content": "<p>With the <code>guard</code> version I wouldnt even know what it means</p>",
        "id": 246478212,
        "sender_full_name": "RalfJ",
        "timestamp": 1626712257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246244198\">said</a>:</p>\n<blockquote>\n<p>I think <code>let</code> ... <code>else</code> will feel like a natural extension of <code>let</code>.</p>\n</blockquote>\n<p><span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> I basically find myself in full agreement with Josh. (Also in terms of none of these other proposals being better than <code>let pattern = expr else { ... }</code>)</p>",
        "id": 246478894,
        "sender_full_name": "RalfJ",
        "timestamp": 1626712567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280891\">Frank Steffahn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246477998\">said</a>:</p>\n<blockquote>\n<p>I do care about the absence of the <code>else</code> because the <code>else</code> seems like a syntactic nightmare,</p>\n</blockquote>\n<p>I think this is much too strong. What matters is the common case, and 99% of the time you won't be using a block in the scrutinee, and in the remaining 1% of the time using <code>({ block })</code> is no big deal.</p>\n<p>If you mean a nightmare for specification and/or implementation, I disagree less strongly but I still think it's relatively simple to implement, and I've made several stabs at a spec already, modulo bikeshedding.</p>",
        "id": 246479059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626712664
    },
    {
        "content": "<p>No opinions on just making <code>let match</code> more concise?</p>",
        "id": 246481218,
        "sender_full_name": "The 8472",
        "timestamp": 1626713717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> That proposal seems like it moves the <code>expr</code> much too far away from the binding, and changes <code>match</code> syntax too much in a non-obvious way. It doesn't feel like an orthogonal combination of existing language features.</p>",
        "id": 246483132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626714566
    },
    {
        "content": "<p>I think an issue with the <code>let match</code> syntax proposed above is that it doesn't scale down very much for simpler cases. An upside of <code>let else</code> is that simple cases look extremely simple. And for non-simple cases we have full <code>match</code>. This has parallels with how <code>if let</code> works for simple cases, but if you scale up in the complexity of the expression then you might want to just convert to a <code>match</code>.</p>\n<p>So I think one of the things we're struggling with is that while it's understood that a complicated-enough <code>if let</code> should just be turned into a <code>match</code>, the <code>let else</code> syntax doesn't scale up as well as <code>if let</code> does, so there's a larger gulf between the simple-and-lightweight <code>let else</code> and the powerful-and-heavyweight <code>match</code> equivalent.</p>",
        "id": 246483245,
        "sender_full_name": "bstrie",
        "timestamp": 1626714607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> Also, the placement of the bindings in that proposal has a problem similar to <code>unless let</code>: it doesn't look like it binds something in the outer scope.</p>",
        "id": 246483346,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626714658
    },
    {
        "content": "<p>leading with a <code>let</code> would be a clear sign that something is being bound though</p>",
        "id": 246483410,
        "sender_full_name": "The 8472",
        "timestamp": 1626714696
    },
    {
        "content": "<p>It would, but then you have to scan quite far into the expression to see what's being bound.</p>",
        "id": 246483446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626714720
    },
    {
        "content": "<p>Not all that far with <code>let match { (Some(foo), Ok(bar)) ; _ =&gt; return } = expr;</code></p>",
        "id": 246483586,
        "sender_full_name": "The 8472",
        "timestamp": 1626714765
    },
    {
        "content": "<p>I do agree that leading with a <code>let</code> at the beginning is important for expressing that a binding is being introduced, although yes, it's almost as important to also have the binding itself be nearby the let</p>",
        "id": 246483594,
        "sender_full_name": "bstrie",
        "timestamp": 1626714769
    },
    {
        "content": "<p>if you put the expression first then yes, there would be quite a distance between the let and the bindings, but if you have it in the tail position then the distance is fixed.</p>",
        "id": 246483654,
        "sender_full_name": "The 8472",
        "timestamp": 1626714811
    },
    {
        "content": "<p>So, one problem there is that the block handling the non-matching case comes before the expression, which pushes the expression too far to the right.</p>",
        "id": 246483790,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626714862
    },
    {
        "content": "<p>I would guess that in most medium or larger examples that wouldn't fit on a line, and then indentation looks like a mess</p>",
        "id": 246483935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626714938
    },
    {
        "content": "<p>Something like <code>let PAT = match EXPR else { ... }</code> wouldn't be completely out of the question... just full-on non-exhaustive match where the <code>else</code> is first-class sugar for the inner <code>_</code> arm</p>",
        "id": 246483943,
        "sender_full_name": "bstrie",
        "timestamp": 1626714944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Not necessarily a mess, but no simpler or briefer than <code>match</code> at that point.</p>",
        "id": 246484045,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626714980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> And the <code>let PAT =</code> is syntactic sugar for the first arm of the match?</p>",
        "id": 246484126,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715026
    },
    {
        "content": "<p>yes, although I wonder if there's a more expression-oriented friendly way to formulate it</p>",
        "id": 246484187,
        "sender_full_name": "bstrie",
        "timestamp": 1626715065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> That <em>feels</em> non-orthogonal in a language design sense, because the <code>match EXPR else { ... }</code> on the right feels like a construct that should work outside of the <code>let</code>, but it's not obvious what it could mean.</p>",
        "id": 246484197,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715073
    },
    {
        "content": "<p>So the preferences seem to be:</p>\n<ol>\n<li>let in front</li>\n<li>pattern</li>\n<li>expression</li>\n<li>diverging block</li>\n</ol>\n<p>That doesn't leave many options how to structure this, other than picking keywords and sigils</p>",
        "id": 246484292,
        "sender_full_name": "The 8472",
        "timestamp": 1626715108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> Pretty much, yes.</p>",
        "id": 246484323,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715125
    },
    {
        "content": "<p>it does have the advantage that of all the braced expressions that we could add <code>else</code> to, <code>match</code> is the only one that's not complete nonsense :P</p>",
        "id": 246484324,
        "sender_full_name": "bstrie",
        "timestamp": 1626715126
    },
    {
        "content": "<p>1) <code>let</code> in front to advertise that there are bindings<br>\n2) <code>pat</code> next for similarity with let and to define what the bindings are early.<br>\n3) <code>expr</code> next for similarity with let and because it's executed logically before the diverging block<br>\n4) diverging block last because it's executed logically last as part of error handling, and to make it easy to break across lines since it's a braced block that could contain multiple statements.</p>",
        "id": 246484506,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715226
    },
    {
        "content": "<p><code>let PAT if = EXPR else { ... }</code>?</p>",
        "id": 246484515,
        "sender_full_name": "bstrie",
        "timestamp": 1626715234
    },
    {
        "content": "<p>valid under the given constraints :P</p>",
        "id": 246484744,
        "sender_full_name": "The 8472",
        "timestamp": 1626715354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> That does fit all the above criteria, though its use of <code>if</code> seems confusing. You're trying to find a way to forecast the \"else\" there? <code>if</code> as a keyword followed immediately by <code>=</code> confuses my internal parser. :)</p>",
        "id": 246484827,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715389
    },
    {
        "content": "<p>it's not half bad... or rather maybe it's <em>only</em> half bad, which might be an improvement over everything else we've got :P</p>",
        "id": 246484836,
        "sender_full_name": "bstrie",
        "timestamp": 1626715394
    },
    {
        "content": "<p>And I'm concerned that <code>if = EXPR</code> will be easy to misread as <code>if EXPR</code>.</p>",
        "id": 246484870,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715409
    },
    {
        "content": "<p>is &lt;- still reserved?</p>",
        "id": 246484920,
        "sender_full_name": "The 8472",
        "timestamp": 1626715430
    },
    {
        "content": "<p>oh no, <code>=</code> vs <code>&lt;-</code>... <em>flashbacks to R</em></p>",
        "id": 246485021,
        "sender_full_name": "bstrie",
        "timestamp": 1626715458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> Huh. Possibly. Are you thinking that replacing <code>=</code> with <code>&lt;-</code> in a let-else would have a symmetry with match using <code>=&gt;</code>, and thus evoke a different construct?</p>",
        "id": 246485082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715489
    },
    {
        "content": "<p>/me is still trying to figure out the actual problem people are trying to solve.</p>",
        "id": 246485127,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715510
    },
    {
        "content": "<p>yes</p>",
        "id": 246485129,
        "sender_full_name": "The 8472",
        "timestamp": 1626715512
    },
    {
        "content": "<p>I get that people want to forecast the <code>else</code>, but I haven't yet fully understood <em>why</em>.</p>",
        "id": 246485156,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715523
    },
    {
        "content": "<p>I feel like people must read code very differently than I do. Which is completely valid, and I'm trying to understand what goes wrong in people's internal Rust parsers if the <code>else</code> isn't forecast by anything other than \"this pattern looks like it might be refutable\".</p>",
        "id": 246485269,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715570
    },
    {
        "content": "<p>because let looks_like_an_infallible_pattern = multi-line expressions... SURPRISE ELSE ?</p>",
        "id": 246485303,
        "sender_full_name": "The 8472",
        "timestamp": 1626715589
    },
    {
        "content": "<p>I don't particularly care about forecasting the <code>else</code> (well, it would be nice for parsing), but I am a little worried about any future extension re: if-let-chains, where suddenly the RHS of the <code>=</code> is a full-on conditional context without any forewarning</p>",
        "id": 246485333,
        "sender_full_name": "bstrie",
        "timestamp": 1626715608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> I feel quite strongly that we should never allow this to mix with if-let chains.</p>",
        "id": 246485413,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715649
    },
    {
        "content": "<p>note that with if-let-chains, <code>if let</code> actually stops being its own distinct thing at all, and now <code>let</code> is just allowed to exist inside of <code>if</code> conditional contexts</p>",
        "id": 246485421,
        "sender_full_name": "bstrie",
        "timestamp": 1626715651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> That was one proposal for how to handle if-let chains; another was that you still could only write chains of <code>let</code> and booleans inside an if.</p>",
        "id": 246485566,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715698
    },
    {
        "content": "<p>I personally prefer the latter, for simplicity and avoiding the \"surprise, I bound a variable inside this complex step\" problem.</p>",
        "id": 246485602,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that's part of what I was getting at earlier where I feel like let-else doesn't \"scale up\" as well as if-let does, which threatens to leave people in a no-man's-land where their code is slightly too complicated for let-else and slightly too simple for match</p>",
        "id": 246485612,
        "sender_full_name": "bstrie",
        "timestamp": 1626715721
    },
    {
        "content": "<p>I would expect let-else to scale up in the complexity of the binding, or the diverging expression. It just doesn't scale to 1) arbitrarily complex expr, in which case you might want to bind the expr to a name first and then let-else on it, or 2) wanting more than one pattern, for either the success or failure cases, in which case you should switch to a full match.</p>",
        "id": 246485900,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715844
    },
    {
        "content": "<p>I don't want to outright disallow the prospect of let-else-chains (I can imagine they'd be useful at times), but I agree that with the current prevailing syntax I think it would be fraught to allow them</p>",
        "id": 246485906,
        "sender_full_name": "bstrie",
        "timestamp": 1626715847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> I very much do want to outright disallow that; I think if you write <code>if let ... else { ... } { ... } else { ... }</code>, where the first <code>else</code> binds to the <code>let</code> and the second binds to the <code>if</code>, that turns into spaghetti very quickly and is almost never going to produce readable code.</p>",
        "id": 246486020,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715910
    },
    {
        "content": "<p>It's not just \"that will get unreadable fast\"; I think it's unlikely to ever be readable enough to be useful, outside of carefully formatted sample code.</p>",
        "id": 246486121,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626715955
    },
    {
        "content": "<p><a href=\"http://weird-exprs.rs\">weird-exprs.rs</a> demands sacrifices</p>",
        "id": 246486186,
        "sender_full_name": "The 8472",
        "timestamp": 1626715993
    },
    {
        "content": "<p>oh you're thinking about allowing let-else inside of if-let-chains, I definitely wouldn't allow that :P if-let-chains should only allow <code>let</code>, and <code>let else</code> is IMO a distinct construct from <code>let</code>, not some kind of subset/superset</p>",
        "id": 246486197,
        "sender_full_name": "bstrie",
        "timestamp": 1626716000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> Right. And I personally don't think let chains should exist outside of if-let or while-let, which means let-else never needs to combine with let chains. Were you <em>just</em> thinking of the case of let-chains outside of if-let and while-let?</p>",
        "id": 246486364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626716085
    },
    {
        "content": "<p>This is, for the record, one of the things we had in mind when stating that we need to consider let-else and let-chains together before stabilizing, because if we changed our plans on the latter then that would affect the former.</p>",
        "id": 246486559,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626716177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246485303\">said</a>:</p>\n<blockquote>\n<p>because let looks_like_an_infallible_pattern = multi-line expressions... SURPRISE ELSE ?</p>\n</blockquote>\n<p>I'm expecting that \"looks_like_an_infallible_pattern\" won't happen very often; it's absolutely possible but I'd expect it to be uncommon. I also expect hugely complex multi-line expressions to be better written as a separate statement, and I'm hoping that expr is <em>usually</em> simple, as it often is with <code>if let</code>. Given both of those things, I'm expecting that code that <em>wants</em> to be readable won't end up combining all three of <code>looks_like_an_infallible_pattern</code> and complex multi-line expressions and let-else.</p>",
        "id": 246487284,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626716524
    },
    {
        "content": "<p>yes, WRT \"chains\" I think we have this implicit notion of a short-circuiting conditional context that allows a <code>let</code> that either succeeds or it doesn't, and you can use that with <code>while</code> and <code>if</code>. So the <code>FOO</code> in <code>if FOO {</code> and <code>while FOO {</code> are this conditional context, where if you have a <code>let</code> in there then it introduces a binding into the following block. I envision a \"let-else-chains\" proposal to look like <code>let PAT = FOO else {</code>, where <code>FOO</code> is similarly such a conditional context except the first \"condition\" in the context has to be an expression and a successful pattern match there short-circuits the remainder of the conditional context.</p>",
        "id": 246487540,
        "sender_full_name": "bstrie",
        "timestamp": 1626716659
    },
    {
        "content": "<p>The first sentence there made perfect sense. The second sentence lost me.</p>",
        "id": 246487659,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626716733
    },
    {
        "content": "<p>What kind of chaining do you have in mind there?</p>",
        "id": 246487676,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626716743
    },
    {
        "content": "<p>Are you talking about let-else-else?</p>",
        "id": 246487681,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626716747
    },
    {
        "content": "<p>I'm extrapolating from if-let-chains, where you have <code>if let Some(x) = y &amp;&amp; a == b { // then do a thing with x</code>, you might also want to have <code>let Some(x) = y || a == b { // then diverge</code>. I don't think it's as useful as if-let-chains, certainly, since one of the advantages of if-let-chains is that you can refer to successful matches from earlier in the chain, whereas here we're guaranteed to have at least one unsuccessful match that we naturally can't use any binding from. However, it would be useful in collapsing multiple identical \"failure\" blocks into a single one. I don't think it would be the end of the world to not support it, but it might be a missed opportunity if it can be done elegantly</p>",
        "id": 246488310,
        "sender_full_name": "bstrie",
        "timestamp": 1626717027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246485303\">said</a>:</p>\n<blockquote>\n<p>because let looks_like_an_infallible_pattern = multi-line expressions... SURPRISE ELSE ?</p>\n</blockquote>\n<p>Also, this isn't really a \"surprise\". If you think the pattern is infallible and read on, it's not like you will be mislead: when you have those bindings the rest of the block applies as normal. When you see the <code>else</code> you know that there are other cases that have to be handled, like a <code>_ =&gt;</code> at the end of a match statement, but it doesn't require a revision to whatever you inferred about the \"main\" code path.</p>",
        "id": 246488845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626717251
    },
    {
        "content": "<p>As long as enum variants aren't proper types, I thought there was an RFC for it but it looks like that was closed.</p>",
        "id": 246489711,
        "sender_full_name": "The 8472",
        "timestamp": 1626717636
    },
    {
        "content": "<p>I'm not sure how that would interact with this</p>",
        "id": 246489992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626717741
    },
    {
        "content": "<p>we'll have infallible bindings on enums as soon as <code>!</code> is stabilized, as IMO the whole point of <code>!</code> is to allow things like <code>let Ok(x) = y;</code> (where <code>y: Result&lt;Foo, !&gt;</code>). But even then I don't expect it to ever be common to assume that an assignment from an enum variant is infallible, rather I expect people to assume the opposite unless something special is going on (such as <code>!</code>, or let-else).</p>",
        "id": 246490065,
        "sender_full_name": "bstrie",
        "timestamp": 1626717780
    },
    {
        "content": "<p>(and yes, cue the usual joke about when <code>!</code> will finally be stabilized, but it'll still happen before enum-variants-as-types :P )</p>",
        "id": 246490262,
        "sender_full_name": "bstrie",
        "timestamp": 1626717871
    },
    {
        "content": "<p>Also, the compiler will always help you get it right: it'll complain about <code>let Ok(x) = y;</code> if <code>y</code> is <code>Result&lt;T, E&gt;</code>, and it'll complain about <code>let Ok(x) = y else { ... };</code> if <code>y</code> is <code>Result&lt;T, !&gt;</code>.</p>",
        "id": 246491274,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626718303
    },
    {
        "content": "<p>Thoughts on <code>let? Some(x) = y else { return }</code>?</p>",
        "id": 246510963,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626727256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360405\">@Cameron Steffen</span> Seems pretty reasonable. The use of <code>?</code> as syntax there might confuse people slightly who are used to <code>?</code> meaning try, but in <em>general</em> the concept makes sense.</p>",
        "id": 246511227,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626727402
    },
    {
        "content": "<p>It certainly doesn't cause any of the problems I've seen with other proposals, and it meets all the criteria mentioned earlier. At this point, we're out of \"here's a fatal issue\" territory, and into \"that would not be my preference\" territory. :)</p>",
        "id": 246511338,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626727444
    },
    {
        "content": "<p>let-else combined with let-chains would be nice for cases like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"c1\">// ERROR - `x` does not live long enough</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246511387,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626727474
    },
    {
        "content": "<p>I think the only major issue with <code>let?</code>, apart from \"do we need to forecast the <code>else</code> at all\", is \"should we use <code>?</code> for that, is that confusing for people who know what <code>?</code> means\".</p>",
        "id": 246511405,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626727482
    },
    {
        "content": "<p>if you interpret it as fallible operation then it makes sense.</p>",
        "id": 246511606,
        "sender_full_name": "The 8472",
        "timestamp": 1626727573
    },
    {
        "content": "<p>Or it could be put behind the pattern instead of the let?</p>",
        "id": 246511654,
        "sender_full_name": "The 8472",
        "timestamp": 1626727594
    },
    {
        "content": "<p>(like I said on the issue) I think that would be solved by syntax highlighting. The <code>?</code> would not look like an operator, it is just part of the <code>let?</code> keyword.</p>",
        "id": 246511661,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626727598
    },
    {
        "content": "<p>*kinda solved</p>",
        "id": 246511721,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626727629
    },
    {
        "content": "<p>it lends to the description \"fallible let\" which is nice</p>",
        "id": 246511785,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626727664
    },
    {
        "content": "<p>otoh it's not really a property of the let but the assignment, you could have the same fallibility during a reassignment.</p>\n<p>So it should be on the pattern or the equals.</p>",
        "id": 246512988,
        "sender_full_name": "The 8472",
        "timestamp": 1626728239
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">?=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246513028,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728273
    },
    {
        "content": "<p>indeed</p>",
        "id": 246513094,
        "sender_full_name": "The 8472",
        "timestamp": 1626728292
    },
    {
        "content": "<p>it's like...\"test equals\"...too weird?</p>",
        "id": 246513184,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728358
    },
    {
        "content": "<p><code>let Some(x)? = y else { return };</code> move it one whitespace to the left or<br>\n<code>let Some(x) ? y : { return };</code> finally we have a ternary operator!</p>",
        "id": 246513472,
        "sender_full_name": "The 8472",
        "timestamp": 1626728442
    },
    {
        "content": "<p>except it's not like ternary. might be a problem that it looks like ternary.</p>",
        "id": 246513974,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728536
    },
    {
        "content": "<p>I like the <em>concept</em> of <code>?=</code> here.</p>",
        "id": 246514120,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728584
    },
    {
        "content": "<p>It has the downside that patterns and expressions look similar, and people are used to <code>?</code> after an expression meaning something different.</p>",
        "id": 246514248,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728621
    },
    {
        "content": "<p>yeah it's a nice concept because <code>=</code> usually means \"just assign\" with no condition</p>",
        "id": 246514317,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728642
    },
    {
        "content": "<p><code>let pat ?= expr else { diverge };</code> is the first alternative I've seen where my reaction is \"OK, I wouldn't be sad and disappointed if that's what we ended up with\".</p>",
        "id": 246514458,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728678
    },
    {
        "content": "<p>Fortunately <code>pat</code> cannot end in <code>?</code> right?</p>",
        "id": 246514573,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728713
    },
    {
        "content": "<p>At the moment no, but we'd have to commit to never wanting to use <code>?</code> for something in a patter, and I know we've had some thoughts on doing that.</p>",
        "id": 246514648,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728737
    },
    {
        "content": "<p>As an example, we've had proposals to use <code>for pat? in expr { ... }</code> instead of <code>for pat in expr { let pat = pat?; ... }</code></p>",
        "id": 246514819,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728774
    },
    {
        "content": "<p>yeah but no :)</p>",
        "id": 246514960,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728812
    },
    {
        "content": "<p>I'm not sure if that's the exact syntax we want, but the <em>concept</em> of \"iterate over things that might fail\" is useful.</p>",
        "id": 246514985,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728820
    },
    {
        "content": "<p>(Other proposals include <code>try for</code> or <code>for try</code>. But usually <code>try</code> is the keyword for \"stop propagation of <code>?</code>\" rather than \"start propagation\", with <code>?</code> being used to start propagation.)</p>",
        "id": 246515039,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626728836
    },
    {
        "content": "<p><code>for pat in expr { let pat = pat?; ... }</code> that's just while let else!</p>",
        "id": 246515379,
        "sender_full_name": "The 8472",
        "timestamp": 1626728924
    },
    {
        "content": "<p>Well now we're discussing another feature, but usually patterns don't <em>do</em> anything, and that shouldn't change IMO. I think try for could be solved with postfix macros somehow.</p>",
        "id": 246515400,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626728930
    },
    {
        "content": "<p>Possibly. I'm not entirely sure.</p>",
        "id": 246515698,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729009
    },
    {
        "content": "<p><code>for pat in expr.try_each!()</code></p>",
        "id": 246515746,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626729023
    },
    {
        "content": "<p>Sure. Or for that matter <code>expr.try_for!(|pat| { ... })</code>.</p>",
        "id": 246515882,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729067
    },
    {
        "content": "<p>But in any case, to keep it on topic, if we used <code>let pattern ?= expr else { ... }</code>, we'd have to commit to never giving <code>?</code> a meaning at the end of a pattern.</p>",
        "id": 246515908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729089
    },
    {
        "content": "<p>how about <code>=?</code> instead? then the pattern could still have a <code>?</code></p>",
        "id": 246516026,
        "sender_full_name": "The 8472",
        "timestamp": 1626729147
    },
    {
        "content": "<p><code>let pattern =? expr else { ... }</code> i guess if you want to keep <code>?</code> free for patterns <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 246516041,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1626729155
    },
    {
        "content": "<p>ah you got there before me lol</p>",
        "id": 246516047,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1626729159
    },
    {
        "content": "<p>I think that is a little more likely to be confused with <code>?</code> operator semantics.</p>",
        "id": 246516263,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626729267
    },
    {
        "content": "<p><code>=?</code> makes sense. <em>Slightly</em> less natural in my opinion, since <code>?=</code> reads like \"conditionally assign\", while <code>=?</code> reads like \"assign conditional\", but avoids future ambiguity.</p>",
        "id": 246516318,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729280
    },
    {
        "content": "<p>I think it's less likely we would give <code>?</code> a meaning at the <em>start</em> of an expr rather than the <em>end</em> of a pat.</p>",
        "id": 246516519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729328
    },
    {
        "content": "<p>I like <code>?=</code> a lot more. Can't really explain why. It seems quite unlikely to me we'd ever want <code>let Some(x)? =? y else</code>.</p>",
        "id": 246516887,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626729532
    },
    {
        "content": "<p>I like <code>?=</code> more as well; I think it'd come down to how much we want to reserve <code>pat?</code>.</p>",
        "id": 246516961,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729581
    },
    {
        "content": "<p>We even have the <em>option</em> of allowing both to work and requiring <code>pat? =</code> if you mean to attach the <code>?</code> to the <code>pat</code>, and <code>pat ?=</code> if you're writing let-else.</p>",
        "id": 246517142,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729660
    },
    {
        "content": "<p>But in any case, future compatibility can be decided later in the process, as long as the implications are documented.</p>",
        "id": 246517171,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729677
    },
    {
        "content": "<p>speaking purely from aesthetics I'm not extremely keen on just glomming together two sigils</p>",
        "id": 246517184,
        "sender_full_name": "bstrie",
        "timestamp": 1626729685
    },
    {
        "content": "<p>We already have operators like <code>+=</code></p>",
        "id": 246517270,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626729728
    },
    {
        "content": "<p>would it at least be generalizable to anything else? I see sigil syntax as having a higher conceptual cost than keyword syntax</p>",
        "id": 246517292,
        "sender_full_name": "bstrie",
        "timestamp": 1626729744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360405\">Cameron Steffen</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246517270\">said</a>:</p>\n<blockquote>\n<p>We already have operators like <code>+=</code></p>\n</blockquote>\n<p>We do, but that's a <em>downside</em>. That means one instinct might be to read <code>let x ?= expr ...</code> as <code>let x = x ? expr</code> (which doesn't mean anything, but...)</p>",
        "id": 246517345,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729772
    },
    {
        "content": "<p>the binary ternary operator, clearly :P</p>",
        "id": 246517375,
        "sender_full_name": "bstrie",
        "timestamp": 1626729792
    },
    {
        "content": "<p>I personally still prefer <code>let pat = expr else { diverge };</code>. I just find <code>let pat ?= expr else { diverge };</code> the least objectionable alternative syntax mentioned thus far.</p>",
        "id": 246517416,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729832
    },
    {
        "content": "<p>I don't think \"surprise else\" will turn out to be a problem in practice.</p>",
        "id": 246517484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729856
    },
    {
        "content": "<p>ship it.</p>",
        "id": 246517495,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626729867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360405\">Cameron Steffen</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246517495\">said</a>:</p>\n<blockquote>\n<p>ship it.</p>\n</blockquote>\n<p>Which one? :)</p>",
        "id": 246517520,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626729886
    },
    {
        "content": "<p>presumably <code>expr</code> will not be extremely long in practice, but it would be nice to have real-world examples</p>",
        "id": 246517542,
        "sender_full_name": "bstrie",
        "timestamp": 1626729902
    },
    {
        "content": "<p><code>let else</code>. Sorry, got impatient for a moment <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 246517571,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626729916
    },
    {
        "content": "<p>you can even pull examples from if let, since this feature and if let are basically the dual of each other. so what's the longest expression you've seen in an if let?</p>",
        "id": 246517594,
        "sender_full_name": "bstrie",
        "timestamp": 1626729935
    },
    {
        "content": "<p>Here's an example from my own code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">service</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">service</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">service</span><span class=\"p\">.</span><span class=\"n\">strip_prefix</span><span class=\"p\">(</span><span class=\"s\">\"git-\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">service</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">forbidden</span><span class=\"p\">(</span><span class=\"s\">\"Unsupported service\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This would become:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">service</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">service</span><span class=\"p\">.</span><span class=\"n\">strip_prefix</span><span class=\"p\">(</span><span class=\"s\">\"git-\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">forbidden</span><span class=\"p\">(</span><span class=\"s\">\"Unsupported service\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246517756,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626730029
    },
    {
        "content": "<p>and this is what I mean when I say this scales down very well, it looks quite nice to me. it's scaling it up that's a little tricky, but maybe I should just stop fretting about that</p>",
        "id": 246517993,
        "sender_full_name": "bstrie",
        "timestamp": 1626730167
    },
    {
        "content": "<p>I think we have many things that don't \"scale up\" in the way you're describing, and that's normal.</p>",
        "id": 246518056,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626730203
    },
    {
        "content": "<p>yes, I'm rather paranoid about accidentally closing off future avenues of development :)</p>",
        "id": 246518152,
        "sender_full_name": "bstrie",
        "timestamp": 1626730236
    },
    {
        "content": "<p>For instance, functions don't scale to arbitrary numbers of parameters; you need to introduce a struct.</p>",
        "id": 246518168,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626730245
    },
    {
        "content": "<p><code>if let</code> doesn't scale well to multiple patterns on the same expr, you should switch to <code>match</code>. (And on the other hand, it <em>does</em> scale well to doing things with <em>different</em> exprs.)</p>",
        "id": 246518243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626730286
    },
    {
        "content": "<p>With the lengthy discussion about syntax, I'd just like to let it be known that I've no issue with the syntax as-is. It is clean, readable, and unambiguous. Just putting it out there because \"nothing is wrong\" people like myself generally don't participate in discussions like this.</p>",
        "id": 246518438,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1626730406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> Huge appreciation for taking the time to avert that.</p>",
        "id": 246519725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626731265
    },
    {
        "content": "<p>If we're closing in on the current RFC, are there any action items before merging?</p>",
        "id": 246520175,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626731581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360405\">Cameron Steffen</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246520175\">said</a>:</p>\n<blockquote>\n<p>If we're closing in on the current RFC, are there any action items before merging?</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> is interested in making sure that the grammar is clear.</p>",
        "id": 246521540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626732523
    },
    {
        "content": "<p>That's the only thing that I think needs to be addressed, either by improving the RFC or by deciding it's precise enough for implementation work.</p>",
        "id": 246521824,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626732685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/245907347\">said</a>:</p>\n<blockquote>\n<p>I like the suggested change of <code>1. May not end with a `}` unless this brace is the terminating brace of a [`BlockExpression`][block-expr].</code>.</p>\n</blockquote>\n<p>Regarding the grammar question, if we're ditching the exception for blocks then this can be stated even more simply:</p>\n<div class=\"codehilite\"><pre><span></span><code>1. May not end with a `}`.\n</code></pre></div>\n<p>Restriction 2, about no lazy boolean ops at the top level, remains as is, and restriction 1 is not expressed through some convoluted <code>EXPRESSION-NOT-ENDING-IN-BRACE</code> nonterminal because that is not easy to read and not how it would be implemented anyway.</p>",
        "id": 246522619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626733236
    },
    {
        "content": "<p>It might be helpful to specify that restriction 1 applies after macro expansion by descending into the right child of prefix and infix operators, and failing if the first other expr constructor we find is a block-like expression. (Actually, the prose spec there probably needs an exception to handle invisible grouping, because <code>&lt;{ e }&gt;</code> is supposed to count as not ending in a brace even though the last physical token is <code>}</code>.)</p>",
        "id": 246523297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626733719
    },
    {
        "content": "<p>A macro call expression <code>foo!{bar}</code> can end in a brace as well. So I'm not sure if “after macro expansion” works too well for detecting this.</p>",
        "id": 246527928,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1626737400
    },
    {
        "content": "<p>I don't think that <code>macro!{ } else { }</code> is ever confusable though?</p>",
        "id": 246528809,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626738361
    },
    {
        "content": "<p>Also, this was a lot to catch up on. Uhh...</p>\n<ul>\n<li>In regards to if-let-chains, If we _really_ wanted interoperability there I think that extending <code>||</code> syntax would be better than let-else.</li>\n<li>In regards to <code>unless bool { ... }</code> I agree also that <code>if !x { ... }</code> doesn't read as easily as I'd hope but that seems a bit separate.</li>\n<li>I mention in the RFC that currently only <code>let</code> makes local bindings in scope, which people have brought up in regards to <code>unless let</code>.</li>\n<li>I hope we can just settle of disallowing the expression to end in <code>}</code> _before_ macro expansion and be done with it.</li>\n</ul>",
        "id": 246530210,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626739848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246530210\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I hope we can just settle of disallowing the expression to end in <code>}</code> _before_ macro expansion and be done with it.</li>\n</ul>\n</blockquote>\n<p>Sounds good, as long as the mechanism for disallowing ending in <code>}</code> is a lint that can be disabled, since it would be handy to be able to compile the output of <code>cargo expand</code> if a macro happened to expand to something ending in <code>}</code>. if it were a hard error the generated code would require manual editing to compile.</p>",
        "id": 246531562,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626741057
    },
    {
        "content": "<p>ah, that's already a problem with the post-macro expansion version I mentioned, because macros can introduce invisible grouping, and printing and re-parsing that would cause the grouping to go away, resulting in a bad expression. I think this issue is not limited to let-else</p>",
        "id": 246531796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626741347
    },
    {
        "content": "<p>...or not? <code>cargo expand</code> is smarter than I gave it credit for</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"cp\">$e</span>:<span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"cp\">$e</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{})</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// cargo expand</span>\n<span class=\"cp\">#![feature(prelude_import)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[prelude_import]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">prelude</span>::<span class=\"n\">rust_2018</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cp\">#[macro_use]</span><span class=\"w\"></span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{})</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246532057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626741633
    },
    {
        "content": "<p>I don't know what voodoo magic is being used to make this work, but maybe <code>let .. else</code> could borrow a bit of it to make it insert parentheses when needed</p>",
        "id": 246532082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626741712
    },
    {
        "content": "<p>cargo expand is smarter than expected :)</p>",
        "id": 246532148,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626741788
    },
    {
        "content": "<p>although, I can't compile the output of cargo expand anyway because of the first line</p>",
        "id": 246532258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626741960
    },
    {
        "content": "<p>just use <code>cargo +nightly</code> :)</p>",
        "id": 246535431,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626744620
    },
    {
        "content": "<p>the parenthesis are only added for pretty-printing IIUC</p>",
        "id": 246540358,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626750478
    },
    {
        "content": "<p>IMO <code>cargo-expand</code> should just be smart enough to put parenthesis there then...</p>",
        "id": 246613011,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626797469
    },
    {
        "content": "<p>Yeah, I think you can say that the <code>} else</code> restriction is pre-expansion and <code>macro! {} else</code> is fine.</p>",
        "id": 246644564,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626812658
    },
    {
        "content": "<p>Do you mean that <code>macro!() else</code> with the macro expanding to end in <code>}</code> is fine?</p>",
        "id": 246644642,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626812698
    },
    {
        "content": "<p>Or do you actually mean that <code>macro! {} else</code> should be fine too?</p>",
        "id": 246644671,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626812710
    },
    {
        "content": "<p>the latter</p>",
        "id": 246644721,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626812739
    },
    {
        "content": "<p>Why would that be fine? It clearly ends in a <code>}</code> pre-expansion</p>",
        "id": 246644847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626812793
    },
    {
        "content": "<p>Well I suppose it's debatable. I'd make it an exception in addition to blocks.</p>",
        "id": 246644905,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626812831
    },
    {
        "content": "<p>I think the latest is that the exception for blocks is dropped</p>",
        "id": 246644952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626812862
    },
    {
        "content": "<p>On that note...</p>",
        "id": 246645078,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626812917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> I'm currently gearing up to merge the RFC. However, if there's further grammar work you'd like to see happen before it gets merged, I'm happy to wait.</p>",
        "id": 246645127,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626812942
    },
    {
        "content": "<p>oh I didn't catch that</p>",
        "id": 246645236,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626812999
    },
    {
        "content": "<p>the rationale is that if you see <code>let .... &lt;many lines&gt; } else { .... };</code> you can know that it's actually an if statement</p>",
        "id": 246645377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626813056
    },
    {
        "content": "<p>the recommended style for blocks in let-else is e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">({</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">})</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246645678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626813198
    },
    {
        "content": "<p>Hm, I don't really like that, and I think indentation would be clear enough, but okay.</p>",
        "id": 246645832,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626813260
    },
    {
        "content": "<p>the point is that we <em>don't</em> want it to look just like an if-else</p>",
        "id": 246645869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626813280
    },
    {
        "content": "<p>Also, this is forward-compatible, in that if we discover during experimentation that this is onerous and people <em>want</em> braced blocks, that's easy enough to change.</p>",
        "id": 246645925,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626813307
    },
    {
        "content": "<p>fair enough</p>",
        "id": 246645946,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626813321
    },
    {
        "content": "<p>I think this also augurs for \"use this with simple exprs\".</p>",
        "id": 246646009,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626813349
    },
    {
        "content": "<p>If you're having to write <code>let pat = ({ complex block }) else { ... };</code>, I personally think the code will almost always be improved by:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">some_name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">complex</span><span class=\"w\"> </span><span class=\"n\">block</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pat</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_name</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246646153,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626813407
    },
    {
        "content": "<p>yep, I'm convinced!</p>",
        "id": 246646175,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626813425
    },
    {
        "content": "<p>I was imagining blocks would be somewhat common, but on second thought they shouldn't be</p>",
        "id": 246646371,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626813529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Yes, I am going to make that last change to specify that everything ending with a <code>}</code>. Hopefully today. I should have time.</p>",
        "id": 246647457,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626814114
    },
    {
        "content": "<p>Sounds great. Let me know when that's ready, and then I'll merge.</p>",
        "id": 246647585,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626814190
    },
    {
        "content": "<p>Do we need to coordinate with rustfmt?</p>",
        "id": 246648045,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626814410
    },
    {
        "content": "<p>I think we should. Not before merging, but we should coordinate.</p>",
        "id": 246650953,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815326
    },
    {
        "content": "<p>I think this <em>mostly</em> should follow existing formatting guidelines: break after <code>{</code> unless the whole thing fits on one line <em>and</em> isn't multiple statements.</p>",
        "id": 246651065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815367
    },
    {
        "content": "<p>But I think there's a useful distinction to be made there...</p>",
        "id": 246651134,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815393
    },
    {
        "content": "<p>The style guide says that a braced block can only go on one line if it's an expression rather than a statement.</p>",
        "id": 246651247,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815416
    },
    {
        "content": "<p>In general, these diverging blocks will often be <em>effectively</em> a statement, in that they don't produce a meaningful value. They may or may not end with a semicolon.</p>",
        "id": 246651286,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815432
    },
    {
        "content": "<p>Do we want to allow <code>let simple_pat = simple_expr else { return simple_value; };</code>?</p>",
        "id": 246651331,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815459
    },
    {
        "content": "<p>Or should we require that to use three lines (newline after <code>{</code> and after <code>return simple_value;</code>)?</p>",
        "id": 246651363,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815479
    },
    {
        "content": "<p>I personally think we should require three lines there.</p>",
        "id": 246651379,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815493
    },
    {
        "content": "<p>The same question applies to <code>yeet e;</code>, or <code>Err(e)?;</code> (assuming the compiler understands that to always diverge), or <code>panic!(\"...\");</code>.</p>",
        "id": 246651481,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815532
    },
    {
        "content": "<p>I <em>think</em> we want those to always get a line of their own, because control flow.</p>",
        "id": 246651503,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815541
    },
    {
        "content": "<p>Thoughts?</p>",
        "id": 246651519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626815548
    },
    {
        "content": "<p>what about suppressing the semicolon when used in one line style? It should never be needed since it's a diverging expression, and the back to back semicolons look weird.</p>",
        "id": 246657012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626818645
    },
    {
        "content": "<p>I'm strongly against requiring three lines for even simple let-else, but I don't use rustfmt for reasons like this anyway</p>",
        "id": 246657210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626818776
    },
    {
        "content": "<p>you don't need the semicolon after the <code>return</code>, you can omit it</p>",
        "id": 246657298,
        "sender_full_name": "bstrie",
        "timestamp": 1626818872
    },
    {
        "content": "<p>by which I mean you don't need it today. <code>fn main() { return () }</code> is valid</p>",
        "id": 246657363,
        "sender_full_name": "bstrie",
        "timestamp": 1626818897
    },
    {
        "content": "<p>I think a recent clippy lint has been encouraging semicolons everywhere</p>",
        "id": 246657377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626818908
    },
    {
        "content": "<p>I always omit the semicolon when I am allowed to, but reasonable minds can disagree</p>",
        "id": 246657422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626818952
    },
    {
        "content": "<p>I like the diverging expr to stay on the right side of the screen, out of the main control flow path. That's the reason I'm using let-else in the first place</p>",
        "id": 246657567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626819056
    },
    {
        "content": "<p>this is kind of a gray area... rustfmt will split <code>if let foo = bar { 1 } else { 2 }</code> onto multiple lines, but <code>let x = if let foo = bar { 1 } else { 2 };</code> remains on a single line</p>",
        "id": 246658043,
        "sender_full_name": "bstrie",
        "timestamp": 1626819478
    },
    {
        "content": "<p>IMO, whether to format this like <code>if</code> or like <code>let</code> should be consistent with whether we require a semicolon after the statement. no semicolon? treat it like <code>if</code>. semicolon? treat it like <code>let</code>. and I think there should be a semicolon after a let-else.</p>",
        "id": 246658173,
        "sender_full_name": "bstrie",
        "timestamp": 1626819570
    },
    {
        "content": "<p>but I don't really feel that strongly either way about the formatting</p>",
        "id": 246658827,
        "sender_full_name": "bstrie",
        "timestamp": 1626820121
    },
    {
        "content": "<p>I don't know how to write a good formatting heuristic for it.  But I definitely think that the simple cases like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">continue</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>ought not need multiple line.  Especially not</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">continue</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246659349,
        "sender_full_name": "scottmcm",
        "timestamp": 1626820563
    },
    {
        "content": "<p>I guess this is back to the \"does it need an introduction syntax?\" conversation again.</p>\n<p><code>guard let Some(x) = x else { continue }</code> doesn't need the </p>\n<blockquote>\n<p>I think we want those to always get a line of their own, because control flow.</p>\n</blockquote>\n<p>thing.</p>",
        "id": 246659441,
        "sender_full_name": "scottmcm",
        "timestamp": 1626820644
    },
    {
        "content": "<p>I don't follow, how are those related to the formatting question?</p>",
        "id": 246659477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626820681
    },
    {
        "content": "<p>Mostly unimportant: I also find the <code>};</code> awkward.</p>",
        "id": 246659521,
        "sender_full_name": "scottmcm",
        "timestamp": 1626820686
    },
    {
        "content": "<p>you already have that when doing <code>let foo = match/if { ... };</code></p>",
        "id": 246659574,
        "sender_full_name": "The 8472",
        "timestamp": 1626820753
    },
    {
        "content": "<p>For the length of expr problem, maybe a clippy lint could be added to say « you used let-else/guard-let and the expression is 3 lines, consider making an intermediate variable »</p>",
        "id": 246659585,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1626820762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246659477\">said</a>:</p>\n<blockquote>\n<p>I don't follow, how are those related to the formatting question?</p>\n</blockquote>\n<p>If the formatting is being used to call attention to the control flow, then I think that it might be an indication that the syntax should be calling attention to it instead.</p>",
        "id": 246659588,
        "sender_full_name": "scottmcm",
        "timestamp": 1626820773
    },
    {
        "content": "<p>but I want to not call attention to the control flow. I want it to be a let statement with an asterisk</p>",
        "id": 246659704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626820876
    },
    {
        "content": "<p>Especially with deep pattern matching, it's not unusual to have a whole bunch of these in a row. They should not need three lines each</p>",
        "id": 246659744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626820923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I have updated the RFC with wording which specifies that the expr must not end with a <code>}</code> before macro expansion.</p>\n<p>There is also a note about macro groups which I almost forgot but which I hope is reasonable. If that looks good, I'd like to be done with this stage haha.</p>",
        "id": 246661049,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626822024
    },
    {
        "content": "<p>nice work <span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> !</p>",
        "id": 246662845,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626823551
    },
    {
        "content": "<p>I would think semicolon forces a new line and no semicolon allows for one line</p>",
        "id": 246662988,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1626823675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.60let.20pattern.20.3D.20expr.20else.20.7B.20.2E.2E.2E.20.7D.60.20statements/near/246659349\">said</a>:</p>\n<blockquote>\n<p>I don't know how to write a good formatting heuristic for it.  But I definitely think that the simple cases like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">continue</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>ought not need multiple line.  Especially not</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">continue</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't think we want the latter in any case; I think if that needs multiple lines then it should look like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">continue</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246664634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626825307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> Any objections if I fix a couple of typos when merging? (<code>parenthesis</code> -&gt; <code>parentheses</code> when talking about a pair of them.)</p>",
        "id": 246668843,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626829542
    },
    {
        "content": "<p>Please go ahead</p>",
        "id": 246669552,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626830299
    },
    {
        "content": "<p>RFC 3137, let-else statements, has been merged! Thanks to everyone involved with the RFC. And thanks to <span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> for putting so much effort into incorporating feedback, alternatives, unresolved questions, and other content from the GitHub and Zulip threads to make the RFC self-contained.</p>\n<p>Tracking issue: <a href=\"https://github.com/rust-lang/rust/issues/87335\">rust-lang/rust#87335</a></p>",
        "id": 246671485,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626832487
    },
    {
        "content": "<p>WRT \"calling out the control flow\", I don't think <code>let foo = bar_bar_bar() else { return };</code> inherently necessitates any more calling out than <code>let foo = bar?;</code></p>",
        "id": 246733295,
        "sender_full_name": "bstrie",
        "timestamp": 1626880092
    },
    {
        "content": "<p>I encountered a \"valid early output &amp; return if None\" situation today in real world code, which can't be easily handled by e.g. <code>ok_or_else</code> (no error) and where the \"if\" would be literally 200 lines long, so I am pretty happy the RFC moved forward. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 246895500,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626982912
    },
    {
        "content": "<p>Nice. What would the <code>let else</code> look like from that code? Can you paste it?</p>",
        "id": 246897078,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626983701
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">task_id</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"p\">.</span><span class=\"n\">task_id</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">task_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">task_id</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// update 'thing' in the database</span>\n<span class=\"w\">        </span><span class=\"n\">Something</span>::<span class=\"n\">whatever</span>::<span class=\"n\">adjust</span><span class=\"p\">(</span><span class=\"n\">thing</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">!</span><span class=\"p\">({</span><span class=\"w\"> </span><span class=\"s\">\"adjusted_thing_id\"</span>: <span class=\"nc\">thing</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Becoming:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">task_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"p\">.</span><span class=\"n\">task_id</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// update 'thing' in the database</span>\n<span class=\"w\">    </span><span class=\"n\">Something</span>::<span class=\"n\">whatever</span>::<span class=\"n\">adjust</span><span class=\"p\">(</span><span class=\"n\">thing</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">!</span><span class=\"p\">({</span><span class=\"w\"> </span><span class=\"s\">\"adjusted_thing_id\"</span>: <span class=\"nc\">thing</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}));</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247224951,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1627316082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> Awesome.</p>",
        "id": 247226227,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627316681
    },
    {
        "content": "<p>just stopping by to say this looks dreamy :). big fan, thanks to everyone that contributed</p>",
        "id": 247475140,
        "sender_full_name": "Chaz Kiker",
        "timestamp": 1627486514
    }
]