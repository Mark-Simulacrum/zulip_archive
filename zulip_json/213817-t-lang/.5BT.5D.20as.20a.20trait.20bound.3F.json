[
    {
        "content": "<p>I saw a twitter thread awhile ago which noted that <code>[T]</code> is conceptually almost the same as a trait which is implemented by all fixed-size arrays, but that it's not actually a trait for historical reasons relating to const generics.</p>\n<p>Has there been any discussion about making <code>[T]</code> a trait, or more like a trait? The specific use case I had today was having a trait bound that ensures some associated type is a fixed-size array of some size. Currently, the workaround is to create my own sealed <code>Array</code> trait and implement it for arrays, but that's kind of messy and not good for future-compatibility. It would be great to be able to just say <code>type Foo: [u8];</code>.</p>",
        "id": 259043013,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635213485
    },
    {
        "content": "<p>Of course, with const generics one can do this, but it requires having <code>N</code> be a type parameter rather than having an existential bound.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Foo</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 259043636,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635214083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"392468\">Teddy Katz</span> <a href=\"#narrow/stream/213817-t-lang/topic/.5BT.5D.20as.20a.20trait.20bound.3F/near/259043013\">said</a>:</p>\n<blockquote>\n<p>Currently, the workaround is to create my own sealed <code>Array</code> trait and implement it for arrays, but that's kind of messy and not good for future-compatibility.</p>\n</blockquote>\n<p>Why is it bad for future compatibility?</p>",
        "id": 259043779,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635214223
    },
    {
        "content": "<p>We sort of have this today in nightly:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">A</span>: <span class=\"nc\">Unsize</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">A</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Use a</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 259043952,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635214438
    },
    {
        "content": "<blockquote>\n<p>Why is it bad for future compatibility?</p>\n</blockquote>\n<ul>\n<li>If the standard library adds new traits impls for arrays, then anyone using the custom <code>Array</code> trait can't take advantage of those traits until the maintainer of the <code>Array</code> trait adds the new impl as a type bound. Sometimes, the maintainer of the <code>Array</code> trait won't be able to do this if the new trait is unstable. (This is already sort of an issue with <code>Unsize</code> and <code>CoerceUnsized</code>.)</li>\n<li>Suppose I have a function with an <code>Array&lt;T&gt;</code> trait bound, and I call another function in a crate with an <code>Array&lt;T&gt;</code> trait bound. If it becomes possible to use <code>[T]</code> as a trait bound directly in the future, I wouldn't be able to switch to this until my dependency crate does, because the compiler would think that <code>Array&lt;T&gt;</code> is a stricter trait bound than <code>[T]</code> (even though they are implemented for the same set of types)</li>\n</ul>",
        "id": 259044189,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635214654
    },
    {
        "content": "<p><code>Unsize</code> would sort of work, but my understanding is that that's not really the intended usage of that feature, and based on <a href=\"https://github.com/rust-lang/rust/issues/27732#issuecomment-480073837\">https://github.com/rust-lang/rust/issues/27732#issuecomment-480073837</a> it seems like <code>Unsize</code> is intended to be permanently unstable.</p>",
        "id": 259044290,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635214748
    },
    {
        "content": "<p>Hmm, why do you need to be generic over a type instead of using const generics directly?</p>",
        "id": 259044532,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635214957
    },
    {
        "content": "<p>The specific use case is specifying an interface for a cryptographic hash algorithm, where each type implementing the trait needs a fixed-size array of a different length. Simplified code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">HashAlgorithm</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">StateVector</span>: <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// &lt;-- this doesn't work, but it would be nice if it did</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">HashAlgorithm</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Sha1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">StateVector</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">HashAlgorithm</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Sha256</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">StateVector</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">hash_something</span><span class=\"o\">&lt;</span><span class=\"n\">H</span>: <span class=\"nc\">HashAlgorithm</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Parametrizing <code>HashAlgorithm</code> to <code>HashAlgorithm&lt;8&gt;</code> and <code>HashAlgorithm&lt;5&gt;</code> wouldn't work because that would prevent using <code>HashAlgorithm</code> generically.</p>\n<p>Another solution would be to add an associated const to <code>HashAlgorithm</code>, and then specify that <code>StateVector</code> has a length equal to that const. Currently, that doesn't work on stable due to <a href=\"https://github.com/rust-lang/rust/issues/60551\">https://github.com/rust-lang/rust/issues/60551</a>, but that aside, it's adding a small amount of additional API surface to the trait beyond what's actually needed.</p>",
        "id": 259045594,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635216191
    },
    {
        "content": "<p>Yeah, unfortunate that associated consts won't work</p>",
        "id": 259047163,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635217948
    },
    {
        "content": "<p>It doesn't seem necessary to me that the StateVector needs to be arrays though.</p>",
        "id": 259047172,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635217956
    },
    {
        "content": "<p>Could you clarify what the proposed alternative is? I mean, sure, it doesn't <em>need</em> to be an array in the strictest sense and other API designs would also be possible, but the various alternatives (say, using a <code>Vec</code>) seem worse for various reasons.</p>",
        "id": 259047830,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635218715
    },
    {
        "content": "<p>You don't need to bound them as arrays.</p>",
        "id": 259047919,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635218803
    },
    {
        "content": "<p>I don't think <code>hash_something</code> can manipulate this array in a hash-algorithm-independent way.</p>",
        "id": 259047950,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635218853
    },
    {
        "content": "<p>Thanks for clarifying. I think that's an artifact of me simplifying the example too much. To unroll the simplification one step, suppose <code>hash_something</code> is replaced with this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">hash_is_similar_to</span><span class=\"o\">&lt;</span><span class=\"n\">H</span>: <span class=\"nc\">HashAlgorithm</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">data</span>: <span class=\"nc\">SomeInput</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"nc\">H</span>::<span class=\"n\">StateVector</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Having <code>H::StateVector</code> be a fixed-size array is useful here because it gives a compile-time guarantee that the values will be the same length, and also allows monomorphization for small lengths to e.g. unroll loops fully.</p>",
        "id": 259048603,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1635219656
    },
    {
        "content": "<p>This has come up before as some kind of a generalization of a \"flatten\" method like <code>&amp;[[T;N]]</code> -&gt; <code>&amp;[T]</code>.  That gets into whether it really means <em>array</em>, or whether it means <em>with array-like layout</em>.  For example, a <code>#[repr(C)] struct Color(u8, u8, u8);</code> might want to be <code>unsafe</code>ly considered \"array-like enough to work in that\", but it's unclear that that should also get all the methods that arrays do.  It could be considered an advantage for it to <em>not</em> support <code>binary_search</code>, for example.</p>",
        "id": 259058576,
        "sender_full_name": "scottmcm",
        "timestamp": 1635231814
    },
    {
        "content": "<p>I'm not sure exactly what you expect to do with the associated type generically, but <code>Copy+AsRef&lt;[u8]&gt;</code> might cover quite a bit of that.</p>\n<p>And if you really want arrays specifically, there's always</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">hash_is_similar_to</span><span class=\"o\">&lt;</span><span class=\"n\">H</span>: <span class=\"nc\">HashAlgorithm</span><span class=\"o\">&lt;</span><span class=\"n\">StateVector</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 259058818,
        "sender_full_name": "scottmcm",
        "timestamp": 1635232038
    }
]