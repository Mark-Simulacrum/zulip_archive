[
    {
        "content": "<p>Is it weird that <code>size_of::&lt;!&gt;()</code> is 0? It just occurs to me that size_of normally can't be called on types that aren't Sized, and I think(?) that <code>!</code> isn't Sized, and yet as the bottom type I'm not sure if it makes sense to exclude it from anything? I can't think of any concrete risk, I'm just being wary.</p>",
        "id": 245624420,
        "sender_full_name": "bstrie",
        "timestamp": 1626034468
    },
    {
        "content": "<p><code>!: Sized</code> is satisfied.</p>",
        "id": 245624566,
        "sender_full_name": "bjorn3",
        "timestamp": 1626034696
    },
    {
        "content": "<p>An empty type can even have a non-zero size I think. Eg <code>struct Foo([u8; 16], !)</code> is 16 bytes I think.</p>",
        "id": 245624581,
        "sender_full_name": "bjorn3",
        "timestamp": 1626034750
    },
    {
        "content": "<p>Ah, good point. Is <code>!: Sized</code> because it actually implements Sized, or is it because as the bottom type it implicitly satisfies everything? I don't see the usual blanket impls that I would expect on Sized types, e.g. the docs don't show the <code>impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for T</code>. But I guess I also don't understand why <code>!</code> has to have explicit implementations for <code>Clone</code>, <code>Display</code>, etc</p>",
        "id": 245624859,
        "sender_full_name": "bstrie",
        "timestamp": 1626035171
    },
    {
        "content": "<p>Sized is an auto trait, so <code>!</code> doesn't need to explicitly implement it.</p>",
        "id": 245625441,
        "sender_full_name": "bjorn3",
        "timestamp": 1626036058
    },
    {
        "content": "<p>There were proposals to make size_of::&lt;!&gt; a negative infinity, represented in whatever way, at some point.</p>",
        "id": 245625448,
        "sender_full_name": "nagisa",
        "timestamp": 1626036094
    },
    {
        "content": "<p>that'd be a good april fools day RFC, change size_of to return a float :)</p>",
        "id": 245625504,
        "sender_full_name": "bstrie",
        "timestamp": 1626036142
    },
    {
        "content": "<p>the thing is, whether ! is Sized or not doesn't really matter all that much</p>",
        "id": 245625569,
        "sender_full_name": "nagisa",
        "timestamp": 1626036255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/245625441\">said</a>:</p>\n<blockquote>\n<p>Sized is an auto trait, so <code>!</code> doesn't need to explicitly implement it.</p>\n</blockquote>\n<p>I think it's something even more magical than an auto trait, Unpin is defined as <code>pub auto trait Unpin</code> but Sized is just <code>pub trait Sized</code></p>",
        "id": 245625595,
        "sender_full_name": "bstrie",
        "timestamp": 1626036302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/245625569\">said</a>:</p>\n<blockquote>\n<p>the thing is, whether ! is Sized or not doesn't really matter all that much</p>\n</blockquote>\n<p>Wouldn't it matter for things like <code>Result&lt;u32, !&gt;</code>? If it wasn't sized the enum here wouldn't be sized either which means you couldn't pass it by value right?</p>",
        "id": 245625619,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1626036345
    },
    {
        "content": "<p><code>!</code> works on a different layer than sizes: an uninhabited type can have a size but all bit patterns of that size are invalid for that type.</p>",
        "id": 245625670,
        "sender_full_name": "Amanieu",
        "timestamp": 1626036400
    },
    {
        "content": "<p>On one hand yeah, on the other you could argue that since the variants with <code>!</code> aren't constructible, they shouldn't be considered for the purposes of determining the containers' sizedness.</p>",
        "id": 245625677,
        "sender_full_name": "nagisa",
        "timestamp": 1626036414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300586\">@Lukas Wirth</span> Enums with unsized fields aren't even allowed at all.</p>",
        "id": 245625692,
        "sender_full_name": "bjorn3",
        "timestamp": 1626036441
    },
    {
        "content": "<p>but all things considered <code>!: Sized</code> makes things overall significantly less hacky, probably?</p>",
        "id": 245625693,
        "sender_full_name": "nagisa",
        "timestamp": 1626036442
    },
    {
        "content": "<p><code>!</code>  should be as unsurprising as possible: it should be identical to <code>()</code> in every way except that it has no valid values instead of just one.</p>",
        "id": 245625742,
        "sender_full_name": "Amanieu",
        "timestamp": 1626036491
    },
    {
        "content": "<p>So <code>!</code> would be <code>Sized</code> and <code>Copy</code>, and it wouldn't matter since you'd never get around to creating a value to copy.</p>",
        "id": 245625751,
        "sender_full_name": "Amanieu",
        "timestamp": 1626036523
    },
    {
        "content": "<p><code>MaybeUninit&lt;!&gt;</code> exists and has size 0 (It can store a single value, <code>MaybeUninit::uninit()</code>, though you could argue that <code>MaybeUnini::zeroed()</code> is distinct). Because <code>MaybeUninit&lt;T&gt;</code> has the same size and alignment as <code>T</code>, then <code>!</code> must also have size 0.</p>",
        "id": 245629847,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626041526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/245624581\">said</a>:</p>\n<blockquote>\n<p>An empty type can even have a non-zero size I think. Eg <code>struct Foo([u8; 16], !)</code> is 16 bytes I think.</p>\n</blockquote>\n<p>See also <a href=\"https://github.com/rust-lang/rust/issues/54987\">https://github.com/rust-lang/rust/issues/54987</a> for why it really needs to be nonzero size. The <code>!</code> type really needs to be a regular ZST, not a magic negative infinity size type that ZSTs anything it is tupled with, because of partial initialization. It's not a slam dunk argument because this is not allowed today and I don't know whether it will become safe in the future:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But especially for generic code, one really would like this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(never_type)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">()).</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span>::<span class=\"o\">&lt;!&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245646157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626066911
    },
    {
        "content": "<p>It seems reasonable enough to me (a bystander) that something which can't be represented in actuality has a size of 0.</p>",
        "id": 245720271,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1626111457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/245646157\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/245624581\">said</a>:</p>\n<blockquote>\n<p>An empty type can even have a non-zero size I think. Eg <code>struct Foo([u8; 16], !)</code> is 16 bytes I think.</p>\n</blockquote>\n<p>See also <a href=\"https://github.com/rust-lang/rust/issues/54987\">https://github.com/rust-lang/rust/issues/54987</a> for why it really needs to be nonzero size. The <code>!</code> type really needs to be a regular ZST, not a magic negative infinity size type that ZSTs anything it is tupled with, because of partial initialization. It's not a slam dunk argument because this is not allowed today and I don't know whether it will become safe in the future:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But especially for generic code, one really would like this to work:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(never_type)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">()).</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span>::<span class=\"o\">&lt;!&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Allowing these kinds of shenanigans seems incredibly dangerous. For example, I might be tempted to then add this snipped to the end of your function:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// cool, `x` is completely initalized</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264104953,
        "sender_full_name": "Jake",
        "timestamp": 1638931857
    },
    {
        "content": "<p>(is necro-posting frowned upon? Apologies if so)</p>",
        "id": 264104965,
        "sender_full_name": "Jake",
        "timestamp": 1638931875
    },
    {
        "content": "<p>Although this isn't really restricted to that example, <code>size_of::&lt;!&gt;()</code> returning <code>0</code> means that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>might be UB, which is sort of an issue on its own</p>",
        "id": 264105130,
        "sender_full_name": "Jake",
        "timestamp": 1638932044
    },
    {
        "content": "<p>Right, and that's been the case on stable for a long time.</p>\n<p>And even for inhabited ZSTs where it's <em>valid</em> to summon them from nothing, it can still be a violation of a <em>safety</em> invariant.</p>",
        "id": 264105205,
        "sender_full_name": "scottmcm",
        "timestamp": 1638932138
    },
    {
        "content": "<p>Fair</p>",
        "id": 264105218,
        "sender_full_name": "Jake",
        "timestamp": 1638932159
    },
    {
        "content": "<p>That being said, I would like to argue that <code>Foo</code> in the example should actually be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MayebUninit</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>in which case we wouldnt have an issue here</p>",
        "id": 264105393,
        "sender_full_name": "Jake",
        "timestamp": 1638932317
    },
    {
        "content": "<p>There's even some monomorphization-time checks to help catch the uninhabited-ZST mistake: <a href=\"https://rust.godbolt.org/z/zxqPczb7r\">https://rust.godbolt.org/z/zxqPczb7r</a></p>",
        "id": 264105422,
        "sender_full_name": "scottmcm",
        "timestamp": 1638932360
    },
    {
        "content": "<p>If the safe version of things is desirable then I suppose this might be necessary, although partially initalizing a completely uninhabited value sounds like a very weird semantic to me</p>",
        "id": 264105568,
        "sender_full_name": "Jake",
        "timestamp": 1638932430
    },
    {
        "content": "<p>Yeah, this is probably already stable through <code>MaybeUninit</code></p>",
        "id": 264107515,
        "sender_full_name": "Jake",
        "timestamp": 1638934276
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>type DefinitelyUninit = MaybeUninit&lt;!&gt;;\n</code></pre></div>",
        "id": 264107655,
        "sender_full_name": "cuviper",
        "timestamp": 1638934414
    },
    {
        "content": "<p>Could there be a new <code>size_of</code> function, say, <code>size_of_inhabited</code> which would return an <code>Option&lt;usize&gt;</code> (or <code>enum Size { Inhabited(usize), Uninhabited }</code> or w/e). Since obviously we can't change <code>size_of</code>, but having a way to know if a type is inhabited or not could be desirable (<em>e.g.</em>, a way to stabilize <code>intrinsics::assert_inhabited</code> of sorts):</p>\n<p>right now in non-<code>const</code> context one could do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">size_of_inhabited</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">panic</span>::<span class=\"n\">catch_unwind</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()).</span><span class=\"n\">ok</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264142357,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638962962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264105393\">said</a>:</p>\n<blockquote>\n<p>That being said, I would like to argue that <code>Foo</code> in the example should actually be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MayebUninit</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>in which case we wouldnt have an issue here</p>\n</blockquote>\n<p>I believe that <code>MaybeUninit</code> not being structural (transitive with field {un,}projection) is deemed too big of a footgun to ever feature it, no matter how much it would simplify things elsewhere (IIRC, for instance, it's also the reason <code>&amp;!</code> can't/shouldn't be uninhabited).</p>",
        "id": 264142359,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638962965
    },
    {
        "content": "<p>Interesting discussion.. I never knew that e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Void</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Void</span><span class=\"p\">)</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>produces a size of <code>8</code> (so two times size of <code>u32</code>)! (I would’ve liked/expected to get <code>0</code> size instead, like for <code>Result&lt;(), Void&gt;</code>) <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> would your opinion be that it <em>has</em> to stay this way? Or are you only concerned with structs, not with enums?</p>",
        "id": 264163432,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1638974228
    },
    {
        "content": "<p>In addition/instead of <code>size_of_inhabited</code> we could expose a function that would say if the type is inhabited or not:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"rust-intrinsic\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_inhabited</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With this <code>assert_inhabited</code> and <code>size_of_inhabited</code> could be implemented in libs without hacks</p>",
        "id": 264163627,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638974309
    },
    {
        "content": "<p>I'm actually regurgitating some opinions of <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> here, so they might have more to say on the matter, but I can definitely see that it's difficult to argue for the soundness of a partially initialized value which has non-ZST data in it even though it somehow takes up zero space on stack. In the case of an enum, I think it is conceivable to insist that the <code>Err</code> variant in that example is not constructible, although it has some unusual consequences: If <code>Result&lt;(), (u32, Void)&gt;</code> has zero size but <code>(u32, Void)</code> has size 4, then what is the relative address of the pointer into the <code>Err</code> variant?</p>",
        "id": 264164152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638974552
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"273349\">@Waffle Lapkin</span> that it would make more sense to have a separate <code>is_inhabited</code> function here, rather than mixing it with <code>size_of</code>, because (especially with that <code>Result&lt;(), (u32, Void)&gt;</code> layout optimization) we want to be able to say that <code>(u32, Void)</code> is an uninhabited type with size 4</p>",
        "id": 264164648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638974773
    },
    {
        "content": "<blockquote>\n<p>If <code>Result&lt;(), (u32, Void)&gt;</code> has zero size but <code>(u32, Void)</code> has size 4, then what is the relative address of the pointer into the <code>Err</code> variant?</p>\n</blockquote>\n<p>Is there a sound way to obtain this relative address of the <code>Err</code>’s field (for an enum, not a struct)? If not, maybe this question doesn’t even need an answer?</p>",
        "id": 264164763,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1638974828
    },
    {
        "content": "<p>At the very least, I think the UCG layout document needs some rewriting, since I recall there being some picture where an enum's variant fields were contained in the enum's data layout</p>",
        "id": 264164943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638974897
    },
    {
        "content": "<p>But I don't see any immediate problems with such a design</p>",
        "id": 264165041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638974940
    },
    {
        "content": "<p>it potentially conflicts with a layout API that allows you to ask questions like \"what is the offset of this field on this enum\" directly</p>",
        "id": 264165343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638975067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264164648\">said</a>:</p>\n<blockquote>\n<p>I agree with <span class=\"user-mention silent\" data-user-id=\"273349\">Waffle Lapkin</span> that it would make more sense to have a separate <code>is_inhabited</code> function here, rather than mixing it with <code>size_of</code>, because (especially with that <code>Result&lt;(), (u32, Void)&gt;</code> layout optimization) we want to be able to say that <code>(u32, Void)</code> is an uninhabited type with size 4</p>\n</blockquote>\n<p>Yep, my bad there, I totally fell into the trap of thinking uninhabited =&gt; ZST <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> A separate <code>bool</code> makes most sense</p>",
        "id": 264168311,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638976249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264105130\">said</a>:</p>\n<blockquote>\n<p>Although this isn't really restricted to that example, <code>size_of::&lt;!&gt;()</code> returning <code>0</code> means that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>might be UB, which is sort of an issue on its own</p>\n</blockquote>\n<p>its not an issue, it is perfectly expected IMO. why would all ZST be inhabited?</p>",
        "id": 264170637,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264105422\">said</a>:</p>\n<blockquote>\n<p>There's even some monomorphization-time checks to help catch the uninhabited-ZST mistake: <a href=\"https://rust.godbolt.org/z/zxqPczb7r\">https://rust.godbolt.org/z/zxqPczb7r</a></p>\n</blockquote>\n<p>btw I recently wondered if we should do something similar for <code>transmute</code>? we could adjust its codegen so that if the target type is uninhabited, it panics instead of causing UB</p>",
        "id": 264170774,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977134
    },
    {
        "content": "<blockquote>\n<p>right now in non-const context one could do:</p>\n</blockquote>\n<p>oh god please don't do that.^^ there is no <em>guarantee</em> that <code>assume_init</code> will ever panic. this code is causing library UB and if someone seriously proposes this I will regret ever having added those panics.</p>",
        "id": 264171234,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977309
    },
    {
        "content": "<p>there is extremely little one can do with a type just because it is inhabited (as was noted above, it can still have arbitrary <em>safety</em> invariants), so I dont think I understand the motivation for having such a test on a type.</p>",
        "id": 264171388,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977369
    },
    {
        "content": "<p>while knowing that a type is inhabited doesn't say much, being <em>un</em>inhabited is useful information, especially if it comes up in layout calculations. User code might want to interact with that</p>",
        "id": 264171695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638977446
    },
    {
        "content": "<blockquote>\n<p>I believe that MaybeUninit not being structural (transitive with field {un,}projection) is deemed too big of a footgun to ever feature it, no matter how much it would simplify things elsewhere (IIRC, for instance, it's also the reason &amp;! can't/shouldn't be uninhabited).</p>\n</blockquote>\n<p>I don't quite follow; actually my current working draft of reference validity does make <code>&amp;!</code> uninhabited. (I think of this as <code>!</code> having an impossible-to-satisfy alignment requirement, so <code>&amp;!</code> can never be properly aligned, and so it is uninhabited. the key point is that validity of <code>&amp;T</code> never depends on the bytes stored in memory, it only depends on the pointer value and on <code>T</code>'s alignment.)</p>",
        "id": 264171966,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977535
    },
    {
        "content": "<p>I was actually thinking that \"inhabited\" isn't a great word for this concept since it doesn't match the meaning of \"inhabited\" from type theory. It's closer to \"possibly not uninhabited\"</p>",
        "id": 264172006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638977554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264171695\">said</a>:</p>\n<blockquote>\n<p>while knowing that a type is inhabited doesn't say much, being <em>un</em>inhabited is useful information, especially if it comes up in layout calculations. User code might want to interact with that</p>\n</blockquote>\n<p>it would probably be wrong most of the time though, since people would just repeat the mistake of making <code>(i32, !)</code> a ZST since it has an uninhabited field...</p>",
        "id": 264172075,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264172006\">said</a>:</p>\n<blockquote>\n<p>I was actually thinking that \"inhabited\" isn't a great word for this concept since it doesn't match the meaning of \"inhabited\" from type theory. It's closer to \"possibly not uninhabited\"</p>\n</blockquote>\n<p>well, we have two invariants and thus two notions of inhabited: 'validly inhabited' and 'safely inhabited'</p>",
        "id": 264172119,
        "sender_full_name": "RalfJ",
        "timestamp": 1638977601
    },
    {
        "content": "<p>I suppose that we could conceivably define \"validly inhabited\" such that it is a decidable property, but really only one direction is relevant: if it is not inhabited according to rust then it definitely can't be instantiated, but the converse may not hold</p>",
        "id": 264172382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638977681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264172075\">said</a>:</p>\n<blockquote>\n<p>it would probably be wrong most of the time though, since people would just repeat the mistake of making <code>(i32, !)</code> a ZST since it has an uninhabited field...</p>\n</blockquote>\n<p>Why is this a mistake? I think I've missed something <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 264173262,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638977985
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/49298\">#49298</a> I guess</p>",
        "id": 264174465,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1638978443
    },
    {
        "content": "<p>Oh</p>\n<p>Thanks!</p>",
        "id": 264176279,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638979116
    }
]