[
    {
        "content": "<p>withoutboats (are they on zulip?) asked on the const generics tracking issue:</p>\n<blockquote>\n<p>Is there a subset of const generics that doesn't hit lazy normalization and doesn't have many bugs and papercuts, but which can express a good amount of useful code? I notice that std's impls of many traits for arrays seem to work just fine. Maybe there's a narrowing that would allow other crates to write the kind of impls we have in std for their own traits, even though they don't support all the fancier functionality?</p>\n</blockquote>",
        "id": 202925130,
        "sender_full_name": "lcnr",
        "timestamp": 1593961487
    },
    {
        "content": "<p>Considering that this issue is corrently locked and should imo mostly be used for updates I wanted to move this to here for now (or a new issue on github <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> don't really care).</p>",
        "id": 202925187,
        "sender_full_name": "lcnr",
        "timestamp": 1593961584
    },
    {
        "content": "<p>So I think that const generics with the following limitations should be fairly bug free and hopefully won't change much from now on:</p>",
        "id": 202925208,
        "sender_full_name": "lcnr",
        "timestamp": 1593961646
    },
    {
        "content": "<ul>\n<li>only integer params, e.g. <code>const N: usize</code> and <code>const M: u8</code></li>\n</ul>",
        "id": 202925260,
        "sender_full_name": "lcnr",
        "timestamp": 1593961685
    },
    {
        "content": "<ul>\n<li>no where bounds</li>\n</ul>",
        "id": 202925263,
        "sender_full_name": "lcnr",
        "timestamp": 1593961688
    },
    {
        "content": "<ul>\n<li>only constants and params as generic arguments, i.e. we still forbid <code>[u8; size_of::&lt;T&gt;()]</code> and <code>[u8; N + 1]</code>.</li>\n</ul>",
        "id": 202925365,
        "sender_full_name": "lcnr",
        "timestamp": 1593961859
    },
    {
        "content": "<p>Before this is usable we need to first land a replacement for <a href=\"https://github.com/rust-lang/rust/pull/71154\">https://github.com/rust-lang/rust/pull/71154</a> though, so if that doesn't introduce a lot more bugs I believe it should be fairly save to slowly consider getting the above subset to stable</p>",
        "id": 202925433,
        "sender_full_name": "lcnr",
        "timestamp": 1593961931
    },
    {
        "content": "<p>As always, I might be missing something here, so cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> who probably have some more concerns.</p>",
        "id": 202925450,
        "sender_full_name": "lcnr",
        "timestamp": 1593961984
    },
    {
        "content": "<p>I think on Zulip they're <span class=\"user-mention\" data-user-id=\"256759\">@boats</span>? I could be wrong though</p>",
        "id": 202925520,
        "sender_full_name": "eddyb",
        "timestamp": 1593962113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/202925365\">said</a>:</p>\n<blockquote>\n<ul>\n<li>only constants and params as generic arguments, i.e. we still forbid <code>[u8; size_of::&lt;T&gt;()]</code> and <code>[u8; N + 1]</code>.</li>\n</ul>\n</blockquote>\n<p>this is the sad one for me</p>",
        "id": 202925533,
        "sender_full_name": "eddyb",
        "timestamp": 1593962161
    },
    {
        "content": "<p>I guess it makes sense but I didn't expect us to have to make that compromise</p>",
        "id": 202925574,
        "sender_full_name": "eddyb",
        "timestamp": 1593962206
    },
    {
        "content": "<p>anything more requires both lazy norm and better const wf (design + impl work), so I don't think we get to that quickly</p>",
        "id": 202925582,
        "sender_full_name": "lcnr",
        "timestamp": 1593962225
    },
    {
        "content": "<p>This seems like a set of limitations that is pretty easy to delimit. With good diagnostics when someone tries to step outside of it, it could be a reasonable MVP</p>",
        "id": 202927632,
        "sender_full_name": "boats",
        "timestamp": 1593965779
    },
    {
        "content": "<p>As a potential user, even just having const generic arrays would make a LOT of no_std/embedded applications much nicer very quickly.</p>",
        "id": 203107064,
        "sender_full_name": "James Munns",
        "timestamp": 1594130974
    },
    {
        "content": "<p>Especially if those parameters could be used as part of const-fn constructors</p>",
        "id": 203107096,
        "sender_full_name": "James Munns",
        "timestamp": 1594130995
    },
    {
        "content": "<p>For example, <code>bbqueue</code>: <a href=\"https://docs.rs/bbqueue/0.4.8/bbqueue/#static-usage\">https://docs.rs/bbqueue/0.4.8/bbqueue/#static-usage</a></p>\n<p>We have to do a big dance to get const-fn constuctors over <code>GenericArray</code> types:</p>\n<ul>\n<li><a href=\"https://github.com/jamesmunns/bbqueue/blob/master/core/src/bbbuffer.rs#L22-L27\">https://github.com/jamesmunns/bbqueue/blob/master/core/src/bbbuffer.rs#L22-L27</a></li>\n<li><a href=\"https://github.com/jamesmunns/bbqueue/blob/master/core/src/bbbuffer.rs#L206-L242\">https://github.com/jamesmunns/bbqueue/blob/master/core/src/bbbuffer.rs#L206-L242</a></li>\n</ul>",
        "id": 203107440,
        "sender_full_name": "James Munns",
        "timestamp": 1594131148
    },
    {
        "content": "<p>I wouldn't have an objection to trying to stabilise a small subset like this. I don't think there would be technical issues for a small subset: we've effectively been using it in the standard library for quite a long time now.</p>",
        "id": 203613013,
        "sender_full_name": "varkor",
        "timestamp": 1594500864
    },
    {
        "content": "<p>I think Centril was the only one who objected to this, and they're not involved at the moment.</p>",
        "id": 203613016,
        "sender_full_name": "varkor",
        "timestamp": 1594500883
    },
    {
        "content": "<p>I'd love to see <code>min_const_generics</code> get stabilized.</p>",
        "id": 203613082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594500979
    },
    {
        "content": "<p>I think the first step would be someone codifying exactly what that subset would be, based on knowledge of what's working reliably that we'd be willing to commit to.</p>",
        "id": 203613088,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594501003
    },
    {
        "content": "<p>it's basically universal quantification over concrete constants, with 0 computation, right?</p>",
        "id": 203620337,
        "sender_full_name": "eddyb",
        "timestamp": 1594514365
    },
    {
        "content": "<p>we could've probably done this ages ago, but no crying over spilt features etc.</p>",
        "id": 203620341,
        "sender_full_name": "eddyb",
        "timestamp": 1594514401
    },
    {
        "content": "<p>we just need to make sure we don't allow any types <em>or values</em> that are not pure integers (or modelable as ADT-ish trees with integer leaves)</p>",
        "id": 203620396,
        "sender_full_name": "eddyb",
        "timestamp": 1594514461
    },
    {
        "content": "<p>in the interest of being able to compare two concrete values for equality (in order to compare two types which refer to them for equality)</p>",
        "id": 203620451,
        "sender_full_name": "eddyb",
        "timestamp": 1594514524
    },
    {
        "content": "<p>one thing I'll say is we should be able allow <code>Foo&lt;\"bar\"&gt;</code> from the start. which would be enough for some metaprogramming usecases</p>",
        "id": 203620474,
        "sender_full_name": "eddyb",
        "timestamp": 1594514590
    },
    {
        "content": "<p>so maybe we should focus on full printing and mangling for concrete values (it's not a lot of work, just someone has to plumb them together) - and <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>'s MCP for \"integer trees\" representation would be great to have just so we know we can 100% trust type-level constants</p>",
        "id": 203620527,
        "sender_full_name": "eddyb",
        "timestamp": 1594514662
    },
    {
        "content": "<p>if necessary, we can disallow using user-defined types even if \"structural match\" might make sense to use as the condition</p>",
        "id": 203620541,
        "sender_full_name": "eddyb",
        "timestamp": 1594514707
    },
    {
        "content": "<p>but the real split is between <code>Foo&lt;123, N, M&gt;</code> and <code>Bar&lt;{N+M}&gt;</code>, the latter requiring ways of constraining that the expression successfully evalutes, which haven't even been designed yet</p>",
        "id": 203620595,
        "sender_full_name": "eddyb",
        "timestamp": 1594514788
    },
    {
        "content": "<p>maybe people disagree and want just integers (or even just <code>usize</code>) - that's probably fine as well, but I'll note that value checking is still required to avoid something like <code>Foo&lt;{ &amp;() as *const _ as usize }&gt;</code> where an integer constant exists with a non-integer value</p>",
        "id": 203620670,
        "sender_full_name": "eddyb",
        "timestamp": 1594514925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Just to confirm, if we had this version of <code>min_const_generics</code>, you'd still be able to get the constant value for CTFE, you just couldn't do computation and put the result back in the type system, right?</p>",
        "id": 203621322,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> you could do CTFE for the value of a const generic argument, just not dependent on generic parameters</p>",
        "id": 203621342,
        "sender_full_name": "eddyb",
        "timestamp": 1594516298
    },
    {
        "content": "<p>so you could still have <code>Foo&lt;{compute_this()}&gt;</code> but not <code>Foo&lt;{size_of::&lt;T&gt;()}&gt;</code> where <code>T</code> is a type parameter (would work fine with a concrete type)</p>",
        "id": 203621398,
        "sender_full_name": "eddyb",
        "timestamp": 1594516332
    },
    {
        "content": "<p>Ah, so <code>const { size_of::&lt;ConcreteType&gt;() * 8 }</code> would be OK?</p>",
        "id": 203621401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516347
    },
    {
        "content": "<p>yes (although we don't use the <code>const</code> keyword)</p>",
        "id": 203621407,
        "sender_full_name": "eddyb",
        "timestamp": 1594516363
    },
    {
        "content": "<p>There's been discussion about <code>const { ... }</code> blocks.</p>",
        "id": 203621413,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> IOW, pretty much anything that works today in an array length</p>",
        "id": 203621415,
        "sender_full_name": "eddyb",
        "timestamp": 1594516384
    },
    {
        "content": "<p>yeah, I mean that const generics don't use that syntax</p>",
        "id": 203621422,
        "sender_full_name": "eddyb",
        "timestamp": 1594516395
    },
    {
        "content": "<p>Ah.</p>",
        "id": 203621424,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516399
    },
    {
        "content": "<p>the <code>const {...}</code> syntax is explicitly in (potentially-)runtime code</p>",
        "id": 203621429,
        "sender_full_name": "eddyb",
        "timestamp": 1594516412
    },
    {
        "content": "<p>Can you get the generic parameter <em>out</em> and do CTFE on it, as long as you don't put it back <em>into</em> the type system?</p>",
        "id": 203621475,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516446
    },
    {
        "content": "<p>depends where</p>",
        "id": 203621489,
        "sender_full_name": "eddyb",
        "timestamp": 1594516461
    },
    {
        "content": "<p>I believe you can do that in associated <code>const</code>s. and definitely in <code>fn</code>s</p>",
        "id": 203621494,
        "sender_full_name": "eddyb",
        "timestamp": 1594516477
    },
    {
        "content": "<p>Well, to give the simplest example: <code>const fn foo&lt;T, N&gt;(slice: [T; N]) -&gt; usize { N * 42 }</code>.</p>",
        "id": 203621506,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516519
    },
    {
        "content": "<p>yes</p>",
        "id": 203621510,
        "sender_full_name": "eddyb",
        "timestamp": 1594516524
    },
    {
        "content": "<p>Awesome.</p>",
        "id": 203621512,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516536
    },
    {
        "content": "<p>note that <code>[...; N * 42]</code> expressions wouldn't work because that ends up with a <code>[_; N * 42]</code> type</p>",
        "id": 203621560,
        "sender_full_name": "eddyb",
        "timestamp": 1594516583
    },
    {
        "content": "<p>Yeah, I can understand that.</p>",
        "id": 203621565,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1594516599
    },
    {
        "content": "<p>If it's not a crazy amount of extra work, I'd like to strongly request that the minimal version support user enums that are <code>repr(some_primitive)</code>. And of course that you be allowed to do <code>val as prim_type</code> to turn it into its integer form.</p>\n<p>Or, in the \"just <code>usize</code>\" case, of course limit it to user enums that are <code>repr(usize)</code>.</p>",
        "id": 203630953,
        "sender_full_name": "Lokathor",
        "timestamp": 1594536179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <code>repr(X)</code> doesn't really matter here, the only distinction we could make is data-less enums</p>",
        "id": 203659907,
        "sender_full_name": "eddyb",
        "timestamp": 1594586192
    },
    {
        "content": "<p>aka \"C-like\"</p>",
        "id": 203659909,
        "sender_full_name": "eddyb",
        "timestamp": 1594586196
    },
    {
        "content": "<p>but I'd prefer if we did all user-defined types at once. or at least, had the <code>#[derive(PartialEq, Eq)]</code> (\"structural match\") requirement from the start</p>",
        "id": 203659923,
        "sender_full_name": "eddyb",
        "timestamp": 1594586235
    },
    {
        "content": "<p>Well, all C-like enums then.</p>",
        "id": 203666393,
        "sender_full_name": "Lokathor",
        "timestamp": 1594596735
    },
    {
        "content": "<p>(I had to check the reference just now to be reminded that you can repr(prim) on a non-C-like enum, and you just get an unspecified layout, without even a warning, which seems... less than good).</p>",
        "id": 203666410,
        "sender_full_name": "Lokathor",
        "timestamp": 1594596792
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> if the reference says that, then the reference is lying</p>",
        "id": 203667586,
        "sender_full_name": "eddyb",
        "timestamp": 1594598887
    },
    {
        "content": "<p>which I've seen people insist is not a problem anymore, but for a long time we learned to tell people \"yeah the reference is outdated, ignore it\"</p>",
        "id": 203667593,
        "sender_full_name": "eddyb",
        "timestamp": 1594598914
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e1f0ffecfe1037f14037c7356fea51cc\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e1f0ffecfe1037f14037c7356fea51cc</a><br>\nThe size of <code>i32</code> is not 8, so the reference seems accurate. It seems to have just done \"something\", and it gives no warning that the actual type generated doesn't have an <code>i32</code> layout.</p>",
        "id": 203668384,
        "sender_full_name": "Lokathor",
        "timestamp": 1594600236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> sorry I didn't get back to you earlier, got distracted. <code>repr(iN)</code> controls the tag representation</p>",
        "id": 203673484,
        "sender_full_name": "eddyb",
        "timestamp": 1594608774
    },
    {
        "content": "<p>we actually define the entire layout if you use <code>repr(C)</code>, <code>repr(iN)</code> or both (<code>repr(C, iN)</code>)</p>",
        "id": 203673490,
        "sender_full_name": "eddyb",
        "timestamp": 1594608797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <a href=\"https://github.com/rust-lang/rfcs/pull/2195\">https://github.com/rust-lang/rfcs/pull/2195</a></p>",
        "id": 203673496,
        "sender_full_name": "eddyb",
        "timestamp": 1594608824
    },
    {
        "content": "<p>oh, well i do love when the reference is out of date</p>",
        "id": 203673498,
        "sender_full_name": "Lokathor",
        "timestamp": 1594608831
    },
    {
        "content": "<p>not sure if <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md\">https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md</a> is itself outdated but it might be more useful than the reference</p>",
        "id": 203673548,
        "sender_full_name": "eddyb",
        "timestamp": 1594608860
    },
    {
        "content": "<p>so yeah you've been able to do FFI using Rust enums for a couple years now</p>",
        "id": 203673557,
        "sender_full_name": "eddyb",
        "timestamp": 1594608906
    },
    {
        "content": "<p>maybe we need PSAs for stuff like this, maybe some people still use <code>union</code>s (or worse) for FFI when <code>enum</code> would work</p>",
        "id": 203673568,
        "sender_full_name": "eddyb",
        "timestamp": 1594608950
    },
    {
        "content": "<p>I have only one place I'd even maybe use this knowledge, but it's taking in data from C so I wouldn't actually switch from union (the current code) to enum.</p>",
        "id": 203673625,
        "sender_full_name": "Lokathor",
        "timestamp": 1594609016
    },
    {
        "content": "<p>I mean it's intended for that purpose, yes (the difference between <code>repr(C, iN)</code> and <code>repr(iN)</code> is how padding works between the tag and the data, so that we can support both struct-of-tag-and-union and union-of-structs-each-with-tag styles)</p>",
        "id": 203674129,
        "sender_full_name": "eddyb",
        "timestamp": 1594609899
    },
    {
        "content": "<p>but this is getting off-topic :P</p>",
        "id": 203674131,
        "sender_full_name": "eddyb",
        "timestamp": 1594609903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203659923\">said</a>:</p>\n<blockquote>\n<p>but I'd prefer if we did all user-defined types at once. or at least, had the <code>#[derive(PartialEq, Eq)]</code> (\"structural match\") requirement from the start</p>\n</blockquote>\n<p>Do you think there's any dissensus at all about what user-defined types can be allowed? cc @varkor Basically, we should include the exact subset where all stakeholders have consensus &amp; the implementation is solid.</p>",
        "id": 203828597,
        "sender_full_name": "boats",
        "timestamp": 1594730918
    },
    {
        "content": "<p>I personally fairly strongly believe that we should only support integer types as a quite self contained subset. I don't know by how much the situation will improve once <a href=\"https://github.com/rust-lang/compiler-team/issues/323\">https://github.com/rust-lang/compiler-team/issues/323</a> is implemented, in which case I might also be fine with arrays, references and <code>&amp;str</code>.</p>",
        "id": 203830011,
        "sender_full_name": "lcnr",
        "timestamp": 1594731768
    },
    {
        "content": "<p>Created an internals thread but before seeing lcnr's last comment</p>",
        "id": 203830210,
        "sender_full_name": "boats",
        "timestamp": 1594731882
    },
    {
        "content": "<p>So I do not want <code>#[repr(...)]</code> enums in the initial MVP</p>",
        "id": 203830220,
        "sender_full_name": "lcnr",
        "timestamp": 1594731888
    },
    {
        "content": "<p>We can leave non integer primtiives out of the MVP IMO, and make them the 1.1</p>",
        "id": 203830250,
        "sender_full_name": "boats",
        "timestamp": 1594731902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256759\">boats</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203830210\">said</a>:</p>\n<blockquote>\n<p>Created an internals thread but before seeing lcnr's last comment</p>\n</blockquote>\n<p>do you have a link?</p>",
        "id": 203830400,
        "sender_full_name": "lcnr",
        "timestamp": 1594731985
    },
    {
        "content": "<p>ah <a href=\"https://internals.rust-lang.org/t/stabilizing-a-const-generics-mvp/12727\">https://internals.rust-lang.org/t/stabilizing-a-const-generics-mvp/12727</a></p>",
        "id": 203830467,
        "sender_full_name": "lcnr",
        "timestamp": 1594732030
    },
    {
        "content": "<p>I still also have some thoughts on \"structural match/eq\" in particular in the context of const-generics that I need to write up. I don't fully understand it yet and the parts I do understand lead me to think it can be improved...</p>",
        "id": 203835783,
        "sender_full_name": "RalfJ",
        "timestamp": 1594734984
    },
    {
        "content": "<p>my thoughts are not coherent enough for a blog post so my plan was to open an issue, once I find the time^^</p>",
        "id": 203835827,
        "sender_full_name": "RalfJ",
        "timestamp": 1594735006
    },
    {
        "content": "<p>Allowing integer convertible enums in the minimum version would greatly help SIMD intrinsic abstracting, but if it has to be in the 1.1 then I'll live.</p>",
        "id": 203851763,
        "sender_full_name": "Lokathor",
        "timestamp": 1594742560
    },
    {
        "content": "<p>I would like rustc_args_required_const to be turned into syntax sugar for const generics. It's only used by intrinsics and will never be stable anyways.</p>",
        "id": 203869312,
        "sender_full_name": "Amanieu",
        "timestamp": 1594751263
    },
    {
        "content": "<p>On that point either way is fine, but that change wouldn't let you restrict the caller to the legally allowed const values (as an enum would).</p>",
        "id": 203870393,
        "sender_full_name": "Lokathor",
        "timestamp": 1594751779
    },
    {
        "content": "<p>Actually now that I think about it it's not fine either way: having to put a call argument in turbofish position would be ugly as heck, and we shouldn't make that the main way to do things, even if maybe the alternative way de-sugars to that.</p>",
        "id": 203870627,
        "sender_full_name": "Lokathor",
        "timestamp": 1594751890
    },
    {
        "content": "<p>I wonder if we could support range restrictions with where clauses...</p>",
        "id": 203882016,
        "sender_full_name": "Amanieu",
        "timestamp": 1594757801
    },
    {
        "content": "<p>Yea, using const arguments in that way is really interesting and I agree that better support for that pattern without requiring turbofish syntax would be a cool feature if it made sense.</p>",
        "id": 203882069,
        "sender_full_name": "boats",
        "timestamp": 1594757839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> so uhhhh did you see when I realized how \"required const\" was used and I got scared we made a huge mistake?</p>",
        "id": 203882415,
        "sender_full_name": "eddyb",
        "timestamp": 1594758028
    },
    {
        "content": "<p>for some reason I had previously assumed it was used only on intrinsics, or maybe on unstabilizable functions</p>",
        "id": 203882445,
        "sender_full_name": "eddyb",
        "timestamp": 1594758048
    },
    {
        "content": "<p>it's not used by intrinsics, it's used by Rust wrappers around intrinsics</p>",
        "id": 203882515,
        "sender_full_name": "eddyb",
        "timestamp": 1594758080
    },
    {
        "content": "<p>and the only way to really make that work is to replace the wrappers with actual intrinsics</p>",
        "id": 203882549,
        "sender_full_name": "eddyb",
        "timestamp": 1594758106
    },
    {
        "content": "<p>within the foreseable future, I mean. having regular arguments that behave like generics is either going to be extremely hacky, or one of those \"Rust 2.0\" things</p>",
        "id": 203882673,
        "sender_full_name": "eddyb",
        "timestamp": 1594758154
    },
    {
        "content": "<p>at least <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>'s recent work makes <em>something</em> possible at all (type-checking the const arg where inference in the parent, e.g. function, is required to know what the const param type is), but it's still much harder for function calls</p>",
        "id": 203882923,
        "sender_full_name": "eddyb",
        "timestamp": 1594758265
    },
    {
        "content": "<p>to be able to type-check, build the MIR, and evaluate the MIR, in order to plug it into a const generic position in the typesystem, you need to know very early that it's a separate body</p>",
        "id": 203883078,
        "sender_full_name": "eddyb",
        "timestamp": 1594758345
    },
    {
        "content": "<p>for the \"arg required to be const\" hack, we can only bypass all that <em>because</em> it never shows up in the typesystem and we can't do monomorphization based on it</p>",
        "id": 203883185,
        "sender_full_name": "eddyb",
        "timestamp": 1594758380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> okay I think I have a hack for you but you might not like it :P. we can have <code>rustc_args_required_const</code> rewrite the call <em>to a different function</em></p>",
        "id": 203883252,
        "sender_full_name": "eddyb",
        "timestamp": 1594758419
    },
    {
        "content": "<p>so the type-checking wouldn't be of const generics, it would be of regular arguments, and only as a MIR transformation would we change it from what looks like a runtime call</p>",
        "id": 203883378,
        "sender_full_name": "eddyb",
        "timestamp": 1594758478
    },
    {
        "content": "<p>this means that instead of being able to type-check a desugared form, the best you'll get is MIR borrowck ICE-ing due to a type mismatch</p>",
        "id": 203883505,
        "sender_full_name": "eddyb",
        "timestamp": 1594758520
    },
    {
        "content": "<p>this is why I'm considering this different from \"desugaring\", because it happens pretty late</p>",
        "id": 203883601,
        "sender_full_name": "eddyb",
        "timestamp": 1594758569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> so basically you'd specify the name of another function in the <code>#[rustc_args_required_const]</code> attribute, and the argument that has to be const is added at the end of the generics, or something, and when you define such a <code>#[rustc_args_required_const]</code> function, you have to get it right or it will ICE your users</p>",
        "id": 203883772,
        "sender_full_name": "eddyb",
        "timestamp": 1594758641
    },
    {
        "content": "<p>that's what we can do today with the same infra that enforces that the value would be computed at compile-time, and thankfully that \"promoted\" MIR fragment we can actually reference from type-level constants</p>",
        "id": 203883910,
        "sender_full_name": "eddyb",
        "timestamp": 1594758699
    },
    {
        "content": "<p>oh another limitation is that the signature can't refer to that const generic, because type inference doesn't know about it (it basically looks like dependent typing without the separate body that e.g. houses <code>g(N)</code> in <code>f::&lt;{g(N)}&gt;</code>)</p>",
        "id": 203884222,
        "sender_full_name": "eddyb",
        "timestamp": 1594758828
    },
    {
        "content": "<p>maybe long-term we can fuse these concepts somehow (maybe by having type-checking create lightweight <code>DefId</code> + attached body that just refers to an expression in the parent) but for now hacks are the best we can offer I'm afraid</p>",
        "id": 203884485,
        "sender_full_name": "eddyb",
        "timestamp": 1594758938
    },
    {
        "content": "<p>anyway, as for the <code>#[repr(iN)]</code> stuff - that's irrelevant to being able to cast an <code>enum</code> to an integer AFAIK, the important thing IMO is an opt-in like <code>#[derive(Eq, PartialEq)]</code> that  the <code>==</code> behavior is \"boring\", to avoid surprises and remain conservative (at least for now)</p>",
        "id": 203884726,
        "sender_full_name": "eddyb",
        "timestamp": 1594759035
    },
    {
        "content": "<p>True, <code>repr(integer)</code> isn't required to cast the enum to an integer type. I guess what is really needed is to be able to convert the enum value into its integer form so that you can pass it along to the intrinsic being wrapped. So, depending on what that \"you can't use the const arg for computation\" limit means, it may be a problem.</p>\n<p>Since we have gotten more into it than I expected to, let me spell out specifically one example scenario so that we're on the same page. Our example function is this:</p>\n<ul>\n<li>pub unsafe fn <a href=\"https://doc.rust-lang.org/core/arch/x86_64/fn._mm_round_ps.html\">_mm_round_ps</a>(a: __m128, rounding: i32) -&gt; __m128</li>\n</ul>\n<p>The second argument (<code>rounding</code>) indicates the rounding mode you want to use for this round operation, and it must be a const. It must be one of 5 specific const values. The full names are unimportant, but they map to the rounding modes Nearest, Neg infinity, Pos infinity, Zero, or \"current rounding mode\".</p>\n<p>In <code>safe_arch</code> we end up with the <a href=\"https://docs.rs/safe_arch/0.5.0/safe_arch/macro.round_m128.html\">round_m128</a> macro, which takes <code>$a:expr,</code> followed by the name of the rounding mode you want as just a literal token. It's not part of an enum type, it's just a literal. If you type the wrong thing then your invocation ends up matching none of the macro branches and you get a compile error complaining about an unexpected token. This gives us \"type safety\", of a sort, but at the cost of confusing error messages.</p>\n<p>Right now the usage looks like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">round_m128</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Nearest</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>and if we instead had a const generic function that could accept an enum value it would hopefully look like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">round_m128</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Nearest</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>You just take out the <code>!</code> and you're all set. If I understand the discussion properly, the current version of const generics would require the function version to be called with something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">round_m128</span>::<span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"n\">Nearest</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Certainly usable, but also not the best.</p>",
        "id": 203891210,
        "sender_full_name": "Lokathor",
        "timestamp": 1594762345
    },
    {
        "content": "<p>sorry, is that replying to the <code>repr(iN)</code> discussion, or the <code>#[rustc_args_required_const]</code> one?</p>",
        "id": 203893066,
        "sender_full_name": "eddyb",
        "timestamp": 1594763593
    },
    {
        "content": "<p>if it's \"both\" that's super confusing</p>",
        "id": 203893070,
        "sender_full_name": "eddyb",
        "timestamp": 1594763598
    },
    {
        "content": "<p>also, it's not \"the current version of const generics\", it's the only version ever designed to an extent that is implementable</p>",
        "id": 203893106,
        "sender_full_name": "eddyb",
        "timestamp": 1594763636
    },
    {
        "content": "<p>const generics intentionally rely on having a syntactical distinction, which regular function arguments simply don't have, in order to \"lift\" the expression into a separate (unnamed) constant \"definition\", <em>before</em> type-checking</p>",
        "id": 203893219,
        "sender_full_name": "eddyb",
        "timestamp": 1594763710
    },
    {
        "content": "<p>if type-checking is the first place where it's known that an expression is being passed to a \"<code>const</code> argument\", then it's too late to do any lifting that type-checking could then use in the type-system</p>",
        "id": 203893377,
        "sender_full_name": "eddyb",
        "timestamp": 1594763789
    },
    {
        "content": "<p>Well I started by replying to the repr(iN) thing, but you'd written a lot so I ended up writing a lot myself :P</p>",
        "id": 203893396,
        "sender_full_name": "Lokathor",
        "timestamp": 1594763804
    },
    {
        "content": "<p>alright so you want <code>fn foo(const x: Foo)</code> and also <code>Foo</code> happens to be an <code>enum</code></p>",
        "id": 203893450,
        "sender_full_name": "eddyb",
        "timestamp": 1594763842
    },
    {
        "content": "<p>Well, yeah, i don't know anything about the compiler, but basically as a <em>user of a function</em> the <code>rustc_args_required_const</code> system is actually a better way to interact with a function</p>",
        "id": 203893636,
        "sender_full_name": "Lokathor",
        "timestamp": 1594763949
    },
    {
        "content": "<p>the unstable-only workaround for <code>#[rustc_args_required_const]</code> that I mentioned above, would redirect the public regular-looking function to a private const-generic one, so you will indeed be limited by what const generics accept. but also you wouldn't care about things being stabilized because <code>#[rustc_args_required_const]</code> is perma-unstable and there is no design or path forward for \"const argurments\"</p>",
        "id": 203893637,
        "sender_full_name": "eddyb",
        "timestamp": 1594763950
    },
    {
        "content": "<p>deeply unfortunate</p>",
        "id": 203893762,
        "sender_full_name": "Lokathor",
        "timestamp": 1594764023
    },
    {
        "content": "<p>frankly, if we do want <code>fn foo(const x: Foo)</code> to work, we should start trying to make rustc dependent-typing-friendly</p>",
        "id": 203893812,
        "sender_full_name": "eddyb",
        "timestamp": 1594764064
    },
    {
        "content": "<p>which means breaking some of the barriers between the value level and the type level</p>",
        "id": 203893846,
        "sender_full_name": "eddyb",
        "timestamp": 1594764093
    },
    {
        "content": "<p>sounds like an itty bitty RFC that no one would have strong feelings about.</p>",
        "id": 203893913,
        "sender_full_name": "Lokathor",
        "timestamp": 1594764126
    },
    {
        "content": "<p>anything I can think of that's not a pile of hacks feels insurmountable</p>",
        "id": 203893917,
        "sender_full_name": "eddyb",
        "timestamp": 1594764127
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> to be clear: I mean the implementation</p>",
        "id": 203893929,
        "sender_full_name": "eddyb",
        "timestamp": 1594764138
    },
    {
        "content": "<p>ah, so it wouldn't introduce it all to the language?</p>",
        "id": 203893950,
        "sender_full_name": "Lokathor",
        "timestamp": 1594764161
    },
    {
        "content": "<p>yeah, I'm talking about redesigning parts of the typesystem implementation to more readily allow referring to values</p>",
        "id": 203894282,
        "sender_full_name": "eddyb",
        "timestamp": 1594764385
    },
    {
        "content": "<p>right now it heavily relies on very early lifting, with one exception being promoted MIR fragments (but typeck can't exactly make use of those)</p>",
        "id": 203894307,
        "sender_full_name": "eddyb",
        "timestamp": 1594764418
    },
    {
        "content": "<p>the current situation is similar to how Haskell has a syntax for making a value into effectively a type where the <em>kind</em> of that type would be called roughly e.g. <code>const i32</code> Rust, and that's very much different from dependent typing</p>",
        "id": 203894495,
        "sender_full_name": "eddyb",
        "timestamp": 1594764556
    },
    {
        "content": "<p>longer-term I feel like dataless enums shouldn't be hard to represent in the \"integer tree\" we are moving towards, but I also feel like we should get some basic experience with integers and product types before we move to more complex sum types ;)</p>",
        "id": 203922425,
        "sender_full_name": "RalfJ",
        "timestamp": 1594797033
    },
    {
        "content": "<p>(in terms of stabilizaiton, that is. on nightly miri is probably more than prepared enough already for all that.)</p>",
        "id": 203922438,
        "sender_full_name": "RalfJ",
        "timestamp": 1594797053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I mean, enum variants are trivial to support? there's not much to do in the first place</p>",
        "id": 203925498,
        "sender_full_name": "eddyb",
        "timestamp": 1594799632
    },
    {
        "content": "<p>I mean I'd hope so but I prefer to be cautious I guess^^</p>",
        "id": 203926906,
        "sender_full_name": "RalfJ",
        "timestamp": 1594800722
    },
    {
        "content": "<p>the \"structural match\" requirement and checking that the value doesn't contain anything weird are the scary bits to me, and the latter is mostly subsumed by the conversion to the \"ADT tree with integer leaves\" (not sure I like how it keeps getting shortened to \"integer tree\" :P)</p>",
        "id": 203927117,
        "sender_full_name": "eddyb",
        "timestamp": 1594800891
    },
    {
        "content": "<p>structural match strikes fear into the hearts of even the strongest warriors</p>",
        "id": 203927169,
        "sender_full_name": "lcnr",
        "timestamp": 1594800949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> we can do ATWIL for shortening it if you prefer, but I prefer integer tree over acronyms</p>",
        "id": 203927989,
        "sender_full_name": "oli",
        "timestamp": 1594801550
    },
    {
        "content": "<p>lol</p>",
        "id": 203928042,
        "sender_full_name": "eddyb",
        "timestamp": 1594801568
    },
    {
        "content": "<p>I think \"integer\" isn't the most important part</p>",
        "id": 203928047,
        "sender_full_name": "eddyb",
        "timestamp": 1594801576
    },
    {
        "content": "<p>I'd call it ADT tree (and just imagine an inductive <code>Nat</code> definition)</p>",
        "id": 203928064,
        "sender_full_name": "eddyb",
        "timestamp": 1594801588
    },
    {
        "content": "<p>or \"pure value tree\" idk</p>",
        "id": 203928076,
        "sender_full_name": "eddyb",
        "timestamp": 1594801600
    },
    {
        "content": "<p>valtree is ok <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 203928095,
        "sender_full_name": "oli",
        "timestamp": 1594801626
    },
    {
        "content": "<p>valtralla</p>",
        "id": 203928109,
        "sender_full_name": "eddyb",
        "timestamp": 1594801641
    },
    {
        "content": "<p>(I'm so sorry,)</p>",
        "id": 203928117,
        "sender_full_name": "eddyb",
        "timestamp": 1594801647
    },
    {
        "content": "<p>I like valtree</p>",
        "id": 203928701,
        "sender_full_name": "RalfJ",
        "timestamp": 1594802107
    },
    {
        "content": "<p>@lcnr I'm still a little unclear on what can't be allowed in constraints without lazy normalization.</p>",
        "id": 203934533,
        "sender_full_name": "boats",
        "timestamp": 1594806471
    },
    {
        "content": "<p>The example you posted doesn't cause any errors on nightly: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8e5d2be7fd6ddb4790083e0c0378ef8a\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8e5d2be7fd6ddb4790083e0c0378ef8a</a></p>",
        "id": 203934614,
        "sender_full_name": "boats",
        "timestamp": 1594806503
    },
    {
        "content": "<p>And since on stable you can already use a constant in a where clause by doing <code>[T; 0]: Default</code> (for example), it can't just be any constant showing up in a where clause, but that's all your example shows</p>",
        "id": 203934716,
        "sender_full_name": "boats",
        "timestamp": 1594806590
    },
    {
        "content": "<p>Is it meant to be just the use of free const parameters in where clauses?</p>",
        "id": 203934841,
        "sender_full_name": "boats",
        "timestamp": 1594806659
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> ^^ (sorry I'm bad at zulip)</p>",
        "id": 203934865,
        "sender_full_name": "boats",
        "timestamp": 1594806684
    },
    {
        "content": "<p>Yeah, you are right</p>",
        "id": 203934935,
        "sender_full_name": "lcnr",
        "timestamp": 1594806730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256759\">boats</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203934614\">said</a>:</p>\n<blockquote>\n<p>The example you posted doesn't cause any errors on nightly: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8e5d2be7fd6ddb4790083e0c0378ef8a\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8e5d2be7fd6ddb4790083e0c0378ef8a</a></p>\n</blockquote>\n<p>This works because<code>#![feature(const_generics)]</code> automatically activates lazy norm</p>",
        "id": 203934949,
        "sender_full_name": "lcnr",
        "timestamp": 1594806758
    },
    {
        "content": "<p>Tested it locally</p>",
        "id": 203934962,
        "sender_full_name": "lcnr",
        "timestamp": 1594806776
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/131828-t-compiler/topic/lazy.20norm.20const.20parent.20generics.20hack/near/203899955\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/lazy.20norm.20const.20parent.20generics.20hack/near/203899955</a></p>",
        "id": 203934987,
        "sender_full_name": "lcnr",
        "timestamp": 1594806796
    },
    {
        "content": "<p>I forgot that we currently use a hack to evade the need for lazy norm</p>",
        "id": 203934997,
        "sender_full_name": "lcnr",
        "timestamp": 1594806811
    },
    {
        "content": "<p>so we probably can't stabilize const generics without first stabilizing lazy norm first</p>",
        "id": 203935017,
        "sender_full_name": "lcnr",
        "timestamp": 1594806832
    },
    {
        "content": "<p>which means that we don't really have to restrict bounds after all</p>",
        "id": 203935070,
        "sender_full_name": "lcnr",
        "timestamp": 1594806860
    },
    {
        "content": "<p>But isn't this only an issue if we use free parameters?</p>",
        "id": 203935388,
        "sender_full_name": "boats",
        "timestamp": 1594807100
    },
    {
        "content": "<p>it's a problem if we use <code>impl&lt;T&gt; From&lt;[u8; 1 &lt;&lt; 2]&gt; for IpAddr&lt;T&gt;</code> I think. We can't really decide when the parent generics are needed, so we currently always supply them</p>",
        "id": 203935520,
        "sender_full_name": "lcnr",
        "timestamp": 1594807208
    },
    {
        "content": "<p>i.e. getting const generics to work without lazy norm can very easily break stable code</p>",
        "id": 203935548,
        "sender_full_name": "lcnr",
        "timestamp": 1594807229
    },
    {
        "content": "<p>am currently looking into this... we previously didn't have a clear example of stable code which breaks without lazy norm</p>",
        "id": 203935568,
        "sender_full_name": "lcnr",
        "timestamp": 1594807260
    },
    {
        "content": "<p>Yea I'm not able to find an example (based on eddy's comment in the other zulip thread) that doesn't work. e.g. <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=5ceb2d8f660da0488d796dae2116a44c\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=5ceb2d8f660da0488d796dae2116a44c</a> is fine</p>",
        "id": 203935929,
        "sender_full_name": "boats",
        "timestamp": 1594807505
    },
    {
        "content": "<p>Isn't this covered by not allowing any free type or const parameters in these expressions?</p>",
        "id": 203936040,
        "sender_full_name": "boats",
        "timestamp": 1594807594
    },
    {
        "content": "<p>the problem is that we currently don't supply the parent generics to array lengths, which is why <a href=\"https://github.com/rust-lang/rust/issues/43408\">https://github.com/rust-lang/rust/issues/43408</a> and its duplicates exist</p>",
        "id": 203936222,
        "sender_full_name": "lcnr",
        "timestamp": 1594807739
    },
    {
        "content": "<p>This ICEs because of this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">sof</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>:<span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">10</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">to_byte_array</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">sof</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">panic</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203936231,
        "sender_full_name": "lcnr",
        "timestamp": 1594807748
    },
    {
        "content": "<p>To use const generics, we now supply the parent generics (<code>T</code>) to the unevaluated const <code>1 &lt;&lt; 2</code> in my above example.</p>",
        "id": 203936355,
        "sender_full_name": "lcnr",
        "timestamp": 1594807834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> what <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> said, you need to enable \"correct generics in scope\" without enabling lazy normalization</p>",
        "id": 203936357,
        "sender_full_name": "eddyb",
        "timestamp": 1594807839
    },
    {
        "content": "<p>AFAICT there's no way to do this currently without changing the compiler</p>",
        "id": 203936364,
        "sender_full_name": "eddyb",
        "timestamp": 1594807852
    },
    {
        "content": "<p>presumably because we wanted <code>#![feature(const_generics)]</code> to \"just work\"</p>",
        "id": 203936377,
        "sender_full_name": "eddyb",
        "timestamp": 1594807868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203936364\">said</a>:</p>\n<blockquote>\n<p>AFAICT there's no way to do this currently without changing the compiler</p>\n</blockquote>\n<p>It mostly works, until it doesn't <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> and \"until it doesn't\" include stable code</p>",
        "id": 203936396,
        "sender_full_name": "lcnr",
        "timestamp": 1594807881
    },
    {
        "content": "<p>Right but we're already scoping down to not allow use of type parameters in the MVP</p>",
        "id": 203936398,
        "sender_full_name": "boats",
        "timestamp": 1594807881
    },
    {
        "content": "<p>sure, we just have to be even stricter than that and say that the expression is either the name of a const generic param, or doesn't see parameters in scope at all</p>",
        "id": 203936428,
        "sender_full_name": "eddyb",
        "timestamp": 1594807915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> We could bodge this by only supplying generic params if one of these params is a const param <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 203936495,
        "sender_full_name": "lcnr",
        "timestamp": 1594807940
    },
    {
        "content": "<p>It's already either an identity expression or an expression which doesn't use the parameter. What is the difference with \"doesn't see\"?</p>",
        "id": 203936511,
        "sender_full_name": "boats",
        "timestamp": 1594807954
    },
    {
        "content": "<p>but then it's easy to break it</p>",
        "id": 203936514,
        "sender_full_name": "eddyb",
        "timestamp": 1594807956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> in terms of what the compiler passes around even when not used</p>",
        "id": 203936522,
        "sender_full_name": "eddyb",
        "timestamp": 1594807976
    },
    {
        "content": "<p>think like a closure that doesn't really depend on the parent <code>fn</code>'s generics</p>",
        "id": 203936536,
        "sender_full_name": "eddyb",
        "timestamp": 1594807990
    },
    {
        "content": "<p>they are still tracked everywhere</p>",
        "id": 203936550,
        "sender_full_name": "eddyb",
        "timestamp": 1594808004
    },
    {
        "content": "<p>But how does that impact the exposed surface area? Trait resolution?</p>",
        "id": 203936562,
        "sender_full_name": "boats",
        "timestamp": 1594808017
    },
    {
        "content": "<p>if <del>it</del> a const expression shows up in where clauses, without lazy normalization, you'll end up with a cyclic dependency</p>",
        "id": 203936598,
        "sender_full_name": "eddyb",
        "timestamp": 1594808042
    },
    {
        "content": "<p>what is \"it\"?</p>",
        "id": 203936631,
        "sender_full_name": "boats",
        "timestamp": 1594808058
    },
    {
        "content": "<p>between \"bounds in scope\" and \"normalize this constant expression\" (which is found in the bounds in scope, of it self)</p>",
        "id": 203936632,
        "sender_full_name": "eddyb",
        "timestamp": 1594808059
    },
    {
        "content": "<p>I'm kind of sad we took out the trigger for this, it'd be useful to demonstrate without modifying the compiler</p>",
        "id": 203936664,
        "sender_full_name": "eddyb",
        "timestamp": 1594808096
    },
    {
        "content": "<p>in the case of your <code>impl</code> there, <code>Foo&lt;T&gt;: From&lt;[U; 1 + 1]&gt;</code> is a \"bound in scope\" (<code>ParamEnv</code>) of the whole impl, including the <code>1+1</code> expression (so e.g. if you had an associated <code>const</code> in the <code>impl</code>, you could probably use it, lol?)</p>",
        "id": 203936747,
        "sender_full_name": "eddyb",
        "timestamp": 1594808161
    },
    {
        "content": "<p>and without lazy normalization, we try to eagerly normalize the <code>1 + 1</code>, but type-checking <code>1 + 1</code> eagerly depends on the \"bounds in scope\" (so that you can check which traits are implemented, <em>just in case you need to</em> etc.)</p>",
        "id": 203936833,
        "sender_full_name": "eddyb",
        "timestamp": 1594808221
    },
    {
        "content": "<p>lazy normalization breaks the cycle by replacing \"just in case you need to\" with \"only if you need to\"</p>",
        "id": 203936858,
        "sender_full_name": "eddyb",
        "timestamp": 1594808243
    },
    {
        "content": "<p>Thanks, I managed to get a cycle: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8cd9fc9808eaf04e119dda2de2ef445a\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=8cd9fc9808eaf04e119dda2de2ef445a</a></p>",
        "id": 203936889,
        "sender_full_name": "boats",
        "timestamp": 1594808268
    },
    {
        "content": "<p>the only reason a plain literal works is basically a pre-lazy-normalization hack</p>",
        "id": 203936893,
        "sender_full_name": "eddyb",
        "timestamp": 1594808269
    },
    {
        "content": "<p>that's a <del>normal</del> unavoidable cycle though</p>",
        "id": 203936952,
        "sender_full_name": "eddyb",
        "timestamp": 1594808290
    },
    {
        "content": "<p>although it partially overlaps with the ones I'm talking about</p>",
        "id": 203936963,
        "sender_full_name": "eddyb",
        "timestamp": 1594808307
    },
    {
        "content": "<p>the difference is that in what I'm talking about you'd see the <code>param_env</code> query show up, let me check what that's described as</p>",
        "id": 203937023,
        "sender_full_name": "eddyb",
        "timestamp": 1594808365
    },
    {
        "content": "<p>But you've talked about compiler internals, I'm asking what users can witness that would change once lazy const normalization is enabled</p>",
        "id": 203937035,
        "sender_full_name": "boats",
        "timestamp": 1594808376
    },
    {
        "content": "<p>lazy normalization just makes more things work</p>",
        "id": 203937080,
        "sender_full_name": "eddyb",
        "timestamp": 1594808403
    },
    {
        "content": "<p>(modulo bugs)</p>",
        "id": 203937094,
        "sender_full_name": "eddyb",
        "timestamp": 1594808408
    },
    {
        "content": "<p>What expression is non-cyclical, with no free parameters used in the expression, but still depends on those parameters?</p>",
        "id": 203937136,
        "sender_full_name": "boats",
        "timestamp": 1594808459
    },
    {
        "content": "<p>ie what would work that doesn't work now that isn't already excluded by the no free params rule</p>",
        "id": 203937213,
        "sender_full_name": "boats",
        "timestamp": 1594808485
    },
    {
        "content": "<p>without it, if we want to have const generics and not break any existing code, we'd have to come up with a decision for \"does this get to see parameters/bounds in scope\", likely limited to \"this is literally a use of a const generic param\"</p>",
        "id": 203937225,
        "sender_full_name": "eddyb",
        "timestamp": 1594808493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> it's specifically stuff that <em>doesn't</em> mention parameters</p>",
        "id": 203937235,
        "sender_full_name": "eddyb",
        "timestamp": 1594808512
    },
    {
        "content": "<p>that we're worried about</p>",
        "id": 203937241,
        "sender_full_name": "eddyb",
        "timestamp": 1594808519
    },
    {
        "content": "<p>yea, I'm trying to get a concrete example of that to understand the user impact better</p>",
        "id": 203937294,
        "sender_full_name": "boats",
        "timestamp": 1594808533
    },
    {
        "content": "<p>note that  \"syntactically mentions parameters\" is an incomplete approximation of \"semantically depends on parameters/bounds in scope\"</p>",
        "id": 203937307,
        "sender_full_name": "eddyb",
        "timestamp": 1594808545
    },
    {
        "content": "<p>right, that's why I mentioned trait resolution.</p>",
        "id": 203937322,
        "sender_full_name": "boats",
        "timestamp": 1594808561
    },
    {
        "content": "<p>I'd be especially worried about an example where method resolution works only because it doesn't see an impl, but lazy normalization could allow it to see an additional impl</p>",
        "id": 203937361,
        "sender_full_name": "boats",
        "timestamp": 1594808603
    },
    {
        "content": "<p>but most examples in the wild are just pure computations AFAIK, so we just need to preserve the behavior until we can do the correct thing</p>",
        "id": 203937369,
        "sender_full_name": "eddyb",
        "timestamp": 1594808611
    },
    {
        "content": "<p>I mean, it's hard to construct examples because CTFE and no traits, but I can try, I guess?</p>",
        "id": 203937422,
        "sender_full_name": "eddyb",
        "timestamp": 1594808643
    },
    {
        "content": "<p>so you're not interested in cycle errors but behavioral changes when turning on lazy normalization, due to the \"bounds in scope\" interactions?</p>",
        "id": 203937462,
        "sender_full_name": "eddyb",
        "timestamp": 1594808669
    },
    {
        "content": "<p>just to make sure</p>",
        "id": 203937472,
        "sender_full_name": "eddyb",
        "timestamp": 1594808676
    },
    {
        "content": "<p>that should be easy to demonstrate (if at all possible) without changing the compiler because they shouldn't need const generics and you can otherwise toggle lazy normalization with <code>#![feature(const_generics)]</code>. I'll get it on it now</p>",
        "id": 203937513,
        "sender_full_name": "eddyb",
        "timestamp": 1594808722
    },
    {
        "content": "<p>I'm interested in user impact. So breaking changes in the future would be a showstopper, but cycle errors only seem like a showstopper if they're easy to encounter.</p>",
        "id": 203937527,
        "sender_full_name": "boats",
        "timestamp": 1594808735
    },
    {
        "content": "<p>so if \"no free params but identity expressions\" is enough to avoid breaking changes and easy to encounter bugs, it seems like we could avoid blocking on lazy normalization</p>",
        "id": 203937622,
        "sender_full_name": "boats",
        "timestamp": 1594808795
    },
    {
        "content": "<p>in terms of cycle errors being a showstopper: doing the naive (i.e. w/o lazy normalization) correct thing (of always exposing params/bounds in scope) used to trigger cycles in libcore. the move to <code>const</code>-generic impls (or just <code>#![feature(const_generics)]</code> turning on lazy normalization) have fixed some of that</p>",
        "id": 203937656,
        "sender_full_name": "eddyb",
        "timestamp": 1594808844
    },
    {
        "content": "<p>I don't remember if we did a crater run but it should be relatively easy, especially for macro generated code, to trip over that</p>",
        "id": 203937685,
        "sender_full_name": "eddyb",
        "timestamp": 1594808871
    },
    {
        "content": "<p>anyway I'll go try to make a behavioral example now</p>",
        "id": 203937753,
        "sender_full_name": "eddyb",
        "timestamp": 1594808891
    },
    {
        "content": "<p>oh and this is what you'd see in the kind of cycle error I'm talking about <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/query/mod.rs#L802\">https://github.com/rust-lang/rust/blob/master/src/librustc_middle/query/mod.rs#L802</a></p>",
        "id": 203937765,
        "sender_full_name": "eddyb",
        "timestamp": 1594808903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> done: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=257b316bd0aa5382de83ca55757b6121\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=257b316bd0aa5382de83ca55757b6121</a></p>",
        "id": 203938376,
        "sender_full_name": "eddyb",
        "timestamp": 1594809427
    },
    {
        "content": "<p>comment out <code>#![feature(const_generics)]</code> to disable lazy normalization</p>",
        "id": 203938394,
        "sender_full_name": "eddyb",
        "timestamp": 1594809441
    },
    {
        "content": "<p>wasted a bunch of time trying to create an ambiguity between the where clause and the known impl, but the easy thing was just to create an ambiguity between two bounds in scope (which have the same precedence)</p>",
        "id": 203938465,
        "sender_full_name": "eddyb",
        "timestamp": 1594809482
    },
    {
        "content": "<p>makes sense</p>",
        "id": 203938485,
        "sender_full_name": "boats",
        "timestamp": 1594809493
    },
    {
        "content": "<p>okay so is the solution to block on lazy normalization or is there a limitation we can provide that avoids the issue?</p>",
        "id": 203938526,
        "sender_full_name": "boats",
        "timestamp": 1594809516
    },
    {
        "content": "<p>I think we can do something</p>",
        "id": 203938561,
        "sender_full_name": "eddyb",
        "timestamp": 1594809547
    },
    {
        "content": "<p>I'm trying to decide if we need to do one of the refactors that got brought up by <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>, <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> and I elsewhere, which is making <code>rustc_typeck</code> capable of knowing which generics are in scope, all the time (according to its own definition), instead of <code>rustc_resolve</code> for some of the checks that prevent ICEs (such as disallowing <code>struct Foo&lt;T, U = U&gt;(T, U);</code> which would ICE when using e.g. <code>Foo&lt;()&gt;</code>)</p>",
        "id": 203938673,
        "sender_full_name": "eddyb",
        "timestamp": 1594809657
    },
    {
        "content": "<p>if we do that (which I increasingly regret not doing years ago), and are careful about it, then I think we're golden for making things either error or work, but not ICE</p>",
        "id": 203938721,
        "sender_full_name": "eddyb",
        "timestamp": 1594809696
    },
    {
        "content": "<p>which means we can keep <code>1 + 1</code> working the exact same way it does today, while special-casing const generic param uses (but not expressions containing them, at least not in the initial stabilization)</p>",
        "id": 203938804,
        "sender_full_name": "eddyb",
        "timestamp": 1594809739
    },
    {
        "content": "<p>but if we don't want to do even that, we have to be a bit more careful elsewhere</p>",
        "id": 203938829,
        "sender_full_name": "eddyb",
        "timestamp": 1594809762
    },
    {
        "content": "<p>and presumably handle it in name resolution</p>",
        "id": 203938833,
        "sender_full_name": "eddyb",
        "timestamp": 1594809770
    },
    {
        "content": "<p>lone <code>N</code> would resolve on stable, const/type parameters nested in an const expression would require <code>#![feature(const_generics)]</code></p>",
        "id": 203938876,
        "sender_full_name": "eddyb",
        "timestamp": 1594809811
    },
    {
        "content": "<p>and if the user turns that on, they get lazy normalization, which makes everything work</p>",
        "id": 203938896,
        "sender_full_name": "eddyb",
        "timestamp": 1594809834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> so yeah there's a path forward w/o any refactors</p>",
        "id": 203938946,
        "sender_full_name": "eddyb",
        "timestamp": 1594809846
    },
    {
        "content": "<p>we just have to make sure we emit an error <em>somewhere</em> before there's a chance of ICEs</p>",
        "id": 203938975,
        "sender_full_name": "eddyb",
        "timestamp": 1594809867
    },
    {
        "content": "<p>although, this is only for <code>[T; expr]</code> and <code>Foo&lt;{expr}&gt;</code>, I believe <code>[0u8; size_of::&lt;T&gt;()]</code> works already? or maybe I am confusing myself</p>",
        "id": 203939102,
        "sender_full_name": "eddyb",
        "timestamp": 1594809940
    },
    {
        "content": "<p>ah no, only this does:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203939220,
        "sender_full_name": "eddyb",
        "timestamp": 1594810009
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> actually, this breakage is already inevitable, because this is fine on stable: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8663df490e41c9a237a90de19e4c9ac9\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8663df490e41c9a237a90de19e4c9ac9</a></p>",
        "id": 203939296,
        "sender_full_name": "boats",
        "timestamp": 1594810060
    },
    {
        "content": "<p>my link above also compiles on stable, no?</p>",
        "id": 203939363,
        "sender_full_name": "eddyb",
        "timestamp": 1594810092
    },
    {
        "content": "<p>But isn't that fine as <code>u8</code> is a concrete type?</p>",
        "id": 203939368,
        "sender_full_name": "lcnr",
        "timestamp": 1594810097
    },
    {
        "content": "<p>yea, you're right</p>",
        "id": 203939374,
        "sender_full_name": "boats",
        "timestamp": 1594810100
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203939386,
        "sender_full_name": "lcnr",
        "timestamp": 1594810107
    },
    {
        "content": "<p>That one is a back compat hazard and imo a problem with the way our generics work</p>",
        "id": 203939402,
        "sender_full_name": "lcnr",
        "timestamp": 1594810127
    },
    {
        "content": "<p>(sorry I wasn't clearer, I was searching for something that compiles on stable and changes behavior with lazy normalization)</p>",
        "id": 203939414,
        "sender_full_name": "eddyb",
        "timestamp": 1594810136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> what do you mean?</p>",
        "id": 203939435,
        "sender_full_name": "eddyb",
        "timestamp": 1594810145
    },
    {
        "content": "<p>the size of <code>*mut T</code> is perfectly well-defined given <code>T: Sized</code>, it's the same as the size of <code>usize</code> :P</p>",
        "id": 203939457,
        "sender_full_name": "eddyb",
        "timestamp": 1594810167
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> oh btw I think you can also make lazy normalization not error but instead change runtime behavior</p>",
        "id": 203939560,
        "sender_full_name": "eddyb",
        "timestamp": 1594810216
    },
    {
        "content": "<p>So the sense I have is just disallowing free parameters except for const identity expressions will make the user impact of turning on lazy normalization for consts unimportant</p>",
        "id": 203939570,
        "sender_full_name": "boats",
        "timestamp": 1594810224
    },
    {
        "content": "<p>I think its fine for these examples to break, they're clearly wrong code that is also pathological</p>",
        "id": 203939593,
        "sender_full_name": "boats",
        "timestamp": 1594810252
    },
    {
        "content": "<p>by having just <code>Trait&lt;T&gt;</code> instead of <code>Trait&lt;T&gt; + Trait&lt;U&gt;</code> - without lazy normalization, that gets ignored and the <code>Trait&lt;()&gt;</code> impl is used instead</p>",
        "id": 203939594,
        "sender_full_name": "eddyb",
        "timestamp": 1594810253
    },
    {
        "content": "<p>I'm also fine with breaking these examples, yes</p>",
        "id": 203939606,
        "sender_full_name": "eddyb",
        "timestamp": 1594810262
    },
    {
        "content": "<p>what I don't want to break is <code>1 + 1 + 1 + 1</code> generated by a macro, in any position</p>",
        "id": 203939628,
        "sender_full_name": "eddyb",
        "timestamp": 1594810274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> I should've asked earlier, what do you mean by \"identity\" here?</p>",
        "id": 203939647,
        "sender_full_name": "eddyb",
        "timestamp": 1594810293
    },
    {
        "content": "<p><code>N</code></p>",
        "id": 203939656,
        "sender_full_name": "boats",
        "timestamp": 1594810301
    },
    {
        "content": "<p>aaaah alright, thanks, makes sense</p>",
        "id": 203939661,
        "sender_full_name": "eddyb",
        "timestamp": 1594810306
    },
    {
        "content": "<p>in the original RFC an identity expression is defined that way</p>",
        "id": 203939668,
        "sender_full_name": "boats",
        "timestamp": 1594810314
    },
    {
        "content": "<p>shows you how well I remember the RFC :P</p>",
        "id": 203939713,
        "sender_full_name": "eddyb",
        "timestamp": 1594810325
    },
    {
        "content": "<p>then yes I agree with you, I think that's the setup I was describing above</p>",
        "id": 203939737,
        "sender_full_name": "eddyb",
        "timestamp": 1594810347
    },
    {
        "content": "<p>where \"disallowing\" presumably means \"refuse to succeed name-resolving generic parameter names\", that is, not anything subtler like whether bounds are in scope</p>",
        "id": 203939782,
        "sender_full_name": "eddyb",
        "timestamp": 1594810394
    },
    {
        "content": "<p>yea thats what I mean</p>",
        "id": 203939810,
        "sender_full_name": "boats",
        "timestamp": 1594810423
    },
    {
        "content": "<p>(I've used more ambiguous words in the past like \"exposing\", that's why I'm trying to make sure I don't repeat that here)</p>",
        "id": 203939814,
        "sender_full_name": "eddyb",
        "timestamp": 1594810426
    },
    {
        "content": "<p>My belief is changing the behavior of subtler things to be more correct will only break pathological examples that are already expressible on stable</p>",
        "id": 203939886,
        "sender_full_name": "boats",
        "timestamp": 1594810454
    },
    {
        "content": "<p>I mean it doesn't really make sense that const generics would change anything because consts can already be used in these positions by way of array types ofc</p>",
        "id": 203939961,
        "sender_full_name": "boats",
        "timestamp": 1594810500
    },
    {
        "content": "<p>alright seems like we agree on the minimum stabilizable configuration</p>",
        "id": 203940009,
        "sender_full_name": "eddyb",
        "timestamp": 1594810530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203939435\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> what do you mean?</p>\n</blockquote>\n<p>This works:</p>",
        "id": 203940128,
        "sender_full_name": "lcnr",
        "timestamp": 1594810585
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">no_use</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">42</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">no_use</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203940165,
        "sender_full_name": "lcnr",
        "timestamp": 1594810602
    },
    {
        "content": "<p>yyyyes?</p>",
        "id": 203940199,
        "sender_full_name": "eddyb",
        "timestamp": 1594810621
    },
    {
        "content": "<p>This doesn't</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">use</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">42</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"k\">use</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203940200,
        "sender_full_name": "lcnr",
        "timestamp": 1594810623
    },
    {
        "content": "<p>meaning that we leak the way a given function is implemented</p>",
        "id": 203940218,
        "sender_full_name": "lcnr",
        "timestamp": 1594810637
    },
    {
        "content": "<p>I mean we kind of decided not to make CTFE impossible to misuse, for practicality reasons</p>",
        "id": 203940243,
        "sender_full_name": "eddyb",
        "timestamp": 1594810661
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 203940258,
        "sender_full_name": "eddyb",
        "timestamp": 1594810672
    },
    {
        "content": "<p>but in that case we could avoid descending into <code>const fn use</code> if we don't fully know its generic parameters, maybe?</p>",
        "id": 203940358,
        "sender_full_name": "eddyb",
        "timestamp": 1594810722
    },
    {
        "content": "<p>although it might already be a breaking change, did we stabilize <code>if</code> in <code>const fn</code> yet?</p>",
        "id": 203940397,
        "sender_full_name": "eddyb",
        "timestamp": 1594810752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203940397\">said</a>:</p>\n<blockquote>\n<p>although it might already be a breaking change, did we stabilize <code>if</code> in <code>const fn</code> yet?</p>\n</blockquote>\n<p>on nightly</p>",
        "id": 203940417,
        "sender_full_name": "lcnr",
        "timestamp": 1594810771
    },
    {
        "content": "<p>so we have a limited time-window for breaking this :P</p>",
        "id": 203940455,
        "sender_full_name": "eddyb",
        "timestamp": 1594810795
    },
    {
        "content": "<p>we already allow this though</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">no_use</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">42</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">no_use</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203940552,
        "sender_full_name": "lcnr",
        "timestamp": 1594810830
    },
    {
        "content": "<p>I would like to change <code>Predicate::ConstEvaluatable</code> to not look into generic functions at all, but that train is probably long gone</p>",
        "id": 203940612,
        "sender_full_name": "lcnr",
        "timestamp": 1594810885
    },
    {
        "content": "<p>oh right</p>",
        "id": 203940660,
        "sender_full_name": "eddyb",
        "timestamp": 1594810915
    },
    {
        "content": "<p>although in that case, the <code>const fn</code> participates in the typesystem so presumably you can't change the body to return anything other than <code>42</code></p>",
        "id": 203940749,
        "sender_full_name": "eddyb",
        "timestamp": 1594810953
    },
    {
        "content": "<p>hmm <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span> </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">no_use</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">42</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 203940812,
        "sender_full_name": "lcnr",
        "timestamp": 1594811001
    },
    {
        "content": "<p>this is more a general concern, I don't really know how many methods like this exist</p>",
        "id": 203940869,
        "sender_full_name": "lcnr",
        "timestamp": 1594811036
    },
    {
        "content": "<p>anyway I'll leave that stuff to the CTFE people, although I suspect we already made a decision about this in the past</p>",
        "id": 203940967,
        "sender_full_name": "eddyb",
        "timestamp": 1594811077
    },
    {
        "content": "<p>(either that or <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> and I went rogue for \"cool trick\" points)</p>",
        "id": 203940991,
        "sender_full_name": "eddyb",
        "timestamp": 1594811096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> btw I think with this minimal subset, and <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>'s most recent endeavor, we can start to have e.g. <code>.array_chunks::&lt;123&gt;()</code> methods on stable :D</p>",
        "id": 203941628,
        "sender_full_name": "eddyb",
        "timestamp": 1594811541
    },
    {
        "content": "<p>I'm starting to see why <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> and <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> insisted on wishing that into possibility</p>",
        "id": 203941684,
        "sender_full_name": "eddyb",
        "timestamp": 1594811601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203941628\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256759\">boats</span> btw I think with this minimal subset, and <span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span>'s most recent endeavor, we can start to have e.g. <code>.array_chunks::&lt;123&gt;()</code> methods on stable :D</p>\n</blockquote>\n<p>everybody write <code>slice.array_chunks().map(|[a, b]| a + b)</code></p>",
        "id": 203941697,
        "sender_full_name": "lcnr",
        "timestamp": 1594811614
    },
    {
        "content": "<p>since it greatly benefits API design</p>",
        "id": 203941701,
        "sender_full_name": "eddyb",
        "timestamp": 1594811616
    },
    {
        "content": "<p>fair lol</p>",
        "id": 203941712,
        "sender_full_name": "eddyb",
        "timestamp": 1594811622
    },
    {
        "content": "<p>it's so elegant</p>",
        "id": 203941731,
        "sender_full_name": "lcnr",
        "timestamp": 1594811638
    },
    {
        "content": "<p>but also, wow, that is beautiful</p>",
        "id": 203941734,
        "sender_full_name": "eddyb",
        "timestamp": 1594811640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203940009\">said</a>:</p>\n<blockquote>\n<p>alright seems like we agree on the minimum stabilizable configuration</p>\n</blockquote>\n<p>So to sum this up, we do not want to stabilize <code>lazy_normalization_consts</code> for the const generics MCP.</p>\n<p>We instead only allow const params in identity expressions, i.e. <code>N</code> and <code>{ N }</code> and cause an error during typeck if generic parameters are used in a different way? We therefore do not have to supply the parent generics to unevaluated consts, sidestepping the need for lazy norm</p>",
        "id": 203944264,
        "sender_full_name": "lcnr",
        "timestamp": 1594813542
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> it's easier for now to instead feature-gate in <code>rustc_resolve</code></p>",
        "id": 203944406,
        "sender_full_name": "eddyb",
        "timestamp": 1594813627
    },
    {
        "content": "<p>otherwise we need to do that refactor to accurately track generics in scope in <code>rustc_typeck::astconv</code></p>",
        "id": 203944429,
        "sender_full_name": "eddyb",
        "timestamp": 1594813654
    },
    {
        "content": "<p>how can we cleanly gate in a way which allows <code>N</code> but not <code>{ N + 1 }</code> during resolve?</p>",
        "id": 203944443,
        "sender_full_name": "lcnr",
        "timestamp": 1594813664
    },
    {
        "content": "<p>feature-gate the latter and make a special-case for the former</p>",
        "id": 203944515,
        "sender_full_name": "eddyb",
        "timestamp": 1594813690
    },
    {
        "content": "<p>as in, feature-gate mentioning generic parameters in <code>TyKind::Array</code> or <code>GenericArg::Const</code> expressions</p>",
        "id": 203944583,
        "sender_full_name": "eddyb",
        "timestamp": 1594813745
    },
    {
        "content": "<p>and make one exception for \"just the name of a const generic\"</p>",
        "id": 203944619,
        "sender_full_name": "eddyb",
        "timestamp": 1594813767
    },
    {
        "content": "<p>it will likely look a bit hacky, but it should be way less work (and presumably less to try and get right) than the refactor</p>",
        "id": 203944680,
        "sender_full_name": "eddyb",
        "timestamp": 1594813802
    },
    {
        "content": "<p>that means will still keep the ICE on <code>fn foo&lt;T&gt;() -&gt; [u8; std::mem::size_of::&lt;T&gt;()]</code> after const generics is stable?</p>",
        "id": 203944968,
        "sender_full_name": "lcnr",
        "timestamp": 1594813963
    },
    {
        "content": "<p>but yeah, I understand why this makes sense</p>",
        "id": 203944988,
        "sender_full_name": "lcnr",
        "timestamp": 1594813977
    },
    {
        "content": "<p>but I just don't want to <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> can't we just wait a few months and I get lazy norm to stable first <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 203945037,
        "sender_full_name": "lcnr",
        "timestamp": 1594814009
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> no, we'd start feature-gating that instead of ICE-ing</p>",
        "id": 203945218,
        "sender_full_name": "eddyb",
        "timestamp": 1594814109
    },
    {
        "content": "<p>how?</p>",
        "id": 203945241,
        "sender_full_name": "lcnr",
        "timestamp": 1594814130
    },
    {
        "content": "<p>because it's a type parameter in an array type's length</p>",
        "id": 203945267,
        "sender_full_name": "eddyb",
        "timestamp": 1594814147
    },
    {
        "content": "<p><code>fn foo&lt;T&gt;() -&gt; [u8; std::mem::size_of::&lt;*mut T&gt;()]</code> already works on stable</p>",
        "id": 203945271,
        "sender_full_name": "lcnr",
        "timestamp": 1594814151
    },
    {
        "content": "<p>/me squints</p>",
        "id": 203945280,
        "sender_full_name": "eddyb",
        "timestamp": 1594814160
    },
    {
        "content": "<p>it does not</p>",
        "id": 203945341,
        "sender_full_name": "eddyb",
        "timestamp": 1594814182
    },
    {
        "content": "<p>note that what I made work a couple months ago is <code>[expr; N]</code> not <code>[type; N]</code></p>",
        "id": 203945365,
        "sender_full_name": "eddyb",
        "timestamp": 1594814197
    },
    {
        "content": "<p>the \"repeat expression\" not \"array type\"</p>",
        "id": 203945371,
        "sender_full_name": "eddyb",
        "timestamp": 1594814204
    },
    {
        "content": "<p>the array type example fails on both stable and nightly with:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: internal compiler error: src/librustc_middle/ty/subst.rs:554:17: type parameter `T/#0` (T/0) out of range when substituting (root type=Some(fn() -&gt; usize {std::mem::size_of::&lt;*mut T&gt;})) substs=[]\n</code></pre></div>",
        "id": 203945413,
        "sender_full_name": "eddyb",
        "timestamp": 1594814230
    },
    {
        "content": "<p>mb</p>",
        "id": 203945429,
        "sender_full_name": "lcnr",
        "timestamp": 1594814239
    },
    {
        "content": "<p>(\"repeat expressions\" are fine because they can't show up in positions that can lead to cycle errors  - another fact I wish I appreciated years ago <em>sigh</em> - but at least nowadays we have the \"const expression depends on generic parameter\" error)</p>",
        "id": 203945598,
        "sender_full_name": "eddyb",
        "timestamp": 1594814334
    },
    {
        "content": "<p>I think the const generics MVP described in <a href=\"https://internals.rust-lang.org/t/stabilizing-a-const-generics-mvp/12727/9?u=lcnr\">https://internals.rust-lang.org/t/stabilizing-a-const-generics-mvp/12727/9?u=lcnr</a> seems good to me <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 203947273,
        "sender_full_name": "lcnr",
        "timestamp": 1594815415
    },
    {
        "content": "<p>I also have to add the mentioned lazy norm breakage as a ui test so I don't forget this in the future</p>",
        "id": 203947315,
        "sender_full_name": "lcnr",
        "timestamp": 1594815450
    },
    {
        "content": "<p>I think at least adding references (and maybe pointers) to const-generics MVP would be useful.<br>\nIn C++, non-type template parameters allowed references from 98, and while I didn't make use of it often, it certainly was helpful in a few niche cases (for example, emitting static reflection information). A similar, but wider argument could be made about non-data carrying enums. I used that quite a bit as a more type-safe parameter.</p>",
        "id": 203948309,
        "sender_full_name": "Connor Horman",
        "timestamp": 1594816114
    },
    {
        "content": "<p>They would be useful, but they are also more complicated to deal with than integers.</p>\n<p>We do plan to support them eventually, but at least for me the main priority is getting generic arrays on stable. Mostly focusing on integers for now gets us there faster</p>",
        "id": 203948620,
        "sender_full_name": "lcnr",
        "timestamp": 1594816283
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> note that pointers could only be allowed if they contain integer addresses</p>",
        "id": 203949620,
        "sender_full_name": "eddyb",
        "timestamp": 1594816856
    },
    {
        "content": "<p>since that's what pointer equality compares, and we want to avoid <code>Foo&lt;{a}&gt; = Foo&lt;{b}&gt;</code> using a notion of equality different than <code>a == b</code></p>",
        "id": 203949747,
        "sender_full_name": "eddyb",
        "timestamp": 1594816923
    },
    {
        "content": "<p>(we don't want to rely on the <code>Eq</code> implementations though, just disallow types/values for which it would do something different)</p>",
        "id": 203949781,
        "sender_full_name": "eddyb",
        "timestamp": 1594816956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> thanks for linking the internals post, I missed it previously</p>",
        "id": 203949811,
        "sender_full_name": "eddyb",
        "timestamp": 1594816986
    },
    {
        "content": "<p>The requirements for references in C++ are:</p>\n<ul>\n<li>\n<p>Must be a reference to an object with <em>static storage duration</em> and that has linkage. Note that lifetime extended temporary objects, and string literals do not have linkage<br>\nPointers are similar, though the requirements are encoded in the definition of <em>pointer constant expression</em>:</p>\n</li>\n<li>\n<p>Must be a null pointer, or</p>\n</li>\n<li>Must be a pointer to an object with <em>static storage duration</em> that has linkage, or</li>\n<li>Must be a pointer one-passed-the-end of such an object, or</li>\n<li>Must be a pointer to a function</li>\n</ul>\n<p>At least in C++, references are by-identity. Even different objects comparing equal would be considered to be different for instantiation purposes.</p>",
        "id": 203950512,
        "sender_full_name": "Connor Horman",
        "timestamp": 1594817423
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> heh that's way more complicated than what we're doing/want to do in Rust, which is:</p>\n<ul>\n<li>raw pointers are disallowed (or largely behave like <code>usize</code>, allowing only integer addresses)</li>\n<li>references are treated like newtypes (around the value they point to), just like <code>==</code> behaves on them</li>\n</ul>",
        "id": 203951383,
        "sender_full_name": "eddyb",
        "timestamp": 1594817904
    },
    {
        "content": "<p>arguably C++ has a harder time doing the simpler/better thing for CTFE type stuff, due to everything else in the language</p>",
        "id": 203951480,
        "sender_full_name": "eddyb",
        "timestamp": 1594817961
    },
    {
        "content": "<p>although <code>constexpr</code> seems to be approaching what miri can do (and we haven't stabilized a good chunk of that yet, so you could say Rust is behind language-wise even when ahead technology-wise)</p>",
        "id": 203951702,
        "sender_full_name": "eddyb",
        "timestamp": 1594818044
    },
    {
        "content": "<p>Well, C++ does have the blessing (and curse) of being stuck behind a well-specified standard that is voted on by national bodies. It has the advantage that there is more than one correct, or incorrect (depending on how you look at it), implementation, but they also add stuff to the language at the pace of a snail.</p>",
        "id": 203952964,
        "sender_full_name": "Connor Horman",
        "timestamp": 1594818695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/203941697\">said</a>:</p>\n<blockquote>\n<p>everybody write <code>slice.array_chunks().map(|[a, b]| a + b)</code></p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/issues/74373\">#74373</a> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 203984232,
        "sender_full_name": "lcnr",
        "timestamp": 1594833142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> that's great! One thing that is not evident to me, as a plain user, and by reading the lorem example in the docs, is why, without giving an explicit N=2 const parameter, the array_chunks iterator you get returns chunks of two elements.</p>",
        "id": 203990994,
        "sender_full_name": "pachi",
        "timestamp": 1594836315
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v2</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"p\">.</span><span class=\"n\">array_chunks</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|&amp;</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">]</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">).</span><span class=\"n\">sum</span>::<span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>because of type inference. The closure <code>|&amp;[a, b]| a * b</code> has an irrefutable binding requiring an array with 2 elements</p>",
        "id": 203991199,
        "sender_full_name": "lcnr",
        "timestamp": 1594836396
    },
    {
        "content": "<p>Which is used to infer the value of <code>N</code> in <code>fn array_chunks</code></p>",
        "id": 203991270,
        "sender_full_name": "lcnr",
        "timestamp": 1594836429
    },
    {
        "content": "<p>I meant the other example in the docstring:<br>\nlet slice = ['l', 'o', 'r', 'e', 'm'];<br>\nlet mut iter = slice.array_chunks();<br>\nassert_eq!(iter.next().unwrap(), &amp;['l', 'o']);<br>\nassert_eq!(iter.next().unwrap(), &amp;['r', 'e']);<br>\nassert!(iter.next().is_none());<br>\nassert_eq!(iter.remainder(), &amp;['m']);</p>",
        "id": 203991341,
        "sender_full_name": "pachi",
        "timestamp": 1594836466
    },
    {
        "content": "<p>it's similar, the requirements \"backflow\" from the assert_eq into the iter</p>",
        "id": 203991445,
        "sender_full_name": "Lokathor",
        "timestamp": 1594836507
    },
    {
        "content": "<p>Oh! I see! Wow, I wouldn't have imagined that!</p>",
        "id": 203991486,
        "sender_full_name": "pachi",
        "timestamp": 1594836528
    },
    {
        "content": "<p>Here we compare the result if <code>iter.next().unwrap()</code> with <code>&amp;['l', 'o']</code>. <code>[T; 2]</code> only implements partial equality with <code>[T; 2]</code> itself, which is then used to go backwards to <code>array_chunks</code>.</p>",
        "id": 203991491,
        "sender_full_name": "lcnr",
        "timestamp": 1594836530
    },
    {
        "content": "<p>Yes, I can see how type inference does it, but I wouldn't expect it to be so smart...</p>",
        "id": 203991606,
        "sender_full_name": "pachi",
        "timestamp": 1594836576
    },
    {
        "content": "<p>well, at least I put assert out of its domain</p>",
        "id": 203991665,
        "sender_full_name": "pachi",
        "timestamp": 1594836599
    },
    {
        "content": "<p>assert is just a normal expression when you get down to it</p>",
        "id": 203991792,
        "sender_full_name": "Lokathor",
        "timestamp": 1594836652
    },
    {
        "content": "<p>if !(assertion) { panic!() }</p>",
        "id": 203991841,
        "sender_full_name": "Lokathor",
        "timestamp": 1594836677
    },
    {
        "content": "<p>Indeed, it's just me that these cases, like those using asserts to \"remind\" the optimizer some precondition that may not be clear at the point of use look like magic, but yeah. Thanks for the explanations!</p>",
        "id": 203993304,
        "sender_full_name": "pachi",
        "timestamp": 1594837372
    },
    {
        "content": "<blockquote>\n<p>Too bad that this is just a strictly better version of the existing chunks_exact</p>\n</blockquote>\n<p>Also me years ago when chunks_exact was introduced.</p>",
        "id": 204000528,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1594840813
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> rayon can do it too! <a href=\"https://github.com/rayon-rs/rayon/compare/master...cuviper:array_chunks\">https://github.com/rayon-rs/rayon/compare/master...cuviper:array_chunks</a></p>",
        "id": 204009620,
        "sender_full_name": "cuviper",
        "timestamp": 1594845382
    },
    {
        "content": "<p>Nice <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> I am really happy with how well <a href=\"https://github.com/rust-lang/rust/issues/74113\">#74113</a> seems to work. Did you encounter any problems while implementing this?</p>",
        "id": 204010037,
        "sender_full_name": "lcnr",
        "timestamp": 1594845622
    },
    {
        "content": "<p>I had weird type inference errors at first, using the current nightly, but those went away after <code>rustup-toolchain-install-master</code><br>\n(nightly <a href=\"https://github.com/rust-lang/rust/commit/23744c84d9c0f8e4e870edb983f1ad6d33449c34\">23744c84d9c0f8e4e870edb983f1ad6d33449c34</a> vs. master <a href=\"https://github.com/rust-lang/rust/commit/7e11379f3b4c376fbb9a6c4d44f3286ccc28d149\">7e11379f3b4c376fbb9a6c4d44f3286ccc28d149</a>)</p>",
        "id": 204011403,
        "sender_full_name": "cuviper",
        "timestamp": 1594846345
    },
    {
        "content": "<p>which is explained by <a href=\"https://github.com/rust-lang/rust/issues/74113\">#74113</a></p>",
        "id": 204011420,
        "sender_full_name": "cuviper",
        "timestamp": 1594846354
    },
    {
        "content": "<p>yeah, that PR isn't on nightly yet</p>",
        "id": 204011463,
        "sender_full_name": "lcnr",
        "timestamp": 1594846381
    },
    {
        "content": "<p><em>soon</em></p>",
        "id": 204011475,
        "sender_full_name": "cuviper",
        "timestamp": 1594846390
    },
    {
        "content": "<p>Sorry, I need to catch up on all of this discussion, but I think I'm in agreement with the conclusion from what I can see.</p>",
        "id": 204021975,
        "sender_full_name": "varkor",
        "timestamp": 1594852898
    },
    {
        "content": "<p>I wonder if Miri will explode when those tests land^^</p>",
        "id": 204062016,
        "sender_full_name": "RalfJ",
        "timestamp": 1594891531
    },
    {
        "content": "<p>that sometimes happened with new const generic stuff in the past</p>",
        "id": 204062032,
        "sender_full_name": "RalfJ",
        "timestamp": 1594891544
    },
    {
        "content": "<p>wrote a blog post to promote this vision: <a href=\"https://without.boats/blog/shipping-const-generics/\">https://without.boats/blog/shipping-const-generics/</a></p>",
        "id": 204081671,
        "sender_full_name": "boats",
        "timestamp": 1594905522
    },
    {
        "content": "<p>how does the compiler team track proposals like this (to create a new feature gate) nowadays?</p>",
        "id": 204081718,
        "sender_full_name": "boats",
        "timestamp": 1594905548
    },
    {
        "content": "<p>MCPs probably</p>",
        "id": 204081770,
        "sender_full_name": "lcnr",
        "timestamp": 1594905574
    },
    {
        "content": "<p>so same as lang, cool</p>",
        "id": 204081862,
        "sender_full_name": "boats",
        "timestamp": 1594905606
    },
    {
        "content": "<p>yeah</p>",
        "id": 204081870,
        "sender_full_name": "lcnr",
        "timestamp": 1594905611
    },
    {
        "content": "<p><code>impl&lt;T: Debug, const N: usize&gt; Debug for [T; N&gt;</code><br>\nReplace <code>&gt;</code> with <code>]</code></p>",
        "id": 204081984,
        "sender_full_name": "lcnr",
        "timestamp": 1594905668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256759\">@boats</span> hmm, idk how important this is, but instead of <code>[T; {N + M}]</code> I'd give both <code>[T; N + M]</code> and <code>ArrayVec&lt;T, {N + M}&gt;</code> as examples (the braces being necessary only for the latter)</p>",
        "id": 204090324,
        "sender_full_name": "eddyb",
        "timestamp": 1594909485
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I forgot the braces aren't necessary for arrays</p>",
        "id": 204090367,
        "sender_full_name": "boats",
        "timestamp": 1594909510
    },
    {
        "content": "<p>but only in those examples did I forget <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>",
        "id": 204090553,
        "sender_full_name": "boats",
        "timestamp": 1594909577
    },
    {
        "content": "<p>you did use braceless expressions lower down. I've sometimes seen people assume <code>{N}</code> is the name of a <code>const N</code> parameter, or something of the sort, not sure exactly what led to stuff like that</p>",
        "id": 204090606,
        "sender_full_name": "eddyb",
        "timestamp": 1594909599
    },
    {
        "content": "<p>for a while <code>Foo&lt;T, N&gt;</code> didn't work so that's probably part of it I think</p>",
        "id": 204090632,
        "sender_full_name": "eddyb",
        "timestamp": 1594909616
    },
    {
        "content": "<p>anyway not on topic but loving the night mode theme :D</p>",
        "id": 204090725,
        "sender_full_name": "eddyb",
        "timestamp": 1594909658
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/compiler-team/issues/332\">https://github.com/rust-lang/compiler-team/issues/332</a></p>",
        "id": 204096226,
        "sender_full_name": "boats",
        "timestamp": 1594911882
    },
    {
        "content": "<p>any chance we could merge this thread with the MCP thread for that? cc <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span></p>",
        "id": 204098298,
        "sender_full_name": "eddyb",
        "timestamp": 1594912751
    },
    {
        "content": "<p>no idea</p>",
        "id": 204098328,
        "sender_full_name": "simulacrum",
        "timestamp": 1594912767
    },
    {
        "content": "<p>we'd lose the thread here</p>",
        "id": 204098360,
        "sender_full_name": "simulacrum",
        "timestamp": 1594912784
    },
    {
        "content": "<p>I mean worst case you move it to that stream with the current name and then if you rename the topic they get merged</p>",
        "id": 204098368,
        "sender_full_name": "eddyb",
        "timestamp": 1594912789
    },
    {
        "content": "<p>yeah -- I'm just not sure we <em>want</em> to unify them</p>",
        "id": 204098500,
        "sender_full_name": "simulacrum",
        "timestamp": 1594912829
    },
    {
        "content": "<p>alright</p>",
        "id": 204098532,
        "sender_full_name": "eddyb",
        "timestamp": 1594912840
    },
    {
        "content": "<p>I hope stabilizing this is blocked on having a valtree representation and two kinds of CTFE queries (one to get \"raw bytes\" that works for everything, and one to get the valtree that just works for types with \"sufficiently well-behaved equality\")? I'm worried that the current state in rustc might have too many unexpected surprises still lurking somewhere.</p>",
        "id": 204196601,
        "sender_full_name": "RalfJ",
        "timestamp": 1594986569
    },
    {
        "content": "<p>We only want stabilize types represented as <code>ConstValue::Scalar</code>, which shouldn't have to deal with these problems, should it?</p>",
        "id": 204196692,
        "sender_full_name": "lcnr",
        "timestamp": 1594986640
    },
    {
        "content": "<p>or more accurately integers, bool and char</p>",
        "id": 204196722,
        "sender_full_name": "lcnr",
        "timestamp": 1594986660
    },
    {
        "content": "<p>hm I guess... but the entire logic that decides which <code>ConstValue</code> representation to use is a mess, and valtrees would get rid of it</p>",
        "id": 204196885,
        "sender_full_name": "RalfJ",
        "timestamp": 1594986803
    },
    {
        "content": "<p>/me whispers something about pointers being scalars</p>",
        "id": 204204219,
        "sender_full_name": "eddyb",
        "timestamp": 1594991812
    },
    {
        "content": "<p><a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">heretic!</a></p>",
        "id": 204211075,
        "sender_full_name": "RalfJ",
        "timestamp": 1594995524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Is there a reference I could read about \"valtree\"? I haven't heard of it before.</p>",
        "id": 204222442,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1595000818
    },
    {
        "content": "<p>I think <a href=\"https://github.com/rust-lang/compiler-team/issues/323\">https://github.com/rust-lang/compiler-team/issues/323</a> is a good summary</p>",
        "id": 204222550,
        "sender_full_name": "RalfJ",
        "timestamp": 1595000878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I renamed the MCP to \"value tree\"; I hope that's okay</p>",
        "id": 204223080,
        "sender_full_name": "RalfJ",
        "timestamp": 1595001096
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/70889\">https://github.com/rust-lang/rust/issues/70889</a> shows some of the issues with our current approach (the user-visible ones -- the other issue is that it's rather messy internally)</p>",
        "id": 204223092,
        "sender_full_name": "RalfJ",
        "timestamp": 1595001102
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 204223094,
        "sender_full_name": "oli",
        "timestamp": 1595001103
    },
    {
        "content": "<p>hm I now feel like \"scalar tree\" would be even better -- it's a tree of scalars at the leafs...</p>",
        "id": 204229667,
        "sender_full_name": "RalfJ",
        "timestamp": 1595004189
    },
    {
        "content": "<p>but I guess if <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> didnt like \"integer tree\" he wont like \"scalar tree\" either. whatever.^^</p>",
        "id": 204229704,
        "sender_full_name": "RalfJ",
        "timestamp": 1595004221
    },
    {
        "content": "<p>(\"value tree\" sounds like you could e.g. just put \"the value of a union\" into it, which you cannot; that's one of the key points, really)</p>",
        "id": 204229764,
        "sender_full_name": "RalfJ",
        "timestamp": 1595004247
    },
    {
        "content": "<p>IMO the ADT \"nodes\" are more interesting than the leaves</p>",
        "id": 204232489,
        "sender_full_name": "eddyb",
        "timestamp": 1595005783
    },
    {
        "content": "<p>which are just units because natural numbers are ADTs,</p>",
        "id": 204232565,
        "sender_full_name": "eddyb",
        "timestamp": 1595005804
    },
    {
        "content": "<p>(I mean ADT in the product/sum sense that an union isn't)</p>",
        "id": 204232598,
        "sender_full_name": "eddyb",
        "timestamp": 1595005826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/204211075\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\">heretic!</a></p>\n</blockquote>\n<p>it's literally \"Scalar\" in miri</p>",
        "id": 204232656,
        "sender_full_name": "eddyb",
        "timestamp": 1595005855
    },
    {
        "content": "<p>I'm not making stuff up (... am I?)</p>",
        "id": 204232675,
        "sender_full_name": "eddyb",
        "timestamp": 1595005867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> the goal of limiting the types of consts is to not block on that change</p>",
        "id": 204232870,
        "sender_full_name": "boats",
        "timestamp": 1595005992
    },
    {
        "content": "<p>just realized we also should forbid default types for structs with const generic parameters</p>",
        "id": 204318632,
        "sender_full_name": "lcnr",
        "timestamp": 1595107726
    },
    {
        "content": "<p>i.e. forbid <code>struct Foo&lt;T = u32, const N: usize&gt;</code></p>",
        "id": 204318641,
        "sender_full_name": "lcnr",
        "timestamp": 1595107746
    },
    {
        "content": "<p>ref <a href=\"https://github.com/rust-lang/rust/issues/70471\">#70471</a> (which I don't really want to stabilize yet)</p>",
        "id": 204318649,
        "sender_full_name": "lcnr",
        "timestamp": 1595107778
    },
    {
        "content": "<p>isn't that disallowed for the same reason we don't allow <code>&lt;T = u32, U&gt;</code>?</p>",
        "id": 204324177,
        "sender_full_name": "eddyb",
        "timestamp": 1595118280
    },
    {
        "content": "<p>not rn</p>",
        "id": 204337600,
        "sender_full_name": "lcnr",
        "timestamp": 1595144408
    },
    {
        "content": "<p>but we should</p>",
        "id": 204337601,
        "sender_full_name": "lcnr",
        "timestamp": 1595144412
    },
    {
        "content": "<p>we currently don</p>",
        "id": 204421038,
        "sender_full_name": "boats",
        "timestamp": 1595251302
    },
    {
        "content": "<p>*don't allow free ordering among types and consts, right? const params must come after right now?</p>",
        "id": 204421123,
        "sender_full_name": "boats",
        "timestamp": 1595251331
    },
    {
        "content": "<p>yes</p>",
        "id": 204421502,
        "sender_full_name": "oli",
        "timestamp": 1595251566
    },
    {
        "content": "<p>I'm a bit worried at how artificial that is and if we'll end up with some weird assumptions that rely on that order</p>",
        "id": 204425448,
        "sender_full_name": "eddyb",
        "timestamp": 1595253664
    },
    {
        "content": "<p>we already have some assumptions here which cause ICE on unordered parameters (we currently fix this by sorting them)</p>",
        "id": 204428127,
        "sender_full_name": "lcnr",
        "timestamp": 1595254943
    },
    {
        "content": "<p>I also think its probably a good idea to allow consts and types in an arbitrary order, which would also make me more comfortable with allowing type defaults in the future</p>",
        "id": 204428198,
        "sender_full_name": "lcnr",
        "timestamp": 1595254982
    },
    {
        "content": "<p>I think we should allow them in any order, but there were a couple of non-obvious issues with removing that assumption last time I checked (albeit quite a long time ago).</p>",
        "id": 204653023,
        "sender_full_name": "varkor",
        "timestamp": 1595416429
    },
    {
        "content": "<p>i think in the longer term allowing them in any order is probably a good idea. for now i'd just want to make sure that this wont be a breaking change</p>",
        "id": 204670135,
        "sender_full_name": "boats",
        "timestamp": 1595426907
    },
    {
        "content": "<p>Do we want to add the usage restriction of either <code>N</code> or a concrete value also to repeat expressions and enum discriminants?</p>",
        "id": 204717880,
        "sender_full_name": "lcnr",
        "timestamp": 1595449346
    },
    {
        "content": "<p>So rn <code>let _ = [0; std::mem::size_of::&lt;*mut T&gt;()]</code> works on stable.</p>",
        "id": 204717946,
        "sender_full_name": "lcnr",
        "timestamp": 1595449377
    },
    {
        "content": "<p>If we implement this check in name resolution, we either forbid this or don't add this restriction in these cases, which is imo quite inconsistent</p>",
        "id": 204718395,
        "sender_full_name": "lcnr",
        "timestamp": 1595449578
    },
    {
        "content": "<p>we should forbid this anyways IMO, see <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstEvaluatable.60.20generic.20functions/near/204125452\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstEvaluatable.60.20generic.20functions/near/204125452</a> for the relevant discussion and <a href=\"https://github.com/rust-lang/rust/issues/74595\">#74595</a> for a short summary and crater run</p>",
        "id": 204718586,
        "sender_full_name": "lcnr",
        "timestamp": 1595449682
    },
    {
        "content": "<p>im a bit concerned about const fns leaking facts about their bodies like this (and the example with <code>if</code>)</p>",
        "id": 204725100,
        "sender_full_name": "boats",
        "timestamp": 1595453307
    },
    {
        "content": "<p>me too, which is why I opened <a href=\"https://github.com/rust-lang/rust/issues/74595\">#74595</a> <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 204776782,
        "sender_full_name": "lcnr",
        "timestamp": 1595496779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256759\">boats</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/204232870\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> the goal of limiting the types of consts is to not block on that change</p>\n</blockquote>\n<p>fair. looks like we'll have to be careful then.<br>\n(not sure where on <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> 's timeline the valtree change is.)</p>",
        "id": 204787480,
        "sender_full_name": "RalfJ",
        "timestamp": 1595505897
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/rust-lang/rust/issues/74877\">#74877</a> which implements the feature gate and all mentioned restrictions. There are still some annoying problems here, but it's fairly nice to use const generics without having to deal with <code>incomplete_features</code>warning  <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>",
        "id": 205246655,
        "sender_full_name": "lcnr",
        "timestamp": 1595948453
    },
    {
        "content": "<p><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 205259682,
        "sender_full_name": "Lo Lanteri Thauvin",
        "timestamp": 1595954298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> I didn't understand the feature to include any change to associated consts</p>",
        "id": 205343966,
        "sender_full_name": "boats",
        "timestamp": 1596022036
    },
    {
        "content": "<p>can you ellaborate on why your PR impacts that?</p>",
        "id": 205344008,
        "sender_full_name": "boats",
        "timestamp": 1596022073
    },
    {
        "content": "<p>There is a bit more discussion in <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/associated.20consts.20const.20wf\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/associated.20consts.20const.20wf</a></p>",
        "id": 205344055,
        "sender_full_name": "lcnr",
        "timestamp": 1596022087
    },
    {
        "content": "<p>and I will probably revert that change because it's already to late here</p>",
        "id": 205344076,
        "sender_full_name": "lcnr",
        "timestamp": 1596022105
    },
    {
        "content": "<p>(i.e. we can't really do what I wanted without breaking stable code)</p>",
        "id": 205344092,
        "sender_full_name": "lcnr",
        "timestamp": 1596022121
    },
    {
        "content": "<p>thanks, i think it should be separated, but we likely want to treat it as a bug and start a future deprecation cycle</p>",
        "id": 205344383,
        "sender_full_name": "boats",
        "timestamp": 1596022329
    },
    {
        "content": "<p>I am currently trying to write a lang team MCP with both a summary of what const wf is, why we would like to statically enforce this, and how we will do so.</p>",
        "id": 205344404,
        "sender_full_name": "lcnr",
        "timestamp": 1596022348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256759\">boats</span> <a href=\"#narrow/stream/213817-t-lang/topic/stable.20subset.20of.20const.20generics/near/205344383\">said</a>:</p>\n<blockquote>\n<p>thanks, i think it should be separated, but we likely want to treat it as a bug and start a future deprecation cycle</p>\n</blockquote>\n<p>So you want to forbid</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ASSOC</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 205344479,
        "sender_full_name": "lcnr",
        "timestamp": 1596022431
    },
    {
        "content": "<p>The relevant question for <code>T-lang</code> is:</p>\n<blockquote>\n<p>What I am now still unsure of is if we want to restrict associated consts to just <code>N</code> and <code>{ N }</code> for min_const_generics</p>\n</blockquote>",
        "id": 205344669,
        "sender_full_name": "lcnr",
        "timestamp": 1596022590
    },
    {
        "content": "<p>So should we allow more complex expressions using const params in associated consts?</p>",
        "id": 205344678,
        "sender_full_name": "lcnr",
        "timestamp": 1596022605
    },
    {
        "content": "<p>My idea would be that we start warning in the future if we have associated consts without a corresponding const wf bound</p>",
        "id": 205344745,
        "sender_full_name": "lcnr",
        "timestamp": 1596022675
    },
    {
        "content": "<p>but for that I would first want to actually implement const wf bounds, so these warnings are actionable</p>",
        "id": 205344804,
        "sender_full_name": "lcnr",
        "timestamp": 1596022699
    },
    {
        "content": "<p>So it might make sense to restrict any associated consts which use const params to just the param itself until const wf bounds are on stable, where we then both allow more complex usage of const params and warn if the trait impl is missing a const wf bound</p>",
        "id": 205344921,
        "sender_full_name": "lcnr",
        "timestamp": 1596022801
    },
    {
        "content": "<p>I would expect it to allow anything thats allowed in other consts that are not input to the type system</p>",
        "id": 205346683,
        "sender_full_name": "boats",
        "timestamp": 1596023949
    },
    {
        "content": "<p>associated consts are the only consts rn which are not input to the type system and can use generic params afaik</p>",
        "id": 205346812,
        "sender_full_name": "lcnr",
        "timestamp": 1596024038
    },
    {
        "content": "<p>right, other consts can't use params ofc</p>",
        "id": 205356507,
        "sender_full_name": "boats",
        "timestamp": 1596029652
    },
    {
        "content": "<p>yea we need to think through it more</p>",
        "id": 205356530,
        "sender_full_name": "boats",
        "timestamp": 1596029673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326189\">@jknodt</span> opened PR <a href=\"https://github.com/rust-lang/rust/issues/74953\">#74953</a> which removes the ordering restriction on types and const parameters, allowing the following</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Do we want to allow this as part of the MCP? Doing so would not be an implementation challenge so it's mostly up for the lang team to decide</p>",
        "id": 205523733,
        "sender_full_name": "lcnr",
        "timestamp": 1596138332
    },
    {
        "content": "<p>see <a href=\"https://github.com/rust-lang/rust/pull/74953#issuecomment-666640203\">https://github.com/rust-lang/rust/pull/74953#issuecomment-666640203</a></p>",
        "id": 205523741,
        "sender_full_name": "lcnr",
        "timestamp": 1596138340
    },
    {
        "content": "<p>Would the min_const_generics allow the generic int value to be cast to other int types?</p>\n<p>Eg, const generic on <code>u16</code> and then use the value in code with <code>N as usize</code></p>",
        "id": 205563561,
        "sender_full_name": "Lokathor",
        "timestamp": 1596179044
    },
    {
        "content": "<p>no, it allows exactly <code>N</code> and <code>{ N }</code>.</p>",
        "id": 205585250,
        "sender_full_name": "lcnr",
        "timestamp": 1596198923
    },
    {
        "content": "<p>afaik getting these casts right without hacks pretty much requires something like <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/205476289\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/205476289</a>.</p>",
        "id": 205586071,
        "sender_full_name": "lcnr",
        "timestamp": 1596199596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> by \"in code\", do you mean <code>N as usize</code> as a normal value in the body, as opposed to in a generic argument?</p>",
        "id": 205843745,
        "sender_full_name": "scottmcm",
        "timestamp": 1596486619
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">todo</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>is forbidden</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; -&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>is allowed (you can use const params as you like inside of a function, as long as they don't feed back into the type system)</p>",
        "id": 205844051,
        "sender_full_name": "lcnr",
        "timestamp": 1596486769
    },
    {
        "content": "<p>yes i mean in a function body, not a type</p>",
        "id": 205844235,
        "sender_full_name": "Lokathor",
        "timestamp": 1596486866
    },
    {
        "content": "<p>inside of the function body it's allowed, sry for misunderstanding you</p>",
        "id": 205844274,
        "sender_full_name": "lcnr",
        "timestamp": 1596486899
    },
    {
        "content": "<p>Is anyone able to review <a href=\"https://github.com/rust-lang/rust/issues/74877\">#74877</a>?</p>",
        "id": 206016748,
        "sender_full_name": "boats",
        "timestamp": 1596631193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> as to <a href=\"https://github.com/rust-lang/rust/issues/74953\">#74953</a>, I do not think it should be included in the MVP. I think there are concerns once you start allowing mixed ordering and default parameters about backwards compatibility hazards, so I think we should take more time to think through that functionality.</p>",
        "id": 206016860,
        "sender_full_name": "boats",
        "timestamp": 1596631268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> /general </p>\n<p>I removed the restriction on associated consts, meaning that the following now compiles:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#![feature(min_const_generics)]</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ASSOC</span>: <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ASSOC</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 206049231,
        "sender_full_name": "lcnr",
        "timestamp": 1596647060
    },
    {
        "content": "<p>While we probably want to warn here once this can be restricted using const wf bounds, we already allow things like <code>64 / std::mem::size_of::&lt;T&gt;()</code> here which have the same problem. For more details see  <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/associated.20consts.20const.20wf\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/associated.20consts.20const.20wf</a></p>",
        "id": 206049490,
        "sender_full_name": "lcnr",
        "timestamp": 1596647186
    },
    {
        "content": "<p>Can we write a short internals post to get people to test this once it's on nightly?</p>",
        "id": 206049639,
        "sender_full_name": "lcnr",
        "timestamp": 1596647268
    }
]