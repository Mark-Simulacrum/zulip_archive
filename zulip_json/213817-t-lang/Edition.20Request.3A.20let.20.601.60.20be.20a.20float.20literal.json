[
    {
        "content": "<p>What I miss the most from Haskell is honestly just that you can just write <code>1</code> in a floating point position and it'll give you <code>1.0</code> like you wanted instead of giving you a compile error that says \"I know what you meant but you have to put a dot on that number manually\".</p>",
        "id": 196235654,
        "sender_full_name": "Lokathor",
        "timestamp": 1588624049
    },
    {
        "content": "<p>That would be nice, namely <code>let x:f32 = 1;</code> would then work.</p>",
        "id": 196238737,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588625613
    },
    {
        "content": "<p>Potential risk: That would mean that <code>1</code> would be both <code>{integer}</code> and <code>{float}</code>; I'm not sure how that might impact inference.</p>",
        "id": 196259436,
        "sender_full_name": "scottmcm",
        "timestamp": 1588641958
    },
    {
        "content": "<p>I'd propose that, rather than immediately being \"integer or float\" the whole time, it's integer until an integer inference would fail, then at that moment the inference tries to continue as float until either that would also fail or things work out.</p>\n<p>Though that doesn't fully mitigate the problem. It does make for an easy to explain rule at least.</p>",
        "id": 196273268,
        "sender_full_name": "Lokathor",
        "timestamp": 1588661833
    },
    {
        "content": "<p>Inference fallbacks are already fiddly, adding more layers to it seems scary. What if we just said the <code>{integer}</code> pseudo-type can be constrained to any concrete float or int type, instead of just any concrete int type? Is there any situation where \"this is some float or int type, don't know which one yet\" leads to ambiguities but \"this is some int type, don't know which one yet\" doesn't?</p>",
        "id": 196275882,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588664285
    },
    {
        "content": "<blockquote>\n<p>Is there any situation where \"this is some float or int type, don't know which one yet\" leads to ambiguities but \"this is some int type, don't know which one yet\" doesn't?</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mf\">5.</span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// inference breakage if `{float}` has same priority as `{int}`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196284085,
        "sender_full_name": "kennytm",
        "timestamp": 1588670019
    },
    {
        "content": "<p>Okay, good point. Next question: is this something that is at all common in the real world? I recall a similar problem exists with allowing slice/array indexing with integer types other than <code>usize</code>, but I can't think of any cases where <em>one</em> integer type <em>and</em> some float types are an option. Much more common are \"several/all int types\" and \"all numeric types (ints and floats)\".</p>",
        "id": 196284807,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588670511
    },
    {
        "content": "<p>There's also that at least some users may expect that 0 or 1 is an integer and 0.0 or 1.0 is a float.</p>",
        "id": 196316235,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588689344
    },
    {
        "content": "<p>There's the standard tension between wanting the compiler to DWIM and wanting types kept strictly separated.</p>",
        "id": 196316424,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588689401
    },
    {
        "content": "<p>well, in this instance, the type would be clearly assigned and not \"mixable\"</p>",
        "id": 196316507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588689434
    },
    {
        "content": "<p>I think that whenever this topic comes up, it behooves us to be very clear about the obstacles we're wary of</p>",
        "id": 196316538,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588689451
    },
    {
        "content": "<p>\"this topic\" here means specifically \"the tension about DWIM vs being strict\"</p>",
        "id": 196316703,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588689510
    },
    {
        "content": "<p>The common case that I encounter is that you're doing an operation, <code>x+=1</code> for example, and <code>x</code> has a type already and so there's no question as to what type <code>1</code> must be for the expression to become valid. Any type but a particular type is a compilation error.</p>",
        "id": 196331201,
        "sender_full_name": "Lokathor",
        "timestamp": 1588695873
    },
    {
        "content": "<p>Right. The question then becomes, is the desired behavior \"compilation error\". For some users it may be.</p>",
        "id": 196333764,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588697110
    },
    {
        "content": "<p>note though that we could plausibly solve that problem through a <code>Add</code> impl, though maybe not</p>",
        "id": 196335460,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588697926
    },
    {
        "content": "<p>we have some limitations to the set of impls we can add</p>",
        "id": 196335473,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588697932
    },
    {
        "content": "<p>@Josh: Sure, and that's perhaps a reasonable thing to want. I was more responding to Hanna's question of \"what are the real world examples of this?\"</p>\n<p>If people <em>do</em> want to be extra hardline about things perhaps converting an int literal into being a float literal could also fire off an allow-by-default lint that a project could change to deny by default.</p>\n<p>The Haskell community does get along just fine with <code>1 + 5.4</code> evaluating to <code>6.4</code> (also C and Python and basically the whole rest of the world, but Haskell specifically has a similar mentality to Rust of \"absolute minimal implicit conversions\")</p>\n<p>@Niko: Well also: fields in a struct when you're initializing with a literal, or function args when you pass a literal to a function.</p>",
        "id": 196335800,
        "sender_full_name": "Lokathor",
        "timestamp": 1588698065
    },
    {
        "content": "<p>re: \"keep strictly separated\", I think my main concern here would be precision loss</p>",
        "id": 196690999,
        "sender_full_name": "RalfJ",
        "timestamp": 1588796167
    },
    {
        "content": "<p>so even if <code>1</code> becomes \"float or int\", I think integers that cannot be precisely represented in the target float point must <em>not</em> be turned into floats implicitly</p>",
        "id": 196691032,
        "sender_full_name": "RalfJ",
        "timestamp": 1588796188
    },
    {
        "content": "<p>such loss of information should at least be explicitly acknowledged by appending <code>.0</code></p>",
        "id": 196691071,
        "sender_full_name": "RalfJ",
        "timestamp": 1588796206
    },
    {
        "content": "<p>if we adopt that, since we are already accepting that  <code>5</code> might considered an element of <code>i32</code> or <code>u8</code>, I dont see any harm in also freely considering it an element of <code>f32</code> -- I dont think signed 32-bit and unsigned 8-bit integers are conceptually <em>that</em> much closer to each other than to <code>f32</code> to justify the distinction. people that want strict type separation should already be writing <code>5i32</code> for extra explicitness.</p>",
        "id": 196691248,
        "sender_full_name": "RalfJ",
        "timestamp": 1588796293
    },
    {
        "content": "<p>Right, i suppose i was also assuming that the \"overflowing literals\" lint would apply here, the same as you can't use <code>0xFFF</code> in a <code>u8</code> position.</p>",
        "id": 196725138,
        "sender_full_name": "Lokathor",
        "timestamp": 1588824024
    },
    {
        "content": "<p>speaking of which, if <code>123</code> can be considered an <code>f32</code>, can <code>0xff</code> / <code>0o777</code> / <code>0b1010</code> be also be considered an <code>f32</code></p>",
        "id": 196729165,
        "sender_full_name": "kennytm",
        "timestamp": 1588830270
    },
    {
        "content": "<p>oof that's a big can of worms.</p>",
        "id": 196731170,
        "sender_full_name": "Lokathor",
        "timestamp": 1588832954
    },
    {
        "content": "<p>I would say not since the reason for using binary, or octal, or hex is generally because you care about specific bit locations</p>",
        "id": 196769842,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588858223
    },
    {
        "content": "<p>Advanced float math actually does use hex float literals because \"advanced float math\" means \"very carefully weave the line between what CPUs do and how IEEE works\".</p>",
        "id": 196788243,
        "sender_full_name": "Lokathor",
        "timestamp": 1588865554
    },
    {
        "content": "<p>That said if we didn't have hex float literals in the \"first round\" of this change, or even ever, it'd be fine. You can use the \"const union hack\" in that rare case.</p>",
        "id": 196788366,
        "sender_full_name": "Lokathor",
        "timestamp": 1588865602
    },
    {
        "content": "<p>It sounds like you're referring to e.g. specifying the smallest subnormal as <code>0x0000_0001</code> (which you can express today with <code>fN::from_bits</code>), but extrapolating the \"<code>1</code> as float literal\" feature to integer hexadecimal literals would instead suggest e.g. <code>0xff == 255.0</code> (which you can express today with <code>as</code> casts).</p>",
        "id": 196788894,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588865825
    },
    {
        "content": "<p>I assumed everyone was referring to the latter. Making <code>let x: f32 = 0xff;</code> do something different from <code>let x: f32 = 255;</code> (if both work) seems very confusing.</p>",
        "id": 196789087,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588865895
    },
    {
        "content": "<p>one issue:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">123</span><span class=\"p\">;</span><span class=\"w\">       </span><span class=\"c1\">// proposed for 2021.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">123_</span><span class=\"k\">f32</span><span class=\"p\">;</span><span class=\"w\">   </span><span class=\"c1\">// works in 2015.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0xff</span><span class=\"p\">;</span><span class=\"w\">      </span><span class=\"c1\">// proposed for 2021.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0xff_f32</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// errrr....</span>\n</code></pre></div>",
        "id": 196790950,
        "sender_full_name": "kennytm",
        "timestamp": 1588866704
    },
    {
        "content": "<p>ohno.jpg</p>",
        "id": 196792348,
        "sender_full_name": "Lokathor",
        "timestamp": 1588867252
    },
    {
        "content": "<p>I would say that it would be better to do:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">123</span><span class=\"p\">;</span><span class=\"w\">       </span><span class=\"c1\">// proposed for 2021.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">123_</span><span class=\"k\">f32</span><span class=\"p\">;</span><span class=\"w\">   </span><span class=\"c1\">// works in 2015.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0xff</span><span class=\"p\">;</span><span class=\"w\">      </span><span class=\"c1\">// errors now and in 2021</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0xff_f32</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// ^^^</span>\n</code></pre></div>",
        "id": 196793125,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588867556
    },
    {
        "content": "<p>Would people think that we have had enough discussion to write up an RFC.</p>\n<p>I see the following points:</p>\n<ol>\n<li>Allow for base 10 numeric literals to be interpreted by the compiler as <code>{float}</code> if interpreting it as <code>{integer}</code> results in a type error. If both result in a type error, <em>only</em> report the <code>{integer}</code> type error.</li>\n<li>Implement an <code>allow-by-default</code> lint for the above feature so that project that do not want to have this can disable it.</li>\n</ol>",
        "id": 196795827,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588868751
    },
    {
        "content": "<p>I agree with those points but I already am looking after about 1.5 RFCs so I wouldn't want to take on another right now.</p>",
        "id": 196795930,
        "sender_full_name": "Lokathor",
        "timestamp": 1588868803
    },
    {
        "content": "<p>I would be fine doing the writeup</p>",
        "id": 196796173,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588868939
    },
    {
        "content": "<p>There's a lang meeting later today and I'm not on the lang team but I can point them in the direction of this topic for them to check out when they get the time.</p>",
        "id": 196796253,
        "sender_full_name": "Lokathor",
        "timestamp": 1588868997
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;f32&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;f64&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mf\">1.0.</span><span class=\"n\">g</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// currently prints &quot;f64&quot;</span>\n<span class=\"w\">    </span><span class=\"mf\">1.</span><span class=\"n\">g</span><span class=\"p\">();</span><span class=\"w\">   </span><span class=\"c1\">// type error or print &quot;f64&quot;?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196796257,
        "sender_full_name": "kennytm",
        "timestamp": 1588868998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I think I'm still trying to wrap my head around the use case for this. The goal here is to...avoid typing <code>.0</code>?</p>",
        "id": 196802914,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588872052
    },
    {
        "content": "<p>And in exchange for that, we get potential new inference issues and what seems like a lot of complexity?</p>",
        "id": 196802971,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588872088
    },
    {
        "content": "<p>What am I missing?</p>",
        "id": 196802980,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588872091
    },
    {
        "content": "<p>(That's leaving aside whether we <em>want</em> the compiler to accept <code>1</code> as a float, which I personally would prefer it didn't, but for the purposes of the questions above I'm ignoring that for the moment.)</p>",
        "id": 196803083,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588872136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125254\">@kennytm</span> Since it is only implemented for <code>f32</code> and <code>f64</code> the behaviour between <code>1.0.g()</code> and <code>1.g()</code> should be the same</p>",
        "id": 196805027,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588873013
    },
    {
        "content": "<p>so there would be 4 levels of inference: <code>i32 &gt; {integer} &gt; f64 &gt; {float}</code></p>",
        "id": 196805165,
        "sender_full_name": "kennytm",
        "timestamp": 1588873077
    },
    {
        "content": "<p>I don't know, in edition 2015 and 2018 are there already two for <code>1</code> and a different two for <code>1.0</code>?</p>",
        "id": 196806357,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588873617
    },
    {
        "content": "<p>in 2018 for <code>1</code> it is <code>i32 &gt; {integer}</code> and for <code>1.0</code> it is <code>f64 &gt; {float}</code></p>",
        "id": 196806629,
        "sender_full_name": "kennytm",
        "timestamp": 1588873734
    },
    {
        "content": "<p>if <code>1.g()</code> is compilation error, we get 3 levels for 2021 <code>i32 &gt; {integer} &gt; {float}</code></p>",
        "id": 196806680,
        "sender_full_name": "kennytm",
        "timestamp": 1588873769
    },
    {
        "content": "<p>Well I think that it would be much more confusing if <code>1.g()</code> was a compilation error.</p>",
        "id": 196820455,
        "sender_full_name": "Sebastian Malton",
        "timestamp": 1588880236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> one time I've wanted this is when implementing something by macro for both integers and floats -- then it's annoying that I can't write a literal that works with both.</p>",
        "id": 196849848,
        "sender_full_name": "cuviper",
        "timestamp": 1588901047
    },
    {
        "content": "<p>not a big deal to work around though</p>",
        "id": 196849853,
        "sender_full_name": "cuviper",
        "timestamp": 1588901056
    },
    {
        "content": "<p>Right, it's not the worst thing, but nearly every other major language lets you do it.</p>",
        "id": 196854467,
        "sender_full_name": "Lokathor",
        "timestamp": 1588908183
    },
    {
        "content": "<p>Other weakly typed languages definitely. Do other strongly typed languages?</p>",
        "id": 196854615,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588908461
    },
    {
        "content": "<p>Yes, Haskell does.</p>",
        "id": 196854935,
        "sender_full_name": "Lokathor",
        "timestamp": 1588909053
    },
    {
        "content": "<p>In Haskell, any integer literal <code>n</code> is effectively the expression <code>fromInteger n</code> and has the type <code>Num a =&gt; a</code></p>\n<p>or in approximate Rust terms, <code>n: impl Num</code></p>",
        "id": 196855107,
        "sender_full_name": "Lokathor",
        "timestamp": 1588909330
    },
    {
        "content": "<p>and you can further constrain a particular literal of course, making it Int32 or Float or whatever specific number type</p>",
        "id": 196855120,
        "sender_full_name": "Lokathor",
        "timestamp": 1588909387
    },
    {
        "content": "<p>I'm aware of what Haskell does. For the benefit of something like the macro case, we could easily add something like fromInteger. The question is whether we should do so by default.</p>",
        "id": 196857213,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588912512
    },
    {
        "content": "<blockquote>\n<p>Other weakly typed languages definitely. Do other strongly typed languages?</p>\n</blockquote>\n<p>perhaps this question is more about what languages do <strong>not</strong> allow <code>1</code> as float. </p>\n<p>Swift, Go, C#, Scala all can accept the dotless literal as float, not to mention C++ (\"weak\"), Python, TypeScript (no clear distinction between int and float), Haskell (see above).</p>",
        "id": 196861161,
        "sender_full_name": "kennytm",
        "timestamp": 1588918696
    },
    {
        "content": "<p>FWIW, at least C# and Python don't really \"allow <code>1</code> as float\" but rather have implicit conversions from ints to floats that affect all runtime values (not specifically literals). Well, Python doesn't have \"implicit conversions\" per se, but essentially all operators and functions that expect floats will gladly accept anything with a <code>__float__</code> method.</p>",
        "id": 196865615,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588923098
    },
    {
        "content": "<p>ok that means C# is \"weak\".</p>",
        "id": 196865927,
        "sender_full_name": "kennytm",
        "timestamp": 1588923371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Edition.20Request.3A.20let.20.601.60.20be.20a.20float.20literal/near/196788243\" title=\"#narrow/stream/213817-t-lang/topic/Edition.20Request.3A.20let.20.601.60.20be.20a.20float.20literal/near/196788243\">said</a>:</p>\n<blockquote>\n<p>Advanced float math actually does use hex float literals because \"advanced float math\" means \"very carefully weave the line between what CPUs do and how IEEE works\".</p>\n</blockquote>\n<p>there's also binary float literals to directly control the float bits which rust unfortunately does not support (but there's a crate for it)</p>",
        "id": 196867932,
        "sender_full_name": "RalfJ",
        "timestamp": 1588925001
    },
    {
        "content": "<p>A bit of history:</p>\n<p>When I first started working on Rust, the expression <code>22</code> <em>always</em> had type <code>isize</code> (then called <code>int</code>). You had to explicitly write <code>22_u32</code>. When we changed it to do inference, there was vociferous resistance, because things had to be explicit. We settled on inference and a lint for 'oversized' literals that don't fit the type they are ultimately inferred to be. (I actually.. am not entirely sure why a lint and not a hard error, I think there was some use case to sometimes abuse 2's complement notation or something..?)</p>",
        "id": 196879691,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588934225
    },
    {
        "content": "<p>In particular, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>, I want to push back on the notion that allowing <code>22</code> to be inferred to be <code>22.0</code> is truly \"loosely typed\". I think you can say that C's implicit upcasting of types and so forth is definitely loose, but inferring a fixed float type seems much different. (EDIT: Re-reading, I realize that you didn't say that it was loosely typed, though I think a connection was implied.)</p>",
        "id": 196879810,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588934317
    },
    {
        "content": "<p>I guess it'd be good to list out specific errors you can get that <em>can't</em> be addressed through a lint that checks for extreme floating point issues (e.g., a number that can't be represented)</p>",
        "id": 196880309,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588934676
    },
    {
        "content": "<blockquote>\n<p>I guess it'd be good to list out specific errors you can get that can't be addressed through a lint that checks for extreme floating point issues (e.g., a number that can't be represented)</p>\n</blockquote>\n<p>Things like this feel both undesirable and inevitable if we allow float literals afaict. (if somewhat artificial tbh)</p>\n<div class=\"codehilite\"><pre><span></span><code>trait Foo {}\nimpl Foo for f32 {}\nfn consume(_: impl Foo) {}\nfn main() {\n    consume(20_000_000 + 1); // When using f32, this calls consume with 20_000_000\n}\n</code></pre></div>",
        "id": 196884452,
        "sender_full_name": "lcnr",
        "timestamp": 1588937742
    },
    {
        "content": "<p>I'm not sure why that feels undesirable</p>",
        "id": 196885085,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588938207
    },
    {
        "content": "<p>it's the arithmetic?</p>",
        "id": 196885123,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588938231
    },
    {
        "content": "<p>oh, I see the comment</p>",
        "id": 196885175,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588938246
    },
    {
        "content": "<p>ok, that's helpful :)</p>",
        "id": 196885183,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588938250
    },
    {
        "content": "<p>although.. hmm.. I'm not sure ultimately it's any <em>more</em> surprising than 20_000_000.0 + 1.0 (EDIT: upon reflection I don't agree with this statement of mine; the <code>.0</code> is an obvious \"tell\" when inspecting the caller, without needing to look at the definition of <code>consume</code>)</p>",
        "id": 196885239,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588938293
    },
    {
        "content": "<p>or <code>255 + 1</code> where you have <code>impl Foo for u8</code></p>",
        "id": 196885288,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588938325
    },
    {
        "content": "<blockquote>\n<p>or <code>255 + 1</code> where you have <code>impl Foo for u8</code></p>\n</blockquote>\n<p>That's a good point. I still think it's worse for floats, as integer overflow is far more noticeable <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <br>\nI also really dislike floats in general, so I am somewhat biased here.</p>",
        "id": 196886296,
        "sender_full_name": "lcnr",
        "timestamp": 1588939034
    },
    {
        "content": "<p>^ A worse example  is <code>consume(20_000_000 + 1 + 1)</code>. Even if consume should take a f32 here, there is an actual difference between <code>(20_000_000 + 1 + 1) as f32</code> and <code>20_000_000.0 + 1.0 + 1.0</code>.</p>",
        "id": 196886754,
        "sender_full_name": "lcnr",
        "timestamp": 1588939340
    },
    {
        "content": "<p>Yeah, I definitely think there's an argument to be made for \"the surprise factor of floats is so high that they are qualitatively different than integers\" (and I think these examples are a good way to make it). That, combined with \"floats are needed an order of magnitude less often\" is perhaps enough to tilt the balance away from the surprise factor of \"wait? there's a difference between 1 and 1.0?\" (I've definitely sometimes spent time scratching my head over that...even though I ought to know better.)</p>",
        "id": 196887384,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588939821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Edition.20Request.3A.20let.20.601.60.20be.20a.20float.20literal/near/196802914\" title=\"#narrow/stream/213817-t-lang/topic/Edition.20Request.3A.20let.20.601.60.20be.20a.20float.20literal/near/196802914\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> I think I'm still trying to wrap my head around the use case for this. The goal here is to...avoid typing <code>.0</code>?</p>\n</blockquote>\n<p>Just to respond to this, too, I think it's not fair to characterize as \"avoid typing\". The goal is to make numbers in Rust behave more like numbers in the real world, I imagine, and to avoid the \"ergonomic hit\" of compilation cycles driven just by \"oh yeah gotta add a <code>.0</code> to please the compiler\". Those cycles may be worthwhile, but I think the burden of proof should fall on us to show <em>it's worth it to force you to change your code, because it prevents bugs</em> (or <em>is easier to understand</em> or <em>can be implemented</em> or whatever), and not the reverse.</p>",
        "id": 196908568,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588951174
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I appreciate the explanation in those terms. To clarify something, that was intended as a genuine question. I didn't understand the use case for this at all, and my question was intended as \"I must be missing something here\".</p>",
        "id": 196925529,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588958961
    },
    {
        "content": "<p>Separate from that, I do think your phrasing of \"the surprise factor of floats is so high that they are qualitatively different than integers\" is a much better way of putting my argument that I don't think we should let one token infer to either int or float, without stating that.</p>",
        "id": 196925718,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588959042
    },
    {
        "content": "<p>I do think, for uses such as macros, we may need a way of writing \"1 or 1.0, whichever the expression needs\". But I'm inclined to make that <code>1.to_num()</code> or <code>1.into()</code>, not just <code>1</code>.</p>",
        "id": 196925844,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588959106
    },
    {
        "content": "<p>Having just written a pile of code that uses <code>as</code> in many places (far more than I'd like), I think I can also further elaborate in response to the notion of \"gotta add a <code>.0</code> to please the compiler\". The question is, how often is the response \"just add <code>.0</code>\", and how often is the response going to be \"yikes, it's a float? I need to think about this harder\". Because with the mixing of integer types, it turns out that when I had a <code>u64</code> and needed a <code>u32</code>, the answer was almost never \"gotta add <code>as u32</code> to please the compiler\", but rather \"hrm, how do I handle this, let me work backwards and figure out if the original thing should have been a u32 to begin with\".</p>",
        "id": 196926142,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588959260
    },
    {
        "content": "<p>Well, I started this topic when I'd just written 200+ doc tests with math in them that, on a test by test basis, used floating point and integer types of all sizes. And it really started to show the fiddly weaknesses involved (eg: <code>from</code> often also has very poor errors). And now I'm up to 409 doc tests any my position has not changed at all.</p>\n<p>To answer your most recent question there:</p>\n<ul>\n<li>when using bound variables I quite often need to change data types with <code>as</code> or other methods, and sometimes it gives me pause and I reconsider a bit, perhaps convert all values to a common type before getting started with the math.</li>\n<li>However when using literals I have never ever typed an integer, been told i needed a float there, and then and then changed the code to accommodate this new information and then changed the code in some way other than to add the .0 and immediately hit <em>compile</em>.</li>\n</ul>\n<p>I am sympathetic to the \"20 million + 1\" problem. However, that's also mostly a slightly separate problem with how float literals work. This example here:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">20_000_001.0_</span><span class=\"k\">f32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Will print <code>20000000</code> with no warning that your literal can't be exactly represented within <code>f32</code>.</p>\n<p>So my own opinion is that <code>20_000_000+1</code> should fold to <code>20_000_001: {integer}</code> and then as the next step turning that integer to an f32 should fire off a warning that the value can't be exactly represented within the f32 type. However I also expect that such a system could then lead to some other edge case.</p>",
        "id": 196930252,
        "sender_full_name": "Lokathor",
        "timestamp": 1588961198
    },
    {
        "content": "<p>we can detect at const prop time that <code>20_000_000.0_f32 + 1.0</code> does not do anything</p>",
        "id": 196930569,
        "sender_full_name": "oli",
        "timestamp": 1588961366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I do think there's value in warning when literal values can't be represented precisely.</p>",
        "id": 196930761,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588961464
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 196930826,
        "sender_full_name": "Lokathor",
        "timestamp": 1588961499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> but this kind of thing can happen in \"ordinary\" computations that happen to become elegible for const prop, so warning about it is on shaky ground / likely to give false positives</p>",
        "id": 196930913,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588961531
    },
    {
        "content": "<p>indeed, that is a problem, but the above example seems awefully rare, I would expect this to only be an issue when more complexity is involved, as it isn't obvious to the user what's going on</p>",
        "id": 196931214,
        "sender_full_name": "oli",
        "timestamp": 1588961688
    },
    {
        "content": "<p>does float math even run at const time? I thought it did not and would never because of the dreaded non-determinism</p>",
        "id": 196931306,
        "sender_full_name": "Lokathor",
        "timestamp": 1588961746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> GCC, at least, runs float math at compile time, and has some very careful libraries that exist to do so deterministically.</p>",
        "id": 196931517,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588961843
    },
    {
        "content": "<p>To be clear I would love to have floats at const times  and even to emulate float intrinsics at compile time, and so on.</p>\n<p>I was just previously told by various folks that it is (loosely) \"probably never gonna happen, because it's non-determinism\"</p>",
        "id": 196931773,
        "sender_full_name": "Lokathor",
        "timestamp": 1588961993
    },
    {
        "content": "<p>idk what const prop does or should do, but for better or worse, float arithmetic in constant expressions <em>is</em> supported.</p>",
        "id": 196932198,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588962208
    },
    {
        "content": "<p>since <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5eb83b14d13b63470af9336e9b2ae459\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5eb83b14d13b63470af9336e9b2ae459\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5eb83b14d13b63470af9336e9b2ae459</a> compiles, we can be sure that it works at const eval time. We may not be doing it at const prop time, but we most definitely could</p>",
        "id": 196932199,
        "sender_full_name": "oli",
        "timestamp": 1588962211
    },
    {
        "content": "<p>It's supported in a const declaration expression but not a const fn body.</p>",
        "id": 196932320,
        "sender_full_name": "Lokathor",
        "timestamp": 1588962286
    },
    {
        "content": "<p>well, <em>stable</em> that is.</p>\n<p>anyway that's maybe a little off topic for this particular thread.</p>",
        "id": 196932513,
        "sender_full_name": "Lokathor",
        "timestamp": 1588962393
    },
    {
        "content": "<p>By the way, this thread is making me think.</p>",
        "id": 196933518,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962918
    },
    {
        "content": "<p>I want to beef up the lang-team website to have a lot more info</p>",
        "id": 196933531,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962930
    },
    {
        "content": "<p>including design notes and thoughts that collect over time about particular questions</p>",
        "id": 196933541,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962937
    },
    {
        "content": "<p>I was thinking that after major threads like this that occur on Zulip, we should make a point to write-up conclusions</p>",
        "id": 196933558,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962950
    },
    {
        "content": "<p>I'm going to try and do just a bit of that for this thread</p>",
        "id": 196933575,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962956
    },
    {
        "content": "<p>to show what I mean, but I think it should be standard practice -- in fact, i'm even getting grandiose ideas of trying to create a set of \"wg-scribes\" or something who generally have that role</p>",
        "id": 196933657,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962993
    },
    {
        "content": "<p>but let's start small :)</p>",
        "id": 196933664,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588962999
    },
    {
        "content": "<p>I'm sick of having the same conversations over and over and rediscovering the same constraints :P</p>",
        "id": 196933693,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588963016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Edition.20Request.3A.20let.20.601.60.20be.20a.20float.20literal/near/196931517\" title=\"#narrow/stream/213817-t-lang/topic/Edition.20Request.3A.20let.20.601.60.20be.20a.20float.20literal/near/196931517\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> GCC, at least, runs float math at compile time, and has some very careful libraries that exist to do so deterministically.</p>\n</blockquote>\n<p>We use <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> 's Rust port of LLVM's libapfloat for this</p>",
        "id": 196934278,
        "sender_full_name": "RalfJ",
        "timestamp": 1588963322
    },
    {
        "content": "<p>so, I think basically the same as GCC</p>",
        "id": 196934301,
        "sender_full_name": "RalfJ",
        "timestamp": 1588963328
    },
    {
        "content": "<p>well, the same as Clang, but yeah :P</p>",
        "id": 196934339,
        "sender_full_name": "eddyb",
        "timestamp": 1588963353
    },
    {
        "content": "<p>I mean on the level of \"careful lib for deterministic float math\"</p>",
        "id": 196934374,
        "sender_full_name": "RalfJ",
        "timestamp": 1588963370
    },
    {
        "content": "<p>Miri-the-tool will use host float operations to fill in some gaps in libapfloat, but rustc itself will never do that</p>",
        "id": 196934422,
        "sender_full_name": "RalfJ",
        "timestamp": 1588963401
    },
    {
        "content": "<blockquote>\n<p>we can detect at const prop time that 20_000_000.0_f32 + 1.0 does not do anything</p>\n</blockquote>\n<p>This is not always possible though <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Delegate</span>: <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">bar</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span><span class=\"n\">Delegate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">consume</span><span class=\"p\">(</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"mi\">20_000_000</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>edit: fixed the example</p>",
        "id": 196934433,
        "sender_full_name": "lcnr",
        "timestamp": 1588963409
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> btw <code>rustc_apfloat</code>:</p>\n<ul>\n<li>only uses non-<code>core</code> functionality (heap allocation) for string&lt;-&gt;float conversions (<code>core</code>'s own <code>FromStr</code> uses stack-allocated bigints, maybe I should try that)</li>\n<li>has <code>#![forbid(unsafe_code)]</code></li>\n<li>has no global state</li>\n</ul>",
        "id": 196935637,
        "sender_full_name": "eddyb",
        "timestamp": 1588964040
    },
    {
        "content": "<p>AFAIK this effectively makes it \"pure\" :P</p>",
        "id": 196935694,
        "sender_full_name": "eddyb",
        "timestamp": 1588964050
    },
    {
        "content": "<p>might be able to start using <code>const fn</code> in it except for traits (<code>Iterator</code> is the worst I guess)</p>",
        "id": 196935810,
        "sender_full_name": "eddyb",
        "timestamp": 1588964101
    },
    {
        "content": "<p>(don't copy what core::dec2flt does, it has arbitrary limitations and is much slower than it has to be)</p>",
        "id": 196936056,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588964200
    },
    {
        "content": "<p>I strongly suspect <code>rustc_apfloat</code> is slower given how naive it is, but if I would do the stack thing, it would probably be behind a <code>not(feature(alloc))</code> or something</p>",
        "id": 196936177,
        "sender_full_name": "eddyb",
        "timestamp": 1588964253
    },
    {
        "content": "<p>Much of the slowness in the libcore impl is in the bignum operations, fwiw</p>",
        "id": 196936433,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1588964367
    },
    {
        "content": "<p>I didn't implement any of the APInt optimizations for e.g. division, except for short division (idk if they have it as a special case or what), which is when your divisor fits in whatever bigint unit (\"limb\") you're using, true for most of the common divisors</p>",
        "id": 196936952,
        "sender_full_name": "eddyb",
        "timestamp": 1588964614
    },
    {
        "content": "<p>and that was to fix a regression when we switched to <code>rustc_apfloat</code> :P</p>",
        "id": 196937241,
        "sender_full_name": "eddyb",
        "timestamp": 1588964760
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> on using something like <code>1.into()</code>, you still need a type for that <code>1</code> -- <code>u8</code> works into everything but <code>i8</code></p>",
        "id": 196937700,
        "sender_full_name": "cuviper",
        "timestamp": 1588964998
    },
    {
        "content": "<p><code>1 as $num</code> is the lazy macro solution</p>",
        "id": 196937886,
        "sender_full_name": "cuviper",
        "timestamp": 1588965087
    },
    {
        "content": "<p><code>$num</code>?</p>",
        "id": 196938045,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588965167
    },
    {
        "content": "<p>Is that a macro argument supplying the type?</p>",
        "id": 196938085,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588965187
    },
    {
        "content": "<p>OK folks</p>",
        "id": 196939712,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588966062
    },
    {
        "content": "<p>I created this PR that summarizes some key points and takeaways: </p>\n<p><a href=\"https://github.com/rust-lang/lang-team/pull/16\" title=\"https://github.com/rust-lang/lang-team/pull/16\">https://github.com/rust-lang/lang-team/pull/16</a></p>",
        "id": 196939736,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588966073
    },
    {
        "content": "<p>It is by no means exhaustive. I would <em>love</em> it if people who participated in this meeting went and suggested edits.</p>",
        "id": 196939799,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588966089
    },
    {
        "content": "<p>As I was saying, I think that -- eventually -- every substantial conversation that takes place here  should conclude with a PR of this kind that updates and records the information :)</p>",
        "id": 196939824,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588966110
    },
    {
        "content": "<p>but let's just start with this one</p>",
        "id": 196939832,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588966115
    },
    {
        "content": "<p>Good summary, thank you.</p>",
        "id": 196939940,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588966168
    },
    {
        "content": "<p>That'll help the next time this comes up.</p>",
        "id": 196939963,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588966184
    },
    {
        "content": "<p>It doesn't have a conclusion, but then, neither did the discussion here.</p>",
        "id": 196939995,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588966196
    },
    {
        "content": "<p>Indeed, it wasn't meant to \"conclude\"</p>",
        "id": 196942200,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588967343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I was concerned I didn't capture the \"pro\" side very well btw :)</p>",
        "id": 196944984,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588968736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> yes I meant that like a macro argument <code>$num:ty</code></p>",
        "id": 196950767,
        "sender_full_name": "cuviper",
        "timestamp": 1588972042
    },
    {
        "content": "<p>hm you might even be able to get away with \"5 as _\" right?</p>",
        "id": 196950938,
        "sender_full_name": "simulacrum",
        "timestamp": 1588972148
    },
    {
        "content": "<p>/me stares.</p>",
        "id": 196951056,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588972204
    },
    {
        "content": "<p>/me stares harder.</p>",
        "id": 196951066,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588972207
    },
    {
        "content": "<p>/me is impressed with Rust type inference.</p>",
        "id": 196951117,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588972239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <code>as _</code> would probably work, but I usually do have the type at hand because I'm writing some <code>impl XYZ for $num</code></p>",
        "id": 196951575,
        "sender_full_name": "cuviper",
        "timestamp": 1588972505
    },
    {
        "content": "<p>sure, yes</p>",
        "id": 196951584,
        "sender_full_name": "simulacrum",
        "timestamp": 1588972512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I can comment on the PR later perhaps with more persuasive words. My ISP is dead right now and I was hoping it would be fixed around the top of the hour but it was not. Until then I'm stuck on just a phone.</p>",
        "id": 196954461,
        "sender_full_name": "Lokathor",
        "timestamp": 1588974571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> ok -- I may also just land and you can open a follow-up PR</p>",
        "id": 196954657,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588974708
    },
    {
        "content": "<p>yeah no worries</p>",
        "id": 196954709,
        "sender_full_name": "Lokathor",
        "timestamp": 1588974728
    },
    {
        "content": "<p>with <code>5 as _</code> you may end up with <code>5 as *const String</code> if you can't control the <code>$num</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 196977117,
        "sender_full_name": "kennytm",
        "timestamp": 1589006949
    }
]