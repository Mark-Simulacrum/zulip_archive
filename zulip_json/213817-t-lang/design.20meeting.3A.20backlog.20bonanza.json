[
    {
        "content": "<p>Hey <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> -- backlog bonanza!</p>",
        "id": 268580013,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1642615439
    },
    {
        "content": "<p>Was there a hackmd for this? I usually like to read it over</p>",
        "id": 268588727,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642619305
    },
    {
        "content": "<p><a href=\"https://hackmd.io/hVAVy77xTnKmDtgy3DMjAg?edit\">https://hackmd.io/hVAVy77xTnKmDtgy3DMjAg?edit</a></p>",
        "id": 268588783,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642619336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> and I planned to do backlog bonanza today -- but I'm not able to join!</p>",
        "id": 269451189,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643218811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Is there a Zoom meeting setting for \"let the meeting start without me\"?</p>",
        "id": 269454583,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643220070
    },
    {
        "content": "<p>Meanwhile, we'll need something other than Zoom.</p>",
        "id": 269454632,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643220087
    },
    {
        "content": "<p>I can spin up a google meet</p>",
        "id": 269455225,
        "sender_full_name": "simulacrum",
        "timestamp": 1643220291
    },
    {
        "content": "<p><a href=\"https://meet.google.com/egs-ouiu-mrv\">https://meet.google.com/egs-ouiu-mrv</a> (if we want it)</p>",
        "id": 269455281,
        "sender_full_name": "simulacrum",
        "timestamp": 1643220309
    },
    {
        "content": "<p>Oh, I'd already started a Jitsi. :)</p>",
        "id": 269455357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643220341
    },
    {
        "content": "<p>I guess we can try Google Meet and see how that goes instead. :)</p>",
        "id": 269455389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643220355
    },
    {
        "content": "<p>Can I chime in <em>w.r.t.</em> marker trait soundness?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>If yes</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Basically it isn't unsound; it's just problematic with <code>Unpin</code>, since it was deemed that <code>Unpin</code> shouldn't be an <code>unsafe</code> trait.</p>\n<p>In hindsight, considering <code>pin_project</code>'s macro-based (that is, non-lang-based) API, this is problematic:<br>\nindeed, when writing unsafe code that wants to deal with <code>Pin</code>, it needs to have knowledge of all the code present in that crate. In this instance, the lack of \"bad <code>Unpin</code> impls\" for the decorated struct. Such a lack is currently, \"hackily\" (but there is no other way to achieve this), guaranteed by an already present constrained impl, and relying on coherence to prevent any \"extension\":</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[pin_project]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[pin]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">baz</span>: <span class=\"nc\">Baz</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>generates</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- macro naming boundary</span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">marker</span>::<span class=\"nb\">Unpin</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Newtype</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_unpin_bound</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_no_unpin_bound</span>: <span class=\"nc\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Baz</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Unpin</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Newtype</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"> </span>: <span class=\"nb\">Unpin</span> <span class=\"c1\">// i.e., when `Bar : Unpin`</span>\n<span class=\"w\">    </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This currently effectively makes it so <code>impl Unpin for Foo&lt;SmthNotUnpin, ()&gt; {}</code> fails due to coherence.</p>\n<ul>\n<li><a href=\"https://rust.godbolt.org/z/bac36aEMf\">Demo</a></li>\n</ul>\n<p>Why, you may ask? I have to admit having been puzzled by this quite a lot. The root issue stems from the fact that any attempt to break this impl on stable would rely on making something <code>!Unpin</code> by making it contain a <code>PhantomPinned</code> and relying on the structurality of that negative impl. And since <code>PhantomPinned</code> is not a local type, the coherence checker conservatively considers the possibility that <code>PhantomPinned : Unpin</code> could hold some time in the future?? This whole thing looks like it's abusing coherence way too much, and that it could break in the future, when, for instance, <code>PhantomPinned : !Unpin</code> can be relied on by the coherence checker, or when people get to write explicit <code>impl !Unpin …</code> opt-outs for their local types.</p>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=ba9b55f4f6ec5783ea3a3b20bb49d883\">Demo</a></li>\n</ul>\n<p>So yeah, in such a brittle context, a <code>#[marker]</code> on <code>Unpin</code> would make it harder for macro-based APIs to prevent exterior-to-the-macro impls that would make what the macro exposes unsound.</p>\n<p>In that regard, being given a tool to express <em>quantified trait impls</em> properties, at least for local types, would be a more proper way for macro authors to guarantee soundness:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[pin_project]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[pin]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">baz</span>: <span class=\"nc\">Baz</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// generating</span>\n<span class=\"n\">trait_bound_assertion</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">not</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">exists</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Bar</span><span class=\"w\"> </span>: <span class=\"o\">!</span><span class=\"nb\">Unpin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"o\">&gt;</span><span class=\"w\"> </span>: <span class=\"nb\">Unpin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<hr>\n<p>Anyways, back to the original question: <em>quid</em> of other traits / auto-traits? I'd say that:</p>\n<ul>\n<li>\n<p>an <code>unsafe trait</code> such as <code>Send</code> and <code>Sync</code> can always be marked as <code>#[marker]</code>, since the need for <code>unsafe</code> takes care of the unsoundness (note that having such a thing would be actually useful for, for instance, <code>ReentrantMutex&lt;T&gt;</code>, which can be <code>Sync</code> when <code>T : Sync</code> <strong>or</strong> <code>T : Send</code>, while right now it's only <code>Sync</code> when <code>T : Send</code>).</p>\n</li>\n<li>\n<p>a safe trait other-than-<code>Unpin</code>-which-ought-to-have-been-<code>unsafe</code> should also be harmless to make <code>#[marker]</code>, provided any APIs that rely on lack of of a trait impl for soundness are then the ones considered to be making something incorrect, at least if using coherence as the tool to achieve that.</p>\n</li>\n</ul>\n<p>Put it simply, given a safe trait <code>Trait</code>, consider:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(NotAlwaysTrait)]</span><span class=\"w\"> </span><span class=\"c1\">// guarantees that `Foo&lt;CertainTypes…&gt; : Copy&gt;` does not hold, and relies on that for safety</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"err\">…</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>What should we make of this pattern? The <code>#[pin_project]</code> case is just <em>one</em> instance of this pattern, where the trait is <code>Unpin</code>, but maybe we could imagine something similar for <code>Copy</code> (<em>e.g.</em>, the derive generates a builder-pattern that <code>unsafe</code> code can rely on, whose correct usage is guaranteed by move semantics thanks to a lack of <code>Copy</code>).</p>\n<p>I think that any implementation of such a pattern that is coherence-based is doomed to eventually be broken by language evolution: coherence being overly strict at the moment is not something guaranteed by Rust, especially when we see all these instance where it's cumbersome for many users: Rust would gain a lot from making coherence as lenient as possible (when reasoning locally to a crate, obviously!).</p>\n<ul>\n<li><code>Unpin</code> is a special case since, again, safety of pin APIs rely on <code>SometimesNotUnpin</code> to hold…</li>\n</ul>\n<p>So, now the final question is, beyond <code>Unpin</code>, are such APIs legitimate? I suspect they are.</p>\n<p>So all this leads to: <strong>we need a tool to be able to assert certain lack of impls for a given type</strong>.</p>\n<p>This may sound related to \"negative impls integrated into coherence\", except that if we take <code>pin_project</code>'s case, for instance, we can't write the necessary requirements, since we do want some cases of <code>impl Unpin</code>, and so the  <code>impl&lt;…&gt; !Unpin</code> and <code>impl&lt;…&gt; Unpin</code> would overlap.</p>\n<p>I don't know enough of coherence to know if there would be a nice solution to all this, besides my \"static assertions of certain trait properties\" idea.</p>\n<p>EDIT: actually the assertions don't need to be static (which takes care of that existential statement which was bugging me): it would suffice to be able to have a <code>does_impl!(T : Trait)</code> runtime check kind of API, so that we can, at least, guard the safety-critical parts with assertions of that.</p>\n<p>In the case of <code>pin_project</code>, for instance, being able to guard the <code>.project()</code> function with a runtime assertion of:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">does_impl</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">PinnedField</span><span class=\"w\"> </span>: <span class=\"nb\">Unpin</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">does_impl</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"bp\">Self</span><span class=\"w\"> </span>: <span class=\"nb\">Unpin</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>cc <span class=\"user-mention\" data-user-id=\"213313\">@Taiki Endo</span> </p>\n</div></div>",
        "id": 269471299,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643226734
    },
    {
        "content": "<p>Followup from the issues regarding Termination and ExitCode: <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby [she/her]</span> agreed to take care of Termination under the error handling banner.</p>",
        "id": 269484782,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643232331
    },
    {
        "content": "<p>(Including whether we should use <code>ExitCode</code> or just accept that we already have <code>std::process:exit</code> that takes <code>i32</code>.)</p>",
        "id": 269485159,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643232483
    },
    {
        "content": "<p>Was there a hackmd for this time (again, sorry)?</p>",
        "id": 269521247,
        "sender_full_name": "Charles Lew",
        "timestamp": 1643254043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> <a href=\"https://hackmd.io/YA5rOUQURnqe5qoH1zGkJw?edit\">https://hackmd.io/YA5rOUQURnqe5qoH1zGkJw?edit</a></p>",
        "id": 269594189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643299355
    }
]