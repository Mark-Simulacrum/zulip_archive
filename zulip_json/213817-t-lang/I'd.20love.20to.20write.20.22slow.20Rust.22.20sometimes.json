[
    {
        "content": "<p>Someone said something in a private meeting last week that really stuck with me, and some of the conversation in RPITIDT made me think of it.  My take on it would be this:</p>\n<blockquote>\n<p>I wish I could write slow Rust instead of fast C#.</p>\n</blockquote>\n<p>C# is a pretty good language, and they've been adding a bunch of nice things to make certain performance things (like using <code>struct</code>s pervasively, as those aren't boxed the way <code>class</code>es are).  But at some point, trying to push it further gets much more awkward.  For example, by the time you're pooling arrays (like <a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1?view=net-6.0\">.NET Core</a> added a class for) there's so many possible ways to mess it up that I really don't want to attempt it.  And its iterators don't optimize well, so you start losing a bunch of the nice parts if you try to make it \"fast\".</p>\n<p>Jumping down to \"slow C++\" doesn't really work because of the pervasive unsafety.  But jumping down to \"slow Rust\" could be a great experience, with all the nice features it has, especially if one isn't worried about a few extra clones or boxes in a few places.  (The bar being the \"well we just allocate basically everything\" default convention in C#, so a few in comparison is minor.)  The iterator comparison is another nice point -- in Rust <a href=\"https://internals.rust-lang.org/t/mir-optimization-pass-that-implements-auto-vectorization/16360/6?u=scottmcm\">they often make code *faster*</a>, exactly the opposite of how it ends up in C#.</p>\n<p>I obviously don't want to lose all the \"fast, full-control Rust\" stuff that makes it one of the <em>very</em> few options for that space.  But I also think it's important that we don't discount the uses that are willing to sacrifice just a bit of perf to still have great performance, just not <em>perfectly optimal</em> performance.</p>",
        "id": 276438173,
        "sender_full_name": "scottmcm",
        "timestamp": 1648105044
    },
    {
        "content": "<p>Oh yea. I would love a way to opt a crate (or function) into implicit clones, boxing, derefs, ...</p>",
        "id": 276438568,
        "sender_full_name": "oli",
        "timestamp": 1648105501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> FWIW, while I don't want to <em>default</em> to it, I am very much in favor of making it easier and lower-friction to write \"slow Rust\" as you're describing.</p>",
        "id": 276439136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648106092
    },
    {
        "content": "<p>I don't know exactly what I'd expect in terms of language features for it.  It's possible it'd be mostly a philosophical thing.  Like <a href=\"https://lib.rs/crates/ureq\">https://lib.rs/crates/ureq</a> is totally fine not being an \"eek out every last possible smidgen of performance here\" library.  (At least as I understand it; sorry if I'm misrepresenting something.)</p>\n<p>My instinct says I'm not sure I'd actually want implicit cloning in the kind of code I'm thinking about, at least.  Implicit boxing actually sounds more interesting.  I don't know that I could elaborate exactly what the difference is.  One thing it might be is that there's at least a type difference for the boxing case.</p>\n<p>One thing that does come to mind might be something like <code>type Foo&lt;trait T&gt; = Box&lt;dyn T + Send + Sync&gt;;</code>, since I don't think that's possible to write right now.</p>",
        "id": 276439141,
        "sender_full_name": "scottmcm",
        "timestamp": 1648106099
    },
    {
        "content": "<p>Implicit clone does seem significantly scarier than implicit boxing because it's not just implicit allocating (which some people might be completely ok with) but implicit arbitrary user code with all the potential side-effects and brokenness that comes with that</p>",
        "id": 276457794,
        "sender_full_name": "Jake",
        "timestamp": 1648118915
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276457794\">said</a>:</p>\n<blockquote>\n<p>Implicit clone does seem significantly scarier than implicit boxing because it's not just implicit allocating (which some people might be completely ok with) but implicit arbitrary user code with all the potential side-effects and brokenness that comes with that</p>\n</blockquote>\n<p>we can limit it to types that opt into it and start out with Arc and friends</p>",
        "id": 276461846,
        "sender_full_name": "oli",
        "timestamp": 1648121349
    },
    {
        "content": "<p>We already have fairly implicit arbitrary code execution in Deref, Index, Drop, probably others. Which is not to say we should add it willy-nilly, but this is not a hard line we must never cross, and some kind of easy cloning would be a huge improvement for heavy users of Arc, etc.</p>",
        "id": 276465059,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648123368
    },
    {
        "content": "<p>I wonder how much a slow Rust could be feasible by just having libraries which are optimised for ease of use rather than performance and idiomatic error handling, etc? I think Rust can be made much easier to use without any language changes at all (and that any language changes which would make a big difference would probably be un-rusty enough that they wouldn't get a decent level of support, as much as I would like to see help with clone, into, etc)</p>",
        "id": 276465456,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648123594
    },
    {
        "content": "<p>One thing about \"slow Rust\" that I have noticed is that <code>dyn</code> is pretty discouraged. I don't have too much first hand experience on this but I have heard others say that using it pervasively causes issues and generally looks quite a bit worse than analogous code in say Java or Haskell</p>",
        "id": 276466405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648124154
    },
    {
        "content": "<p>A big use case would be things like cloning into closures, like <a href=\"https://github.com/rust-lang/rfcs/issues/2407\">https://github.com/rust-lang/rfcs/issues/2407</a></p>",
        "id": 276466549,
        "sender_full_name": "mejrs",
        "timestamp": 1648124239
    },
    {
        "content": "<p>Allocating on each <code>next()</code> call in an async iterator as was discussed in the RPITIDT topic still seems questionable to me. This can be fine if you have a super-efficient allocator (as GCed languages do) but if you have some crufty malloc that can be more costly.</p>",
        "id": 276470551,
        "sender_full_name": "The 8472",
        "timestamp": 1648126359
    },
    {
        "content": "<p>I think it is a dangerous, yet common, trap for languages to think that they can be everything to all users. Languages that try to be everything to everyone only survive via overwhelming institituonal inertia and/or millions of dollars in marketing. Languages that don't have that, like Rust, only survive due to user enthusiasm, which is achieved by being good at things, which usually involves making compromises that make you worse at other things. I don't want a \"slow Rust\" to compete with \"fast C#\"; that's a losing battle that C# will always win because C# has inertia and Microsoft. Rust is beloved because it's a \"safe C++\", so let it stay focused on that.</p>",
        "id": 276484418,
        "sender_full_name": "bstrie",
        "timestamp": 1648132632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276484418\">said</a>:</p>\n<blockquote>\n<p>I think it is a dangerous, yet common, trap for languages to think that they can be everything to all users.</p>\n</blockquote>\n<p>That's certainly true, but I think it's more a question of where the line is.  I'm not, for example, trying to have \"slow Rust\" compete with even \"normal C#\", let alone \"normal Python\".</p>\n<p>To try to better elaborate on what I mean here, \"normal C#\" code that wants to take a iterator does something like this:</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"nf\">ConsumeStuff</span><span class=\"p\">(</span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">Foo</span><span class=\"p\">&gt;</span><span class=\"w\"> </span><span class=\"n\">foos</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's kinda like a function taking a hypothetical <code>GC&lt;dyn Iterator&lt;Item = Foo&gt; + Send&gt;</code> in Rust.  And I'm <em>not</em> saying that this is something where I would expect Rust to be particularly good.</p>\n<p>But that way is somewhat fundamentally slow, in the same way that <code>dyn Iterator</code> is often not what you want in Rust either.  So in what I'm loosely calling \"fast C#\", it might look like this instead:</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"n\">ConsumeStuff</span><span class=\"p\">&lt;</span><span class=\"n\">T</span><span class=\"p\">&gt;(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">foos</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">Foo</span><span class=\"p\">&gt;,</span><span class=\"w\"> </span><span class=\"n\">struct</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Because that forces the JiT to monomorphize, and because it only takes non-boxed types it can \"easily\" devirtualize, etc.</p>\n<p>At that point I'd say it's basically <em>trying</em> to be \"safe C++\".  And thus writing this in Rust where normal code does this kind of thing is likely to be a better experience, even with only the language features that exist today.  The code would just largely ignore lots of the \"if you need 100% control over everything\" parts of the language.</p>",
        "id": 276496890,
        "sender_full_name": "scottmcm",
        "timestamp": 1648137469
    },
    {
        "content": "<p>TL/DR: I don't want to write \"100% slower Rust\", but I'd often happily take \"10% slower Rust\".</p>",
        "id": 276497553,
        "sender_full_name": "scottmcm",
        "timestamp": 1648137664
    },
    {
        "content": "<p>I wouldn't mind having the ability to write 100% slower Rust sometimes. <code>type Var&lt;T&gt; = Arc&lt;Mutex&lt;T&gt;&gt;</code></p>",
        "id": 276498184,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648137891
    },
    {
        "content": "<p>Rust-as-faster-Python would be interesting. Just not as the default.</p>",
        "id": 276498259,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648137926
    },
    {
        "content": "<p>(I've deleted my post with percentages, because I think it'll lead to discussing the wrong parts of what I wanted to say)</p>",
        "id": 276498800,
        "sender_full_name": "scottmcm",
        "timestamp": 1648138142
    },
    {
        "content": "<p>(fair enough, feel free to ignore mine)</p>",
        "id": 276499007,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648138215
    },
    {
        "content": "<p>I agree completely with preferring to write slower-Rust over faster-otherlang. I don't feel like that should be an especially controversial matter. I think defaults are going to be more a matter of concern than capabilities.</p>",
        "id": 276499152,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648138261
    },
    {
        "content": "<blockquote>\n<p>That's certainly true, but I think it's more a question of where the line is.</p>\n</blockquote>",
        "id": 276520411,
        "sender_full_name": "bstrie",
        "timestamp": 1648146394
    },
    {
        "content": "<p>I think the line is \"does it compromise Rust's performance advantages?\" I too like things to be nice, expressive, and convenient. But I am willing to trade off on all of those things if it means not compromising on performance. (Obviously memory safety still takes precedence over performance!) We switched from a \"GC\" to ownership because the former imposed a pervasive performance penalty, even though it was more convenient. We switched <code>for</code> from internal iteration to external iteration because it resulted in better performance, even though it makes writing iterator adaptors a relatively big pain. We tore out the green thread runtime because it was imposing a performance cost on everything that wasn't using it, even though green threads are desirable. Convenient things are good, especially if they help to onboard new users. But there has to be a path to doing things \"the right way\"; it's not a crime to clone and box everything all over the place if it helps you get started with Rust, but that's not by any means considered idiomatic.</p>",
        "id": 276521136,
        "sender_full_name": "bstrie",
        "timestamp": 1648146712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276521136\">said</a>:</p>\n<blockquote>\n<p>We switched <code>for</code> from internal iteration to external iteration because it resulted in better performance, even though it makes writing iterator adaptors a relatively big pain.</p>\n</blockquote>\n<p>This is not actually true.  It's <em>internal</em> iteration that's <a href=\"https://medium.com/@veedrac/rust-is-slow-and-i-am-the-cure-32facc0fdcb\">faster</a>.</p>",
        "id": 276522208,
        "sender_full_name": "scottmcm",
        "timestamp": 1648147211
    },
    {
        "content": "<p>Also adapters are easier to write for external iteration I believe. That being said, I do think this example is a bit of a red herring because it's not an <em>irrecoverable</em> speed difference. It's mostly an issue of one being harder for compilers, and at least in principle I don't see why we couldn't write the opts to bridge the gap</p>",
        "id": 276522896,
        "sender_full_name": "Jake",
        "timestamp": 1648147542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276522208\">said</a>:</p>\n<blockquote>\n<p>This is not actually true.  It's <em>internal</em> iteration that's <a href=\"https://medium.com/@veedrac/rust-is-slow-and-i-am-the-cure-32facc0fdcb\">faster</a>.</p>\n</blockquote>\n<p>heh, at the time rust still had boxed closures (<a href=\"https://github.com/rust-lang/rfcs/pull/114\">https://github.com/rust-lang/rfcs/pull/114</a>), so when the decision was made it was dramatically friendlier to the optimizer. If internal iteration is faster today, then it's because we unboxed closures, which is another example of making things more annoying for the sake of performance :P</p>",
        "id": 276524702,
        "sender_full_name": "bstrie",
        "timestamp": 1648148364
    },
    {
        "content": "<p>I was looking for a blog post about why we switched to external iteration. Didn't find it yet, but I found <a href=\"https://smallcultfollowing.com/babysteps//blog/2012/02/02/breaking-out-is-hard-to-do/\">https://smallcultfollowing.com/babysteps//blog/2012/02/02/breaking-out-is-hard-to-do/</a> which talks about how breaking out of a loop is anying with internal iteration.</p>",
        "id": 276525149,
        "sender_full_name": "bjorn3",
        "timestamp": 1648148527
    },
    {
        "content": "<blockquote>\n<p>Also adapters are easier to write for external iteration I believe.</p>\n</blockquote>\n<p>See <a href=\"https://github.com/rust-lang/rust/issues/7746\">https://github.com/rust-lang/rust/issues/7746</a> . The original impetus for generators was to make writing external iterators easier!</p>",
        "id": 276525995,
        "sender_full_name": "bstrie",
        "timestamp": 1648148955
    },
    {
        "content": "<p><a href=\"https://mail.mozilla.org/pipermail/rust-dev/2013-June/004364.html\">https://mail.mozilla.org/pipermail/rust-dev/2013-June/004364.html</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">.]</span><span class=\"w\"></span>\n<span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">workaround</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"n\">algorithms</span><span class=\"w\"> </span><span class=\"n\">assuming</span><span class=\"w\"> </span><span class=\"n\">internal</span><span class=\"w\"> </span><span class=\"n\">iterators</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">take</span><span class=\"w\"></span>\n<span class=\"n\">one</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"p\">)</span>:\n\n    <span class=\"nc\">fn</span><span class=\"w\"> </span><span class=\"n\">count</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">uint</span><span class=\"w\"></span>\n\n<span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"w\"> </span><span class=\"n\">adaptors</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"></span>\n<span class=\"n\">lack</span><span class=\"w\"> </span><span class=\"n\">sugar</span>:\n\n    <span class=\"nc\">count</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">f</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">uint</span>::<span class=\"n\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"w\"></span>\n\n<span class=\"n\">For</span><span class=\"w\"> </span><span class=\"n\">simple</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">fairly</span><span class=\"w\"> </span><span class=\"n\">reasonable</span><span class=\"w\"> </span><span class=\"n\">once</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"o\">'</span><span class=\"na\">re</span><span class=\"w\"> </span><span class=\"n\">used</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"w\"></span>\n<span class=\"n\">quickly</span><span class=\"w\"> </span><span class=\"n\">gets</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">control</span><span class=\"w\"> </span><span class=\"n\">though</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">simple</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">like</span><span class=\"w\"> </span><span class=\"n\">filter</span>:\n\n    <span class=\"nc\">filter</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pred</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">input</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">.]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276526047,
        "sender_full_name": "bjorn3",
        "timestamp": 1648148986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276525995\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Also adapters are easier to write for external iteration I believe.</p>\n</blockquote>\n<p>See <a href=\"https://github.com/rust-lang/rust/issues/7746\">https://github.com/rust-lang/rust/issues/7746</a> . The original impetus for generators was to make writing external iterators easier!</p>\n</blockquote>\n<p>Ah, yeah sorry. I'd gotten things mixed up - they're easier to write for internal (usuallly) and easier to <em>use</em> for external</p>",
        "id": 276526171,
        "sender_full_name": "Jake",
        "timestamp": 1648149039
    },
    {
        "content": "<p>Which kind of iteration is better depends on the iterator shape. For things involving Zip  external iteration is better, for TrustedLen internal and external can be equal in runtime performance but external generates less IR (fewer intermediate closures), for Chain and Flatten internal iteration wins.</p>",
        "id": 276527234,
        "sender_full_name": "The 8472",
        "timestamp": 1648149619
    },
    {
        "content": "<p>In any case I don't want to engender hostility here; I am not necessarily opposed to having things that are more convenient even if they're slower. What I <em>don't</em> want is either of the following:</p>\n<ol>\n<li>Using \"there's an easier-but-slower version of what you're trying to do\" as an excuse for not needing to improve the ergonomics of the as-fast-as-possible version. There should always be a \"pit of success\" that leads to good performance.</li>\n<li>Having the notion of \"Slow Rust\" take root as its own informal dialect of the language. We can't afford to fork the language.</li>\n</ol>",
        "id": 276527254,
        "sender_full_name": "bstrie",
        "timestamp": 1648149626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276527254\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Having the notion of \"Slow Rust\" take root as its own informal dialect of the language. We can't afford to fork the language.</li>\n</ol>\n</blockquote>\n<p>I very strongly agree with the second sentence. However, depending on what you mean by \"informal dialect\" it doesn't necessarily have to be a consequence of the first part. I would love to see a design that allows for a \"slow\" version of Rust without just making two languages. I don't see how to do it to be clear, but there are lots of things that I didn't know were possible before Rust went and did them</p>",
        "id": 276528900,
        "sender_full_name": "Jake",
        "timestamp": 1648150608
    },
    {
        "content": "<p>Rough sketch of an idea: what if you could use the extension trait pattern to opt in to language features that relax the explicitness of your code? e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">lang</span>::<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">AutoBox</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">AutoClone</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Monomorphize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276550447,
        "sender_full_name": "tmandry",
        "timestamp": 1648162909
    },
    {
        "content": "<p>You could implement <a href=\"#narrow/stream/213817-t-lang/topic/return.20position.20impl.20Trait.20in.20dyn.20Trait/near/276431021\">profiles</a> as modules with <code>pub use</code> statements and glob-import them</p>",
        "id": 276550683,
        "sender_full_name": "tmandry",
        "timestamp": 1648163068
    },
    {
        "content": "<p>I also strongly agree that forking the language is a bad idea, but the ability to make local changes while preserving interop (as we are able to do with editions) seems valuable</p>",
        "id": 276551001,
        "sender_full_name": "tmandry",
        "timestamp": 1648163313
    },
    {
        "content": "<p>I'm actually quite wary of de-facto dialects, despite what I put as the topic name here.  I don't want to have to check the <code>use</code>s to not be confused by what's happening.</p>\n<p>That said, one version of this is just called lints.  <code>#![allow(some_feature)]</code>, where it's deny-by-default, has this same kind of impact.  That would say that it's just a matter of finding things that fit well, so this is just the same \"some things aren't just lints\", like how there's no <code>allow</code> to not have to write <code>unsafe</code> for unsafe things.</p>",
        "id": 276552260,
        "sender_full_name": "scottmcm",
        "timestamp": 1648164179
    },
    {
        "content": "<p>Yeah, I think any move towards dialects would be bad. And I wonder about lints in this perspective too. Given lints and features are per crate I feel like theee is already a bit of an aspect of checking the crate root to find out what kind of rust I should be writing, and while that has good use cases I’d hate to push that further along</p>",
        "id": 276587273,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648196223
    },
    {
        "content": "<p>a flag that changes global semantics in this way is precisely what I'm afraid of. if you want to add a convenience feature, opt into it at the type level (e.g. <code>Rc</code> to escape ownership), not at the crate/file/module level</p>",
        "id": 276600499,
        "sender_full_name": "bstrie",
        "timestamp": 1648204657
    },
    {
        "content": "<p>silly idea: proc macro that does autoboxing</p>",
        "id": 276696006,
        "sender_full_name": "Jubilee",
        "timestamp": 1648255820
    },
    {
        "content": "<p>I've wanted something like <code>#[repr(Box)]</code> to autobox creation of a struct (well, the case i had was an enum) before.</p>",
        "id": 276696189,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648256060
    },
    {
        "content": "<p>If I think about this, I think it would be bad though.</p>",
        "id": 276696202,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648256090
    },
    {
        "content": "<p>I wouldn't want that in the lang no.</p>",
        "id": 276697049,
        "sender_full_name": "Jubilee",
        "timestamp": 1648257209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276696189\">said</a>:</p>\n<blockquote>\n<p>I've wanted something like <code>#[repr(Box)]</code> to autobox creation of a struct (well, the case i had was an enum) before.</p>\n</blockquote>\n<p>While I don't know that specifically this would be a good idea, it does seem like the general area of the kinds of things that wouldn't be a deal-breaker.</p>\n<p>Applying as opt-in to a specific type avoids the worst dialect issues, it's easy for someone to just not use that type like they'd avoid any other library they'd rather not use, and it could plausibly disappear by MIR time by lowering <code>#[whatever_the_thing] struct Foo { ... }</code> to something like <code>struct FooInner { ... } struct Foo(Box&lt;FooInner&gt;);</code> or something.</p>",
        "id": 276697760,
        "sender_full_name": "scottmcm",
        "timestamp": 1648258142
    },
    {
        "content": "<p>This is a topic that I touch on on my training as well. I point out that Rust can attract the hyper-optimizers (and I include myself in that group) but that it's very easy to get lost in the weeds that way.</p>\n<p>I encourage the students to do things like \"too many allocations\" for the sake of getting the program working and understanding how their data needs to flow. Then they can benchmark / profile and there's a set of breadcrumbs to address (e.g. \"find all the <code>.clone()</code> calls\").</p>\n<p>The breadcrumbs are something I'd want to see preserved. I don't mind writing that slower Rust code sometimes either, but I want to quickly identify it in the code.</p>\n<p>A parallel that's coming to mind is <code>?</code> — most of the time I don't want to think too deeply about the error cases (so no <code>err = x; if err return err</code> or <code>throw AnErrorHere</code>), but I don't want to completely hide them from sight either (e.g. unchecked exceptions). The <code>?</code> strikes a nice balance.</p>\n<p>Perhaps what I'm saying  is it's time to bring back <code>~</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 276699114,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1648260050
    },
    {
        "content": "<p>no no, we need ~ for fields</p>",
        "id": 276699332,
        "sender_full_name": "Lokathor",
        "timestamp": 1648260312
    },
    {
        "content": "<p>I said that at about a 10% serious level. Thinking on it a second or two more, I think that a single character operator would be too encouraging to use. Perhaps a 15% serious suggestion would be the <code>box</code> keyword. ￼￼</p>\n<p>Maybe even <code>.box</code></p>",
        "id": 276699468,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1648260514
    },
    {
        "content": "<p><code>.box</code> passes my heuristic of \"it only applies to a value, not to a scope\", so it's plausible.</p>",
        "id": 276699772,
        "sender_full_name": "scottmcm",
        "timestamp": 1648260980
    },
    {
        "content": "<p>If we remove the <code>box</code> keyword, then we could just have <code>box</code> via an extension trait.</p>",
        "id": 276699880,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648261162
    },
    {
        "content": "<p>why bother with a trait, just let the keyword be used in a new spot</p>",
        "id": 276700901,
        "sender_full_name": "Lokathor",
        "timestamp": 1648262590
    },
    {
        "content": "<p>It's less magical.</p>",
        "id": 276701021,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648262782
    },
    {
        "content": "<p>But everything in the world would implement this trait, which is a little magical to begin with (there's already auto-traits, but users can't make auto-traits)</p>",
        "id": 276738710,
        "sender_full_name": "Lokathor",
        "timestamp": 1648318840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276738710\">said</a>:</p>\n<blockquote>\n<p>But everything in the world would implement this trait, which is a little magical to begin with (there's already auto-traits, but users can't make auto-traits)</p>\n</blockquote>\n<p>Uuum what?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">BoxIt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">box_it</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">BoxIt</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles today</p>",
        "id": 276739275,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1648319566
    },
    {
        "content": "<p>Oh right, it doesn't need to be auto</p>",
        "id": 276741556,
        "sender_full_name": "Lokathor",
        "timestamp": 1648322680
    },
    {
        "content": "<p>Yeah, a simple blanket impl for the trait, and just shove it in the prelude in edition N.</p>",
        "id": 276741849,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648323096
    },
    {
        "content": "<p>At the risk of summoning demons of features deleted, recall that <code>box</code> worked beyond <code>Box</code> specifically, which is part of the reason it was a keyword. E.g. things akin to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">a</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">.</span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">b</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Arc</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">.</span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">c</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kc\">true</span><span class=\"p\">].</span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276750958,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1648335926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276750958\">said</a>:</p>\n<blockquote>\n<p>At the risk of summoning demons of features deleted, recall that <code>box</code> worked beyond <code>Box</code> specifically, which is part of the reason it was a keyword. E.g. things akin to</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">a</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">.</span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">b</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Arc</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">.</span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">c</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kc\">true</span><span class=\"p\">].</span><span class=\"k\">box</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">sync</span>::<span class=\"n\">Arc</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FromUnboxed</span><span class=\"o\">&lt;</span><span class=\"n\">Unboxed</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from_unboxed</span><span class=\"p\">(</span><span class=\"n\">unboxed</span>: <span class=\"nc\">Unboxed</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromUnboxed</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from_unboxed</span><span class=\"p\">(</span><span class=\"n\">unboxed</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">unboxed</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromUnboxed</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Arc</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from_unboxed</span><span class=\"p\">(</span><span class=\"n\">unboxed</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Arc</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">unboxed</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromUnboxed</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from_unboxed</span><span class=\"p\">(</span><span class=\"n\">unboxed</span>: <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">unboxed</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">BoxIt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">box_it</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">FromUnboxed</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">T</span>::<span class=\"n\">from_unboxed</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">BoxIt</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276756555,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1648344576
    },
    {
        "content": "<p>Now just make placement new work <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 276756751,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1648344927
    },
    {
        "content": "<p><code>FromUnboxed</code> is not equivalent to <code>box expr</code>. <code>box expr</code> first allocates the box and then evaluates the expression, trying to write the result directly to the box, while <code>FromUnboxed</code> would evaluate the expression to a stack temporary and then allocate the box.</p>",
        "id": 276781739,
        "sender_full_name": "bjorn3",
        "timestamp": 1648377973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276756751\">said</a>:</p>\n<blockquote>\n<p>Now just make placement new work <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">placement_new</span>::<span class=\"n\">boxed</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">boxed</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: ::<span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">boxed</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8e3a3e48113daba7cf68953094ebec77\">Playground</a></li>\n</ul>",
        "id": 276795634,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1648397961
    },
    {
        "content": "<p>Imagine that with postfix macros <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 276795642,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1648397975
    },
    {
        "content": "<p>As someone who often writes \"slow rust\", I have to say that rust already feels pretty good at this.  I'm having a hard time figuring out if \"slow rust\" is just a style thing or a language-level thing.  I feel frequently write a lot of <code>.clone()</code> or <code>.to_string()</code> if I can't be bothered to make borrowck happy.  Or I'll often collect iterators into intermediate <code>Vec</code>s because it's easier to read/write than longer, but more efficient, iterator chains.    Or shove things in Arc/Mutex.  Going back to the very first message in this thread, which quoted someone as asking \"I wish I could write slow Rust\", my initial reaction is:  well, it seems like you already can; why can't you?</p>",
        "id": 276797074,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1648399986
    },
    {
        "content": "<p>To me, it's largely about culture, but it could also be about what the Rust language / standard library include:</p>\n<blockquote>\n<p>But I also think it's important that we don't discount the uses that are willing to sacrifice just a bit of perf to still have great performance, just not perfectly optimal performance.</p>\n</blockquote>\n<p><code>#[async_trait]</code> may be a good example of this. We can't yet write the \"perfectly optimal\" async trait, so we are OK with doing a bit of boxing. Why is it a crate instead of the compiler (especially considering that the compiler recommends <code>async_trait</code>)?</p>\n<blockquote>\n<p>I [...] write a lot of <code>.clone()</code> or <code>.to_string()</code></p>\n</blockquote>\n<p>All of those are small roadbumps; each one can make people think \"Should I really be writing this? Am I doing the wrong thing?\"</p>\n<blockquote>\n<p>Or shove things in Arc/Mutex</p>\n</blockquote>\n<p>Which has even more syntax to get in the way (e.g. <code>lock()</code> and <code>unwrap()</code>).</p>\n<p>A hypothetical Rust could have some syntax (that I'm not imaginative enough at the moment to make up) that puts all of these things on the same level. Ideally still allowing you to distinguish between the two.</p>",
        "id": 276798670,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1648402303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222286\">Andrew Chin (eminence)</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/276797074\">said</a>:</p>\n<blockquote>\n<p>Going back to the very first message in this thread, which quoted someone as asking \"I wish I could write slow Rust\", my initial reaction is:  well, it seems like you already can; why can't you?</p>\n</blockquote>\n<p>I think it's largely an organizational inertia thing.  If one is already working on a product in Java/C#/etc, then porting and retraining and such is often not justifiable as a business decision.  It might be better to just accept being a bit slower over and the code a bit uglier in a few places than you might wish.  Whereas if you really need <em>fast</em> Rust then it's more feasible to make the case.</p>\n<p>The \"I wish I could\" might be in part because technically it'd be pretty nice already -- there might be a few rough edges, but there are in the non-Rust solution too.</p>\n<p>(This was largely an aside from that person in a conversation a few weeks ago now, so I can't say for certain exactly what they meant.)</p>",
        "id": 276805456,
        "sender_full_name": "scottmcm",
        "timestamp": 1648411989
    },
    {
        "content": "<p>For what it's worth: I both agree with the sentiment initiating this thread (\"it'd be nice to be able to ...\") and strongly agree with the sentiment that adding any sort of global dialects is an undesirable approach. My experience is that rust has the necessary pieces lying around on the floor to write this way (minus cloning arcs or locking mutexes, which is not _that_ bad) but that lots of the pieces don't quite fit together right. object safety rules in particular make most traits or libraries unusable; it's just like \"not a priority\" for most rust code to support dyn.</p>\n<p>I'm not sure if more language infrastructure would help, or maybe just finishing unfinished TODOs in the language around dyn, or if it's all just library issues. but I've much more often found myself trying-and-failing to write \"slow rust\" -- being defeated by roadblocks -- than I have found myself wanting a global mode-switch to make it all implicitly-so.</p>",
        "id": 277053143,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648581629
    },
    {
        "content": "<p>(some of this is like just that trait-bounded existential types are fundamentally different than trait-bounded universals -- or are at least so in rust , where for example there's no way to locally open-and-use an associated type provided by a dyn, and rust design patterns lean fairly heavily on doing that sort of thing in polymorphic code; possibly that'd be a way to help this problem space with \"language level\" support)</p>",
        "id": 277053620,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648581858
    },
    {
        "content": "<blockquote>\n<p>for example there's no way to locally open-and-use an associated type provided by a dyn</p>\n</blockquote>\n<p>what do you mean by \"open-and-use\" here?</p>",
        "id": 277053792,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648581936
    },
    {
        "content": "<blockquote>\n<p>object safety rules in particular</p>\n</blockquote>\n<p>For a long time, I was really annoyed that a language like Java allowed me to have dynamic traits/interfaces with generics while Rust didn't. After years, I realized that those languages just enforced object safety all the time and Rust allowed <em>more</em>. It was largely that the default syntax led me down the performance path that wasn't compatible with maximum dynamics.</p>",
        "id": 277053882,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1648581970
    },
    {
        "content": "<p>the object-safety RFC talks about splitting traits into object-safe and non-object-safe functionality, or carefully bounding only the necessary methods with Sized. IME virtually no rust libraries do that.</p>",
        "id": 277053894,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648581978
    },
    {
        "content": "<p>vaguely related: niko just published a blog post today talking all about dyn trait and object safety and talking about, among other things, making object safety opt-in vs opt-out in the next edition</p>",
        "id": 277053993,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648582054
    },
    {
        "content": "<p><a href=\"https://smallcultfollowing.com/babysteps//blog/2022/03/29/dyn-can-we-make-dyn-sized/\">https://smallcultfollowing.com/babysteps//blog/2022/03/29/dyn-can-we-make-dyn-sized/</a></p>",
        "id": 277053995,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648582055
    },
    {
        "content": "<blockquote>\n<p>what do you mean by \"open-and-use\" here?</p>\n</blockquote>\n<p>Some languages with existentials / dynamic first-class modules have a syntactic form where the dynamic type is \"opened\" / pinned to a static identity for the duration of a given code block.  so you have something like (spitballing syntax)  <code>fn foo(x: dyn T) { type K = &lt;x as T&gt;::K; /* ... use K as an unknown but static type in this block */ }</code></p>\n<p>This enables a dynamic type's inhabitants, including type-inhabitants, to sort of \"temporarily become static\" for the purposes of further type judgments -- you don't need the typechecker to partially-evaluate the program by tracking the flow of dyn values around a block that's using them just to prove identity of types that were fished out of one of the dyns.</p>",
        "id": 277054947,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648582594
    },
    {
        "content": "<p>do you have examples of languages that support this that I can look at for reference? (does swift do this?)</p>",
        "id": 277055357,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648582830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/277053993\">said</a>:</p>\n<blockquote>\n<p>among other things, making object safety opt-in vs opt-out in the next edition</p>\n</blockquote>\n<p>I'd love to do that.  I'm way too good at accidentally breaking object-safety (<a href=\"https://github.com/rust-lang/rust/issues/87991\">#87991</a>), since there's nothing by default checking that traits actually meet it.</p>\n<p>You might, say, require <code>dyn trait</code> in the definition in 2024 crates in order for them to be used with <code>dyn</code>: &lt;<a href=\"https://github.com/rust-lang/rfcs/pull/3022\">https://github.com/rust-lang/rfcs/pull/3022</a>&gt;</p>",
        "id": 277055611,
        "sender_full_name": "scottmcm",
        "timestamp": 1648582974
    },
    {
        "content": "<p>I think I agree with niko's comment in the blog post that I'd rather it be opt out than opt in, though the opt in syntax is much easier to imagine / less bikeshed-prone</p>",
        "id": 277055829,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648583089
    },
    {
        "content": "<blockquote>\n<p>Some languages with existentials / dynamic first-class modules have a syntactic form where the dynamic type is \"opened\" ....</p>\n</blockquote>\n<p>Yeah I want non-monomorphizing (erasing) type quantification, in both it's universal and existential forms.</p>\n<p>With that, and a few other things (e.g. DynSized for better support for thin types, coercions for GADTs) we should be able to do flawless FFI with <em>any</em> sort of object/dynamic dispatch thing out there. It just makes our ability to type memory/ABIs so <em>vastly</em> more expressive than what we have today.</p>",
        "id": 277056350,
        "sender_full_name": "John Ericson",
        "timestamp": 1648583399
    },
    {
        "content": "<p>I'm not saying Rust needs that kind of feature in particular, or even that it makes sense in rust as-is. I'm just thinking of .. the ways the existing dyn types are somewhat underpowered / hard to integrate with libraries that weren't built explicitly for them. I especially worry this risks splitting library users who want to avoid code expansion through monomorphization, eg. embedded users.</p>",
        "id": 277056511,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648583482
    },
    {
        "content": "<p>Well, it's again opt in. It's a big feature, but I really do think it is worth it because of the shear breadth of use-cases it helps with.</p>",
        "id": 277056586,
        "sender_full_name": "John Ericson",
        "timestamp": 1648583522
    },
    {
        "content": "<p>The existing <code>dyn</code>, like C++ inheritence, is just a magical black box to hack around a lack of expressive power to build the thing out of first principles.</p>",
        "id": 277056749,
        "sender_full_name": "John Ericson",
        "timestamp": 1648583603
    },
    {
        "content": "<p>So yes, it is fine for single-language use, and good for ergonomics in that single language, but a mess for FFI.</p>",
        "id": 277056806,
        "sender_full_name": "John Ericson",
        "timestamp": 1648583629
    },
    {
        "content": "<p>Being able to write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">qsort</span><span class=\"o\">&lt;</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">array</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">compare</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>as single non-monomorphized wrapper around C's <code>qosrt</code> is very nice!</p>",
        "id": 277057176,
        "sender_full_name": "John Ericson",
        "timestamp": 1648583843
    },
    {
        "content": "<blockquote>\n<p>do you have examples of languages that support this that I can look at for reference? (does swift do this?)</p>\n</blockquote>\n<p>The feature usually shows up as \"first class modules\", i.e. a static module type that can turn into a dynamic value (and then, to be useful, back to a static module). I think it's been in ocaml since about the mid 3.x series (<a href=\"https://ocaml.org/releases/4.13/htmlman/firstclassmodules.html\">https://ocaml.org/releases/4.13/htmlman/firstclassmodules.html</a>); there's a design for it here in haskell: <a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/first_class_modules.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/first_class_modules.pdf</a></p>\n<p>I don't know the exact state of Swift's existentials but they seem to be grappling with the same set of roadblocks to existential usage (<a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md\">https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md</a>) so I suspect not. I don't remember such a feature anyway; it might occur magically in some contexts.</p>",
        "id": 277057284,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648583896
    },
    {
        "content": "<p>cool, thank you!</p>",
        "id": 277057553,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648584017
    },
    {
        "content": "<p>What I know about Switch is just second hand from <a href=\"https://gankra.github.io/blah/swift-abi/\">https://gankra.github.io/blah/swift-abi/</a>, but this sort of dictionary passing, (runtime) dictionary building stuff is how bog standard typeclasses work too. Haskell doesn't use dictionaries for that <em>purpose</em> (having only support for concrete unboxed types, sadly) but the mechanism as opposed to the objective is exactly the same.</p>",
        "id": 277057655,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584074
    },
    {
        "content": "<p>I mean it's much easier in languages that aren't all tangled up in reasoning about sizedness-of-types and the owner of a type and its static lifetime and so forth. Haskell and OCaml are sort of easy-mode when it comes to data representation. Uniform representation assumed, exceptions are left to the optimizer.</p>",
        "id": 277058300,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584409
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/first_class_modules.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/first_class_modules.pdf</a></p>\n</blockquote>\n<p>I wasn't familiar with that one, but many of the ideas in it have circulated to the more recent paper <a href=\"https://richarde.dev/papers/2021/exists/exists.pdf\">https://richarde.dev/papers/2021/exists/exists.pdf</a> which hammered out some of the type inference concerns (which Rust largely wouldn't have, been less ambitious in its type inference to begin with) and an  <a href=\"https://github.com/ghc-proposals/ghc-proposals/pull/473\">https://github.com/ghc-proposals/ghc-proposals/pull/473</a> (our version of RFCs), so seems likely to happen in 1-3 years.</p>",
        "id": 277058326,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584428
    },
    {
        "content": "<p>Swift is not easy mode but it's also willing to do a lot of stuff at runtime. It has a \"generic value\" that's 3 words long that it'll try packing stuff into and passing dictionaries before requiring specialization; and it'll let you add impls at runtime and dispatch over from indirect code to direct code if it detects a known type equality and .. all sorts of elaborate dynamic/static bridging machinery Rust would never go for.</p>",
        "id": 277058475,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584503
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"158781\">@Graydon Hoare</span> I know, I have been thinking about this stuff with Rust in mind. Rust already found the solution with DSTs: namely get rid of the \"ambient authority\" that being well typed means you the size of all values statically.</p>",
        "id": 277058499,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584535
    },
    {
        "content": "<p>Yeah. It's just fairly restrictive :)</p>",
        "id": 277058533,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584555
    },
    {
        "content": "<p>Well, there <em>is</em> an unavoidable tradeoff between flexiblity and doing things statically. The trick isn't to fight that, but put the tradeoff in the hands of the programmer.</p>",
        "id": 277058680,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584614
    },
    {
        "content": "<p>or rather .. I think maybe some of the restrictions on ?Sized types that came along for the ride that might be weakened without undermining the general solution.</p>",
        "id": 277058710,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584630
    },
    {
        "content": "<p>Yeah we can just keep on adding more <code>?Trait</code>, until we are left with the type you can do nothing at all with, and then there is nothing left to monomorphize!</p>",
        "id": 277058765,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584668
    },
    {
        "content": "<p>equivalent, types are <em>always</em> just erased, and \"monomophizing\" is just inlining various extra parameters/dictionaries. not the types themselves, which are mere bookkeeping.</p>",
        "id": 277058938,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584738
    },
    {
        "content": "<p>yeah, for sure. I've just found (as a programmer trying to use this power in my hands) that the language is in fact fighting me, usually by making a dyn type seemingly-too-hard to use with code written not-thinking-about-dyn. I don't have the full set of restrictions in my head, but I think this isn't that uncommon an experience (niko's post above points to ways to relax some restrictions, though doesn't talk about access to associated types .. baby steps!)</p>",
        "id": 277059061,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584798
    },
    {
        "content": "<p>Yeah <code>dyn</code> is a complete abrogation to put the expressive power in the language. instead burying it in special case compiler magic.</p>",
        "id": 277059168,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584852
    },
    {
        "content": "<p>The result it's very unclear what exactly it <em>is</em>, as a somewhat black box we all have slightly different mental models about, and issues are likely to crop up over time.</p>",
        "id": 277059228,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584898
    },
    {
        "content": "<p>(I am a little oversensitized to this since it's also a bit part of \"why rust compiles so slowly\" and something, ages ago, I was somewhat adamant about the project being careful not to fall into the hole of that .. it did somewhat fall into, in practice. I realize we had to do something better than the \"every generic is dictionaries-and-dynamic-calculations\" model we started with, but we kinda overcorrected, imo)</p>",
        "id": 277059256,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584914
    },
    {
        "content": "<p>The thing with some <code>exists&lt;T&gt;</code>is very verbose, but there is no magic all the complexity is stairing back right at you in the code</p>",
        "id": 277059355,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584966
    },
    {
        "content": "<p>Yes, more control around incrementality guarnatees just as we control compile times costs would be nice.</p>",
        "id": 277059392,
        "sender_full_name": "John Ericson",
        "timestamp": 1648584990
    },
    {
        "content": "<p>Heh. I don't mind special-case compiler magic if it is _complete enough_ to smooth over static/dynamic barriers.</p>",
        "id": 277059405,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648584999
    },
    {
        "content": "<p>Just like the slogan \"make it correct, then make it fast\", I prefer all magic to just be sugar over more verbose things I could write already.</p>",
        "id": 277059509,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585077
    },
    {
        "content": "<p>I am not quite sure how the core language (MIR) does trait object, but I assume it is very unsatisfying, quick google turns up <a href=\"https://www.cs.cornell.edu/~avh/dyn-trait-icse-seip-2022-preprint.pdf\">https://www.cs.cornell.edu/~avh/dyn-trait-icse-seip-2022-preprint.pdf</a> I supose I should take a look.</p>",
        "id": 277059708,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585196
    },
    {
        "content": "<p><em>shrug</em> I feel like Rust has followed a bit of a C++ path where it's considered bad to have the compiler do something special-case that \"you should be able to do in libraries\" but then to express those things in libraries the language grows (and the compiler is obliged to implement) much more complex general-purpose mechanisms, where it would have cost both implementation and user cognitive load much less to just leave the special case in.</p>",
        "id": 277059784,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648585224
    },
    {
        "content": "<p>Hmm that's not how I would read the C++ history. C++ and Scala just grow ever more complex because they never got the <em>right</em> core things. It is one 90% kludge after another.</p>",
        "id": 277059843,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585272
    },
    {
        "content": "<p>but I know this ship has sailed about 10 years ago and I am not here to reverse that course. please ignore general commentary; the specific topic is more interesting :)</p>",
        "id": 277059847,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648585275
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/49708\">https://github.com/rust-lang/rust/issues/49708</a> if this goes the way I want, and they let me implement a permanently unstable <code>DynSized</code>, I think that is the beachhead needed to make all the other stuff happen, so fingers crossed.</p>",
        "id": 277060029,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585365
    },
    {
        "content": "<p>Also Haskell (where I spend more time these days) will probably get monomorphizing quanitification sooner or later because we are all sick of boxing, and so I can attack the problem from both sides.</p>",
        "id": 277060139,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585427
    },
    {
        "content": "<p>(In general, advocating for language design feels like talking to multiple completely isolated tunnneling teams from different sides of the mountain. I've almost for 10 years wanted the <em>one</em> language that does all the things, and is still less far less crazy than Scala or C++, and then we can build dialects on top making different opposed use-cases more ergonomic.)</p>",
        "id": 277060342,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585547
    },
    {
        "content": "<p>I doubt the tunneling teams of haskell and rust are likely to meet in the middle! I'd think of it more like different musicians sometimes doing covers of one another's stuff. each language usually has its own themes.</p>",
        "id": 277060576,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648585682
    },
    {
        "content": "<p>Well, I have yet to see anything that has happened that is fundamentally contradictory!</p>",
        "id": 277060630,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585720
    },
    {
        "content": "<p>I suppose the \"do all the things\" subtext is clearer in Haskell, where from the beginnings of GHC there was <a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/1991/01/unboxed-values.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/1991/01/unboxed-values.pdf</a></p>",
        "id": 277060825,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585794
    },
    {
        "content": "<p>And back then, being merely not slow as shit, let alone making speed daemon system programming expressible, already seemed difficult enough.</p>",
        "id": 277061101,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585887
    },
    {
        "content": "<p>Safe interop with Spider (JS) is no longer the business imperative it was, but hoping C++ interop keeps Rust moving in good directions nonetheless.</p>",
        "id": 277061247,
        "sender_full_name": "John Ericson",
        "timestamp": 1648585977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"158781\">Graydon Hoare</span> <a href=\"#narrow/stream/213817-t-lang/topic/I'd.20love.20to.20write.20.22slow.20Rust.22.20sometimes/near/277054947\">said</a>:</p>\n<blockquote>\n<p>Some languages with existentials / dynamic first-class modules have a syntactic form where the dynamic type is \"opened\" / pinned to a static identity for the duration of a given code block.  so you have something like (spitballing syntax)  <code>fn foo(x: dyn T) { type K = &lt;x as T&gt;::K; /* ... use K as an unknown but static type in this block */ }</code></p>\n</blockquote>\n<p>I think the formal name for this concept is <a href=\"https://stackoverflow.com/questions/2693067/what-is-meant-by-scalas-path-dependent-types\">path-dependent types</a>?</p>",
        "id": 277124308,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648636840
    },
    {
        "content": "<p>I think there's some overlap with PDTs but I'm not certain I'd call them exactly the same feature. <a href=\"http://lampwww.epfl.ch/~amin/dot/fpdt.pdf\">http://lampwww.epfl.ch/~amin/dot/fpdt.pdf</a> has a little discussion in the related work section -- I think Rossberg's MixML, F-ing modules and 1ML work explores the design space a fair bit. I actually tried to cram something like this into early Rust but I got about half way through trying to understand the MixML implementation and gave up. I have an old pathetic email-for-help I sent to Rossberg in 2008.</p>",
        "id": 277207332,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648676281
    },
    {
        "content": "<p>(<a href=\"https://mrapoport.com/publ/pdot.pdf\">https://mrapoport.com/publ/pdot.pdf</a> gives even more related work -- this stuff is incredibly subtle; Odersky, Amin, Grutter, Rompf, Rapoport etc. have been working on \"a sound and complete formal model\" for Scala's semantics for like .. most of its life, maybe 15 or more years?)</p>",
        "id": 277209505,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1648677778
    }
]