[
    {
        "content": "<p>In <a href=\"https://github.com/rust-lang/rust/issues/74836\">#74836</a> , <span class=\"user-mention\" data-user-id=\"352985\">@tm</span> :</p>\n<blockquote>\n<p>I wondered about that too. So far I noticed that it would require additional changes to take into account lifetime extension / promotion, as direct implementation would allow:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"p\">[</span><span class=\"nb\">String</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Why do we not want to allow this? The const promotion rules in the reference state that we promote consts if the value could be written in a const, and that seems to be the case here (<code>[String; 0]</code> being a ZST and all...)</p>",
        "id": 278541130,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649677530
    },
    {
        "content": "<p>Is the proposal to desugar to <code>&amp;{ let _ = String::new(); [] }</code>? Because in that case you have to run <code>String</code>'s non-const Drop impl, which would make it ineligible for const promotion</p>",
        "id": 278544572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649679540
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"p\">[</span><span class=\"nb\">String</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[]</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles today</p>",
        "id": 278545175,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649679867
    },
    {
        "content": "<p>yes, because it const promotes the <code>[]</code> only and not the <code>let _ = String::new()</code> which happens at runtime</p>",
        "id": 278547810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649681165
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/95935\">#95935</a> is up with what I am proposing for the fix. The code given above compiles under this PR</p>",
        "id": 278548074,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649681302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Fixing.20zero.20length.20array.20leak/near/278547810\">said</a>:</p>\n<blockquote>\n<p>yes, because it const promotes the <code>[]</code> only and not the <code>let _ = String::new()</code> which happens at runtime</p>\n</blockquote>\n<p>I'm not sure I really understand. The const is a <em>value</em>. <code>[String::new(); 0]</code> is not a different value from <code>[]</code>; why should they be treated differently for const promotion?</p>",
        "id": 278548126,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649681350
    },
    {
        "content": "<p><code>[String::new(); 0]</code> is an <em>expression</em>, which drops a string</p>",
        "id": 278549209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649681890
    },
    {
        "content": "<p>Yes, but when we promote consts we don't promote expressions, we promote values - that's what consts are</p>",
        "id": 278549291,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649681933
    },
    {
        "content": "<p>we don't want that to be legal in <code>const</code>, but arguably it would be okay to const promote the <code>[]</code> part after desugaring as above</p>",
        "id": 278549306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649681942
    },
    {
        "content": "<p>Oh interesting, extracting this into a function doesn't work; then const promotion is not what I thought it was</p>",
        "id": 278549675,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649682089
    },
    {
        "content": "<p>Ah, I misread the reference documentation on this. Yeah, this indeed doesn't work then...</p>",
        "id": 278550190,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649682345
    },
    {
        "content": "<p>Unfortunately, this compiles today:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"p\">[</span><span class=\"nb\">String</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278557373,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649685571
    },
    {
        "content": "<p>Which... complicates things. This means that fixing this might even be a breaking change</p>",
        "id": 278557707,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649685680
    },
    {
        "content": "<p>Note that the current plan is <em>not</em> to extend const promotion, but to require <code>const { ... }</code> around the things that aren't \"trivially obviously const\" (like <code>const</code>s or literals).</p>",
        "id": 278591496,
        "sender_full_name": "scottmcm",
        "timestamp": 1649699355
    },
    {
        "content": "<blockquote>\n<p>Which... complicates things. This means that fixing this might even be a breaking change</p>\n</blockquote>\n<p>As a hack you could only fix this in non-const code and we can figure out a future incompat lint.</p>\n<p>Or we just try it out on crater and <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 278592636,
        "sender_full_name": "oli",
        "timestamp": 1649699825
    },
    {
        "content": "<p>My preferred solution would be to require Copy for repeat operand unless length operand is known to be 1, mostly to avoid answering question what happens with [const item that needs to be dropped; 0], which feels surprising either way.</p>",
        "id": 278595910,
        "sender_full_name": "tm",
        "timestamp": 1649701272
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/95819/files\">https://github.com/rust-lang/rust/pull/95819/files</a> moves the logic from a mir based one to a hir based one, which is closer to what the user wrote and thus mdore explicit about what we allow and why</p>",
        "id": 278597643,
        "sender_full_name": "oli",
        "timestamp": 1649701898
    },
    {
        "content": "<p>I think it is simultaneously a breaking change and allows more code. Gotta document more and write more tests, but we can easily add more checks for zero sized arrays here</p>",
        "id": 278598357,
        "sender_full_name": "oli",
        "timestamp": 1649702180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/Fixing.20zero.20length.20array.20leak/near/278592636\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Which... complicates things. This means that fixing this might even be a breaking change</p>\n</blockquote>\n<p>As a hack you could only fix this in non-const code and we can figure out a future incompat lint.</p>\n<p>Or we just try it out on crater and <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>\n</blockquote>\n<p>If I'm understanding correctly, this would at least allow the above code, but not the same thing if it's the result of const promotion, yes?</p>",
        "id": 278598677,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702300
    },
    {
        "content": "<p>Const promotion is its very own analysis. We'll need to carefully build the MIR, but I think it should be possible</p>",
        "id": 278600056,
        "sender_full_name": "oli",
        "timestamp": 1649702940
    },
    {
        "content": "<p>Const promotion is its very own analysis. We'll need to carefully build the MIR, but I think it should be possible</p>",
        "id": 278600269,
        "sender_full_name": "oli",
        "timestamp": 1649703040
    },
    {
        "content": "<p>We'd essentially need to know what is promoted to a const at MIR build time, right?</p>",
        "id": 278601116,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649703477
    },
    {
        "content": "<p>I think we just need to make sure that the transformation we do will be handled correctly by promotion</p>",
        "id": 278602943,
        "sender_full_name": "oli",
        "timestamp": 1649704384
    },
    {
        "content": "<p>Basically there needs to be some path from the repeat element to the reference. I mean, we could \"simply\" emit both the drop and the repeat rvalue</p>",
        "id": 278603082,
        "sender_full_name": "oli",
        "timestamp": 1649704447
    },
    {
        "content": "<p>That way promotion picks it up from the data flow and we get the early drop</p>",
        "id": 278603176,
        "sender_full_name": "oli",
        "timestamp": 1649704519
    },
    {
        "content": "<p>Tho I wonder if we shouldn't rather fix drop elab to handle this correctly</p>",
        "id": 278603237,
        "sender_full_name": "oli",
        "timestamp": 1649704562
    },
    {
        "content": "<p>Sorry, I'm sort of lost here. What's the intended outcome of your proposal?</p>",
        "id": 278603388,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649704632
    },
    {
        "content": "<p>Promotion does dataflow to see if any nonconst values or operations flow into a rvalue::ref's argument. If there is no dataflow from the repeat element to the repeat expression being borrowed, promotion will rightfully promote the repeat expression.<br>\nIf we do your PR, but instead of early returning a zst constant we just fall through to the repeat rvalue, then we get both: the drop and the correct dataflow for promotion</p>",
        "id": 278603653,
        "sender_full_name": "oli",
        "timestamp": 1649704790
    },
    {
        "content": "<p>This way <code>&amp;[String::new(); 0]</code> does not get promoted and <code>[String::new(); 0]</code> drops the single String element</p>",
        "id": 278603779,
        "sender_full_name": "oli",
        "timestamp": 1649704854
    },
    {
        "content": "<p>I see. That does not fix the breaking change though, right?</p>",
        "id": 278603826,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649704879
    },
    {
        "content": "<p>Ah, for that you check whether the thing currently being mir build is a const context</p>",
        "id": 278603945,
        "sender_full_name": "oli",
        "timestamp": 1649704926
    },
    {
        "content": "<p>Right, ok, you're suggesting doing both. This makes sense now</p>",
        "id": 278604081,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649705007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/Fixing.20zero.20length.20array.20leak/near/278603653\">said</a>:</p>\n<blockquote>\n<p>Promotion does dataflow to see if any nonconst values or operations flow into a rvalue::ref's argument. If there is no dataflow from the repeat element to the repeat expression being borrowed, promotion will rightfully promote the repeat expression.<br>\nIf we do your PR, but instead of early returning a zst constant we just fall through to the repeat rvalue, then we get both: the drop and the correct dataflow for promotion</p>\n</blockquote>\n<p>Would this effectively requiring special casing the analysis in one of borrowck/const promotion? It seems like the same dataflow that prevents the const from being promoted would cause a use after move error in borrowck</p>",
        "id": 278604418,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649705190
    },
    {
        "content": "<p>Oh... hmpf</p>",
        "id": 278605026,
        "sender_full_name": "oli",
        "timestamp": 1649705484
    },
    {
        "content": "<p>OK, maybe we just add a mir opt after borrowck that does your transform before drop elab?</p>",
        "id": 278605264,
        "sender_full_name": "oli",
        "timestamp": 1649705599
    },
    {
        "content": "<p>Oh hmm, that sounds like it could totally work. This seems like it would still be recognizable then and everything. We could do this after const promotion as well, right? Thereby bypassing that whole issue too</p>",
        "id": 278605525,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649705737
    },
    {
        "content": "<p>The earlier in the pipeline, the better</p>",
        "id": 278605770,
        "sender_full_name": "oli",
        "timestamp": 1649705865
    },
    {
        "content": "<p>So I'm trying this right now, and I think it almost works out, except for the unwind path. It poses a problem because 1) we don't really have the information on how to build it after MIR building, and 2) borrowck not knowing about it sounds like it would cause bugs</p>",
        "id": 278611198,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649708485
    },
    {
        "content": "<p>Hmm, can we insert a <code>FakeUnwind</code> here?</p>",
        "id": 278613480,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649709550
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/95953\">#95953</a> contains the new candidate implementation</p>",
        "id": 278625101,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649715846
    }
]