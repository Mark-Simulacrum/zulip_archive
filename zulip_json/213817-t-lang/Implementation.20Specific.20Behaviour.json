[
    {
        "content": "<p>I wanted to raise this question when I was reminded of this comment:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270226146\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225982\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/asm!.20and.20backends/near/270225700\">said</a>:</p>\n<blockquote>\n<p>Why is it called <code>asm!</code> instead of <code>llvm_asm!</code>? It's apparently still tied up with LLVM</p>\n</blockquote>\n<p>Or do what C++ does, which is just say its <em>conditionally-supported</em> with <em>implementation-defined</em> semantics.</p>\n</blockquote>\n<p>A world of <em>nope</em> to anything \"implementation-defined\" in Rust.</p>\n</blockquote>\n<p>I wanted to clarify <em>implementation-defined</em> behaviour (and related behaviours) as it applies to rust.<br>\nC++ has 3 categories of implementation-specific behaviour, other than undefined behaviour:<br>\n<em>implementation-defined behaviour</em> is classified as parameters of the abstract machine on which the standard operates. <a href=\"http://eel.is/c++draft/intro.abstract#2\">http://eel.is/c++draft/intro.abstract#2</a>. It further requires that implementations document the choices for these parameters. Arguably, rust has limited implementation-defiend behaviour</p>\n<ul>\n<li>The set of target features available in cfg are implementation-defined </li>\n<li>Whether or not overflowing default scalar operations panic or wrap is implementation-defined</li>\n</ul>\n<p><em>Unspecified behaviour</em> is classified as non-deterministic aspects of the parameterized abstract machine, of which the implementation choices made for each occurance in a program consistutes an \"execution\". Unspecified behaviour and implementation-defined behaviour differ only in that the standard does not require documentation for the latter. Rust does have several occurances of unspecified behaviour (characterized sometimes in documentation as unstable), such as:</p>\n<ul>\n<li>The layout of repr(Rust) types</li>\n<li>The ABI of <code>extern \"Rust\"</code> functions</li>\n<li>The pointer returned by <code>core::ptr::NonNull::dangling()</code></li>\n<li>etc.</li>\n</ul>\n<p>There is also <em>conditionally-supported behaviour</em> which is similar to implementation-defined behaviour. An implementation is required to document all conditionally-supported behaviour it does not support (but not the ones it does). Rust has no occurances of this currently.</p>\n<p>This set could be extended to include <em>target-specific behaviour</em> which I would ideally categorize as implementation-defined behaviour, but for a set of well-known targets, the behaviour could be fixed. There are arguments that this should be fixed exhaustively, however, this places the burden of new target support solely on t-lang, which may be unreasonable for some implementations, and may be unreasonable, especially when the choices may be obvious (for example, size of <code>usize</code> on a platform with 32-bit pointers and registers). </p>\n<ul>\n<li>The name of each of the cfg(target_*) components set</li>\n<li>The complete set of target features</li>\n<li>The size_of::&lt;usize&gt;() et. al</li>\n<li>The underlying type of <code>std::ffi::c_int</code>, <code>std::ffi::c_long</code>, and <code>std::ffi::c_char</code></li>\n<li>Which of the <code>core::arch</code> and <code>std::os</code> submodules are available, if any.</li>\n</ul>\n<p>(Note: I do not consider the options passed to the rustc invocation anything more than a detail of the implementation, and a way to control unspecified, implementation-defined, and target-specific behaviour. )</p>",
        "id": 271866373,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644862571
    },
    {
        "content": "<p>Do these lists seem correct as described?</p>",
        "id": 271866503,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644862643
    },
    {
        "content": "<p>Seems a stretch to call overflow behavior implementation-defined because that can be configured in cargo.toml. Would we expect some implementations to just ignore the user setting?</p>",
        "id": 271866996,
        "sender_full_name": "The 8472",
        "timestamp": 1644862895
    },
    {
        "content": "<p>Or perhaps it's a very unintuitive way to interpret implementation-defined when it applies to all implementations.</p>",
        "id": 271867139,
        "sender_full_name": "The 8472",
        "timestamp": 1644862945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271866996\">said</a>:</p>\n<blockquote>\n<p>Seems a stretch to call overflow behavior implementation-defined because that can be configured in cargo.toml. Would we expect some implementations to just ignore the user setting?</p>\n</blockquote>\n<p>See my note: the options passed to the rustc invocation aren't considered here as more than a detail of how the implementation makes a choice for implementation-defined behaviour.<br>\nA non-rustc CLI is a perfectly valid implementation. It couldn't be used with cargo directly, but it's a valid implementation.</p>",
        "id": 271868445,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644863614
    },
    {
        "content": "<p>Depends on whether the CLI is part of the spec so that other implementations have to be plug-in compatible or not.</p>",
        "id": 271870385,
        "sender_full_name": "The 8472",
        "timestamp": 1644864545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271870385\">said</a>:</p>\n<blockquote>\n<p>Depends on whether the CLI is part of the spec so that other implementations have to be plug-in compatible or not.</p>\n</blockquote>\n<p>Well, there are implementations without a rustc CLI already - gcc-rs being one of them and, strictly speaking, lccc's rust frontend. <br>\nThe entire frontend for the rust implementation is <code>xlangfrontend-rust.{so,dll}</code>, and that definately doesn't have  CLI. You could load that up with the necessary backend and intermediate transformers, agnostic of the driver (or even without any driver). The default driver is gcc-like, though there is a rustc driver planned, and also a \"raw\" driver that doesn't do fancy stuff like frontend detection (the invocation is something like <code>xlang --frontend=&lt;name or plugin path&gt; --backend=&lt;name or plugin path&gt; [--plugin &lt;name-or-path&gt;]... &lt;input&gt; &lt;output&gt;</code>). I'd argue these are still valid drivers for a rust implementation.</p>",
        "id": 271874311,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644866122
    },
    {
        "content": "<p>yeah, ok, that argument was the wrong direction. What I mean is that some software might only be tested with overflow checks enabled. If we say implementation-defined without saying that it's an externally configurable input then always disabling overflow checks would be a valid implementation, no? Which could leave a security hole in such software.</p>",
        "id": 271877341,
        "sender_full_name": "The 8472",
        "timestamp": 1644867348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271877341\">said</a>:</p>\n<blockquote>\n<p>yeah, ok, that argument was the wrong direction. What I mean is that some software might only be tested with overflow checks enabled. If we say implementation-defined without saying that it's an externally configurable input then always disabling overflow checks would be a valid implementation, no? Which could leave a security hole in such software.</p>\n</blockquote>\n<p>Well, it's guaranteed that overflow checks occur when debug assertions are enabled (which would also be implementation-defined).<br>\nIf an implementation didn't support overflow checks via <code>-C overflow-checks</code>, it probably doesn't support cargo, in which case, the software likely won't build unless it's aware of this possibility (and would be aware of the alternative, and ways to check if the alternative is available, e.g. <code>-ftrapv</code>).</p>",
        "id": 271877899,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644867558
    },
    {
        "content": "<p>First, implementation-defined behavior assumes that other implementations can make different definitions. I don't think that's necessarily the case; we'd need to make a deliberate decision to that effect about features that Rust implementations can vary on and features they can't.</p>",
        "id": 271914257,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644888194
    },
    {
        "content": "<p>Second, I think we <em>do</em> fix the behavior of targets, when defining those targets; that behavior should be fixed for all implementations of the same target, and should only differ in a different target.</p>",
        "id": 271914320,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644888251
    },
    {
        "content": "<p>(though that doesn't necessary make it lang)</p>",
        "id": 271914330,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644888260
    },
    {
        "content": "<p>Third, I do think some aspects of the command line may need to be standardized, not varying; that again needs a deliberate decision.</p>",
        "id": 271914354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644888298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> </p>\n<blockquote>\n<p>Well, there are implementations without a rustc CLI already - gcc-rs being one of them and, strictly speaking, lccc's rust frontend. </p>\n</blockquote>\n<p>It remains to be seen if those become Rust implementations. Right now, I think they're implementations of some subset of Rust.</p>",
        "id": 271914473,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644888414
    },
    {
        "content": "<p>Whether that subset becomes complete will depend both on the implementation (downstream) and on the definition of \"complete\" (upstream).</p>",
        "id": 271914525,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644888474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914473\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> </p>\n<blockquote>\n<p>Well, there are implementations without a rustc CLI already - gcc-rs being one of them and, strictly speaking, lccc's rust frontend. </p>\n</blockquote>\n<p>It remains to be seen if those become Rust implementations. Right now, I think they're implementations of some subset of Rust.</p>\n</blockquote>\n<p>Fair. Although mrustc is arguably an implementation of 1.54</p>\n<p>In either case, I doubt it's a good idea to even stabilize the existance of a CLI from a language perspective, let alone it's form. I think that it may be a good optional feature set, and further constrains choices of implementation-defined behaviour, but it should be opt-in for the implementation. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914257\">said</a>:</p>\n<blockquote>\n<p>First, implementation-defined behavior assumes that other implementations can make different definitions. I don't think that's necessarily the case; we'd need to make a deliberate decision to that effect about features that Rust implementations can vary on and features they can't.</p>\n</blockquote>\n<p>IIRC, the numeric overflow RFC left it up to the implementation to decide, effectively. Keep in mind that it's not necessarily \"different implementations can choose w/e\" implementation-defined behaviour can be (and almost always is) constrained. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914320\">said</a>:</p>\n<blockquote>\n<p>Second, I think we <em>do</em> fix the behavior of targets, when defining those targets; that behavior should be fixed for all implementations of the same target, and should only differ in a different target.</p>\n</blockquote>\n<p>Right, but outside of the defined set of targets, implementations should be free to choose the behaviour. If I'm compiling for proprietaryinternalprocessor-pc-internal, I should be able to say what the choices are for the target-dependant behaviour, without necessarily consulting upstream, especially in the case where it's unlikely any other implementation would pick it up.</p>",
        "id": 271916362,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644890046
    },
    {
        "content": "<p>To be clear, I'm not suggesting we should standardize the CLI, I'm just suggesting that we haven't made a decision on that front at all, and we should make a deliberate decision.</p>",
        "id": 271916393,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644890096
    },
    {
        "content": "<p>I do think there's an advantage to having a standardized command line interface, even if we said that not all compilers need to have a command line interface; we could effectively say that if you have one, it needs to have certain options and syntax, which would help people invoke it in a standardized way. That actually seems helpful for other compilers, to give them a clear standard to support that will let them drop in.</p>",
        "id": 271916422,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644890142
    },
    {
        "content": "<p>Regarding targets, the problem is that if some other implementation of rust or of a subset of rust ends up establishing a target by a given name, and then makes implementation decisions about that target, we could get stuck with some of those implementation decisions, or find ourselves having to consider breaking large numbers of existing users.</p>",
        "id": 271916496,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644890190
    },
    {
        "content": "<p>That's part of why I'd come up with a candidate target policy, for proposing targets that aren't ready to even become tier 3 in rust itself.</p>",
        "id": 271916506,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644890206
    },
    {
        "content": "<p>Part of the goal was to create a way to register a target and make the obvious decisions, without having to get that target upstream.</p>",
        "id": 271916519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644890225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271916496\">said</a>:</p>\n<blockquote>\n<p>Regarding targets, the problem is that if some other implementation of rust or of a subset of rust ends up establishing a target by a given name, and then makes implementation decisions about that target, we could get stuck with some of those implementation decisions, or find ourselves having to consider breaking large numbers of existing users.</p>\n</blockquote>\n<p>Well, sure, but a lot of the decisions will either be obvious, fixed, or be decided outside of the context of rust (usually a combination of all three). I've mentioned it before, but it's not like T-lang can change the C ABI of a target, especially if it's already been in use for a while. <br>\nI'm also thinking about internal proprietary targets that might never see an official implementation.</p>\n<p>Also, speaking specifically of lccc, but may apply equally to gcc-rs. It seems unnecessarily restrictive that only the rust frontend for those implementations cannot support a target (and I'd personally not be a fan of making all of the targets supported period be a subset of those supported by rust). In lccc, the set of supported targets is dictated by <code>xlang_target</code>, which also describes common information for all targets.</p>\n<p>I've got a target this easily applies to (a WIP 64-bit ISA <a href=\"https://github.com/Clever-ISA/Clever-ISA\">https://github.com/Clever-ISA/Clever-ISA</a>&gt;). The default model would be pointers 64-bit, long 64-bit, int 32-bit. There would also likely be an ILP32 model. The target (arch) names are specified, the feature names are specified, assembly syntax is mostly given. <br>\nI'm unsure there would be any decisions at all left for rust, in this case.</p>",
        "id": 271922740,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644896401
    },
    {
        "content": "<p>That sounds like a target easily proposed as a candidate target then...</p>",
        "id": 271922838,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644896489
    },
    {
        "content": "<p>Well, it's unlikely to see it's way into rustc specifically for a while. While most of the major ISA development is complete, toolchain development is lacking... and as it stands, I'm more likely to include it more quickly in lccc and it's related tooling than in the absolutely annoying gcc+binutils and llvm stacks.</p>",
        "id": 271923077,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644896757
    },
    {
        "content": "<p>Sure. But there's no reason it couldn't be, hence coordinating about it.</p>",
        "id": 271925261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644898878
    },
    {
        "content": "<p>I can imagine a lot of targets are like this, with very little room to do much of anything other than say \"Yes\" or \"No\". In which case, is there a reason that decision shouldn't be left up to the implementors, assuming the target isn't so far out of left field that it violates basic assumptions? </p>\n<p>I could also imagine that implementations like gcc-rs or lccc could easily use this to side step the \"well, we should coordinate it\". After all, both of them aren't just a rust implementation. If I want to add a target and lockdown all the details to w/e I want, I could add it to every other frontend (which is as theoretically as easy as adding somewhere between 13 and 40 lines of code to xlang_target, then adding backend support for the architecture if necessary), stabilize the C abi, then request it added to rust.  Seems like a lot of extra steps, and gives considerable advantage in that regard to multi-language implementations. </p>\n<p>Not saying I would do that, but I'm sure you could see how that could easily be used by a hostile implementation to sidestep coordinating anything. Or just as a shortcut.</p>",
        "id": 271925651,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644899288
    },
    {
        "content": "<p>The scenarios are:</p>\n<ol>\n<li>A rust implementation adds a new target nobody supports yet, unilaterally decides everything about the target, then later proposes it upstream with everything fixed, vs.</li>\n<li>A C implementation adds a new target nobody supports yet, unilaterally decides everything about the target, then proposes it upstream to rust with everything fixed. Oh, and then trivially adds support to the rust frontend using the same architecture.</li>\n</ol>\n<p>The only difference I see here is that in the latter case,  the details of the target get decided without necessarily applying it to rust itself, and that the rust implementation needs to have a C frontend in the same tree.</p>",
        "id": 271925858,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644899536
    },
    {
        "content": "<p>(Or not even just C, <em>any other language</em> but rust)</p>",
        "id": 271925876,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644899563
    },
    {
        "content": "<p>C compilers sometimes coordinate new target definitions too, especially contemporary ones. The x86-64 target was coordinated, for example.</p>",
        "id": 271927914,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644901632
    },
    {
        "content": "<p>Sure, they can, and sometimes do. But they aren't requried to.</p>",
        "id": 271966438,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644928150
    },
    {
        "content": "<p>Also, I'd argue that the fact that they do without being required to is an argument that Rust implementations might do the same. I known that I'd be likely to coordinate with upstream any time that there are major decisions to be made.</p>",
        "id": 271967437,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644928737
    },
    {
        "content": "<p>And it's basically artifically limiting the frontend in these cases. In lccc, if xlang_target supports the target, then all of the frontends support it by design. If the rust frontend is the only one that imposes a limitation, that wouldn't be a technical limitation.</p>",
        "id": 271968444,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644929273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/271914257\">said</a>:</p>\n<blockquote>\n<p>First, implementation-defined behavior assumes that other implementations can make different definitions. I don't think that's necessarily the case; we'd need to make a deliberate decision to that effect about features that Rust implementations can vary on and features they can't.</p>\n</blockquote>\n<p>Also, this is already the case:<br>\n<code>rustc -C overflow-checks=y</code> vs. <code>rustc -C overflow-checks=n</code> are different parameterized abstract machines in terms of rust - one panics on <code>i32::MAX+1</code>, the other one produces <code>i32::MIN</code> (or issues an deny-by-default lint). </p>\n<p>From RFC 0560:</p>\n<blockquote>\n<h2>Summary</h2>\n<p>[...]<br>\nImplementations are permitted to check for overflow at any time (statically or dynamically). Implementations are required to at least check dynamically when debug_assert! assertions are enabled. [...]</p>\n<h2>Arithmetic operations with error conditions</h2>\n<p>[...]<br>\nThe result of an error condition depends upon the state of overflow checking, which can be either enabled or default (this RFC does not describe a way to disable overflow checking completely). If overflow checking is enabled, then an error condition always results in a panic.<br>\n[...]</p>\n<h2>Enabling Overflow Checking</h2>\n<p>[...]<br>\nCompilers should present a command-line option to enable overflow checking universally.</p>\n</blockquote>\n<p>These sections together, at least to me,  seem to imply three things<br>\n(1) It is the implementation's choice to check overflow, except that it must when debug_assertions are enabled<br>\n(2) The result of checking overflow is a panic, otherwise, it wraps (constraint on the behaviour when disabled). Note that the Summary section also permits the implementation to issue a diagnostic and make the program ill-formed if overflow can be detected (which rustc <em>does</em>)<br>\n(3) Implementations are recommended - but not required - to provide (and likely to document) a command line switch to control.</p>\n<p>This seems to me to be a declaration of <em>implementation-defined</em> behaviour - the only thing that is missing is a mandate that the implementation documented it's choice in (1) (which would be implied in documentation of (3)). It could also be interpreted as unspecified behaviour, and it's merely a choice of rustc, as recommended, to provide a documented command line flag (which is a valid part of an implementations documentation - choices for unspecified behaviour).</p>",
        "id": 271986236,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644937243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> </p>\n<blockquote>\n<p>Fair. Although mrustc is arguably an implementation of 1.54</p>\n</blockquote>\n<p>I'd emphatically disagree, mrustc cannot count as a conformant implementation of Rust because it allows an arbitrary superset of the language, specifically the superset that includes \"all programs that would be rejected by a borrow checker\". Arguably conformant implementations might be able to define <em>subsets</em> of the language, but certainly not arbitrary <em>supersets</em>, at least not on a stable-esque channel, and at least not without specific license from the hypothetical specification (I'm assuming that it will not be a valid implementation-defined choice to not provide a borrow checker). Which isn't to denigrate how cool or useful mrustc is, of course</p>",
        "id": 272034034,
        "sender_full_name": "bstrie",
        "timestamp": 1644957245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> I'm honestly concerned both about subset-of-Rust implementations and superset-of-Rust implementations, for different reasons. I agree with you underlying point though.</p>",
        "id": 272034188,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644957355
    },
    {
        "content": "<p>C and C++ both explicitly note that an implementation can translate an ill-formed program, and, while I'd expect rust to recommend implementations not translate additionall ill-formed programs, I wouldn't expect it to forbid it.<br>\nsubset-of-Rust isn't a valid implementation (notwithstanding lints that can be controlled), but I'd expected superset-of-Rust to be valid, though discouraged.</p>",
        "id": 272034322,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644957416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> A subset-of-Rust implementation causes ecosystem issues if it pushes people to stick to that subset for compatibility. A superset-of-Rust implementation causes ecosystem issues if people use that superset and expect Rust to add that feature without breaking it (effectively, such an implementation bypasses the unstable-to-stable development cycle).</p>",
        "id": 272034351,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644957435
    },
    {
        "content": "<p>(Especially wrt. something like mrustc, which is explicitly designed to be a simple implementation that sidesteps the huge implementation pain of the borrow checker, while being designed to operate on code known to be well-formed, namely rustc itself)</p>",
        "id": 272034477,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644957492
    },
    {
        "content": "<p>indeed, I'm not <em>entirely</em> on board with allowing subsets in \"conformant Rust implementations\", although in practical terms it may be functionally impossible to <em>actually</em> implement 100% of Rust, so we'd need some sort of reasonable cut-off to say that an implementation is \"close enough\". If we were to produce a Rust specification today, for example, I highly doubt rustc would adhere to it 100%, when you take bugs into account...</p>",
        "id": 272034517,
        "sender_full_name": "bstrie",
        "timestamp": 1644957519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I would be very happy to see Rust specifically say \"if you have extensions to Rust, you're not a compliant Rust implementation\", for precisely the reason of it creating expectations that such extensions will not change when becoming part of Rust. Or, possibly, to have some process for handling such extensions.</p>",
        "id": 272034535,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644957528
    },
    {
        "content": "<p>(And arguably, unstable features themselves are a form of superset)</p>",
        "id": 272034568,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644957546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272034477\">said</a>:</p>\n<blockquote>\n<p>(Especially wrt. something like mrustc, which is explicitly designed to be a simple implementation that sidesteps the huge implementation pain of the borrow checker, while being designed to operate on code known to be well-formed, namely rustc itself)</p>\n</blockquote>\n<p>I do think what mrustc does makes sense, and I think we <em>should</em> have a process for explicitly permitting mrustc to do that, which is not the same as saying that we should allow borrow-checker-less implementations in general.</p>",
        "id": 272034635,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644957592
    },
    {
        "content": "<p>As an example, I think mrustc's approach of \"this exists to compile already-known-working Rust code for bootstrapping purposes\" is very different than a compiler that intentionally omits borrow checking so that people can write code that does mutable aliasing, or a compiler that provides a <code>#[borrow_checker(disable)]</code>.</p>",
        "id": 272034793,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644957667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272034535\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> I would be very happy to see Rust specifically say \"if you have extensions to Rust, you're not a compliant Rust implementation\", for precisely the reason of it creating expectations that such extensions will not change when becoming part of Rust. Or, possibly, to have some process for handling such extensions.</p>\n</blockquote>\n<p>You'd have to define what an \"extension\" is. Would an implementation happening to be well-behaved in the face of some undefined behaviour be considered an extension? What about if it then documents that choice. Or if it documents the specific layout of repr(Rust) structures on that implementation (which is something I already do). <br>\nDefinately, I think that unstable features are the right way to go for extensions (especially wrt. well-formedness), and implementations should be discouraged from going beyond that, but I'd still consider a line such as \"An implementation may nonetheless translate an ill-formed program for which it produces a diagnostic\" necessary for a specification.</p>",
        "id": 272034998,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644957779
    },
    {
        "content": "<p>right, I don't think we need to censure or denounce mrustc, we should just be clear that it's not quite \"an implementation of Rust\" so much as it's a \"Rust-compatible code generator\" or something, if we implicitly allow \"implementation\" (or \"compiler\") to suggest a full suite of static analysis that strictly characterizes the language</p>",
        "id": 272035038,
        "sender_full_name": "bstrie",
        "timestamp": 1644957810
    },
    {
        "content": "<p>(An exception would be something like the <code>compile_error!</code> macro, in the same way that C explicitly forbids implementations from translating a program that contains an <code>#error</code> directive that isn't removed by the preprocessor)</p>",
        "id": 272035145,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644957862
    },
    {
        "content": "<blockquote>\n<p>You'd have to define what an \"extension\" is. Would an implementation happening to be well-behaved in the face of some undefined behaviour be considered an extension? What about if it then documents that choice. Or if it documents the specific layout of repr(Rust) structures on that implementation (which is something I already do). </p>\n</blockquote>\n<p>If users can rely on something like that then they'd end up writing code that only runs on that particular compiler and is UB on other rustc implementations. That's a pretty horrible outcome.</p>",
        "id": 272035501,
        "sender_full_name": "The 8472",
        "timestamp": 1644958064
    },
    {
        "content": "<p>An implementation may add something behind a feature gate, but be incapable of gating all parts of the feature (see <a href=\"https://internals.rust-lang.org/t/reserved-syntax-should-be-lexically-valid/15743\">https://internals.rust-lang.org/t/reserved-syntax-should-be-lexically-valid/15743</a>, where I noted that gating it from the lexer is not an option).</p>",
        "id": 272035591,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272035501\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>You'd have to define what an \"extension\" is. Would an implementation happening to be well-behaved in the face of some undefined behaviour be considered an extension? What about if it then documents that choice. Or if it documents the specific layout of repr(Rust) structures on that implementation (which is something I already do). </p>\n</blockquote>\n<p>If users can rely on something like that then they'd end up writing code that only runs on that particular compiler and is UB on other rustc implementations. That's a pretty horrible outcome.</p>\n</blockquote>\n<p>There are ways arround it (in my case, you have to either explicitly compile with a particular <code>-Z</code> option you can't set from cargo, or you can detect it and fallback when unavailable, which is still portable if the detection logic is correct)<br>\nAlso, you can already write non-portable code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272035743,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Regarding that thread, one underlying reason for not doing that is precisely that that syntax is reserved <em>so that Rust can use it</em>, and allowing it to be parsed and interpreted by a macro would potentially break our ability to use such syntax ourselves.</p>",
        "id": 272035845,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958222
    },
    {
        "content": "<p>If a macro can say \"ooh, shiny syntax, I'm going to parse <code>foo#thing</code> in my macro\", that could break our ability to create a Rust feature that uses <code>foo#thing</code>.</p>",
        "id": 272035919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958261
    },
    {
        "content": "<p>Which defeats part of the purpose of having reserved syntax.</p>",
        "id": 272035950,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958279
    },
    {
        "content": "<p>Yeah, I noted that. Although there are ways through, for example, by reserving a set of prefixes (say, <code>__&lt;XID_Continue&gt;+</code>) for implementations.</p>",
        "id": 272035996,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958308
    },
    {
        "content": "<p>We're talking about stable compilers. -Z / #[feature()] is nightly stuff. Aka this may blow up in your face at any time.</p>",
        "id": 272036022,
        "sender_full_name": "The 8472",
        "timestamp": 1644958322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272035996\">said</a>:</p>\n<blockquote>\n<p>Yeah, I noted that. Although there are ways through, for example, by reserving a set of prefixes (say, <code>__&lt;XID_Continue&gt;+</code>) for implementations.</p>\n</blockquote>\n<p>We could do that, which then raises the question of whether we want to have syntax space reserved for implementations, which then raises the question of whether we want implementation-specific extensions at all. :)</p>",
        "id": 272036124,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958358
    },
    {
        "content": "<p>Some implementations don't have that distinction.<br>\nI think of all of the ones that exist or are being worked on now, rustc <em>is</em> the only one that has that explicit distinction.</p>",
        "id": 272036135,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> But that aside, I do think it'd be reasonable to consider designating some specific part of syntax space (whether using <code>#</code> or something else) for macro use, so that macros can define \"keywords\" and know they won't conflict with identifiers, for instance.</p>",
        "id": 272036211,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958418
    },
    {
        "content": "<p>I think they can't be called compliant implementations then until they have a stable-compliant mode?</p>",
        "id": 272036217,
        "sender_full_name": "The 8472",
        "timestamp": 1644958421
    },
    {
        "content": "<p>This is perfectly fine for experimental/under development compilers , but they should advertise themselves similar to nightly.</p>",
        "id": 272036402,
        "sender_full_name": "The 8472",
        "timestamp": 1644958490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272036135\">said</a>:</p>\n<blockquote>\n<p>Some implementations don't have that distinction.<br>\nI think of all of the ones that exist or are being worked on now, rustc <em>is</em> the only one that has that explicit distinction.</p>\n</blockquote>\n<p>That also has to do with rustc being \"where Rust is developed\", and while I acknowledge the potential problems with that equivocation, it's also an accurate description.</p>",
        "id": 272036405,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958491
    },
    {
        "content": "<p>(lccc might include a <code>--disable-unstable</code> option, but that comes with issues, like needing to use a previously built version of the compiler to build the stdlib, because I don't want the RUSTC_BOOTSTRAP issue)</p>",
        "id": 272036414,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958495
    },
    {
        "content": "<p>(rustc is also unique among the group that I'm aware of, in that it contemplates binary distribution as the primary form of release, which enables the nightly/beta/stable distinction)</p>",
        "id": 272036506,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958551
    },
    {
        "content": "<p>well, it also has the advantage that you can't link nightly-built libs to stable</p>",
        "id": 272036735,
        "sender_full_name": "The 8472",
        "timestamp": 1644958646
    },
    {
        "content": "<p>TBH, the most I'd want to see in the spec related to stable is that</p>\n<blockquote>\n<p>The <code>#[feature]</code> attribute may be applied to a crate, and takes one or more identifiers, separated by commas. Whether or not the <code>#[feature]</code> attribute is supported is <em>implementation-defined</em> and the identifiers accepted by the attribute and their effects are unspecified.</p>\n</blockquote>",
        "id": 272036956,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958753
    },
    {
        "content": "<p>So, there are two separate aspects of that that might need to be treated independently.</p>",
        "id": 272037198,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958834
    },
    {
        "content": "<p>One is  \"you can be a compliant implementation whether or not you implement nightly Rust\", which I do think should be true.</p>",
        "id": 272037215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958844
    },
    {
        "content": "<p>It is true in fact, stable rustc (w/o <code>RUSTC_BOOTSTRAP</code>) is considered an implementation of rust, after all.</p>",
        "id": 272037277,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958882
    },
    {
        "content": "<p>The other is \"can other implementations define and implement arbitrary nightly features\", which needs thought, and <em>if</em> we support that it'd need both namespacing and perhaps something more specific than \"effects are unspecified\".</p>",
        "id": 272037295,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272037277\">said</a>:</p>\n<blockquote>\n<p>It is true in fact, stable rustc (w/o <code>RUSTC_BOOTSTRAP</code>) is considered an implementation of rust, after all.</p>\n</blockquote>\n<p>We don't yet have a definition of \"an implementation of Rust\", so \"it is true\" isn't yet established. But yes, I think that's a demonstration that it <em>should</em> be true if and when we have a definition.</p>",
        "id": 272037451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644958950
    },
    {
        "content": "<p>Certainly. I'd love to see namespaced features, currently I have an ugly <code>lccc_</code> prefix. But rustc already does define and implement arbitrary nightly features, and I definately already do and use them in the standard library.</p>",
        "id": 272037486,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644958970
    },
    {
        "content": "<p>Also, I'd say \"The effects are unspecified\" perfectly describes the situtation as-is, and the situtation I'd ideally have.<br>\nFirst, being unspecified doesn't prohibit documention, it merely doesn't mandate it.<br>\nSecond, unspecified can be constrained. It's not free-for-all. Well known features could be included in the spec, or separated out as a \"If you use these features, you should match these results\".</p>",
        "id": 272037954,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644959155
    },
    {
        "content": "<p>I'm thinking about constraints like \"features can't break the behavior of other mandatory aspects of the spec\". e.g. \"you can't have a feature to turn off the borrow checker\".</p>",
        "id": 272038311,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959298
    },
    {
        "content": "<p>Not trying to be too specific here, just thinking in general that there might need to be constraints on \"features can do anything\".</p>",
        "id": 272038371,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272037486\">said</a>:</p>\n<blockquote>\n<p>But rustc already does define and implement arbitrary nightly features, and I definately already do and use them in the standard library.</p>\n</blockquote>\n<p>I think it's important to distinguish the degree to which \"rustc defines nightly features\" and the degree to which \"Rust defines nightly features\". We have features that have been through an RFC or similar process, and we also have random internal features that haven't. The latter have been a regular source of problems.</p>",
        "id": 272038490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959389
    },
    {
        "content": "<p>That would be a valid constraint on the unspecified behaviour, but seeing as it's already designed to alter the well-formedness of a program, that would be a very difficult constraint to define.</p>",
        "id": 272038519,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644959402
    },
    {
        "content": "<p>Fully acknowledged. Specifications are not easy.</p>",
        "id": 272038621,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272038490\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272037486\">said</a>:</p>\n<blockquote>\n<p>But rustc already does define and implement arbitrary nightly features, and I definately already do and use them in the standard library.</p>\n</blockquote>\n<p>I think it's important to distinguish the degree to which \"rustc does\" and the degree to which \"Rust does\". We have features that have been through an RFC or similar process, and we also have random internal features that haven't. The latter have been a regular source of problems.</p>\n</blockquote>\n<p>Yes. I will note that I mostly consistently use Rust to mean the language, and rustc to mean the implementation. If I'm saying rustc does x, I'm pointing specifically to the rustc implementation in fact.</p>",
        "id": 272038648,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644959455
    },
    {
        "content": "<p>I've noticed that. :)<br>\nI tend to also use \"Rust\" to encompass \"the parts of rustc that I would vaguely imagine to be/define part of Rust\", which is a fuzzy line.</p>",
        "id": 272038759,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959519
    },
    {
        "content": "<p>It's possible to debate the merits of \"random internal features\" for sure, but I'd argue they're necessary to provide much of what is specified. For example, <code>#[lang]</code> (and likewise <code>core::intrinsics</code>) is easily something I can point to as \"this is necessarily a private detail of the implementation\".</p>",
        "id": 272038981,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644959615
    },
    {
        "content": "<p>In some ways, Rust is also its development process, not just the resulting language. So, for instance, the language team defines \"Rust\", and doesn't just define \"rustc\", even though we work on both.</p>",
        "id": 272038984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959617
    },
    {
        "content": "<p>re: extensions, it wouldn't even be terrible if the specification forbade implementations from offering any extensions at all that weren't specifically covered under implementation-defined behavior, with a specific exception carved-out for rustc. Unfair to some degree, certainly, but I don't think splitting up that sort of experimentation across multiple implementations actually buys you anything, rustc's process for adding things already has plenty of community buy-in and bureaucratic process (and would presumably have much <em>more</em> process if there were  actually a professional specification)</p>",
        "id": 272039076,
        "sender_full_name": "bstrie",
        "timestamp": 1644959649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> That's something I'd like to fix. FWIW, I personally share your distaste for \"lang items\".</p>",
        "id": 272039082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959652
    },
    {
        "content": "<p>And to the extent those are required, I <em>do</em> think we could make them stable. For instance, if the compiler <em>needs</em> to know how to desugar something that needs to reference a library thing, we should have a stable way of saying \"this is the library thing in question\".</p>",
        "id": 272039161,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959693
    },
    {
        "content": "<p>(e.g. <code>IntoIterator</code> or the internals of <code>try</code>.)</p>",
        "id": 272039214,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> While I wouldn't <em>object</em> to special-casing rustc, I also think that would not go over well as a standards process. ;)</p>",
        "id": 272039291,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959747
    },
    {
        "content": "<p>Eh... I can point to several occurances where I've both added or removed lang items in lccc's standard library,<br>\nMy philosphy is, \"If I can do it another way, it's not a lang item.\" UnsafeCell is a great example of where I've moved magic by 3 lines as it were (and <code>Box</code> is an even better example).</p>",
        "id": 272039486,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644959828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> That's going to ultimately be a hazard we have to deal with. \"Rust\" is tied to \"Rust development process\" which is tied to \"rustc development process\" which is tied to \"rustc\" (among many other things Rust and rustc share). We don't want to have a \"standard\" in name only, but we <em>also</em> don't want to break the important parts of that link (e.g. \"defining new features of Rust via the Rust process, not by random downstream extensions that get widely adopted and used to force us to not break them\").</p>",
        "id": 272039548,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644959867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272039291\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> While I wouldn't <em>object</em> to special-casing rustc, I also think that would not go over well as a standards process. ;)</p>\n</blockquote>\n<p>Yes, I would object with all of the weight my opinion carries against special-casing any particular implementation, but least of all rustc.</p>",
        "id": 272039616,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644959896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272039548\">said</a>:</p>\n<blockquote>\n<p>We don't want to have a \"standard\" in name only, but we <em>also</em> don't want to break the important parts of that link (e.g. \"defining new features of Rust via the Rust process, not by random downstream extensions that get widely adopted and used to force us to not break them\").</p>\n</blockquote>\n<p>In particular, I bring up the latter half of this fairly often because it's the portion that tends to come up often even <em>without</em> a standard, but I do care about the first half of this as well. If we're going to have a standard that says \"whatever rustc does\", that's not a standard, and we might as well not have one. Which is part of why sometimes I wonder if we <em>should</em> have one or not. :)</p>",
        "id": 272039763,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644960001
    },
    {
        "content": "<p>I'll argue that the value in a standard is that the text of a standard can be assumed to be deliberate, whereas the code in a reference implementation like rustc can easily be assumed to be incidental. In that sense, I'd much rather read a normative specification than read the source of rustc as a way of determining what the \"language\" \"should\" be doing, and users of the language can benefit from this even if there's only one implementation. I think there may be benefits to having more than one implementation (and perhaps detriments, to be sure), and a specification can facilitate that, but I ultimately disagree that \"having/facilitating multiple implementations\" is the only impetus for having a normative specification. Which is why, if we do have more than one, I don't mind rustc being privileged/\"first among equals\". Competition can be achieved via the standards process itself, not via competition between the implementations, and then the purpose of rustc's nightly channel/feature flags is just the prototyping phase of the standards track.</p>",
        "id": 272041177,
        "sender_full_name": "bstrie",
        "timestamp": 1644960677
    },
    {
        "content": "<p>Maybe we could say that alternative rust compilers can be compliant even if they have extensions for as long as they don't allow those extensions on the \"stable\"/\"preferred\"/\"suitable for production usage\" release channel just like rustc.</p>",
        "id": 272041239,
        "sender_full_name": "bjorn3",
        "timestamp": 1644960703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> That assumes other implementations <em>have</em> a \"stable\"/\"nightly\" distinction, and don't succumb to pressure to not have one. (Such pressure being <em>higher</em> for other implementations out of temptation to have it be a differentiating factor from rustc.)</p>",
        "id": 272041394,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644960765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041177\">said</a>:</p>\n<blockquote>\n<p>I'll argue that the value in a standard is that the text of a standard can be assumed to be deliberate, whereas the code in a reference implementation like rustc can easily be assumed to be incidental. In that sense, I'd much rather read a normative specification than read the source of rustc as a way of determining what the \"language\" \"should\" be doing, and users of the language can benefit from this even if there's only one implementation.</p>\n</blockquote>\n<p>I completely agree with this, but that's one major reason why I'm saying the standard shouldn't <em>defer</em> to rustc, rather than <em>deliberately documenting</em> rustc.</p>",
        "id": 272041455,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644960805
    },
    {
        "content": "<p>I would prefer to have one layer of indirection here. For instance, the standard could reference and require the use of certain Rust development processes, and those Rust development processes may include trying things out in rustc, but the Rust development processes aren't defined <em>in</em> the standard, and \"must do xyz in rustc\" isn't directly <em>in</em> the standard.</p>",
        "id": 272041590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644960883
    },
    {
        "content": "<p>For example gccrs could disable extensions when merging into upstream gcc, leaving it enabled on the gccrs fork. I presume distros ate unlikely to package the gccrs fork rather than upstream gcc.</p>",
        "id": 272041630,
        "sender_full_name": "bjorn3",
        "timestamp": 1644960909
    },
    {
        "content": "<p>(and to be clear, there are <em>some</em> things that can be improved via competition between implementations, like error messages, performance, etc. Just not anything semantically-visible/subject to backwards-compatibility)</p>",
        "id": 272041647,
        "sender_full_name": "bstrie",
        "timestamp": 1644960920
    },
    {
        "content": "<p>I've noted that none of the ones I'm aware of have that distinction. lccc really can't support stable/nightly distinction and I likewise can't see that gcc-rs is capable of the same, because the distribution method is source. I contemplate a \"Stable Release\" in lccc being <code>git tag release-1.x &amp;&amp; tar * | gzip &gt; lccc-1.x.tar.gz</code></p>",
        "id": 272041678,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644960943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041630\">said</a>:</p>\n<blockquote>\n<p>For example gccrs could disable extensions when merging into upstream gcc, leaving it enabled on the gccrs fork. I presume distros ate unlikely to package the gccrs fork rather than upstream gcc.</p>\n</blockquote>\n<p>How would you build the standard library using gccrs when merged, then?</p>",
        "id": 272041746,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644960964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041746\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041630\">said</a>:</p>\n<blockquote>\n<p>For example gccrs could disable extensions when merging into upstream gcc, leaving it enabled on the gccrs fork. I presume distros ate unlikely to package the gccrs fork rather than upstream gcc.</p>\n</blockquote>\n<p>How would you build the standard library using gccrs when merged, then?</p>\n</blockquote>\n<p>Don't use unstable features in it. :)</p>",
        "id": 272041784,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644960984
    },
    {
        "content": "<p>Yeah, that's happening.</p>",
        "id": 272041804,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041678\">said</a>:</p>\n<blockquote>\n<p>I've noted that none of the ones I'm aware of have that distinction. lccc really can't support stable/nightly distinction and I likewise can't see that gcc-rs is capable of the same, because the distribution method is source. I contemplate a \"Stable Release\" in lccc being <code>git tag release-1.x &amp;&amp; tar * | gzip &gt; lccc-1.x.tar.gz</code></p>\n</blockquote>\n<p>It's still possible to have such a distinction, if you make that change on a release branch before shipping a release.</p>",
        "id": 272041812,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041804\">said</a>:</p>\n<blockquote>\n<p>Yeah, that's happening.</p>\n</blockquote>\n<p>It actually is something that we're working to improve. <em>Currently</em>, not hypothetically.</p>",
        "id": 272041851,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961027
    },
    {
        "content": "<p>alternatively, split out all the lang-item-using parts of std into a new \"liblang\" that's below libcore :)</p>",
        "id": 272041865,
        "sender_full_name": "bstrie",
        "timestamp": 1644961042
    },
    {
        "content": "<p>RIght, but then you run into the same problem \"How to build the standard library\". At the very least, <code>libcore</code> necessarily has to interact with the compiler in compiler specific ways.</p>",
        "id": 272041894,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961064
    },
    {
        "content": "<blockquote>\n<p>How would you build the standard library using gccrs when merged, then?</p>\n</blockquote>\n<p>The same way rustc does it (env var override) or as part of the build system by building an additional binary for building the standard library which is discarded.</p>",
        "id": 272041911,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041865\">said</a>:</p>\n<blockquote>\n<p>alternatively, split out all the lang-item-using parts of std into a new \"liblang\" that's below libcore :)</p>\n</blockquote>\n<p>That just moves the goal</p>",
        "id": 272041921,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> I think the lang-item bits could potentially be stabilized. But also, we could potentially make alloc and std shareable and non-nightly more easily than core, and that's an <em>improvement</em>.</p>",
        "id": 272041925,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961080
    },
    {
        "content": "<p>just give me a future where core/alloc/std is one crate configured via cargo features and I'll be happy :P</p>",
        "id": 272042023,
        "sender_full_name": "bstrie",
        "timestamp": 1644961124
    },
    {
        "content": "<p>How about a future where it's one or more crates <em>on crates.io</em>? :)</p>",
        "id": 272042061,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272041925\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> I think the lang-item bits could potentially be stabilized. But also, we could potentially make alloc and std shareable and non-nightly more easily than core, and that's an <em>improvement</em>.</p>\n</blockquote>\n<p>I've noted above why I don't think so: at that level, you need to interface directly with the compiler, and compilers will have different ways of doing that, by way of being different internally.</p>",
        "id": 272042105,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272042061\">said</a>:</p>\n<blockquote>\n<p>How about a future where it's one or more crates <em>on crates.io</em>? :)</p>\n</blockquote>\n<p>(Not expecting that any time <em>soon</em>, but striving will get us some nice things.)</p>",
        "id": 272042108,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961176
    },
    {
        "content": "<p>but that implies that we'll stabilize scary things like auto traits...</p>",
        "id": 272042111,
        "sender_full_name": "bstrie",
        "timestamp": 1644961178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> We have a variety of uses of lang items, some of which make more sense than others.</p>",
        "id": 272042215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961214
    },
    {
        "content": "<p>Having a lang item so that the compiler can find a specific type definition, because it's needed for desugaring, seems easy to stabilize.</p>",
        "id": 272042248,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961241
    },
    {
        "content": "<p>I think libstd/liballoc could reasonably be made unstable. libcore, or some liblang that provides that primitive interface... not so much, imo.</p>",
        "id": 272042275,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961256
    },
    {
        "content": "<p>And we should ideally make it so that we don't <em>need</em> lang items for the <code>impl</code> blocks on built-in types, for instance.</p>",
        "id": 272042280,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961262
    },
    {
        "content": "<p>e.g. we really shouldn't need <code>slice_u8_alloc</code> as a lang item.</p>",
        "id": 272042346,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961315
    },
    {
        "content": "<p>Do you mean stable <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span>?</p>",
        "id": 272042424,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961352
    },
    {
        "content": "<p>we might be getting off-topic for #t-lang, but one reason why not to lean into the existing core/alloc/std split is that I can think of a dozen different configurable \"cargo features\" for std and having an individual crate for each one would be a nightmare for coherence</p>",
        "id": 272042526,
        "sender_full_name": "bstrie",
        "timestamp": 1644961432
    },
    {
        "content": "<p>Also, some standard libraries may have reciprocal requirements. For example, in lccc, I specify that the 3 base standard library crates are named <code>std</code> in mangling, and that's definately something that will be relied upon internally. Like <code>#[global_allocator]</code> that defines a symbol that matches the mangled name of a stdlib symbol that's imported.</p>",
        "id": 272042583,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961452
    },
    {
        "content": "<p>The lang items for builtin type impls are necessary not just for coherence, but also for finding the list of implementations on specific types. For the former I tried introducing a coherence loophole attribute once. For the latter I think any replacement will lead to a perf regression.</p>",
        "id": 272042588,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Can you clarify what you mean by \"for finding the list of implementations on specific types\"?</p>",
        "id": 272042628,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272042424\">said</a>:</p>\n<blockquote>\n<p>Do you mean stable <span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span>?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 272042641,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961499
    },
    {
        "content": "<p>If I do <code>a.foo()</code> it needs to find all impls on the type of <code>a</code> to find one which contains the method <code>foo</code>.</p>",
        "id": 272042677,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> In particular, is it necessary to have a <em>different</em> lang item for <em>each</em> impl block, or would it suffice to have one lang item that could be applied to multiple such blocks, and collect them when compiling?</p>",
        "id": 272042692,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961539
    },
    {
        "content": "<p>I think the keyword to search for is \"assemble\".</p>",
        "id": 272042696,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961543
    },
    {
        "content": "<p>Each lang item is tied to a single def id. The code to search for builtin type impls looks at the lang item specific to the type it needs to have impls for.</p>",
        "id": 272042830,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961608
    },
    {
        "content": "<p>Having a different mechanism for these impls would be possible, but it would likely require searching in every crate of the crate graph which would be a perf regression.</p>",
        "id": 272042930,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961676
    },
    {
        "content": "<p>What makes built-in types different than non-built-in types in that way?</p>",
        "id": 272043002,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961699
    },
    {
        "content": "<p>To what degree does the same logic apply to making, say, Vec faster?</p>",
        "id": 272043033,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961721
    },
    {
        "content": "<p>builtin types are defined by the compiler, and can't be traced to a particular crate that defines them.</p>",
        "id": 272043061,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961737
    },
    {
        "content": "<p>Exactly!</p>",
        "id": 272043076,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961747
    },
    {
        "content": "<p>But yes, I don't think that stabilizing the surface of the raw \"compiler-stdlib interface\" is a good idea, though reducing the scope of that surface is, and constraining it to <code>libcore</code>. But you'll always have different interfaces by way of having different compilers.<br>\nAlso, <code>libproc_macro</code> is a whole other story, and basically has to be compiler-specific.</p>",
        "id": 272043258,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961866
    },
    {
        "content": "<p>That explains why we need <em>a</em> lang item. But what would happen if we just treated <code>#[lang = \"u32\"] type u32;</code> as the definition of the type <code>u32</code>, in the crate it appears in, and then <code>impl u32 {}</code> blocks as not special and just associated with that type definition?</p>",
        "id": 272043266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961872
    },
    {
        "content": "<p>(I'm aware that we have some cases of coherence issues, where a type has impl blocks in both core and alloc. That aside, though?)</p>",
        "id": 272043310,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961900
    },
    {
        "content": "<p>I think that would be a valid and viable implementation.</p>",
        "id": 272043367,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961923
    },
    {
        "content": "<p>That could work I think.</p>",
        "id": 272043389,
        "sender_full_name": "bjorn3",
        "timestamp": 1644961927
    },
    {
        "content": "<p>Thanks, that's what I was trying to figure out.</p>",
        "id": 272043413,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961945
    },
    {
        "content": "<p>That's the <em>kind</em> of change that seems like it'd be an improvement to the lang-libs interface.</p>",
        "id": 272043434,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644961964
    },
    {
        "content": "<p>Although, the type still needs to be available unqualified in every namespace.</p>",
        "id": 272043435,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644961964
    },
    {
        "content": "<p>(Prelude doesn't do it, you can still use builtin types w/ <code>#![no_implicit_prelude]</code>)</p>",
        "id": 272043481,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644962001
    },
    {
        "content": "<p>In an ideal world, perhaps that could be just another kind of more primitive prelude, but I get why it likely needs a special case. That special case doesn't seem like an <em>issue</em> though, if we have the one lang item.</p>",
        "id": 272043527,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962024
    },
    {
        "content": "<p>This is the code I was refering to by the way: <a href=\"https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler/rustc_typeck/src/check/method/probe.rs#L653\">https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler/rustc_typeck/src/check/method/probe.rs#L653</a></p>",
        "id": 272043624,
        "sender_full_name": "bjorn3",
        "timestamp": 1644962059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Yeah, I just recently touched that code in a PR. Doesn't mean I understood <em>why</em> we needed that approach. :)</p>",
        "id": 272043692,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962101
    },
    {
        "content": "<p>In any case, I'd argue that this proves my point of different implementations having different raw interfaces: one implementation could choose what rustc currently does, and one implementation could choose the other approach, depending on which is more reasonable for it's structure.</p>",
        "id": 272043761,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644962141
    },
    {
        "content": "<p>I think what I'm getting at is that it might not be unreasonable to attempt to standardize parts of that interface. Doesn't mean we're prepared to commit to that <em>entire</em> interface being stable, but things like <code>#[lang = \"add\"]</code> and <code>#[lang = \"copy\"]</code> seem feasible to stabilize.</p>",
        "id": 272044099,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962297
    },
    {
        "content": "<p>Or <code>#[lang = \"bool\"]</code>.</p>",
        "id": 272044129,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962317
    },
    {
        "content": "<p>And for certain desugarings: What's do say that implementations will desugar the same constructs the same way. They only have to operate <em>as-if</em> they were.</p>",
        "id": 272044138,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644962326
    },
    {
        "content": "<p>If the types and traits in question are public, then that as-if is sufficiently constraining that the lang items are still necessary.</p>",
        "id": 272044391,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962440
    },
    {
        "content": "<p>(And if the types and traits <em>aren't</em> exposed then the lang items may not need to be stable.)</p>",
        "id": 272044427,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044099\">said</a>:</p>\n<blockquote>\n<p>I think what I'm getting at is that it might not be unreasonable to attempt to standardize parts of that interface. Doesn't mean we're prepared to commit to that <em>entire</em> interface being stable, but things like <code>#[lang = \"add\"]</code> and <code>#[lang = \"copy\"]</code> seem feasible to stabilize.</p>\n</blockquote>\n<p>I'd point to this: <a href=\"https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libcore/src/intrinsics.rs\">https://github.com/LightningCreations/lccc/blob/main/lcrust/libraries/libcore/src/intrinsics.rs</a>.<br>\nIn the case where I'm pulling in from the <code>__lccc::builtins::rust</code> namespace, I'm just desugaring <code>extern \"rust-intrinsic\"</code> manually. In other cases, I'm pulling in from the C builtin namespace which isn't normally available to rust code (but welcome to different implementations do different things, and lccc's fully-qualified intrinsic names).</p>",
        "id": 272044713,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644962602
    },
    {
        "content": "<p>Is there an implied expectation there that different implementations would share the same <code>core</code>, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>?  That doesn't seem obvious, to me.</p>",
        "id": 272044735,
        "sender_full_name": "scottmcm",
        "timestamp": 1644962613
    },
    {
        "content": "<p>I don't think stabilizing simple lang items makes sense. Any rust program needs to have the panic related lang items defined. The only stable provider of them is libcore which defines all simple lang items too. Stabilizing the panic related lang items is something I hope won't happen in the conceivable future as they are still rather in flux and have some less nice properties like depnding on <code>core::fmt</code> (which is unsuitable for microcontrollers and other constrained environments)</p>",
        "id": 272044856,
        "sender_full_name": "bjorn3",
        "timestamp": 1644962678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044735\">said</a>:</p>\n<blockquote>\n<p>Is there an implied expectation there that different implementations would share the same <code>core</code>, <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span>?  That doesn't seem obvious, to me.</p>\n</blockquote>\n<p>More an expectation that they <em>could</em> if they don't have a specific reason to reimplement it.</p>",
        "id": 272045119,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962844
    },
    {
        "content": "<p>(Which goes slightly along with an expectation that they <em>should</em> if they don't have a really <em>good</em> reason to reimplement it. ;) )</p>",
        "id": 272045281,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044391\">said</a>:</p>\n<blockquote>\n<p>If the types and traits in question are public, then that as-if is sufficiently constraining that the lang items are still necessary.</p>\n</blockquote>\n<p>Not necessarily. While experimenting on loop desugaring I also tried a few approaches that didn't use IntoIterator and replaced IntoIterator::into_iter in the desugaring with separate function which eventually called IntoIterator::into_iter. The lang item currently requires it to be a trait method without body. Had to change the compiler to change the desugaring.</p>",
        "id": 272045851,
        "sender_full_name": "The 8472",
        "timestamp": 1644963250
    },
    {
        "content": "<p>And if we ever want to opportunistically desugar into try_fold instead, well, new lang item.</p>",
        "id": 272045983,
        "sender_full_name": "The 8472",
        "timestamp": 1644963333
    },
    {
        "content": "<p>I guess a specification could leave some wiggle room by allowing indirection and non-default implementations. I.e. if Iterator::next is the lang item then it could allow calling an Iterator::foo instead as long as its default implementation results in next() being called. A non-default lang implementation would be observable in overridden code, so the as-if rule wouldn't be sufficient.</p>",
        "id": 272046476,
        "sender_full_name": "The 8472",
        "timestamp": 1644963576
    },
    {
        "content": "<p>FYI For compiler generated function bodies we generally write the function as a function calling itself.</p>",
        "id": 272046506,
        "sender_full_name": "bjorn3",
        "timestamp": 1644963593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272045119\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272044735\">said</a>:</p>\n<blockquote>\n<p>Is there an implied expectation there that different implementations would share the same <code>core</code>, <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span>?  That doesn't seem obvious, to me.</p>\n</blockquote>\n<p>More an expectation that they <em>could</em> if they don't have a specific reason to reimplement it.</p>\n</blockquote>\n<p>FTR, most currently do. Both mrustc and gcc-rs reuse rustc's stdlib. lccc is the odd one out here, because I decided I definately was not going to track nightly rustc.</p>",
        "id": 272046557,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644963603
    },
    {
        "content": "<p>Also gave me opportunity to explore certain changes that aren't publicly observable, for example, fixing TypeId.</p>",
        "id": 272046645,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644963636
    },
    {
        "content": "<p>gcc-rs is not yet at the point where reusing rustc's libcore would be possible at all. Currently it is limited to single crate usage as no crate metadata serialization has been implemented. It does use the same lang items for operator traits though.</p>",
        "id": 272046764,
        "sender_full_name": "bjorn3",
        "timestamp": 1644963709
    },
    {
        "content": "<p>Fair, in the latter two cases, it's more accurate to say, that's the intention (in the case of gcc-rs, at least as of the last time I read the website)</p>",
        "id": 272046970,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644963821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272046476\">said</a>:</p>\n<blockquote>\n<p>I guess a specification could leave some wiggle room by allowing indirection and non-default implementations. I.e. if Iterator::next is the lang item then it could allow calling an Iterator::foo instead as long as its default implementation results in next() being called. A non-default lang implementation would be observable in overridden code, so the as-if rule wouldn't be sufficient.</p>\n</blockquote>\n<p>Well, if <code>Iterator::foo</code> is unstable, then it wouldn't be observable in terms of the rust spec.</p>",
        "id": 272047146,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644963902
    },
    {
        "content": "<p>Doesn't help if we want it to be stable so that user code can implement a better alternative to repeatedly calling <code>next</code>. <code>foo</code> would likely be <code>try_fold</code> or something similar.</p>",
        "id": 272047396,
        "sender_full_name": "The 8472",
        "timestamp": 1644964060
    },
    {
        "content": "<p>I mean right now I'm going for unstable methods (get_unchecked) but switching between next() and try_fold() depending on whether the body contains control flow is another approach that has been discussed multiple times.</p>",
        "id": 272047527,
        "sender_full_name": "The 8472",
        "timestamp": 1644964135
    },
    {
        "content": "<p>Well, I guess if it's standardized then an extension would just have go through the standards process?</p>",
        "id": 272047580,
        "sender_full_name": "The 8472",
        "timestamp": 1644964177
    },
    {
        "content": "<p>One thing I think we should capture: \"standards process\" does not need to mean \"thing that takes time measured in years\".</p>",
        "id": 272047677,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964222
    },
    {
        "content": "<p>Just because some languages work that way does not mean we have to.</p>",
        "id": 272047690,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964231
    },
    {
        "content": "<p>Yeah. One thing I do like about rust is that features can be added quickly. Although, in some cases, far <em>too</em> quickly. And also, far <em>too</em> slowly.</p>",
        "id": 272047751,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964272
    },
    {
        "content": "<p>I think our response to people concerned that having something in the standard would slow down iteration should be for us to speed up the iteration time of the standard. :)</p>",
        "id": 272047753,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964273
    },
    {
        "content": "<p><em>cough</em> Never <em>cough</em></p>",
        "id": 272047784,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964299
    },
    {
        "content": "<p>I like the idea of having the rust specification just be an ever-evolving document, that is changed as features are stabilized, and then released on the same schedule that is already used.</p>",
        "id": 272047868,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964341
    },
    {
        "content": "<p><em>nod</em></p>",
        "id": 272047976,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964424
    },
    {
        "content": "<p>Yes please.</p>",
        "id": 272047979,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964426
    },
    {
        "content": "<p>I like the approach used by the HTML5 \"living standard\".</p>",
        "id": 272048049,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964448
    },
    {
        "content": "<p>I think one of the main things of targets is that it should be possible to say, add support for a target which requires propietary code to be linked, or other such things, and have that still Rust.</p>",
        "id": 272048056,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1644964453
    },
    {
        "content": "<p>Yeah... who wants to be the safari?</p>",
        "id": 272048066,
        "sender_full_name": "The 8472",
        "timestamp": 1644964461
    },
    {
        "content": "<p>&lt;opinionated&gt;(The real HTML5 standard by WHATWG, not the snapshot-of-other-people's-work by W3C.)&lt;/opinionated&gt;</p>",
        "id": 272048091,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644964482
    },
    {
        "content": "<p>Oh, we already have <a href=\"http://caniuse.rs\">caniuse.rs</a></p>",
        "id": 272048157,
        "sender_full_name": "The 8472",
        "timestamp": 1644964523
    },
    {
        "content": "<p>In fact, the way I'd personally implement having a rust specification, after completing the work of specifying rust as-is, would be to stabilize a feature, normative documentation needs to be added to the specification. That would be a prerequisite (or part of) the stabilization report.</p>",
        "id": 272048168,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964527
    },
    {
        "content": "<p>(I say part of because it seems like functionally, stabilizing a feature from a T-lang or T-libs-api perspective is adding it to the formal language/standard library (resp.), so it could be argued that what <em>should</em> be FCP'd is the actual specification of the feature, rather than the stabilization of a particular implementation)</p>",
        "id": 272048366,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964652
    },
    {
        "content": "<p>Yeah, I was thinking about how C# does their standardization process, and I think my ideal process would be a living standard owned by the Rust foundation, and then every x years we submit it to ISO/whatever as a kind of LTS Rust/edition/whatever.</p>",
        "id": 272048492,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1644964737
    },
    {
        "content": "<p>Nope to ISO. Ton of nopes to ISO. I don't need another ISO standard to implement, I already have upwards of $700 worth (and I'm avoiding buying those as well).</p>",
        "id": 272048573,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964802
    },
    {
        "content": "<p>TBH, I don't see a need for the spec to be anything other than the documentation provided by T-lang and T-libs-api jointly that says \"This is what Rust is\". I don't see a need for there to be a formal body backing that document other than Rust itself (and the Rust Foundation).</p>",
        "id": 272048676,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644964868
    },
    {
        "content": "<p><a href=\"https://youtu.be/YZomx3Jt4Xs?t=1541\">https://youtu.be/YZomx3Jt4Xs?t=1541</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"YZomx3Jt4Xs\" href=\"https://youtu.be/YZomx3Jt4Xs?t=1541\"><img src=\"https://uploads.zulipusercontent.net/546c04ca1b755dc02a5d54374262e87ea59b65a4/68747470733a2f2f692e7974696d672e636f6d2f76692f595a6f6d78334a743458732f64656661756c742e6a7067\"></a></div>",
        "id": 272048698,
        "sender_full_name": "Urgau",
        "timestamp": 1644964887
    },
    {
        "content": "<p>Yeah ISO was just an example, alongside ECMA as with what Dart is doing or w/e. I do think it's a fundamental debate with the Rust standard that of whether we want it more like C++ or Java. I'm still partial to the C++ way of doing things, but there are definitely people who think that the main production compilers will be forks/distributions of rustc (ala openjdk), or niche/research compilers.</p>",
        "id": 272049404,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1644965330
    },
    {
        "content": "<blockquote>\n<p>there are definitely people who think that the main production compilers will be forks/distributions of rust</p>\n</blockquote>\n<p>I hope not <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 272049510,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644965402
    },
    {
        "content": "<p>But as I say, I don't think there really needs to be any sort of entity or organization, other than Rust itself, backing the Rust specification.</p>",
        "id": 272049663,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644965488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272049404\">said</a>:</p>\n<blockquote>\n<p>I do think it's a fundamental debate with the Rust standard that of whether we want it more like C++ or Java.</p>\n</blockquote>\n<p>Is \"no\" an option? ;)</p>",
        "id": 272049956,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644965655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272049663\">said</a>:</p>\n<blockquote>\n<p>But as I say, I don't think there really needs to be any sort of entity or organization, other than Rust itself, backing the Rust specification.</p>\n</blockquote>\n<p>I can imagine scenarios in which it makes sense to have an organization stamp the Rust specification, but not take over the Rust specification.</p>",
        "id": 272050013,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644965700
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 272050037,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644965716
    },
    {
        "content": "<p>Something like ISO is <em>fun</em> though, because they like having exclusive publication rights to <em>the</em> standard.</p>",
        "id": 272050146,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644965774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272048492\">said</a>:</p>\n<blockquote>\n<p>Yeah, I was thinking about how C# does their standardization process, and I think my ideal process would be a living standard owned by the Rust foundation, and then every x years we submit it to ISO/whatever as a kind of LTS Rust/edition/whatever.</p>\n</blockquote>\n<p>I don't think we want an \"LTS Rust\" in that sense. If there's an org that will take and stamp a version every x <em>weeks</em> or at most <em>months</em>, that might work.</p>",
        "id": 272050194,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644965810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272050146\">said</a>:</p>\n<blockquote>\n<p>Something like ISO is <em>fun</em> though, because they like having exclusive publication rights to <em>the</em> standard.</p>\n</blockquote>\n<p>Which makes them pretty much automatically a no-go. That's not adding value, that's taking away value.</p>",
        "id": 272050213,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644965831
    },
    {
        "content": "<p>Yeah. C++ and C actually go arround this by publishing drafts on open-std.</p>",
        "id": 272050251,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644965863
    },
    {
        "content": "<p>But if you want <em>the</em> standard? That's 250 CHF for C, and 200 for C++.</p>",
        "id": 272050319,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644965887
    },
    {
        "content": "<p>I'm not aware of any downsides of standardizing through ECMA rather than ISO, it seems to work well for javascript and be strictly better</p>",
        "id": 272130504,
        "sender_full_name": "bstrie",
        "timestamp": 1645025293
    },
    {
        "content": "<p>it even seems appropriate since, as far as <em>organizational</em> genealogy is concerned, Rust is Javascript's nearest sibling :P</p>",
        "id": 272130676,
        "sender_full_name": "bstrie",
        "timestamp": 1645025377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272034322\">said</a>:</p>\n<blockquote>\n<p>C and C++ both explicitly note that an implementation can translate an ill-formed program, and, while I'd expect rust to recommend implementations not translate additionall ill-formed programs, I wouldn't expect it to forbid it.<br>\nsubset-of-Rust isn't a valid implementation (notwithstanding lints that can be controlled), but I'd expected superset-of-Rust to be valid, though discouraged.</p>\n</blockquote>\n<p>I actually do expect Rust to say ill-formed programs should not be translated to machine code.</p>",
        "id": 272769812,
        "sender_full_name": "Jubilee",
        "timestamp": 1645516623
    },
    {
        "content": "<p>The purpose of a type system is to reject ill-formed programs.<br>\nRust is functionally defined by its ownership type system.<br>\nThus, a compiler that does not reject ill-formed programs is not implementing Rust's type system.<br>\nThus, a compiler that does not reject ill-formed programs is not implementing Rust.</p>",
        "id": 272769977,
        "sender_full_name": "Jubilee",
        "timestamp": 1645516786
    },
    {
        "content": "<p>I would also expect the complete definition of that mandate to have a loophole you could drive a truck through because it might still e.g. allow dynamic interpretation for debugging purposes or partially lowering parts of the program to object fragments but refusing to actually fully emit and link the result.</p>",
        "id": 272770380,
        "sender_full_name": "Jubilee",
        "timestamp": 1645517113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/213817-t-lang/topic/Implementation.20Specific.20Behaviour/near/272769977\">said</a>:</p>\n<blockquote>\n<p>The purpose of a type system is to reject ill-formed programs.<br>\nRust is functionally defined by its ownership type system.<br>\nThus, a compiler that does not reject ill-formed programs is not implementing Rust's type system.<br>\nThus, a compiler that does not reject ill-formed programs is not implementing Rust.</p>\n</blockquote>\n<p>I understand that it's less useful, but I noted a few reasons that having it open is useful (namely pieces of extensions that cannot be detected after features are checked, and implementations like mrustc that are used for bootstrapping).</p>",
        "id": 272791559,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645530361
    },
    {
        "content": "<p>It would also open the option of making fcw's treated as \"Ill-formed\" immediately, while still allowing them to just be warnings for backcompat.</p>",
        "id": 272792027,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645530655
    },
    {
        "content": "<p>I do not believe Mutabah has a finished implementation of rustc, either.</p>",
        "id": 274016290,
        "sender_full_name": "Jubilee",
        "timestamp": 1646331876
    }
]