[
    {
        "content": "<p>Started putting together an initial set of notes for the design meeting later this week -- will likely iterate some more, but if folks have time initial questions or comments would likely help to polish the doc up a little, since there's quite a bit of context to try and embed in a short amount of space.</p>",
        "id": 272726173,
        "sender_full_name": "simulacrum",
        "timestamp": 1645470991
    },
    {
        "content": "<p>Are these notes available for pre-read? I'm very interested in the never type implementation changes needed to get it stabilized, and I'd love to give it a read/comments.</p>",
        "id": 272728216,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645472440
    },
    {
        "content": "<p>heh</p>",
        "id": 272728299,
        "sender_full_name": "simulacrum",
        "timestamp": 1645472512
    },
    {
        "content": "<p>I meant to link them  <a href=\"https://hackmd.io/9sTGmQ_VQ_mX_bdQhuqVRA\">https://hackmd.io/9sTGmQ_VQ_mX_bdQhuqVRA</a></p>",
        "id": 272728309,
        "sender_full_name": "simulacrum",
        "timestamp": 1645472516
    },
    {
        "content": "<p>the short summary is that current trajectory is towards not stabilizing, but there's some options potentially and maybe other design points I/Niko haven't thought of yet</p>",
        "id": 272728383,
        "sender_full_name": "simulacrum",
        "timestamp": 1645472556
    },
    {
        "content": "<blockquote>\n<p>Motivation for ! having special coercion behavior seems weak</p>\n</blockquote>\n<p>The biggest one I know is that people like writing things like <code>fn from(x: !) -&gt; Foo { x }</code>.  If it's a normal enum, then one has to write <code>{ match x {} }</code> instead.  But that's not <em>that</em> bad, and it's certainly clearer, so it may well be fine.</p>\n<p>It's more annoying in things like <a href=\"https://github.com/SergioBenitez/Rocket/pull/1645/files?diff=unified&amp;w=0#diff-f67fece1f153ba05053cb505d78f11abfb3fc7866f7f1d9b83adc5699fd56c5aR618\">https://github.com/SergioBenitez/Rocket/pull/1645/files?diff=unified&amp;w=0#diff-f67fece1f153ba05053cb505d78f11abfb3fc7866f7f1d9b83adc5699fd56c5aR618</a>, but something like \"<code>!</code> patterns\" could solve that instead of a coercion, so since coercions are generally evil, that's probably further evidence to not have the coercion for <code>!</code>.</p>",
        "id": 272729568,
        "sender_full_name": "scottmcm",
        "timestamp": 1645473418
    },
    {
        "content": "<p>Pondering a whole different direction: if people replace <code>-&gt; !</code> functions with <code>-&gt; Never</code> (for an <code>enum Never {}</code> in the prelude or something), what breaks?</p>",
        "id": 272729665,
        "sender_full_name": "scottmcm",
        "timestamp": 1645473483
    },
    {
        "content": "<p>Coercion behavior -- it's necessary for things like unreachable!() or panic!() (which are just -&gt; ! functions under the hood) to work in functions with e.g. u32 return type</p>",
        "id": 272729736,
        "sender_full_name": "simulacrum",
        "timestamp": 1645473532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272729736\">said</a>:</p>\n<blockquote>\n<p>Coercion behavior -- it's necessary for things like unreachable!() or panic!() (which are just -&gt; ! functions under the hood) to work in functions with e.g. u32 return type</p>\n</blockquote>\n<p>at least for backwards compat with common macros that diverge, could we desugar <code>unreachable!()</code>, etc., into <code>match something_returning_Never_enum() {}</code> instead?</p>",
        "id": 272729932,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645473636
    },
    {
        "content": "<p>(<code>something_returning_Never_enum()</code> doesn't necessarily have to be a fn call, just an expression evaluating to that type)</p>",
        "id": 272729990,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645473669
    },
    {
        "content": "<p>also don't want to get into the weeds of discussion here I guess, perhaps I should hold off on suggesting things</p>",
        "id": 272730055,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645473709
    },
    {
        "content": "<p>No, I think discussion here is fine -- in general, that's possible, but obviously anyone can today define -&gt; ! functions (that's not feature gated)</p>",
        "id": 272730130,
        "sender_full_name": "simulacrum",
        "timestamp": 1645473757
    },
    {
        "content": "<p>More random thoughts: while I certainly like the terseness of <code>Option&lt;!&gt;</code> when I write things like <code>Try</code>, it does seem kinda weird to me that a relatively-niche feature has such a short name.</p>\n<p>Having people use a canonical library type for it instead of a symbol seems perfectly reasonable.</p>\n<p>(And edition-gating the <code>-&gt; !</code> syntax would be pretty simple.)</p>",
        "id": 272730134,
        "sender_full_name": "scottmcm",
        "timestamp": 1645473761
    },
    {
        "content": "<p>yeah, across an edition we could go for</p>\n<blockquote>\n<p>! is syntax sugar for Infallible inside types (e.g., Result&lt;!, T&gt; == Result&lt;Infallible, T&gt;) but behaves as current stable ! at the top level</p>\n</blockquote>",
        "id": 272730214,
        "sender_full_name": "simulacrum",
        "timestamp": 1645473839
    },
    {
        "content": "<p>(well, make regular ! always go for Infallible, and insert match x {} automatically where necessary, with panic etc desugaring to that directly)</p>",
        "id": 272730286,
        "sender_full_name": "simulacrum",
        "timestamp": 1645473870
    },
    {
        "content": "<p>I kinda like the \"<code>-&gt; whatever::we::make::the::canonical::Never</code> gets the magic behaviour and we cargo fix <code>-&gt; !</code> to that\".  Now to see if I can figure out <em>why</em> I like it...</p>",
        "id": 272730456,
        "sender_full_name": "scottmcm",
        "timestamp": 1645473991
    },
    {
        "content": "<p>Sorry if I missed this earlier in the conversation, but I'm curious what we gain by not using the name <code>!</code>?</p>",
        "id": 272730496,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645474034
    },
    {
        "content": "<p>well, I think my proposal is rather the opposite: <em>not</em> have magic behavior for any !-like type</p>",
        "id": 272730497,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272730496\">said</a>:</p>\n<blockquote>\n<p>Sorry if I missed this earlier in the conversation, but I'm curious what we gain by not using the name <code>!</code>?</p>\n</blockquote>\n<p>The main advantage to immediate-term proposals that don't use <code>!</code> directly is that there is existing stable behavior attached to <code>!</code>; across an edition that behavior is maybe changeable.</p>",
        "id": 272730594,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474092
    },
    {
        "content": "<p>the type of <code>match x {}</code> still needs to be a magic metavariable though</p>",
        "id": 272730606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645474102
    },
    {
        "content": "<p>\"diverging type variable\" I think it's called</p>",
        "id": 272730625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645474121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272730606\">said</a>:</p>\n<blockquote>\n<p>the type of <code>match x {}</code> still needs to be a magic metavariable though</p>\n</blockquote>\n<p>I think it already is on stable, though?</p>",
        "id": 272730637,
        "sender_full_name": "scottmcm",
        "timestamp": 1645474132
    },
    {
        "content": "<p>Well, if you constrain to just <code>match x {}</code> rather than any coercion site, a bunch of things become much simpler, so I think it could still be worthwhile</p>",
        "id": 272730682,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272730497\">said</a>:</p>\n<blockquote>\n<p>well, I think my proposal is rather the opposite: <em>not</em> have magic behavior for any !-like type</p>\n</blockquote>\n<p>I feel like this runs into the risk of not having any canonical <code>!</code>-like type, especially given that the name for the best candidate we currently have (<code>std::convert::Infallible</code>) is really poorly suited for that</p>",
        "id": 272730800,
        "sender_full_name": "Jake",
        "timestamp": 1645474233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272730496\">said</a>:</p>\n<blockquote>\n<p>Sorry if I missed this earlier in the conversation, but I'm curious what we gain by not using the name <code>!</code>?</p>\n</blockquote>\n<p>No, you didn't miss anything.  Maybe we don't gain anything, though I think that people might expect more smarts from something with a special name than they do something that looks like a normal type.</p>",
        "id": 272730854,
        "sender_full_name": "scottmcm",
        "timestamp": 1645474268
    },
    {
        "content": "<p><code>()</code> has a special name but not much smarts AFAIK</p>",
        "id": 272730895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645474300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272730895\">said</a>:</p>\n<blockquote>\n<p><code>()</code> has a special name but not much smarts AFAIK</p>\n</blockquote>\n<p>The automatic <code>else { () }</code> is pretty special, though I agree that's not exactly \"smarts\".</p>",
        "id": 272730988,
        "sender_full_name": "scottmcm",
        "timestamp": 1645474333
    },
    {
        "content": "<p>I think of <code>!</code> as the co-<code>()</code>, the 0-ary anonymous enum</p>",
        "id": 272731044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645474388
    },
    {
        "content": "<p>so a snappy symbol name seems fine</p>",
        "id": 272731089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645474425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272731044\">said</a>:</p>\n<blockquote>\n<p>I think of <code>!</code> as the co-<code>()</code>, the 0-ary anonymous enum</p>\n</blockquote>\n<p>It's just the <code>NonZeroU0</code> to <code>()</code>s <code>u0</code>.</p>",
        "id": 272731162,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645474465
    },
    {
        "content": "<p>Actually, <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>, I don't see anything about <code>match</code> being smart about uninhabited variants in the doc.</p>\n<p>I remember that being the same feature gate as <code>!</code>.  Is it no longer, and thus out of scope for this conversation?</p>\n<p>Because we might say that  the special behaviour it does have would be that <code>let None: Option&lt;!&gt; = None;</code> is infallible, even if perhaps it wouldn't be for any other uninhabited type.</p>",
        "id": 272731216,
        "sender_full_name": "scottmcm",
        "timestamp": 1645474521
    },
    {
        "content": "<p>It's not related to ! -- IIRC, it's either stabilized already or a separate feature gate, I can look</p>",
        "id": 272731237,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474546
    },
    {
        "content": "<p>(Or, perhaps more realistically, <code>let Ok(x) = u32::try_from(0_u8);</code> being allowed once that impl uses magic-Never.)</p>",
        "id": 272731303,
        "sender_full_name": "scottmcm",
        "timestamp": 1645474568
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/51085\">https://github.com/rust-lang/rust/issues/51085</a></p>",
        "id": 272731327,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474584
    },
    {
        "content": "<p>I would not intuitively expect that ! should be different from 'any other uninhabited type', personally, but I think in either case it's sort of a separate discussion -- I think worthwhile to add a short section on though</p>",
        "id": 272731374,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272731374\">said</a>:</p>\n<blockquote>\n<p>I would not intuitively expect that ! should be different from 'any other uninhabited type', personally</p>\n</blockquote>\n<p>That's not completely obvious to me, because <code>()</code> is more special than any other ZST, for example.</p>\n<p>Maybe not <em>substantially</em> more special, especially in behaviour of instances, but it definitely has a privileged position.</p>\n<p>(<code>-&gt; !</code> being special being kinda like how <code>-&gt; ()</code> is special comes to mind.)</p>",
        "id": 272731547,
        "sender_full_name": "scottmcm",
        "timestamp": 1645474776
    },
    {
        "content": "<p>Added a short section</p>",
        "id": 272731573,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474798
    },
    {
        "content": "<p>Yeah, in general, I agree with <code>!</code> being special -- but not in patterns, I think. Not sure there.</p>",
        "id": 272731649,
        "sender_full_name": "simulacrum",
        "timestamp": 1645474832
    },
    {
        "content": "<p>One of my <code>?</code> PRs implied to me that <code>exhaustive_patterns</code> is surprisingly expensive, perhaps because it needs to handle things like <code>Result&lt;!, !&gt;</code> and not just <code>!</code> -- though maybe that's not an \"only <code>!</code> should be special\" but an \"only zero-variant enums should be special\".</p>\n<p>(Thought after some of the recent things we've hit, my brain immediately pipes up with \"zero-variant enums that aren't <code>#[non_exhaustive]</code>!\"...)</p>",
        "id": 272731864,
        "sender_full_name": "scottmcm",
        "timestamp": 1645475022
    },
    {
        "content": "<p>But back to the actual topic, I'm sad that the fallback change looks like it's impractical, since <code>Err(x)</code> being <code>Result&lt;!, _&gt;</code> would really have been pretty nice, but the doc says to me that we just shouldn't change it.</p>",
        "id": 272732068,
        "sender_full_name": "scottmcm",
        "timestamp": 1645475203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272730800\">said</a>:</p>\n<blockquote>\n<p>I feel like this runs into the risk of not having any canonical <code>!</code>-like type, especially given that the name for the best candidate we currently have (<code>std::convert::Infallible</code>) is really poorly suited for that</p>\n</blockquote>\n<p>I think it's very important that we have <em>a</em> canonical never type, since libraries all through the ecosystem will want to implement their traits for it.</p>\n<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> The biggest reason I think it's important that <code>Infallible</code> becomes a type alias for whatever-it-is that we make the canonical type -- be that <code>!</code> or <code>core::something::Never</code> or ... -- is that people are today implementing traits for <code>Infallible</code>, so having it become a type alias for <em>the</em> canonical thing means that they immediately support that type.  If it's not an alias, then there will be an MSRV-annoying rust to impl traits for whatever the new thing is.</p>\n<p>(And I agree that it would be a shame if it that canonical type was named <code>Infallible</code> forever, as that's an ok name in <code>convert</code> but globally is pretty bad -- especially since <code>-&gt; Infallible</code> basically does the opposite of what it appears to say.)</p>",
        "id": 272732884,
        "sender_full_name": "scottmcm",
        "timestamp": 1645475844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272731864\">said</a>:</p>\n<blockquote>\n<p>One of my <code>?</code> PRs implied to me that <code>exhaustive_patterns</code> is surprisingly expensive, perhaps because it needs to handle things like <code>Result&lt;!, !&gt;</code> and not just <code>!</code> -- though maybe that's not an \"only <code>!</code> should be special\" but an \"only zero-variant enums should be special\".</p>\n<p>(Thought after some of the recent things we've hit, my brain immediately pipes up with \"zero-variant enums that aren't <code>#[non_exhaustive]</code>!\"...)</p>\n</blockquote>\n<p>patterns are surprisingly expensive and underdeveloped in general IMO. There's a lot of missed optimizations concerning them. I mean perhaps you mean something more uniquely particular, but</p>",
        "id": 272734806,
        "sender_full_name": "Jubilee",
        "timestamp": 1645477353
    },
    {
        "content": "<p>exhaustive_patterns + never_type is extremely nice and I'd be very sad if it was ruled out forever</p>",
        "id": 272796242,
        "sender_full_name": "bstrie",
        "timestamp": 1645533352
    },
    {
        "content": "<p>I'd support changing the name, <code>!</code> is cryptic and heard to search for</p>",
        "id": 272796291,
        "sender_full_name": "bstrie",
        "timestamp": 1645533370
    },
    {
        "content": "<p><code>!</code> is a meme source, though. </p>\n<blockquote>\n<p>When will that divergent type be stabilized?<br>\n<code>!</code></p>\n</blockquote>",
        "id": 272796352,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645533422
    },
    {
        "content": "<p>I would also like to see exhaustive_patterns performance bugfixed if that's the issue. It doesn't seem like it should be a huge expense, any more than regular pattern matching, even accounting for stuff like <code>Result&lt;!, !&gt;</code> being uninhabited</p>",
        "id": 272796603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645533554
    },
    {
        "content": "<p>And also I've used Lean for years which has exhaustive_patterns from the start and it's never been a problem. (It's extra cool when you add dependent types, since then you can pattern match on <code>{v: Vec&lt;A&gt; | v.len() == 3}</code> and only have one case <code>([a, b, c], _) =&gt; ...</code>)</p>",
        "id": 272796830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645533664
    },
    {
        "content": "<p>if you're looking for an intuitive name for <code>!</code> then we can reuse existing terminology and  call it <code>Unreachable</code></p>",
        "id": 272798336,
        "sender_full_name": "bstrie",
        "timestamp": 1645534583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272796242\">said</a>:</p>\n<blockquote>\n<p>exhaustive_patterns + never_type is extremely nice and I'd be very sad if it was ruled out forever</p>\n</blockquote>\n<p>FWIW, it does seem like <code>exhaustive_patterns</code> does not necessarily require <code>never_type</code> to shine, any uninhabited type will do (<em>e.g.</em>, <code>enum Never {} let None::&lt;Never&gt;;</code>).</p>",
        "id": 272799086,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645535006
    },
    {
        "content": "<p>That being said, I personally agree that in the same fashion that we use <code>()</code> over <code>Unit</code>, \"divergence\" seems special enough for some canonical form of it being being sigil-based (I wouldn't be fond of seeing <code>fn handle_alloc_error(â€¦) -&gt; Never</code> kind of signatures).</p>",
        "id": 272799089,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645535007
    },
    {
        "content": "<p>Given that we already support <code>!</code> as function return type for ages I don't think we should change it.</p>",
        "id": 272817819,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645543477
    },
    {
        "content": "<p>See, that was rust's first mistake wrt. <code>!</code>.</p>",
        "id": 272818002,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645543545
    },
    {
        "content": "<p>I wouldn't call it a mistake, having some kind of access to the bottom type was pretty much non-negotiable for 1.0. the problem was that the syntax dates back to before even 0.1, so it never really got any rigorous consideration :P</p>",
        "id": 272819301,
        "sender_full_name": "bstrie",
        "timestamp": 1645544026
    },
    {
        "content": "<p>I mean, it was arguably a mistake to let people name the type at all, if you can't name the type normally.</p>",
        "id": 272819530,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645544109
    },
    {
        "content": "<p>Because people will just name it anyways anywhere they want.</p>",
        "id": 272819557,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645544120
    },
    {
        "content": "<p>well, it's deliberately <em>not</em> naming the type. from the 0.1 manual: 'The ! annotation does not denote a type. Rather, the result type of a diverging function is a special type called $\\bot$ (\"bottom\") that unifies with any type. Rust has no syntax for $\\bot$.' So it was never intended to be the type itself, it's just that people thought it would be consistent to reuse the same syntax.</p>",
        "id": 272820087,
        "sender_full_name": "bstrie",
        "timestamp": 1645544317
    },
    {
        "content": "<p>But you can write <code>impl&lt;R&gt; fn()-&gt;R</code>, to name <code>R</code>.</p>",
        "id": 272820216,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645544371
    },
    {
        "content": "<p>Can someone explain why changing inference from <code>()</code> to <code>!</code> can lead to UB? The whole discussion about the need of a complex inference algorithm seems to be all based on this, but I never understand the original issue in the first place.</p>",
        "id": 272820748,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645544566
    },
    {
        "content": "<p>I know there can be breakages due to this change, but that's something that could be done via the next edition.</p>",
        "id": 272820883,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645544636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> did you read <a href=\"https://rust-lang.github.io/never-type-initiative/explainer/conditional-fallback-v1.html#bug-66173-unsoundness-introduced-by-changing-fallback-from--to-\">https://rust-lang.github.io/never-type-initiative/explainer/conditional-fallback-v1.html#bug-66173-unsoundness-introduced-by-changing-fallback-from--to-</a>?</p>",
        "id": 272821014,
        "sender_full_name": "simulacrum",
        "timestamp": 1645544679
    },
    {
        "content": "<p>today that code is weird &amp; probably not what's intended, but safe code and produces <code>()</code></p>",
        "id": 272821096,
        "sender_full_name": "simulacrum",
        "timestamp": 1645544718
    },
    {
        "content": "<p>but if we just change inference to <code>!</code> you get unsoundness, because you've produced a type indicating divergence in live code.</p>",
        "id": 272821140,
        "sender_full_name": "simulacrum",
        "timestamp": 1645544741
    },
    {
        "content": "<p>I've read that. But that wouldn't compile if <code>()</code> is changed to <code>!</code>. The linked issue gives a <code>unconstrained_return</code> which I think is unsound in the first place.</p>",
        "id": 272821217,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645544765
    },
    {
        "content": "<p>So from my understanding the inference can cause breakage in poorly written safe code, and can cause previously-not-exhibited UB in poorly written (and unsound) unsafe code.</p>",
        "id": 272821613,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645544925
    },
    {
        "content": "<p>So a new edition should suffice?</p>",
        "id": 272821646,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645544935
    },
    {
        "content": "<p>yeah, I'm not sure if there's purely safe code that can change behavior -- it seems not impossible. In particular, you could impl for () and Infallible and if we change Infallible to alias !, things change. An edition doesn't really work here because the Infallible = ! change basically has to be global I think</p>",
        "id": 272822368,
        "sender_full_name": "simulacrum",
        "timestamp": 1645545181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272821217\">said</a>:</p>\n<blockquote>\n<p>I've read that. But that wouldn't compile if <code>()</code> is changed to <code>!</code>. The linked issue gives a <code>unconstrained_return</code> which I think is unsound in the first place.</p>\n</blockquote>\n<p>I mean, the only thing you need to do is mark <code>unconstrained_return</code> as <code>unsafe</code>, and then its no longer unsound (under some safety contract) and you get the UB with the fallback change</p>",
        "id": 272822407,
        "sender_full_name": "Jake",
        "timestamp": 1645545194
    },
    {
        "content": "<p>Can we use the v2 inference algorithm just for lint production? I.e. change inference fallback to <code>!</code> in the next edition and have the current v2 inference algorithm produces a lint whenever <code>()</code> needs to be inferred?</p>",
        "id": 272823793,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645545682
    },
    {
        "content": "<p>edition-dependent inference doesn't really work: you can't change Infallible to be ! if you don't have inference changes too, and you need the first of those to be on all editions -- this is something I tried to express in the doc, but maybe not very well? Suggestions on how to make that clearer definitely appreciated.</p>",
        "id": 272824128,
        "sender_full_name": "simulacrum",
        "timestamp": 1645545805
    },
    {
        "content": "<p>I think I need to ingest more code example <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 272825543,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645546330
    },
    {
        "content": "<p>Just thinking out loud: can we:</p>\n<ul>\n<li>Have two flavours of never type, i'll call it <code>never </code> and  <code>never_legacy</code>.</li>\n<li>Inference variables created by <code>never_legacy</code> coercion falls back to <code>()</code>.</li>\n<li>Inference variables created by <code>never</code> falls backs to <code>never</code>.</li>\n<li>All current way of producing <code>!</code> becomes <code>never_legacy</code> (e.g. return <code>!</code> ,<code>loop {}</code>)</li>\n<li><code>!</code> (except as function return value) and <code>Infallible</code> becomes alias to <code>never</code>.</li>\n<li>Change <code>never_legacy</code> to also falls back to <code>never</code> in the next edition.</li>\n</ul>",
        "id": 272828374,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645547331
    },
    {
        "content": "<blockquote>\n<p>In particular, you could impl for () and Infallible and if we change Infallible to alias !, things change. An edition doesn't really work here because the Infallible = ! change basically has to be global I think</p>\n</blockquote>\n<p>Yeah, but the documentation explicitly forbids doing that. If you do that and your code breaks when the compiler updates, well that's your fault. As long as it doesn't result in unsound code, it shouldn't be a problem.</p>",
        "id": 272952558,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645625110
    },
    {
        "content": "<p>Two flavors is essentially 'Edition-dependent migration away from special coercion behavior for !, letting us avoid inference algorithm changes while changing Infallible = ! aliasing.', I think, just with an early-opt-in of some kind on earlier editions under some other name (or context-dependent, in theory).</p>",
        "id": 272952800,
        "sender_full_name": "simulacrum",
        "timestamp": 1645625224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272952558\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>In particular, you could impl for () and Infallible and if we change Infallible to alias !, things change. An edition doesn't really work here because the Infallible = ! change basically has to be global I think</p>\n</blockquote>\n<p>Yeah, but the documentation explicitly forbids doing that. If you do that and your code breaks when the compiler updates, well that's your fault. As long as it doesn't result in unsound code, it shouldn't be a problem.</p>\n</blockquote>\n<p>Documentation doesn't forbid impls for () and Infallible? The only thing we ask users not to do is impl for Infallible and ! (e.g., for function pointers with those return types), but that's pretty unlikely compared to impling for () and Infallible, which is not unreasonable.</p>",
        "id": 272952891,
        "sender_full_name": "simulacrum",
        "timestamp": 1645625281
    },
    {
        "content": "<p>And it seems pretty clear that such a behavior change could result in unsound code since it's changing what gets called. Not necessarily currently <em>good</em> code changing, but still.</p>",
        "id": 272952984,
        "sender_full_name": "simulacrum",
        "timestamp": 1645625315
    },
    {
        "content": "<p>Was there ever a crater run done for unsafe code which would be impacted by the inference change?</p>",
        "id": 272953194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645625420
    },
    {
        "content": "<p>Honestly it's not clear to me how we can ever make changes to inference if this example is considered a soundness issue</p>",
        "id": 272953529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645625607
    },
    {
        "content": "<p>I'm not sure on crater, but we definitely have stumbled upon cases when trying to stabilize in user reports</p>",
        "id": 272953543,
        "sender_full_name": "simulacrum",
        "timestamp": 1645625614
    },
    {
        "content": "<p>a future incompatibility lint for this would be great</p>",
        "id": 272953650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645625649
    },
    {
        "content": "<p>IIRC, it's not clear in which cases we should lint to avoid false positives -- and without careful logic, you lint a lot on code that really doesn't care about this, which makes such a lint impractical. Plus, typically we emit such lints when the next step is either an error or a breaking change that's more benign than silently introducing miscompilations effectively (which is what some of the past attempts to land ! did for e.g. Servo).</p>",
        "id": 272954306,
        "sender_full_name": "simulacrum",
        "timestamp": 1645625982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272952800\">said</a>:</p>\n<blockquote>\n<p>Two flavors is essentially 'Edition-dependent migration away from special coercion behavior for !, letting us avoid inference algorithm changes while changing Infallible = ! aliasing.', I think, just with an early-opt-in of some kind on earlier editions under some other name (or context-dependent, in theory).</p>\n</blockquote>\n<p>I am not exactly sure what that \"migration away from special coercion behavior\" mean in that sentence. I interpret that as meaning that we can no longer accept a match where one arm returns <code>T</code> and another returns <code>!</code>? That doesn't sound good for me.</p>",
        "id": 272967035,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645631375
    },
    {
        "content": "<p>I think we're somewhat forced into it unless we want the complex inference algorithm</p>",
        "id": 272967543,
        "sender_full_name": "simulacrum",
        "timestamp": 1645631594
    },
    {
        "content": "<p>It's possible that the match desugaring / type check could be changed such that the first arm or something gives the canonical type, rather than trying to find ?M such that all the ?T from each arm can be coerced into it, which is I believe current logic.</p>",
        "id": 272967722,
        "sender_full_name": "simulacrum",
        "timestamp": 1645631660
    },
    {
        "content": "<p>I think we should keep accepting these. What I propose is that:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">todo!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Infallible</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">todo!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pattern1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unconstrained_return</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pattern2</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pattern1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unconstrained_return</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pattern2</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>will have <code>x</code> inferred to <code>Infallible</code> in Rust 2024 and <code>()</code> in Rust 2021, while <code>y</code> will always be inferred to <code>Infallible</code>.</p>",
        "id": 272969292,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645632195
    },
    {
        "content": "<p>I'm not sure what the advantage of that over just landing the complex inference algorithm onto all editions is -- we'd still have to maintain it, presumably, indefinitely for Rust 2015-2021 code</p>",
        "id": 272969537,
        "sender_full_name": "simulacrum",
        "timestamp": 1645632295
    },
    {
        "content": "<p>This is different from current rules I believe, this just looks at where the <code>!</code> comes from. If it's from a <code>-&gt; !</code> or a non-returning expression, then it falls back to <code>()</code>, and otherwsie it falls back to <code>!</code>.</p>",
        "id": 272969985,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645632474
    },
    {
        "content": "<p>It doesn't seem to fix the soundness problem, though? <code>y</code> inferring to Infallible is basically introducing UB into (poorly written, yes) unsafe code where it didn't really exist before</p>",
        "id": 272970622,
        "sender_full_name": "simulacrum",
        "timestamp": 1645632750
    },
    {
        "content": "<p>I agree it's a simpler rule set in theory, though I'm not sure we can plausibly track 'where ! comes from'</p>",
        "id": 272970659,
        "sender_full_name": "simulacrum",
        "timestamp": 1645632775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/never.20type.20design.20meeting/near/272970622\">said</a>:</p>\n<blockquote>\n<p>It doesn't seem to fix the soundness problem, though? <code>y</code> inferring to Infallible is basically introducing UB into (poorly written, yes) unsafe code where it didn't really exist before</p>\n</blockquote>\n<p>It wouldn't because <code>Infallible</code> can't unify with other types today so unconstrained type vars are already inferred to be <code>Infallible</code>.</p>",
        "id": 272974914,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645634581
    },
    {
        "content": "<p>I think the key takeaway is that there's no proposal so far that lets Infallible and ! alias unless we implement the complex inference algorithm</p>",
        "id": 272975486,
        "sender_full_name": "simulacrum",
        "timestamp": 1645634832
    },
    {
        "content": "<p>If we avoid that it's then possible to make changes over an edition boundary, perhaps as you describe.</p>",
        "id": 272975790,
        "sender_full_name": "simulacrum",
        "timestamp": 1645634970
    },
    {
        "content": "<p>My understanding is that Gary's proposal achieves this: <code>Infallible</code> and <code>!</code> are unified, but when written in certain positions like <code>foo() -&gt; !</code> you get the <code>never_legacy</code> type instead</p>",
        "id": 272979379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645636345
    },
    {
        "content": "<p>although I'm not clear on whether <code>never</code> and <code>never_legacy</code> unify as types though; can you have coherent impls on both?</p>",
        "id": 272979490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645636394
    },
    {
        "content": "<p>right, I think that is basically what I mean by don't unify</p>",
        "id": 272979693,
        "sender_full_name": "simulacrum",
        "timestamp": 1645636475
    },
    {
        "content": "<p>it's worth noting that you can get the <code>!</code> type appearing in nested contexts on stable (or the <code>never_legacy</code> type in Gary's proposal):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"cm\">/* : Option&lt;!&gt; */</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I don't know how to implement traits on such types though, since you have to name the type to do that</p>",
        "id": 272980823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645636906
    },
    {
        "content": "<p>You can do it by implementing a trait for <code>fn</code> and making an associated type for the return type.</p>\n<p>We're explicitly allowed to break people doing that, though.</p>",
        "id": 272981455,
        "sender_full_name": "scottmcm",
        "timestamp": 1645637138
    },
    {
        "content": "<p>Oh cool</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">type</span> <span class=\"nc\">Never</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span>::<span class=\"n\">Ret</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Never</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272982349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645637418
    },
    {
        "content": "<p>Meeting soon!  Re-linking the doc: <a href=\"https://hackmd.io/9sTGmQ_VQ_mX_bdQhuqVRA\">https://hackmd.io/9sTGmQ_VQ_mX_bdQhuqVRA</a></p>",
        "id": 272987205,
        "sender_full_name": "scottmcm",
        "timestamp": 1645639140
    },
    {
        "content": "<p>Since Niko isn't available, do we need a separate room today?</p>",
        "id": 272987551,
        "sender_full_name": "simulacrum",
        "timestamp": 1645639235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I can spin up a google meet or we can do jitsi</p>",
        "id": 272987580,
        "sender_full_name": "simulacrum",
        "timestamp": 1645639247
    },
    {
        "content": "<p>Let's try Jitsi, if that's OK.</p>",
        "id": 272987981,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645639383
    },
    {
        "content": "<p>Sure</p>",
        "id": 272988057,
        "sender_full_name": "simulacrum",
        "timestamp": 1645639410
    },
    {
        "content": "<p>Can you set it up?</p>",
        "id": 272988079,
        "sender_full_name": "simulacrum",
        "timestamp": 1645639418
    },
    {
        "content": "<p><a href=\"https://meet.jit.si/RBgxW8fHOMCtvKPO\">https://meet.jit.si/RBgxW8fHOMCtvKPO</a></p>",
        "id": 272988186,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645639459
    },
    {
        "content": "<p>ping <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> Design meeting starting.</p>",
        "id": 272988534,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645639582
    },
    {
        "content": "<p>I think I want to know more about these unsound cases in the wild.</p>",
        "id": 272996060,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645642930
    }
]