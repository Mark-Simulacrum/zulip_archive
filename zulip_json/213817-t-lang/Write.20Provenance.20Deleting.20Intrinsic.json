[
    {
        "content": "<p>Miri currently does not catch</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's because this is library UB only, and not language UB - the implementation of <code>.as_ptr()</code> returns the stored data pointer, which has write provenance. There are probably also many other examples of this for various <code>.as_ptr()</code> like functions on containers, smart pointers, etc. This could be addressed by the addition of some safe <code>.delete_write_provenance()</code> intrinsic (obviously not a good name) which accepts a pointer as input and returns as output a new pointer with all write provenance removed, should it have any (asserting absolutely no validity in the process, and keeping all other provenance the same). A perfectly legal implementation of this intrinsic would be the identity function, but rustc could both use this information for optimizations (ie marking pointers readonly) and miri can use it to catch more UB - like the example above</p>",
        "id": 270315191,
        "sender_full_name": "Jake",
        "timestamp": 1643763115
    },
    {
        "content": "<p>Another example of library UB that this would catch is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Block</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// SAFETY: we guarantee that `blocks` does not point outside of `data`</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">blocks</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts_mut</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">nb</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270317544,
        "sender_full_name": "Jake",
        "timestamp": 1643764421
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 270339557,
        "sender_full_name": "oli",
        "timestamp": 1643782236
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 270339990,
        "sender_full_name": "oli",
        "timestamp": 1643782690
    },
    {
        "content": "<p>So, the challenge here seems to be about what of other pointers? As in:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// assuming copy or w/e</span>\n<span class=\"o\">*</span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">r1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- is this elided?</span>\n</code></pre></div>\n<p>Currently the backing pointer is always SharedReadWrite, so this behaves fine (as in, the assertion is <em>not</em> elided).<br>\nBut the naïve ways to imagine stripping <code>p</code> of its write provenance, library-wise, would involve making it SharedReadOnly, in the <code>noalias</code> sense of LLVM: that <code>*pm</code> operation would be deemed <code>noalias</code>ing the <code>*p</code> reads, and thus the assertion could be elided altogether:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">as_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Invalidates the write rights of outstanding pointers!</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>::<span class=\"n\">slice</span>::<span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">().</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"n\">MU</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">capacity</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which, for a <code>&amp;</code>-based methods, looks a quite legitimate thing to do, but in the case of <code>Vec</code>, it is explicitly documented that this kind of methods do not do that.</p>",
        "id": 270403201,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643816119
    },
    {
        "content": "<hr>",
        "id": 270403202,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643816120
    },
    {
        "content": "<p>To me, the best candidate for these semantics would be <code>ptr::addr_of!</code>: it ought to artificially strip any write provenance to the pointee, even if the base pointer had some, while not tagging the pointee as read-only / the pointer itself as <code>noalias</code>. Basically the semantics of a <code>const *</code> pointer in C, IIRC.</p>\n<p>In this case, the operation <span class=\"user-mention\" data-user-id=\"310518\">@Jake</span>  is talking about would be expressed, in this instance, as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">ptr</span>::<span class=\"n\">addr_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span>::<span class=\"n\">slice_from_raw_parts</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">capacity</span><span class=\"p\">()))</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270403203,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643816121
    },
    {
        "content": "<p>Finally, I've found that it could sometimes be useful to have a <code>CellImmutRef&lt;'_, T&gt;</code> kind of reference, kind of similar to <code>Out&lt;'_, T&gt;</code> _vs._ <code>&amp;'_ mut MU&lt;T&gt;</code>: an <code>Out&lt;'_, T&gt;</code> doesn't make assumptions about the pointee, but it artificially restricts its API to only allow initialized values. This makes it so <code>&amp;'_ mut T -&gt; Out&lt;'_, T&gt;</code> can soundly be featured.</p>\n<p>With a <code>CellImmutRef&lt;'_, T&gt;</code>, such a pointer / reference (_e.g._, backed by a <code>&amp;'_ Cell</code>) would not make assumptions about the immutability of the pointee, and yet it would artifically restrict its API not to allow mutation through itself. This would allow featuring a sound <code>&amp;'_ T -&gt; CellImmutRef&lt;'_, T&gt;</code> API.</p>\n<p>The reason for such an API came up when porting some C code that had to deal with slices, and which wanted to manipulate / shuffle them around through some sorting algorithm which allowed the \"src slice\" and the \"dst slice\" to overlap.</p>\n<p>I recommended that <code>&amp;[Cell&lt;u8&gt;]</code> be used for the slices, but then it lead to the usability problem of the function not being usable on <code>&amp;[u8]</code>s without the caller using <code>unsafe</code>. Again, all this ought to sound similar to <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code> APIs, and how the solution was to use <a href=\"https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html\"><code>Out&lt;'_, [u8]&gt;</code></a>.</p>\n<p>So it seems that, at least from a library point of view, having the semantics of C <code>const *</code> could still make sense; and so the question is whether miri / SB could be made to take that into account: <code>SharedReadWriteWhichCantItselfWrite</code> or something <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 270404644,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643816639
    },
    {
        "content": "<p>Ah, for some reason I had thought that SB already had the tools to express this and that we could just fix this by returning a pointer with the correct value, but that's not the case</p>",
        "id": 270425667,
        "sender_full_name": "Jake",
        "timestamp": 1643823307
    },
    {
        "content": "<p>So the problem here is actually different now: it's not actually possible for the pointer returned by <code>Vec::as_ptr</code> to not have write provenance if it also doesn't invalidate other pointers, despite the claiming that this may be the case</p>",
        "id": 270426064,
        "sender_full_name": "Jake",
        "timestamp": 1643823434
    },
    {
        "content": "<p>By the way <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> : the intent was for other pointers to be entirely unaffected. Ie in your first example, <code>p</code> would be marked readonly, but there would be no justification for marking <code>pm</code> <code>noalias</code>, since raw pointers are aliasable in general</p>",
        "id": 270426725,
        "sender_full_name": "Jake",
        "timestamp": 1643823645
    },
    {
        "content": "<p>Yeah, I imagined such, that's why I wanted to point out this aspect. Note that I am not making claims either about what may or may not be possible to express within SB, just observations about this special \"pointer property\" which I haven't personally seen / noticed in SB <em>examples</em>; the formal model may feature it for all I know.</p>\n<p>That is, I still defer to RalfJ's input on the topic, I just mentioned this aspect which seems like an important distinction.</p>\n<p>Since, indeed, reducing to <code>SharedReadOnly</code> in a way that affects other pointers is currently possible, but undesirable for the case of <code>Vec</code>'s <code>.as_ptr()</code> <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 270427210,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643823823
    },
    {
        "content": "<p>So for the context of what I'm doing it's part of an experimental serialization system. It follows the design from miniserde largely where the deserialization interface is by putting values into slots. So this is the API I wanted to enable:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">deser</span>::<span class=\"n\">de</span>::<span class=\"p\">{</span><span class=\"n\">Sink</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Slot</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">DeserializerState</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">deser</span>::<span class=\"n\">Error</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyBool</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Sink</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Slot</span><span class=\"o\">&lt;</span><span class=\"n\">MyBool</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bool</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">value</span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_state</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">DeserializerState</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">place</span><span class=\"p\">(</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270428608,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643824282
    },
    {
        "content": "<p>fwiw, lccc's xlang has a construct for exactly this: <code>readshallow</code>, which is defined as follows:</p>\n<blockquote>\n<p>If a pointer is derived with the dereference_write attribute, all pointers that the pointer is (indirectly) derived from that point to the same object, or a superobject, and have the <code>readshallow</code> attribute are invalidated, except if this pointer points to a <code>mutable</code> subobject of that object or to a subobject thereof.</p>\n</blockquote>\n<p>It also has</p>\n<blockquote>\n<p>A byte is not reachable for writing from a pointer derived with the <code>readshallow</code> attribute, or from any pointer derived from that pointer, except to bytes contained within any mutable subobjects of the object pointed to by the <code>readshallow</code> pointer.</p>\n</blockquote>\n<p>(Note that here, <code>mutable</code> subobject basically means the contents of an <code>UnsafeCell</code>, and derive is effectively the stacked-borrows reborrow operation, though generalized, and possibly heavily overloaded).</p>\n<p>I don't know if Stacked Borrows itself can express something similar, since the model xlang uses is graph-based, rather than discrete stack-based, but this seems to be what is desired here: Prevent the pointer, and any pointers created from it from being used to write, while not invalidating any other pointers.</p>",
        "id": 270493717,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643856928
    },
    {
        "content": "<p>Yeah the only thing SB has here is basically what <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> wrote: reborrow through a shared reference.<br>\nHowever, if that's not what you want -- if you don't want the assertion in <a href=\"#narrow/stream/213817-t-lang/topic/Write.20Provenance.20Deleting.20Intrinsic/near/270403201\">the first example here</a> to be elided -- then I guess I dont quite understand why you want to have extra UB here in the first place. Which optimizations are enabled by this?</p>",
        "id": 271100599,
        "sender_full_name": "RalfJ",
        "timestamp": 1644312246
    },
    {
        "content": "<p>I think the main reason here is detecting the library undefined behaviour in miri, rather than enabling further optimizations. It is already undefined behaviour to write through a pointer returned from <code>Vec::as_ptr</code>, but it seems like it isn't allowed to invalidate other pointers.</p>",
        "id": 271122809,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644325059
    },
    {
        "content": "<p>Stacked Borrows as-is doesn't have the concepts necessary to express only local write preclusion, which is what these two points together seem to imply.</p>",
        "id": 271123011,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644325147
    },
    {
        "content": "<p>The Vec as_ptr docs currently say this <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_ptr\">https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_ptr</a></p>\n<blockquote>\n<p>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an UnsafeCell) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use as_mut_ptr.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Are you saying this restriction should maybe be relaxed? (Since it presumably doesn't enable anything)</p>",
        "id": 271172983,
        "sender_full_name": "Nick12",
        "timestamp": 1644345885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219940\">@Nick12</span> the restriction would IMO actually allow is to change <code>as_ptr</code> to do a shared reference reborrow, which would enable the optimization <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> suggested</p>",
        "id": 271259035,
        "sender_full_name": "RalfJ",
        "timestamp": 1644403929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Write.20Provenance.20Deleting.20Intrinsic/near/271122809\">said</a>:</p>\n<blockquote>\n<p>I think the main reason here is detecting the library undefined behaviour in miri, rather than enabling further optimizations. It is already undefined behaviour to write through a pointer returned from <code>Vec::as_ptr</code>, but it seems like it isn't allowed to invalidate other pointers.</p>\n</blockquote>\n<p>detecting library UB can become arbitrarily complicated and is not currently a goal of Miri -- I think long-term this might be an interesting extension, but (a) I think we should iron out the language spec before we do that, and (b) we should somehow engineer this so that it is clearly separate from the language UB checks</p>",
        "id": 271259148,
        "sender_full_name": "RalfJ",
        "timestamp": 1644404020
    }
]