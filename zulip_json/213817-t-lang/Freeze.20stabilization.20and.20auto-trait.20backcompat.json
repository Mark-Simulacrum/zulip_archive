[
    {
        "content": "<p>I was thinking about the <code>Freeze</code> proposal (<a href=\"https://github.com/mtak-/rfcs/blob/freeze/text/0000-freeze.md\">https://github.com/mtak-/rfcs/blob/freeze/text/0000-freeze.md</a>) and my objections to it WRT backwcompat</p>",
        "id": 214251682,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603402871
    },
    {
        "content": "<p>and I realized that my concerns are actually generalize-able to stable auto traits (the feature) as well</p>",
        "id": 214251731,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603402912
    },
    {
        "content": "<p>because they allow you to write <code>auto trait DoesntHaveU8 {} impl !DoesntHaveU8 for u8 {}</code></p>",
        "id": 214251817,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603402968
    },
    {
        "content": "<p>which allows you to, at compile-time, introspect for arbitrary field contents of types defined by remote library authors</p>",
        "id": 214251837,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603402993
    },
    {
        "content": "<p>this seems bad^TM</p>",
        "id": 214251843,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603403001
    },
    {
        "content": "<p>Has this come up before?</p>",
        "id": 214251861,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603403017
    },
    {
        "content": "<p>I agree it <em>seems</em> bad, but what harm can actually come of it?</p>",
        "id": 214252050,
        "sender_full_name": "cuviper",
        "timestamp": 1603403130
    },
    {
        "content": "<p>I guess then adding a private <code>u8</code> becomes a breaking change?</p>",
        "id": 214252160,
        "sender_full_name": "cuviper",
        "timestamp": 1603403197
    },
    {
        "content": "<p>Yes, exactly.</p>",
        "id": 214252188,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603403220
    },
    {
        "content": "<p>Adding private fields would now be a breaking change unless you already had a field of exactly that type.</p>",
        "id": 214252230,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603403259
    },
    {
        "content": "<p>I was trying to think of more practical examples... <code>Freeze</code> already makes adding <code>UnsafeCell</code> a breaking change, but then I realized you can do a type-level opposite of <code>needs_drop</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Levitate</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Drop</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">Levitate</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 214253229,
        "sender_full_name": "cuviper",
        "timestamp": 1603403910
    },
    {
        "content": "<p>Right, and the concern about <code>Freeze</code> is exactly why I'm extremely hesitant about the idea of stabilizing it.</p>",
        "id": 214253486,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603404101
    },
    {
        "content": "<p>The <a href=\"https://github.com/rust-lang/rust/issues/13231\">tracker for OIBIT</a> mentions a problem of conditional negative impls, which I think includes my <code>T: Drop</code> example.</p>",
        "id": 214253977,
        "sender_full_name": "cuviper",
        "timestamp": 1603404430
    },
    {
        "content": "<p>but I guess \"presence of a type\" at all is still a conditional negative impl</p>",
        "id": 214254005,
        "sender_full_name": "cuviper",
        "timestamp": 1603404452
    },
    {
        "content": "<p>it's really no different than the problem of adding a <code>!Send</code> or <code>!Sync</code> field to your type though</p>",
        "id": 214254182,
        "sender_full_name": "cuviper",
        "timestamp": 1603404568
    },
    {
        "content": "<p>As someone who really wants to use Freeze, the unintentional breaking changes of auto traits is problematic. I feel like Freeze is on the innocuous side because adding an Unsafe cell probably means you're changing the behavior of your struct in a non-trivial way, but it does put an implicit burden on basically all library maintainers.  It would be nice if there was a lint (or something?) that warned about changes to auto traits, especially std library ones.</p>",
        "id": 214254452,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603404750
    },
    {
        "content": "<p>If using something like <a href=\"https://github.com/rust-dev-tools/rust-semverver\">Cargo semvar</a> was standard, that would definitely help for std auto traits. However, I can't think of a way in which user definable auto traits won't always present a SemVar hazard. In the case of Freeze, workarounds should be fairly easy and  I believe the likelihood of non-intentional breaking change should be pretty low.</p>",
        "id": 214256937,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603406711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214251731\">said</a>:</p>\n<blockquote>\n<p>and I realized that my concerns are actually generalize-able to stable auto traits (the feature) as well</p>\n</blockquote>\n<p>Hm, I am confused by this -- auto traits are not stable, right? There's no way to do this in general on stable today</p>",
        "id": 214257092,
        "sender_full_name": "simulacrum",
        "timestamp": 1603406884
    },
    {
        "content": "<p>Or do you mean that <em>if</em> we had stabilized auto traits, this would be a concern? If so, I agree</p>",
        "id": 214257158,
        "sender_full_name": "simulacrum",
        "timestamp": 1603406948
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Correct, if we eventually aim to stabilize auto traits, this will be a problem.</p>",
        "id": 214258326,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1603408108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327642\">@Joshua Chartier</span> As someone who wants to use <code>Freeze</code>, how much of an imposition would it be for you if <code>Freeze</code> weren't an auto trait at all, and instead, types had to <code>#[derive(Freeze)]</code> if they wanted to offer that guarantee going forward? Assume for the sake of argument that types in <code>std</code> and <code>core</code> did so.</p>",
        "id": 214258669,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603408447
    },
    {
        "content": "<p>Well,  I want to create an append only log like structure that can be shared memory and reallocate (byte copy where I take care of drops) safely because I know it's not changing. Ideally, I'd really want to be an option for any type that I know wasn't going to change under me.</p>",
        "id": 214259001,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603408733
    },
    {
        "content": "<p>Making all the users of this data structure add #derive definitely puts limits on what people can do. Especially in the beginning</p>",
        "id": 214259129,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603408841
    },
    {
        "content": "<p>It basically means they couldn't use external structs</p>",
        "id": 214259237,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603408944
    },
    {
        "content": "<p>I do think pure-immutability is something that is under exploited in Rust. Though I definitely agree that it's pretty niche so far.</p>",
        "id": 214259358,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603409062
    },
    {
        "content": "<p>I absolutely agree that it'd be nice to have widely.</p>",
        "id": 214259471,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603409178
    },
    {
        "content": "<p>I'm wondering, in practice, how much of an imposition it'd be to have to get some key external structures to <code>derive(Freeze)</code> so you can use them.</p>",
        "id": 214259484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603409200
    },
    {
        "content": "<p>I think the concerns (at least as I understood them in the meeting discussion) meant that derive(Freeze) / this is not an auto trait doesn't actually help, since it likely means that folks would end up making PRs all over the place and the burden is still on library authors to understand Freeze. I'd personally rather have the auto trait than a derive, I think.</p>",
        "id": 214259570,
        "sender_full_name": "simulacrum",
        "timestamp": 1603409283
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I think the difference is that I'd hope there aren't a <em>massive</em> number of libraries that would need to add <code>Freeze</code> for this to be useful.</p>",
        "id": 214259934,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603409592
    },
    {
        "content": "<p>Yeah, I'm not sure derive(Freeze) is particularly useful. If that's the path to prove that these structures are useful, that's fine. I don't think it's a super big deal to have to use derive. But certainly, if it were to be more generally useful, I don't think derive really helps. It's would be like adding copy or clone to 90% of structs</p>",
        "id": 214259960,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603409616
    },
    {
        "content": "<p>Some library authors would still have to understand <code>Freeze</code>, but they wouldn't be unexpectedly trapped by it they way they might be if it were an auto trait.</p>",
        "id": 214259973,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603409627
    },
    {
        "content": "<p>Hm, so that's true, but it feels similar to things like <code>?Move</code> or whatever -- even if strictly speaking you probably don't care, don't need to do anything (i.e., too niche for me) it ends up being true that \"responsible\" library authors need to learn about it</p>",
        "id": 214260075,
        "sender_full_name": "simulacrum",
        "timestamp": 1603409686
    },
    {
        "content": "<p>I'm personally thinking that if we want to provide this in std, then the solution is pretty clearly an auto trait IMO</p>",
        "id": 214260216,
        "sender_full_name": "simulacrum",
        "timestamp": 1603409780
    },
    {
        "content": "<p>Agreed. I just don't think there are key structs that get us there. The power is that most structs already support it and if that weren't the case, it wouldn't be very useful</p>",
        "id": 214260282,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603409844
    },
    {
        "content": "<p>It's just unfortunate that they don't know that they support it <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 214260305,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603409876
    },
    {
        "content": "<p>One question I do have -- perhaps somewhat off topic -- is that I recall hearing/reading that patterns like the ones suggested here are usually UB (even if \"work in hardware\" is true), as they still having racing reads and writes. Is that not true? (It seems like it must not be)</p>",
        "id": 214260414,
        "sender_full_name": "simulacrum",
        "timestamp": 1603409972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214254452\">said</a>:</p>\n<blockquote>\n<p>I feel like Freeze is on the innocuous side because adding an Unsafe cell probably means you're changing the behavior of your struct in a non-trivial way.</p>\n</blockquote>\n<p>I have no trouble imagining some sort of strategy type where replacing compute-every-time with lookup-in-cache would be a completely reasonable change, FWIW.</p>",
        "id": 214260648,
        "sender_full_name": "scottmcm",
        "timestamp": 1603410161
    },
    {
        "content": "<p>I think that's tough to answer, but you definitely have to be very careful about synchronization. If you really asked me what I wanted, I'd say I want an &amp;immut borrow and freeze is really just a reasonably close approximation</p>",
        "id": 214260667,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603410182
    },
    {
        "content": "<p>You don't have to add an unsafe cell; you just have to add an Arc, for instance. Or a Mutex. Or an LRU cache...</p>",
        "id": 214260687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327642\">@Joshua Chartier</span> I honestly wish that were spelled <code>&amp;</code>, and the current \"shared but not immutable\" borrow got the more elaborate spelling, but that's the \"it's too late for that\" I mentioned in the meeting.</p>",
        "id": 214260755,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410246
    },
    {
        "content": "<p>@scottmcm I'm definitely not saying that it couldn't happen. I believe those types of changes tend to be wrapped up in SemVar breaking ways, though maybe that's less true for more mature crates where stability is more important. It's definitely something that should not be taken lightly.</p>",
        "id": 214261025,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603410524
    },
    {
        "content": "<p>That's fair.  I definitely imagine happening more in binaries where semver is much less important.</p>",
        "id": 214261286,
        "sender_full_name": "scottmcm",
        "timestamp": 1603410839
    },
    {
        "content": "<p>Or in \"single-purpose\" crates, that are mostly intended for one dependency chain even though they're a library.</p>",
        "id": 214261364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410910
    },
    {
        "content": "<p>I do think people should be less afraid of major version bumps.</p>",
        "id": 214261374,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410921
    },
    {
        "content": "<p>All that said, <em>if</em> we're going to make this an auto trait, I'd want an opt-out.</p>",
        "id": 214261390,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410944
    },
    {
        "content": "<p>Some way to <code>impl !Freeze for Type</code>.</p>",
        "id": 214261396,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410958
    },
    {
        "content": "<p>Not just \"don't be Freeze if you don't want to be Freeze\", and not just \"stuff a <code>PhantomUnfreezable</code> in there\" because that's more friction to do in practice.</p>",
        "id": 214261448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603410994
    },
    {
        "content": "<p>I've long wanted to stabilize negative impls for marker traits</p>",
        "id": 214261459,
        "sender_full_name": "simulacrum",
        "timestamp": 1603411017
    },
    {
        "content": "<p>I feel like if there's an opt-out, we'd end up keeping the hidden one internally for use in the compiler for the original \"can go in readonly memory\" purpose...</p>",
        "id": 214261460,
        "sender_full_name": "scottmcm",
        "timestamp": 1603411019
    },
    {
        "content": "<p>I'm excited to see negative impls on everything, even if we're not at the phase of being able to use them for coherence yet.</p>",
        "id": 214261681,
        "sender_full_name": "scottmcm",
        "timestamp": 1603411222
    },
    {
        "content": "<p>Overall, I don't strongly disagree with the decision to close the RFP at least until there is more of a ground swell around the use cases. There is definitely a burden on those who want to be careful  about their libraries and rust is fortunate enough to have numerous of those. I do hope that it is something that could be revisited if there was more proof of its usefulness. It is a bit of a chicken and an egg problem though, if it were more exposed, people might start taking more advantage of it. True immutability could open up some really interesting concurrent data structures and it'd be awesome if we could express them effectively in Rust</p>",
        "id": 214261845,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603411422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214261845\">said</a>:</p>\n<blockquote>\n<p>Overall, I don't strongly disagree with the decision to close the RFP at least until there is more of a ground swell around the use cases. There is definitely a burden on those who want to be careful  about their libraries and rust is fortunate enough to have numerous of those. I do hope that it is something that could be revisited if there was more proof of its usefulness. It is a bit of a chicken and an egg problem though, if it were more exposed, people might start taking more advantage of it. True immutability could open up some really interesting concurrent data structures and it'd be awesome if we could express them effectively in Rust</p>\n</blockquote>\n<p>I'm genuinely excited about the idea of immutable data structures for concurrency. (I'm not generally a fan of STM, but I do like other mechanisms for \"swap a new version in place atomically\" and similar.)</p>",
        "id": 214270817,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603424877
    },
    {
        "content": "<p>I personally think <code>Freeze</code> seems reasonable, my only concern is the ecosystem effect of adding a new auto trait.</p>",
        "id": 214270863,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603424900
    },
    {
        "content": "<p>Yeah, I think I agree with Taylor's original skepticism about us perhaps ever stabilizing <code>auto trait</code> because of the infectiousness.</p>\n<p>I guess to be willing to do it we'd need to have a super-general opt-out mechanism for all of them, but that's also pretty painful since it means needing to opt back into <code>Send</code>, which sounds like a good way for people to start doing it by rote, and then potentially doing it wrong.  Hmm, maybe the big opt-out could allow a non-unsafe <code>impl Send for Foo;</code> that only works if all the fields are <code>Send</code>...</p>",
        "id": 214271498,
        "sender_full_name": "scottmcm",
        "timestamp": 1603425918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214271498\">said</a>:</p>\n<blockquote>\n<p>Hmm, maybe the big opt-out could allow a non-unsafe <code>impl Send for Foo;</code> that only works if all the fields are <code>Send</code>...</p>\n</blockquote>\n<p>How about <code>#[derive(Send)]</code> automatically adding an impl:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"n\">fields</span><span class=\"o\">&gt;</span><span class=\"p\">,)</span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>seems better than inventing new custom syntax.</p>",
        "id": 214277493,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1603433675
    },
    {
        "content": "<p>Any variety of things could work.  I was just hoping for something that wouldn't take unsafe in the crate, so that <code>cargo geiger</code> or whatever wouldn't go \"You need to audit this\".</p>",
        "id": 214284872,
        "sender_full_name": "scottmcm",
        "timestamp": 1603441117
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  <a href=\"https://github.com/jonhoo/rust-evmap\">evmap</a> is another potential use case. It's pretty easy to imagine an implementation that replaces the Clone bound with  Freeze.  That would expand the number of usable cases for evmap while making it more efficient by removing needless cloning and dropping. It also has a ShallowCopy trait and derive macro so talking to the maintainers might be good datapoint on how burdensome the use of a derive() is in practice. I've added an <a href=\"https://github.com/jonhoo/rust-evmap/issues/71\">issue</a> to evmap asking them to comment.</p>",
        "id": 214323262,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603464647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Your global opt out method could also allow you to exclude certain auto traits, which might let you limit the unsafe. Another piece that I think might be interesting is if std lib pub auto traits could be tied to editions. Previous editions would have to be explicit opt in and therefore would only be breaking if the library authors changed their minds, but in newer editions they would become explicit opt out and SemVar compatibility is something that has to be considered as part of the contract for the new edition.</p>",
        "id": 214331399,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603468737
    },
    {
        "content": "<p>Editions generally can't affect the library.  I guess you could get different auto traits depending on where you compiled by having the compiler auto-opt-out of some of them depending on the edition used to compile the crate that defined the type?  Feels a bit weird, though...</p>",
        "id": 214334682,
        "sender_full_name": "scottmcm",
        "timestamp": 1603470439
    },
    {
        "content": "<p>Yep, that's the idea. In theory adding  an auto trait wouldn't break a library, though changing the edition the library could create a semvar hazard,  but that's pretty unavoidable for auto traits and at least this gives a clear place where it needs to be considered. In practice, I have no idea if this is even remotely feasible, and it's a huge leap from adding a pub to an existing trait, so, yeah... but if new auto traits are going to be a thing, this might be a way to do it in a consistent and, hopefully, manageable way.</p>",
        "id": 214340331,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603473295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214259001\">said</a>:</p>\n<blockquote>\n<p>Well,  I want to create an append only log like structure that can be shared memory and reallocate (byte copy where I take care of drops) safely because I know it's not changing. Ideally, I'd really want to be an option for any type that I know wasn't going to change under me.</p>\n</blockquote>\n<p>given that <code>Box&lt;Cell&lt;T&gt;&gt;</code> is <code>Freeze</code> and otherwise has basically the same API behavior as <code>Cell&lt;T&gt;</code>... I wonder what the concrete guarantee for a type is that this append-only log would need?</p>",
        "id": 214344453,
        "sender_full_name": "RalfJ",
        "timestamp": 1603475367
    },
    {
        "content": "<p>The guarantee needed is that I can copy the bytes of the struct (top level only, i.e. the just the pointer in box) from one location to another while still being able to read and potentially dereference those bytes from both locations. Structs will be be deallocated when no longer in use and when the last copy of the struct is to be deallocated drop will be called.  Cell&lt;T&gt; can't directly be copied because it might catch T in an invalid state, this should not be a problem with Box&lt;Cell&lt;T&gt;&gt; since existing references are still valid.</p>",
        "id": 214346492,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603476315
    },
    {
        "content": "<p>T can also not be self-referential, but I think that is already covered by Rust move-ability constraints</p>",
        "id": 214346660,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603476382
    },
    {
        "content": "<blockquote>\n<p>Cell&lt;T&gt; can't directly be copied because it might catch T in an invalid state</p>\n</blockquote>\n<p>ah so specifically you want to do this concurrently with other potential accesses?</p>",
        "id": 214346923,
        "sender_full_name": "RalfJ",
        "timestamp": 1603476503
    },
    {
        "content": "<p>Yes. Though definitely let me know if there's some pointer aliasing thing going on in the compiler that makes it so this isn't a safe thing to do.</p>",
        "id": 214347079,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603476582
    },
    {
        "content": "<p><code>Cell</code> specifically is a strange example here though... <code>Cell&lt;T&gt;: Copy</code> would be sound (if <code>T: Copy</code>). but your approach sounds like it should definitely work for any <code>Copy</code> type. ergo it should also work for <code>Cell</code>.</p>",
        "id": 214347170,
        "sender_full_name": "RalfJ",
        "timestamp": 1603476609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214347079\">said</a>:</p>\n<blockquote>\n<p>Yes. Though definitely let me know if there's some pointer aliasing thing going on in the compiler that makes it so this isn't a safe thing to do.</p>\n</blockquote>\n<p>I'd need to look more closely at what concretely happens. do you have a small self-contained example of the kind of thing you'd like to do to a <code>T</code>/<code>&amp;T</code>?</p>",
        "id": 214347233,
        "sender_full_name": "RalfJ",
        "timestamp": 1603476639
    },
    {
        "content": "<p>How small is small? Here's some <a href=\"https://github.com/jfcha/imm-ds/blob/a1fdfe4f0d40925c98da8092d8f5a95b362c54cf/arc-log/src/arc_log.rs#L577\">test code</a>. I'm still in the process of getting my code crate ready, but hopefully this will give you an idea.</p>",
        "id": 214347644,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603476842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214347644\">said</a>:</p>\n<blockquote>\n<p>How small is small? Here's some <a href=\"https://github.com/jfcha/imm-ds/blob/a1fdfe4f0d40925c98da8092d8f5a95b362c54cf/arc-log/src/arc_log.rs#L577\">test code</a>. I'm still in the process of getting my code crate ready, but hopefully this will give you an idea.</p>\n</blockquote>\n<p>hm, I was hoping for something that just demonstrates the core principle without being nicely wrapped in an API^^ but maybe that is too much to ask</p>",
        "id": 214349804,
        "sender_full_name": "RalfJ",
        "timestamp": 1603477960
    },
    {
        "content": "<p>The basic structure is a blend of Arc and RawVec (hence all the nightly usage). Each allocation keeps it's own reference count of all it's reference clones and has a forward pointer. There's a spin lock on write and when a write reaches capacity, it adds a forward pointer to a new allocation and copies all the bytes. The other clones can then call update(&amp;mut self) to move their pointers to the new allocation when they are ready.</p>",
        "id": 214349878,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603478000
    },
    {
        "content": "<p>what do you think about <code>Cell&lt;T&gt;</code> being <code>Copy</code> though? I have a proof that that is sound, so if it would be a problem for you then something very interesting would definitely be going on</p>",
        "id": 214349909,
        "sender_full_name": "RalfJ",
        "timestamp": 1603478024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214349878\">said</a>:</p>\n<blockquote>\n<p>The basic structure is a blend of Arc and RawVec (hence all the nightly usage). Each allocation keeps it's own reference count of all it's reference clones and has a forward pointer. There's a spin lock on write and when a write reaches capacity, it adds a forward pointer to a new allocation and copies all the bytes. The other clones can then call update(&amp;mut self) to move their pointers to the new allocation when they are ready.</p>\n</blockquote>\n<p>thanks; putting it on my weekend list (but I cant promise I'll get through the entire list^^)</p>",
        "id": 214350019,
        "sender_full_name": "RalfJ",
        "timestamp": 1603478076
    },
    {
        "content": "<p>Or they can keep referencing  the old allocation by &amp;.</p>\n<p>Is Cell&lt;T&gt;:Clone also Sync? I think that would be where my hang up would be</p>",
        "id": 214350050,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603478099
    },
    {
        "content": "<p>no <code>Cell</code> is never <code>Sync</code></p>",
        "id": 214350085,
        "sender_full_name": "RalfJ",
        "timestamp": 1603478117
    },
    {
        "content": "<p>that would be very unsound</p>",
        "id": 214350099,
        "sender_full_name": "RalfJ",
        "timestamp": 1603478128
    },
    {
        "content": "<p>Does copy also copy the T? Or is it a shallow copy?</p>",
        "id": 214350507,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603478326
    },
    {
        "content": "<p>I dont understand the question... an implicit copy is always shallow in Rust, but a shallow copy of a <code>Cell&lt;T&gt;</code> (where <code>T: Copy</code>) copies the <code>T</code> of course</p>",
        "id": 214350793,
        "sender_full_name": "RalfJ",
        "timestamp": 1603478485
    },
    {
        "content": "<p>Sorry, I'm a little slow on this. I think, I get it now. The point is that Cell&lt;T&gt; : Copy gives you a new Cell that can change in place, that happens to have the same value as the old Cell. Which is useful. Minus the sync part it would be safe in my setup, though it would lead to surprising behavior.</p>",
        "id": 214351465,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603478820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327642\">@Joshua Chartier</span> Would <code>Pin</code> help you at all?</p>",
        "id": 214361977,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603484853
    },
    {
        "content": "<p>Or rather, <code>Unpin</code>?</p>",
        "id": 214362000,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603484866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  I had originally thought  I needed Freeze + Unpin, but I don't think so any more. Mostly because I expect ArcLog&lt;T&gt; to own T going in. So if T is already a pointer (and Pin only takes a pointer), I don't have a problem because copying/moving a pointer is fine. I don't give out &amp;mut access to any of my inner data, so Pin is pretty irrelevant. If Rust starts having a Move trait that allows self referential structs I'll have a problem, though, because I am invalidating the self references. But I think that's a general problem and not allowed (safely) in Rust anyway.</p>",
        "id": 214363845,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603485877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  Here's a <a href=\"https://github.com/jfcha/imm-ds/blob/master/arc-log/ArcLog.jpg\">simple diagram</a> of the key functionality. The diagram only shows two references, but there could be N different references on M different threads and at any time a given reference could have &amp; borrows in the form of slices (no &amp;mut slices). The only time &amp; borrowed slices may not exist for a given reference is when &amp;mut self calls are needed for that reference to push/update/drop (i.e. normal rust rules). The key step is the reallocation in step  4.  That's where the Freeze bound comes into play. The thought is that if T has no interior mutability it's safe to just copy the bytes. Copy is stronger than I need, because I can still guaranteed drop is called, and only called once. Clone would work, but then you're paying the price for clones and drops on all allocations. Box could also work, but then you're paying for the extra indirection. I would definitely love to know if there's some reason that Freeze is not a strong enough guaranteed to safely copy and eventually deallocate and finally drop. It seems to generally be working, but my testing is still pretty limited at this point.</p>\n<div class=\"message_inline_image\"><a href=\"https://github.com/jfcha/imm-ds/blob/master/arc-log/ArcLog.jpg\" title=\"simple diagram\"><img src=\"https://raw.githubusercontent.com/jfcha/imm-ds/master/arc-log/ArcLog.jpg\"></a></div>",
        "id": 214371406,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603491042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327642\">@Joshua Chartier</span> Which program did you use to make that diagram?</p>",
        "id": 214416919,
        "sender_full_name": "bjorn3",
        "timestamp": 1603530474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span>  I used <a href=\"https://github.com/jgraph/drawio-desktop\">diagrams.net</a>. I haven't used it a ton, but so far I like it. They also have an online version, but I prefer the desktop application.</p>",
        "id": 214433293,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603553246
    },
    {
        "content": "<p>Thanks. I will take a look.</p>",
        "id": 214433903,
        "sender_full_name": "bjorn3",
        "timestamp": 1603554056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I was thinking about Cell&lt;T&gt; being Copy and my ArcLog&lt;T&gt;. Even in a single threaded version that didn't require Sync (RcLog!) I would not want to allow Cell in my Ts. It wouldn't be unsafe, but the behavior would be surprising if you made a change via an &amp; borrow, updated RcLog to get new items and that change was no longer there. I want my allocations to maintain byte for byte equality for items that exist in multiple allocation. Cell&lt;T&gt; could circumvent that, copy or not.</p>\n<p>Separately, I do have a use for Cell&lt;T&gt; being Copy, if you're looking for use cases. Right now my ArcLog reference counts because I assume that memory is a constraint. If it wasn't and I never needed to deallocate, I could create a new type of log structure, let's call it SharedLog,<br>\n<code>struct SharedLog&lt;T: Freeze&gt; { ptr: Cell&lt;NonNull&lt;InnerSharedLog&lt;T&gt;&gt;&gt; } </code> <br>\nand it could be Copy like any other pointer and I could update it to point to the newest allocation on any dereference so it could always be up to date. That would make for a really nice user experience. That said, I think Cell&lt;T&gt; being Copy would be a huge footgun (and why I was confused earlier). I don't expect to get a new Cell if I move it (aka, call it by new name), even if its T is Copy. But if it were a different struct, say CopyCell&lt;T&gt;, and I knew that I had to be careful about moves, it could definitely be useful!</p>",
        "id": 214508632,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1603655595
    },
    {
        "content": "<p>Right, there are good reaosns for making <code>Cell</code> not <code>Copy</code> that are unrelated to soundness, which is why the usual proposals there involve some lints or so, I think</p>",
        "id": 214509294,
        "sender_full_name": "RalfJ",
        "timestamp": 1603656381
    },
    {
        "content": "<p>I was mostly curious if you were relying on <code>Copy</code> implying <code>Freeze</code> (which is the case currently but broken by making <code>Cell: Copy</code>)</p>",
        "id": 214509302,
        "sender_full_name": "RalfJ",
        "timestamp": 1603656403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127859\">Taylor Cramer</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/214251861\">said</a>:</p>\n<blockquote>\n<p>Has this come up before?</p>\n</blockquote>\n<p>Yes, it has definitely come up before.</p>",
        "id": 214607990,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1603733914
    },
    {
        "content": "<p>I am not sure whether auto traits will ever be something we permit outside the stdlib for this reason</p>",
        "id": 214608275,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1603734047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  Random question of the day: Should the field <em>value</em> of  MaybeUninit&lt;T&gt; actually be ManuallyDrop&lt;UnsafeCell&lt;T&gt;&gt; instead of just ManuallyDrop&lt;T&gt;? I was thinking of this in the terms of Freeze and how you can't count on the byte representation of a MaybeUninit. I doubt it makes any real difference in the given usage, but it seemed to fit in the same conceptual bucket.</p>",
        "id": 215032796,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1604008016
    },
    {
        "content": "<p>does that include an initialized <code>MaybeUninit&lt;T&gt;</code>?</p>",
        "id": 215033115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604008211
    },
    {
        "content": "<p>I think this (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=649399a6e71aa952f0270eedb8915a14\">playground link</a>) is a program that is UB only if initialized MaybeUninits are not in an unsafecell:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 215034151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604008849
    },
    {
        "content": "<p>I don't think it should be conflated with mutability. You can use <code>MaybeUninit&lt;UnsafeCell&lt;T&gt;&gt;</code> if needed.</p>",
        "id": 215035054,
        "sender_full_name": "cuviper",
        "timestamp": 1604009446
    },
    {
        "content": "<p>I would think it only matters for the uninitialized, so maybe I should have been pointing at <em>init</em> instead of <em>value</em>. I was thinking about the Freeze auto trait and it seem like MaybeUninit should not be Freeze. But yeah, maybe that's a distinction that should be separate from mutability.</p>",
        "id": 215035518,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1604009783
    },
    {
        "content": "<p>I think it should be freeze, because the compiler is free to assume that it cannot be mutably aliased, because the only way it differs from a <code>T</code> is when the value is uninitialized in which case a write cannot race any read because all reads are UB</p>",
        "id": 215035908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604010069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327642\">Joshua Chartier</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215032796\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>  Random question of the day: Should the field <em>value</em> of  MaybeUninit&lt;T&gt; actually be ManuallyDrop&lt;UnsafeCell&lt;T&gt;&gt; instead of just ManuallyDrop&lt;T&gt;? I was thinking of this in the terms of Freeze and how you can't count on the byte representation of a MaybeUninit. I doubt it makes any real difference in the given usage, but it seemed to fit in the same conceptual bucket.</p>\n</blockquote>\n<p>no, there is no interior mutability here</p>",
        "id": 215067252,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047347
    },
    {
        "content": "<p><code>UnsafeCell</code> is specifically granting the power to mutate data behind a shared reference</p>",
        "id": 215067292,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047381
    },
    {
        "content": "<p>that is fully orthogonal to whether you are working with uninitialized data. usually in Rust we strive to have APIs that do one thing and one thing only... like, we could merge <code>Arc</code> and <code>RwLock</code> into a single type for a \"thread-safe freely sharable pointer to concurrently accessible data\", but that would be a bad design decision as the pieces are independently useful. the same is true for <code>MaybeUninit</code> and <code>UnsafeCell</code>.</p>",
        "id": 215067309,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047399
    },
    {
        "content": "<blockquote>\n<p>I think this (playground link) is a program that is UB only if initialized MaybeUninits are not in an unsafecell:</p>\n</blockquote>\n<p>this program is indeed UB and is intended to be UB. why do you think that this is an okay way to use <code>MaybeUninit</code>? You are mutating through a shared reference!</p>",
        "id": 215067333,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047434
    },
    {
        "content": "<p>the <a href=\"https://doc.rust-lang.org/nightly/std/mem/union.MaybeUninit.html#method.as_ptr\">docs for <code>MabyeUninit::as_ptr</code></a> explicitly say</p>\n<blockquote>\n<p>Writing to memory that this pointer (non-transitively) points to is undefined behavior (except inside an UnsafeCell&lt;T&gt;).</p>\n</blockquote>",
        "id": 215067403,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047469
    },
    {
        "content": "<p>this is the same for basically all the <code>as_ptr</code> methods in the stdlib</p>",
        "id": 215067418,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047485
    },
    {
        "content": "<p>I don't think there is any good reason to make this one an exception</p>",
        "id": 215067432,
        "sender_full_name": "RalfJ",
        "timestamp": 1604047497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215067333\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think this (playground link) is a program that is UB only if initialized MaybeUninits are not in an unsafecell:</p>\n</blockquote>\n<p>this program is indeed UB and is intended to be UB. why do you think that this is an okay way to use <code>MaybeUninit</code>? You are mutating through a shared reference!</p>\n</blockquote>\n<p>I <em>do</em> think it should be UB. Sorry for not making that clear. The idea was to get a concrete example of a program that would be affected by the proposed change</p>",
        "id": 215080705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604056303
    },
    {
        "content": "<p>Also, the program can be modified to start with <code>MaybeUninit::uninit()</code> instead of <code>MaybeUninit::new(1)</code> and you get the same result: currently UB, detected by miri, would be defined under the proposal, and in this case it is even the uninit value being non-freeze, not just a defined value in a <code>MaybeUninit</code></p>",
        "id": 215081025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604056546
    },
    {
        "content": "<p>also FWIW, I'd use <code>UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> which will work better with the stable APIs, and it better conveys that even the initialziation status may change</p>",
        "id": 215081059,
        "sender_full_name": "RalfJ",
        "timestamp": 1604056563
    },
    {
        "content": "<p>Wait, are those different? Specifically, is it UB to write to an uninitialized <code>MaybeUninit&lt;UnsafeCell&lt;T&gt;&gt;</code> through a shared pointer?</p>",
        "id": 215081292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604056701
    },
    {
        "content": "<p>I recall there being some other discussions about unsafecells in unions but I'm not sure how that all works</p>",
        "id": 215081392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604056762
    },
    {
        "content": "<p>I feel like making a difference is a good way to simplify the interactions through shared references to <code>MU</code>, see <a href=\"https://github.com/rust-lang/rust/issues/66699#issuecomment-709223948\">https://github.com/rust-lang/rust/issues/66699#issuecomment-709223948</a></p>",
        "id": 215092585,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1604063771
    },
    {
        "content": "<p>Hmm. I guess I was thinking of a Freeze bound as a guarantee that if I do a shallow read of the bytes of this type, I will always get the same result (aka, the functional programming ideal of run with same inputs, get the same results). And since reading a MaybeUninit can be UB,  that does not hold. But no interior mutability is different, literally what's in code, and also useful. I definitely appreciate the clarification. Unfortunately, this leads to my next question. Is there some trait equivalent to !MaybeUninit, aka, something that says T is always safe to read? And if not, how about another semvar hazard auto trait! Sadly, only half kidding. Also, if reading from MaybeUninit can be UB, how is Vec&lt;MaybeUninit&lt;T&gt;&gt; safe when it has capacity increasing reallocations? Is copying the bytes not actually considered a read?</p>",
        "id": 215145714,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1604089104
    },
    {
        "content": "<p>Reading a MaybeUninit at type MaybeUninit is not UB</p>",
        "id": 215145827,
        "sender_full_name": "simulacrum",
        "timestamp": 1604089194
    },
    {
        "content": "<p>and memcpy or realloc do so</p>",
        "id": 215145836,
        "sender_full_name": "simulacrum",
        "timestamp": 1604089201
    },
    {
        "content": "<p>OOhhh. Ok. Thanks. That makes a lot of sense. It's only when you look inside. Sorry for the noise.</p>",
        "id": 215146005,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1604089293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215081292\">said</a>:</p>\n<blockquote>\n<p>Wait, are those different? Specifically, is it UB to write to an uninitialized <code>MaybeUninit&lt;UnsafeCell&lt;T&gt;&gt;</code> through a shared pointer?</p>\n</blockquote>\n<p>I do not think it is UB, but I'd consider it unclear code. If we think of <code>MaybeUninit</code> as \"<code>Option</code> without the tag\", then what you want here is definitely <code>UnsafeCell&lt;Option&lt;T&gt;&gt;</code>, not <code>Option&lt;UnsafeCell&lt;T&gt;&gt;</code>, which differ by whether the tag is mutable when shared or not.</p>",
        "id": 215188983,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327642\">@Joshua Chartier</span> it sounds a bit like you assume that readuing uninit memory is UB in Rust. It is not, but somehow this is a common belief. But there is no such clause <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">listed here</a>.</p>",
        "id": 215189046,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146703
    },
    {
        "content": "<p>Reading uninit memory is UB <em>at some types</em>, just like reading <code>0x03</code> is UB at some types (namely, <code>bool</code>).</p>",
        "id": 215189054,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146728
    },
    {
        "content": "<blockquote>\n<p>I do not think it is UB, but I'd consider it unclear code. If we think of MaybeUninit as \"Option without the tag\",</p>\n</blockquote>\n<p>This is the part that confuses me. If it's an option without the tag, then when it is in None state it should not be modifiable, even if it would be if it were in the Some(UnsafeCell) state</p>",
        "id": 215207115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604171532
    },
    {
        "content": "<p>isn't the point here do be able to take a shared ref to and initialize it through that?</p>",
        "id": 215209404,
        "sender_full_name": "RalfJ",
        "timestamp": 1604174612
    },
    {
        "content": "<p>I don't disagree that <code>UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> is better for this use case. I'm just double checking that there is no special case around <code>MaybeUninit&lt;UnsafeCell&lt;T&gt;&gt;</code> that would make it equivalent, which your earlier comment suggested</p>",
        "id": 215211549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604177644
    },
    {
        "content": "<p>Actually, I've managed to phrase the difference between both types, and why they <strong>do not commute</strong>: while you can write an initialised <code>T</code> through a shared reference to both types, you can only write an uninit <code>T</code> through a shared reference to a <code>UC&lt;MU&lt;T&gt;&gt;</code>, and not a <code>MU&lt;UC&lt;T&gt;&gt;</code></p>",
        "id": 215215752,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1604185019
    },
    {
        "content": "<p>At least theoretically. The current implementation makes enough guarantees about the layout and the freeze-ness of these types that I can't think of a way the compiler could exploit this difference, but library crates would very much like to (<em>c.f.</em>, my previous post).</p>",
        "id": 215215836,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1604185194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215211549\">said</a>:</p>\n<blockquote>\n<p>I don't disagree that <code>UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> is better for this use case. I'm just double checking that there is no special case around <code>MaybeUninit&lt;UnsafeCell&lt;T&gt;&gt;</code> that would make it equivalent, which your earlier comment suggested</p>\n</blockquote>\n<p>there is no special case but I think they are mostly equivalent if you go down to the operational semantics with Stacked Borrows -- <code>UnsafeCell</code> affects the locations on which it sits, and that is the same in both cases.<br>\nBut due to their conceptual difference I'd advice against doing that.</p>",
        "id": 215234217,
        "sender_full_name": "RalfJ",
        "timestamp": 1604220370
    },
    {
        "content": "<p>Wait, so if you have a <code>Result&lt;u32, UnsafeCell&lt;u32&gt;&gt;</code> then it's not UB to modify the <code>Ok(ref n)</code> case through a shared pointer?</p>",
        "id": 215241684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604232750
    },
    {
        "content": "<p>this seems undesirable... but also off topic for this thread. I think there is a relevant UCG issue about this somewhere</p>",
        "id": 215241702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604232829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215241702\">said</a>:</p>\n<blockquote>\n<p>this seems undesirable... but also off topic for this thread. I think there is a relevant UCG issue about this somewhere</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/236\">https://github.com/rust-lang/unsafe-code-guidelines/issues/236</a></p>",
        "id": 215260828,
        "sender_full_name": "RalfJ",
        "timestamp": 1604262563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215241684\">said</a>:</p>\n<blockquote>\n<p>Wait, so if you have a <code>Result&lt;u32, UnsafeCell&lt;u32&gt;&gt;</code> then it's not UB to modify the <code>Ok(ref n)</code> case through a shared pointer?</p>\n</blockquote>\n<p>that is not at all what I said but also true under the current implementation of Stacked Borrows</p>",
        "id": 215260838,
        "sender_full_name": "RalfJ",
        "timestamp": 1604262579
    },
    {
        "content": "<p>we were not talking about an enum so I am confused by the segway^^</p>",
        "id": 215260857,
        "sender_full_name": "RalfJ",
        "timestamp": 1604262601
    },
    {
        "content": "<p>an enum is just a union with a discriminant</p>",
        "id": 215261119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604262889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215261119\">said</a>:</p>\n<blockquote>\n<p>an enum is just a union with a discriminant</p>\n</blockquote>\n<p>no, the two are much more different than that</p>",
        "id": 215264732,
        "sender_full_name": "RalfJ",
        "timestamp": 1604268440
    },
    {
        "content": "<p>unions have no \"active variant\" or so, they are just syntactic sugar for <code>transmute</code> on each access</p>",
        "id": 215264739,
        "sender_full_name": "RalfJ",
        "timestamp": 1604268455
    },
    {
        "content": "<p>that is very different from enums</p>",
        "id": 215264747,
        "sender_full_name": "RalfJ",
        "timestamp": 1604268461
    },
    {
        "content": "<p>if you look at <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">my proposal for what an \"abstract value\" could be</a> in the rust abstract machine, you'll notice <code>Variant</code> for enums and <code>RawBag</code> for unions.</p>",
        "id": 215264814,
        "sender_full_name": "RalfJ",
        "timestamp": 1604268534
    },
    {
        "content": "<p>also formally speaking, \"union\" and \"disjoint union\" (aka enum) are entirely distinct concepts with very different properties (e.g. in type theory or category theory)</p>",
        "id": 215264837,
        "sender_full_name": "RalfJ",
        "timestamp": 1604268573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215264739\">said</a>:</p>\n<blockquote>\n<p>unions have no \"active variant\" or so, they are just syntactic sugar for <code>transmute</code> on each access</p>\n</blockquote>\n<p>Ah, that is good to know. I was working under the assumption that the typing condition for a union is the disjunction of the members. So this implies that unions have no validity invariant then, they are just a \"bag of bytes\"? (Edit: I guess you just said as much.)</p>",
        "id": 215268071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604273334
    },
    {
        "content": "<p>From reading the UCG issue on unions the validity invariant should be that, althoguh there's the caveat that padding bits are indeterminate so bag of bytes might not be the best model.</p>",
        "id": 215269694,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1604276141
    },
    {
        "content": "<p>so, wait, if I have <code>union U { v: bool }</code> I can store <code>3</code> in <code>U</code>?!</p>",
        "id": 215272378,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1604280488
    },
    {
        "content": "<p>apparently...</p>",
        "id": 215272571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604280848
    },
    {
        "content": "<p>although you will not be able to do so anyway without unsafe code</p>",
        "id": 215272580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604280891
    },
    {
        "content": "<p>This just means that storing 3 in <code>U</code> is not insta-UB as it would be in a bool, because there is no easy accidental deref happening with unions</p>",
        "id": 215272638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604280965
    },
    {
        "content": "<p>it is still UB to read 3 from <code>U.v</code></p>",
        "id": 215272643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604280993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215268071\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215264739\">said</a>:</p>\n<blockquote>\n<p>unions have no \"active variant\" or so, they are just syntactic sugar for <code>transmute</code> on each access</p>\n</blockquote>\n<p>Ah, that is good to know. I was working under the assumption that the typing condition for a union is the disjunction of the members. So this implies that unions have no validity invariant then, they are just a \"bag of bytes\"? (Edit: I guess you just said as much.)</p>\n</blockquote>\n<p>FWIW, even if the validity of union would be the disjunction of the field validity (which is definitely too weak, and the <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">relevant UCG issue</a> has counterexamples for that), that would not imply that there'd an \"active variant\" in the operational semantics. for example, if the current bit pattern is valid for multiple of the fields, an \"active variant\" still remembers which field the data \"really belongs to\"; Rust has nothing like that.</p>",
        "id": 215952201,
        "sender_full_name": "RalfJ",
        "timestamp": 1604750991
    },
    {
        "content": "<p>\"no active variant\" does not imply \"bag of bytes\" (but the other way around holds)</p>",
        "id": 215952249,
        "sender_full_name": "RalfJ",
        "timestamp": 1604751021
    },
    {
        "content": "<p>Well yes, of course there are other possible invariants one could assert, and in the UCG issue a few are proposed, but they are all more complicated than the \"obvious\" one. In that issue, it seems you set the stage in the first post by requiring that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">union</span> <span class=\"nc\">Mix</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f1</span>: <span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">f2</span>: <span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Mix</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f1</span>: <span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">f2</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>be valid code, but this was never challenged. Can I ask why you think this is a good idea? To me, this seems analogous to having an uninitialized field <code>m.f2.1</code>, and such a value should not be allowed to escape; i.e. it is not actually valid for the type and a reachability analysis ensures that it isn't used before the field is assigned.</p>",
        "id": 215962399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604766680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 215962411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604766703
    },
    {
        "content": "<p>(Also, FWIW while I am in favor of the disjunction formulation, I don't think that we should have an \"active variant\" in the sense of C, that is, a ghost discriminant value. <code>union{f:u8, g:u8}</code> should be equivalent to <code>u8</code>.)</p>",
        "id": 215962550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604766869
    },
    {
        "content": "<p>FWIW, I did not come up with this example, it was given in an earlier RFC about unions (I forgot which one...)</p>",
        "id": 215962789,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767236
    },
    {
        "content": "<p>I think the question ought to be \"why should this be disallowed\" -- the entire point of unions is to be convenient syntactic sugar for transmutes (IMO), and unions with tuple fields should permit \"per-field transmutes\".</p>",
        "id": 215962813,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767304
    },
    {
        "content": "<p>any little bit of UB we add here will mean additional footguns for unsafe code that is already error-prone (since it uses unions)</p>",
        "id": 215962949,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767453
    },
    {
        "content": "<p>the disjunction formulation is also awfully non-constructive -- when dynamically checking if a value is valid for a type, it would have to attempt each variant in sequence</p>",
        "id": 215962974,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767506
    },
    {
        "content": "<p>and things get even worse when considering that the validity invariant is really just a projection of the representation relation, as <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">I sketched here</a>: if we take the unions of the representation relations of the fields, I am pretty sure that will be utter nonsense (I can come up with an example later)</p>",
        "id": 215963046,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767571
    },
    {
        "content": "<p>I think you are probably right that this is untenable, in particular dynamic checking. I just want to program directly in separation logic ^_^</p>",
        "id": 215963145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604767701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/215963145\">said</a>:</p>\n<blockquote>\n<p>I think you are probably right that this is untenable, in particular dynamic checking. I just want to program directly in separation logic ^_^</p>\n</blockquote>\n<p>you mean like this thing some of my colleagues have been working on? :D<br>\n<a href=\"https://plv.mpi-sws.org/refinedc/paper.pdf\">https://plv.mpi-sws.org/refinedc/paper.pdf</a></p>",
        "id": 215963342,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767948
    },
    {
        "content": "<p>I hope we'll have that for Rust one day^^</p>",
        "id": 215963350,
        "sender_full_name": "RalfJ",
        "timestamp": 1604767956
    },
    {
        "content": "<p>oh, I've been scooped</p>",
        "id": 215964925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604770112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327642\">@Joshua Chartier</span> sorry for the long silence. I finally looked at your diagram in detail. This is great, thank you so much for drawing it!<br>\nI think that the key property you need is something like \"location-independence\" of shared data. You basically want do move data, which is trivial to do with owned data, but not with shared data as there can be aliases.<br>\nMutability is indeed breaking location-independence, because mutation is a way to \"test ptr equality\": write through one pointer, see if what you read through the other pointer changed.<br>\nBut it is not the only location-independence-breaking operation -- I could imagine a type that takes its address and then relies on staying at that address. Given that everything owned is movable in Rust, this is tricky to arrange, but not impossible. For once, I could use pinning. However, container types can control if they support containing pinned data (by default they do not, \"pinning projections\" are needed to support them), so I think this is not a problem.</p>",
        "id": 218172689,
        "sender_full_name": "RalfJ",
        "timestamp": 1606584000
    },
    {
        "content": "<p>But I could imagine more obscure patterns along the lines of <a href=\"https://github.com/rust-lang/rust/issues/49206#issuecomment-376002169\">this</a>. I can try to come up with something a bit more tangible if that helps.</p>",
        "id": 218172751,
        "sender_full_name": "RalfJ",
        "timestamp": 1606584070
    },
    {
        "content": "<p>FWIW, the formal model of shared references that we used in LambdaRust does not guarantee location-independence of any kind. We needed this primarily for interior mutability, but made no attempt to guarantee location-independence of non-interior-mutable types. In other words, this is a property that is independent of the rest of the Rust type system -- the lang team at some point has to make a call either way, which will rule out one piece of code or another.</p>",
        "id": 218173015,
        "sender_full_name": "RalfJ",
        "timestamp": 1606584580
    },
    {
        "content": "<p>The kind of type I am worried about is something like <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f244d2756a23122f5da5968d388daf0e\">this weird <code>Singleton</code> type</a>. If I understand your diagram correctly, then you might move <code>Singleton</code> while it is in use by another thread.<br>\nUsually, this type offers the guarantee that between two <code>observe</code> calls with the same id, all other calls that might occur will have the same <code>x</code>. But with your type, that guarantee cases to hold. So in some fundamental way your type is letting safe code do something that it otherwise couldn't.</p>",
        "id": 218307674,
        "sender_full_name": "RalfJ",
        "timestamp": 1606752743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> First off, thank you for your time on this and I like the location-independence nomenclature! Perhaps my diagram was little misleading... It's more like splitting the move into a new copy that takes over drop responsibilities and a delayed deallocation. For the Singleton case, x would still have the same value because within the borrow the data referenced is in the same location; it's just that  another thread may have moved on to the new copy. I do reference count just to make sure I don't drop the old allocation until all the borrows are completed, but I'm not technically moving anything in a shared borrow. That said, the location independence is still a vital characteristic of this setup. If you had an child struct keeping track of its parent's location, and the parent was in my ArcLog, that would be a problem. But my assumption is that this already a problem generally in Rust given that moves are allowed and there are no hooks that allows someone to keep track of when a struct is moved. If those hooks did existed, it seems reasonable for that child to expect there to be only one copy of the given parent and that after a move the child should no longer expect calls from the old location. My code could/would break that expectation.</p>",
        "id": 218382740,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1606801138
    },
    {
        "content": "<p>If I understood correctly, with your code, it can be the case that a shared object finds itself at another location without the sharing ever stopping -- is that accurate? If so, I would describe this as \"moving data behind a shared reference\".<br>\nThis is observably different from ending the sharing, moving the object, and then starting sharing again. The latter is of course universally possible for all types in safe code. But doing the move <em>without ending the sharing</em>, like I think you are, is not usually possible.</p>",
        "id": 218402004,
        "sender_full_name": "RalfJ",
        "timestamp": 1606817684
    },
    {
        "content": "<blockquote>\n<p>It's more like splitting the move into a new copy that takes over drop responsibilities and a delayed deallocation.</p>\n</blockquote>\n<p>I could agree with this if it was the case that there definitely was no access to the copy of the object whose deallocation is shared. But if I understood correctly, this is all concurrent, and other threads can still read from the old copy even after the new copy was created?</p>",
        "id": 218402173,
        "sender_full_name": "RalfJ",
        "timestamp": 1606817806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Freeze.20stabilization.20and.20auto-trait.20backcompat/near/218402004\">said</a>:</p>\n<blockquote>\n<p>If I understood correctly, with your code, it can be the case that a shared object finds itself at another location without the sharing ever stopping -- is that accurate?</p>\n</blockquote>\n<p>I guess it depends on what you consider the object. Let's take a Box&lt;T: Sync&gt; as an example. A Box consists of a pointer and a heap allocated T. When the capacity of ArcLog&lt;Box&lt;T&gt;&gt; is reached, I create a shallow copy of all the Box pointers using core::ptr::copy_nonoverlapping. So each T will now have two pointers pointing toward it and both can/do have shared borrows. This a violation of the Box unique ownership invariant, but I'm arguing that since I don't give out any kind of mutable access, and I eventually restore that invariant, it's a benign violation. From the perspective of existing borrower, nothing has changed as they shouldn't care about my copying of their pointer. Likewise, new borrows shouldn't care about the existence of the old pointer either. Once the old borrows are complete (all the existing ArcLogs have moved to the new allocation of pointers), I deallocate the old set of pointers (without dropping the Ts) and we're back to Box having one unique pointer. And when the last ArcLog is dropped, I also drop all of the Boxes. So the question is, is my violation of the uniqueness of the Box pointer and multiple immutable access to it's underlying T actually ok? I think it's pretty clear I can't just copy_nonoverlapping something mutable (like a Mutex) and expect it'll end up in a valid state, but beyond that, is the compiler making assumptions about uniqueness that makes having this kind of temporary split ownership problematic?</p>",
        "id": 218478581,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1606855377
    },
    {
        "content": "<blockquote>\n<p>This a violation of the Box unique ownership invariant, but I'm arguing that since I don't give out any kind of mutable access, and I eventually restore that invariant, it's a benign violation.</p>\n</blockquote>\n<p>It is unclear if there is such a thing as a benign violation, see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/258\">https://github.com/rust-lang/unsafe-code-guidelines/issues/258</a>.</p>\n<p>But that is not even my point. For <code>Box</code>, if we ignore aliasing rules, what you are saying makes sense. But I am asking you to consider the case of a general type <code>T</code> that you know nothing about.</p>\n<blockquote>\n<p>is the compiler making assumptions about uniqueness that makes having this kind of temporary split ownership problematic?</p>\n</blockquote>\n<p>Possibly, but that is besides the point. <em>Other code</em> may make assumptions that make having this kind of temporary split problematic. When someone then combines that other code with your code, we have UB. Now one could argue that it's the other code that is wrong, not your code, but that is an arbitrary choice -- nothing in Rust as it exists today says either way.</p>",
        "id": 218492163,
        "sender_full_name": "RalfJ",
        "timestamp": 1606862179
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 218492199,
        "sender_full_name": "RalfJ",
        "timestamp": 1606862215
    },
    {
        "content": "<p>you have to find an argument that shows that <em>all types are location-independent when shared</em>. and I think this is just not true, there is no such rule in Rust. I <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f244d2756a23122f5da5968d388daf0e\">gave a counterexample</a>. We could <em>make</em> it a rule but that would be a fundamental change to the language, similar to how we made the rule that destructors need not be called. (And it would technically be a breaking change: now in principle all existing unsafe code needs to be audited to check that it is location-independent.)</p>\n<p>This is just like Leakpocalypse: the presence of <code>Rc</code> and <code>Arc</code> (and <code>mem::forget</code>) made the old scoped thread API wrong, because that API relied on a guarantee that destructors need to run. Likewise, you are relying on a guarantee of location-independence. In both cases it is possible for unsafe code to violate that guarantee <em>without breaking any preexisting rule</em>.. Either API works in isolation, but putting them together yields an inconsistent system.</p>",
        "id": 218492256,
        "sender_full_name": "RalfJ",
        "timestamp": 1606862269
    },
    {
        "content": "<p>I get where you're going with the counterexample, but I think it represents my miscommunication on how the borrowing works in my setup. Any ArcLog::method(&amp;self,...) (getting a slice) will only see one location within a call. In order to update to a new allocation you have to use ArcLog::method(&amp;mut self, ...) (push or update) so we do have guarantee that any particular instance of ArcLog will only be able to see one location at a time. Regaining exclusivity before moving to the new allocation is also a requirement for me to do proper reference counting of the borrows of the underlying. So I shouldn't be violating location-independence in a single borrow. But, thinking about interactions, if someone did something like creating a shortcut for equality that just compared locations, that would definitely produce unexpected results and seems like a reasonable thing to do. So yeah, location-independence is definitely something else that would be required. Good call. I really appreciate you helping me think this through!</p>",
        "id": 218514339,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1606883460
    },
    {
        "content": "<blockquote>\n<p>Any ArcLog::method(&amp;self,...) (getting a slice) will only see one location within a call. In order to update to a new allocation you have to use ArcLog::method(&amp;mut self, ...) (push or update) so we do have guarantee that any particular instance of ArcLog will only be able to see one location at a time</p>\n</blockquote>\n<p>Can't I just clone the ArcLog to get an <code>&amp;mut</code> without duplicating the underlying data?</p>",
        "id": 218532828,
        "sender_full_name": "RalfJ",
        "timestamp": 1606901618
    },
    {
        "content": "<p>with <code>Arc</code>, <code>&amp;mut self</code> is mostly meaningless (except for very special cases such as <code>Arc::get_mut</code>). Why is this different here?</p>",
        "id": 218533178,
        "sender_full_name": "RalfJ",
        "timestamp": 1606901801
    },
    {
        "content": "<p>Maybe I misunderstood the API, but I thought I could do something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ref1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ArcLoc</span>::<span class=\"n\">with_capacity</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ref2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ref1</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">ref1</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Singleton</span>::<span class=\"n\">new</span><span class=\"p\">()));</span><span class=\"w\"> </span><span class=\"c1\">// using my singleton type from before.</span>\n<span class=\"n\">rayon</span>::<span class=\"n\">join</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">ref1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">as_ref</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">observe</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"c1\">// observes the shared singleton at the old location</span>\n<span class=\"w\">  </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ref2</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// creates a copy of the inner data</span>\n<span class=\"w\">    </span><span class=\"n\">ref2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">as_ref</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">observe</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"c1\">// observes the shared singleton at the new location</span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This could could end up observing the shared singleton at two different locations at the same time, which would be impossible without ArcLog (and hence, which code might <em>in principle</em> rely on never happening).</p>",
        "id": 218533552,
        "sender_full_name": "RalfJ",
        "timestamp": 1606902033
    },
    {
        "content": "<p>Yes. That's true. I definitely break the Singleton promise. If you care about the actual value as an identifier, Arc&lt;Mutex&lt;Vec&lt;Singleton&gt;&gt;&gt;&gt; will also change the value (thread one could be with either the old location or the new location), but it does so at a definite point and thus it still preserves the singleton-ness. ArcLog allows both locations to coexist, so it's a singleton no more! Great example. So now I need Freeze+NonSingleton+LocationIndependent+...+... Ha, bummer. But super interesting. Thank you. As an aside, I really like how traits can be used to document/enforce assumptions/properties in Rust. I hope that a good backward compatibility story emerges for auto-traits because the more extensive the properties you have for your code, the more the compiler can help you progress and explore in a safe and productive way. Rust is already on a great track for this, but I feel like there's an opportunity to do much, much more!</p>",
        "id": 218593103,
        "sender_full_name": "Joshua Chartier",
        "timestamp": 1606931166
    },
    {
        "content": "<blockquote>\n<p>I definitely break the Singleton promise. If you care about the actual value as an identifier, Arc&lt;Mutex&lt;Vec&lt;Singleton&gt;&gt;&gt;&gt; will also change the value (thread one could be with either the old location or the new location), but it does so at a definite point and thus it still preserves the singleton-ness. ArcLog allows both locations to coexist, so it's a singleton no more! </p>\n</blockquote>\n<p>Okay, we agree on this then. :)</p>",
        "id": 218599045,
        "sender_full_name": "RalfJ",
        "timestamp": 1606933751
    },
    {
        "content": "<blockquote>\n<p>NonSingleton+LocationIndependent</p>\n</blockquote>\n<p>FWIW I'd munge those together -- the <code>Singleton</code> type would simply not be <code>LocationIndependent</code>, since it clearly cares about its location.</p>",
        "id": 218599152,
        "sender_full_name": "RalfJ",
        "timestamp": 1606933799
    },
    {
        "content": "<blockquote>\n<p>So now I need</p>\n</blockquote>\n<p>There is an alternative: if you had a promise from the lang team that <code>Freeze</code> <em>implies location-independence</em>, then a data structure like yours can be made to work, I think. I have no idea if this is realistic, but I expect <code>!LocationIndependent</code> to be exceedingly rare. Furthermore, <em>maybe</em> this could be used to fix <a href=\"https://github.com/rust-lang/rust/issues/49206\">https://github.com/rust-lang/rust/issues/49206</a> \"by fiat\".</p>",
        "id": 218599503,
        "sender_full_name": "RalfJ",
        "timestamp": 1606933932
    },
    {
        "content": "<p>(completely unrelated and off topic, but every time I hear \"by fiat\" it makes me think of <a href=\"https://en.wikipedia.org/wiki/A_Canticle_for_Leibowitz\">https://en.wikipedia.org/wiki/A_Canticle_for_Leibowitz</a>)</p>",
        "id": 218601813,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1606934987
    }
]