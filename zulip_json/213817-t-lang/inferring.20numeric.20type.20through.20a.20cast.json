[
    {
        "content": "<p>There seems to be an interesting edge case around numeric types and casts:</p>\n<div class=\"codehilite\"><pre><span></span><code>    // let nope = &amp;[0; 4] as &amp;[u8];\n    let a = &amp;[0: u8; 4] as &amp;[u8];\n    let b = &amp;[true; 4] as &amp;[bool];\n</code></pre></div>\n<p>In the first statement, the zero is inferred to be an isize (default integer type) and the cast fails. I'd hope the u8 could flow through the cast and we could make it type check. Anyone think it is possible/impossible? (Note, that the unsizing is irrelevant, it's just the motivation for doing the cast in the first place, <code>[0; 4] as [u8; 4]</code> also fails).</p>",
        "id": 274561954,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646755558
    },
    {
        "content": "<p>Wait, it's inferred to be isize? The default integer type is actually i32. Either way it would be great to make this work.</p>",
        "id": 274577066,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646761446
    },
    {
        "content": "<p>Sorry, typo, i32</p>",
        "id": 274578248,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646761953
    },
    {
        "content": "<p>casts currently happen after inference, and the code is pretty specific to make that the case, though I don't know why</p>",
        "id": 274579279,
        "sender_full_name": "simulacrum",
        "timestamp": 1646762370
    },
    {
        "content": "<p>(at least unsizing casts, not sure if that's true in all cases).</p>",
        "id": 274579311,
        "sender_full_name": "simulacrum",
        "timestamp": 1646762384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/213817-t-lang/topic/inferring.20numeric.20type.20through.20a.20cast/near/274561954\">said</a>:</p>\n<blockquote>\n<p>Anyone think it is possible/impossible? (Note, that the unsizing is irrelevant, it's just the motivation for doing the cast in the first place, <code>[0; 4] as [u8; 4]</code> also fails).</p>\n</blockquote>\n<p>I think this is essentially the same as the \"type inference defaults/fallback\" wish that people want in a bunch of places.  I don't know how hard that'll be.  In general, all the fallback/coercion stuff is just hardâ„¢.  Seems like a place I just say \"chalk?\" and point to <span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span>'s new team: <a href=\"#narrow/stream/144729-wg-traits/topic/making.20a.20team.20for.20traits.2C.20polonius.2C.20etc/near/273563728\">https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/making.20a.20team.20for.20traits.2C.20polonius.2C.20etc/near/273563728</a></p>\n<p>The one core complication I know about is that something like <code>Box::new(e) as Box&lt;dyn Error&gt;</code> is sometimes really important that it <em>not</em> flow that type into the first expression.  That was particularly the case if <code>e</code> is a type variable, IIRC -- there was something like this that blocked never type stabilization once upon a time.</p>",
        "id": 274587819,
        "sender_full_name": "scottmcm",
        "timestamp": 1646765596
    }
]