[
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> , I wanted to check in with you about some discussion related to Rust PR <a href=\"https://github.com/rust-lang/rust/issues/58611\">#58611</a></p>",
        "id": 214992291,
        "sender_full_name": "pnkfelix",
        "timestamp": 1603988887
    },
    {
        "content": "<p>You said said in closing that PR that the team wanted to first do some exploration to figure out <em>which</em> solution they would adopt</p>",
        "id": 214992353,
        "sender_full_name": "pnkfelix",
        "timestamp": 1603988913
    },
    {
        "content": "<p>I wanted to first see if the wg-ucg <strong>is</strong> the group doing that investigation, or if you meant it to be the job of T-compiler (or T-libs, etc...)</p>",
        "id": 214992440,
        "sender_full_name": "pnkfelix",
        "timestamp": 1603988950
    },
    {
        "content": "<p>I think it is mostly a T-lang job. The current status is:</p>\n<ul>\n<li>there <a href=\"https://paper.dropbox.com/doc/Lang-Team-Design-Meeting-and-Deferenceable--AvT5LmzDfgLQRDF8YyG0utbmAg-enTyRslkuAcNPgqWsN4UU\">was a T-lang discussion </a> mapping out some of the design space but without a conclusion</li>\n<li>since then, there was an <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">interesting proposal</a> that looks like it would fix the problem for <code>Arc</code> from a Stacked Borrows perspective, but it would not fix the other issues around the <code>dereferencable</code> attribute and it would likely not result in us being able to communicate anything more than \"dereferencable on function entry\" to LLVM.</li>\n</ul>",
        "id": 215018675,
        "sender_full_name": "RalfJ",
        "timestamp": 1604000978
    },
    {
        "content": "<p>also see <a href=\"https://github.com/rust-lang/rust/issues/55005#issuecomment-608566917\">this GH thread</a></p>",
        "id": 215018797,
        "sender_full_name": "RalfJ",
        "timestamp": 1604001032
    },
    {
        "content": "<p>I am trying to figure out if we should <em>still</em> have the <code>*const AtomicT</code> methods anyway</p>",
        "id": 215093138,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064113
    },
    {
        "content": "<p>because there may be scenarios where people want to do these \"final decrements\" of ref-counts</p>",
        "id": 215093211,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064136
    },
    {
        "content": "<p>on their own data types</p>",
        "id": 215093214,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064140
    },
    {
        "content": "<p>I suppose part of my problem is that I do not understand the <code>&amp;unsafe</code> proposal</p>",
        "id": 215093421,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064245
    },
    {
        "content": "<p>and so I have not yet understood why we would delay adding the atomic methods in anticipation of an <code>&amp;unsafe</code> option</p>",
        "id": 215093474,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064275
    },
    {
        "content": "<p>On a related note: Would working around the absence of *Atomic-based methods by taking a <code>input: *const Atomic</code> and then doing <code>&amp;*input</code> to turn it into a <code>&amp;Atomic</code> for the purposes of the (final) method invocation be fundamentally wrong? that is, would the lifetime of the reference in <em>that</em> case still be too long as to cause instant UB?</p>",
        "id": 215093727,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064430
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ^</p>",
        "id": 215093847,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064492
    },
    {
        "content": "<p>(also, I guess I should move this up to the #t-lang stream, based on ralf's feedback above...)</p>",
        "id": 215093893,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604064529
    },
    {
        "content": "<p>This topic was moved here from #<strong>t-lang/wg-unsafe-code-guidelines&gt;Whither *Atomic API duplication</strong> by <span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span></p>",
        "id": 215095681,
        "sender_full_name": "Notification Bot",
        "timestamp": 1604065453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215093727\">said</a>:</p>\n<blockquote>\n<p>On a related note: Would working around the absence of *Atomic-based methods by taking a <code>input: *const Atomic</code> and then doing <code>&amp;*input</code> to turn it into a <code>&amp;Atomic</code> for the purposes of the (final) method invocation be fundamentally wrong? that is, would the lifetime of the reference in <em>that</em> case still be too long as to cause instant UB?</p>\n</blockquote>\n<p>I guess it would still be fundamentally wrong.</p>",
        "id": 215097771,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604066444
    },
    {
        "content": "<p>(now that I've reflected more on the fact that you'd still have that call on a <code>&amp;self</code> there, with the potentially for a concurrent method to actually do the subsequent free.)</p>",
        "id": 215097861,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604066482
    },
    {
        "content": "<p>Just had phone conversation with niko. Outcome: We think adding either free functions or methods on <code>*const Atomic</code> makes sense, because there is a real-world (lack of) expressiveness bug today. The reasoning that led us there was involved enough that it also probably make sense to put together an RFC for this.</p>",
        "id": 215111096,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072232
    },
    {
        "content": "<p>(and I plan to draft an RFC soon)</p>",
        "id": 215111131,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072253
    },
    {
        "content": "<p>hm it does feel really unfortunate to (eventually?) stabilize basically 2x the API surface here</p>",
        "id": 215111263,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072309
    },
    {
        "content": "<p>It seems really unfortunate to have to teach users which one to use</p>",
        "id": 215111392,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072367
    },
    {
        "content": "<p>I don't think you can avoid that, though</p>",
        "id": 215111414,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072384
    },
    {
        "content": "<p>without giving up optimization opportunities</p>",
        "id": 215111427,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072392
    },
    {
        "content": "<p>because either you change the rules everywhere (which gives up optimization opportunities)</p>",
        "id": 215111525,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072418
    },
    {
        "content": "<p>I guess my point is that I am really skeptical about optimization around here, personally</p>",
        "id": 215111527,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072419
    },
    {
        "content": "<p>like I can't see LLVM doing anything different for these methods, given you're pretty much guaranteed to be calling them on a &amp;Atomic anyway, right?</p>",
        "id": 215111591,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072459
    },
    {
        "content": "<p>no, I don't think so</p>",
        "id": 215111679,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072500
    },
    {
        "content": "<p>As in, the <code>&amp;Atomic</code> should be dead by the time you call the method on the <code>*const Atomic</code></p>",
        "id": 215111709,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072516
    },
    {
        "content": "<p>Why would it change to <code>&amp;Atomic</code> internally? the ultimate implementations just operate on <code>*mut T</code> after digging the <code>UnsafeCell</code> -- but I guess we may want a pointer version of <code>UnsafeCell::get</code> (edit: there is <code>raw_get</code>)</p>",
        "id": 215111711,
        "sender_full_name": "cuviper",
        "timestamp": 1604072516
    },
    {
        "content": "<p>How do you get the *const Atomic then? raw-ref on fields?</p>",
        "id": 215111764,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072525
    },
    {
        "content": "<p>Well, for my use-case of <code>Arc</code></p>",
        "id": 215111798,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072541
    },
    {
        "content": "<p>you get the <code>&amp;Atomic</code> early on</p>",
        "id": 215111817,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072552
    },
    {
        "content": "<p>cast it</p>",
        "id": 215111829,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072556
    },
    {
        "content": "<p>then it dies</p>",
        "id": 215111835,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072559
    },
    {
        "content": "<p>while you still hold on to the <code>*const Atomic</code></p>",
        "id": 215111856,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072569
    },
    {
        "content": "<p>Having said that, I would be happy to recommend people use <code>raw-ref</code> or whatever (<code>&amp;raw</code>? )</p>",
        "id": 215111896,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072588
    },
    {
        "content": "<p>I guess it is unclear to me on this \"then it dies\" actually working</p>",
        "id": 215111926,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072600
    },
    {
        "content": "<p>(I guess it must, since otherwise you would never be able to deallocate memory)</p>",
        "id": 215111970,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072620
    },
    {
        "content": "<p>right</p>",
        "id": 215111977,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072624
    },
    {
        "content": "<p>I want to give people the option to actually say the right thing</p>",
        "id": 215112017,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072641
    },
    {
        "content": "<p>right now, they cannot express it</p>",
        "id": 215112056,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072644
    },
    {
        "content": "<p>I am uncertain how much the additional dereferenceable attribute buys us here</p>",
        "id": 215112125,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072682
    },
    {
        "content": "<p>I do not like the perspective of focusing on LLVM optimizations for the decision here</p>",
        "id": 215112234,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072729
    },
    {
        "content": "<p>I prefer to ask: What is the language's semantic model</p>",
        "id": 215112253,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072741
    },
    {
        "content": "<p>and the only semantic model that would allow this</p>",
        "id": 215112276,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072757
    },
    {
        "content": "<p>is one that says <code>x: &amp;T</code> can actually be deallocated</p>",
        "id": 215112327,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072768
    },
    {
        "content": "<p>(that is, a <code>x: &amp;T</code> parameter to a function)</p>",
        "id": 215112357,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072785
    },
    {
        "content": "<p>can be deallocated sometime during the function's execution</p>",
        "id": 215112378,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072796
    },
    {
        "content": "<p>Yeah. I guess it seems unfortunate that if we stabilize the *const API, we'll likely end up with 3 in the end: *const Atomic, &amp;Atomic, and &amp;unsafe Atomic</p>",
        "id": 215112389,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072805
    },
    {
        "content": "<p>I do not yet understand the <code>&amp;unsafe</code> proposal</p>",
        "id": 215112434,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072831
    },
    {
        "content": "<p>niko outlined the intent to me</p>",
        "id": 215112455,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072838
    },
    {
        "content": "<p>sure, it's not well defined</p>",
        "id": 215112463,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072840
    },
    {
        "content": "<p>but I think it is bad to be sitting in a situation where there is real world code that is trying to make their own Arc's or whatever</p>",
        "id": 215112535,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072874
    },
    {
        "content": "<p>and they literally cannot write something correct</p>",
        "id": 215112643,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072907
    },
    {
        "content": "<p>sure, I agree with that</p>",
        "id": 215112681,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072921
    },
    {
        "content": "<p>Also maybe API duplication is not the right way to look at this</p>",
        "id": 215112765,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072954
    },
    {
        "content": "<p>It just feels really awkward to have *const taking methods whose safety comment is basically \"this must be a reference\"</p>",
        "id": 215112797,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072971
    },
    {
        "content": "<p>?</p>",
        "id": 215112822,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072978
    },
    {
        "content": "<p>is that the safety comment?</p>",
        "id": 215112844,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072988
    },
    {
        "content": "<p>/me thinks</p>",
        "id": 215112851,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604072992
    },
    {
        "content": "<p>What else is it?</p>",
        "id": 215112854,
        "sender_full_name": "simulacrum",
        "timestamp": 1604072994
    },
    {
        "content": "<p>I think the point is that it needs to be something weaker</p>",
        "id": 215112960,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073028
    },
    {
        "content": "<p>Not on entry</p>",
        "id": 215113009,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073054
    },
    {
        "content": "<p>that allows for the concurrent deallocation after the side-effect happens</p>",
        "id": 215113010,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073055
    },
    {
        "content": "<p>right</p>",
        "id": 215113019,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073059
    },
    {
        "content": "<p>this must be a reference on method entry</p>",
        "id": 215113034,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073067
    },
    {
        "content": "<p>that <em>is</em> weaker</p>",
        "id": 215113050,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073073
    },
    {
        "content": "<p>hm, I suppose so</p>",
        "id": 215113078,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073084
    },
    {
        "content": "<p>(unless one takes the attitude that all <code>x: &amp;T</code> parameters could be written with that safety condition instead.)</p>",
        "id": 215113107,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073099
    },
    {
        "content": "<p>(but I don't have that perspective)</p>",
        "id": 215113120,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073106
    },
    {
        "content": "<p>ok, I'm convinced that there is sufficient difference in some sense</p>",
        "id": 215113254,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073161
    },
    {
        "content": "<p>niko and I were debating about whether free functions or methods would be best here</p>",
        "id": 215113668,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073317
    },
    {
        "content": "<p>I'm probably going to see if I can get an <code>impl *const AtomicFoo { fn raw_action(self, ...) { ... } ... }</code> going</p>",
        "id": 215113768,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073358
    },
    {
        "content": "<p>(in <code>core</code>)</p>",
        "id": 215113803,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073364
    },
    {
        "content": "<p>but this point about confusion about which to use</p>",
        "id": 215113849,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073374
    },
    {
        "content": "<p>I think you want <code>impl AtomicFoo { fn raw_action(*const Self, ...) {} }</code></p>",
        "id": 215113863,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073380
    },
    {
        "content": "<p>makes me wonder if free functions <em>are</em> better here</p>",
        "id": 215113865,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073381
    },
    {
        "content": "<p>right, but we do not support <code>*const Self</code> today, no?</p>",
        "id": 215113891,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073393
    },
    {
        "content": "<p>I think we do</p>",
        "id": 215113901,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073396
    },
    {
        "content": "<p>Okay I'll have to look.</p>",
        "id": 215113920,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073403
    },
    {
        "content": "<p>in any case</p>",
        "id": 215113956,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073415
    },
    {
        "content": "<p>the scenario where you want to use the <code>*const</code> variants</p>",
        "id": 215113985,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073427
    },
    {
        "content": "<p>does seem so niche</p>",
        "id": 215113995,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073430
    },
    {
        "content": "<p>ah well not stable</p>",
        "id": 215114003,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073432
    },
    {
        "content": "<p>(and one where one must think very carefully)</p>",
        "id": 215114018,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073439
    },
    {
        "content": "<p>I wonder if <a href=\"https://en.cppreference.com/w/cpp/atomic/atomic_ref\">https://en.cppreference.com/w/cpp/atomic/atomic_ref</a> is sort of relevant here</p>",
        "id": 215114035,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073449
    },
    {
        "content": "<p>that I would be able to justify being forced to use free functions...</p>",
        "id": 215114068,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073461
    },
    {
        "content": "<p>/me looks</p>",
        "id": 215114090,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073469
    },
    {
        "content": "<p>I think no, because with these you could just cast the pointer</p>",
        "id": 215114106,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073476
    },
    {
        "content": "<p>though I admit I don't fully grok why atomic_ref needed to exist in C++ either</p>",
        "id": 215114204,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215114106\">said</a>:</p>\n<blockquote>\n<p>I think no, because with these you could just cast the pointer</p>\n</blockquote>\n<p>sorry, what do you mean?</p>",
        "id": 215114244,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073521
    },
    {
        "content": "<p>cast what to what?</p>",
        "id": 215114301,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073543
    },
    {
        "content": "<p>i.e., if you want to temporarily have an atomic you can \"just\" <code>&amp;u32 as *const u32 as *const AtomicU32</code></p>",
        "id": 215114312,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073548
    },
    {
        "content": "<p>and then call these hypothetical methods</p>",
        "id": 215114324,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073555
    },
    {
        "content": "<p>but that's my point</p>",
        "id": 215114327,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073557
    },
    {
        "content": "<p>I think that's an antipattern</p>",
        "id": 215114342,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073565
    },
    {
        "content": "<p>the cases where you are calling <code>*const</code> <del>methods</del> variants</p>",
        "id": 215114356,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073573
    },
    {
        "content": "<p>are ones where you explicitly do not want the <code>&amp;OriginalType</code> hanging around</p>",
        "id": 215114408,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073599
    },
    {
        "content": "<p>correct, yes</p>",
        "id": 215114512,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073619
    },
    {
        "content": "<p>though I guess the expression you wrote</p>",
        "id": 215114548,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073633
    },
    {
        "content": "<p>...</p>",
        "id": 215114559,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073634
    },
    {
        "content": "<p>/me thinkis</p>",
        "id": 215114564,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073636
    },
    {
        "content": "<p>it might need to be like <code>raw_ref!(foo: u32)</code></p>",
        "id": 215114611,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073656
    },
    {
        "content": "<p>I'm trying to remember whether the <code>&amp;u32</code> will live for the entirety of the expression there or not</p>",
        "id": 215114625,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073662
    },
    {
        "content": "<p>yeah, it could well be that we should recommend the use of <code>raw_ref!</code> in these scenarios</p>",
        "id": 215114675,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073682
    },
    {
        "content": "<p>and in any case</p>",
        "id": 215114708,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073696
    },
    {
        "content": "<p>once you're doing that</p>",
        "id": 215114721,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073700
    },
    {
        "content": "<p>is it really so bad to be calling a free function?</p>",
        "id": 215114739,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073708
    },
    {
        "content": "<p>In other words, do you really want to be trying to optimize the ergonomics of calling these methods?</p>",
        "id": 215114858,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073740
    },
    {
        "content": "<p>when its something where the ordering is often so important</p>",
        "id": 215114908,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073758
    },
    {
        "content": "<p>I think it's just awkward to have them as free functions</p>",
        "id": 215114920,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073764
    },
    {
        "content": "<p>that it might always deserve its own statement?</p>",
        "id": 215114925,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073767
    },
    {
        "content": "<p>since you need them at some type anyway, right?</p>",
        "id": 215114936,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073773
    },
    {
        "content": "<p>so you'd end up with <code>core::atomic::u32::sub</code></p>",
        "id": 215114969,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073788
    },
    {
        "content": "<p>Ah, okay</p>",
        "id": 215114987,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073794
    },
    {
        "content": "<p>or, I guess, fetch_sub, w/e</p>",
        "id": 215114993,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073796
    },
    {
        "content": "<p>that does seem annoying</p>",
        "id": 215115010,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073803
    },
    {
        "content": "<p>presumably one could abstract it with a trait</p>",
        "id": 215115047,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073820
    },
    {
        "content": "<p><code>raw_fetch_sub&lt;T: AtomicType&gt;(arg: *const T, delta: T) -&gt; T</code></p>",
        "id": 215115123,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073845
    },
    {
        "content": "<p>right?</p>",
        "id": 215115139,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073847
    },
    {
        "content": "<p>but of course the implementation then ends up relying on methods anyway</p>",
        "id": 215115235,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073901
    },
    {
        "content": "<p>and we don't have T: AtomicType today</p>",
        "id": 215115247,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073912
    },
    {
        "content": "<p>right, we'd have to add it</p>",
        "id": 215115255,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073917
    },
    {
        "content": "<p>so it would be a lot of machinery</p>",
        "id": 215115262,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073923
    },
    {
        "content": "<p>(though perhaps we should, certainly it would be useful)</p>",
        "id": 215115265,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073924
    },
    {
        "content": "<p>Would it?</p>",
        "id": 215115285,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073932
    },
    {
        "content": "<p>maybe</p>",
        "id": 215115287,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073934
    },
    {
        "content": "<p>Presuming an eventual expansion to T: AtomicType for e.g. <code>enum Bar { Yes, No }</code></p>",
        "id": 215115330,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073958
    },
    {
        "content": "<p>anyway, I'm willing to believe that methods are a better choice here based on this argument</p>",
        "id": 215115339,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073962
    },
    {
        "content": "<p>oh interesting</p>",
        "id": 215115408,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073980
    },
    {
        "content": "<p>perhaps with a <code>#[repr(atomic)]</code> or some such?</p>",
        "id": 215115421,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604073988
    },
    {
        "content": "<p>(this is what C++ gives you, btw)</p>",
        "id": 215115422,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073988
    },
    {
        "content": "<p>repr(u8) or so maybe</p>",
        "id": 215115443,
        "sender_full_name": "simulacrum",
        "timestamp": 1604073998
    },
    {
        "content": "<p>sure, <code>#[repr(atomic, u8)]</code></p>",
        "id": 215115465,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074014
    },
    {
        "content": "<p>or maybe your point is that types shouldn't have to opt-in</p>",
        "id": 215115495,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074029
    },
    {
        "content": "<p>(which... I'm ... well, I'm not sure where I fall on that question)</p>",
        "id": 215115524,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074046
    },
    {
        "content": "<p>yeah I don't either :)</p>",
        "id": 215115533,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074051
    },
    {
        "content": "<p>anyway, that's more of an aside</p>",
        "id": 215115540,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074054
    },
    {
        "content": "<p>yeah</p>",
        "id": 215115554,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074058
    },
    {
        "content": "<p>I think if we did end up with T: AtomicType then we'd likely rewrite basically the whole atomic module</p>",
        "id": 215115585,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074070
    },
    {
        "content": "<p>I think methods would be mostly fine</p>",
        "id": 215115652,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074089
    },
    {
        "content": "<p>this can all wait for Rust 2.0</p>",
        "id": 215115673,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074102
    },
    {
        "content": "<p>ha ha ha</p>",
        "id": 215115676,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074103
    },
    {
        "content": "<p>coming back to the API duplication question</p>",
        "id": 215115810,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074180
    },
    {
        "content": "<p>I'm wondering if it might be as simple as</p>",
        "id": 215115834,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074191
    },
    {
        "content": "<p>\"If you're not doing <code>unsafe</code> stuff, then you can definitely use the <code>&amp;AtomicFoo</code> methods\"</p>",
        "id": 215115920,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074211
    },
    {
        "content": "<p>seems true, yes</p>",
        "id": 215115940,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074229
    },
    {
        "content": "<p>\"If you're doing <code>unsafe</code> stuff, then you'll need to consider whether you managing memory. If so, you may need <code>*const AtomicFoo</code>\"</p>",
        "id": 215115965,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074241
    },
    {
        "content": "<p>I'm not sure if there's cases besides memory management that it comes up</p>",
        "id": 215115979,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074252
    },
    {
        "content": "<p>Probably better to be a little more open-ended</p>",
        "id": 215115997,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074261
    },
    {
        "content": "<p>but do you see what I mean? I don't think it needs to be that difficult a question, in the hopefully common case of someone <em>not</em> using <code>unsafe</code></p>",
        "id": 215116086,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074301
    },
    {
        "content": "<p>If the atomic operation can result in the memory at that address no longer being a valid AtomicFoo</p>",
        "id": 215116097,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074306
    },
    {
        "content": "<p>I think</p>",
        "id": 215116105,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074309
    },
    {
        "content": "<p>/me thinks</p>",
        "id": 215116120,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074317
    },
    {
        "content": "<p>is there a case where that can happen that's <em>not</em> memory management stuff</p>",
        "id": 215116174,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074327
    },
    {
        "content": "<p>well, in any case, your phrasing is better</p>",
        "id": 215116212,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074343
    },
    {
        "content": "<p>I guess for some definition of \"memory management,\" e.g. the temporary atomic stuff I was talking about earlier</p>",
        "id": 215116243,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074356
    },
    {
        "content": "<p>I.e. I'd probably use your phrasing, and then give the example of <code>Arc</code></p>",
        "id": 215116252,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074358
    },
    {
        "content": "<p>\"temporary atomic stuff\"</p>",
        "id": 215116292,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074374
    },
    {
        "content": "<p>where e.g. you have an Arc with a thread counter or something and the AtomicU32 magically becomes a Cell&lt;u32&gt;</p>",
        "id": 215116303,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074378
    },
    {
        "content": "<p>Ah okay</p>",
        "id": 215116322,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074388
    },
    {
        "content": "<p>in rayon's case, it was dealing with stack memory in another thread, that will go out of scope once triggered by the atomic operation</p>",
        "id": 215116348,
        "sender_full_name": "cuviper",
        "timestamp": 1604074400
    },
    {
        "content": "<p>ah true</p>",
        "id": 215116420,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074439
    },
    {
        "content": "<p>that is arguably another kind of memory management</p>",
        "id": 215116478,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074447
    },
    {
        "content": "<p>but its one that's being done under the hood</p>",
        "id": 215116484,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074453
    },
    {
        "content": "<p>so its a good additional example</p>",
        "id": 215116492,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215116303\">said</a>:</p>\n<blockquote>\n<p>where e.g. you have an Arc with a thread counter or something and the AtomicU32 magically becomes a Cell&lt;u32&gt;</p>\n</blockquote>\n<p>where is an example of this? I'm trying to understand the scenario where such a conversion is sound. Just the case where you first prove that you are the only thread with access to the <code>AtomicU32</code> ?</p>",
        "id": 215116648,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074545
    },
    {
        "content": "<p>I think so yes</p>",
        "id": 215116688,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074561
    },
    {
        "content": "<p>okay</p>",
        "id": 215116704,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074563
    },
    {
        "content": "<p>and that's kind of analogous to an <code>Arc</code></p>",
        "id": 215116748,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074574
    },
    {
        "content": "<p>i.e. first dynamically proving uniqueness</p>",
        "id": 215116769,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074584
    },
    {
        "content": "<p>anyway, I get it now</p>",
        "id": 215116788,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074590
    },
    {
        "content": "<p>I think perhaps the thread counter is not <em>in</em> the arc in that case</p>",
        "id": 215116792,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074592
    },
    {
        "content": "<p>(e.g., I believe C++ does this for shared_ptr, where it's an Rc until you spawn a thread)</p>",
        "id": 215116834,
        "sender_full_name": "simulacrum",
        "timestamp": 1604074617
    },
    {
        "content": "<p>Oh that's interesting</p>",
        "id": 215116880,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074630
    },
    {
        "content": "<p>I didn't actually know that C++ did that</p>",
        "id": 215116900,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074639
    },
    {
        "content": "<p>I just assumed everyone paid the cost all the time</p>",
        "id": 215116909,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074648
    },
    {
        "content": "<p>silly me</p>",
        "id": 215116923,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074654
    },
    {
        "content": "<p><a href=\"https://snf.github.io/2019/02/13/shared-ptr-optimization/\">https://snf.github.io/2019/02/13/shared-ptr-optimization/</a></p>",
        "id": 215117064,
        "sender_full_name": "cuviper",
        "timestamp": 1604074713
    },
    {
        "content": "<p>I wonder if our <code>Arc</code> could do that</p>",
        "id": 215117191,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074778
    },
    {
        "content": "<p>it's not exactly \"until you spawn a thread\", but whether <code>pthread_create</code> is linked</p>",
        "id": 215117212,
        "sender_full_name": "cuviper",
        "timestamp": 1604074787
    },
    {
        "content": "<p>it probably isn't worth the effort, given that we have <code>Rc</code></p>",
        "id": 215117214,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074787
    },
    {
        "content": "<p>oh</p>",
        "id": 215117225,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074792
    },
    {
        "content": "<p>that's not quite as exciting</p>",
        "id": 215117243,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074799
    },
    {
        "content": "<p>/me reads the blog post</p>",
        "id": 215117291,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074805
    },
    {
        "content": "<p>wow that blog post is really cool, in terms of the diving into scenarios where the stdlib <em>fails</em> to detect potential threading</p>",
        "id": 215117503,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074899
    },
    {
        "content": "<p>(the \"shared library loaded by static binary\" scenario)</p>",
        "id": 215117537,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074914
    },
    {
        "content": "<p>oh and it looks like VisualC++ does not seem to have this optimization</p>",
        "id": 215117697,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215117191\">said</a>:</p>\n<blockquote>\n<p>I wonder if our <code>Arc</code> could do that</p>\n</blockquote>\n<p>(heh the blog post even addresses this line of thought)</p>",
        "id": 215117747,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604074992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215114035\">said</a>:</p>\n<blockquote>\n<p>I wonder if <a href=\"https://en.cppreference.com/w/cpp/atomic/atomic_ref\">https://en.cppreference.com/w/cpp/atomic/atomic_ref</a> is sort of relevant here</p>\n</blockquote>\n<p>AFAICT, <code>atomic_ref</code> allows you to use atomic operations on something that you can also do non-atomic operations on, because IIRC converting <code>atomic&lt;T&gt; *</code> to <code>T *</code> is UB in C++ due to C++ supporting TBAA.</p>",
        "id": 215120914,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1604076509
    },
    {
        "content": "<p>Ah, TBAA makes sense as the reason.</p>",
        "id": 215126405,
        "sender_full_name": "simulacrum",
        "timestamp": 1604079065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215111096\">said</a>:</p>\n<blockquote>\n<p>Just had phone conversation with niko. Outcome: We think adding either free functions or methods on <code>*const Atomic</code> makes sense, because there is a real-world (lack of) expressiveness bug today. The reasoning that led us there was involved enough that it also probably make sense to put together an RFC for this.</p>\n</blockquote>\n<p>looking forward to that RFC... I don't see why we'd need these functions if we find a good solution to the <code>Arc</code>-<code>dereferencable</code> problem (and I do not consider these functions a good solution)</p>",
        "id": 215188790,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146219
    },
    {
        "content": "<blockquote>\n<p>pnkfelix: and the only semantic model that would allow this<br>\npnkfelix: is one that says x: &amp;T can actually be deallocated<br>\npnkfelix: (that is, a x: &amp;T parameter to a function)<br>\npnkfelix: can be deallocated sometime during the function's execution</p>\n</blockquote>\n<p>Yes. But that on its own seems fine to me, if it does not cause other problems (such as missed optimizations).</p>",
        "id": 215188865,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215120914\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215114035\">said</a>:</p>\n<blockquote>\n<p>I wonder if <a href=\"https://en.cppreference.com/w/cpp/atomic/atomic_ref\">https://en.cppreference.com/w/cpp/atomic/atomic_ref</a> is sort of relevant here</p>\n</blockquote>\n<p>AFAICT, <code>atomic_ref</code> allows you to use atomic operations on something that you can also do non-atomic operations on, because IIRC converting <code>atomic&lt;T&gt; *</code> to <code>T *</code> is UB in C++ due to C++ supporting TBAA.</p>\n</blockquote>\n<p>FWIW, we have kind of the inverse in Rust, with <code>get_mut</code> methods on our <code>Atomic*</code> types</p>",
        "id": 215188907,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146457
    },
    {
        "content": "<p>this poses some really nasty questions around compare-and-swap on uninit memory... but let's not go there in this thread ;)</p>",
        "id": 215188914,
        "sender_full_name": "RalfJ",
        "timestamp": 1604146484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> one comment here is that I would expect to just tell people to <em>always</em> use the <code>*const</code> version of the methods</p>",
        "id": 215361543,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343106
    },
    {
        "content": "<p>not to say I don't agree with the downsides</p>",
        "id": 215361554,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343115
    },
    {
        "content": "<p>Well, ok, I guess that makes them <code>unsafe</code> functions</p>",
        "id": 215361681,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343175
    },
    {
        "content": "<p>/me sighs</p>",
        "id": 215361687,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343178
    },
    {
        "content": "<p>I had kind of forgotten about that, I admit</p>",
        "id": 215361697,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215115920\">said</a>:</p>\n<blockquote>\n<p>\"If you're not doing <code>unsafe</code> stuff, then you can definitely use the <code>&amp;AtomicFoo</code> methods\"</p>\n</blockquote>\n<p>that was my motivation for this rule of thumb</p>",
        "id": 215361794,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343236
    },
    {
        "content": "<p>One of the things that I keep thinking is that this \"may deallocate mid-function\" property almost certainly needs to extend to the caller and quite possibly caller's caller, etc</p>",
        "id": 215361872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343266
    },
    {
        "content": "<p>So it really seems like it wants to be a type, something that will be more apparent</p>",
        "id": 215361915,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215188865\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>pnkfelix: and the only semantic model that would allow this<br>\npnkfelix: is one that says x: &amp;T can actually be deallocated<br>\npnkfelix: (that is, a x: &amp;T parameter to a function)<br>\npnkfelix: can be deallocated sometime during the function's execution</p>\n</blockquote>\n<p>Yes. But that on its own seems fine to me, if it does not cause other problems (such as missed optimizations).</p>\n</blockquote>\n<p>It strikes me as unintuitive, to say the least. I would have thought its simpler to say \"if you get <code>&amp;T</code> as an input to a function, the <em>caller</em> is guaranteeing it will live for entirety of the call.\"</p>",
        "id": 215361953,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343310
    },
    {
        "content": "<p>(Something else that <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> and I discussed is that you want the name of the method to be distinct, so that it can be more readily audited when reading PRs and the like)</p>",
        "id": 215361962,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> the caller can't guarantee that, right? At least, not always. that seems to be the crux of the problem. The caller is guaranteeing it to the callee, but the callee must also guarantee it back to the caller.</p>",
        "id": 215362088,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343365
    },
    {
        "content": "<p>/me thinks</p>",
        "id": 215362133,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343391
    },
    {
        "content": "<p>Are there cases besides the one under discussion where it would not be realistic to make that the rule?</p>",
        "id": 215362200,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343422
    },
    {
        "content": "<p>I.e., I had thought that switching to using <code>*const AtomicFoo</code> for the ref-count decrement <em>would</em> allow for a caller (or perhaps caller+callee collective, still ruminating on that)  guarantee that a <code>&amp;T</code> <em>will live</em></p>",
        "id": 215362362,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343492
    },
    {
        "content": "<p>well we've long had the question of whether a function can invoke <code>free</code> on some <code>&amp;T</code> it gets (presuming it knows that to come from a <code>malloc</code> call somehow)</p>",
        "id": 215362409,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343518
    },
    {
        "content": "<p>ah</p>",
        "id": 215362449,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343539
    },
    {
        "content": "<p>I somehow have forgotten this debate</p>",
        "id": 215362476,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343553
    },
    {
        "content": "<p>debate/question</p>",
        "id": 215362485,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343560
    },
    {
        "content": "<p>it seems kind of the same to me</p>",
        "id": 215362490,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604343562
    },
    {
        "content": "<p>and figured <code>*const T</code> was the answer here too</p>",
        "id": 215362715,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604343661
    },
    {
        "content": "<p>I think with &amp;T it feels less obvious that you could, but the same applies to &amp;mut T, and there it is very much not obvious (e.g., ptr::drop_in_place)</p>",
        "id": 215366314,
        "sender_full_name": "simulacrum",
        "timestamp": 1604345236
    },
    {
        "content": "<p>wait, I don't understand: <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> , are you saying you think <code>&amp;mut T</code> conveys you <em>should</em> be able to do such a deallocation?</p>",
        "id": 215383389,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604353490
    },
    {
        "content": "<p><code>ptr::drop_in_place</code> doesn't take a <code>&amp;mut</code>, so I'm confused about your mentioning it.</p>",
        "id": 215383431,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604353514
    },
    {
        "content": "<p>I am uncertain - I lean towards no, I think. But I am saying that of the two, &amp;mut seems more likely to be a candidate for such an operation</p>",
        "id": 215383517,
        "sender_full_name": "simulacrum",
        "timestamp": 1604353552
    },
    {
        "content": "<p>oh, okay. More of a candidate, yes. But I still lean towards: Not a candidate. :)</p>",
        "id": 215383604,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604353582
    },
    {
        "content": "<p>we have definitely been pushing towards \"no\"</p>",
        "id": 215384846,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354237
    },
    {
        "content": "<p>that is what permits us to do various aggressive reorderings which, the vast majority fo the time, ought to be fine</p>",
        "id": 215384897,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354261
    },
    {
        "content": "<p>and if you think (intuitively) about <em>borrowing</em>, it makes sense</p>",
        "id": 215384924,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354273
    },
    {
        "content": "<p>i.e., the caller lent you this data, they didn't say you can destroy it</p>",
        "id": 215384976,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354286
    },
    {
        "content": "<p>anyway, the fly in the ointment for me is that a <code>*const T</code> version must be unsafe to call</p>",
        "id": 215385005,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354304
    },
    {
        "content": "<p>that's a real drag</p>",
        "id": 215385011,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354307
    },
    {
        "content": "<p>I'd like one that is safe to call with an <code>&amp;T</code> but unsafe to call with a <code>*const T</code> :)</p>",
        "id": 215385033,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354321
    },
    {
        "content": "<p>(er, not sure if that makes sense, but I guess that's just \"having two copies of the API surface\")</p>",
        "id": 215385134,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604354381
    },
    {
        "content": "<p>Hmm</p>",
        "id": 215385706,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604354683
    },
    {
        "content": "<p>yes I think this just ... doesn't sound that bad to me</p>",
        "id": 215385751,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604354715
    },
    {
        "content": "<p>Maybe I'm too willing to swallow \"its not a duplicated API. One is for safe uses, the other for unsafe. And when you see the latter, you want it called out very explicitly, because Here Be Tygers\"</p>",
        "id": 215385823,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604354762
    },
    {
        "content": "<p>I think Niko's intuition/feeling there basically matches mine, that with some compiler magic or &amp;unsafe or so we could design a better API than just duplicating, because it seems like the function ultimately does the same thing - at least in the case of atomics - just with different guarantees at the caller level. Perhaps an interesting exercise would be to try to think if we <em>could</em> just remove the additional bit that &amp;T arguably gives for these functions within the function, would that be enough? i.e. if you could call it with *const to get the less strict behavior or &amp;T to promise more, but the function of definition itself is the same</p>",
        "id": 215393082,
        "sender_full_name": "simulacrum",
        "timestamp": 1604359716
    },
    {
        "content": "<p>Sort of that the function says \"I do not need this additional requirement\"</p>",
        "id": 215393105,
        "sender_full_name": "simulacrum",
        "timestamp": 1604359742
    },
    {
        "content": "<p>with perhaps s/need/want, I guess.</p>",
        "id": 215393132,
        "sender_full_name": "simulacrum",
        "timestamp": 1604359768
    },
    {
        "content": "<p>I really do worry that if we do this here it'll end up being true that a bunch of APIs technically need the same treatment</p>",
        "id": 215393270,
        "sender_full_name": "simulacrum",
        "timestamp": 1604359848
    },
    {
        "content": "<p>I guess it's mainly a problem with Sync types, so that might help, but it feels like opening a can of worms.</p>",
        "id": 215393453,
        "sender_full_name": "simulacrum",
        "timestamp": 1604359949
    },
    {
        "content": "<p>It would help me at least to actually get clarity on that - does this problem require a synchronization operation in the function to cause problems (i.e. is atomic the only API needing this in std as such?)</p>",
        "id": 215393534,
        "sender_full_name": "simulacrum",
        "timestamp": 1604360014
    },
    {
        "content": "<p>thanks for feedback. I'll see if I can address it when I have a moment</p>",
        "id": 215618809,
        "sender_full_name": "pnkfelix",
        "timestamp": 1604512834
    },
    {
        "content": "<p>FWIW, if you only focus on Arc/Atomics, then by favorite proposal currently is <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">this one</a>. This <em>does</em> give up on \"derefeerncable for the duration of the entire function call\" for <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252#issuecomment-709042507\">all references</a>, but all the Stacked Borrows optimizations we considered so far are preserved. (To be fair, we did not consider very many, but the basic reorderings we considered are very powerful.)</p>",
        "id": 215952482,
        "sender_full_name": "RalfJ",
        "timestamp": 1604751415
    },
    {
        "content": "<p>This does not help with the other problems around <code>dereferencable</code>/protectors, but then you seem to not currently consider those in your discussion anyway</p>",
        "id": 215952490,
        "sender_full_name": "RalfJ",
        "timestamp": 1604751446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> that's interesting! I'll read into that issue</p>",
        "id": 215959392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1604762232
    },
    {
        "content": "<p>Yes, the main pain point that I am currently focusing on is Arc/Atomics, since that is the one that I see real-world code getting burned by our (what I would call) lack of expressiveness here</p>",
        "id": 216662191,
        "sender_full_name": "pnkfelix",
        "timestamp": 1605296274
    },
    {
        "content": "<p>(but I remain concerned about people's overall mental model of parameters of type <code>&amp;T</code>)</p>",
        "id": 216662344,
        "sender_full_name": "pnkfelix",
        "timestamp": 1605296323
    },
    {
        "content": "<p>(and yes I know that I still need to post a response to simulacrum's feedback above... balancing a lot of stuff at moment)</p>",
        "id": 216662449,
        "sender_full_name": "pnkfelix",
        "timestamp": 1605296376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/216662191\">said</a>:</p>\n<blockquote>\n<p>Yes, the main pain point that I am currently focusing on is Arc/Atomics, since that is the one that I see real-world code getting burned by our (what I would call) lack of expressiveness here</p>\n</blockquote>\n<p>I'm a bit worried that we might end up with a partial solution, that might actually not be a good solution when/if we solve the wider problem.</p>",
        "id": 216726017,
        "sender_full_name": "RalfJ",
        "timestamp": 1605356431
    },
    {
        "content": "<p>Okay I just re-read this whole conversation, as well as the notes from a prior <a href=\"https://paper.dropbox.com/doc/Lang-Team-Design-Meeting-and-Dereferenceable--BAGtOq5x6fY2s7TuGlAx~drlAg-enTyRslkuAcNPgqWsN4UU\">lang team discussion</a>. My current response to <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> 's <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215393082\">later points</a> is that I'm struggling to understand which proposals are trying to get away with not adding <em>any</em> new API at all (i.e. figure out a way to fix things so that all the current API's \"just work\", which I think is the essence of what <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> is proposing), versus which proposals are accepting that we will need to add <em>some</em> new API, and the question is whether we can stomach adding <code>*const</code> API (at least in short term), or if we must wait for <code>&amp;unsafe T</code>, or some attributes to attach to <code>&amp;T</code> parameters, etc, to get the desired effect(s).</p>",
        "id": 217909751,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606322854
    },
    {
        "content": "<p>One basic goal is that I want a solution that allows a 3rd party developer to make their own <code>Arc</code>. I don't need it to be an <em>easy task</em>; I just want it to be <em>possible</em>, and I want basic things like \"you can write intermediate helper functions\" to work.</p>",
        "id": 217910187,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606323045
    },
    {
        "content": "<p>That latter goal makes me suspicious of suggestions of compiler-magic for making <code>&amp;T</code> parameters behave special when given <code>*const T</code> inputs; e.g. consider that special-ness needs to <em>trickle down</em> through subroutine calls that pass along the <code>&amp;T</code>.</p>",
        "id": 217910316,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606323114
    },
    {
        "content": "<p>Another basic goal is that I want to have a simple way to explain what a <code>&amp;T</code> formal parameter is guaranteeing from the caller, and as <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> rightly points out, what guarantees need to be upheld by the callee. I've been assuming that we would keep saying \"it lives for the entirety of the function body\", because that's just always the way I've read it. Changing it to something like \"it lives up until the last access within the function body (but immediately after that last access, its possible that concurrent activity causes it to become a dangling-pointer)\" is much harder for me to stomach. But I <em>can</em> stomach it; it <em>is</em> something I can explain, though it requires a lot more exposition to explain why it isn't paradoxical.</p>",
        "id": 217910986,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606323384
    },
    {
        "content": "<p>(Am I correct that adopting <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> is, in spirit, much like saying \"all <code>&amp;T</code> formals live up until their last access within a function body\"?)</p>",
        "id": 217911286,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606323499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ^</p>",
        "id": 217911296,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606323503
    },
    {
        "content": "<p>(Maybe \"paradoxical\" is the wrong word above. I'm happy to elaborate on my concerns there, but I don't want to further derail this discussion with that digression.)</p>",
        "id": 217911998,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606323769
    },
    {
        "content": "<p>(I will also admit that the experience of prototyping the proposal of \"just\" duplicating the Atomic* API with <code>raw_</code> variants has given me some appreciation for the opposing side.)</p>",
        "id": 217934011,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606335434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/217911286\">said</a>:</p>\n<blockquote>\n<p>(Am I correct that adopting <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> is, in spirit, much like saying \"all <code>&amp;T</code> formals live up until their last access within a function body\"?)</p>\n</blockquote>\n<p><code>&amp;T</code> guarantees way more than \"it lives for the entirety of the function body\", at least in general -- it guarantees that nobody writes to this memory for the duration of the fn call (except for <code>UnsafeCell</code>). deallocation is IMO a (very strong) form of \"writing\"/mutation, and is thus also rules out. this remains true under <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> for <code>&amp;T</code> <em>without <code>UnsafeCell</code></em>.<br>\nThe difference comes in when there is an <code>UnsafeCell</code>. under current Stacked Borrows, the rule is that the <code>UnsafeCell</code> part of the pointee may be <em>mutated</em> but not deallocated by others. So, deallocation is \"stronger than\" normal mutation. <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> proposes to make them equally strong, IOW, memory that other parties may write to, may also be deallocated by those parties.</p>",
        "id": 218118448,
        "sender_full_name": "RalfJ",
        "timestamp": 1606501268
    },
    {
        "content": "<p>there is no \"until the last access\" in any of this. but of course, at every access, the memory must still exist, so \"until the last access\" arises as a kind of emergent property.</p>",
        "id": 218118530,
        "sender_full_name": "RalfJ",
        "timestamp": 1606501349
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> implies removing <code>dereferencable</code> from <code>&amp;UnsafeCell</code> (assuming this attribute means \"dereferencable for the entire fn body\"), however it does so in a much more elegant way than what was discussed with the lang team back then. The downside is that it means also removing this attribute for <code>&amp;mut</code>, because where previously <em>nobody</em> was allowed to deallocate this memory, now <em>nobody else</em> (as in, no alias that might exist anywhere) is allowed to deallocate it, but the function itself may still deallocate. This is symmetric with mutation where nobody else is allowed to mutate but the function itself may mutate. I think this is beautiful but unfortunately does not match how LLVM is architected. But maybe that's okay, we'll need custom optimizations to really exploit these properties anyway.</p>",
        "id": 218118818,
        "sender_full_name": "RalfJ",
        "timestamp": 1606501632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/217909751\">said</a>:</p>\n<blockquote>\n<p>Okay I just re-read this whole conversation, as well as the notes from a prior <a href=\"https://paper.dropbox.com/doc/Lang-Team-Design-Meeting-and-Dereferenceable--BAGtOq5x6fY2s7TuGlAx~drlAg-enTyRslkuAcNPgqWsN4UU\">lang team discussion</a>. My current response to <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> 's <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/215393082\">later points</a> is that I'm struggling to understand which proposals are trying to get away with not adding <em>any</em> new API at all (i.e. figure out a way to fix things so that all the current API's \"just work\", which I think is the essence of what <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> is proposing), versus which proposals are accepting that we will need to add <em>some</em> new API, and the question is whether we can stomach adding <code>*const</code> API (at least in short term), or if we must wait for <code>&amp;unsafe T</code>, or some attributes to attach to <code>&amp;T</code> parameters, etc, to get the desired effect(s).</p>\n</blockquote>\n<p>I think one problem is that a whole host of proposals exist and they all get confused quickly and regularly.</p>",
        "id": 218119031,
        "sender_full_name": "RalfJ",
        "timestamp": 1606501846
    },
    {
        "content": "<p>does anyone know what the status of dereferencable / dereferencable_on_entry / dereferencable_globally in LLVM is right now? <a href=\"https://reviews.llvm.org/D61652\">https://reviews.llvm.org/D61652</a> says \"accepted\" but I do not see <code>dereferecable_globally</code> in the LangRef.</p>",
        "id": 218119160,
        "sender_full_name": "RalfJ",
        "timestamp": 1606501953
    },
    {
        "content": "<p>Honestly, I think my preference is for <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a>. this means we have to remove <code>dereferencable</code> now from everything but <code>&amp;Frozen</code>, but we can add it back once LLVM changed its meaning to \"dereferencable on entry\".<br>\nThis does not solve <code>VecDeque</code> and <code>RefCell</code>, but I think that should just be fixed in the code (<code>vec_deque::Drain</code>, <code>Ref</code> and <code>RefMut</code> should use raw pointers, not references, since the lifetimes they are using are mere <em>upper bounds</em> for how long those pointers are actually valid ). It also does not fix MMIO but again that rather asks for more ergonomic raw pointers I think.<br>\nMy impression is that part of the problem is that there are quite a few issues put together here -- I am guilty of trying to solve them all at once as that seemed like a nice idea. But maybe it's not such a nice idea after all, and we should consider each of them in isolation.</p>",
        "id": 218119560,
        "sender_full_name": "RalfJ",
        "timestamp": 1606502397
    },
    {
        "content": "<p>I'm trying to understand a critical part of your response here: It sounds like you're saying that <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> wouldn't even solve the problem that the deferent of a <code>&amp;AtomicUsize</code> can get deallocated by another party when it is decremented...?</p>",
        "id": 218196014,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606625233
    },
    {
        "content": "<p>(i.e. that the guarantee that it must live for entirety of the function body would persist?)</p>",
        "id": 218196024,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606625273
    },
    {
        "content": "<p>oh, no wait, I overlooked this sentence: \"So, deallocation is \"stronger than\" normal mutation. <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> proposes to make them equally strong, IOW, memory that other parties may write to, may also be deallocated by those parties.\"</p>",
        "id": 218196075,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606625369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/218119160\">said</a>:</p>\n<blockquote>\n<p>does anyone know what the status of dereferencable / dereferencable_on_entry / dereferencable_globally in LLVM is right now? <a href=\"https://reviews.llvm.org/D61652\">https://reviews.llvm.org/D61652</a> says \"accepted\" but I do not see <code>dereferecable_globally</code> in the LangRef.</p>\n</blockquote>\n<p>metadata on ticket from September says it is now (as in, at that time) \"ready to land\"</p>",
        "id": 218196169,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606625544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/218196075\">said</a>:</p>\n<blockquote>\n<p>oh, no wait, I overlooked this sentence: \"So, deallocation is \"stronger than\" normal mutation. <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/252\">ucg#252</a> proposes to make them equally strong, IOW, memory that other parties may write to, may also be deallocated by those parties.\"</p>\n</blockquote>\n<p>(but even here, I don't think the <code>AtomicUsize</code> in an <code>Arc</code> (or rather, <code>ArcInner</code> ...) is behind an <code>UnsafeCell</code>, is it? And in any case, you're still going to end up with an <code>&amp;AtomicUsize</code> parameter somewhere in the method call chain... <em>unless</em> we adopt a solution that involves extending the std API to allow one to use <code>*const AtomicUsize</code> for the decrements for dropping an <code>Arc</code>)</p>",
        "id": 218196327,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606625956
    },
    {
        "content": "<p><code>AtomicUsize</code> is itself (wrapping) an <code>UnsafeCell&lt;usize&gt;</code> (so, IIUC, those <code>mem::size_of::&lt;usize&gt;()</code> bytes are allowed to be concurrently mutated, or even deallocated, according to this model, leading to an <code>&amp;AtomicUsize</code> only being <code>dereferenceable_on_entry</code>)</p>",
        "id": 218208144,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1606648403
    },
    {
        "content": "<p>right, this works because <code>AtomicUsize = UnsafeCell&lt;usize&gt;</code> (plus privacy)</p>",
        "id": 218214573,
        "sender_full_name": "RalfJ",
        "timestamp": 1606659241
    },
    {
        "content": "<p>however, if you e.g. added a helper method on <code>&amp;ArcInner</code> that did the decrement, that would still be wrong since that reference would cover the data part, which is not (in general) interior mutable, and thus may not be deallocated by other threads</p>",
        "id": 218214621,
        "sender_full_name": "RalfJ",
        "timestamp": 1606659279
    },
    {
        "content": "<p>but that seems reasonable to me? if other threads cannot mutate, surely they cannot deallocate?</p>",
        "id": 218214623,
        "sender_full_name": "RalfJ",
        "timestamp": 1606659294
    },
    {
        "content": "<p>This is a detail I had been worried about, but I had been taking it from the other direction; I had been incorrectly inferring that the rules described here would <em>allow</em> a helper method on <code>&amp;ArcInner</code> that did the decrement, and I had been worrying about how to make that make sense.</p>",
        "id": 218310334,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606753872
    },
    {
        "content": "<p>Overall I am actually finding the arguments given here pretty compelling. Namely the <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/218196075\">one above</a> that if the compiler is forced to assume a concurrent actor can write to the <code>T</code> behind a <code>&amp;T</code>, then the compiler must also assume that a concurrent actor might deallocate the <code>T</code> there as well.</p>",
        "id": 218310717,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606754056
    },
    {
        "content": "<p>I'm going to do another review of the links I gave above with that lens in place. Maybe I won't have to write an RFC for <code>*const AtomicFoo</code> methods after all. (At least not to resolve <em>my</em> problem. We may still need such methods for the other problems listed.)</p>",
        "id": 218310808,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606754110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/218310717\">said</a>:</p>\n<blockquote>\n<p>Overall I am actually finding the arguments given here pretty compelling. Namely the <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/218196075\">one above</a> that if the compiler is forced to assume a concurrent actor can write to the <code>T</code> behind a <code>&amp;T</code>, then the compiler must also assume that a concurrent actor might deallocate the <code>T</code> there as well.</p>\n</blockquote>\n<p>so you think it'd be okay if an <code>&amp;ArcInner</code> helper would be <em>incorrect</em>, based on the argument that parts of what that pointer points to might be immutable (when <code>T: Frozen</code>) and immutable memory may not be deallocated either?</p>",
        "id": 218315716,
        "sender_full_name": "RalfJ",
        "timestamp": 1606756221
    },
    {
        "content": "<p>I haven't made up my mind about the <code>&amp;ArcInner</code> helper example yet. I had spent some time, when I had thought we would \"have to\" allow it, trying to think of how to explain the model</p>",
        "id": 218329701,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606762727
    },
    {
        "content": "<p>but my main concern has always been how to even express the handling of the <code>&amp;AtomicUsize</code> itself.</p>",
        "id": 218329974,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606762836
    },
    {
        "content": "<p>Under the rules that you and <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> have outlined, it sounds like we need not have a problem with the handling of <code>&amp;AtomicUsize</code>.</p>",
        "id": 218330027,
        "sender_full_name": "pnkfelix",
        "timestamp": 1606762868
    },
    {
        "content": "<p>So theres a lang team meeting coming up related to this topic, <a href=\"https://github.com/rust-lang/lang-team/issues/82\">https://github.com/rust-lang/lang-team/issues/82</a></p>",
        "id": 232003563,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616779658
    },
    {
        "content": "<p>I made a write up, then I decided the write-up was not approrpriate for the lang team meeting (too long winded), so I turned it into a blog post because I couldnt bear to throw it away: <a href=\"http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/\">http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/</a></p>",
        "id": 232003686,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616779703
    },
    {
        "content": "<p>but that blog post does not attempt to address/evaluate the current state of LLVMs <code>dereferencable</code> attribute. I would like to make a decision here that is <em>independent</em> of the state of that attribute, but maybe that is not realistc...</p>",
        "id": 232003761,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616779741
    },
    {
        "content": "<p>I'll read that write up -- I was planning to ping you <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> but keep running out of cycles to do so... we should prepare an agenda of some kind</p>",
        "id": 232009075,
        "sender_full_name": "simulacrum",
        "timestamp": 1616781950
    },
    {
        "content": "<p>Thoughts on a <code>*const</code> API with my libs team hat on:</p>\n<ul>\n<li>I don't think confusion by users is going to be a significant issue. The <code>*const</code> API will clearly be named as a \"raw\" API, it will be <code>unsafe</code> and the docs will recommend using <code>Atomic*</code> instead.</li>\n<li>Having an API to atomically mutate a <code>*const Inner</code> is useful to have in general, especially for FFI which doesn't use atomic types.</li>\n</ul>",
        "id": 232018340,
        "sender_full_name": "Amanieu",
        "timestamp": 1616786313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232009075\">said</a>:</p>\n<blockquote>\n<p>I'll read that write up -- I was planning to ping you <span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> but keep running out of cycles to do so... we should prepare an agenda of some kind</p>\n</blockquote>\n<p>Yes, my current plan is to construct a much smaller agenda for the lang-team meeting by trying to condense that writeup into something a lang team member could read in five minutes.</p>",
        "id": 232024493,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616789189
    },
    {
        "content": "<p>Hm, ok</p>",
        "id": 232028807,
        "sender_full_name": "simulacrum",
        "timestamp": 1616791301
    },
    {
        "content": "<p>That seems like the right goal</p>",
        "id": 232028819,
        "sender_full_name": "simulacrum",
        "timestamp": 1616791309
    },
    {
        "content": "<p>I keep going back to the question of trying to dive back into the previous discussions related to this topic</p>",
        "id": 232028908,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791347
    },
    {
        "content": "<p>but they get really unwieldy, and I want this to be a bit more focused</p>",
        "id": 232028926,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791361
    },
    {
        "content": "<p>Yeah, that was my impression based on a few brief forays</p>",
        "id": 232029444,
        "sender_full_name": "simulacrum",
        "timestamp": 1616791670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232003686\">said</a>:</p>\n<blockquote>\n<p>I made a write up, then I decided the write-up was not approrpriate for the lang team meeting (too long winded), so I turned it into a blog post because I couldnt bear to throw it away: <a href=\"http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/\">http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/</a></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Im sort of dreading pointing you at this, because its pretty long-winded, and ends up not even saying that much in the end.</p>",
        "id": 232029595,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791738
    },
    {
        "content": "<p>but at the same time, I expect you (Ralf) might have insight into other points in the domain that I failed to distinguish/consider.</p>",
        "id": 232029637,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791770
    },
    {
        "content": "<p>(both problem and solution domains, that is.)</p>",
        "id": 232029655,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791786
    },
    {
        "content": "<p>I think it feels like your blog post identifies pretty clearly a couple models we <em>could</em> go with -- I've not yet formed a position of preference, though I do have thoughts -- I'm wondering if the right shape for the meeting is to:</p>\n<ul>\n<li>read a prepared summary of the problem</li>\n<li>read a prepared summary of the available options (your models at least, potentially coming up with some new ones)</li>\n<li>discuss, in the hopes of identifying how we want to move forward (i.e., on which model)</li>\n</ul>\n<p>I am a bit of the mind that perhaps the last point here is not actually right -- it seems pretty likely that we'd not be able to come to a reasonable understanding in the meeting <em>and</em> arrive at any kind of consensus; these topics at least for me really require some idle thinking time</p>",
        "id": 232029779,
        "sender_full_name": "simulacrum",
        "timestamp": 1616791836
    },
    {
        "content": "<p>so I'm wondering if the right thing is that we instead <em>focus</em> the meeting on a collaborative exploration of the design space, potentially even without all of lang in attendance -- in the hopes of actually coming up with the first two bullets I had prepared, which can then be more asynchronously digested and such</p>",
        "id": 232029872,
        "sender_full_name": "simulacrum",
        "timestamp": 1616791892
    },
    {
        "content": "<p>maybe</p>",
        "id": 232029960,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> s comment above makes me worry that I was too quick to dismiss a raw API</p>",
        "id": 232029990,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616791946
    },
    {
        "content": "<p>but I think I <em>like</em> the philosophy that deallocation capability should be on same footing as mutation capability w.r.t reasoning. Something really sings to me about that.</p>",
        "id": 232030084,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792025
    },
    {
        "content": "<p>even though Im not sure if its entirely coherent (given that you can attach <code>UnsafeCell</code> to only <em>part</em> of a memory block youve allocated)</p>",
        "id": 232030183,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792069
    },
    {
        "content": "<p>Yeah, that's my worry with it</p>",
        "id": 232030195,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792076
    },
    {
        "content": "<p>it feels like what that the coherent expectation would be UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt; gives you that</p>",
        "id": 232030252,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792101
    },
    {
        "content": "<p>hmm.  You think the <code>MaybeUninit</code> needs to be part of the story?</p>",
        "id": 232030353,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792143
    },
    {
        "content": "<p>Well, to me, UnsafeCell does not imply no validity invariant, whereas deallocation (to some extent) implies replacement with uninit memory, right?</p>",
        "id": 232030428,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792169
    },
    {
        "content": "<p>Though we've certainly oscillated on whether e.g. UnsafeCell&lt;bool&gt; can be a 0x3 in memory, I don't know if there's firm conclusions</p>",
        "id": 232030481,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792203
    },
    {
        "content": "<p>deallocation to me is more severe than replacement with uninit\"</p>",
        "id": 232030504,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792221
    },
    {
        "content": "<p>I agree :) But if it's <em>at least</em> that, then it seems like you should request a maybeuninit somewhere</p>",
        "id": 232030554,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792254
    },
    {
        "content": "<p>but your point is that you do not think <code>UnsafeCell&lt;T&gt;</code> should suffice as a marker</p>",
        "id": 232030559,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792258
    },
    {
        "content": "<p>I definitely don't think it should suffice for memory outside of it</p>",
        "id": 232030767,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792363
    },
    {
        "content": "<p>(since I don't know where to stop then)</p>",
        "id": 232030791,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792382
    },
    {
        "content": "<p>I could imagine ways to formalize its leakiness</p>",
        "id": 232030928,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792427
    },
    {
        "content": "<p>but I understand the concern</p>",
        "id": 232030963,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792439
    },
    {
        "content": "<p>the main thing for me is whether we try to come up with something that is likely to work with existing coding patterns that are modelled after what <code>Arc</code> does</p>",
        "id": 232031018,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792463
    },
    {
        "content": "<p>or do we require something new</p>",
        "id": 232031032,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792469
    },
    {
        "content": "<p>Yeah, I'm not sure. I lean towards saying we should work with existing patterns, but I think ultimately I'd prefer to aim for a model that feels pretty easily explainable. I think saying that UnsafeCell, for example, combines both mutation and deallocation, that seems coherent to me; I think the interaction with MaybeUninit is a bit fuzzy but not too bad.</p>\n<p>That might mean that in the Arc example, we would indeed need a rewrite to have UnsafeCell&lt;Inner&gt;; that seems a bit unfortunate, as the compiler cannot \"know\" then that the T is <em>not</em> permitted to be mutated, only deallocated</p>",
        "id": 232031334,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792629
    },
    {
        "content": "<p>(though I'm trying to understand why that matters)</p>",
        "id": 232031349,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792639
    },
    {
        "content": "<p>Interesting</p>",
        "id": 232031465,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792689
    },
    {
        "content": "<p>I was hoping to make <code>Arc</code> work soley from the presence of <code>UnsafeCell</code> within the <code>AtomicUsize</code>, but yes, then we hit the problem you were noting earlier of having to define where does it stop\"</p>",
        "id": 232031532,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792730
    },
    {
        "content": "<p>anyway we can try to leave this discussion for the meeting</p>",
        "id": 232031562,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792751
    },
    {
        "content": "<p>well, maybe</p>",
        "id": 232031580,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792758
    },
    {
        "content": "<p>but its good stuff to try to figure out how to summarize concisely.</p>",
        "id": 232031638,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792769
    },
    {
        "content": "<p>I'm not sure if it's helpful to come in with a well understood framework/design space</p>",
        "id": 232031643,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792773
    },
    {
        "content": "<p>(at least by someone)</p>",
        "id": 232031668,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792789
    },
    {
        "content": "<p> either you have a typo, or youre saying that doing design before the meeting will just mean people will be confused by the design at the meeting?</p>",
        "id": 232031865,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616792895
    },
    {
        "content": "<p>No, I'm saying -- do we want to do design in the meeting? Or choose amongst a set of options (potentially finding a combination between them)</p>",
        "id": 232031990,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792965
    },
    {
        "content": "<p>I was seeing this conversation as trying to come up with some set of options and a framework of pros/cons pre-identified</p>",
        "id": 232032031,
        "sender_full_name": "simulacrum",
        "timestamp": 1616792998
    },
    {
        "content": "<p>Right, okay</p>",
        "id": 232032095,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793010
    },
    {
        "content": "<p>(and I see that as helpful for the meeting, but if it feels differently to you, perhaps we shouldn't do it :)</p>",
        "id": 232032103,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793019
    },
    {
        "content": "<p>Well</p>",
        "id": 232032165,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793059
    },
    {
        "content": "<p>I guess Im dividied</p>",
        "id": 232032178,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793066
    },
    {
        "content": "<p>on the one hand, Im about to be called away, so I really cant invest much time right now into <em>anything</em>. :)</p>",
        "id": 232032211,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793093
    },
    {
        "content": "<p>but really, that s not an arguemnt against async discussion</p>",
        "id": 232032227,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793105
    },
    {
        "content": "<p>what I <em>am</em> worried aobut</p>",
        "id": 232032232,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793108
    },
    {
        "content": "<p>is not having a useful doc at all going into the meeting</p>",
        "id": 232032292,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793127
    },
    {
        "content": "<p>so I guess its good to have this conversation, as long as it drives me towards coming up with something for the meeting itself.</p>",
        "id": 232032330,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793149
    },
    {
        "content": "<p>Right, yeah, I don't necessarily think it needs to be a discussion, though that can be helpful to pull out into a doc</p>",
        "id": 232032342,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793156
    },
    {
        "content": "<p>I'm happy to work on preparing the doc to some extent</p>",
        "id": 232032361,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793165
    },
    {
        "content": "<p>are there other compiler optimizations that should be illustrated in the text?</p>",
        "id": 232032421,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793187
    },
    {
        "content": "<p>or unsafe code examples that shoudl be in there?</p>",
        "id": 232032452,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793193
    },
    {
        "content": "<p>you mean vs. your blog post?</p>",
        "id": 232032587,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793235
    },
    {
        "content": "<p>yes. for the blog post, I chose something dirt simple</p>",
        "id": 232032643,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793247
    },
    {
        "content": "<p>I think there was the Arc case, and there was a potentially similar but different case in the rayon library</p>",
        "id": 232032660,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793254
    },
    {
        "content": "<p>(also with deallocation)</p>",
        "id": 232032681,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793267
    },
    {
        "content": "<p>I don't know about compiler opts</p>",
        "id": 232032702,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793283
    },
    {
        "content": "<p>i see. There are I think also examples of intrusive linked-lists where this problem arises</p>",
        "id": 232032713,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793289
    },
    {
        "content": "<p>(the Rayon thing might be that, Im not sure.)</p>",
        "id": 232032737,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616793299
    },
    {
        "content": "<p>yeah I forget too</p>",
        "id": 232032849,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793355
    },
    {
        "content": "<p>anyway, I'll see if I can find some time to invest in starting a draft layout and such</p>",
        "id": 232032898,
        "sender_full_name": "simulacrum",
        "timestamp": 1616793367
    },
    {
        "content": "<p>Okay, but dont worry too much about it <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> ; I know you have a lot of balls in the air</p>",
        "id": 232039451,
        "sender_full_name": "pnkfelix",
        "timestamp": 1616797088
    },
    {
        "content": "<p>Yeah, we'll see :)</p>",
        "id": 232039498,
        "sender_full_name": "simulacrum",
        "timestamp": 1616797107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232029637\">said</a>:</p>\n<blockquote>\n<p>but at the same time, I expect you (Ralf) might have insight into other points in the domain that I failed to distinguish/consider.</p>\n</blockquote>\n<p>I saw the post in my RSS feed. :) I started reading and was really impressed by the depth and liked the approach of comparing directly with possible optimizations. Then I saw how long it is.^^ Given my backlog, I estimate I won't have time to read it this week-end. I hope I can read it next week-end.</p>",
        "id": 232075305,
        "sender_full_name": "RalfJ",
        "timestamp": 1616834449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232030183\">said</a>:</p>\n<blockquote>\n<p>even though Im not sure if its entirely coherent (given that you can attach <code>UnsafeCell</code> to only <em>part</em> of a memory block youve allocated)</p>\n</blockquote>\n<p>I think that's pretty clear -- a deallocation is like a write <em>to the entire allocation</em>. That should make it coherent pretty easily, no?</p>",
        "id": 232075383,
        "sender_full_name": "RalfJ",
        "timestamp": 1616834542
    },
    {
        "content": "<p>And I think that's enough for <code>Arc</code> -- AFAIK the only \"must stay alive\" references we have there are <code>&amp;AtomicUsize</code>, not <code>&amp;ArcInner</code></p>",
        "id": 232075430,
        "sender_full_name": "RalfJ",
        "timestamp": 1616834639
    },
    {
        "content": "<blockquote>\n<p>Having an API to atomically mutate a *const Inner is useful to have in general, especially for FFI which doesn't use atomic types.</p>\n</blockquote>\n<p>Sure, but what is not clear is if that API should ever be <em>required</em>. If we go with \"mutable memory can be deallocated\", then is it the case that one can implement the raw API by turning <code>*const Inner</code> to <code>&amp;AtomicUsize</code> and using the reference-based API? I think so.</p>",
        "id": 232075591,
        "sender_full_name": "RalfJ",
        "timestamp": 1616834793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232075383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232030183\">said</a>:</p>\n<blockquote>\n<p>even though Im not sure if its entirely coherent (given that you can attach <code>UnsafeCell</code> to only <em>part</em> of a memory block youve allocated)</p>\n</blockquote>\n<p>I think that's pretty clear -- a deallocation is like a write <em>to the entire allocation</em>. That should make it coherent pretty easily, no?</p>\n</blockquote>\n<p>But this is in the context of a claim that a <code>&amp;UnsafeCell&lt;T&gt;</code> (or <code>&amp;mut T</code>?) gives you access to mutate and maybe deallocate the <code>T</code>; if the deallocation is extends beyond the unsafe cell itself then that means that you can get a double-free by deallocating a <code>&amp;mut (T, T)</code> twice via its two projections</p>",
        "id": 232130876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616893717
    },
    {
        "content": "<blockquote>\n<p>But this is in the context of a claim that a &amp;UnsafeCell&lt;T&gt; (or &amp;mut T?) gives you access to mutate and maybe deallocate the T; if the deallocation is extends beyond the unsafe cell itself then that means that you can get a double-free by deallocating a &amp;mut (T, T) twice via its two projections</p>\n</blockquote>\n<p>I am thoroughly confused now.</p>",
        "id": 232154260,
        "sender_full_name": "RalfJ",
        "timestamp": 1616922869
    },
    {
        "content": "<p>There is no operating in Rust to deallocate the <code>T</code> part of a <code>(T, T)</code></p>",
        "id": 232154268,
        "sender_full_name": "RalfJ",
        "timestamp": 1616922893
    },
    {
        "content": "<p>I am not proposing to change that, and <code>UnsafCell</code> does not change that.</p>",
        "id": 232154269,
        "sender_full_name": "RalfJ",
        "timestamp": 1616922896
    },
    {
        "content": "<p>I am just say that when something is deallocated (which is inherently going to be an entire allocated object, not just a part of it), then the entire deallocated memory range must be writable through the pointer you are using for deallocation.</p>",
        "id": 232154296,
        "sender_full_name": "RalfJ",
        "timestamp": 1616922931
    },
    {
        "content": "<p>deallocation, just like reads and writes, is an operation on <em>memory ranges</em>, not just individual addresses. clearly, reading 2 bytes starting at ptr <code>p</code> is very different from reading 4 bytes starting at ptr <code>p</code>.</p>",
        "id": 232154359,
        "sender_full_name": "RalfJ",
        "timestamp": 1616922994
    },
    {
        "content": "<p>From all of the above it follows that <code>UnsafeCell&lt;T&gt;</code> gives you access to deallocate the <code>T</code> <em>and just the <code>T</code></em>. If the allocated object is larger than the <code>T</code>, then you may not deallocate the rest of the allocated object. in practice this means you cannot deallocate the <code>T</code> either, but that is not a consequence of the aliasing rules (they are being very reasonable and compositional here), it is a consequence of the allocator API which does not permit deallocating a part of an allocated object.</p>",
        "id": 232154444,
        "sender_full_name": "RalfJ",
        "timestamp": 1616923107
    },
    {
        "content": "<p>In that case, isn't this \"permission to deallocate\" a bit useless? In particular, it doesn't validate the <code>Arc</code> functions</p>",
        "id": 232158347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616927776
    },
    {
        "content": "<p>it does validate the <code>Arc</code> functions</p>",
        "id": 232158472,
        "sender_full_name": "RalfJ",
        "timestamp": 1616927964
    },
    {
        "content": "<p>the only reference that is still alive and potentially in conflict with the deallocation is the <code>&amp;AtomicUsize</code> of other thread that just did their last decrement</p>",
        "id": 232158479,
        "sender_full_name": "RalfJ",
        "timestamp": 1616927990
    },
    {
        "content": "<p>the reason that reference is a problem is that its item in the borrow stack is protected, so it may not be removed from the stack while the function associated with the item still runs (that function is <code>compare_exchange</code> or whatever atomic op is doing the decrement)</p>",
        "id": 232158558,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928048
    },
    {
        "content": "<p>I thought the <code>&amp;Arc&lt;T&gt;</code> (and possibly the <code>&amp;ArcInner&lt;T&gt;</code> as well) are being held in locals up the call stack</p>",
        "id": 232158585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616928096
    },
    {
        "content": "<p>but the item is a <code>SharedReadWrite</code>, so it is completely fine with mutation</p>",
        "id": 232158588,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928102
    },
    {
        "content": "<p>those locals are never used again and their borrow stack items are not protected so that's fine</p>",
        "id": 232158590,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928110
    },
    {
        "content": "<p>also <code>&amp;Arc</code> doesnt even point to the same allocation so it is irrelevant here</p>",
        "id": 232158629,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928124
    },
    {
        "content": "<p>But that does mean that the <code>&amp;ArcInner&lt;T&gt;</code> refcount decrease can't be put in a function, right?</p>",
        "id": 232158668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616928224
    },
    {
        "content": "<p>because then it would also be protected</p>",
        "id": 232158692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616928238
    },
    {
        "content": "<p>there <em>would</em> be a problem if we added an extra method</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">do_decrement</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">ArcInner</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">fetch_sub</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and called that from <code>drop_slow</code> (instead of directly calling <code>fetch_sub</code> or whatever). this is a problem because then there'd be a <code>&amp;ArcInner</code> pointer with protected items on the borrow stack, and some of those items (the one covering the <code>T</code>) are <em>not</em> okay with writes since they are <code>SharedReadOnly</code></p>",
        "id": 232158732,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928245
    },
    {
        "content": "<p>yes we were typing concurrently ;)</p>",
        "id": 232158744,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928260
    },
    {
        "content": "<p>but there'd also be a fix here -- use <code>NonNull</code> (or raw ptrs or so) instead of <code>&amp;</code></p>",
        "id": 232158762,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928300
    },
    {
        "content": "<p>I never said this wasn't subtle. ;)</p>",
        "id": 232158994,
        "sender_full_name": "RalfJ",
        "timestamp": 1616928542
    },
    {
        "content": "<p>Hm, this seems to solve the problem. +1 from me</p>",
        "id": 232158999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616928545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232158732\">said</a>:</p>\n<blockquote>\n<p>there <em>would</em> be a problem if we added an extra method</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">do_decrement</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">ArcInner</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">fetch_sub</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and called that from <code>drop_slow</code> (instead of directly calling <code>fetch_sub</code> or whatever). this is a problem because then there'd be a <code>&amp;ArcInner</code> pointer with protected items on the borrow stack, and some of those items (the one covering the <code>T</code>) are <em>not</em> okay with writes since they are <code>SharedReadOnly</code></p>\n</blockquote>\n<p>The blog post tries to tease out these distinctions by making an explicit matrix covering them. Id like to know whether I got it right nor not.</p>",
        "id": 232365393,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617072406
    },
    {
        "content": "<p>Namely, I <em>think</em> you are describing <a href=\"http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/#Version.2:..inner-ref.handled.out-of-line.\">version 2</a> as problematic. But I think that you are also saying that <a href=\"http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/#Version.4:..atomic-ref.handled.out-of-line.\">version 4</a> is <strong>not</strong> problematic.</p>",
        "id": 232365714,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617072671
    },
    {
        "content": "<p>Which may mean that you are saying <a href=\"http://blog.pnkfx.org/blog/2021/03/25/how-to-dismantle-an-atomic-bomb/#Option.4..Put.deallocation.on.same.footing.as.mutation\">Option 4</a> in my blog post would work. (Specifically 4A i think)</p>",
        "id": 232365871,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617072824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> at this point Im doing my expurgated version of the blog post here: <a href=\"https://hackmd.io/p0sspE8pSSSfBuLV0EwIlw\">https://hackmd.io/p0sspE8pSSSfBuLV0EwIlw</a></p>",
        "id": 232367708,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617074440
    },
    {
        "content": "<p>Sounds good. I expect to devote an hour tomorrow to this, likely in the morning, FWIW - not sure how much I'll be able to get done, but can help clean things up or get them into better shape, at least, or draft some additional explanations/thinking.</p>",
        "id": 232367848,
        "sender_full_name": "simulacrum",
        "timestamp": 1617074534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232075383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232030183\">said</a>:</p>\n<blockquote>\n<p>even though Im not sure if its entirely coherent (given that you can attach <code>UnsafeCell</code> to only <em>part</em> of a memory block youve allocated)</p>\n</blockquote>\n<p>I think that's pretty clear -- a deallocation is like a write <em>to the entire allocation</em>. That should make it coherent pretty easily, no?</p>\n</blockquote>\n<p>As in: If you <em>do</em> have a <code>&amp;ArcInner</code> lying around when the deallocation happens, then thats breaking the rules, right? It needs to be narrowed to just the <code>&amp;AtomicUsize</code>, because you need to narrow the scope of the reference that overlaps to the write to just the thing that is a trivial wrapper around <code>UnsafeCell</code> ?</p>",
        "id": 232368540,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617075117
    },
    {
        "content": "<p>This seems pretty good -- I think I'm happy to try to go for it in the meeting tomorrow.</p>",
        "id": 232427185,
        "sender_full_name": "simulacrum",
        "timestamp": 1617111818
    },
    {
        "content": "<p>Btw, just wanted to thank you <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> for that blog post you published; I had somehow inferred the issues at had out of random fragments out of this very lengthy topic, but your blog post very clearly curated the information in a well-ordered manner <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 232451339,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617120229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232368540\">said</a>:</p>\n<blockquote>\n<p>As in: If you <em>do</em> have a <code>&amp;ArcInner</code> lying around when the deallocation happens, then thats breaking the rules, right? It needs to be narrowed to just the <code>&amp;AtomicUsize</code>, because you need to narrow the scope of the reference that overlaps to the write to just the thing that is a trivial wrapper around <code>UnsafeCell</code> ?</p>\n</blockquote>\n<p>It is okay if the <code>&amp;ArcInner</code> is in a local variable that is never used again, because these are not \"stack-protected\" and so they can become invalid before drop (because they have no drop glue). But if the <code>&amp;ArcInner</code> is a function parameter, then it is stack-protected, meaning that it has to be valid until the end of the function, even if it is never used again in either this function or the caller.</p>",
        "id": 232456080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617121988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232368540\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232075383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232030183\">said</a>:</p>\n<blockquote>\n<p>even though Im not sure if its entirely coherent (given that you can attach <code>UnsafeCell</code> to only <em>part</em> of a memory block youve allocated)</p>\n</blockquote>\n<p>I think that's pretty clear -- a deallocation is like a write <em>to the entire allocation</em>. That should make it coherent pretty easily, no?</p>\n</blockquote>\n<p>As in: If you <em>do</em> have a <code>&amp;ArcInner</code> lying around when the deallocation happens, then thats breaking the rules, right? It needs to be narrowed to just the <code>&amp;AtomicUsize</code>, because you need to narrow the scope of the reference that overlaps to the write to just the thing that is a trivial wrapper around <code>UnsafeCell</code> ?</p>\n</blockquote>\n<p>yes, basically. the <code>&amp;ArcInner</code> becomes invalid at that point (and if it is protected, that's immediate UB; else its just UB if its used again)</p>",
        "id": 232456759,
        "sender_full_name": "RalfJ",
        "timestamp": 1617122245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232427185\">said</a>:</p>\n<blockquote>\n<p>This seems pretty good -- I think I'm happy to try to go for it in the meeting tomorrow.</p>\n</blockquote>\n<p>I just realized that meeting overlaps with the \"social event\" at ETAPS :/</p>",
        "id": 232456824,
        "sender_full_name": "RalfJ",
        "timestamp": 1617122272
    },
    {
        "content": "<p>\"an escape game social event\", sounds interesting...</p>",
        "id": 232456991,
        "sender_full_name": "RalfJ",
        "timestamp": 1617122346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> the point youre making about the impact of stack-protection on the local-variable vs function parameter question: Thats a property that comes from stacked borrows, right? Am I correct in inferring that the semantics there has no notion of inlining? (In the sense that if inlining does happen, it is an implementation detail, and cannot affect the semantic rules being described.)</p>",
        "id": 232459213,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123206
    },
    {
        "content": "<p>That's a good question. I think you can recover inlining by inserting a fake read after the function body when performing an inlining operation</p>",
        "id": 232459563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617123323
    },
    {
        "content": "<p>It sounds like theres some variant that I have failed to describe in my write-up, where the out-of-line <code>&amp;Inner</code> decrement is not okay, but the other three quadrants of the matrix are all okay.</p>",
        "id": 232459623,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123341
    },
    {
        "content": "<p>Ill make sure to include that in my doc for the design meeting tomorrow.</p>",
        "id": 232459761,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123383
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> is there a way to introduce a stack protector besides a function call? I.e. is there some way to make the local variable treated the same way as the function parameter?</p>",
        "id": 232459922,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123434
    },
    {
        "content": "<p>Although I think this doesn't affect the validity of inlining but rather outlining - the UB is introduced by adding a stack protector, not by removing one</p>",
        "id": 232459966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617123450
    },
    {
        "content": "<p>(Maybe that is what you are saying when you are suggesting inserting a fake read after the function body when inlining...)</p>",
        "id": 232459977,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123453
    },
    {
        "content": "<p>(Okay correction, sounds like the fake read doesnt insert a protector)</p>",
        "id": 232460181,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123512
    },
    {
        "content": "<p>I believe the effect of a stack protector is the same as inserting a read of all the parameters in the function epilogue</p>",
        "id": 232460186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617123514
    },
    {
        "content": "<p>Heh Im really ping-ponging here.</p>",
        "id": 232460239,
        "sender_full_name": "pnkfelix",
        "timestamp": 1617123538
    },
    {
        "content": "<p>so for the same reason that you can drop a dead read, you can also inline a function, but you can't necessarily reverse that - insert a read or outline a function</p>",
        "id": 232460385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617123588
    },
    {
        "content": "<p>(you being the compiler)</p>",
        "id": 232460498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617123610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232459922\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> is there a way to introduce a stack protector besides a function call? I.e. is there some way to make the local variable treated the same way as the function parameter?</p>\n</blockquote>\n<p>no, not currently.</p>",
        "id": 232557632,
        "sender_full_name": "RalfJ",
        "timestamp": 1617181419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232460186\">said</a>:</p>\n<blockquote>\n<p>I believe the effect of a stack protector is the same as inserting a read of all the parameters in the function epilogue</p>\n</blockquote>\n<p>no, it is not. the stack protector is stronger, since it causes <em>immediate</em> UB to invalidate them.<br>\nyou cannot simulate this with a read of all parameters at the end since the function might never return, so those reads might never happen.</p>",
        "id": 232557754,
        "sender_full_name": "RalfJ",
        "timestamp": 1617181475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Whither.20*Atomic.20API.20duplication/near/232460385\">said</a>:</p>\n<blockquote>\n<p>so for the same reason that you can drop a dead read, you can also inline a function, but you can't necessarily reverse that - insert a read or outline a function</p>\n</blockquote>\n<p>correct. (or rather, when you do outlining, you have to generate a function that doesn't add stack protectors. in MIR this is possible; surface Rust doesn't have syntax for that. this would also have to affect the LLVM attributes emitted for this function, which is not currently implemented.)</p>",
        "id": 232557822,
        "sender_full_name": "RalfJ",
        "timestamp": 1617181511
    }
]