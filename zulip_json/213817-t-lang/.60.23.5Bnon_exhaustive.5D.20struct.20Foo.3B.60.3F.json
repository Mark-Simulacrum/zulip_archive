[
    {
        "content": "<p>I noticed today that there's <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=dc00152baa4fa43c530bcf625ed3897c\">no warning</a> for </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Should there be?  It feels weird to use unit struct syntax but say \"but there might be more later\".  And I'm not actually sure what that implies for the visibility of the <code>const</code> that syntax generates.  Can people still use it?</p>",
        "id": 258418167,
        "sender_full_name": "scottmcm",
        "timestamp": 1634754208
    },
    {
        "content": "<p>The <code>const</code> it generates becomes private.</p>",
        "id": 258435080,
        "sender_full_name": "Eric Huss",
        "timestamp": 1634760335
    },
    {
        "content": "<p>Filed <a href=\"https://github.com/rust-lang/reference/issues/1097\">https://github.com/rust-lang/reference/issues/1097</a> to clarify the documentation around that.</p>",
        "id": 258437049,
        "sender_full_name": "Eric Huss",
        "timestamp": 1634761106
    },
    {
        "content": "<p>Interesting! So that makes the type public but the value of that type private?</p>",
        "id": 258441033,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634762646
    },
    {
        "content": "<p>Yea, lowered to <code>pub(crate)</code>.  It's the same with tuple constructors.</p>",
        "id": 258441794,
        "sender_full_name": "Eric Huss",
        "timestamp": 1634762957
    },
    {
        "content": "<p>i've definitely used <code>#[non_exhaustive] pub struct Foo;</code> as a better version of <code>pub struct Foo { _priv: () }</code></p>",
        "id": 258461103,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1634772790
    },
    {
        "content": "<p>Why not <code>#[non_exhaustive] pub struct Foo {}</code>?</p>",
        "id": 258461154,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634772837
    },
    {
        "content": "<p>just because i don't need the <code>{}</code></p>",
        "id": 258462115,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1634773499
    },
    {
        "content": "<p>e.g. it still works as <code>pub struct Foo;</code></p>",
        "id": 258462136,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1634773515
    },
    {
        "content": "<p>Oh so you are using <code>#[non_exhaustive]</code> to mean the type shouldn't be constructed by the user, but you actually don't intend to add any field in the future?</p>",
        "id": 258463300,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634774219
    },
    {
        "content": "<p>That sounds like abusing <code>#[non_exhaustive]</code> ;)</p>",
        "id": 258463330,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634774244
    },
    {
        "content": "<p><strong><code>pub struct Foo(());</code> crying in a corner</strong></p>",
        "id": 258836442,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1635013533
    },
    {
        "content": "<p>Often they're error types for TryFrom/FromStr/etc cases. In principal I could add more stuff to them, but for the most part it's unlikely.</p>",
        "id": 258841831,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635021956
    },
    {
        "content": "<p>I don't think its really abusing non_exhaustive though.</p>",
        "id": 258841875,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1635021974
    },
    {
        "content": "<p>Btw this is even used by the stdlib: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// An error returned when parsing a `bool` using [`from_str`] fails</span>\n<span class=\"sd\">///</span>\n<span class=\"sd\">/// [`from_str`]: super::FromStr::from_str</span>\n<span class=\"cp\">#[derive(Debug, Clone, PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"cp\">#[stable(feature = </span><span class=\"s\">\"rust1\"</span><span class=\"cp\">, since = </span><span class=\"s\">\"1.0.0\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ParseBoolError</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://doc.rust-lang.org/std/str/struct.ParseBoolError.html\">https://doc.rust-lang.org/std/str/struct.ParseBoolError.html</a></p>",
        "id": 260394793,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1636112767
    },
    {
        "content": "<p>Yeah, I consider this usage to be idiomatic, and have filed a previous PR to that effect.</p>",
        "id": 260467365,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1636147937
    },
    {
        "content": "<p>I guess I would have written that as <code>#[non_exhaustive] pub struct ParseBoolError {}</code>, but I suppose it's reasonable with the <code>;</code> too.</p>",
        "id": 260474180,
        "sender_full_name": "scottmcm",
        "timestamp": 1636152831
    },
    {
        "content": "<p>My assumption is that it doesn't make a difference? I've never actually checked</p>",
        "id": 260482328,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1636160728
    },
    {
        "content": "<p>makes a difference in how you construct it. the construction has to include the braces (or not) depending on if the declaration does.</p>",
        "id": 260485843,
        "sender_full_name": "Lokathor",
        "timestamp": 1636164660
    },
    {
        "content": "<p>Sure, I meant externally though</p>",
        "id": 260518489,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1636210991
    },
    {
        "content": "<p>To me the semantics of <code>#[non_exhaustive] struct Foo;</code> are quite ambiguous; it could mean:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Foo</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{};</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>as the RFC author seemed to interpret it;</li>\n</ul>\n<p>but it would also be perfectly valid for it to mean:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Foo</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And the latter is actually, if not more, at least as consistent as the RFC's author choice, since the original rationale behind <code>#[non_exhaustive]</code>'s design —as the name indicates—, is <strong>to consider a lack of non-<code>pub</code> fields to be <code>pub(crate)</code></strong>.</p>\n<p>And <strong>having an eponymous <code>const</code> is an orthogonal question to that of field visibility!</strong></p>\n<ul>\n<li>So <code>Foo {}</code> or any kind of <code>Foo {}</code>-based mechanic would be forbidden, but the <code>Foo</code> const would still be available.</li>\n</ul>\n<p>That is, it would allow for the following kind of non-semver-breaking addition:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"n\">a_field</span>: <span class=\"err\">…</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Foo</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a_field</span>: <span class=\"o\">&lt;</span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">provide</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"k\">const</span><span class=\"err\">`</span><span class=\"o\">-</span><span class=\"n\">compatible</span><span class=\"w\"> </span><span class=\"n\">initializer</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Granted, having to future-anticipate that we'd remain <code>const</code>-constructible can be quite challenging, which I guess is the main reason to end up entangling the eponymous const question with that of field visibility, but I find it to be a code smell in either case. I'll definitely make these be linted with my own custom pass, to be sure.</p>\n<p>Another way of seeing the <code>non_exhaustive</code> unit case as alien, is with an imaginary <code>pub(crate) ∅</code> syntax that would represent the desired / intuitive semantics of <code>#[non_exhaustive]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">A</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// means</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">A</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"err\">∅</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- usable with braced syntax</span>\n\n<span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// means</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">crate</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"err\">∅</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- Usable with parens</span>\n\n<span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// where to put the `pub(crate) ∅` ??</span>\n</code></pre></div>\n<p>That is, how can we say that some enumeration/sequence of elements is non-exhaustive when there is no enumeration to begin with?</p>",
        "id": 260659179,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636379681
    }
]