[
    {
        "content": "<p>I'm writing the ahead-of-meeting notes for this Wednesday's design meeting in <a href=\"https://hackmd.io/JdKPGA2eQ_qSX13pQeKoNg\">https://hackmd.io/JdKPGA2eQ_qSX13pQeKoNg</a></p>",
        "id": 265549828,
        "sender_full_name": "oli",
        "timestamp": 1639999079
    },
    {
        "content": "<p>I am not entirely sure what you meant by \"many open questions around trait objects and fn ptrs\" for option three. Are you talking about the same problems for const trait impls? i.e. how to specify a const fn ptr with the <code>const_heap</code> \"effect\", how to specify traits with methods that use the <code>const_heap</code> \"effect\" etc? This point should be clarified more IMO.</p>",
        "id": 265564156,
        "sender_full_name": "fee1-dead",
        "timestamp": 1640007929
    },
    {
        "content": "<p>you're right, that was very negatively formulated, I now wrote</p>\n<blockquote>\n<p>open question (like with const fn calls in general): how do we handle  trait objects method calls and fn ptr calls with this?</p>\n</blockquote>",
        "id": 265566331,
        "sender_full_name": "oli",
        "timestamp": 1640008813
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> will you be able to attend, in that case?</p>",
        "id": 265716649,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640109981
    },
    {
        "content": "<p>I will be there, yes.</p>",
        "id": 265717129,
        "sender_full_name": "oli",
        "timestamp": 1640110253
    },
    {
        "content": "<p>The doc is just so we have a written overview. We can dig into details in questions</p>",
        "id": 265717207,
        "sender_full_name": "oli",
        "timestamp": 1640110308
    },
    {
        "content": "<p>seems good, we were thinking the framing is more \"overview of where const eval is at\"</p>",
        "id": 265717284,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640110327
    },
    {
        "content": "<p>I'll make a calendar invite</p>",
        "id": 265717298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640110335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span> (are you available too?)</p>",
        "id": 265717316,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640110344
    },
    {
        "content": "<p>Yea, but we also have two things we'd like to explain so you can FCP it xD</p>",
        "id": 265717385,
        "sender_full_name": "oli",
        "timestamp": 1640110393
    },
    {
        "content": "<p>Filed <a href=\"https://github.com/rust-lang/lang-team/issues/131\">https://github.com/rust-lang/lang-team/issues/131</a> and created a calendar invite</p>",
        "id": 265719491,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640111643
    },
    {
        "content": "<p>I'll be in attendance as well, since I was involved in <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstSafe.60.20and.20bitwise.20copies/near/179959089\">some of the initial discussions</a>. Many thanks to <span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> for writing the MCP, as well as all the const trait impl work they've done. Due to their work, we're quite close to being able to do some really interesting stuff at compile-time in an ergonomic way (no serialization from a build script). <code>impl const Iterator for Range&lt;usize&gt;</code> is going to be a huge boon.</p>\n<p>One point I'd like to make about heap allocation is that the \"effect\" to allow it should go the other way (<code>#[const_no_heap]</code>). The issue here is functions that return a <strong>value</strong> that is known to always be bitwise copyable of a <strong>type</strong> that is not. However, this case is actually pretty rare—basically only for default/sentinel values—so most functions would require <em>both</em> <code>const</code> and <code>#[const_heap]</code>. <code>#[const_heap]</code> is easier to make backwards compatible, but we should be able to do <code>#[const_no_heap]</code> across an edition boundary if we're careful here.</p>\n<p>I haven't thought too much about the special const allocator. That seems promising as well, although I'm not sure how fun it is to use custom allocators at the moment.</p>\n<p>Another issue is mutable references in the final value of a constant. This should not be allowed. It can cause UB in safe code because constants are bitwise copied whenever they are used (this is the same underlying issue as for things with heap allocations btw, we are bitwise copying things that aren't copy). We're fine for now, since mutable reference (or shared references to types with interior mutability) are forbidden in a const context (except on nightly), but this restriction is <em>really</em> annoying and lifting it is likely a prerequisite for transient heap allocations to be useful. I think we'll need to use the \"value-based analysis\" from const qualification for this, since we already allow stuff like <code>const X: Option&lt;&amp;mut u32&gt; = None;</code>.</p>",
        "id": 265728923,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640117342
    },
    {
        "content": "<p>Also, I agree with Ralf that \"effect\" isn't really the right term. <code>#[const_no_heap]</code> is just about guaranteeing that the return value of a function is bitwise copyable. We know that's the case because no heap allocations took place during the function call (although there's other ways for non-<code>Copy</code> types to cause problems when copied, I don't think anything besides <code>&amp;mut</code> is an issue in a const-context).</p>",
        "id": 265730615,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640118470
    },
    {
        "content": "<p>You could also imagine an <code>#[unsafe_return_value_bitwise_copyable]</code>, which doesn't do any additional checks, that gets added to <code>Vec::new()</code> and friends. I think that's not a good idea because we want users to be able to define const default constructors for their containers, and we don't have precedent for publicly exposed attributes allowing unsafety as far as I know.</p>",
        "id": 265730866,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640118602
    },
    {
        "content": "<p>Oh, and one more question re: the allocator proposal. If we have <code>const X: Vec&lt;i32&gt; = vec![2];</code> where we've used a custom allocator that never deallocates, what happens when we do <code>X.push()</code>at runtime? Presumably we would clone <code>X</code> onto the heap, but that seems difficult within the current allocator framework (though maybe not with <code>const_eval_select</code>?). I think I prefer just emulating the default allocator when in a const context and forcing people to <code>leak</code> containers with interesting results instead of returning  the container itself by value.</p>",
        "id": 265731227,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640118839
    },
    {
        "content": "<p>We don't want to allow <code>const X: Vec&lt;i32&gt;</code> to be built from a heap allocation at all. We'd allow <code>const X: Vec&lt;i32, ConstAlloc&gt;</code>, which never deallocates, so bit copying those vecs is fine.</p>",
        "id": 265731598,
        "sender_full_name": "oli",
        "timestamp": 1640119070
    },
    {
        "content": "<p>If we allow <code>Vec&lt;T, GlobalAlloc&gt;</code> beyond <code>Vec::new</code>, then we need the const_heap attribute or some variant of it</p>",
        "id": 265731787,
        "sender_full_name": "oli",
        "timestamp": 1640119178
    },
    {
        "content": "<p>I left that attribute as the last part of the meeting, as it requires the most discussion and I want to give the overview and two other topics some time</p>",
        "id": 265731928,
        "sender_full_name": "oli",
        "timestamp": 1640119266
    },
    {
        "content": "<p>Its details are in the MCP linked at the top of the doc</p>",
        "id": 265731952,
        "sender_full_name": "oli",
        "timestamp": 1640119291
    },
    {
        "content": "<p>I just read <a href=\"https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/\">https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/</a> and am wondering if that could give us the very thing we want. Libraries don't have to change their allocator or become generic, but users can inject the const allocator</p>",
        "id": 265733072,
        "sender_full_name": "oli",
        "timestamp": 1640120103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265731598\">said</a>:</p>\n<blockquote>\n<p>We don't want to allow <code>const X: Vec&lt;i32&gt;</code> to be built from a heap allocation at all. We'd allow <code>const X: Vec&lt;i32, ConstAlloc&gt;</code>, which never deallocates, so bit copying those vecs is fine.</p>\n</blockquote>\n<p>I omitted the extra parameter in my example, but that's what my question about <code>push</code> was referring to. What happens when we call <code>X.push()</code> at runtime for the <code>ConstAlloc</code> parameterized one?</p>",
        "id": 265734390,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640120920
    },
    {
        "content": "<p>Also, what happens if we do the following (once again, assume <code>X</code> is parameterized with <code>ConstAlloc</code>)?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">get_mut</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">get_mut</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"o\">*</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265734939,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> ^ (I don't have notifications for this channel, so ping me if you respond)</p>",
        "id": 265735058,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121326
    },
    {
        "content": "<p>The push will reallocate, so yea, you get a clone and add to that. The const allocator never frees, it just allocates, so you will waste a lot of memory at runtime that way</p>",
        "id": 265735205,
        "sender_full_name": "oli",
        "timestamp": 1640121420
    },
    {
        "content": "<p>Oof. Good point on the owned mutation</p>",
        "id": 265735232,
        "sender_full_name": "oli",
        "timestamp": 1640121440
    },
    {
        "content": "<p>Yeah, <code>Box</code> and <code>Vec</code> are similar to <code>&amp;mut</code> in the respect that they allow safe code to create a  mutable reference into memory that is <em>not</em> copied when the const is read.</p>",
        "id": 265735344,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121520
    },
    {
        "content": "<p>I guess we do need to treat Vec as we do &amp;mut... yea that...</p>",
        "id": 265735406,
        "sender_full_name": "oli",
        "timestamp": 1640121574
    },
    {
        "content": "<p>Damn and here I thought ConstAlloc was straightforward</p>",
        "id": 265735437,
        "sender_full_name": "oli",
        "timestamp": 1640121600
    },
    {
        "content": "<p>I guess even for that we need ConstSafe and ConstRefSafe</p>",
        "id": 265735523,
        "sender_full_name": "oli",
        "timestamp": 1640121621
    },
    {
        "content": "<p>I'm also a little confused about <code>ConstRefSafe</code>. Is it ever any different from <code>Freeze</code>? It seems like it only matters for things with interior mutability.</p>",
        "id": 265735682,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121730
    },
    {
        "content": "<p>I guess if you include raw pointers in the list of things that aren't <code>ConstRefSafe</code>, but I've given up trying to enforce this stuff in the presence of unsafe code.</p>",
        "id": 265735804,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121811
    },
    {
        "content": "<p>Hmm... I need to read up before tomorrow's meeting. I don't remember the details xD</p>",
        "id": 265735843,
        "sender_full_name": "oli",
        "timestamp": 1640121837
    },
    {
        "content": "<p>But maybe this capabilities stuff can really safe our hide here. If we only allow scoped allocators, you can't really leak the value. That should give us transient heap</p>",
        "id": 265735931,
        "sender_full_name": "oli",
        "timestamp": 1640121891
    },
    {
        "content": "<p>I think it's enough to say that attempting to mutate that was allocated during const-eval is UB, and to ensure that it can't happen in purely safe code.</p>",
        "id": 265735948,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121900
    },
    {
        "content": "<p>Right</p>",
        "id": 265735974,
        "sender_full_name": "oli",
        "timestamp": 1640121913
    },
    {
        "content": "<p>I'll read tmandry's post.</p>",
        "id": 265735975,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640121914
    },
    {
        "content": "<p>But users may have written safe abstractions containing raw pointers, and I don't want to just push new kinds of UB that aren't that outside of const contexts. People should safely be able to slap const on a function and if it wasn't UB before, it shouldn't be now</p>",
        "id": 265736168,
        "sender_full_name": "oli",
        "timestamp": 1640122040
    },
    {
        "content": "<p>That's why I worry about raw pointers in people's abstractions</p>",
        "id": 265736231,
        "sender_full_name": "oli",
        "timestamp": 1640122080
    },
    {
        "content": "<p>We can vet libstd, but if we create a new source of UB footguns, then that's bad</p>",
        "id": 265736304,
        "sender_full_name": "oli",
        "timestamp": 1640122111
    },
    {
        "content": "<p>It doesn't seem that bad to me. Everything will still work at compile-time (assuming the existing validity invariants are upheld). The only issue is calling that function at runtime while passing it a pointer to something that was created at compile-time. All we would be saying is that such pointers can't be written to. In other words, if you have a function that writes through a raw pointer, it requires that that raw pointer is valid for writes. Pointers into <code>.rodata</code> aren't valid for writes.</p>",
        "id": 265736910,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640122494
    },
    {
        "content": "<p>But the only alternative I've been considering is escape analysis. Perhaps there's something different? I dunno.</p>",
        "id": 265737497,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640122648
    },
    {
        "content": "<p>The c&amp;c proposal could also give us an easy way to check non-transient heap allocations. We could allow the trailing expression of const contexts (other than const fn) to be a <code>with</code> block that registers a ConstAlloc as the global allocator, and then run fee1-dead's analysis assuming all calls heap allocate. Pessimistic, but you can always convert a box into a reference and a vec into a slice and everything is peachy</p>",
        "id": 265737581,
        "sender_full_name": "oli",
        "timestamp": 1640122704
    },
    {
        "content": "<p>That requires no attribute, is backcompat and doesn't have issues with mutation</p>",
        "id": 265737673,
        "sender_full_name": "oli",
        "timestamp": 1640122791
    },
    {
        "content": "<p>Only hacky thing would be the <code>ConstAlloc</code> not being mentionable elsewhere</p>",
        "id": 265737756,
        "sender_full_name": "oli",
        "timestamp": 1640122831
    },
    {
        "content": "<p>I was just about to ask about mutation. How would what you're thinking about handle the <code>get_mut</code> example above?</p>",
        "id": 265737774,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640122850
    },
    {
        "content": "<p>Which one? for transient or non-transient?</p>",
        "id": 265737832,
        "sender_full_name": "oli",
        "timestamp": 1640122897
    },
    {
        "content": "<p>non-transient (I think?)</p>",
        "id": 265737849,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640122920
    },
    {
        "content": "<p>Right. The mcp suggests an analysis run on const contexts other than functions that ensures all owned values are behind references and freeze or are created via functions that aren't annotated with the effect attribute</p>",
        "id": 265737992,
        "sender_full_name": "oli",
        "timestamp": 1640123016
    },
    {
        "content": "<p>Thus any <code>&amp;mut X</code> or equivalent at runtime would result in a <code>&amp;mut &amp;Vec&lt;T&gt;</code> or similar</p>",
        "id": 265738175,
        "sender_full_name": "oli",
        "timestamp": 1640123124
    },
    {
        "content": "<p>Oh, interesting, so we would implicitly add a reference? Or are you just saying that we forbid <code>const X: Vec&lt;u32&gt;</code> unless the initializer is not <code>#[const_heap]</code>?</p>",
        "id": 265738319,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640123214
    },
    {
        "content": "<p>Yes, that is what the mcp suggests</p>",
        "id": 265738350,
        "sender_full_name": "oli",
        "timestamp": 1640123238
    },
    {
        "content": "<p>I assumed the second one, but then I don't quite understand where c&amp;c fits it. Probably good to talk it out tomorrow.</p>",
        "id": 265738376,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640123257
    },
    {
        "content": "<p>And my c&amp;c idea would do the same, but without an attribute</p>",
        "id": 265738385,
        "sender_full_name": "oli",
        "timestamp": 1640123267
    },
    {
        "content": "<p>One more thing, does reversing the polarity of <code>#[const_heap]</code> appeal to you? Unfortunately we're at a bad time to plan an edition-gated change. The idea would be to make <code>#[const_heap]</code> the (implicit) default in edition 2024 and apply<code>#[const_no_heap]</code>to a subset of existing const fn during migration.</p>",
        "id": 265738886,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640123573
    },
    {
        "content": "<p>Obviously that assumes that we end up using an attribute, which is not decided.</p>",
        "id": 265738916,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640123594
    },
    {
        "content": "<p>The subset being const fn that return types which are <code>!Copy</code> (or maybe <code>!NeedsDrop</code>?).</p>",
        "id": 265739190,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640123799
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>)<br>\nFWIW, since this is all about bit-copy-ing (<em>e.g.</em>, <code>&amp;mut</code> suffers from these issues as well (and while a <code>&amp;mut</code> to a non-zero span of memory can only be obtained, in safe code, through heap allocs (+ leaking), the <code>&amp;mut</code> itself final result is a type that has become allocator agnostic; hence why it's not really about \"a const allocator\")).</p>\n<p>I suggested a copy-focused approach in <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Heap.20allocations.20in.20constants.20lang-team.23129/near/263299173\">https://rust-lang.zulipchat.com/#narrow/stream/243200-t-lang.2Fmajor-changes/topic/Heap.20allocations.20in.20constants.20lang-team.23129/near/263299173</a>, with basically a provideable <code>unsafe impl</code> with which one could say whether <strong>a specific instance</strong> of the implementing type was safely bit-copyable:</p>\n<ul>\n<li>all instances of all <code>Copy</code> types are;</li>\n<li><code>String</code>, <code>Vec</code>, <em>etc.</em>, are, if and only if they have a null capacity;</li>\n<li>a <code>.leak()</code>ed version of the above, which ends up as a <code>&amp;'static str</code> or a <code>&amp;'static [T]</code>, would involve <code>Copy</code> types (shared references) and thus be <code>const</code>-safe as well.</li>\n</ul>\n<p>I find that approach to be quite good at covering all corner cases, and so, kind of elegant. It does involve a form of \"runtime code checking\" of the actual instance that ends up emitted by a <code>const</code> block, so it may boil down to the \"post-monomorphization errors\" unsatisfactory category? It would, however, be more satisfactory than <code>#[unsafe_return_value_bitwise_copyable]</code>, imho.</p>\n<p>Also, there seems to be a <code>Send</code> requirement as well, since the <code>Copy</code> can occur in any thread: <code>&amp;'static Cell&lt;…&gt;</code> should not be <code>const</code>-safe either</p>",
        "id": 265740482,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640124580
    },
    {
        "content": "<p>The benefit of <code>#[const_{no_,}heap]</code> (or <del>the allocator</del> Oli's c&amp;c approach) as opposed to your traits or <code>#[unsafe_return_value_is_const_safe]</code> is that we <em>know for sure</em> that there are no heap allocations in the final value of the constant. There's no unsafe like with your traits. As you point out, <code>&amp;Cell&lt;T&gt;</code> is <code>Copy</code> and also should not be allowed in the final value of a <code>const</code>, so we would couple this with a value-based analysis for references that allow mutation (<code>&amp;mut T</code>, <code>&amp;Cell&lt;T&gt;</code>, etc.) which will cover all safe code. You could still leak a <code>Box</code>, convert the <code>&amp;'static mut</code> to a raw pointer, and dereference it at runtime, but that requires <code>unsafe</code> code</p>",
        "id": 265741686,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640125358
    },
    {
        "content": "<p>Your proposal seems quite close to the checks we could implement in Miri to make sure that the final value of a const does not contain any pointers that would allow mutation, but done explicitly through the trait system, which is cool.</p>",
        "id": 265741877,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1640125514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265717316\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> (are you available too?)</p>\n</blockquote>\n<p>I would probably only be available for the first half of the meeting.</p>",
        "id": 265765949,
        "sender_full_name": "fee1-dead",
        "timestamp": 1640148439
    },
    {
        "content": "<p>OK, I'll rewrite the doc so we can start with heap</p>",
        "id": 265777901,
        "sender_full_name": "oli",
        "timestamp": 1640161981
    },
    {
        "content": "<p>My idea is wildly different, but I'm curious whether it is feasible to \"materialize\" const rvalue to ordinary rvalues, by converting the graph topology structure and relationships into allocation and memory write \"instructions\" :)</p>",
        "id": 265789616,
        "sender_full_name": "Charles Lew",
        "timestamp": 1640169679
    },
    {
        "content": "<p>Hackmd is not very mobile friendly. I wasn't able to do larger refactorings. We'll go through the doc as it is and then just start with the const heap topic. <span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span> feel free to edit the doc to reflect your MCP better. I don't think I did that properly</p>",
        "id": 265824963,
        "sender_full_name": "oli",
        "timestamp": 1640191166
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> design meeting</p>",
        "id": 265833878,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640196066
    },
    {
        "content": "<p><a href=\"https://hackmd.io/JdKPGA2eQ_qSX13pQeKoNg\">hackmd document</a></p>",
        "id": 265833899,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640196074
    },
    {
        "content": "<p>anyone who wants zoom link and doesn't have it (it's on the cal invite) ping me</p>",
        "id": 265833947,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640196099
    },
    {
        "content": "<p>Some follow-ups from the meeting:</p>",
        "id": 265840336,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640199685
    },
    {
        "content": "<p>Where is discussion about <code>~const</code> syntax happening, so that that can get addressed concurrently and not let the syntax become a blocker on future stabilization of that mechanism?</p>",
        "id": 265840451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640199742
    },
    {
        "content": "<p>I was about to open a thread here XD</p>",
        "id": 265840470,
        "sender_full_name": "oli",
        "timestamp": 1640199752
    },
    {
        "content": "<p>Also, I agree with <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span>'s point in the meeting that it'd be potentially awkward to require <em>every</em> struct to be generic over allocators (e.g. <code>struct S { v: Vec&lt;u32&gt; }</code>). I'm wondering what the right mechanism would be to simplify that.</p>",
        "id": 265840538,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640199813
    },
    {
        "content": "<p>Or, alternatively, perhaps we can make the default type parameter for <code>Vec</code> and similar be something that works in const context, as long as we have a way to handle that being the same type used at runtime?</p>",
        "id": 265840619,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640199859
    },
    {
        "content": "<p>I'm wondering if we need a convenient way to spell <code>if const context { StaticAlloc } else { GlobalAlloc }</code>.</p>",
        "id": 265840721,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640199935
    },
    {
        "content": "<p>the problem is not as much in making a \"runtime\" (guaranteed optimized out) decision, but how we could ever make such a decision in the type system itself</p>",
        "id": 265840889,
        "sender_full_name": "oli",
        "timestamp": 1640200043
    },
    {
        "content": "<p>we do already have <code>const_eval_select</code> and could create convenient syntax for that, but that's an expression, you can't make a type decision on that</p>",
        "id": 265841100,
        "sender_full_name": "oli",
        "timestamp": 1640200201
    },
    {
        "content": "<p>there is the safe transmute project that we could use to transmute from something with a <code>StaticAlloc</code> to <code>GlobalAlloc</code> if it is behind a reference</p>",
        "id": 265841255,
        "sender_full_name": "oli",
        "timestamp": 1640200301
    },
    {
        "content": "<p>I had thought there was a <code>.clone_in</code> method, but I can't seem to <em>find</em> it.</p>",
        "id": 265841328,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200330
    },
    {
        "content": "<p>but all of these schemes rely on users not creating types that erase allocators</p>",
        "id": 265841330,
        "sender_full_name": "oli",
        "timestamp": 1640200331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265841328\">said</a>:</p>\n<blockquote>\n<p>I had thought there was a <code>.clone_in</code> method, but I can't seem to <em>find</em> it.</p>\n</blockquote>\n<p>even if there were, it's not recursive/deep, so it would still be fairly annoying to use</p>",
        "id": 265841358,
        "sender_full_name": "oli",
        "timestamp": 1640200355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/265841330\">said</a>:</p>\n<blockquote>\n<p>but all of these schemes rely on users not creating types that erase allocators</p>\n</blockquote>\n<p>imagine a <code>struct GlobalBox&lt;i32&gt;(*mut i32);</code> that a user wrote that always gets initialized with <code>Box::into_raw(Box::&lt;i32, GlobalAlloc&gt;::new(42))</code>, that seems a totally reasonable type to me, but I don't see how we could ever make that work out without introducing a new kind of UB or sth.</p>",
        "id": 265841534,
        "sender_full_name": "oli",
        "timestamp": 1640200463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> The heap handling in miri could handle checking for that UB, right?</p>",
        "id": 265841734,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200583
    },
    {
        "content": "<p>sure, but for associated constants being used in generic functions, that would cause post monomorphization errors</p>",
        "id": 265841785,
        "sender_full_name": "oli",
        "timestamp": 1640200620
    },
    {
        "content": "<p>To what extent do all the problems with <code>ConstAlloc</code>/<code>StaticAlloc</code> apply equally to any <em>other</em> allocator someone might want to use?</p>",
        "id": 265841816,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200638
    },
    {
        "content": "<p>other allocators either are arenas, so fine, or call FFI, so don't work anyway</p>",
        "id": 265841857,
        "sender_full_name": "oli",
        "timestamp": 1640200663
    },
    {
        "content": "<p>Sorry, clarification:</p>",
        "id": 265841873,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200675
    },
    {
        "content": "<p>oooh</p>",
        "id": 265841929,
        "sender_full_name": "oli",
        "timestamp": 1640200691
    },
    {
        "content": "<p>yea, that's true</p>",
        "id": 265841946,
        "sender_full_name": "oli",
        "timestamp": 1640200701
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-12-22-Const-eval-update.md\">https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-12-22-Const-eval-update.md</a></p>",
        "id": 265841949,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640200702
    },
    {
        "content": "<p>I don't mean in a const context. I mean, ignoring const for a moment, wouldn't we have all the same problems about non-<code>GlobalAlloc</code> allocators being painful to use with any <code>DifferentAlloc</code> at runtime?</p>",
        "id": 265841953,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200703
    },
    {
        "content": "<p>So why don't we talk about how to make that less painful in general, and then const benefits from that?</p>",
        "id": 265841984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200726
    },
    {
        "content": "<p>we are basically trying to solve both the allocator pains and const pains at the same time, but should be talking about them independently</p>",
        "id": 265841999,
        "sender_full_name": "oli",
        "timestamp": 1640200736
    },
    {
        "content": "<p><a href=\"#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Making.20allocators.20less.20painful.20to.20use</a></p>",
        "id": 265842337,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640200927
    },
    {
        "content": "<p>Something else we didn't get to in the meeting: what exactly does the proposed <code>#[const_alloc]</code> mean in that particular approach?</p>",
        "id": 265844858,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640202557
    },
    {
        "content": "<p>That idea was a bit complicated. Instead of using a custom allocator, the <code>#[const_alloc]</code> approach makes <code>GlobalAlloc</code> work in const contexts.<br>\nWe then created marker traits to limit what types are allowed for the final values of constants because we want to avoid having <code>const FOO: Vec&lt;i32&gt; = vec![42];</code>. </p>\n<p>The only problem would be that only looking at the types would disallow some current real-world code e.g. <code>const A: Vec&lt;i32&gt; = Vec::new()</code> which is legal on stable. The solution for that is to look at what functions actually do (i.e. do they make allocations or not?) by marking functions that allocate and return owned pointers of allocations with <code>#[const_alloc]</code>. Then when we check constants we need to ask these questions: 1. Did you create an allocation? (are there any calls to <code>#[const_alloc]</code> functions?), 2. If so then the following types are forbidden: <code>Box&lt;T&gt;, Vec&lt;T&gt;, etc.</code> The same rules apply to functions, of course. We require functions to be marked with <code>#[const_alloc]</code> if there are any calls to other <code>#[const_alloc]</code> functions and the return type might point to an allocation.</p>",
        "id": 265884946,
        "sender_full_name": "fee1-dead",
        "timestamp": 1640237183
    },
    {
        "content": "<blockquote>\n<p>cramertj: right, you could use droppable things as intermediaries…but the actual const I would think would just return a reference, and now there is no “drop” that will get called</p>\n<p>cramertj: you’d also have to require Freeze, but we have a lot of requirements on these things anyway, it seems like we’re generally on the same page that we don’t want types with random drop impls getting inserted</p>\n</blockquote>\n<p>I think that avenue has been under-discussed.</p>\n<p>If you say \"only give me owned values if they don't have a drop impl or interior mutability\" then there is no possible way static values get deallocated. You don't need to rewrite the entire serde crate to allow a new allocator, and you don't need to introduce potential post-monomorphization errors by filtering types based on their computed values.</p>",
        "id": 266826783,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641312713
    },
    {
        "content": "<p>The biggest obstacle mentioned is that it would be a breaking change. This code currently compiles on stable:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"dropped\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">FOO</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">FOO</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and would break with the new rules.</p>",
        "id": 266826865,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641312728
    },
    {
        "content": "<p>But I think there could be workarounds.</p>",
        "id": 266826933,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641312748
    },
    {
        "content": "<p>What I have in mind would be \"We allow constants to have a type with a drop impl; but we don't allow these constants to be used by value in non-const contexts, only by shared ref\".</p>\n<p>eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">42</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// ok</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// ok</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\">   </span><span class=\"c1\">// ok</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span><span class=\"p\">;</span><span class=\"w\">         </span><span class=\"c1\">// ERROR</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's still a breaking change, so.</p>",
        "id": 266827933,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641313044
    },
    {
        "content": "<p>If existing code uses constants with a drop impl by value, we implicitly clone the value. (although that's also a breaking change in itself; the non-breaking version would be to actually create one static per instantiation of the const value, I guess) We lint against this behavior and remove it in a future edition.</p>",
        "id": 266828422,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641313194
    },
    {
        "content": "<p>The bottom line is, that way you can have Vec in consts without rewriting all serde code to be generic over allocator type, or having complex analysis that checks if a constant has allocated pointers or not.</p>",
        "id": 266828807,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641313298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/266827933\">said</a>:</p>\n<blockquote>\n<p>What I have in mind would be \"We allow constants to have a type with a drop impl; but we don't allow these constants to be used by value in non-const contexts, only by shared ref\".</p>\n<p>eg:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">42</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// ok</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// ok</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\">   </span><span class=\"c1\">// ok</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MY_VEC</span><span class=\"p\">;</span><span class=\"w\">         </span><span class=\"c1\">// ERROR</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's still a breaking change, so.</p>\n</blockquote>\n<p>It wouldn't be an actual breaking change if we could detect whether a type contains an allocation in its final value. We'd just disallow it to be the final value of a <code>const</code>. It is allowed to exist behind a reference or inside a <code>static</code>.</p>",
        "id": 266829521,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641313479
    },
    {
        "content": "<p>I wonder if we could <em>just</em> make it work by restricting <code>const_heap</code> to only statics.</p>",
        "id": 266829676,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641313531
    },
    {
        "content": "<p>Yeah, but the point is to avoid making correctness depend on values.</p>",
        "id": 266830367,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641313705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20eval.20meeting.202021-12-22/near/266830367\">said</a>:</p>\n<blockquote>\n<p>Yeah, but the point is to avoid making correctness depend on values.</p>\n</blockquote>\n<p>Have you read <a href=\"https://github.com/rust-lang/lang-team/issues/129\">https://github.com/rust-lang/lang-team/issues/129</a>? It proposes a system of marker traits and detection of heap allocations based on callees.</p>",
        "id": 266833056,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641314883
    },
    {
        "content": "<p>Oh, I misread it. I thought it was value-based.</p>",
        "id": 266835541,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641316014
    },
    {
        "content": "<p>My biggest objection is that whether or not a function allocates ought to be an implementation detail. Adding a new effect means you need to keep track of whether the functions you call have the effect, whether you're using a vec or a static array, etc, even though most of the time you don't care about it.</p>\n<p>I think an elegant design would be one where using Box, String or Vec isn't any harder in const functions than in regular functions. But there's no obvious way to implement an elegant design, because right now consts with Drop impls are allowed, and the drop glue of those consts can even be called in regular code.</p>",
        "id": 266837073,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1641316769
    }
]