[
    {
        "content": "<p>I recently had to scrap code that I had written because of unnameable types. What it came down to was that I had to store a filtered iterator within a struct, which would act as a wrapper. Following is a minimal example showing the problem with this approach:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">().</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"o\">???</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// it is impossible to write this type</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">iter</span>: <span class=\"nc\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Because closures are unnameable, it is impossible to spell out the type of <code>MyIterWrapper::iter</code>, which is unavoidable when declaring structs. There are, thankfully, ways to avoid having to spell out these unnameable type:</p>\n<ul>\n<li>use <code>impl</code> in return types (<code>get_my_iter</code> in this example does exactly that)</li>\n<li>use <code>fn</code> instead of closures (the downside is that we can't capture local variables anymore)</li>\n<li>re-implement <code>std::iter::Filter</code> by hard-coding the closure in it</li>\n<li>use generics (this works in many cases, but not quite in the example above)</li>\n</ul>\n<p>In the previous example, we cannot straightforwardly use generics in our code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">().</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">MyIterWrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// This fails to compile, as Self is MyIterWrapper&lt;T&gt;, not MyIterWrapper&lt;get_my_iter's return type&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">iter</span>: <span class=\"nc\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// This would work</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">my_iter_wrapper_new</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">MyIterWrapper</span><span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">iter</span>: <span class=\"nc\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd like to introduce a way to name these unnameable types without spelling them, by directly referring to the return type of a function. Let <code>return_type_of!</code> be such a function, that takes as input a function and returns its concrete output type.<br>\nI could then rewrite the example as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">().</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"nc\">return_type_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">get_my_iter</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// We can refer to the return type of `get_my_iter` without spelling it</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">iter</span>: <span class=\"nc\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Alternatively, this type could be stored in a newtype:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">MyIterType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">return_type_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">get_my_iter</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"nc\">MyIterType</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ...</span>\n</code></pre></div>\n<p>Potential issues with this idea are:</p>\n<ul>\n<li>this is a rather niche problem, as <code>impl</code> return types have solved most of the issues with unnameable types</li>\n<li>this adds a layer of complexity; I don't know if there is anything else that use compile-time introspection already in the language</li>\n<li>I don't know how this would work with generics</li>\n</ul>\n<p>I'd love to hear your thoughts on this, and if this idea turns out to be RFC-worthy, help me work out the details :)</p>",
        "id": 227673577,
        "sender_full_name": "Shad",
        "timestamp": 1614201136
    },
    {
        "content": "<p>I think the current plan for this is type-alias impl trait?</p>",
        "id": 227674342,
        "sender_full_name": "scottmcm",
        "timestamp": 1614201471
    },
    {
        "content": "<p>Something like this <a href=\"https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html#aliasing-impl-trait-in-function-signatures\">https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html#aliasing-impl-trait-in-function-signatures</a></p>",
        "id": 227674709,
        "sender_full_name": "scottmcm",
        "timestamp": 1614201607
    },
    {
        "content": "<p>(Perhaps needing an unused function that returns the same thing as <code>get_my_iter</code> to put it into the type alias, if <code>get_my_iter</code> isn't owned by you)</p>",
        "id": 227674883,
        "sender_full_name": "scottmcm",
        "timestamp": 1614201686
    },
    {
        "content": "<p>type-alias impl trait looks to be achieving the same thing, except that whose function/object's type it is is determined by the compiler</p>",
        "id": 227677631,
        "sender_full_name": "Shad",
        "timestamp": 1614202780
    },
    {
        "content": "<p>Can you elaborate on that? How does your example look with type alias impl trait and what parts of it are wrong in your eyes?</p>",
        "id": 227678113,
        "sender_full_name": "oli",
        "timestamp": 1614203012
    },
    {
        "content": "<p>My example would look like this using RFC 2515:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(type_alias_impl_trait)]</span><span class=\"w\"></span>\n\n<span class=\"k\">type</span> <span class=\"nc\">MyIterType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">MyIterType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">().</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"nc\">MyIterType</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">iter</span>: <span class=\"nc\">get_my_iter</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wrapper</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 227681921,
        "sender_full_name": "Shad",
        "timestamp": 1614204355
    },
    {
        "content": "<p>ah, and the issue is that you need the <code>get_my_iter</code> function at all? That's just a limitation of the current implementation. It isn't fundamental, but we're also not putting any resources into it before shipping the minimal version (which I'm working on)</p>",
        "id": 227740324,
        "sender_full_name": "oli",
        "timestamp": 1614245686
    },
    {
        "content": "<p>The issue for this situation is <a href=\"https://github.com/rust-lang/rust/issues/64445\">https://github.com/rust-lang/rust/issues/64445</a></p>",
        "id": 227740424,
        "sender_full_name": "oli",
        "timestamp": 1614245759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> where is the impl trait repo again? :)</p>",
        "id": 227742203,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614246618
    },
    {
        "content": "<p>I can't find it <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> I thought we had a special org for it, but I can't even find that org. Maybe we deleted the org without first moving all repositories?</p>",
        "id": 227748255,
        "sender_full_name": "oli",
        "timestamp": 1614249927
    },
    {
        "content": "<p>const-eval and similar have been moved already</p>",
        "id": 227748263,
        "sender_full_name": "oli",
        "timestamp": 1614249936
    },
    {
        "content": "<p>ahhh found it <a href=\"https://github.com/rust-rfcs/impl-trait\">https://github.com/rust-rfcs/impl-trait</a></p>",
        "id": 227748981,
        "sender_full_name": "oli",
        "timestamp": 1614250373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ^^</p>",
        "id": 227749001,
        "sender_full_name": "oli",
        "timestamp": 1614250389
    },
    {
        "content": "<p>it's a bit dated <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 227749052,
        "sender_full_name": "oli",
        "timestamp": 1614250419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> ah, ok. I'm going to just ... deprecate that I think and move to wg-traits</p>",
        "id": 227787594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614267926
    },
    {
        "content": "<p>yes</p>",
        "id": 227788733,
        "sender_full_name": "oli",
        "timestamp": 1614268306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/suggesting.20a.20way.20to.20alias.20unnameable.20types/near/227740324\">said</a>:</p>\n<blockquote>\n<p>ah, and the issue is that you need the <code>get_my_iter</code> function at all? That's just a limitation of the current implementation. It isn't fundamental, but we're also not putting any resources into it before shipping the minimal version (which I'm working on)</p>\n</blockquote>\n<p>I don't quite know what you mean by that. What I can tell you is that my suggestion does basically the same thing, except that the compiler is directly hinted which function/object the concrete type should resolve to.</p>",
        "id": 227827182,
        "sender_full_name": "Shad",
        "timestamp": 1614282595
    },
    {
        "content": "<p>I would imagine that in the future we may permit</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(type_alias_impl_trait)]</span><span class=\"w\"></span>\n\n<span class=\"k\">type</span> <span class=\"nc\">MyIterType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"nc\">MyIterType</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">vec</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">iter</span>: <span class=\"nc\">vec</span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">().</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wrapper</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MyIterWrapper</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so we make the field initialization be a defining use.</p>",
        "id": 227903906,
        "sender_full_name": "oli",
        "timestamp": 1614332593
    }
]