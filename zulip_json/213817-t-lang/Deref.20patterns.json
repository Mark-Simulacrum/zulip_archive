[
    {
        "content": "<p>I think this thread on internals is worth looking at: <a href=\"https://internals.rust-lang.org/t/somewhat-random-idea-deref-patterns/13813\">https://internals.rust-lang.org/t/somewhat-random-idea-deref-patterns/13813</a></p>",
        "id": 222466751,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610472861
    },
    {
        "content": "<p>Seems like a substantial ergonomic improvement.</p>",
        "id": 222466786,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610472882
    },
    {
        "content": "<p>There's a syntax question that needs resolving.</p>",
        "id": 222470460,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610474423
    },
    {
        "content": "<p>I think it'd be very nice to be able to match <code>Option&lt;String&gt;</code> with <code>Some(\"hello\")</code>.</p>",
        "id": 222470491,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610474438
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span>, who was talking to me about this recently</p>",
        "id": 222470844,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610474593
    },
    {
        "content": "<p>I'm in favor of some kind of deref pattern</p>",
        "id": 222470854,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610474594
    },
    {
        "content": "<p>I'd prefer not to have syntax</p>",
        "id": 222470878,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1610474609
    },
    {
        "content": "<p>Previous internal thread on the same subject (by me) <a href=\"https://internals.rust-lang.org/t/pre-pre-rfc-match-ergonomics-for-container-types-restricted-method-calls-in-patterns/13371\">https://internals.rust-lang.org/t/pre-pre-rfc-match-ergonomics-for-container-types-restricted-method-calls-in-patterns/13371</a></p>",
        "id": 222471136,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610474741
    },
    {
        "content": "<p>I'm getting back to writing a proper RFC for this between this week and the next</p>",
        "id": 222471301,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610474816
    },
    {
        "content": "<p>After that thread I am of the mind that _not_ having any syntax _can_ be reasonable because <code>Deref</code> is already hidden through coercions in enough places that there's _an expectation_ that <code>Deref</code> is \"cheap\" (despite there being no \"language level\" assurances of it)</p>",
        "id": 222471468,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610474897
    },
    {
        "content": "<p>An alternative approach would be to have some way of letting users have (de)structuring with logic, but we already have <code>Deref</code> that we can use for this</p>",
        "id": 222471624,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610474987
    },
    {
        "content": "<p>it seems like a pretty big step to depart from patterns being fully structural, without user code</p>",
        "id": 222471642,
        "sender_full_name": "cuviper",
        "timestamp": 1610474997
    },
    {
        "content": "<p>We already have <code>box</code> in nightly, and I think that _that_ is the wrong solution, we need something that end users can implement for their own types. If we have to add a keyword/sigil, so be it, but I am convinced we need the _feature_ in some form.</p>",
        "id": 222472106,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610475230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban Küber</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222471468\">said</a>:</p>\n<blockquote>\n<p>After that thread I am of the mind that _not_ having any syntax _can_ be reasonable because <code>Deref</code> is already hidden through coercions in enough places that there's _an expectation_ that <code>Deref</code> is \"cheap\" (despite there being no \"language level\" assurances of it)</p>\n</blockquote>\n<p>\"cheap\" isn't my concern. The compiler allowing broader type inference is my concern.</p>",
        "id": 222473220,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610475713
    },
    {
        "content": "<p>Matching <code>Option&lt;String&gt;</code> against <code>Some(\"hello\")</code> seems reasonable, and shouldn't have any broader type inference concerns.</p>",
        "id": 222473301,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610475740
    },
    {
        "content": "<p>Matching <code>Option&lt;String&gt;</code> against <code>Some(x)</code> and allowing type inference to consider the possibility that <code>x</code> isn't <code>String</code> concerns me.</p>",
        "id": 222473355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610475770
    },
    {
        "content": "<p>patterns would still have to be constant, no? so <code>Some(x)</code> wouldn't need inference if that's a <code>const x</code></p>",
        "id": 222474005,
        "sender_full_name": "cuviper",
        "timestamp": 1610476042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> <code>box</code> patterns also raise the question of a <code>DerefMove</code>, if you want this for user types</p>",
        "id": 222474248,
        "sender_full_name": "cuviper",
        "timestamp": 1610476153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> Not sure what you mean by that?</p>",
        "id": 222474526,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610476292
    },
    {
        "content": "<p><code>x</code> is conventionally a variable, not a constant (a constant would be in uppercase).</p>",
        "id": 222474556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610476307
    },
    {
        "content": "<p>oh, you mean <code>x</code> as a new binding, not a value to be matched</p>",
        "id": 222474651,
        "sender_full_name": "cuviper",
        "timestamp": 1610476352
    },
    {
        "content": "<p>I don't see why that would ever deref though</p>",
        "id": 222474698,
        "sender_full_name": "cuviper",
        "timestamp": 1610476385
    },
    {
        "content": "<p>I can imagine people wanting that.</p>",
        "id": 222477389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610477585
    },
    {
        "content": "<p>If that's not part of the proposal on the table, that's great.</p>",
        "id": 222477534,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610477654
    },
    {
        "content": "<p>If we're only talking about literals, I have no objections to <code>Deref</code> without any explicit sigil or other marker.</p>",
        "id": 222477603,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610477693
    },
    {
        "content": "<p>It's only where it affects type inference that I feel a sigil should be required.</p>",
        "id": 222477663,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610477722
    },
    {
        "content": "<p>my intuition would be that binding <code>x</code> would take the type as-is, and you can always deref where it's used</p>",
        "id": 222477721,
        "sender_full_name": "cuviper",
        "timestamp": 1610477756
    },
    {
        "content": "<p>Aside from the syntax question, there is also a question on whether or not to enforce purity of the deref in some way, if for nothing else, then to allow exhaustive matches across a deref.</p>",
        "id": 222477833,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610477802
    },
    {
        "content": "<p>I get the general impression that people already tend to assume Deref is pure-ish.</p>",
        "id": 222480500,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610478938
    },
    {
        "content": "<p>I'm <em>less</em> concerned about the number of calls to <code>deref</code>, since I suspect in practice many match statements will be able to make one call for most or all of the branches.</p>",
        "id": 222480642,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610478998
    },
    {
        "content": "<p>On exhaustiveness, how bad would it be if we just did exhaustiveness checking <em>assuming</em> that deref didn't return inconsistent results?</p>",
        "id": 222480703,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610479032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222477721\">said</a>:</p>\n<blockquote>\n<p>my intuition would be that binding <code>x</code> would take the type as-is, and you can always deref where it's used</p>\n</blockquote>\n<p>One issue with this was raised on the thread, that it would make the types of <code>x</code> and <code>x @ Some(y)</code> different, when matching, say, <code>Box&lt;Option&lt;i32&gt;</code>. One possibility is that binding a pattern that has an implicit dereference would be ill-formed.</p>",
        "id": 222480758,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610479057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> <code>x</code> and <code>x @ Some(y)</code> would both still be identically typed. But it'd make <code>x</code> and <code>x @ Some(\"hello\")</code> different, for instance.</p>",
        "id": 222480871,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610479106
    },
    {
        "content": "<p>I don't think I'd object to <code>x @ Some(\"hello\")</code> working, either.</p>",
        "id": 222480948,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610479153
    },
    {
        "content": "<p>forcing <code>x</code> to be deref'ed? or leaving it <code>Option&lt;String&gt;</code> and deref'ed only for the <code>@...</code> matching?</p>",
        "id": 222481025,
        "sender_full_name": "cuviper",
        "timestamp": 1610479200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222480703\">said</a>:</p>\n<blockquote>\n<p>On exhaustiveness, how bad would it be if we just did exhaustiveness checking <em>assuming</em> that deref didn't return inconsistent results?</p>\n</blockquote>\n<p>Without necessarily considering an implementation, at worst, it could be unsound if the <code>deref</code> is structurally unstable.</p>\n<p>As for the assumption <code>deref</code> is already pure, there are a few counterexamples that I listed in the standard library on the thread, notably <code>std::lazy::Lazy</code> and <code>std::lazy::SyncLazy</code>. The guard type for a <code>lazy_static!</code> would also not be a candidate for <code>DerefPure</code>.</p>",
        "id": 222481090,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610479218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222480871\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <code>x</code> and <code>x @ Some(y)</code> would both still be identically typed. But it'd make <code>x</code> and <code>x @ Some(\"hello\")</code> different, for instance.</p>\n</blockquote>\n<p>Would it? In the example I gave, the former would include an implicit deref, as <code>Box&lt;Option&lt;i32&gt;&gt;</code> needs to be dereferenced to get match against the <code>Some(y)</code> pattern. At least to me, the type of <code>x</code> intuitively should match the pattern.</p>",
        "id": 222481466,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610479404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222474248\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban Küber</span> <code>box</code> patterns also raise the question of a <code>DerefMove</code>, if you want this for user types</p>\n</blockquote>\n<p>Personally I would like to see the most \"permissive\" implementation considered but only the most \"restrictive\" stabilized (at first). Making it possible to get from <code>Box&lt;T&gt;</code> or <code>Arc&lt;T&gt;</code> to <code>&amp;T</code> in a pattern would make a bunch of code much nicer to write. Allowing <code>Cell&lt;T&gt;</code> to <code>&amp;mut T</code> is useful, but a smaller set of use cases which we can potentially consider independently. Allowing <code>Box&lt;T&gt;</code> to <code>T</code> (<code>DerefMove</code>) I would also <em>consider</em> but not <em>address</em> (at least at first, if ever).</p>",
        "id": 222484516,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610480839
    },
    {
        "content": "<blockquote>\n<p>Allowing <code>Cell&lt;T&gt;</code> to <code>&amp;mut T</code> is useful</p>\n</blockquote>\n<p>in theory it could implement <code>DerefMut</code>, but it can't implement <code>Deref</code></p>",
        "id": 222485880,
        "sender_full_name": "cuviper",
        "timestamp": 1610481450
    },
    {
        "content": "<p>but I take the rest of your point</p>",
        "id": 222485911,
        "sender_full_name": "cuviper",
        "timestamp": 1610481463
    },
    {
        "content": "<p>Regarding <code>DerefPure</code>, I don't see any need for it. If it is desugared to multiple calls, then after inlining the compiler may be able to eliminate the calls; if not, maybe use another syntax</p>",
        "id": 222486689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610481805
    },
    {
        "content": "<p>Perhaps there is use for a purity annotation that lets the compiler coalesce multiple calls but that's orthogonal to deref patterns</p>",
        "id": 222486762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610481841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222486689\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>DerefPure</code>, I don't see any need for it. If it is desugared to multiple calls, then after inlining the compiler may be able to eliminate the calls; if not, maybe use another syntax</p>\n</blockquote>\n<p>The only thing is that, without <code>DerefPure</code>, it would be impossible to exhaustively match across a <code>Deref</code> pattern</p>",
        "id": 222487115,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610482000
    },
    {
        "content": "<p>Yet another alternative would be to have <em>another</em> trait <code>DerefPattern</code> to give API devs more granular control, but I don't know how I feel about that...</p>",
        "id": 222487486,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610482169
    },
    {
        "content": "<p>What does this trait do? Is it like view patterns in haskell/scala?</p>",
        "id": 222487600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610482221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban Küber</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222487486\">said</a>:</p>\n<blockquote>\n<p>Yet another alternative would be to have <em>another</em> trait <code>DerefPattern</code> to give API devs more granular control, but I don't know how I feel about that...</p>\n</blockquote>\n<p>This one seems like a can of worms that I'd personally rather keep shut.</p>",
        "id": 222487639,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610482243
    },
    {
        "content": "<p>Mario, yes</p>",
        "id": 222488306,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610482616
    },
    {
        "content": "<p>Or rather a way to have the same functionality through different means</p>",
        "id": 222488352,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1610482638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222480703\">said</a>:</p>\n<blockquote>\n<p>On exhaustiveness, how bad would it be if we just did exhaustiveness checking <em>assuming</em> that deref didn't return inconsistent results?</p>\n</blockquote>\n<p>Could be pretty bad. Imagine</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">MyBool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Assume <code>MyBool</code> derefs to <code>bool</code>, but picks one at random at each call or something. Then there's a good change none of the match arms match, so we get something very undefined. Pretty sure we can't rely on the compiler only derefing once either, a more complex example could work around that.</p>",
        "id": 222493372,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610485066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222481025\">said</a>:</p>\n<blockquote>\n<p>forcing <code>x</code> to be deref'ed? or leaving it <code>Option&lt;String&gt;</code> and deref'ed only for the <code>@...</code> matching?</p>\n</blockquote>\n<p>Making <code>x</code> an <code>Option&lt;&amp;str&gt;</code> to match the pattern.</p>",
        "id": 222493791,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610485244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> <span class=\"user-mention\" data-user-id=\"245339\">@Nadrieril</span> To clarify, I wasn't imagining that we would just proceed and allow unsoundness. We'd still need to verify what we ended up with. I was more asking \"in practice, are Deref implementations sufficiently consistent that this would work\".</p>",
        "id": 222494068,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610485400
    },
    {
        "content": "<p>Ok. Btw, knowing the exhaustiveness code, it would be super easy to require an extra <code>_</code> pattern for deref patterns. So we could stabilise deref patterns with the current <code>Deref</code> trait and maybe add <code>DerefPure</code> later backwards-compatibly</p>",
        "id": 222497103,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610486942
    },
    {
        "content": "<p>That honestly seems reasonable. </p>\n<p>One question, though. Would it be valid to declare that, even without <code>DerefPure</code>, the number of times each of <code>deref</code> and <code>deref_mut</code> are called when matching deref patterns (and whether or not a particular pattern uses <code>deref</code> and <code>deref_mut</code>, where both are valid) is unspecified?  This could allow implementations to theoretically implement the entire stream of deref patterns as a single call to either <code>deref</code> or <code>deref_mut</code>.</p>",
        "id": 222499468,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610488149
    },
    {
        "content": "<p>The number (and timing) of derefs is dangerously close to \"observable means stable\"</p>",
        "id": 222511540,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1610494521
    },
    {
        "content": "<p>If people have interior mutability in their <code>Deref</code> impl they'll (accidentally or deliberately) rely on the number/order of derefs</p>",
        "id": 222511582,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1610494552
    },
    {
        "content": "<p>Drop order was stabilized as-is because changing it would be too breaking, I have a fear that auto(de)ref in patterns would go the same way</p>",
        "id": 222511655,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1610494598
    },
    {
        "content": "<p>Would it be difficult to commit to only derefing each thing once? I can't tell if there are patterns that would make this tricky; seems doable as far as I can see</p>",
        "id": 222519460,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610500565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222519460\">said</a>:</p>\n<blockquote>\n<p>Would it be difficult to commit to only derefing each thing once? I can't tell if there are patterns that would make this tricky; seems doable as far as I can see</p>\n</blockquote>\n<p>It's possible, if all derefs are immutable and there are no intervening mutable borrow of the original place in a pattern, or there are no borrow at all of the derefed value in a pattern.</p>",
        "id": 222520958,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610501728
    },
    {
        "content": "<p>Oh I see, mixing mutable and immutable borrows makes this impossible. That makes trying to specify precisely the number of derefs for a given match painful too &gt;&lt;. I think I want DerefPure too now</p>",
        "id": 222559611,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610533168
    },
    {
        "content": "<p>What if we define some restrictive circumstance in which multiple similar looking patterns in a row count as one deref? If you do any of the funny business that Connor mentions then the condition does not apply and you get multiple derefs</p>",
        "id": 222570073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610539611
    },
    {
        "content": "<p>I'm not entirely sure about the scope of the counterexamples, but I'm thinking something along the lines of: if a contiguous sequence of patterns all contain the same \"prefix\" of pattern matches, then they will all be grouped into a branch of the case tree, even if that includes a deref pattern match. That way you can still do exhaustive pattern matches as long as you write the matches in the right order. I think it will still work in the presence of pattern guards, because it amounts to a syntactic transformation and so is not constrained by the borrow checker rules (this happens in the desugaring pass before getting to MIR).</p>",
        "id": 222570784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610540118
    },
    {
        "content": "<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;*</span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"true\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;*</span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"false\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// exhaustive!</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// desugars to:</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;**</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"true\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"false\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"true, {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}, true\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"other\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// desugars to:</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;**</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;**</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"true, {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}, true\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"other\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"kc\">true</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"ok true\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"err\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"ok false\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// exhaustiveness error, unless you add</span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"ok\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// desugars to:</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">MyBool</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;**</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"ok true\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;**</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;</span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"ok false\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"ok\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"err\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 222572323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610541102
    },
    {
        "content": "<p>It would also be possible to add rules to enable coalescing even in the last case, for example if you say that the <code>Err(_)</code> cases are removed from the list of matches when determining if the derefs under <code>Ok</code> are contiguous, but that seems like it would be harder for programmers to reason about even though it allows more free rearrangement of patterns. The idea here is that the coalescing rule is simple enough that people can predictably trigger it so that exhausiveness errors are easily addressed while still letting people write big matches</p>",
        "id": 222572905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610541428
    },
    {
        "content": "<p>I would prefer not to have to guess whether my code will compile or not :/ autoderef already causes a lot of confusion there, if you look in #beginners on discord there are an awful lot of links to <a href=\"https://img.ifunny.co/images/7ab362ba5b3a1152f8d0c1b029e94d880d0cd4913a5642cbc79320e212676234_1.jpg\">https://img.ifunny.co/images/7ab362ba5b3a1152f8d0c1b029e94d880d0cd4913a5642cbc79320e212676234_1.jpg</a> floating around</p>\n<div class=\"message_inline_image\"><a href=\"https://img.ifunny.co/images/7ab362ba5b3a1152f8d0c1b029e94d880d0cd4913a5642cbc79320e212676234_1.jpg\"><img src=\"https://img.ifunny.co/images/7ab362ba5b3a1152f8d0c1b029e94d880d0cd4913a5642cbc79320e212676234_1.jpg\"></a></div>",
        "id": 222577391,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610544047
    },
    {
        "content": "<p>I would much rather have DerefPure</p>",
        "id": 222577457,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610544081
    },
    {
        "content": "<p>What I don't like about DerefPure is that it makes an assertion about purity that I as code author may not want</p>",
        "id": 222577830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610544256
    },
    {
        "content": "<p>I think it's much more likely that when writing a big nested pattern match you want as few deref calls as required</p>",
        "id": 222577973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610544319
    },
    {
        "content": "<p>whether or not those calls are pure</p>",
        "id": 222577994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610544332
    },
    {
        "content": "<p>but the general syntax of pattern matching requires writing the same deref over and over again even though that's not the intent</p>",
        "id": 222578116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610544382
    },
    {
        "content": "<p>Right, but at least it's consistent. I agree it's a common problem, I'm just not sure compiler magic for the common cases is the right solution.</p>",
        "id": 222579542,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610545076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222577391\">said</a>:</p>\n<blockquote>\n<p>I would prefer not to have to guess whether my code will compile or not :/ autoderef already causes a lot of confusion there, if you look in #beginners on discord there are an awful lot of links to <a href=\"https://img.ifunny.co/images/7ab362ba5b3a1152f8d0c1b029e94d880d0cd4913a5642cbc79320e212676234_1.jpg\">https://img.ifunny.co/images/7ab362ba5b3a1152f8d0c1b029e94d880d0cd4913a5642cbc79320e212676234_1.jpg</a> floating around</p>\n</blockquote>\n<p>this is something I would personally like to see more information on - I don't think I experience it when writing code, but maybe there's some pattern I just have trained myself to not write. It would be good for this sort of case to try to categorize and document the problem (perhaps as a design note) so that it can be considered more effectlively.</p>",
        "id": 222579664,
        "sender_full_name": "simulacrum",
        "timestamp": 1610545115
    },
    {
        "content": "<p>I don't think the description I gave is inconsistent? The basic idea is that the \"syntax\" for building a subtree of the underlying case tree is to write several patterns in a row with the same destructuring pattern. I don't see how else to express something like that without actually writing nested <code>match</code>, which is what we're trying to avoid in the first place</p>",
        "id": 222579883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610545219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> it normally comes up in the presence of smart pointers, people get confused when they have to do <code>&amp;*string</code> or whatever. With boxes it's even worse because sometimes you have <code>&amp;**</code>.</p>\n<p>I think RA's type hints help with this to some extent, but autoderef works just enough of the time that it's confusing when it doesn't.</p>",
        "id": 222579949,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610545254
    },
    {
        "content": "<p>hm, it feels like that's rather an argument for this feature? but again, without more detail hard to say</p>",
        "id": 222580027,
        "sender_full_name": "simulacrum",
        "timestamp": 1610545297
    },
    {
        "content": "<p>I'll try to come up with an example this afternoon</p>",
        "id": 222580069,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610545318
    },
    {
        "content": "<p>most of the time when I end up writing &amp;* or so, it's because I'm e.g. matching and the match needs &amp;str</p>",
        "id": 222580186,
        "sender_full_name": "simulacrum",
        "timestamp": 1610545353
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> sorry, consistent was the wrong word. Your idea seems specified pretty well, I just feel like I'd have trouble telling the rules by looking at code. Sort of like how I'm never sure which function override applies in C++.</p>",
        "id": 222580312,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610545414
    },
    {
        "content": "<p>Like I said, I can imagine ways to make it easier to use / succeed in more cases, but not without making it even worse on that axis. It's probably better if you aren't sure of the rules to think about it the way Connor mentioned earlier: the number of derefs is unspecified (or rather, the specification is more complicated than you would like to think about), so don't rely on it, keep your derefs pure or write nested matches if you need to be precise about it</p>",
        "id": 222581144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610545757
    },
    {
        "content": "<p>Here's another idea: rustc randomizes whether to group similar derefs on purpose, to prevent people from relying on it x)</p>",
        "id": 222606694,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610555213
    },
    {
        "content": "<p>Well that's why I'd say that the number, timings, and kinds of <code>deref</code> calls be unspecified.</p>",
        "id": 222609933,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610556518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Why &amp;* in that case, rather than .as_str() ?</p>",
        "id": 222614099,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610558107
    },
    {
        "content": "<p>Well, I prefer as_str, but it's not always possible on non-String types, e.g. with Arc I think.</p>",
        "id": 222615704,
        "sender_full_name": "simulacrum",
        "timestamp": 1610558711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222577457\">said</a>:</p>\n<blockquote>\n<p>I would much rather have DerefPure</p>\n</blockquote>\n<p>At this point, I'm wondering if, instead of having a <code>DerefPure</code> trait that can be freely implemented, in the first version of this, it's limited to standard library types that are already defined as being candidates for <code>DerefPure</code>.</p>",
        "id": 222619722,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610560440
    },
    {
        "content": "<p>Someone on irlo suggested it could be limited to const Deref impls.</p>",
        "id": 222621092,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1610561002
    },
    {
        "content": "<p>Yeah, that may work as well. The only thing would be if that would be more restrictive then necessary (it also would block it on const trait impls).</p>",
        "id": 222621481,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610561154
    },
    {
        "content": "<p>This would require an MCP, right?</p>",
        "id": 222621583,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610561189
    },
    {
        "content": "<p>can const-eval handle the types we care about here?</p>",
        "id": 222623601,
        "sender_full_name": "cuviper",
        "timestamp": 1610562109
    },
    {
        "content": "<p>in particular, AFAIK dereferencing raw pointers isn't supported</p>",
        "id": 222623709,
        "sender_full_name": "cuviper",
        "timestamp": 1610562138
    },
    {
        "content": "<p>I guess that's <a href=\"https://github.com/rust-lang/rust/issues/51911\">#51911</a></p>",
        "id": 222624400,
        "sender_full_name": "cuviper",
        "timestamp": 1610562453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222609933\">said</a>:</p>\n<blockquote>\n<p>Well that's why I'd say that the number, timings, and kinds of <code>deref</code> calls be unspecified.</p>\n</blockquote>\n<p>Yeah, the problem with this was that even if unspecified, people could start relying on it like they did with drop order.</p>",
        "id": 222625300,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610562858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222619722\">said</a>:</p>\n<blockquote>\n<p>At this point, I'm wondering if, instead of having a <code>DerefPure</code> trait that can be freely implemented, in the first version of this, it's limited to standard library types that are already defined as being candidates for <code>DerefPure</code>.</p>\n</blockquote>\n<p>I like this! This would be like making DerefPure perma-unstable. This would allow us to test the feature at a real scale without comitting on much</p>",
        "id": 222625603,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610563005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222625300\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222609933\">said</a>:</p>\n<blockquote>\n<p>Well that's why I'd say that the number, timings, and kinds of <code>deref</code> calls be unspecified.</p>\n</blockquote>\n<p>Yeah, the problem with this was that even if unspecified, people could start relying on it like they did with drop order.</p>\n</blockquote>\n<p>Well, of course, if it's unspecified, then the compiler could add an option to randomize it and break any code relying on it.  People can already rely on unspecified things, like the layout of a repr(Rust). However, the fact it's unspecified means that implementors don't really have to care about people relying on it and can break it at any time they choose.</p>",
        "id": 222625835,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610563133
    },
    {
        "content": "<p>In principle yes, but apparently in practice we decided we couldn't change drop order because it would break too much code. Anyway, my point about randomizing was made in jest dw</p>",
        "id": 222626135,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610563262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222625603\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222619722\">said</a>:</p>\n<blockquote>\n<p>At this point, I'm wondering if, instead of having a <code>DerefPure</code> trait that can be freely implemented, in the first version of this, it's limited to standard library types that are already defined as being candidates for <code>DerefPure</code>.</p>\n</blockquote>\n<p>I like this! This would be like making DerefPure perma-unstable. This would allow us to test the feature at a real scale without comitting on much</p>\n</blockquote>\n<p>Well, hopefully not <em>perma</em>-unstable. At some point it would be a good idea to look into extending the feature to user-provided types. But this starting point would probably be reasonable enough. </p>\n<p>I have a list of types that would be candidates for this immediately on the IRLO thread (hopefully I didn't miss any types).</p>",
        "id": 222626167,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610563284
    },
    {
        "content": "<p>I would like to bring this idea forward. I assume the next step would be to file a major change proposal. If someone could inform me of the necessary steps for that, that would be helpful.</p>",
        "id": 222642731,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610570624
    },
    {
        "content": "<p>This is a bit tangential, but it'd be cool if the optimizer could take advantage of the purity of the deref as well.  I've seen cases where <code>&amp;mut Vec&lt;T&gt;</code> is noticeably slower than <code>&amp;mut [T]</code> (such as <a href=\"https://users.rust-lang.org/t/we-all-know-iter-is-faster-than-loop-but-why/51486/3?u=scottmcm\">https://users.rust-lang.org/t/we-all-know-iter-is-faster-than-loop-but-why/51486/3?u=scottmcm</a> ), so it might help if the optimizer could tell that the deref is always doing the same thing.</p>",
        "id": 222643783,
        "sender_full_name": "scottmcm",
        "timestamp": 1610571137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222623601\">said</a>:</p>\n<blockquote>\n<p>can const-eval handle the types we care about here?<br>\nin particular, AFAIK dereferencing raw pointers isn't supported</p>\n</blockquote>\n<p>There could be another variety of const-eval more tailored to run-time execution.<br>\nI have tentatively suggested to name it <a href=\"https://internals.rust-lang.org/t/const-pure/13824\">const(pure)</a></p>",
        "id": 222717981,
        "sender_full_name": "atagunov",
        "timestamp": 1610631783
    },
    {
        "content": "<p>I think we'll soon be able to support all kinds of pointer shenanigans. Imo there shouldn't be any <code>Deref</code> impls that aren't <code>const</code>, unless you are explicitly trying to do something nasty</p>",
        "id": 222722723,
        "sender_full_name": "oli",
        "timestamp": 1610634114
    },
    {
        "content": "<p><code>Lazy</code> can't have a const deref though, right?</p>",
        "id": 222728116,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636442
    },
    {
        "content": "<p>probably not, definitely not yet</p>",
        "id": 222728211,
        "sender_full_name": "oli",
        "timestamp": 1610636492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222722723\">said</a>:</p>\n<blockquote>\n<p>I think we'll soon be able to support all kinds of pointer shenanigans. Imo there shouldn't be any <code>Deref</code> impls that aren't <code>const</code>, unless you are explicitly trying to do something nasty</p>\n</blockquote>\n<p>The problem with that is things like <code>std::lazy::Lazy</code> and <code>std::lazy::SyncLazy</code> (as well as the guard type from <code>lazy-static</code>), which can invoke a user-provided initialization function. In all cases, if these were required to be <code>const</code> functions, they would defeat the purpose (which is, at least for lazy-static, to store objects of a type that cannot be constructed at compile time, such as a Mutex, in a <code>static</code>). If we also include <code>DerefMut</code>, <code>std::borrow::Cow</code> would also fail this test, because it's entire point is that it can invoke a <em>user-provided</em> Clone function whenever mutable access is given. So there are, in fact, legitimate implementations of both that are neither pure nor const (even after raw ptr deref becomes valid in const).</p>",
        "id": 222728218,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610636500
    },
    {
        "content": "<p>if we make <code>Cow</code> generic over <code>AllocRef</code> we can make it <code>const</code> according to the current heap plan</p>",
        "id": 222728344,
        "sender_full_name": "oli",
        "timestamp": 1610636548
    },
    {
        "content": "<p>Those are all idempotent though, and that's what we need for exhaustiveness</p>",
        "id": 222728351,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636553
    },
    {
        "content": "<p>even Lazy could work some day, as long as the lazy is in a static and does not use a static by name in a const fn</p>",
        "id": 222728426,
        "sender_full_name": "oli",
        "timestamp": 1610636578
    },
    {
        "content": "<p>I could imagine a Lazy that does a database fetch/fs read, which really can never be const right?</p>",
        "id": 222728547,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636628
    },
    {
        "content": "<p>Indeed, or that loads entries for a static registery from a file.</p>",
        "id": 222728695,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610636687
    },
    {
        "content": "<p>So I'm not a fan of using const as a criterion here, if what we really need is idempotence</p>",
        "id": 222728703,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222728547\">said</a>:</p>\n<blockquote>\n<p>I could imagine a Lazy that does a database fetch/fs read, which really can never be const right?</p>\n</blockquote>\n<p>yea, that's true</p>",
        "id": 222728738,
        "sender_full_name": "oli",
        "timestamp": 1610636708
    },
    {
        "content": "<p>though...</p>",
        "id": 222728766,
        "sender_full_name": "oli",
        "timestamp": 1610636720
    },
    {
        "content": "<p>if you make the fetching method a generic parameter, then it works again</p>",
        "id": 222728788,
        "sender_full_name": "oli",
        "timestamp": 1610636733
    },
    {
        "content": "<p>hm, really? doesn't that mean you could use that to make non-idempotent derefs?</p>",
        "id": 222728935,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636784
    },
    {
        "content": "<p>anyway, for deref patterns I would have thought we want the deref to be trivial, not just idempotent</p>",
        "id": 222728945,
        "sender_full_name": "oli",
        "timestamp": 1610636787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222728935\">said</a>:</p>\n<blockquote>\n<p>hm, really? doesn't that mean you could use that to make non-idempotent derefs?</p>\n</blockquote>\n<p>yea, const just means const at compile-time. The current plan is that you can call arbitrary things if they are generic arguments</p>",
        "id": 222729041,
        "sender_full_name": "oli",
        "timestamp": 1610636824
    },
    {
        "content": "<p>(but at compile-time, only some generic arguments are allowed)</p>",
        "id": 222729084,
        "sender_full_name": "oli",
        "timestamp": 1610636842
    },
    {
        "content": "<p>if I understand correctly then forcing deref to be const doesn't force it to be idempotent? I thought that was the point</p>",
        "id": 222729130,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636866
    },
    {
        "content": "<p>as in, if we want pattern exhaustiveness we need at least idempotency, since we decided we couldn't just commit to a single call to deref()</p>",
        "id": 222729269,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636912
    },
    {
        "content": "<p>If it was const, or pure by the definition I gave, it would be guaranteed to be idempotent.</p>",
        "id": 222729278,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610636916
    },
    {
        "content": "<p>But both are, as noted, more restrictive then merely idempotent.</p>",
        "id": 222729350,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610636943
    },
    {
        "content": "<p>that's what I thought, but <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> said that generic args could allow weird things even in the const case</p>",
        "id": 222729365,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636950
    },
    {
        "content": "<p>I could just be confused</p>",
        "id": 222729456,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610636994
    },
    {
        "content": "<p>My question is what idempotency needs. Would merely structural stability be necessary?</p>",
        "id": 222729468,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637000
    },
    {
        "content": "<p>Would it need address stability+structural stability?</p>",
        "id": 222729542,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637018
    },
    {
        "content": "<p>hm, for match exhaustiveness to be sound I think only structural stability</p>",
        "id": 222729641,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637065
    },
    {
        "content": "<p>but if you don't have address stability then users could observe which derefs have been made which might be surprising</p>",
        "id": 222729739,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637106
    },
    {
        "content": "<p>I don't think const is the right abstraciton level here, especially around <code>DerefMut</code>, as that could access a <code>&amp;mut</code> stored in the struct and modify it</p>",
        "id": 222729772,
        "sender_full_name": "oli",
        "timestamp": 1610637117
    },
    {
        "content": "<p>should we have some kind of document to keep track of the things like that we've discussed?</p>",
        "id": 222730216,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637259
    },
    {
        "content": "<p>For completeness, the structural stability requirement I contemplated states that two consecutive deref/deref_mut operations return references to objects that are structurally equivalent unless an intervening access is made through a mutable reference or a pointer (other then a call to deref_mut)</p>",
        "id": 222730234,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245339\">Nadrieril</span> <a href=\"#narrow/stream/213817-t-lang/topic/Deref.20patterns/near/222730216\">said</a>:</p>\n<blockquote>\n<p>should we have some kind of document to keep track of the things like that we've discussed?</p>\n</blockquote>\n<p>Possibly. I can throw together a hackmd.</p>",
        "id": 222730353,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637310
    },
    {
        "content": "<p>hm right, having a <code>ref</code> then a <code>ref mut</code> then a <code>ref</code> patterns on a Cow would break address stability</p>",
        "id": 222730488,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637344
    },
    {
        "content": "<p>Yeah, and, depending on Clone, it can break structural stability.</p>",
        "id": 222730640,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637373
    },
    {
        "content": "<p>oh right, that's bad</p>",
        "id": 222730688,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637384
    },
    {
        "content": "<p>Clone is a safe trait.</p>",
        "id": 222730712,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637389
    },
    {
        "content": "<p>Cow really cannot be included unless we come up with a way to indicate that Clone is structurally stable (IE. A StructuralClone trait, that perhaps is implemented if Clone is derived and all the fields are StructuralClone)</p>",
        "id": 222731078,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637484
    },
    {
        "content": "<p>unrelatedly, it seems tricky if we want to allow say matching a <code>Cow&lt;Option&lt;String&gt;&gt;</code> with <code>Some(ref mut s)</code>, because the information for which of <code>deref</code> and <code>deref_mut</code> to use would have to flow backwards</p>",
        "id": 222731242,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637528
    },
    {
        "content": "<p><code>Cow</code> would be fine as long as we don't mix <code>ref</code> and <code>ref mut</code>, because the impls are idempotent</p>",
        "id": 222731402,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610637589
    },
    {
        "content": "<p>The issue with that is that we'd have to special case cow.</p>",
        "id": 222731687,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637707
    },
    {
        "content": "<p>Or have some way to disallow mixing deref patterns (or simply disallow the mutable deref patterns for the type)</p>",
        "id": 222731767,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610637736
    },
    {
        "content": "<p>Hackmd for tracking the syntax and requirements questions: <a href=\"https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/S1VwlyCRD\">https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/S1VwlyCRD</a></p>",
        "id": 222732939,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610638248
    },
    {
        "content": "<p>Yeah I was thinking we could disallow mixing deref and deref_mut patterns maybe</p>",
        "id": 222745660,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610643004
    },
    {
        "content": "<p>speaking of structural clones, there's a kind of precedent: consts of custom types in patterns require an automatically-derived <code>PartialEq</code> impl otherwise the user could be surprised that the match is structural instead of using <code>PartialEq</code>. It would not be absurd to require a similarly-autoderived <code>Clone</code> impl for the <code>DerefMut</code> impl of <code>Cow</code></p>",
        "id": 222753200,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610645913
    },
    {
        "content": "<p>hm, an issue of the no-syntax proposal is types that can both be destructured and have a <code>Deref</code> impl:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">cowcow</span>: <span class=\"nc\">Cow</span><span class=\"o\">&lt;</span><span class=\"n\">Cow</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">cowcow</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Cow</span>::<span class=\"n\">Owned</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// what's the type of `x`?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 222754171,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610646330
    },
    {
        "content": "<p>I've expanded the hackmd with most of the points discussed here. I haven't read the irlo thread</p>",
        "id": 222754787,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610646578
    },
    {
        "content": "<p>Also we want to anticipate a future <code>DerefMove</code> possibility. The following should error for now:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"nb\">Some</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 222759107,
        "sender_full_name": "Nadrieril",
        "timestamp": 1610648231
    },
    {
        "content": "<p>I've looked into how to file an MCP, and am preparing to do so. <br>\nWho all here would like to be initially involved with the project?</p>",
        "id": 222766392,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610651178
    },
    {
        "content": "<p>since when was <code>Cow: DerefMut</code> a thing?! I didn't see <code>DerefMut</code> mentioned at all in <code>Cow</code>'s docs...</p>",
        "id": 222827787,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1610696532
    },
    {
        "content": "<p>Huh. I thought it did impl DerefMut, but it has <a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html#method.to_mut\">a dedicated method</a>. In this case, it satisfies all the discussed requirements, so it could be a candidate.</p>",
        "id": 222848558,
        "sender_full_name": "Connor Horman",
        "timestamp": 1610712062
    },
    {
        "content": "<p>On the topic of pattern matching, one concern I'd like to add is that before making it more complicated maybe we should first clean up the <a href=\"https://github.com/rust-lang/rust/issues/74446\">currently somewhat messy state of affairs</a> around \"structural match\"...</p>",
        "id": 222982954,
        "sender_full_name": "RalfJ",
        "timestamp": 1610806054
    },
    {
        "content": "<p>some of the structural match stuff may already be happening with the edition</p>",
        "id": 222983493,
        "sender_full_name": "oli",
        "timestamp": 1610806602
    },
    {
        "content": "<p>Don't we first need a plan before anything can happen?^^ Currently all we have is a bunch of ideas.</p>",
        "id": 222983519,
        "sender_full_name": "RalfJ",
        "timestamp": 1610806645
    },
    {
        "content": "<p>all the ideas revolve around valtrees though so we probably also need those before anything can happen</p>",
        "id": 222983583,
        "sender_full_name": "RalfJ",
        "timestamp": 1610806692
    },
    {
        "content": "<p>edition changes won't help to clean up the codebase so that seems like an orthogonal discussion to me</p>",
        "id": 222983592,
        "sender_full_name": "RalfJ",
        "timestamp": 1610806706
    },
    {
        "content": "<p>I want to chime in and say that I'd very happy to see this come to fruition. Having to write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">assert_error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Error</span>::<span class=\"n\">ElementOpenAndCloseMismatched</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">open</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">close</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">open</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"a\"</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">close</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"b\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would be so much nicer as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">assert_error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Error</span>::<span class=\"n\">ElementOpenAndCloseMismatched</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">open</span>: <span class=\"s\">\"a\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">close</span>: <span class=\"s\">\"b\"</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 228416385,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1614694748
    },
    {
        "content": "<p>Plus the ability to finally answer <a href=\"https://stackoverflow.com/q/25383488/155423\">How to match a String against string literals?</a> in a satisfactory manner.</p>",
        "id": 228416454,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1614694777
    },
    {
        "content": "<p>The Project Group Charter for this is currently on fcp to merge, so assuming no issues are presented, it will be one step closer <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.</p>",
        "id": 228419184,
        "sender_full_name": "Connor Horman",
        "timestamp": 1614695665
    },
    {
        "content": "<p>Yep! I'm watching that, which is how I got this link. Basically wanted to show encouragement without cluttering up that issue with noise.</p>",
        "id": 228421469,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1614696480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I should create the zulip stream! sorry about that, will get on that</p>",
        "id": 228434041,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614700729
    }
]