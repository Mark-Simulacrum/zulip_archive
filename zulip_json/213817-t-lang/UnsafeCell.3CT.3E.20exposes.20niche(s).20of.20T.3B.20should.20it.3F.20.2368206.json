[
    {
        "content": "<p>Interesting question posed on issue <a href=\"https://github.com/rust-lang/rust/issues/68206\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/68206\">#68206</a></p>",
        "id": 185612087,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579019176
    },
    {
        "content": "<p>at least, I find the question of \"What kind of 'primitive' is <code>UnsafeCell</code> supposed to be? Something that you are expected to add extra safe-guards to in order to prevent compiler from doing things like niche optimization?</p>",
        "id": 185612310,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579019313
    },
    {
        "content": "<p>I think to me at least it makes sense to not combine UnsafeCell with niches, though it may also be a good argument that using that niche can never be safe as you then can't really abstract around it, with <code>&amp;mut T</code> now no longer making the guarantees it should be able to</p>",
        "id": 185612726,
        "sender_full_name": "simulacrum",
        "timestamp": 1579019539
    },
    {
        "content": "<p>I cannot tell if your first sentence is stating \"<code>UnsafeCell</code> should expose niche\" or not</p>",
        "id": 185612766,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579019572
    },
    {
        "content": "<p>(probably because my brain is too willing to freely reinterpret what \"combine\" might mean here.)</p>",
        "id": 185612922,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579019655
    },
    {
        "content": "<p>ah, I think it should, because generally we don't combine things like that</p>",
        "id": 185633858,
        "sender_full_name": "simulacrum",
        "timestamp": 1579031884
    },
    {
        "content": "<p>e.g. Arc&lt;Mutex&lt;_&gt;&gt; over SharedMemory&lt;_&gt; basically</p>",
        "id": 185633881,
        "sender_full_name": "simulacrum",
        "timestamp": 1579031902
    },
    {
        "content": "<p>This <em>sort of vagely</em> relates to the question of dereferenceable</p>",
        "id": 185736102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579117495
    },
    {
        "content": "<p>that said, I feel like.. hmm.. I'm having memories of discussing this with <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> at last year's all hands :)</p>",
        "id": 185736143,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579117517
    },
    {
        "content": "<p>basically the question is sort of 'what is the escape hatch that says \"don't trust these bits\"', in part?</p>",
        "id": 185736172,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579117536
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> was advocating that this should be <code>union</code> rather than <code>UnsafeCell</code></p>",
        "id": 185736195,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579117546
    },
    {
        "content": "<p>but I do think we should be able to answer the question, regardless</p>",
        "id": 185736209,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579117557
    },
    {
        "content": "<blockquote>\n<p>I think <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> was advocating that this should be <code>union</code> rather than <code>UnsafeCell</code></p>\n</blockquote>\n<p>what's \"this\"?</p>",
        "id": 185736912,
        "sender_full_name": "RalfJ",
        "timestamp": 1579117978
    },
    {
        "content": "<p>\"Don't trust these bits\" I believe</p>",
        "id": 185737297,
        "sender_full_name": "simulacrum",
        "timestamp": 1579118104
    },
    {
        "content": "<p>I mean unions already do that (or I think they should, that's <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">https://github.com/rust-lang/unsafe-code-guidelines/issues/73</a>). not sure what niko was saying.^^</p>",
        "id": 185737425,
        "sender_full_name": "RalfJ",
        "timestamp": 1579118178
    },
    {
        "content": "<p>I think Niko is saying that UnsafeCell should not <em>also</em> do this</p>",
        "id": 185746390,
        "sender_full_name": "simulacrum",
        "timestamp": 1579123897
    },
    {
        "content": "<p>i.e., if you want this behavior for UnsafeCell then you should also add a union in</p>",
        "id": 185746406,
        "sender_full_name": "simulacrum",
        "timestamp": 1579123919
    },
    {
        "content": "<p>what is not clear to me is that there are use cases for UnsafeCell where the niche is exposed</p>",
        "id": 185746453,
        "sender_full_name": "simulacrum",
        "timestamp": 1579123931
    },
    {
        "content": "<p>I think the answer is that all non-threadsafe use cases are fine to expose the niche in, but I'm not confident in that assessment :)</p>",
        "id": 185746486,
        "sender_full_name": "simulacrum",
        "timestamp": 1579123965
    },
    {
        "content": "<p>What are arguments for not having <code>UnsafeCell</code> <em>also</em> do this? The main one I can imagine is about \"expressive power\" : someone who knows what they are doing will be able to put the lego-pieces of the type system to precisely express what they want</p>",
        "id": 185781760,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579144567
    },
    {
        "content": "<p>but my Point of View is that out of the box, this is a huge footgun for <code>UnsafeCell</code>, and there is probably too much code out there that was written without thinking about this issue.</p>",
        "id": 185781779,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579144658
    },
    {
        "content": "<blockquote>\n<p>what is not clear to me is that there are use cases for UnsafeCell where the niche is exposed</p>\n</blockquote>\n<p>There's discussion on the issue re. <code>Option&lt;Cell&lt;T&gt;&gt;</code></p>",
        "id": 185789351,
        "sender_full_name": "centril",
        "timestamp": 1579156025
    },
    {
        "content": "<blockquote>\n<p>[...], and there is probably too much code out there that was written without thinking about this issue.</p>\n</blockquote>\n<p>I am by default intensely skeptical of these types of assertions given past experience.</p>",
        "id": 185789399,
        "sender_full_name": "centril",
        "timestamp": 1579156086
    },
    {
        "content": "<p>My current opinion is that <code>UnsafeCell&lt;T&gt;</code> should inhibit both</p>\n<ul>\n<li>niches</li>\n<li>dereferencable attribute (when viewed through a reference)</li>\n</ul>\n<p>We know, after all, that we cannot access the data within without potentially triggering data races.  </p>\n<p>But it would be really good to start creating a comprehensive collection of the examples and cases to keep in mind.</p>",
        "id": 185829930,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579191252
    },
    {
        "content": "<p>This feels fairly analogous to me to the auto trait design:</p>",
        "id": 185830024,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579191307
    },
    {
        "content": "<p>We don't consider <code>*mut Send</code>, but you can opt back in at outer levels (except we don't have this opt-in .. yet?)</p>",
        "id": 185830066,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579191329
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>[...], and there is probably too much code out there that was written without thinking about this issue.</p>\n</blockquote>\n<p>I am by default intensely skeptical of these types of assertions given past experience.</p>\n</blockquote>\n<p>Heh. Not me, I tend to buy those claims when I see them. Only defense Rust has against them is that it is still very young and not as popular as we might like.</p>",
        "id": 185830078,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579191335
    },
    {
        "content": "<p>I'd be inclined to put off the opt-in until we're convinced it's necessary</p>",
        "id": 185830083,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579191339
    },
    {
        "content": "<blockquote>\n<p>I think Niko is saying that UnsafeCell should not <em>also</em> do this</p>\n</blockquote>\n<p>I was not saying that, but I thought I remembered <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> saying it. It sounds like I may have been mistaken.</p>",
        "id": 185830194,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579191376
    },
    {
        "content": "<blockquote>\n<p>Heh. Not me, I tend to buy those claims when I see them. Only defense Rust has against them is that it is still very young and not as popular as we might like.</p>\n</blockquote>\n<p>Whereas I require constructive evidence to believe them. ;) Sometimes it might be the case that some widely used crate does something bad, but then it's also easier to fix centrally.</p>",
        "id": 185830974,
        "sender_full_name": "centril",
        "timestamp": 1579191796
    },
    {
        "content": "<p>As far as back-compat is concerned, <code>UnsafeCell&lt;T&gt;</code> is also <code>repr(transparent)</code>, so it seems to me we have already made an observable promise that the niche will be exposed</p>",
        "id": 185831452,
        "sender_full_name": "centril",
        "timestamp": 1579192061
    },
    {
        "content": "<p>and folks can rely on that</p>",
        "id": 185831465,
        "sender_full_name": "centril",
        "timestamp": 1579192070
    },
    {
        "content": "<p>I spent some time last night trying to review the specs</p>",
        "id": 185831498,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192082
    },
    {
        "content": "<p>I couldn't find a place in the reference where the handling of the niche on <code>repr(transparent)</code> on structs was discussed</p>",
        "id": 185831552,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192106
    },
    {
        "content": "<p>As a separate point, I do find it elegant, simple, and understandable that <code>UnsafeCell&lt;T&gt;</code> does one thing, not 3 things</p>",
        "id": 185831583,
        "sender_full_name": "centril",
        "timestamp": 1579192123
    },
    {
        "content": "<p>and I continue to believe that there is <strong>no reason</strong> to make such an observable promise (from <code>repr(transparent)</code> that you describe.</p>",
        "id": 185831605,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192130
    },
    {
        "content": "<blockquote>\n<p>I couldn't find a place in the reference where the handling of the niche on <code>repr(transparent)</code> on structs was discussed</p>\n</blockquote>\n<p>(I <em>did</em> see it in the comments, especially in the <code>repr(transparent)</code> on enum/union RFC PR, but no where regarding the original feature...)</p>",
        "id": 185831680,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192180
    },
    {
        "content": "<blockquote>\n<p>and I continue to believe that there is <strong>no reason</strong> to make such an observable promise (from <code>repr(transparent)</code> that you describe.</p>\n</blockquote>\n<p>Though I would be happy to see a, as you put it, constructive example of why such a promise has utility.</p>",
        "id": 185831818,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192234
    },
    {
        "content": "<p><code>Option&lt;Cell&lt;T&gt;&gt;</code> was an example</p>",
        "id": 185831852,
        "sender_full_name": "centril",
        "timestamp": 1579192259
    },
    {
        "content": "<p>although it was claimed that that occurs infrequently</p>",
        "id": 185831873,
        "sender_full_name": "centril",
        "timestamp": 1579192270
    },
    {
        "content": "<p>i don't see why the optimization of <code>Option&lt;Cell&lt;T&gt;&gt;</code> needs to be something that follows from <code>repr(transparent)</code>. That strikes me as an implementation detail of <code>Cell&lt;T&gt;</code> itself.</p>",
        "id": 185831981,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192337
    },
    {
        "content": "<p>to be honest, though, I'd be perfectly happy with something like <code>#{repr(no_niche)]</code> that we could apply to any ADT (struct/enum/union)</p>",
        "id": 185832040,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192376
    },
    {
        "content": "<p>that would be a utility of <code>UnsafeCell&lt;T&gt;</code> exposing niches specifically</p>",
        "id": 185832051,
        "sender_full_name": "centril",
        "timestamp": 1579192380
    },
    {
        "content": "<p>and then if that composed to yield <code>#[repr(transparent, no_niche)</code>, then it seems like you would get what you want (<code>#[repr(transparent)]</code> alone has simple semantic interpretation) and I would get what I want (the ability to express the ABI desirata without exposing the niche unnecessarily.</p>",
        "id": 185832209,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192462
    },
    {
        "content": "<p><code>repr(transparent)</code> exposing niches feels easy to motivate: just take a newtype wrapper around <code>&amp;'a T</code> and then an <code>Option&lt;_&gt;</code> around that</p>",
        "id": 185832212,
        "sender_full_name": "centril",
        "timestamp": 1579192462
    },
    {
        "content": "<blockquote>\n<p>and then if that composed to yield #[repr(transparent, no_niche), then it seems like you would get what you want (#[repr(transparent)] alone has simple semantic interpretation) and I would get what I want (the ability to express the ABI desirata without exposing the niche unnecessarily.</p>\n</blockquote>\n<p>This feels elegant.</p>",
        "id": 185832264,
        "sender_full_name": "centril",
        "timestamp": 1579192489
    },
    {
        "content": "<p>Although I wouldn't want to attach it to <code>UnsafeCell&lt;T&gt;</code> necessarily</p>",
        "id": 185832305,
        "sender_full_name": "centril",
        "timestamp": 1579192508
    },
    {
        "content": "<p>yeah that we might debate</p>",
        "id": 185832326,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span>  but your <code>no_niche</code> feels like \"composable language design\"</p>",
        "id": 185832372,
        "sender_full_name": "centril",
        "timestamp": 1579192538
    },
    {
        "content": "<p>we have a more short-term question of fixing the soundness hole though</p>",
        "id": 185832462,
        "sender_full_name": "centril",
        "timestamp": 1579192574
    },
    {
        "content": "<p>yes</p>",
        "id": 185832467,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192578
    },
    {
        "content": "<p>use of a niche is itself a compiler optimziation attached to the unstable Rust layout</p>",
        "id": 185832492,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192598
    },
    {
        "content": "<p>so I believe we would be within our rights to <em>still</em> make <code>UnsafeCell&lt;T&gt;</code> act as if it has no_niche</p>",
        "id": 185832526,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192620
    },
    {
        "content": "<p>for short term</p>",
        "id": 185832538,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192623
    },
    {
        "content": "<p>that, or we can go ahead and make a <code>NoNiche&lt;T&gt;</code> wrapper type</p>",
        "id": 185832562,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192638
    },
    {
        "content": "<p>and deploy it in libstd where necessary</p>",
        "id": 185832576,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192645
    },
    {
        "content": "<p>I'll need to think about whether I agree we are within our rights re. the above discussion re. promises already made (or not made)</p>",
        "id": 185832746,
        "sender_full_name": "centril",
        "timestamp": 1579192711
    },
    {
        "content": "<p><code>NoNiche&lt;T&gt;</code> feels more robust as a documentation tool though</p>",
        "id": 185832757,
        "sender_full_name": "centril",
        "timestamp": 1579192719
    },
    {
        "content": "<p>I'm working on <code>#[repr(no_niche)]</code> in my branch where I'm trying to make <code>UnsafeCell</code> hide its niche. It seemed like a natural thing to poke on while I figure out how to actually accomplish the end goal.</p>",
        "id": 185832810,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579192748
    },
    {
        "content": "<p>Slightly off topic, what does \"niche\" mean in this context? I tried searching for it, but googling \"niche programming\" isn't really giving helpful answers. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 185833460,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1579193073
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> it's the thing that allows <code>Option&lt;&amp;T&gt;</code> to have the same size as <code>&amp;T</code></p>",
        "id": 185833561,
        "sender_full_name": "centril",
        "timestamp": 1579193136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> more specifically: <code>enum E { A(...), B(...), ... }</code> uses some state called a \"discriminant\" to differentiate which variant of the enum you are using. A niche allows Rust to store the discriminant intermixed with the payload(s) attached to the variants.</p>",
        "id": 185835598,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579194241
    },
    {
        "content": "<p>There is one relatively authoritative and user-visible sign that <code>repr(transparent)</code> guarantees something about niches: the behavior of the improper_ctypes lint after <a href=\"https://github.com/rust-lang/rust/pull/60300\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/60300\">https://github.com/rust-lang/rust/pull/60300</a><br>\nIn particular, <code>Option&lt;UnsafeCell&lt;&amp;i32&gt;&gt;</code> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7027b7e22dab5bedeeb9c54679dd4ea7\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7027b7e22dab5bedeeb9c54679dd4ea7\">is considered FFI-safe</a> (and same for <code>Cell</code>)</p>",
        "id": 185836886,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579194994
    },
    {
        "content": "<p>I know that many, perhaps most, unsafe code authors <em>assume</em> repr transparent means \"the same layout as the underlying type\".<br>\n(leaving aside the fact that \"layout\" has no formal rust definition yet)</p>",
        "id": 185838132,
        "sender_full_name": "Lokathor",
        "timestamp": 1579195708
    },
    {
        "content": "<blockquote>\n<p>As a separate point, I do find it elegant, simple, and understandable that <code>UnsafeCell&lt;T&gt;</code> does one thing, not 3 things</p>\n</blockquote>\n<p>note however that it turns out that <code>UnsafeCell</code> having niches means <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/204\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/204\">it's really hard to define what that one thing is</a></p>",
        "id": 185840301,
        "sender_full_name": "RalfJ",
        "timestamp": 1579196968
    },
    {
        "content": "<p>a variant of stacked borrows that correctly models the \"one thing <code>UnsafeCell</code> does\" <em>with</em> support for exposing niches might be possible, but I think it will require things I would like to strictly avoid -- like \"ghost state\" that records the actual enum discriminant in some magical place even when in memory, we just see its encoding via some niche. this is exactly the same kind of \"ghost state\" as the \"active union variant\", and I did everything I could to make sure we do <em>not</em> have that ;)</p>",
        "id": 185840431,
        "sender_full_name": "RalfJ",
        "timestamp": 1579197053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> will you be available for the lang meeting today?</p>",
        "id": 185840494,
        "sender_full_name": "centril",
        "timestamp": 1579197115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span>  so, while I agree with not mixing concepts, I also cannot say that I know how to define the concept of interior mutability on its own, ignoring niches</p>",
        "id": 185840499,
        "sender_full_name": "RalfJ",
        "timestamp": 1579197118
    },
    {
        "content": "<p>I'm afraid I have tons of stuff to prepare before flying to a conference on Saturday :/</p>",
        "id": 185840557,
        "sender_full_name": "RalfJ",
        "timestamp": 1579197138
    },
    {
        "content": "<p>ah; have fun at the conference</p>",
        "id": 185840575,
        "sender_full_name": "centril",
        "timestamp": 1579197155
    },
    {
        "content": "<p>(and I'll give a talk about Stacked Borrows there ;)</p>",
        "id": 185840596,
        "sender_full_name": "RalfJ",
        "timestamp": 1579197168
    },
    {
        "content": "<blockquote>\n<p>There is one relatively authoritative and user-visible sign that <code>repr(transparent)</code> guarantees something about niches: the behavior of the improper_ctypes lint after <a href=\"https://github.com/rust-lang/rust/pull/60300\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/60300\">https://github.com/rust-lang/rust/pull/60300</a><br>\nIn particular, <code>Option&lt;UnsafeCell&lt;&amp;i32&gt;&gt;</code> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7027b7e22dab5bedeeb9c54679dd4ea7\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7027b7e22dab5bedeeb9c54679dd4ea7\">is considered FFI-safe</a> (and same for <code>Cell</code>)</p>\n</blockquote>\n<p>Okay, I can understand the argument that a user might reasonably expect (based on the use of <code>repr(transparent)</code> and the semantics you are ascribing it w.r.t. niches), that <code>Option&lt;UnsafeCell&lt;&amp;i32&gt;&gt;</code> is FFI-safe.</p>\n<p>For now I remain internally divided about whether that type <em>should</em> be FFI-safe, which is a slightly different matter.</p>",
        "id": 185841184,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579197507
    },
    {
        "content": "<p>/me wonders if we can/should instead lint for occurrences of <code>UnsafeCell</code> in a type that implements <code>Sync</code>, and if such occurrences also expose a niche, issue a warning.... (this option may have been already discussed in the issue)</p>",
        "id": 185842232,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579198099
    },
    {
        "content": "<p>Personally I am absolutely convinced that it should not be, because I don't think there's good use cases for it and because I think UnsafeCell should not have niches (for the same reason it should inhibit <code>dereferenceable</code>). But as you say, that is a different question.</p>",
        "id": 185842326,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579198174
    },
    {
        "content": "<p>Ralf's point re. the formal model is compelling at any rate.</p>",
        "id": 185842485,
        "sender_full_name": "centril",
        "timestamp": 1579198299
    },
    {
        "content": "<p>The memory / perf benefits may be small in comparison to that cost</p>",
        "id": 185842547,
        "sender_full_name": "centril",
        "timestamp": 1579198324
    },
    {
        "content": "<p>Aside: I can't help but think that we would be in less of a mess now if we'd stuck to <code>repr(transparent)</code> being only for passing things by value in FFI, instead of also (ab)using it as a marker indicating identical <em>memory layout</em> on types that never need to be passed by value in FFI.</p>",
        "id": 185850543,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579203053
    },
    {
        "content": "<p>throw it on the edition pile?</p>",
        "id": 185860269,
        "sender_full_name": "Lokathor",
        "timestamp": 1579208897
    },
    {
        "content": "<p>The discussion in the meeting unanimously resolved in favor of inhibiting niches on <code>UnsafeCell&lt;T&gt;</code></p>",
        "id": 185860622,
        "sender_full_name": "centril",
        "timestamp": 1579209011
    },
    {
        "content": "<p>ah yes, I had forgotten about <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/204\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/204\">rust-lang/unsafe-code-guidelines#204</a>...</p>",
        "id": 185869559,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579214344
    },
    {
        "content": "<blockquote>\n<p>Aside: I can't help but think that we would be in less of a mess now if we'd stuck to <code>repr(transparent)</code> being only for passing things by value in FFI, instead of also (ab)using it as a marker indicating identical <em>memory layout</em> on types that never need to be passed by value in FFI.</p>\n</blockquote>\n<p>Remind me, <span class=\"user-mention\" data-user-id=\"124289\">@rkruppe</span>, when did we decide to alter the meaning? I actually thought <code>#[repr(transparent)]</code> <em>was</em> only used for controlling ABI, and said nothing in particular about memory layout?</p>",
        "id": 185870709,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579215225
    },
    {
        "content": "<p>I started to write-up some notes on the issue <a href=\"https://hackmd.io/7rk-0h8WTqKQgaWB6aaeaw\" target=\"_blank\" title=\"https://hackmd.io/7rk-0h8WTqKQgaWB6aaeaw\">in a hackmd</a>. <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I was trying to write-up notes about unsafe-code-guidelines#204 and I wanted to see whether you agreed with this summary:</p>\n<ul>\n<li>Data-races do not affect <code>Option&lt;Cell&lt;u32&gt;&gt;</code>, however niche optimizations in this case can still have surprising effects, as documented in unsafe-code-guidelines#204:<ul>\n<li>In this case, the code converts a <code>&amp;Option&lt;Cell&lt;&amp;u32&gt;&gt;</code> into a <code>*mut usize</code> and writes a <code>0</code> to it. This changes the <code>Option</code> from <code>Some</code> to <code>None</code>. This means that, from the caller's point-of-view, if we invoke a function that takes an argument of type <code>&amp;Option&lt;Cell&lt;&amp;u32&gt;&gt;</code> we must assume that this argument may spontaneously change from <code>&amp;Some(_)</code> to <code>&amp;None</code>, even though safe code could not possibly do that.</li>\n</ul>\n</li>\n</ul>\n<p>In particular, I agree the code is <em>surprising</em>, but I'm not sure if it can be blamed purely on niches or lack thereof. If I recall, you were arguing for a \"infectious\" semantics for <code>UnsafeCell</code>, in which having an <code>UnsafeCell</code> inside of a struct means that (from stacked borrows point-of-view) the entire struct is writable via a shared reference. (Though presently the semantics are somewhat different, and extend only through enums.)</p>\n<p>In that case, it seems like a <code>&amp;Option&lt;Cell&lt;&amp;u32&gt;&gt;</code> may wind up changing from <code>&amp;Some</code> to <code>&amp;None</code> regardless, right? (Because the discriminant, even if not stored <em>inside</em> the <code>Cell</code>, would still be in the same <em>struct</em>.)</p>",
        "id": 185871113,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579215503
    },
    {
        "content": "<p>The meaning of the attribute hasn't changed, I am just referring to what it's used for. It's always been specified to give ABI compatibility and motivated by that, but as a side effect it also guarantees size+align equal to the non-ZST field (the size part is necessary for ABI compatibility, the align part perhaps not but it's still implied by the RFC). People took note and started using <code>repr(transparent)</code> to document and/or enforce that <code>SomeWrapper&lt;T&gt;</code> has the same memory layout as <code>T</code> -- perhaps for the lack of a better alternative (<code>repr(C)</code> implies a host or other things you may not want or need, and without any <code>repr</code> the layout is technically unspecified).</p>",
        "id": 185871885,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579216112
    },
    {
        "content": "<p>Actually, I believe we <em>did</em> specify it in the UCG</p>",
        "id": 185871953,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579216167
    },
    {
        "content": "<p>which of course aren't formally decided upon</p>",
        "id": 185871958,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579216173
    },
    {
        "content": "<p>but we might want to start moving towards changing that</p>",
        "id": 185871965,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579216180
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/structs-and-tuples.html#single-field-structs\" target=\"_blank\" title=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/structs-and-tuples.html#single-field-structs\">see this section</a></p>",
        "id": 185872037,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579216221
    },
    {
        "content": "<p>but perhaps I'm confused</p>",
        "id": 185872044,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579216226
    },
    {
        "content": "<p>Oh, indeed. But as you say, UCG isn't normative. Moreover, this part is just a few months old (<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/pull/164\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/pull/164\">https://github.com/rust-lang/unsafe-code-guidelines/pull/164</a>) so UnsafeCell and Cell being transparent predates it.</p>",
        "id": 185872278,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579216394
    },
    {
        "content": "<p>My framing above may be ahistorical, even the author of the RFC wanted to make UnsafeCell transparent -- not to pass UnsafeCells by values, but just to shut up <code>improper_ctypes</code> about <code>UnsafeCell</code> fields of structs passed \"by pointer\". See e.g. <a href=\"https://github.com/rust-lang/rfcs/pull/1758#issuecomment-249611805\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/1758#issuecomment-249611805\">https://github.com/rust-lang/rfcs/pull/1758#issuecomment-249611805</a></p>",
        "id": 185872572,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579216613
    },
    {
        "content": "<p>It seems that \"same layout as the inner type\" is very useful, should it be introduced as a separate attribute?</p>",
        "id": 185877476,
        "sender_full_name": "Lokathor",
        "timestamp": 1579221674
    },
    {
        "content": "<p>My current plan is to introduce <code>#[repr(no_niche)]</code> (or maybe <code>#[repr(hide_niche)]</code>), and then <code>#[repr(tranparent, no_niche)]</code> would have the ABI-oriented meaning, while <code>#[repr(transparent)]</code> would have the layout-oriented one.</p>",
        "id": 185878816,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579223303
    },
    {
        "content": "<p>(I just mention this as a way of saying \"I think that is a clean way to express these distinct ideas\")</p>",
        "id": 185878836,
        "sender_full_name": "pnkfelix",
        "timestamp": 1579223339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> </p>\n<blockquote>\n<p>In this case, the code converts a &amp;Option&lt;Cell&lt;&amp;u32&gt;&gt; into a *mut usize and writes a 0 to it. This changes the Option from Some to None. This means that, from the caller's point-of-view, if we invoke a function that takes an argument of type &amp;Option&lt;Cell&lt;&amp;u32&gt;&gt; we must assume that this argument may spontaneously change from &amp;Some(_) to &amp;None, even though safe code could not possibly do that.</p>\n</blockquote>\n<p>It's not just that safe could couldnt do it, it's that this violates the idea that shared references point to immutable data: the discriminant of <code>Option&lt;Cell&lt;i32&gt;&gt;</code> is logically outside the <code>UnsafeCell</code>, so arguably it should be subject to the \"does not change\" guarantee and the optimizer should be allowed to exploit that. except that Stacked Borrows is location-based, so even in its most precise handling of UnsafeCell, it cannot justify this optimization. Justifying the optimization would require the crazy \"shadow discriminant\" stuff I mentioned.</p>",
        "id": 185896500,
        "sender_full_name": "RalfJ",
        "timestamp": 1579249843
    },
    {
        "content": "<blockquote>\n<p>In particular, I agree the code is surprising, but I'm not sure if it can be blamed purely on niches or lack thereof. If I recall, you were arguing for a \"infectious\" semantics for UnsafeCell, in which having an UnsafeCell inside of a struct means that (from stacked borrows point-of-view) the entire struct is writable via a shared reference. (Though presently the semantics are somewhat different, and extend only through enums.)</p>\n</blockquote>\n<p>Indeed Stacked Borrows currently is less precise about UnsafeCell than a location-based model could be -- but the point is that with <code>Option&lt;Cell&lt;bool&gt;&gt;</code>, even if we made it fully precise, it'd still be \"wrong\" in some sense.</p>",
        "id": 185896550,
        "sender_full_name": "RalfJ",
        "timestamp": 1579249916
    },
    {
        "content": "<p>but indeed, with the \"infectious\" semantics (as it is currently implement for enums -- but structs are still handled precisely), it doesnt really make much of a difference whether <code>Cell</code> exposes niches or not</p>",
        "id": 185896984,
        "sender_full_name": "RalfJ",
        "timestamp": 1579250481
    },
    {
        "content": "<p>so, yeah, this is certainly not entirely clear-cut. I merely listed this as further evidence that UnsafeCell with niches is \"odd\" even in the sequential case -- with consequences for potential variants of Stacked Borrows, but indeed without direct ramifications for the current version</p>",
        "id": 185897054,
        "sender_full_name": "RalfJ",
        "timestamp": 1579250552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Your argument re. active union field &amp; stacked borrows weighed heavily into our decision last night <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 185897093,
        "sender_full_name": "centril",
        "timestamp": 1579250604
    },
    {
        "content": "<p>hm, okay^^. maybe I should have pointed out the part about the \"infectious\" semantics earlier...<br>\nanyway, I need to start doing \"real\" work now, ttyl</p>",
        "id": 185897172,
        "sender_full_name": "RalfJ",
        "timestamp": 1579250700
    },
    {
        "content": "<p>have fun</p>",
        "id": 185897192,
        "sender_full_name": "centril",
        "timestamp": 1579250728
    },
    {
        "content": "<blockquote>\n<p>My current plan is to introduce <code>#[repr(no_niche)]</code> (or maybe <code>#[repr(hide_niche)]</code>), and then <code>#[repr(tranparent, no_niche)]</code> would have the ABI-oriented meaning, while <code>#[repr(transparent)]</code> would have the layout-oriented one.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I'm not sure if this explanation makes sense to me. Whether there are niches is not really call ABI vs memory layout of the type itself, and more about a further property that does not fit under either: for which type constructors <code>Foo&lt;T&gt;</code> does <code>Foo&lt;Transparent&lt;X&gt;&gt;</code> have the same memory layout and/or call ABI as <code>Foo&lt;X&gt;</code>? There are many <code>Foo</code> where this is false even when niches are \"propagated\" by <code>Transparent</code>, and many <code>Foo</code> where it's true even when niches are \"hidden\", and it can be relevant to both call ABI and memory layout (cf. <code>Option&lt;UnsafeCell&lt;&amp;T&gt;&gt;</code> being FFI safe or not). So I consider it a related but separate question from whether <code>Transparent&lt;X&gt;</code>has the same \"layout\" and/or \"ABI\" (however we define those terms) as <code>X</code>.</p>\n<p>I'm also wondering if introducing <code>repr(no_niche)</code> is really better than just special-casing UnsafeCell: is there any other type that would have any reason whatsoever to use it? It seems to me that the inability to exploit niches is inseparable from interior mutability, and while some types with interior mutability (like <code>Cell</code>) might want to opt back into it for performance, there doesn't seem to be any incentive for types <em>without</em> interior mutability to opt out of it.</p>",
        "id": 185903345,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1579256684
    },
    {
        "content": "<p>okay, turns out that we don't need to even talk about how \"infectious\" <code>UnsafeCell</code> are... <a href=\"https://github.com/rust-lang/rust/issues/68303\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/68303\">https://github.com/rust-lang/rust/issues/68303</a> demonstrates that there is a more fundamental problem with niches and <code>UnsafeCell</code> and stacked borrows. And it's blindingly obvious, so I wonder why I didn't see that earlier... probably I'm just stretched too thin so I dont give each thing that comes up the time it needs :/</p>\n<p>It's exactly the same thing as with concurrency: a mutable reference gets created, then a conflicting read happens through another pointer (invalidating the mutable reference), and then the (now invalidated) mutable reference gets used</p>",
        "id": 185908930,
        "sender_full_name": "RalfJ",
        "timestamp": 1579262076
    },
    {
        "content": "<p>well, at least this reaffirms the recommendation I gave yesterday, that interior mutability with niches is a problem even in sequential code -- maybe my intuition saw things I didnt entirely realize yet ;)</p>",
        "id": 185909054,
        "sender_full_name": "RalfJ",
        "timestamp": 1579262185
    },
    {
        "content": "<p>hm, so maybe I'm failing to understand something, but it feels like in the niches-don't-propagate through UnsafeCell model, then that code should/would pass miri? As the discriminant's place would be different, and the enum there would be essentially equivalent to a discriminant (u8) + a separate struct/union with the (maybe present) RefCell?</p>",
        "id": 185912397,
        "sender_full_name": "simulacrum",
        "timestamp": 1579265213
    },
    {
        "content": "<p>maybe stacked borrows does not model &amp;(T, UnsafeCell&lt;U&gt;) -&gt; &amp;mut U as retaining &amp;T in the allowed set in some apis though</p>",
        "id": 185912438,
        "sender_full_name": "simulacrum",
        "timestamp": 1579265273
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> thanks for your comments. Did you see what I wrote in <a href=\"https://hackmd.io/7rk-0h8WTqKQgaWB6aaeaw#What-about-Cell\" target=\"_blank\" title=\"https://hackmd.io/7rk-0h8WTqKQgaWB6aaeaw#What-about-Cell\">the hackmd section</a>? That was based on your prior comments, but I think it agrees with what you wrote. (I've not checked out <a href=\"https://github.com/rust-lang/rust/issues/68303\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/68303\">rust-lang/rust#68303</a> yet, I guess I will extend the hackmd once I do...)</p>",
        "id": 185921974,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579272753
    },
    {
        "content": "<p>Oh, ok, I see what <a href=\"https://github.com/rust-lang/rust/issues/68303\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/68303\">rust-lang/rust#68303</a> is about. Yes, very much.</p>",
        "id": 185922031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579272800
    },
    {
        "content": "<p>This is the same basic point.</p>",
        "id": 185922035,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579272805
    },
    {
        "content": "<p>(But in reverse)</p>",
        "id": 185922061,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579272834
    },
    {
        "content": "<p>That is, here, the problem is that we are reading the <em>discriminant</em> and this is creating a borrow of <em>the payload</em></p>",
        "id": 185922112,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579272849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> thank you for taking the time to prepare the hackmd</p>",
        "id": 185933184,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279289
    },
    {
        "content": "<p>I have some questions</p>",
        "id": 185933189,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279294
    },
    {
        "content": "<blockquote>\n<p>A &amp;Option&lt;Mutex&lt;bool&gt;&gt;, for example, might be shared between two threads</p>\n</blockquote>\n<p>IIUC <code>Mutex</code> has a niche, because it contains an <code>UnsafeCell&lt;bool&gt;</code> that has a niche, is that correct ?</p>",
        "id": 185933315,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279351
    },
    {
        "content": "<p>And two threads can match on the option, using the discriminant, one thread can get ahold of the lock, and write to the <code>bool</code>, which changes the discriminant, and there is a data-race.  OTOH,  <code>&amp;Mutex&lt;Option&lt;bool&gt;&gt;</code> would not be unsound, right ?</p>",
        "id": 185933746,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279573
    },
    {
        "content": "<p>Since the discriminant is only modified by the thread that has the <code>Mutex</code></p>",
        "id": 185933830,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279611
    },
    {
        "content": "<p>So a very different approach might be to not make <code>Option&lt;T&gt;: Sync</code> when <code>T: Sync</code>, but only when <code>T: Sync</code> and the option does not store the discriminant within <code>T</code> due to a layout optimizations, but this approach is probably not ok because it would mean that type checking would depend on layout optimizations..</p>",
        "id": 185934090,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279715
    },
    {
        "content": "<p>Inhibiting niches in <code>UnsafeCell&lt;T&gt;</code> does seem like the best way to fix things</p>",
        "id": 185934310,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579279808
    },
    {
        "content": "<blockquote>\n<p>IIUC <code>Mutex</code> has a niche, because it contains an <code>UnsafeCell&lt;bool&gt;</code> that has a niche, is that correct ?</p>\n</blockquote>\n<p>correct</p>",
        "id": 185934904,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579280086
    },
    {
        "content": "<blockquote>\n<p>And two threads can match on the option, using the discriminant, one thread can get ahold of the lock, and write to the <code>bool</code>, which changes the discriminant, and there is a data-race.  OTOH,  <code>&amp;Mutex&lt;Option&lt;bool&gt;&gt;</code> would not be unsound, right ?</p>\n</blockquote>\n<p>correct</p>",
        "id": 185934948,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579280107
    },
    {
        "content": "<blockquote>\n<p>Specifically, the type Option&lt;UnsafeCell&lt;&amp;i32&gt;&gt; is currently considered FFI-safe (and same for Cell), as it would be represented as a Option&lt;&amp;i32&gt; which in turn is a nullable pointer. After this change, that will no longer be the case.</p>\n</blockquote>\n<p>I think <code>extern</code> blocks should require <code>unsafe</code>, so I'm not to worried about that, the FFI-safe lints are a \"best effort\" warning, and we have tuned those in the past.</p>",
        "id": 185934971,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579280116
    },
    {
        "content": "<blockquote>\n<p>So a very different approach might be to not make <code>Option&lt;T&gt;: Sync</code> when <code>T: Sync</code>, but only when <code>T: Sync</code> and the option does not store the discriminant within <code>T</code> due to a layout optimizations, but this approach is probably not ok because it would mean that type checking would depend on layout optimizations..</p>\n</blockquote>\n<p>this would also be wildly backwards incompatible</p>",
        "id": 185935091,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579280169
    },
    {
        "content": "<blockquote>\n<p>hm, so maybe I'm failing to understand something, but it feels like in the niches-don't-propagate through UnsafeCell model, then that code should/would pass miri? As the discriminant's place would be different, and the enum there would be essentially equivalent to a discriminant (u8) + a separate struct/union with the (maybe present) RefCell?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> yes, my hypothesis is that removing niches from UnsafeCell will fix this bug as well. I can try this in Miri once a PR for the niche removal exists.</p>",
        "id": 185944635,
        "sender_full_name": "RalfJ",
        "timestamp": 1579286564
    },
    {
        "content": "<p>(well, I'll be travelling next week, so -- after I'm back, probably)</p>",
        "id": 185944641,
        "sender_full_name": "RalfJ",
        "timestamp": 1579286574
    },
    {
        "content": "<blockquote>\n<p>maybe stacked borrows does not model &amp;(T, UnsafeCell&lt;U&gt;) -&gt; &amp;mut U as retaining &amp;T in the allowed set in some apis though</p>\n</blockquote>\n<p>I dont understand what you are saying here</p>",
        "id": 185944670,
        "sender_full_name": "RalfJ",
        "timestamp": 1579286594
    },
    {
        "content": "<p>Ah okay, so you were talking about current behavior I think</p>",
        "id": 185944681,
        "sender_full_name": "simulacrum",
        "timestamp": 1579286607
    },
    {
        "content": "<p>I was trying to say that it seemed like once the discriminant was not in a niche then things should work just fine</p>",
        "id": 185944765,
        "sender_full_name": "simulacrum",
        "timestamp": 1579286647
    },
    {
        "content": "<p>Which I think we agree with</p>",
        "id": 185944789,
        "sender_full_name": "simulacrum",
        "timestamp": 1579286672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> well, I had a brief phase of \"you are right that the 'infectious' UnsafeCell almost make this niche thing a moot point for Stacked Borrows\", followed by that miri issue and realizing \"nope the point is not moot at all, this is important and yes the niches should go, even for sequential code\".<br>\nwhen I saw that miri issue, things seemed so obvious that I really wonder why I didnt see it before... it was right there in front of my eyes whenever I had niche trouble with Stacked Borrows, but I was blinded because our formal models all dont implement niche optimizations, and I probably thought too much like them. I think that should teach me something, I'll have to reflect on it.</p>",
        "id": 185944852,
        "sender_full_name": "RalfJ",
        "timestamp": 1579286743
    },
    {
        "content": "<blockquote>\n<p>Ah okay, so you were talking about current behavior I think</p>\n</blockquote>\n<p>yes I was -- I should probably be more clear when there are many candidate models floating around^^</p>",
        "id": 185944959,
        "sender_full_name": "RalfJ",
        "timestamp": 1579286824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> FWIW, I feel the same way about <a href=\"https://github.com/rust-lang/rust/issues/57893\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/57893\">#57893</a> -- I remember thinking to myself when implementing the current checks years ago \"this seems so simplistic; can this really suffice?\". Ah well. Anyway, I extended the <a href=\"https://hackmd.io/7rk-0h8WTqKQgaWB6aaeaw#A-deeper-conflict\" target=\"_blank\" title=\"https://hackmd.io/7rk-0h8WTqKQgaWB6aaeaw#A-deeper-conflict\">hackmd section</a> on the \"deeper conflict\" and I <em>think</em> I captured what's going on.</p>\n<p>I admit to some discomfort still about how to square that text with the idea that we may sometimes expand the \"scope\" of struct affected by an <code>UnsafeCell</code>.</p>",
        "id": 185994598,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1579352602
    },
    {
        "content": "<blockquote>\n<p>I admit to some discomfort still about how to square that text with the idea that we may sometimes expand the \"scope\" of struct affected by an UnsafeCell.</p>\n</blockquote>\n<p>hm... that is entirely orthogonal though? the latest counterexample doesnt interact with that \"scope expansion\" at all</p>",
        "id": 186628949,
        "sender_full_name": "RalfJ",
        "timestamp": 1580057821
    },
    {
        "content": "<p>Ah, <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>, I think I see your point. The point is, in <a href=\"https://github.com/rust-lang/rust/issues/68303\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/68303\">#68303</a>, the problem is the <code>&amp;</code> borrow \"re-asserting\" a shared-lock (at least that's how I think about it =)), versus the other examples where we have the cell permitting surprise mutations. Yes, makes sense. I feel better now.</p>\n<p>I guess more generally we have to remember that things \"run both ways\" -- i.e., we were focused on how <code>Cell</code> permits mutation, but the same memory overlap can <em>also</em> be used by <em>safe code</em> to establish borrows.</p>",
        "id": 186758042,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1580195375
    },
    {
        "content": "<p>we don't have literal locks any more, that was an old proposal from my first internship -- but, yes :D</p>",
        "id": 186801911,
        "sender_full_name": "RalfJ",
        "timestamp": 1580230473
    },
    {
        "content": "<p>Yes, I know. I still think of it as a kind of lock. =)</p>",
        "id": 187278991,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1580747800
    }
]