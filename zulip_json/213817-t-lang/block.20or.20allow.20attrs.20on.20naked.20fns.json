[
    {
        "content": "<p>Regarding the pending stabilization of naked functions, <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> brought up in <a href=\"https://github.com/rust-lang/rust/issues/90957#issuecomment-1028351639\">https://github.com/rust-lang/rust/issues/90957#issuecomment-1028351639</a> the idea of further restricting the set of attributes that are allowed on naked functions. Amanieu phrased it as having a list of allowed attributes, but further comments focused more on the list of forbidden attributes, so in <a href=\"https://github.com/rust-lang/rust/pull/93809\">https://github.com/rust-lang/rust/pull/93809</a> I implemented it as rejecting a list of known-bad attributes rather than accepting a list of known-good attributes. Does anyone think it should be the other way around for the purpose of this PR? For now there's no difference between the two approaches, but differences arise for when future attributes are implemented, where they will either need to be manually forbidden from being used with naked functions or manually permitted to be used with naked functions.</p>",
        "id": 271440122,
        "sender_full_name": "bstrie",
        "timestamp": 1644504109
    },
    {
        "content": "<p>Ideally we'd have an exhaustive match or something like that to force evaluation of the choice on each new attribute, but the compiler's attribute handling is not well suited to that today I believe.</p>",
        "id": 271440226,
        "sender_full_name": "simulacrum",
        "timestamp": 1644504160
    },
    {
        "content": "<p>Personally I think that ideally no attribute would be incompatible with any other attribute, but that instead any attributes that are incompatible should be options on the <em>same</em> attribute, and that the code that handles the expansion for that attribute should determine the validity of incompatible options. E.g., instead of having to say \"attributes compatible with #[naked]: &lt;long list&gt;\", \"attributes incompatible with #[naked]: inline, ...\" (and then having to update these lists and the analogous lists for every other attribute any time any other attribute is added), we could just have a single #[codegen] attribute with \"naked = true\" and \"inline = always\" options, and have the codegen expansion guarantee that inline and naked aren't specified together.</p>",
        "id": 271443063,
        "sender_full_name": "bstrie",
        "timestamp": 1644505348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> For now, I would suggest the accept-known-good approach, even though it's a longer list, because rejecting new attributes is safer. We can always move something from rejected to accepted, that's a compatible change. Moving something from accepted to rejected is a breaking change if anyone noticed and used it.</p>",
        "id": 271466629,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644514873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/block.20or.20allow.20attrs.20on.20naked.20fns/near/271440226\">said</a>:</p>\n<blockquote>\n<p>Ideally we'd have an exhaustive match or something like that to force evaluation of the choice on each new attribute, but the compiler's attribute handling is not well suited to that today I believe.</p>\n</blockquote>\n<p>I intend to implement Josh's suggestion here and make an allowlist for naked, how much work do you think it would be for me to go all the way and implement <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> 's idea here? I'm already going to have to make some quite invasive changes, since the existing check_attrs pass happens too late in the pipeline to actually give any assurance of this guarantee (e.g. #[test] is already long gone by then), so maybe I should just go all the way.</p>",
        "id": 271471453,
        "sender_full_name": "bstrie",
        "timestamp": 1644516769
    },
    {
        "content": "<p>I suspect it's a lot of work</p>",
        "id": 271473322,
        "sender_full_name": "simulacrum",
        "timestamp": 1644517566
    },
    {
        "content": "<p>I wouldn't go that far.</p>",
        "id": 271473326,
        "sender_full_name": "simulacrum",
        "timestamp": 1644517570
    },
    {
        "content": "<p>Well, I think this might be a lot of work either way :P First I need to figure out where in the compiler it even makes sense to do this check. I want to deny any unknown builtin attributes, <em>without</em> denying any user-defined proc macros...</p>",
        "id": 271489085,
        "sender_full_name": "bstrie",
        "timestamp": 1644524614
    },
    {
        "content": "<p>That should happen automatically, as long as you perform the check on the HIR or lowered function</p>",
        "id": 271490040,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644525076
    },
    {
        "content": "<p>all custom attributes get expanded and removed during macro expansion</p>",
        "id": 271490067,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644525088
    },
    {
        "content": "<p>watch out for stuff like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[my_proc_macro]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[naked]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[haha_this_is_a_pain_to_filter]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"ret\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">noreturn</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271490249,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644525184
    },
    {
        "content": "<p>what is <code>haha_this_is_a_pain_to_filter</code>? another proc-macro attribute?</p>",
        "id": 271490292,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644525217
    },
    {
        "content": "<p>If so, then that's covered by the logic I mentioned above</p>",
        "id": 271490321,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644525236
    },
    {
        "content": "<p>There are no remaining macro invocations after we run macro expansion</p>",
        "id": 271490376,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644525252
    },
    {
        "content": "<p>a passive attribute interpreted by the proc macro</p>",
        "id": 271490383,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644525257
    },
    {
        "content": "<p>where would that attribute come from?</p>",
        "id": 271490398,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644525268
    },
    {
        "content": "<p>the user wrote it, cuz it modifies how the proc macro behaves</p>",
        "id": 271490452,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1644525306
    }
]