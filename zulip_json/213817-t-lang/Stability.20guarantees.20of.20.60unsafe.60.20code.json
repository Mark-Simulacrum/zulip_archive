[
    {
        "content": "<p>If ever some variant of SB, strict provenance, etc. is stabilized, it is inevitable that some code will \"break\" - there are multiple possible levels to this though:</p>\n<ul>\n<li>Code for which there was non-normative agreement that it is unsound already becomes normatively unsound</li>\n<li>Code for which it was unclear whether it would be sound becomes normatively unsound</li>\n<li>Code for which there was non-normative agreement that it would be sound becomes normatively unsound</li>\n<li>Code for which there was normative agreement (for each of the various definitions of normative that you like) that it would be sound becoming normatively unsound</li>\n</ul>\n<p>Additionally, some code will stop compiling - this is likely inevitable, as at the very least CTFE will be allowed to report more UB. It might also be the case that some APIs or language features have to be deprecated. I don't want to go into the details of <em>which</em> right now, that can be discussed elsewhere.</p>\n<p>My question is this: Currently, it's vaguely permitted for us to do such a thing under the \"soundness fixes\" exception to the stability guarantees. Is it worth it to try and clarify what exactly that covers, even if the answer is \"potentially quite a lot\"? To take some extreme example, (lets please not argue whether they are realistic or a good idea here) would eventually removing <code>usize as ptr</code> be an option? What if we eventually find some horrible bug in SB that means we have to break half the unsafe code out there in order to get any stronger aliasing model than C has? Would we be <em>allowed</em> to make that change? What are the guarantees we make to users here?</p>",
        "id": 277220411,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648687377
    },
    {
        "content": "<p>To clarify: those examples might seem like straw-mans, but to some extent I think that that is actually sort of the point. When we make guarantees to users, I personally feel that they should cover even the edge cases. If this is not something we want to commit to right now (which I imagine is the case), then it seems like the strongest guarantee we can make for unsafe code is that \"the lang team will balance the level of breakage against the benefits of the model and make a decision based on that.\" I would be perfectly content if this is the case; however, I worry that if people are not aware of this, we might get angry tweets from users complaining about Rust's stability guarantees being fake</p>",
        "id": 277220673,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648687700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277220411\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Code for which there was normative agreement (for each of the various definitions of normative that you like) that it would be sound becoming normatively unsound</li>\n</ul>\n</blockquote>\n<p>An example of this would be deciding that <code>usize</code> is really index-sized rather than pointer sized, as we have an RFC and documentation that says it's pointer-sized. This decision seems to be inconvenient now, though.</p>",
        "id": 277221121,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648688188
    },
    {
        "content": "<p>The whole \"what do we do about <code>mem::uninitialized</code>?\" conversation probably shows it a bunch.  Be increasingly aggressive about \"no, you can't use that any more\" over time, while still trying to keep it from breaking too much in old editions.</p>\n<p>And of course there are a bunch of things where we'd just say \"too bad, you weren't supposed to do that\" -- like when struct field reordering happened.</p>\n<p>I'm sure it's possible there are some things that would be too far, and we'd just shrug and leave it for whatever the next great language will be.</p>",
        "id": 277221530,
        "sender_full_name": "scottmcm",
        "timestamp": 1648688621
    },
    {
        "content": "<p>Yeah, the other thing that I'm realizing right now is that if we stabilize the memory model, it may be possible to do so as part of an edition, and declare all code before that edition \"potentially unsound, but we'll do our best.\" Optimizations can probably be edition gated pretty cleanly</p>",
        "id": 277221972,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648689073
    },
    {
        "content": "<p>So the consequences could be reduced to \"potentially unsound and slow, but at least it'll probably work most of the time\"</p>",
        "id": 277222042,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648689130
    },
    {
        "content": "<p>I think if we could gate optimizations across editions, we could also stop worrying about aliasing at FFI boundaries.</p>",
        "id": 277222105,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648689210
    },
    {
        "content": "<p>We may be able to mitigate the damage, but I'm worried about a partial measure that's good</p>",
        "id": 277222169,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648689287
    },
    {
        "content": "<p>Yes, absolutely, this would be by definition a partial solution. But if the vibe is indeed \"balance breakage against benefits\" then partial solutions might be exactly what we need</p>",
        "id": 277222279,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648689420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277221972\">said</a>:</p>\n<blockquote>\n<p>Optimizations can probably be edition gated pretty cleanly</p>\n</blockquote>\n<p>This gets messy depending where you want to pull the edition info.  Because does a lower-edition binary mean the higher-edition library doesn't get the strict behaviour?  What if there are macros putting code from multiple editions into the same function?</p>\n<p>I think this could get messy for the same reason that per-edition type inference can get messy.</p>",
        "id": 277224517,
        "sender_full_name": "scottmcm",
        "timestamp": 1648692139
    },
    {
        "content": "<p>So I think there are two things that save us here: 1) as I said before, this doesn't have to be perfect. If this is really just in the pursuit of reducing breakage, we can just ignore weird edge cases in a way that would be problematic for type inference</p>",
        "id": 277224971,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648692693
    },
    {
        "content": "<p>2) we can always fix this by turning off more rustc opts. I don't expect LLVM to be affected by this, because I don't expect LLVM to ever adopt a model that we cannot compile the code that we care about to (if they do, we have bigger issues anyway). This means that only rustc opts are affected. Given the nature of mir opts right now, clearly the performance of code optimized only by LLVM is competitive too. Maybe we get a bunch of perf benefits in the future from fancier opts. But if someone comes along and complains that their code is 10% slower and now only as fast as the equivalent C because they linked in some edition 2015 code, i won't be heartbroken</p>",
        "id": 277225153,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648692904
    },
    {
        "content": "<blockquote>\n<p>This gets messy depending where you want to pull the edition info. Because does a lower-edition binary mean the higher-edition library doesn't get the strict behaviour? What if there are macros putting code from multiple editions into the same function?</p>\n</blockquote>\n<p>This gets even messier with inlining and the like. Basically, it is impossible to track the source of some code with optimizations. If it woul be, we could get perfect debuginfo in release builds, and everyone that tried debugging them know we don't.</p>",
        "id": 277226294,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648694313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"340138\">Chayim Refael Friedman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277226294\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>This gets messy depending where you want to pull the edition info. Because does a lower-edition binary mean the higher-edition library doesn't get the strict behaviour? What if there are macros putting code from multiple editions into the same function?</p>\n</blockquote>\n<p>This gets even messier with inlining and the like. Basically, it is impossible to track the source of some code with optimizations. If it woul be, we could get perfect debuginfo in release builds, and everyone that tried debugging them know we don't.</p>\n</blockquote>\n<p>Well, we can just not inline edition bad into edition good code, or at least not inline edition bad code that uses <code>unsafe</code> into edition good code</p>",
        "id": 277230535,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648699154
    },
    {
        "content": "<blockquote>\n<p>Well, we can just not inline edition bad into edition good code in rustc</p>\n</blockquote>\n<p><em>That</em> is going to be a major perf bottleneck.</p>",
        "id": 277232829,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648701893
    },
    {
        "content": "<p>No it's not. The rust inliner is off right now, it'll be no worse</p>",
        "id": 277234110,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648703513
    },
    {
        "content": "<p>No, we would have to outline macro invocations if the macros have another edition. This would be worse than the current no outlining necessary.</p>",
        "id": 277234331,
        "sender_full_name": "bjorn3",
        "timestamp": 1648703830
    },
    {
        "content": "<p>In addition we may implement stacked borrow enabled optimizations by adding attributes to the llvm ir which means those optimizations are not limited to mir.</p>",
        "id": 277234384,
        "sender_full_name": "bjorn3",
        "timestamp": 1648703884
    },
    {
        "content": "<p>Yeah, if a poison pill means you get no <code>mutable-noalias</code> anymore, for example, that can have a big impact.</p>",
        "id": 277234403,
        "sender_full_name": "scottmcm",
        "timestamp": 1648703951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277234331\">said</a>:</p>\n<blockquote>\n<p>No, we would have to outline macro invocations if the macros have another edition. This would be worse than the current no outlining necessary.</p>\n</blockquote>\n<p>Or we can just also not do non-llvm opts on those functions</p>",
        "id": 277234998,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648704739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277234110\">said</a>:</p>\n<blockquote>\n<p>No it's not. The rust inliner is off right now, it'll be no worse</p>\n</blockquote>\n<p>And what with the LLVM inliner? As soon as we apply optimizations based on Stacked Borrows (currently only <code>noalias</code>, and even that can break old code).</p>",
        "id": 277235011,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648704773
    },
    {
        "content": "<p>Hm, ok, I feel like the point here is getting sort of lost. The goal is not to have two internally consistent sound versions of the Rust memory model, one \"old\" one and one \"new\" one. The goal is to avoid breakage of old code that was written before the existence of the new memory model. There's no reason to believe that we can't continue to do all the things we do today - if LLVM <code>noalias</code> is something we're ok with emitting today (and doesn't break huge amounts of code) I don't see why that shouldn't continue to be true</p>",
        "id": 277235094,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648704873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277235094\">said</a>:</p>\n<blockquote>\n<p>Hm, ok, I feel like the point here is getting sort of lost. The goal is not to have two internally consistent sound versions of the Rust memory model, one \"old\" one and one \"new\" one. The goal is to avoid breakage of old code that was written before the existence of the new memory model. There's no reason to believe that we can't continue to do all the things we do today - if LLVM <code>noalias</code> is something we're ok with emitting today (and doesn't break huge amounts of code) I don't see why that shouldn't continue to be true</p>\n</blockquote>\n<p>LLVM's <code>noalias</code> is indeed not something I'd expect to break most Rust code out there, even code written without Stacked Borrows in mind. However, we may want to apply future LLVM annotations that will be stricter. This is the most effective way to get the most out of SB, and allowing doing something like you propose will disallow it. That means we'll never be able to optimize Rust code for the best performance if it's using crates from older editions.</p>\n<p>There's no need to disable inlining: we can just disable the optimizations. But then if you'll have in your crate graph <em>one</em> crate that uses an older edition <em>the whole app</em> will not be best optimizable.</p>",
        "id": 277235271,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648705129
    },
    {
        "content": "<p>Yeah, I'm entirely unconvinced that it's not possible to do something smarter that avoids breakage. This seems like exactly the kind of problem that has some partial solution which covers 80% of cases</p>",
        "id": 277235544,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648705456
    },
    {
        "content": "<p>The problem is that when talking about Undefined Behavior, even 1% of the cases might be a nightmare <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 277235692,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648705599
    },
    {
        "content": "<p>Of course it is, but if we're going to take this to the extreme the only solution is to stop writing unsafe Rust immediately</p>",
        "id": 277235732,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648705654
    },
    {
        "content": "<p>Or to promise now that we'll never adopt an aliasing model stronger than C's</p>",
        "id": 277235795,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648705695
    },
    {
        "content": "<p>Or maybe disable all strict optimizations for the whole app when using older editions?</p>\n<p>This will cause people to update their code, I think <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 277235937,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648705840
    },
    {
        "content": "<p>If we decide that introducing an aliasing model which potentially makes existing code UB is not an option, then we can throw SB and friends out now. Now of course that's a reasonable opinion to hold, but if this is not the plan, then \"how do we introduce a formal memory model without introducing UB\" is not a realistic goal as far as I can see</p>",
        "id": 277235968,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648705887
    },
    {
        "content": "<p>That's significantly more draconian than anyone is going to accept, I think.</p>",
        "id": 277235974,
        "sender_full_name": "riking",
        "timestamp": 1648705892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"340138\">Chayim Refael Friedman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277235937\">said</a>:</p>\n<blockquote>\n<p>Or maybe disable all strict optimizations for the whole app when using older editions?</p>\n<p>This will cause people to update their code, I think <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>\n</blockquote>\n<p>Hold on, now I'm confused. Weren't you arguing against this a second ago?</p>",
        "id": 277235985,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648705904
    },
    {
        "content": "<blockquote>\n<p>Hold on, now I'm confused. Weren't you arguing against this a second ago?</p>\n</blockquote>\n<p>I said it will be slow (not \"terrible slow\", but \"as slow as C\"), and that trying to scope the hurt is problematic. But if you don't try to scope it and rather apply it to the whole program I think it's fine.</p>",
        "id": 277236176,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1648706043
    },
    {
        "content": "<p>oh I see</p>",
        "id": 277236238,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648706130
    },
    {
        "content": "<p>Isn't the promise of the edition system that all editions compile to the same MIR, keeping them compatible? I think that unless there's pre-MIR optimizations going on (which, there could be i guess?) then edition-specific optimization is very limited.</p>",
        "id": 277238088,
        "sender_full_name": "Lokathor",
        "timestamp": 1648707920
    },
    {
        "content": "<p>I think you could encode this by desugaring old code to different MIR operations than new code, i.e. <code>Write2015(Place, Rvalue)</code> or something</p>",
        "id": 277238403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648708222
    },
    {
        "content": "<p>they don't have to be date-named like this, they can just be native MIR ops with different specified semantics</p>",
        "id": 277238435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648708263
    },
    {
        "content": "<p>This can also extend to types, although I think it is harder in this case since you can get implicit transmutes or get confused about which type you are talking about if the types are written the same except for edition info and are interconvertible with no syntax (to avoid breakage)</p>",
        "id": 277238636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648708466
    },
    {
        "content": "<p>yeah, Stacked Borrows will definitely make some code UB that people wrote thinking it is not UB. OTOH making an aliasing model normative doesn't immediately break anything, it just gives 'license to break' by adding new optimizations. I expect if it turns out that one of those optimizations has surprisingly bad impact, we'll back it out and reassess. ideally the aliasing model is extensively evaluated and validated <em>before</em> it becomes normative, to reduce the chance of such surprises.</p>",
        "id": 277353298,
        "sender_full_name": "RalfJ",
        "timestamp": 1648769219
    },
    {
        "content": "<p>there is the hypothetical worst-case situation of \"this optimization breaks that huge codebase and it's impossible to fix the codebase and also impossible to adjust the model to encompass the codebase\" -- not sure if we want to decide what we would do in that case before the situaton arises.<br>\nanything else, we have 2 degrees of freedom:</p>\n<ul>\n<li>we can decide not to use our 'right to optimize' when the optimization benefit turns out to be tiny and the breakage of code that has UB too big. this is not satisfying and we should certainly work on ways to make sure more code is moved into UB-free land and no new code is written that has such UB, but that takes time. the <code>extern \"C\" fn</code> unwinding story might be an example of this.</li>\n<li>if we don't expect code to be able to avoid the UB, we can try to adjust the model so that the code actually becomes 'right'. we'll have to trade-off a clean and concise spec against a spec that models real-world code at that point... such is the life of a non-academic language designer, I guess. ;)</li>\n</ul>",
        "id": 277353764,
        "sender_full_name": "RalfJ",
        "timestamp": 1648769546
    },
    {
        "content": "<p>I'd caution about the first one.</p>",
        "id": 277354174,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648769951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"340138\">Chayim Refael Friedman</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277235271\">said</a>:</p>\n<blockquote>\n<p>There's no need to disable inlining: we can just disable the optimizations. But then if you'll have in your crate graph <em>one</em> crate that uses an older edition <em>the whole app</em> will not be best optimizable.</p>\n</blockquote>\n<p>I'm not sure why this is true? Can't we treat non-compliant code as a kind of \"FFI\" boundary? Surely whatever model we come up with has to expose some semantics when calling code written in arbitrary languages (C, assembly) that doesn't adhere to our model. It seems that we could always treat permissive-Rust as just another foreign language in that case.</p>",
        "id": 277370013,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648787822
    },
    {
        "content": "<p>After all, in the limit, you could literally expose an <code>extern \"C\"</code> stable-ABI interface to your old Rust code, compile it using an older version of rustc, and then link it into your final binary. Then all the Rust code that new-rustc sees will be model-compliant.</p>",
        "id": 277370090,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648787982
    },
    {
        "content": "<p>(If it weren't for the bothersome requirement of creating a stable ABI, this might actually be a reasonable solution for many folks, like us, with lots of old Rust!)</p>",
        "id": 277370156,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648788084
    },
    {
        "content": "<p>I wouldn't write off specifying an ABI as implausible as a solution.</p>",
        "id": 277370224,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788182
    },
    {
        "content": "<p>I mean having to manually write C bindings. If we actually specified an ABI for a sizable subset of Rust code, that could be a pretty reasonable solution too.</p>",
        "id": 277370246,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648788236
    },
    {
        "content": "<p>Oh yeah I meant more like</p>\n<p>effectively defining an implicit<br>\n<code>extern \"rust-stable\"</code></p>",
        "id": 277370292,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788273
    },
    {
        "content": "<p>Yeah. Freeze the ABI for old Rust as \"what rustc does today\"</p>",
        "id": 277370312,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648788307
    },
    {
        "content": "<p>not to put too fine a point on it, but a lot of people have been wanting \"an ABI that is actually more stable than the C one\"</p>",
        "id": 277370315,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788310
    },
    {
        "content": "<p>Well we'd probably want to wiggle it a bit.</p>",
        "id": 277370319,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788322
    },
    {
        "content": "<p>Maybe clean it up a bit before freezing it :)</p>",
        "id": 277370320,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648788323
    },
    {
        "content": "<p>Yeah</p>",
        "id": 277370321,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1648788324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277370315\">said</a>:</p>\n<blockquote>\n<p>not to put too fine a point on it, but a lot of people have been wanting \"an ABI that is actually more stable than the C one\"</p>\n</blockquote>\n<p>because uhhh I don't know if you have seen C ABIs but uhhhh</p>",
        "id": 277370327,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788342
    },
    {
        "content": "<p>......................</p>",
        "id": 277370328,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788346
    },
    {
        "content": "<p>It is hard to express how bad and how underdefined the System V ABI is, the \"standard\" ABI everyone except MSVC/Windows uses, and how many times it is actually subtly different in all sorts of ways that break code that seems okay on one arch and one OS but even just moving between OS, even if they \"both\" \"use\" \"System V\", can break it.</p>",
        "id": 277370486,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788529
    },
    {
        "content": "<p>Some of that is because they didn't really expect what happened next, but it turns out<br>\nthe years start coming<br>\nand they don't stop coming<br>\n( fed to the bools and I hit the ground running )</p>",
        "id": 277370597,
        "sender_full_name": "Jubilee",
        "timestamp": 1648788667
    },
    {
        "content": "<p>and Windows, uh... has... interesting solutions for people messing up the ABIs. like... fixing the stack at runtime. <a href=\"https://devblogs.microsoft.com/oldnewthing/20040115-00/?p=41043\">https://devblogs.microsoft.com/oldnewthing/20040115-00/?p=41043</a></p>",
        "id": 277371157,
        "sender_full_name": "Jubilee",
        "timestamp": 1648789427
    },
    {
        "content": "<p>Which, I must admit, that one doesn't cause any problems, as it were.</p>",
        "id": 277371201,
        "sender_full_name": "Jubilee",
        "timestamp": 1648789463
    },
    {
        "content": "<p>but so, one that lets people actually do Rust&lt;-&gt;Rust \"FFI\" would be actually pretty useful <strong>per se</strong>, as a result. It would allow exposing stable interfaces soundly without requiring those interfaces to be perfectly in accord with the rules of C, which fails to define a lot of things that people would otherwise want to use in FFI, or defines them but not all compilers actually agree on what the definition should be, nor even is there an obvious one we should \"favor\" in some cases, making it equally challenging.</p>",
        "id": 277371594,
        "sender_full_name": "Jubilee",
        "timestamp": 1648789925
    },
    {
        "content": "<p>C ABIs almost universally fail to define things like a register calling convention for functions that return two machine words.</p>",
        "id": 277384261,
        "sender_full_name": "riking",
        "timestamp": 1648801634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277353764\">said</a>:</p>\n<blockquote>\n<p>there is the hypothetical worst-case situation of \"this optimization breaks that huge codebase and it's impossible to fix the codebase and also impossible to adjust the model to encompass the codebase\" -- not sure if we want to decide what we would do in that case before the situaton arises.<br>\nanything else, we have 2 degrees of freedom:</p>\n<ul>\n<li>we can decide not to use our 'right to optimize' when the optimization benefit turns out to be tiny and the breakage of code that has UB too big. this is not satisfying and we should certainly work on ways to make sure more code is moved into UB-free land and no new code is written that has such UB, but that takes time. the <code>extern \"C\" fn</code> unwinding story might be an example of this.</li>\n<li>if we don't expect code to be able to avoid the UB, we can try to adjust the model so that the code actually becomes 'right'. we'll have to trade-off a clean and concise spec against a spec that models real-world code at that point... such is the life of a non-academic language designer, I guess. ;)</li>\n</ul>\n</blockquote>\n<p>We could also declare the code UB, turn on the optimizations by default and provide a way for them to turn off optimizations (which we already do to some extent).  Like the linux kernel disables some optimizations that break their idioms. For some projects that have tight control over their build process that can be acceptable.</p>",
        "id": 277432676,
        "sender_full_name": "The 8472",
        "timestamp": 1648825822
    },
    {
        "content": "<p>I think it would be better to minimize linguistic forks of the <code>-fno-strict-aliasing</code> kind, if we can.</p>",
        "id": 277433944,
        "sender_full_name": "Jubilee",
        "timestamp": 1648826341
    },
    {
        "content": "<p>If possible, yes. But imo it's still an option.</p>",
        "id": 277438586,
        "sender_full_name": "The 8472",
        "timestamp": 1648828323
    },
    {
        "content": "<p>We can't rule it out completely until everything is explored.</p>\n<p>But unnecessary linguistic forks are continually making discussions on Zulip heated (esp. in <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance\">#t-lang/wg-unsafe-code-guidelines &gt; Strict provenance</a> ) so <strong>I would really really like to avoid</strong> the topic of unnecessary forks <strong>until someone sees some limitation with backwards compatibility.</strong> </p>\n<p>Here I summarize why (I think) we can get all desirable things without breaking compatibility: <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277358112</a></p>",
        "id": 277440368,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829014
    },
    {
        "content": "<p>Again, if there's a reason to break backwards compatibility / create a fork, I'm very interested and let's talk. But until we have any reason to fork, let's not talk about forking and get people worried, because it gets people very very worried</p>",
        "id": 277440580,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648829094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"264702\">riking</span> <a href=\"#narrow/stream/213817-t-lang/topic/Stability.20guarantees.20of.20.60unsafe.60.20code/near/277384261\">said</a>:</p>\n<blockquote>\n<p>C ABIs almost universally fail to define things like a register calling convention for functions that return two machine words.</p>\n</blockquote>\n<p>That's true, but it's not clear if we'd want to include that in a hypothetical <code>extern \"safe\"</code> for instance, because it'd be harder to support from other languages that already know the C ABI.</p>",
        "id": 277440698,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648829147
    },
    {
        "content": "<p>That said, it's worth considering.</p>",
        "id": 277440722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648829158
    },
    {
        "content": "<p>I am not so sure the advantages wouldn't outweigh that for, for example, Rust&lt;-&gt;Swift calls</p>",
        "id": 277446703,
        "sender_full_name": "Jubilee",
        "timestamp": 1648831732
    },
    {
        "content": "<p>They very well might; the question is how that might impact our adoption rate for this ABI.</p>",
        "id": 277448946,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648832680
    },
    {
        "content": "<p>If we do something that says \"use the C ABI, and here are the data structures used to pass various safe things like counted strings\", that's easy to interoperate with from many things, including C. In particular, anything that can do C FFI could add support for this with no help from their runtime or compiler, just by having a wrapper library.</p>",
        "id": 277449005,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648832715
    },
    {
        "content": "<p>If we start diverging, such as \"use the C ABI, except that you can return up to four values in registers A, B, C, and D\", that needs special support from every language/runtime/etc, and that support can't just be a library.</p>",
        "id": 277449078,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648832758
    },
    {
        "content": "<p>You're correct, but if you can't agree on how to return a two-register-big struct from a function then you can't return (for example) a slice from a function. So that seems like a baseline we need to get people to agree on</p>",
        "id": 277458706,
        "sender_full_name": "Lokathor",
        "timestamp": 1648836874
    },
    {
        "content": "<p>that's true, it seems silly to have to have a pointer to what should be a two-reg struct</p>",
        "id": 277467595,
        "sender_full_name": "Jubilee",
        "timestamp": 1648841323
    },
    {
        "content": "<p>(honestly, 3 would be <em>way better</em> if we can manage it because in practice a lot of rust stuff is 3-reg)</p>",
        "id": 277468417,
        "sender_full_name": "Lokathor",
        "timestamp": 1648841876
    },
    {
        "content": "<p>(but just 2-reg would be fine if this was a rarely used ABI just for the occasional foreign call)</p>",
        "id": 277468496,
        "sender_full_name": "Lokathor",
        "timestamp": 1648841910
    },
    {
        "content": "<p>Strange concept: you could provide ~arbitrary ABI support as a library, if you're willing to take a small performance hit, by just providing a shim to the C ABI</p>",
        "id": 277468561,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648841956
    },
    {
        "content": "<p>Effectively, <code>extern \"C\" fn call(f: extern \"NotC\" fn())</code> and a bunch of other versions for whatever function/return combinations are used</p>",
        "id": 277468712,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648842032
    },
    {
        "content": "<p>And if <code>extern \"NotC\"</code> only differs from <code>extern \"C\"</code>-compatible ABIs for \"small\" amounts registers in/out, the space of shims isn't <em>too</em> too large</p>",
        "id": 277468861,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648842135
    },
    {
        "content": "<p>right.</p>",
        "id": 277470216,
        "sender_full_name": "Jubilee",
        "timestamp": 1648842998
    }
]