[
    {
        "content": "<p>we must go further. postfix let. values flow into bindings.</p>",
        "id": 255257946,
        "sender_full_name": "The 8472",
        "timestamp": 1632849147
    },
    {
        "content": "<p>What about postfix unsafe? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 255257955,
        "sender_full_name": "bjorn3",
        "timestamp": 1632849151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Ematch.20suffix/near/255257946\">said</a>:</p>\n<blockquote>\n<p>we must go further. postfix let. values flow into bindings.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Wowie. Supreme obfuscation.</p>",
        "id": 255260598,
        "sender_full_name": "pnkfelix",
        "timestamp": 1632849293
    },
    {
        "content": "<p>No no no. <code>x.let = expr</code>!</p>",
        "id": 255260727,
        "sender_full_name": "bjorn3",
        "timestamp": 1632849348
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>might actually buy you something.</p>",
        "id": 255260851,
        "sender_full_name": "pnkfelix",
        "timestamp": 1632849388
    },
    {
        "content": "<p>(no, <code>.operation</code> should only be used for expression =&gt; expression operations.)</p>",
        "id": 255261227,
        "sender_full_name": "pnkfelix",
        "timestamp": 1632849524
    },
    {
        "content": "<p>Just add <code>ðŸ‘†</code> as a sigil so the next one can refer to the result of the expression on the previous line.</p>",
        "id": 255261609,
        "sender_full_name": "The 8472",
        "timestamp": 1632849652
    },
    {
        "content": "<p>don't forget postfix divergence! <code>.break</code> <code>.continue</code> <code>.return</code> <code>.yeet</code></p>",
        "id": 255265229,
        "sender_full_name": "cuviper",
        "timestamp": 1632850857
    },
    {
        "content": "<p>you get those for free with postfix blocks</p>",
        "id": 255266244,
        "sender_full_name": "The 8472",
        "timestamp": 1632851223
    },
    {
        "content": "<p>you people are sick &lt;3</p>",
        "id": 255268981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1632852106
    },
    {
        "content": "<p>Make sure to postfix <code>unsafe</code> as well.<br>\n<code>(*ptr).unsafe</code></p>",
        "id": 255269200,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632852169
    },
    {
        "content": "<p>Oh, and function defintions as well. Rewrite <code>dangling&lt;T&gt;()</code> as <code>(NonNull&lt;T&gt;::new_unchecked(core::mem::align_of::&lt;T&gt;() as *mut T).unsafe).fn dangling&lt;T&gt;() -&gt; Self{}</code></p>",
        "id": 255269510,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632852269
    },
    {
        "content": "<p>We can do all of these given postfix macro!</p>",
        "id": 255271143,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632852841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Join the side.dark, we have syntax.postfix!</p>",
        "id": 255271414,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632852931
    },
    {
        "content": "<p>cpp energy: <code>fn deref_mut(self) -&gt; Self::Target &amp;mut</code></p>",
        "id": 255284246,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1632857535
    },
    {
        "content": "<p>postfix borrow and deref would be really nice for real though</p>",
        "id": 255284968,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1632857831
    },
    {
        "content": "<p>I often see code like <code>(&amp;*foo).bar</code> and it feels weird</p>",
        "id": 255285025,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1632857862
    },
    {
        "content": "<p>Just call deref() :)</p>",
        "id": 255285251,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632857951
    },
    {
        "content": "<p>I'd like the <code>-&gt;</code> operator before new types of deref ;3</p>",
        "id": 255290424,
        "sender_full_name": "Lokathor",
        "timestamp": 1632859880
    },
    {
        "content": "<p>I just remembered, there was also the <code>.move</code> idea:<br>\n<a href=\"#narrow/stream/213817-t-lang/topic/Spitballing.3A.20a.20.60move.28x.29.60.20expression.3F/near/212463117\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Spitballing.3A.20a.20.60move.28x.29.60.20expression.3F/near/212463117</a></p>",
        "id": 255306166,
        "sender_full_name": "cuviper",
        "timestamp": 1632866002
    },
    {
        "content": "<p><code>true.if { println!(\"true\"); }</code></p>",
        "id": 255329373,
        "sender_full_name": "isHavvy",
        "timestamp": 1632880499
    },
    {
        "content": "<p>The empty postfix macro?</p>\n<p><code>false.!.if { println!(\"false\"); }</code></p>",
        "id": 255363034,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1632905157
    },
    {
        "content": "<p>that is <code>.not()</code>...</p>",
        "id": 255368751,
        "sender_full_name": "kennytm",
        "timestamp": 1632907990
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296643\">@isHavvy</span> I dunno if that was supposed to be ironic but I completely seriously want <code>some_bool.if { ... }</code></p>",
        "id": 256277810,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1633451818
    },
    {
        "content": "<p>coming from scala it always messed me up that we say <code>match</code> before the expr</p>",
        "id": 256277867,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1633451841
    },
    {
        "content": "<p><code>bool</code> already has <code>.then()</code></p>",
        "id": 256278197,
        "sender_full_name": "The 8472",
        "timestamp": 1633451968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/255257955\">said</a>:</p>\n<blockquote>\n<p>What about postfix unsafe? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>\n</blockquote>\n<p>As a serious answer to a <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>, postfix everything that takes a <em>value</em> (like <code>match</code> and <code>await</code> and <code>?</code>) but prefix everything that affects a <em>block-thunk</em> (like <code>while</code> and <code>async</code> and <code>try</code>).</p>",
        "id": 257410900,
        "sender_full_name": "scottmcm",
        "timestamp": 1634148341
    },
    {
        "content": "<p>Which, I suppose, does mean that postfix let could be allowed.  Arguably in shadowing cases the name resolution is even clearer for <code>x.parse()? -&gt; let x;</code> than in the prefix form.</p>\n<p>Similarly, <code>x.return</code> would be fine, though I wouldn't actually argue for it.  (Anything that's <code>-&gt; !</code> is a bit of an exception.)</p>",
        "id": 257411166,
        "sender_full_name": "scottmcm",
        "timestamp": 1634148449
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kc\">true</span><span class=\"p\">.</span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"true\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">sum</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">expr1</span><span class=\"p\">().</span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">value_a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">expr2</span><span class=\"p\">().</span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">value_b</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">value_a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">value_b</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 257413992,
        "sender_full_name": "Charles Lew",
        "timestamp": 1634149593
    },
    {
        "content": "<p>Let's just revive postfix macros :)</p>",
        "id": 257417445,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634150914
    },
    {
        "content": "<p>Yeah, that seems like a slightly easier alternative.</p>",
        "id": 257435560,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634158258
    },
    {
        "content": "<p>I'd like to revive postfix macros, but I'd <em>also</em> like to have <code>.match</code>.</p>",
        "id": 257549649,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634223552
    },
    {
        "content": "<p>It'd be a great to have a postfix way of calling free functions. Itertools could ditch its <a href=\"https://github.com/rust-lang/rust/issues/88878\">problematic extension trait</a> and define free functions instead, without totally sacrificing the ability to chain iterator adapters. (Maybe postfix macros could help with that too; not sure.)</p>",
        "id": 257583036,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1634236344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/257583036\">said</a>:</p>\n<blockquote>\n<p>It'd be a great to have a postfix way of calling free functions. Itertools could ditch its <a href=\"https://github.com/rust-lang/rust/issues/88878\">problematic extension trait</a> and define free functions instead, without totally sacrificing the ability to chain iterator adapters. (Maybe postfix macros could help with that too; not sure.)</p>\n</blockquote>\n<p>That should be as easy as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$self</span>:<span class=\"nc\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cp\">$f</span>:<span class=\"nc\">expr</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"w\"> </span><span class=\"cp\">$arg</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$f</span><span class=\"p\">(</span><span class=\"cp\">$self</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"w\"> </span><span class=\"cp\">$arg</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>with postfix macros, then you can do <code>expr.map!(free_fn, extra_args)</code></p>",
        "id": 257595195,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634241326
    },
    {
        "content": "<p>Of course, postfix <code>match</code> is kindof a pipe <a href=\"https://docs.rs/tap/1.0.1/tap/#piping\">https://docs.rs/tap/1.0.1/tap/#piping</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">free_fn</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">extra</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 257595573,
        "sender_full_name": "scottmcm",
        "timestamp": 1634241458
    },
    {
        "content": "<p>Oh yeah, with extension traits macros are not needed for that</p>",
        "id": 257596120,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634241650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/257595195\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/257583036\">said</a>:<br>\nwith postfix macros, then you can do <code>expr.map!(free_fn, extra_args)</code></p>\n</blockquote>\n<p>this...is not equivalent in terms of ergonomics though =)</p>",
        "id": 257619289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634252309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/257595195\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/257583036\">said</a>:</p>\n<blockquote>\n<p>It'd be a great to have a postfix way of calling free functions. Itertools could ditch its <a href=\"https://github.com/rust-lang/rust/issues/88878\">problematic extension trait</a> and define free functions instead, without totally sacrificing the ability to chain iterator adapters. (Maybe postfix macros could help with that too; not sure.)</p>\n</blockquote>\n<p>That should be as easy as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$self</span>:<span class=\"nc\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cp\">$f</span>:<span class=\"nc\">expr</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"w\"> </span><span class=\"cp\">$arg</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$f</span><span class=\"p\">(</span><span class=\"cp\">$self</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"w\"> </span><span class=\"cp\">$arg</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>with postfix macros, then you can do <code>expr.map!(free_fn, extra_args)</code></p>\n</blockquote>\n<p>As a nit, I think I'd call that <code>.apply!</code>, but otherwise that seems reasonable.</p>",
        "id": 257690734,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634301558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/257583036\">said</a>:</p>\n<blockquote>\n<p>Itertools could ditch its <a href=\"https://github.com/rust-lang/rust/issues/88878\">problematic extension trait</a> and define free functions instead</p>\n</blockquote>\n<p>I've often wished we allowed <code>foo.Display::fmt(...)</code> and <code>foo.Debug::fmt(...)</code> or something for disambiguating.  Would be nice to not have to make the big jump to UFCS for this stuff.</p>\n<p>That could even be a opt-in <code>cargo fix</code> for people who want extra protection against breakage when dependencies add new methods.</p>",
        "id": 257793642,
        "sender_full_name": "scottmcm",
        "timestamp": 1634351924
    },
    {
        "content": "<p>that'd be relatively easy to do, we considered it back in the day</p>",
        "id": 258230689,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634662298
    },
    {
        "content": "<p>What needs to happen to move <a href=\"https://github.com/rust-lang/rust/issues/2442\">#2442</a> forward?</p>",
        "id": 263089181,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638233477
    },
    {
        "content": "<p>Do you mean <a href=\"https://github.com/rust-lang/rfcs/pull/2442\">https://github.com/rust-lang/rfcs/pull/2442</a> ?</p>",
        "id": 263089300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638233564
    },
    {
        "content": "<p>I think what that needs is a nomination for lang-team re-discussion, and the energy to re-discuss it.</p>",
        "id": 263093115,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638237205
    },
    {
        "content": "<p>I'm happy to provide the former.</p>",
        "id": 263093120,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638237211
    },
    {
        "content": "<p>We can hope for the latter.</p>",
        "id": 263093126,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638237233
    },
    {
        "content": "<p>Actually, hmmm. It's possible that all it needs is an FCP.</p>",
        "id": 263093183,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638237271
    },
    {
        "content": "<p>The one big issue I see that hasn't been addressed is <code>$self</code> analogous to <code>$crate</code></p>",
        "id": 263095580,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638239923
    },
    {
        "content": "<p>I haven't looked over the RFC in a while, but I thought it was understood that <code>$self</code> referred to the preceding expression as an opaque value.</p>",
        "id": 263096591,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638241188
    },
    {
        "content": "<p>Oh, that's right, the RFC had to use <code>$self:self</code> rather than <code>$self</code> for compatibility reasons.</p>",
        "id": 263097202,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638241754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> Right, it does.</p>",
        "id": 263097266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638241819
    },
    {
        "content": "<p>The desugar is approximately equivalent to <code>let _temp = ...; macro!(_temp, ...)</code></p>",
        "id": 263097273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638241840
    },
    {
        "content": "<p>Ah, right, forgot about the compatibility. Either way it's not a huge drawback.</p>",
        "id": 263097385,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638241929
    },
    {
        "content": "<p>So if all that's needed is a FCP...</p>",
        "id": 263097967,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1638242754
    },
    {
        "content": "<p>It's not clear if that's all that's needed.</p>",
        "id": 263099223,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638244449
    },
    {
        "content": "<p>I'm investigating now to see.</p>",
        "id": 263099225,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638244460
    },
    {
        "content": "<p>For the moment, since there's a lang meeting tomorrow, I'm going to go ahead and nominate it, and consider proposing FCP in the meeting.</p>",
        "id": 263107383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638255321
    },
    {
        "content": "<p>Awesome. Even though they're not typed (that's a whole different level of implementation), I think in practice they'll be largely restricted to some type. I know I've got some use cases in my head that would make reading code significantly better.</p>",
        "id": 263108305,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638256457
    },
    {
        "content": "<p>Now that I think of it, the lack of a postfix macro being typed could sort of be worked around by throwing an error if it's not the expected type</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$self</span>:<span class=\"nc\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"o\">&lt;</span><span class=\"n\">expected_type</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// everything else</span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The static assertions crate might be able to be used in more complicated situations.</p>",
        "id": 263108350,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638256555
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> I can easily imagine common cases where they're restricted to things implementing a trait, or even \"things implementing a pseudo-trait I haven't actually defined but which consists of having a function/field like this\".</p>",
        "id": 263109718,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638258097
    },
    {
        "content": "<p>But I do think the convention of giving <code>$self</code> a type with a binding may be useful in cases where it has a specific expected type.</p>",
        "id": 263109781,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638258136
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// ...</span>\n</code></pre></div>\n<p>could be used for something expecting a trait. The same but using a closure would work for needing a function/field.</p>",
        "id": 263109901,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258267
    },
    {
        "content": "<p>basically I don't think it'll be too hard to work around. Though it's probably a bit off topic, admittedly.</p>",
        "id": 263109915,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258300
    },
    {
        "content": "<p>It seems <em>useful</em> to have conventional ways of up-front defining what your macro expects in a checkable way.</p>",
        "id": 263109952,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638258349
    },
    {
        "content": "<p>You know, syntactically it should be possible to do something along the lines of <code>macro_rules! foo&lt;impl T&gt;</code>â€¦</p>",
        "id": 263110052,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258466
    },
    {
        "content": "<p>just a random thought</p>",
        "id": 263110058,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258473
    },
    {
        "content": "<p>certainly best to work on the basic untyped version first, though</p>",
        "id": 263110108,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258498
    },
    {
        "content": "<p>Interesting. Not type-based dispatch, just name-based dispatch with type-based \"nope\" once found?</p>",
        "id": 263110226,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638258605
    },
    {
        "content": "<p>Basically</p>",
        "id": 263110266,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258644
    },
    {
        "content": "<p>It would effectively be the same as what I was saying above</p>",
        "id": 263110276,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258658
    },
    {
        "content": "<p>So no contribution to inference, you have to already know that <code>impl T</code> applies or you get a type error?</p>",
        "id": 263110290,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638258668
    },
    {
        "content": "<p>I'm broadly in favor of an idea like that, though I'd love to see it prototyped as a macro-for-making-postfix-macros first.</p>",
        "id": 263110321,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638258703
    },
    {
        "content": "<p>I'd have to think about that one. Can't hurt to start there once (if) postfix macros are a thing. Adding inference could always come later.</p>",
        "id": 263110379,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258736
    },
    {
        "content": "<p>We're also both in favor of much more powerful macros, I'm pretty sure. Other people might have something to say about this, naturally.</p>",
        "id": 263110433,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638258819
    },
    {
        "content": "<p>Agreed, with the caveat that \"more powerful in what effects they can produce and how expressively they can do so\" and \"more powerful in how you can invoke them with more brevity of syntax\" are two different things and I'm not generally in favor of the latter.</p>",
        "id": 263110815,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638259198
    },
    {
        "content": "<p>So, <em>allowing</em> postfix <em>syntax</em> would do the one thing that macros can't handle. Having to make the macro emit some extra boilerplate to add type-based refinement or w/e is something typical and easy for macro authors to do. Inference can still be nudged by what the macro emits, by the way. We could later allow for type-scoped macros by having them either fail or be shadowed by already existing postfix macros. And by using poor-man's specialization, we can already feature macros featuring <em>code</em> which is interpreted differently for stuff that is known to implement a trait and stuff for which it's unknown (and with true <code>specialization</code> this meaning could even take into account the actual type the generic is instanced with). That is: (very-far-)future <em>features</em> may make writing some of these macros <em>easier</em>, but it can't make them more powerful (and regarding the \"writing macros more easily\" part, that's a task that a helper meta-macro can already tackle <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>)</p>",
        "id": 263139072,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638276666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I just checked your latest push to the RFC. With regard to correctness, couldn't we desugar into a closure now that disjoint captures are a thing? That would work for any situation, I think.</p>",
        "id": 263231914,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638320627
    },
    {
        "content": "<p>I thought about that, but then a postfix macro couldn't do control flow.</p>",
        "id": 263231999,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638320705
    },
    {
        "content": "<p>true</p>",
        "id": 263232015,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638320728
    },
    {
        "content": "<p>Hmm.  While I like the <code>self</code> matcher to distinguish that it's not getting the token tree, I'm less convinced by the <code>self</code>/<code>&amp;self</code>/<code>&amp;mut</code> thing here.  That feels to me like it shouldn't matter at the <em>token</em> level that the macro is operating.</p>",
        "id": 263239599,
        "sender_full_name": "scottmcm",
        "timestamp": 1638328543
    },
    {
        "content": "<p>Can it somehow lower into whatever the HIR thing is that creates autoref opportunities at type checking time?</p>",
        "id": 263239967,
        "sender_full_name": "scottmcm",
        "timestamp": 1638328989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/263108350\">said</a>:</p>\n<blockquote>\n<p>Now that I think of it, the lack of a postfix macro being typed could sort of be worked around by throwing an error if it's not the expected type</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$self</span>:<span class=\"nc\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"o\">&lt;</span><span class=\"n\">expected_type</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// everything else</span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The static assertions crate might be able to be used in more complicated situations.</p>\n</blockquote>\n<p>The goal is legimate,  but the implementation doesn't really work... Please take \"place-expression macros\"(don't know if there's a official term for this) into extra consideration:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$self</span>:<span class=\"nc\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$self</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Usage: <code>array.foo!() = 42; </code></p>\n<p>Please note that there's no chance to insert any statement(<code>let</code> or items) here, and adding braces is not possible too (that will convert this place expression into value expression)</p>",
        "id": 263241235,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638330467
    },
    {
        "content": "<p>That's fair. I'm largely envisioning expression context, as I think that'll be most common. It certainly won't work for everything.</p>",
        "id": 263245459,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1638335661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/263239967\">said</a>:</p>\n<blockquote>\n<p>Can it somehow lower into whatever the HIR thing is that creates autoref opportunities at type checking time?</p>\n</blockquote>\n<p>I would <em>love</em> to get a suggestion for text to that effect.</p>",
        "id": 263252341,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638342883
    },
    {
        "content": "<p>That sounds substantially cleaner.</p>",
        "id": 263252342,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638342890
    },
    {
        "content": "<p>Idea that can do this but involves larger overall change to the language and compiler:</p>\n<ol>\n<li>Introduce associated macro as a new kind of associated item, but allowed on inherent impls only.</li>\n<li>Add a special \"associated macro\" resolution, record usage when doing expansion.</li>\n<li>Typecheck during analysis.</li>\n</ol>",
        "id": 263252789,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638343346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> The first two of those sound a lot like type-based dispatch, which this was supposed to be simple enough to avoid.</p>",
        "id": 263252989,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638343532
    },
    {
        "content": "<p>(It's <em>simpler</em> type-based dispatch, since it only cares about &amp;/&amp;mut/owned, but it still sounds more complex than desired.)</p>",
        "id": 263253005,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638343556
    },
    {
        "content": "<p>Is there some reasonable way we could make this always look up by name alone, then substitute in code that leads to autoref during inference?</p>",
        "id": 263253075,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638343612
    },
    {
        "content": "<p>I don't think I have enough knowledge of where autoref happens in type checking to know how to phrase it.</p>",
        "id": 263253457,
        "sender_full_name": "scottmcm",
        "timestamp": 1638344010
    },
    {
        "content": "<p>Maybe this ties into the <code>let</code> vs <code>match</code> desugaring question?  If there was a kind of forwarding that preserved \"place-ness\" then it might happen naturally?</p>",
        "id": 263253637,
        "sender_full_name": "scottmcm",
        "timestamp": 1638344166
    },
    {
        "content": "<p>Hmm, if this only needed to support <code>&amp;mut self</code> and <code>&amp;self</code>, then I think we could do it as </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"cp\">$LHS</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">internal_temporary</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"cp\">$RHS</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">internal_temporary</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because then it'd get passed a place that could be assigned to or autoref'd or whatever.</p>\n<p>But of course that doesn't work for RHSs that want to move out of the LHS.</p>",
        "id": 263254176,
        "sender_full_name": "scottmcm",
        "timestamp": 1638344710
    },
    {
        "content": "<p>(Obviously I'm not going to <em>propose</em> <code>&amp;own</code> for this, but if we had that I think it would work to solve this.)</p>",
        "id": 263254285,
        "sender_full_name": "scottmcm",
        "timestamp": 1638344789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/263252989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> The first two of those sound a lot like type-based dispatch, which this was supposed to be simple enough to avoid.</p>\n</blockquote>\n<blockquote>\n<p>Is there some reasonable way we could make this always look up by name alone, then substitute in code that leads to autoref during inference?</p>\n</blockquote>\n<p>Indeed this is type-based. (I thought auto-ref is fundamentally a type-level thing?) I meant these three steps as a whole. I think i'm trying to define it exactly this way, just naming it \"associated macro\" for surface syntax level consistency.</p>",
        "id": 263254477,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638344978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/.2Epostfix.20all.20the.20things/near/263253457\">said</a>:</p>\n<blockquote>\n<p>I don't think I have enough knowledge of where autoref happens in type checking to know how to phrase it.</p>\n</blockquote>\n<p>The reference corresponding part is here: <a href=\"https://doc.rust-lang.org/stable/reference/expressions/method-call-expr.html\">https://doc.rust-lang.org/stable/reference/expressions/method-call-expr.html</a> It's defined as algorithm visiting impls, looking up associated items in a certain order.</p>",
        "id": 263254799,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638345214
    },
    {
        "content": "<p>I think this simple postfix macro doesn't need to deal with any autoref mechnaism. <code>$self:self</code> is fundamentally <code>$self:expr</code>, the expr might get evaluated many times within the macro body. It's the macro writer's job to get any necessary borrowing correct on each occurrence.</p>",
        "id": 263256152,
        "sender_full_name": "Charles Lew",
        "timestamp": 1638346216
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> As I understand it, that was explicitly <em>not</em> supposed to be the case for postfix macros; fancy evaluation semantics of something not even in the macro parens was considered confusing</p>",
        "id": 263259653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638348668
    },
    {
        "content": "<p>I think we are somehow missing a bit the comparisons to <code>.match</code>, which I think are quite nice to represent the lack of syntactical access to the <code>$self</code>, and make sense as the keystone of <code>.postfix</code>. That is, assuming the existence of <code>.match</code>, let's imagine unsugaring some of these things:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">*</span><span class=\"n\">indexable</span><span class=\"p\">.</span><span class=\"n\">first</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// becomes</span>\n<span class=\"o\">*</span><span class=\"n\">indexable</span><span class=\"p\">.</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">slice</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">option</span><span class=\"p\">.</span><span class=\"n\">unwrap_or_else</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">return</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"c1\">// becomes (modulo qualified paths)</span>\n<span class=\"n\">option</span><span class=\"p\">.</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>From there, it seems sensible to implement such as macros as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">unwrap_or_return</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"c1\">// Feel free to bikeshed this syntax.</span>\n<span class=\"w\"> </span><span class=\"c1\">// |                        Mandatory for postfix / receiver rules!</span>\n<span class=\"w\"> </span><span class=\"c1\">// v                        vvvvvvvv</span>\n<span class=\"w\">    </span><span class=\"p\">.(</span><span class=\"w\"> </span><span class=\"cp\">$else</span>:<span class=\"nc\">expr</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(.</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"cp\">$else</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- ownership works just fine!</span>\n<span class=\"w\">    </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(.</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">slice</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The key idea is kind of similar to that of <a href=\"https://internals.rust-lang.org/t/pre-rfc-a-value-matcher-for-macro-rules/14357\"><code>$:value</code> matchers for macros</a> (why isn't that proposal mentioned more often in this thread? To me it looks like <code>:value</code> semantics are the starting point of any postfix proposal): <strong>we want to make sure the expression itself is evaluated, exactly once, and before the macro-expanded stuff happens</strong> (since violating any of these rules could lead to very confusing call-sites). With the <code>=&gt; (.match { â€¦ })</code> macro rule rhs, the receiver, syntactically, is never visible, sidestepping most of the questions that would otherwise arise. And, inversely, the only way to \"eagerly bind\" an expression (with potential temporaries) is with a <code>match</code> expression, so any <code>:value</code> or <code>:self</code> macro would have to require anyways that the rhs be of the form <code>match ($($values ,)*) { ($($bindings ,)*) =&gt; ( â€¦ )}</code> (that's how I'd implement <code>$thing:value</code> matchers, for instance):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"cp\">$thing</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"err\">â€¦</span><span class=\"w\"> </span><span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"c1\">// or</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"cp\">$thing</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"err\">â€¦</span><span class=\"w\"> </span><span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"c1\">// or</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"cp\">$thing</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"err\">â€¦</span><span class=\"w\"> </span><span class=\"p\">}}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But this is redundant / cumbersome, and \"enforcing\" such a rhs could be a bit weird (this is the main rough edge of <code>:value</code> matchers). But in the case of <code>$self</code>, both issues are sidestepped thanks to <code>.match</code> not having to mention the scrutinee.</p>\n<p>Finally, the postfix macro, as implemented, would not be able to modify its \"capture mode\" of the receiver based on the type of the latter. While this could be viewed as a limitation of my proposal, it could actually be a healthy limitation: let's start off this limited API, and see where does that lead us. My claim is thus that with this approach, we'd have almost all of the benefits of postfix macros (we could already do so many things!), with almost none of the readability drawbacks (-&gt; <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span>, regarding your \"where does this 'method macro' come from\" readability concern: if all the dot-macros were to be namespaced as free items, completely type agnostic in their expansion (<em>e.g.</em>, to mentally map <code>expr.foo!()</code> to <code>expr.match { foo!() }</code>), would that be that confusing? I think that while it could require some getting used to, such an adaptation period would in practice end up being quite short)</p>",
        "id": 263311241,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638374050
    },
    {
        "content": "<p>My only concern is what happens if you already have a &amp;mut and you call a macro that uses ref mut. You'd get a double reference.</p>",
        "id": 263315777,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638375683
    },
    {
        "content": "<p>Since</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">it</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span>::<span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles fine (thanks to auto-deref) I wouldn't worry too much about that</p>",
        "id": 263317958,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638376533
    }
]