[
    {
        "content": "<p>I'm currently writing up a proposal to stabilize the <code>#[naked]</code> attribute. One thing that I'd like to make note of is that this feature has some overlap with the soon-to-be-stable <code>global_asm!</code>, and I'm wondering whether there's anyone who feels like these two features are so similar that they would object to the stabilization of <code>#[naked]</code>. <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> , any thoughts?</p>",
        "id": 269720064,
        "sender_full_name": "bstrie",
        "timestamp": 1643368557
    },
    {
        "content": "<p>I'm happy to stabilize <code>#[naked]</code> as it is. It has several advantages over <code>global_asm!</code>, such as the ability to have generic naked functions (though currently that's not too useful due to the lack of <code>sym</code> and <code>const</code>).</p>",
        "id": 269720214,
        "sender_full_name": "Amanieu",
        "timestamp": 1643368633
    },
    {
        "content": "<p>And in general it's much easier to use than <code>global_asm!</code> since it avoids the need to use <a href=\"https://gist.github.com/Amanieu/b7523fa69adf5cefab3ab5269602d4db\">this</a> when defining functions.</p>",
        "id": 269720440,
        "sender_full_name": "Amanieu",
        "timestamp": 1643368751
    },
    {
        "content": "<p>(which is in fact still incomplete since it doesn't handle the leading underscore on 32-bit windows)</p>",
        "id": 269720510,
        "sender_full_name": "Amanieu",
        "timestamp": 1643368791
    },
    {
        "content": "<p>Is there no clearer name for this feature?</p>",
        "id": 270140173,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1643681376
    },
    {
        "content": "<p><code>naked</code> is what LLVM calls it, FWIW: <a href=\"https://llvm.org/docs/LangRef.html#function-attributes\">https://llvm.org/docs/LangRef.html#function-attributes</a></p>",
        "id": 270140388,
        "sender_full_name": "scottmcm",
        "timestamp": 1643681548
    },
    {
        "content": "<p>I wonder if it should be held off while <a class=\"stream\" data-stream-id=\"216763\" href=\"/#narrow/stream/216763-project-inline-asm\">#project-inline-asm</a> is in debate.</p>",
        "id": 270142202,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643683075
    },
    {
        "content": "<p>if i were to pick a different name, i might pick <code>#[asm]</code> or <code>#[only_asm]</code> or <code>#[asm_fn]</code></p>",
        "id": 270150427,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643689252
    },
    {
        "content": "<p>from an ergonomics perspective, it might be nice to write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[asm]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">my_add</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">\"lea rax, [rsi + rdi]\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">\"ret\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">pure</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">nomem</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>rather than:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[naked]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">my_add</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"lea rax, [rsi + rdi]\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"ret\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">pure</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">nomem</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">noreturn</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270151265,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643689914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> \"in debate\"? It's shipped in stable at this point.</p>",
        "id": 270160827,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643698375
    },
    {
        "content": "<p>The use of comma terminated lines in a braced block looks off to me. Using <code>;</code> instead would make sense from some points of view, although it's not great edit-distance-wise from the asm block</p>",
        "id": 270173648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643706659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270160827\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> \"in debate\"? It's shipped in stable at this point.</p>\n</blockquote>\n<p>It's not on stable for another 4 weeks as far as I know. If you see the channel I've been trying to get certain promises reversed before that happens, and rust stabilizes the existance of the LLVM Assembler, to the detriment of <em>anything other than llvm</em>.</p>",
        "id": 270189346,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643713543
    },
    {
        "content": "<blockquote>\n<p>Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.</p>\n</blockquote>",
        "id": 270196106,
        "sender_full_name": "bjorn3",
        "timestamp": 1643716611
    },
    {
        "content": "<p>I overall agree with the sentiment that <code>asm!()</code> will make life harder for non-llvm based rust compilers. The same applies to <code>core::arch</code> which unlike <code>asm!()</code> can't be polyfilled using gas as external assembler, but requires implementing almost every single individual intrinsic. The vendor intrinsics in <code>core::arch</code> implemented using <code>extern \"platform-intrinsic\"</code> have been easy to support as these use only a couple of intrinsics internally. However those implemented using LLVM intrinsics require a lot of effort. This is a lot harder than writing a couple hundred lines of code to produce assembly gas can compile.</p>",
        "id": 270197251,
        "sender_full_name": "bjorn3",
        "timestamp": 1643717228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270197251\">said</a>:</p>\n<blockquote>\n<p>I overall agree with the sentiment that <code>asm!()</code> will make life harder for non-llvm based rust compilers. The same applies to <code>core::arch</code> which unlike <code>asm!()</code> can't be polyfilled using gas as external assembler, but requires implementing almost every single individual intrinsic. The vendor intrinsics in <code>core::arch</code> implemented using <code>extern \"platform-intrinsic\"</code> have been easy to support as these use only a couple of intrinsics internally. However those implemented using LLVM intrinsics require a lot of effort. This is a lot harder than writing a couple hundred lines of code to produce assembly gas can compile.</p>\n</blockquote>\n<p>TBH, those are less difficult than having to implement a full on macro assembler. At worst, they can be implemented using <code>asm</code>.</p>",
        "id": 270199128,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643718030
    },
    {
        "content": "<p>Maybe, but there are already two assemblers you can use in non-llvm backends (gcc's gas and llvm's llvm-as), while each vendor intrinsics need to be individually implemented for each backend.</p>",
        "id": 270199609,
        "sender_full_name": "bjorn3",
        "timestamp": 1643718197
    },
    {
        "content": "<p>Both of those have issues I've extensively detailed in the relavant threads. The TL;DR is: GAS can't be built on or for an msvc host, and llvm-as carries with it a massive dependency (all of llvm) and has problems with host cross-compilation (which, in my case, are both non-starters).</p>",
        "id": 270200136,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643718407
    },
    {
        "content": "<p>By the way x86 alone uses 1031 llvm intrinsics with x86_64 adding another 31. For arm32 you need 1090 (shared between arm32 and aarch64) + 96 (arm32 specific) and for aarch64 you need 1090 + 468 (aarch64 specific). Mips: 536 llvm intrinsics.</p>",
        "id": 270200155,
        "sender_full_name": "bjorn3",
        "timestamp": 1643718417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270200136\">said</a>:</p>\n<blockquote>\n<p>Both of those have issues I've extensively detailed in the relavant threads. The TL;DR is: GAS can't be built on or for an msvc host, and llvm-as carries with it a massive dependency (all of llvm) and has problems with host cross-compilation (which, in my case, are both non-starters).</p>\n</blockquote>\n<p>I would expect <code>asm!()</code> to mostly be used for implementing kernels and similar which probably isn't going to work with msvc anyway (at least if you use ELF rather than PE executables). It may also be used for performance reasons, but in that case there would probably be a fallback implementation for unsupported architectures. Finally it may be used for syscalls, but those should be easy to polyfill directly in your compiler.</p>",
        "id": 270200556,
        "sender_full_name": "bjorn3",
        "timestamp": 1643718648
    },
    {
        "content": "<p>There may already get some pressure to support missing <code>asm!()</code> support due to cg_clif not enabling it in the configuration that will hopefully be shipped with rustup in the future and isn't supported on non-linux targets yet anyway. (Windows is missing gas most of the time and on macOS <code>ld -r</code> doesn't work.)</p>",
        "id": 270200944,
        "sender_full_name": "bjorn3",
        "timestamp": 1643718856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270200556\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270200136\">said</a>:</p>\n<blockquote>\n<p>Both of those have issues I've extensively detailed in the relavant threads. The TL;DR is: GAS can't be built on or for an msvc host, and llvm-as carries with it a massive dependency (all of llvm) and has problems with host cross-compilation (which, in my case, are both non-starters).</p>\n</blockquote>\n<p>I would expect <code>asm!()</code> to mostly be used for implementing kernels and similar which probably isn't going to work with msvc anyway (at least if you use ELF rather than PE executables). It may also be used for performance reasons, but in that case there would probably be a fallback implementation for unsupported architectures. Finally it may be used for syscalls, but those should be easy to polyfill directly in your compiler.</p>\n</blockquote>\n<p>You can cross to a non-msvc target from an msvc host, though.</p>",
        "id": 270200973,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643718877
    },
    {
        "content": "<p>(Also, if the fallback is anything like ordinary platform-specific config in rust, it's not checking the host, so it will assume it available on an x86_64 target, for example)</p>",
        "id": 270201060,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643718936
    },
    {
        "content": "<p>Cross-compiling an ELF kernel to a non-msvc target would require getting gnu binutils for handling ELF files. Binutils contains gas already.</p>",
        "id": 270201064,
        "sender_full_name": "bjorn3",
        "timestamp": 1643718937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270201060\">said</a>:</p>\n<blockquote>\n<p>(Also, if the fallback is anything like ordinary platform-specific config in rust, it's not checking the host, so it will assume it available on an x86_64 target, for example)</p>\n</blockquote>\n<p>Right</p>",
        "id": 270201118,
        "sender_full_name": "bjorn3",
        "timestamp": 1643718958
    },
    {
        "content": "<p>Maybe a <code>#[cfg(compiler_asm_supported)]</code> could quickly be introduced for the optimization case?</p>",
        "id": 270201381,
        "sender_full_name": "bjorn3",
        "timestamp": 1643719046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270201064\">said</a>:</p>\n<blockquote>\n<p>Cross-compiling an ELF kernel to a non-msvc target would require getting gnu binutils for handling ELF files. Binutils contains gas already.</p>\n</blockquote>\n<p>Couldn't you just have an ELF compatible linker + objcopy?</p>",
        "id": 270201459,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643719078
    },
    {
        "content": "<p>The easiest way to get that is probably getting the entirety of binutils.</p>",
        "id": 270201557,
        "sender_full_name": "bjorn3",
        "timestamp": 1643719107
    },
    {
        "content": "<p>(objcopy is fairly easy to write once you have the ability to read and write elf files, and mold exists)</p>",
        "id": 270201626,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643719130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270201381\">said</a>:</p>\n<blockquote>\n<p>Maybe a <code>#[cfg(compiler_asm_supported)]</code> could quickly be introduced for the optimization case?</p>\n</blockquote>\n<p>Imagine having any knowledge at all of the backend from the frontend.</p>",
        "id": 270204327,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643720284
    },
    {
        "content": "<p>(There may not even <em>be</em> a backend loaded, in the case of lccc, for example because the user used -fwrite-xir or <code>--emit mir</code>, which emits xir because what else)</p>",
        "id": 270204540,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643720400
    },
    {
        "content": "<p>The backend already tells the frontend certain things. For example if you use <code>-Ctarget-cpu</code> which target features are enabled for the specified target cpu: <a href=\"https://github.com/rust-lang/rust/blob/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/compiler/rustc_codegen_llvm/src/lib.rs#L318-L320\">https://github.com/rust-lang/rust/blob/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/compiler/rustc_codegen_llvm/src/lib.rs#L318-L320</a> Rustc also has several <code>--print</code> arguments that are forwarded to the codegen backend and <code>--version --verbose</code> asks the codegen backend to prints it's own version.</p>",
        "id": 270210722,
        "sender_full_name": "bjorn3",
        "timestamp": 1643722880
    },
    {
        "content": "<p>Those are driver options, not frontend options.</p>\n<p><code>-C target-cpu</code> is also handled outside of the backend in lccc (xlang_target::properties).</p>",
        "id": 270211046,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643722959
    },
    {
        "content": "<p>The backend in lccc also depends on the target and command line options. It can also change in between default invocations, if the user chooses to install a new backend with higher priority that supports the default target.</p>",
        "id": 270211543,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643723124
    },
    {
        "content": "<p>Target features enabled by <code>-Ctarget-cpu</code> show up as <code>#[cfg(target_feature = \"...\")]</code>. A codegen backend probably shouldn't enable target features it does not support.</p>",
        "id": 270211686,
        "sender_full_name": "bjorn3",
        "timestamp": 1643723170
    },
    {
        "content": "<p>This would also be the case with a rustc backend using xlang, where the rustc backend acts as the driver for xlang purposes.</p>",
        "id": 270211805,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643723232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270211543\">said</a>:</p>\n<blockquote>\n<p>The backend in lccc also depends on the target and command line options. It can also change in between default invocations, if the user chooses to install a new backend with higher priority that supports the default target.</p>\n</blockquote>\n<p>So can they in rustc. A user can use a different <code>-Zcodegen-backend</code> for different invocations. Cg_llvm and cg_clif are (almost completely) abi compatible with each other. In rustc however every compilation session has a codegen backend loaded even for <code>--emit mir</code>.</p>",
        "id": 270211878,
        "sender_full_name": "bjorn3",
        "timestamp": 1643723265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270211878\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270211543\">said</a>:</p>\n<blockquote>\n<p>The backend in lccc also depends on the target and command line options. It can also change in between default invocations, if the user chooses to install a new backend with higher priority that supports the default target.</p>\n</blockquote>\n<p>So can they in rustc. A user can use a different <code>-Zcodegen-backend</code> for different invocations. Cg_llvm and cg_clif are (almost completely) abi compatible with each other. In rustc however every compilation session has a codegen backend loaded even for <code>--emit mir</code>.</p>\n</blockquote>\n<p>Unlike mir in rustc, xir in lccc is intended to be a long-surviving format, used for LTO (and not just <code>#[inline]</code>/generics/const eval). Thus, xir could be generated with one codegen enabled, and then the file used later, possibly with an vastly different codegen chosen by the user (possibly without the user recognizing it). Thus, the codegens need to agree on certain things, like the alignment of types, the names of target features, and what features are enabled by default on what targets. xlang_target is the location that provides the single source of truth for target properties (technically, it comes from <code>libxlang_interface.so</code> which provides <code>xlang_get_target_properties</code>, but the user-facing interface is in xlang_target).</p>",
        "id": 270214633,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643724174
    },
    {
        "content": "<p>only_asm is not a good name. Naked means that the function has a specific calling convention/ABI while no prologue and epilogue should be generated for it.</p>",
        "id": 270265262,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643741697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270173648\">said</a>:</p>\n<blockquote>\n<p>The use of comma terminated lines in a braced block looks off to me. Using <code>;</code> instead ...</p>\n</blockquote>\n<p>maybe allow either <code>,</code> or <code>;</code>? it would make asm writing macros and editing from <code>asm!</code> easier if <code>,</code> is allowed.</p>",
        "id": 270266648,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643742209
    },
    {
        "content": "<p>Wouldn't allowing <code>,</code>  there require changes to the parser just for this? Since attributes require well-formed AST items.</p>",
        "id": 270267480,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1643742526
    },
    {
        "content": "<p>We definitely still want an <code>asm!</code> in there so that asm isn't part of the syntax.</p>",
        "id": 270270727,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643743724
    },
    {
        "content": "<p>Agreed, I don't think this feature is so fundamental that it deserves dedicated syntax. If people want to suggest a better name I don't mind, \"naked\" is kind of jargony, but I can't really think of something especially intuitive. And being jargony might be an advantage here since this is a pretty advanced feature, and being familiar to advanced users who understand the term from C/C++ might be more valuable than putting a friendly face on this feature</p>",
        "id": 270288323,
        "sender_full_name": "bstrie",
        "timestamp": 1643750301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/270288323\">said</a>:</p>\n<blockquote>\n<p>Agreed, I don't think this feature is so fundamental that it deserves dedicated syntax. If people want to suggest a better name I don't mind, \"naked\" is kind of jargony, but I can't really think of something especially intuitive. And being jargony might be an advantage here since this is a pretty advanced feature, and being familiar to advanced users who understand the term from C/C++ might be more valuable than putting a friendly face on this feature</p>\n</blockquote>\n<p>Yeah, the danger of a non-jargony name is that people might accidentally think they know what it means without the fairly specific background that the feature requires</p>",
        "id": 270291484,
        "sender_full_name": "Jake",
        "timestamp": 1643751443
    },
    {
        "content": "<p>I have filed a stabilization proposal for <code>#[naked]</code> at <a href=\"https://github.com/rust-lang/rust/issues/90957#issuecomment-1028297041\">https://github.com/rust-lang/rust/issues/90957#issuecomment-1028297041</a> . <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> , may I nominate this for lang team discussion?</p>",
        "id": 270453836,
        "sender_full_name": "bstrie",
        "timestamp": 1643834430
    },
    {
        "content": "<p>FCP started.</p>",
        "id": 270455874,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643835337
    },
    {
        "content": "<p>Though I expect that this FCP may depend on the other ongoing FCP to close unconstrained naked functions.</p>",
        "id": 270455919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643835355
    },
    {
        "content": "<p>Sure, I don't think there's any particular rush, just as long as it isn't totally stagnating :)</p>",
        "id": 270458066,
        "sender_full_name": "bstrie",
        "timestamp": 1643836207
    },
    {
        "content": "<p>Circling back to naming… I wonder if we are happy with it in context of our general refrain in having potentially divisive names for other things in the past (e.g. white/black list vs allow/deny list; main/master and probably some others?) Naked seems like it could be similarly contentious. Though I do agree that jargon and having similar naming as in the other compilers has a fair amount of value too.</p>",
        "id": 272335288,
        "sender_full_name": "nagisa",
        "timestamp": 1645137872
    },
    {
        "content": "<p>I wouldn't say \"naked\" is objectionable/divisive so much as it's vaguely eyebrow-raising or not strictly \"professional\" in the buttoned-up traditional corporate environment sense. I don't think it will be a problem since this is a relatively rare and advanced feature, and there's some benefit to using the standard terminology, but if someone has a better name I'm not opposed to considering it</p>",
        "id": 272407844,
        "sender_full_name": "bstrie",
        "timestamp": 1645194433
    },
    {
        "content": "<p>It's not as descriptive as it could be. It seems more accurate that this is something like \"calling convention = none\", so some notation that unifies it with the syntax used for custom calling conventions seems good</p>",
        "id": 272500148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645255264
    },
    {
        "content": "<p>(Correct me if I'm wrong, but <code>#[naked]</code> is incompatible with other calling convention syntaxes like <code>extern \"C\" fn foo() { ... }</code>, right? At least, it's not clear what it would mean)</p>",
        "id": 272500255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645255411
    },
    {
        "content": "<p>It is. Which <em>does</em> make it tempting to call it something like <code>extern \"none\"</code>.</p>",
        "id": 272500619,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645255906
    },
    {
        "content": "<p>harder to google though</p>",
        "id": 272500649,
        "sender_full_name": "Lokathor",
        "timestamp": 1645255931
    },
    {
        "content": "<p>umm... I'm not sure googling \"naked\" is better</p>",
        "id": 272500866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645256272
    },
    {
        "content": "<p><code>extern \"none\"</code> would mean that attempting to call the naked function from rust would be impossible as the abi is unknown.</p>",
        "id": 272500938,
        "sender_full_name": "bjorn3",
        "timestamp": 1645256378
    },
    {
        "content": "<p>you could cast the function pointer to <code>extern \"C\" fn</code> if you want to call it with a specific calling convention</p>",
        "id": 272501001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645256440
    },
    {
        "content": "<p>but at first blush it seems correct to say that a naked function can't be called by rust since you made up your own calling convention</p>",
        "id": 272501044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645256518
    },
    {
        "content": "<p>or at least rust has no idea what it is</p>",
        "id": 272501086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645256536
    },
    {
        "content": "<p>if you google \"naked function\" you get appropriate clang and msvc docs</p>",
        "id": 272501106,
        "sender_full_name": "Lokathor",
        "timestamp": 1645256583
    },
    {
        "content": "<p>That is just ugly. In addition it wouldn't be possible for cg_clif to optimize the indirect call into a direct call. Cranelift requires knowing the full signature when defining a function.</p>",
        "id": 272501183,
        "sender_full_name": "bjorn3",
        "timestamp": 1645256675
    },
    {
        "content": "<p><code>#[naked] extern \"win64\" fn</code> has the win64 abi. <code>#[naked] extern \"sysv\" fn</code> has the sysv abi.</p>",
        "id": 272501184,
        "sender_full_name": "bjorn3",
        "timestamp": 1645256675
    },
    {
        "content": "<p>Naked functions do not have a made up calling convention.</p>",
        "id": 272501185,
        "sender_full_name": "bjorn3",
        "timestamp": 1645256675
    },
    {
        "content": "<p>They could, in theory.</p>",
        "id": 272519616,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645278434
    },
    {
        "content": "<p>not on eg wasm as the function signature is part of the executable file there rather than implicit like on most systems.</p>",
        "id": 272526016,
        "sender_full_name": "bjorn3",
        "timestamp": 1645286277
    },
    {
        "content": "<p>Right, but on other platforms, the assembly can do basically w/e it wants.</p>",
        "id": 272530601,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645291430
    },
    {
        "content": "<p>The caller still has abi expectations though, including saved registers and such</p>",
        "id": 272531482,
        "sender_full_name": "cuviper",
        "timestamp": 1645292422
    },
    {
        "content": "<p>right but those expectations might not actually match any nameable ABI</p>",
        "id": 272531814,
        "sender_full_name": "Lokathor",
        "timestamp": 1645292855
    },
    {
        "content": "<p>I have wanted an <code>extern \"none\"</code> sort of ABI for naked functions before.  I think it would useful to be able to encode \"this must not be called by rust\" in a way that can be enforced.  \"there will be some convention but it's not a well known or stable to the compiler convention\" is something I have seen in FFI and kernel level code as well.</p>",
        "id": 272575611,
        "sender_full_name": "asquared31415",
        "timestamp": 1645344601
    },
    {
        "content": "<p>I think that's kinda orthogonal to naked functions.</p>",
        "id": 272594124,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645365647
    },
    {
        "content": "<p>Since having <code>extern \"none\"</code> that's defined externally and imported via extern block is also reasonable.</p>",
        "id": 272594204,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645365734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/stabilizing.20.23.5Bnaked.5D/near/272500255\">said</a>:</p>\n<blockquote>\n<p>(Correct me if I'm wrong, but <code>#[naked]</code> is incompatible with other calling convention syntaxes like <code>extern \"C\" fn foo() { ... }</code>, right? At least, it's not clear what it would mean)</p>\n</blockquote>\n<p>can you elaborate? using naked functions all but <em>requires</em> you to specify an extern ABI. the calling convention isn't unknown, it's still handled automatically on the caller side, it's just handled manually on the callee side</p>",
        "id": 272606036,
        "sender_full_name": "bstrie",
        "timestamp": 1645378974
    },
    {
        "content": "<p>Yeah, I see now. <code>extern</code> controls calling convention on both sides, and <code>#[naked]</code> opts out only on the caller side but the callee side calling convention is still important. <code>extern \"none\"</code> might still be useful for reasons like what <span class=\"user-mention silent\" data-user-id=\"384759\">asquared31415</span> mentioned but it's orthogonal to <code>#[naked]</code></p>",
        "id": 272647086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645425394
    },
    {
        "content": "<p>On the subject of less sensational and more descriptive names: <code>#{no_prologue]</code></p>",
        "id": 272647206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645425534
    },
    {
        "content": "<p>although this leads to the obvious question \"but what about the epilogue\", and of course this attribute would control both</p>",
        "id": 272647315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645425636
    },
    {
        "content": "<p>Although epilogue handling is seemingly quite different, I mean if I have <code>asm!(\"ret\")</code> I assume that's a plain <code>ret</code> regardless of whether the function has a compiler generated prologue or not</p>",
        "id": 272647421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645425738
    },
    {
        "content": "<p>spitballing: on the theme of \"it's being called by the caller using <em>some</em> ABI, but it's not automatically handled\", <code>#[manual_abi]</code>?</p>",
        "id": 272649552,
        "sender_full_name": "scottmcm",
        "timestamp": 1645427665
    },
    {
        "content": "<p>Are you allowed to write a <code>#[naked]</code> function with regular code in it? It seems like the syntax should somehow enforce that you put an <code>asm!</code> block because rust can't really do anything sensible if it just skips the prologue but codegens everything else as normal</p>",
        "id": 272657947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645433461
    },
    {
        "content": "<p>IIRC those updates were <a href=\"https://github.com/rust-lang/rfcs/pull/2972\">https://github.com/rust-lang/rfcs/pull/2972</a></p>",
        "id": 272658698,
        "sender_full_name": "scottmcm",
        "timestamp": 1645433902
    },
    {
        "content": "<p>I'm playing with naked functions now without having read the documentation prior, and it is surprisingly hard to write something that compiles. I tried the obvious thing with an <code>asm!(\"ret\")</code> but it wants me to mark the function noreturn, which I didn't know was syntax?</p>",
        "id": 272659915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645434567
    },
    {
        "content": "<p>oh, it wants the asm block to be noreturn. This compiles, but the noreturn looks like a lie:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(naked_functions)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[naked]</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"s\">\"mov rax, 4</span><span class=\"se\">\\n</span><span class=\"s\">ret\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">options</span><span class=\"p\">(</span><span class=\"n\">noreturn</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Shouldn't the requirement go the other way? In a naked function, rust itself can't be trusted to do the epilogue right so the asm block should have a required <code>ret</code></p>",
        "id": 272661246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645435267
    },
    {
        "content": "<p>oh, I guess the noreturn changes the return type of the asm block to <code>!</code> instead of <code>()</code>, so an asm block with <code>ret</code> is actually noreturn... that's confusing</p>",
        "id": 272661505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645435390
    },
    {
        "content": "<p>Yes, it's UB to actually fall out of the bottom of a noreturn asm block.</p>",
        "id": 272664291,
        "sender_full_name": "Jubilee",
        "timestamp": 1645436955
    },
    {
        "content": "<p>so it's more of a \"mustreturn\" then, at least in this case</p>",
        "id": 272668375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645438906
    },
    {
        "content": "<p>I mean I get how it ended up like this but the terminology is unfortunate</p>",
        "id": 272668453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645438935
    },
    {
        "content": "<p>It's the asm block that must not return</p>",
        "id": 272681361,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645446323
    },
    {
        "content": "<p>More like \"must-diverge\"</p>",
        "id": 272698424,
        "sender_full_name": "cuviper",
        "timestamp": 1645455376
    },
    {
        "content": "<p>here I'd say it's more like \"nocleanup\". From the asm docs: \"noreturn: The asm! block never returns, and its return type is defined as ! (never). Behavior is undefined if execution falls through past the end of the asm code. A noreturn asm block behaves just like a function which doesn't return; notably, local variables in scope are not dropped before it is invoked.\"</p>",
        "id": 272719031,
        "sender_full_name": "bstrie",
        "timestamp": 1645466186
    },
    {
        "content": "<p>the analogy is reasonable, but flawed: it's not like calling a function that doesn't return because it's not in a new call frame - <code>ret</code> returns from the function, not the asm block</p>",
        "id": 272721435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645467847
    },
    {
        "content": "<p>\"diverge\" is definitely better terminology. Would you say that the expression <code>return 2 + 2</code> is noreturn? The word \"return\" seems overloaded here, expressions \"return\" values but not <code>return</code> return</p>",
        "id": 272721546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645467946
    },
    {
        "content": "<p>I started a topic on internals about deprecating <code>noreturn</code> and naming the replacement <code>diverges</code> or similar: <a href=\"https://internals.rust-lang.org/t/rename-asm-noreturn-and-deprecate-old-option/16190?u=programmerjake\">https://internals.rust-lang.org/t/rename-asm-noreturn-and-deprecate-old-option/16190?u=programmerjake</a></p>",
        "id": 272728098,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645472349
    }
]