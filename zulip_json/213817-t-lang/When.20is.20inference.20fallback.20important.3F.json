[
    {
        "content": "<p>Inspired by the never type meeting, when do people <em>want</em> type variable fallback today?</p>\n<p>In what cases are people happier with <code>()</code> fallback than getting an error about it?</p>\n<p>(Are things like <code>panic!();</code> or <code>return 4;</code> secretly hitting type variable fallback?)</p>",
        "id": 272996676,
        "sender_full_name": "scottmcm",
        "timestamp": 1645643185
    },
    {
        "content": "<p><code>let _ = panic!();</code> certainly hits inference fallback.</p>",
        "id": 272997086,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645643378
    },
    {
        "content": "<p>I think just adding <code>;</code> also hits fallback, yeah.</p>",
        "id": 272997287,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645643490
    },
    {
        "content": "<p>If I could turn back the clock my \"shiny past\" for inference fallback is that it is <code>!</code> always. I have not seen any example where the <code>()</code> fallback looks desirable except from a backward compatibility perspective</p>",
        "id": 272997441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645643570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/213817-t-lang/topic/When.20is.20inference.20fallback.20important.3F/near/272997287\">said</a>:</p>\n<blockquote>\n<p>I think just adding <code>;</code> also hits fallback, yeah.</p>\n</blockquote>\n<p>How so?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"fm\">panic!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles today</p>",
        "id": 272998677,
        "sender_full_name": "Jake",
        "timestamp": 1645644163
    },
    {
        "content": "<p>(I've always wondered how that's the case tbh, I guess there's some special rules around this already)</p>",
        "id": 272998975,
        "sender_full_name": "Jake",
        "timestamp": 1645644298
    },
    {
        "content": "<p>A case where the fallback to <code>()</code> really confused me while leading a training:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">demo</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">.</span><span class=\"n\">parse</span><span class=\"p\">().</span><span class=\"n\">ok</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">parse</span><span class=\"p\">().</span><span class=\"n\">ok</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error[E0277]: cannot add `i32` to `()`\n --&gt; src/lib.rs:4:12\n  |\n4 |     Some(i + if b { 2 } else { 3 })\n  |            ^ no implementation for `() + i32`\n  |\n  = help: the trait `Add&lt;i32&gt;` is not implemented for `()`\n\nerror[E0277]: the trait bound `(): FromStr` is not satisfied\n    --&gt; src/lib.rs:2:15\n     |\n2    |     let i = i.parse().ok()?;\n     |               ^^^^^ the trait `FromStr` is not implemented for `()`\n     |\nnote: required by a bound in `core::str::&lt;impl str&gt;::parse`\n</code></pre></div>\n<p>I would have preferred a \"i don't know what type this is\" error.</p>",
        "id": 273341858,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645883371
    },
    {
        "content": "<p>I think this is our usual \"type inference doesn't work through binary operators problem\". At least not in the direction you're working with, it works the other way just fine. If you know the inputs to a binary operator, you can find the output, but not the other way around. This does make sense somewhat, because there can be multiple <code>impl Add for Type</code> for different types, but all of them have the same <code>type Output = i32</code>, so we wouldn't know which input type you'd want to pick</p>",
        "id": 273342181,
        "sender_full_name": "oli",
        "timestamp": 1645883807
    },
    {
        "content": "<p>We can't change fallback, as that would be a breaking change for the cases where it compiles successfully, but we could at least improve the diagnostic significantly by</p>\n<p>a) pointing out why and where we came up with <code>()</code><br>\nb) listing all the types that would make it compile</p>",
        "id": 273342276,
        "sender_full_name": "oli",
        "timestamp": 1645883922
    },
    {
        "content": "<blockquote>\n<p>our usual \"type inference doesn't work through binary operators problem\".</p>\n</blockquote>\n<p>There's some extra wrinkle from the <code>Option</code> though. Removing it:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">demo</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">.</span><span class=\"n\">parse</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">parse</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error[E0282]: type annotations needed\n --&gt; src/lib.rs:2:9\n  |\n2 |     let i = i.parse().unwrap();\n  |         ^ consider giving `i` a type\n</code></pre></div>",
        "id": 273343079,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645884767
    },
    {
        "content": "<blockquote>\n<p>improve the diagnostic significantly</p>\n</blockquote>\n<p>This would be nice, yes.</p>\n<blockquote>\n<p>We can't change fallback, as that would be a breaking change</p>\n</blockquote>\n<p>To trot out the old question: even on an edition boundary?</p>",
        "id": 273343154,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645884857
    },
    {
        "content": "<p>Reading the sibling thread, I see the edition answer is “it’s complicated”</p>",
        "id": 273344492,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645886590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/When.20is.20inference.20fallback.20important.3F/near/273342276\">said</a>:</p>\n<blockquote>\n<p>We can't change fallback, as that would be a breaking change for the cases where it compiles successfully</p>\n</blockquote>\n<p>But it's inference breakage, so we're technically allowed.  There's a way to write it that works before and after -- by annotating the types explicitly -- so it's <em>de jure</em> ok.  Obviously the details would greatly impact on whether we'd <em>actually</em> accept it, but it might be worth trying to slowly remove some fallback cases (not that I have any idea how to do that) and see if the breakage is just the \"that never made any sense\" cases where it'd be tolerable.</p>",
        "id": 273350747,
        "sender_full_name": "scottmcm",
        "timestamp": 1645894029
    },
    {
        "content": "<p>I like it!</p>",
        "id": 273352072,
        "sender_full_name": "oli",
        "timestamp": 1645895707
    },
    {
        "content": "<p>One thing we could try before that is to run probes on each fallback and see if that actually helps and otherwise not do the fallback. That would make the successful cases explicit and we could emit a future incompat warning with a suggestion</p>",
        "id": 273352231,
        "sender_full_name": "oli",
        "timestamp": 1645895884
    }
]