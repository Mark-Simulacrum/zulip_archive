[
    {
        "content": "<p>Pain point I ran into: Is it currently possible to implement both <code>Drop</code> and <code>Copy</code> for a type if the <code>impl</code>s don't overlap - e.g. both <code>impl&lt;T: Drop&gt; Drop for Foo&lt;T&gt; { ... }</code> and <code>impl&lt;T: Copy&gt; Copy for Foo&lt;T&gt; {}</code>? Given E0367 (\"drop can't be specialized\") and E0184 (\"types can't implement both Drop and Copy\"), my initial impression was that there isn't a way to do this, but I figured I'd ask in case there's a workaround (I'm already using a bunch of nightly features, so unstable is ok).</p>\n<p>If there isn't a way to do it, is there a possible path towards adding this? AFAICT, it _should_ be sound -- though I don't know enough about E0367 to tell why that's not allowed (for this, could dropck conservatively assume that all <code>Foo&lt;T&gt;</code> have drop glue if the impl is specialized?). </p>\n<p>It's also interesting to me that you can't <code>unsafe impl Copy</code> your way out of E0184 - it was actually the first thing I tried, out of curiosity, not really expecting it to work.</p>\n<p>FWIW, I ran across this with an implementation of a bounded vector on the stack (like <code>SmallVec</code>, but has a maximum capacity). It contains a field with type <code>[MaybeUninit&lt;T&gt;; CAPACITY]</code>, so it has to implement <code>Drop</code> if <code>T: Drop</code>, but ideally I'd like it to be <code>Copy</code> if <code>T: Copy</code> (which implies <code>T: !Drop</code>). Adding the <code>T: Drop</code> bound gets E0367, unfortunately.</p>",
        "id": 278426188,
        "sender_full_name": "sharnoff",
        "timestamp": 1649532137
    },
    {
        "content": "<p>Yeah this <em>should</em> be allowed, but the compiler doesn't \"know\" that one implies not the other (yet?).</p>\n<p>My advice is to go with Drop+Clone and note in your type's docs that the Clone is going to essentially be \"free\" if the elements are Copy.</p>",
        "id": 278427354,
        "sender_full_name": "Lokathor",
        "timestamp": 1649533812
    },
    {
        "content": "<p>I give this advice as the maintainer of <code>tinyvec</code>, which has this exact same situation</p>",
        "id": 278427372,
        "sender_full_name": "Lokathor",
        "timestamp": 1649533845
    },
    {
        "content": "<p>Ah yeah that makes sense, thanks :)</p>",
        "id": 278427476,
        "sender_full_name": "sharnoff",
        "timestamp": 1649533976
    },
    {
        "content": "<p>And hah- I hadn't heard of <code>tinyvec</code> before but it looks like a superset of the original version of what I made. (now it has a couple other funky features specific to where it's used, but still approximately the same)</p>",
        "id": 278427544,
        "sender_full_name": "sharnoff",
        "timestamp": 1649534048
    },
    {
        "content": "<p>I think Drop impls also complain when the bounds don't match the bounds of the type, so <code>impl&lt;T: Drop&gt; for Foo&lt;T&gt; {}</code> will already not work</p>",
        "id": 278427656,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649534252
    },
    {
        "content": "<p>I think current code depends on the Drop impl bounds being equal to the bounds that are on the struct itself</p>",
        "id": 278427704,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649534298
    },
    {
        "content": "<p>A bounded vector on the stack sounds like <code>arrayvec</code> -- and they do not implement <code>Copy</code> either.</p>",
        "id": 278428257,
        "sender_full_name": "cuviper",
        "timestamp": 1649535113
    },
    {
        "content": "<p>(their <code>ArrayString</code> does though)</p>",
        "id": 278428372,
        "sender_full_name": "cuviper",
        "timestamp": 1649535261
    },
    {
        "content": "<p>I wonder if this is one of those things like <code>Iterator</code> where accidental copies might be super confusing.</p>",
        "id": 278428382,
        "sender_full_name": "scottmcm",
        "timestamp": 1649535292
    },
    {
        "content": "<p>Note that <code>with_negative_coherence</code> should make the stdlib adding a <code>impl&lt;T : Copy&gt; !Drop for T {}</code> yield very useful information to the coherence checker, thence allowing what you are looking for</p>",
        "id": 278440087,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649552282
    },
    {
        "content": "<p>Oh interesting! I didn't see anything about <code>with_negative_coherence</code> earlier (given it doesn't have a tracking issue) -- is there somewhere I could learn more about it?</p>\n<p>Looking at the examples in 'src/test/ui' (particularly something like <a href=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/coherence/coherence-overlap-negate-strict.rs\">coherence-overlap-negate-strict</a>), it _does_ seem like <code>impl&lt;T: Copy&gt; !Drop for T {}</code> would essentially give what I'm looking for.</p>\n<p>A little bit of poking around the rustc codebase indicates it interacts with <code>rustc_strict_coherence</code>, but I couldn't find anything else beyond that. (perhaps this would be better to ask about in <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a>)</p>",
        "id": 278441940,
        "sender_full_name": "sharnoff",
        "timestamp": 1649555171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"352290\">@sharnoff</span> <a href=\"https://github.com/rust-lang/rust/issues/68318\">https://github.com/rust-lang/rust/issues/68318</a> <a href=\"https://github.com/rust-lang/negative-impls-initiative\">https://github.com/rust-lang/negative-impls-initiative</a> I think these are the relevant issues/repos for the general idea of negative imples. I think negative coherence is a subset of it, but I'm not super sure.</p>",
        "id": 278443953,
        "sender_full_name": "Parth Nobel",
        "timestamp": 1649558604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"320176\">@Parth Nobel</span> oh cool- that's very helpful, thanks! Being a subset makes sense -- presumably the feature's going to be collapsed into something else once negative impls are closer to stabilization</p>",
        "id": 278445786,
        "sender_full_name": "sharnoff",
        "timestamp": 1649561773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"352290\">@sharnoff</span> so, here is a snippet <strong>with custom traits</strong> to toy a bit with these <code>with_negative_coherence</code> notions: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2b1d91694f20a013166410dd3d5c0fda\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2b1d91694f20a013166410dd3d5c0fda</a></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Regarding rustc_strict_coherence</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>it's a flag used for <code>rustc</code> tests, to disable something that the coherence checker otherwise does:</p>\n<ul>\n<li>if a remote / upstream crate doesn't write <code>impl Trait for TheirType {}</code> (and the <code>Trait</code> (or the type...) isn't <code>#[fundamental]</code>), then <strong> <em>your</em> code can't rely on the absence of such impl</strong>, since they would be allowed to add it in a semver compatible version. So <code>TheirType : Trait</code> does not hold (yet), but neither does <code>TheirType :! Trait</code>.</li>\n<li>but if it is a local type we are talking about, then the rest of your code can rely on your type not implementing the traits it doesn't implement (yet). Basically a lack of <code>impl Trait for YourType {}</code> is treated, by the coherence checker, as a <code>impl !Trait for YourType {}</code> (locally only), so a kind of promise you make for your own code that you won't implement the trait in the future (the idea being that whenever you break that promise, you are able to fully see the scope of breakage that ensues, and tackle it).</li>\n</ul>\n<p>But this difference is precisely one that matters once <code>with_negative_coherence</code> enters in play: to test the differences between no <code>impl Trait for YourType {}</code> and an explicitly written <code>impl Trait for YourType {}</code>, either the whole thing needs to be moved to an upstream crate, or <code>rustc_strict_coherence</code> needs to be used to emulate that.</p>\n</div></div>",
        "id": 278493413,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649630222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> ah, ok! that makes sense - so, just checking I understand,<code>rustc_strict_coherence</code> allows otherwise-invalid code to treat a lack of <code>impl Trait for Type</code> as <code>impl !Trait for Type</code>?</p>\n<p>From the example: If I wanted it to work with the <code>std</code> types, it seems like either <code>std</code> would have to export its own <code>NotCopy</code> (which is ergonomically unelegant) or the langauge would have to allow <code>impl&lt;T: !Trait&gt;</code>, with the same inference that your snippet has. Interestingly, it seems like <code>T: !Trait</code> has previously been somewhat dismissed because of those coherence checks you mentioned, so perhaps <code>with_negative_coherence</code> could provide a path for it.</p>",
        "id": 278497485,
        "sender_full_name": "sharnoff",
        "timestamp": 1649636570
    },
    {
        "content": "<p>Yeah, <code>T: !Trait</code> meaning \"it hasn't implemented the trait\" is a stagnation hazard, but if it means \"has explicitly promised it will <em>never</em> implement the trait\" then it's ≈fine.</p>",
        "id": 278501570,
        "sender_full_name": "scottmcm",
        "timestamp": 1649642530
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"352290\">@sharnoff</span> the other way around: for a <em>local</em> type, <em>by default</em>, a lack of impl is perceived as a \"promise of non-impl\" / as an <code>impl !</code>. So, to properly compare the semantics between a lack of impl and an <code>impl !</code>, the lack of impl ought to be for a non-local type / for an upstream type (which is very cumbersome to set up in tests, which usually involve a single crate), or the <code>rustc_strict_coherence</code> flag ought to be present in the current crate. As the name indicates, it makes coherence more <em>strict</em>  / more <em>conservative</em>, less prone to accept impls, much like it already is when we are dealing with upstream types.</p>",
        "id": 278535063,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649673591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> ah, now I see what you're saying. that makes more sense, thanks :)</p>",
        "id": 278632628,
        "sender_full_name": "sharnoff",
        "timestamp": 1649721837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/E0184.2FE0367.3A.20impl.20both.20Drop.20and.20Copy.3F/near/278501570\">said</a>:</p>\n<blockquote>\n<p>if it means \"has explicitly promised it will <em>never</em> implement the trait\" then it's ≈fine.</p>\n</blockquote>\n<p>ok cool! IMO this seems like a reasonable way to do it -- specifically using the existing coherence rules, so that <code>T: !Trait</code> requires a negative impl for foreign types, or lack of an impl for local types.</p>\n<p>From what I can find, some prior discussions seem to have been around requiring impls for <code>T: !Trait</code> and <code>T: Trait</code> to prevent breakage (<a href=\"https://internals.rust-lang.org/t/rule-for-trait-without-impl-trait-being-a-breaking-change/14763\">link</a>), although there was <a href=\"https://internals.rust-lang.org/t/negative-bounds-mutually-exclusive-traits/2006\">this one</a> that is quite similar to this idea.</p>\n<p>Assuming this would be sound, how doable would it be?</p>",
        "id": 278633660,
        "sender_full_name": "sharnoff",
        "timestamp": 1649722705
    },
    {
        "content": "<p><a class=\"stream\" data-stream-id=\"315151\" href=\"/#narrow/stream/315151-wg-traits.2Fnegative-impls\">#wg-traits/negative-impls</a> is currently looking at using negative impls in coherence, which seems very very close to what you're asking here.  I'd suggest asking them.</p>\n<p>(Or maybe you could file an issue on <a href=\"https://github.com/rust-lang/negative-impls-initiative/issues\">https://github.com/rust-lang/negative-impls-initiative/issues</a> )</p>",
        "id": 278638003,
        "sender_full_name": "scottmcm",
        "timestamp": 1649727331
    }
]