[
    {
        "content": "<p><code>std::mem::size_of</code> currently emits a compilation error if the layout computation failed. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>causes</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0080]: the type `[u8; 18446744073709551615]` is too big for the current architecture\n\nerror[E0080]: evaluation of constant expression failed\n --&gt; src/main.rs:2:20\n  |\n2 |     println!(&quot;{}&quot;, std::mem::size_of::&lt;[u8; usize::MAX]&gt;());\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n\nerror: erroneous constant used\n --&gt; src/main.rs:2:20\n  |\n2 |     println!(&quot;{}&quot;, std::mem::size_of::&lt;[u8; usize::MAX]&gt;());\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n  |\n  = note: `#[deny(const_err)]` on by default\n</code></pre></div>",
        "id": 217115253,
        "sender_full_name": "lcnr",
        "timestamp": 1605693750
    },
    {
        "content": "<p>there are two issues here imo:</p>",
        "id": 217115268,
        "sender_full_name": "lcnr",
        "timestamp": 1605693773
    },
    {
        "content": "<ul>\n<li>the type <code>[u8; usize::MAX]</code> is <strong>not</strong> too big for the current architecture, for example:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(min_const_generics)]</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">'</span><span class=\"nb\">static</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span>::<span class=\"n\">Assoc</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiles and prints the expected size</p>",
        "id": 217115715,
        "sender_full_name": "lcnr",
        "timestamp": 1605694067
    },
    {
        "content": "<p>am changing this error message in <a href=\"https://github.com/rust-lang/rust/issues/79158\">#79158</a> to \"values of the type <code>...</code> are too big\"</p>",
        "id": 217115839,
        "sender_full_name": "lcnr",
        "timestamp": 1605694129
    },
    {
        "content": "<ul>\n<li>IMO <code>size_of</code> really should not cause a compilation error here,</li>\n</ul>",
        "id": 217115981,
        "sender_full_name": "lcnr",
        "timestamp": 1605694232
    },
    {
        "content": "<p>but instead work similar to <code>let _x = 1/0</code>, emitting a <code>unconditional_panic</code> lint</p>",
        "id": 217116170,
        "sender_full_name": "lcnr",
        "timestamp": 1605694396
    },
    {
        "content": "<p>as <code>size_of</code> never actually deals with a value of type <code>T</code></p>",
        "id": 217116215,
        "sender_full_name": "lcnr",
        "timestamp": 1605694432
    },
    {
        "content": "<p>i can't really explain myself too well but causing an error here just <em>feels wrong</em>™</p>",
        "id": 217116481,
        "sender_full_name": "lcnr",
        "timestamp": 1605694601
    },
    {
        "content": "<p>There is no way to construct a value of that type.</p>",
        "id": 217116496,
        "sender_full_name": "bjorn3",
        "timestamp": 1605694618
    },
    {
        "content": "<p>yeah, but we don't have to do that for <code>size_of</code></p>",
        "id": 217116508,
        "sender_full_name": "lcnr",
        "timestamp": 1605694634
    },
    {
        "content": "<p>we can still use the type for trait bounds and projections</p>",
        "id": 217116520,
        "sender_full_name": "lcnr",
        "timestamp": 1605694652
    },
    {
        "content": "<p><code>size_of</code> reads from the layout of the type. To fix this, you would have to duplicate all layout logic just for <code>size_of</code>, or you would have to insert error code at every use of <code>layout_of</code> that doesn't involve <code>size_of</code>.</p>",
        "id": 217116604,
        "sender_full_name": "bjorn3",
        "timestamp": 1605694710
    },
    {
        "content": "<p><code>layout_of</code> already returns <code>Result&lt;.., LayoutError&gt;</code></p>",
        "id": 217116664,
        "sender_full_name": "lcnr",
        "timestamp": 1605694785
    },
    {
        "content": "<p>so instead of<code>size_of</code> emitting the err as a compilation error it contains it in it's panic message</p>",
        "id": 217116719,
        "sender_full_name": "lcnr",
        "timestamp": 1605694807
    },
    {
        "content": "<p>that's not really a lot of duplication, is it?</p>",
        "id": 217116730,
        "sender_full_name": "lcnr",
        "timestamp": 1605694818
    },
    {
        "content": "<p>Forgot how it worked.</p>",
        "id": 217116811,
        "sender_full_name": "bjorn3",
        "timestamp": 1605694898
    },
    {
        "content": "<p>no worries <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 217116915,
        "sender_full_name": "lcnr",
        "timestamp": 1605694958
    },
    {
        "content": "<p>If it were changed to a panic message, that would still cause an error during codegen of <code>size_of</code> as <code>size_of</code> in cg_llvm invokes the const eval implementation of this and several other intrinsics.</p>",
        "id": 217116945,
        "sender_full_name": "bjorn3",
        "timestamp": 1605694987
    },
    {
        "content": "<p>I want to codegen <code>size_of</code> into a panic</p>",
        "id": 217116986,
        "sender_full_name": "lcnr",
        "timestamp": 1605695028
    },
    {
        "content": "<p>if it fails, instead of into an error</p>",
        "id": 217116996,
        "sender_full_name": "lcnr",
        "timestamp": 1605695035
    },
    {
        "content": "<p>so </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 217117068,
        "sender_full_name": "lcnr",
        "timestamp": 1605695059
    },
    {
        "content": "<p>would instead be more similar to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">size_of_concrete_ty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">panic</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"values of the type `[u8; 18446744073709551615]` are too big for the current architecture\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">size_of_concrete_ty</span><span class=\"p\">(();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 217117149,
        "sender_full_name": "lcnr",
        "timestamp": 1605695127
    },
    {
        "content": "<p>What would the advantage of that be?</p>",
        "id": 217117231,
        "sender_full_name": "bjorn3",
        "timestamp": 1605695166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217116481\">said</a>:</p>\n<blockquote>\n<p>i can't really explain myself too well but causing an error here just <em>feels wrong</em>™</p>\n</blockquote>",
        "id": 217117397,
        "sender_full_name": "lcnr",
        "timestamp": 1605695303
    },
    {
        "content": "<p>i can try to explain myself a bit better here, the size of values of a type is not related to the well-formedness of said type</p>",
        "id": 217117470,
        "sender_full_name": "lcnr",
        "timestamp": 1605695377
    },
    {
        "content": "<p>which is why <code>[u16; usize::MAX]</code> can be used in projections and stuff</p>",
        "id": 217117495,
        "sender_full_name": "lcnr",
        "timestamp": 1605695395
    },
    {
        "content": "<p>i think <code>size_of</code> causing a compilation error also causes subtle misunderstandings like <a href=\"https://github.com/rust-lang/rust/pull/79135#issuecomment-729361380\">https://github.com/rust-lang/rust/pull/79135#issuecomment-729361380</a></p>\n<blockquote>\n<p>[When dealing with <code>[[u8; M]; N]</code>, ] It is obvious that using N = M = usize::MAX will result in invalid types (in the sense as discussed in the linked issue)</p>\n</blockquote>",
        "id": 217118021,
        "sender_full_name": "lcnr",
        "timestamp": 1605695683
    },
    {
        "content": "<p>i feel like <code>size_of</code> is also another \"unnecessary\" way to cause \"type\" errors post typeck, which should ideally be avoided because it causes really unhelpful errors</p>",
        "id": 217119264,
        "sender_full_name": "lcnr",
        "timestamp": 1605696506
    },
    {
        "content": "<p>To me <code>size_of</code> feels like a generic constant more than something that happens at runtime. Emitting a panic for that is a little bit like how promotion handles panics. There's an assertion before getting to the uncomputable promoted constant, so we never reach the invalid code. Basically this would make a <code>size_of::&lt;T&gt;()</code> invocation <code>{assert!(well_formed_for_value&lt;T&gt;()); actual_size_of&lt;T&gt;()}</code>. But in contrast to promotion, right now <code>size_of</code> is something that is known to happen at compile time, so it's like a constant, thus we emit a compile-time error if we fail to evaluate it. So basically any use of <code>size_of::&lt;T&gt;()</code> technically requires a <code>where const size_of::&lt;T&gt;()</code> bound on all functions using <code>size_of::&lt;T&gt;()</code> without a concrete <code>T</code>. Now this would be very invasive, so we could autogenerate such bounds <em>just</em> for the <code>size_of</code> case. Though I have been informed that this may not actually be feasible. With such autogenerated bounds, we'd get better errors again</p>",
        "id": 217119287,
        "sender_full_name": "oli",
        "timestamp": 1605696526
    },
    {
        "content": "<p>in general I mostly feel like <code>size_of</code> has <em>no right</em> to cause a compilation error. These are just my expectations of how things should work so it probably isn't really helpful to people who have different expectations here.</p>",
        "id": 217119323,
        "sender_full_name": "lcnr",
        "timestamp": 1605696545
    },
    {
        "content": "<p>if <code>size_of</code> were a constant on <code>Sized</code>, then it not being computable would reasonably cause a compile-time error</p>",
        "id": 217119368,
        "sender_full_name": "oli",
        "timestamp": 1605696587
    },
    {
        "content": "<p>and there definitely was some discussion about something like that, although I can't find it right now</p>",
        "id": 217119431,
        "sender_full_name": "oli",
        "timestamp": 1605696610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217119368\">said</a>:</p>\n<blockquote>\n<p>if <code>size_of</code> were a constant on <code>Sized</code>, then it not being computable would reasonably cause a compile-time error</p>\n</blockquote>\n<p>yeah, though that also brings some other issues with it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 217119650,
        "sender_full_name": "lcnr",
        "timestamp": 1605696779
    },
    {
        "content": "<p>if we ever want to require associated consts to be wf</p>",
        "id": 217119672,
        "sender_full_name": "lcnr",
        "timestamp": 1605696796
    },
    {
        "content": "<p>(tbh I would personally be fine with completely scrapping the compilation error on <code>SizeOverflow</code> and instead emit a deny by default lint and just panic everywhere such a type is used at runtime, though that's probably even more controversial <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> )</p>",
        "id": 217120190,
        "sender_full_name": "lcnr",
        "timestamp": 1605697175
    },
    {
        "content": "<p>that still won't improve the diagnostic ^^</p>",
        "id": 217120254,
        "sender_full_name": "oli",
        "timestamp": 1605697205
    },
    {
        "content": "<p>(though you can then just run your program and look at the stack trace, not ideal.</p>",
        "id": 217120289,
        "sender_full_name": "oli",
        "timestamp": 1605697226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217120254\">said</a>:</p>\n<blockquote>\n<p>that still won't improve the diagnostic ^^</p>\n</blockquote>\n<p>well, you can at least point at the mir local that caused that lint</p>",
        "id": 217120484,
        "sender_full_name": "lcnr",
        "timestamp": 1605697353
    },
    {
        "content": "<p>you can also do that with an error though</p>",
        "id": 217120497,
        "sender_full_name": "lcnr",
        "timestamp": 1605697363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217120190\">said</a>:</p>\n<blockquote>\n<p>(tbh I would personally be fine with completely scrapping the compilation error on <code>SizeOverflow</code> and instead emit a deny by default lint and just panic everywhere such a type is used at runtime, though that's probably even more controversial <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> )</p>\n</blockquote>\n<p>that's just idealism speaking here, so there isn't really a point in doing so except that it's \"cleaner\" (whatever that means)</p>",
        "id": 217120564,
        "sender_full_name": "lcnr",
        "timestamp": 1605697426
    },
    {
        "content": "<p>The problem with an error or lint is that they get reported in other crates, so for lints we wouldn't see them at all and for errors we don't have a span to report them on. If this is 5 function calls deep, you have to figure out which concrete type used as input caused it</p>",
        "id": 217121049,
        "sender_full_name": "oli",
        "timestamp": 1605697716
    },
    {
        "content": "<p>we technically have this information available via the query stack, but we can't use it for diagnostics and it's not reliable</p>",
        "id": 217121085,
        "sender_full_name": "oli",
        "timestamp": 1605697749
    },
    {
        "content": "<p>yeah <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> there is a reason why we implement const wf using explicit where bounds</p>",
        "id": 217121139,
        "sender_full_name": "lcnr",
        "timestamp": 1605697781
    },
    {
        "content": "<p>we might at least add a short note saying in which instance we currently are</p>",
        "id": 217121216,
        "sender_full_name": "lcnr",
        "timestamp": 1605697827
    },
    {
        "content": "<p>so something like \"in a concrete of <code>fn whatever</code> called with the generic parameters <code>u32, 17usize, String</code>\"</p>",
        "id": 217121286,
        "sender_full_name": "lcnr",
        "timestamp": 1605697888
    },
    {
        "content": "<p>I just worry that without a backtrace this will just report the <code>std::mem::size_of</code> wrapper funciton <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 217122097,
        "sender_full_name": "oli",
        "timestamp": 1605698523
    },
    {
        "content": "<p>aaah, that's true</p>",
        "id": 217122159,
        "sender_full_name": "lcnr",
        "timestamp": 1605698545
    },
    {
        "content": "<p>maybe once the mir inliner is running by default <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 217122259,
        "sender_full_name": "lcnr",
        "timestamp": 1605698628
    },
    {
        "content": "<p>re changing size overflows to an runtime error, would that mean that the following transformation becomes unsound?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">before</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">whatever</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">after</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_idk</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">whatever</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where <code>?</code> is free of sideeffects, e.g. array initialization</p>",
        "id": 217126273,
        "sender_full_name": "lcnr",
        "timestamp": 1605701465
    },
    {
        "content": "<p>because we change the behavior for <code>x &gt; 1</code>... that seems undesirable to me, so maybe it's not worth it in the end <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 217126335,
        "sender_full_name": "lcnr",
        "timestamp": 1605701506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217116170\">said</a>:</p>\n<blockquote>\n<p>but instead work similar to <code>let _x = 1/0</code>, emitting a <code>unconditional_panic</code> lint</p>\n</blockquote>\n<p><code>size_of</code> currently cannot panic, and there might be code which relies on that...</p>",
        "id": 217500315,
        "sender_full_name": "RalfJ",
        "timestamp": 1605962558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217117470\">said</a>:</p>\n<blockquote>\n<p>i can try to explain myself a bit better here, the size of values of a type is not related to the well-formedness of said type</p>\n</blockquote>\n<p>is it, though? in my mental model, too big types are ill-formed, and hence <code>size_of</code> has every right to reject them.</p>\n<p>I guess you'll complain that this is a rather non-compositional notion of well-formedness?</p>",
        "id": 217500333,
        "sender_full_name": "RalfJ",
        "timestamp": 1605962617
    },
    {
        "content": "<p>My issue is that <code>[u16; usize::MAX]</code> is absolutely well formed</p>",
        "id": 217500641,
        "sender_full_name": "lcnr",
        "timestamp": 1605963117
    },
    {
        "content": "<p>you can use <code>&lt;[u16; usize::MAX] as Trait&gt;::Assoc</code> and similar things</p>",
        "id": 217500686,
        "sender_full_name": "lcnr",
        "timestamp": 1605963140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217500641\">said</a>:</p>\n<blockquote>\n<p>My issue is that <code>[u16; usize::MAX]</code> is absolutely well formed</p>\n</blockquote>\n<p>that is another possible definition of \"well-formedness\". then we have to live with the fact that there are well-formed types that cannot be translated to LLVM (it is my understanding that LLVM will choke at compiletime when we give it a type that is too big)</p>",
        "id": 217502967,
        "sender_full_name": "RalfJ",
        "timestamp": 1605967289
    },
    {
        "content": "<p>and it's not just LLVM; once offsets within an allocation can get bigger than <code>isize::MAX</code> there'll also be trouble in CTFE</p>",
        "id": 217503016,
        "sender_full_name": "RalfJ",
        "timestamp": 1605967340
    },
    {
        "content": "<p>yeah <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> while imo it makes sense to think of types like this in the same way as <code>!</code> supporting things like <code>*mut [u16; usize::MAX]</code> or whatever is probably not worth the effort, even if it were more consistent</p>",
        "id": 217514979,
        "sender_full_name": "lcnr",
        "timestamp": 1605986676
    },
    {
        "content": "<blockquote>\n<p>there are well-formed types that cannot be translated to LLVM </p>\n</blockquote>\n<p>What about <code>enum Void</code>? How do we translate that to LLVM?</p>",
        "id": 217515002,
        "sender_full_name": "lcnr",
        "timestamp": 1605986726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217515002\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>there are well-formed types that cannot be translated to LLVM </p>\n</blockquote>\n<p>What about <code>enum Void</code>? How do we translate that to LLVM?</p>\n</blockquote>\n<p>no idea but clearly we do</p>",
        "id": 217518373,
        "sender_full_name": "RalfJ",
        "timestamp": 1605991763
    },
    {
        "content": "<p>are you suggesting we should translate too-big-to-be-real types the same way? hm...</p>",
        "id": 217518376,
        "sender_full_name": "RalfJ",
        "timestamp": 1605991780
    },
    {
        "content": "<p>ideally <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> realistically I am not too sure if it's worth the effort</p>",
        "id": 217518881,
        "sender_full_name": "lcnr",
        "timestamp": 1605992574
    },
    {
        "content": "<p>ooh... so since we know a value of type <code>[u16; usize::MAX]</code> can never exist, we can make the layout of it be the same layout as <code>!</code>, with all the effects that brings</p>",
        "id": 217547648,
        "sender_full_name": "oli",
        "timestamp": 1606045696
    },
    {
        "content": "<p>so.. <code>size_of</code> doesn't fail, but returns <code>0</code></p>",
        "id": 217547653,
        "sender_full_name": "oli",
        "timestamp": 1606045706
    },
    {
        "content": "<p>and any code following it is unreachable</p>",
        "id": 217547655,
        "sender_full_name": "oli",
        "timestamp": 1606045713
    },
    {
        "content": "<p>...</p>",
        "id": 217547657,
        "sender_full_name": "oli",
        "timestamp": 1606045718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217547653\">said</a>:</p>\n<blockquote>\n<p>so.. <code>size_of</code> doesn't fail, but returns <code>0</code></p>\n</blockquote>\n<p>no, size_of would return the large number. I thought.</p>",
        "id": 217548226,
        "sender_full_name": "RalfJ",
        "timestamp": 1606046648
    },
    {
        "content": "<p>but maybe that's a problem in itself...</p>",
        "id": 217548230,
        "sender_full_name": "RalfJ",
        "timestamp": 1606046668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217547655\">said</a>:</p>\n<blockquote>\n<p>and any code following it is unreachable</p>\n</blockquote>\n<p>why that? <code>size_of::&lt;!&gt;()</code> is perfectly reachable</p>",
        "id": 217548238,
        "sender_full_name": "RalfJ",
        "timestamp": 1606046690
    },
    {
        "content": "<p>sorry, I mixed two concepts</p>",
        "id": 217548324,
        "sender_full_name": "oli",
        "timestamp": 1606046840
    },
    {
        "content": "<p><code>size_of::&lt;[u16; usize::MAX]&gt;()</code> cannot return any value, as <code>usize::MAX * 2</code> does not fit into a <code>usize</code></p>",
        "id": 217548327,
        "sender_full_name": "oli",
        "timestamp": 1606046867
    },
    {
        "content": "<p>but that's \"fine\", since there can be no values of type <code>[u16; usize::MAX]</code>. Basically <code>[0_u16; usize::MAX]</code> could be replaced by a runtime panic (+ emit a lint), making any code following it unreachable. At that point we can make the layout of <code>[u16; usize::MAX]</code> have the same layout as <code>!</code>, thus returning <code>0</code> for the size</p>",
        "id": 217548389,
        "sender_full_name": "oli",
        "timestamp": 1606046996
    },
    {
        "content": "<p>this makes <code>size_of::&lt;[u16; usize::MAX]&gt;()</code> \"well defined\" as <code>0</code>, though I worry how that interacts with <code>MaybeUninit&lt;[u16; usize::MAX]&gt;</code>, since someone could think this could be initialized element by element</p>",
        "id": 217548445,
        "sender_full_name": "oli",
        "timestamp": 1606047067
    },
    {
        "content": "<p><code>MaybeUninit&lt;[u16; usize::MAX]&gt;</code> still needs enough place to hold all <code>usize::MAX</code> elements right from the start</p>",
        "id": 217548807,
        "sender_full_name": "lcnr",
        "timestamp": 1606047716
    },
    {
        "content": "<p>so i don't think there is an issue with panicking there</p>",
        "id": 217548846,
        "sender_full_name": "lcnr",
        "timestamp": 1606047733
    },
    {
        "content": "<p><code>Option&lt;BigType&gt;</code> is a bit more weird, because one could imagine only needing the place for <code>BigType</code> once we have <code>Some</code></p>",
        "id": 217548852,
        "sender_full_name": "lcnr",
        "timestamp": 1606047766
    },
    {
        "content": "<p>but i personally did not think this way</p>",
        "id": 217548872,
        "sender_full_name": "lcnr",
        "timestamp": 1606047800
    },
    {
        "content": "<p><code>Option&lt;BigType&gt;</code> would work automatically for my idea of making these types represented as <code>!</code>. It would become ZST and you could never have a <code>Some</code> of it</p>",
        "id": 217549079,
        "sender_full_name": "oli",
        "timestamp": 1606048088
    },
    {
        "content": "<p>I'm not sure about <code>MaybeUninit</code> if we use the <code>!</code> layout, as it would now be zero sized.</p>",
        "id": 217549089,
        "sender_full_name": "oli",
        "timestamp": 1606048125
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5116d94942933bcc1e15cf677b5b6cde\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5116d94942933bcc1e15cf677b5b6cde</a> works just fine, and users may start with partially initializing the elements</p>",
        "id": 217549097,
        "sender_full_name": "oli",
        "timestamp": 1606048142
    },
    {
        "content": "<p>eddyb brought up something even worse just now. what if we initialize the array from the end to the beginning... then we have UB. The user may not have realized this, because their array length could have been generic</p>",
        "id": 217549183,
        "sender_full_name": "oli",
        "timestamp": 1606048266
    },
    {
        "content": "<p>wait, won't the whole <code>MaybeUninit</code> become unrepresentable?</p>",
        "id": 217549295,
        "sender_full_name": "lcnr",
        "timestamp": 1606048419
    },
    {
        "content": "<p>so if we propagate this outwards, we end up with <code>layout_of(MaybeUninit)</code> still returning an error</p>",
        "id": 217549301,
        "sender_full_name": "lcnr",
        "timestamp": 1606048441
    },
    {
        "content": "<p>which we then only convert to a layout of size <code>0</code> for the whole type, whatever that means</p>",
        "id": 217549341,
        "sender_full_name": "lcnr",
        "timestamp": 1606048457
    },
    {
        "content": "<p>at least that's how I imagine this</p>",
        "id": 217549353,
        "sender_full_name": "lcnr",
        "timestamp": 1606048480
    },
    {
        "content": "<p>oh... so we keep the layout error, but we don't report it?</p>",
        "id": 217549600,
        "sender_full_name": "oli",
        "timestamp": 1606048885
    },
    {
        "content": "<p>not sure, I expect <code>[(u8, [u16; usize::MAX]); 10]</code> to also be unrepresentable and not have size <code>10</code></p>",
        "id": 217549731,
        "sender_full_name": "lcnr",
        "timestamp": 1606049053
    },
    {
        "content": "<p>well... in my system (which I now fully agree is not good and we should stop talking about it <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>) it would have been <code>0</code></p>",
        "id": 217549742,
        "sender_full_name": "oli",
        "timestamp": 1606049093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217549742\">said</a>:</p>\n<blockquote>\n<p>well... in my system (which I now fully agree is not good and we should stop talking about it :D) it would have been <code>0</code></p>\n</blockquote>\n<p>how?</p>",
        "id": 217549750,
        "sender_full_name": "lcnr",
        "timestamp": 1606049118
    },
    {
        "content": "<p>you're right... I assumed <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c3fdd5dae383852ec2c1092a5ba4b5d1\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c3fdd5dae383852ec2c1092a5ba4b5d1</a> would be <code>0</code>, but.. partial initialization and such</p>",
        "id": 217549812,
        "sender_full_name": "oli",
        "timestamp": 1606049177
    },
    {
        "content": "<p>layout of <code>[(u8, [u16; usize::MAX]); 10]</code> uses layout of <code>(u8, [u16; usize::MAX])</code> which uses layout of <code>[u16; usize::MAX]</code> which returns 0 using your idea which means that <code>(u8, ?)</code> return 1 iiuc</p>",
        "id": 217549813,
        "sender_full_name": "lcnr",
        "timestamp": 1606049177
    },
    {
        "content": "<p>as I said... ignore my system, it's broken in so many ways</p>",
        "id": 217549825,
        "sender_full_name": "oli",
        "timestamp": 1606049205
    },
    {
        "content": "<p>let's go with yours, which I definitely find more reasonable</p>",
        "id": 217549828,
        "sender_full_name": "oli",
        "timestamp": 1606049214
    },
    {
        "content": "<p>basically at the low level when creating locals and stuff, we treat <code>Err(..)</code> and <code>Ok(Uninhabited)</code> the same, except that the <code>Err</code> thing also inserts a <code>panic</code>?</p>",
        "id": 217549854,
        "sender_full_name": "oli",
        "timestamp": 1606049275
    },
    {
        "content": "<p>ok... at that point the \"treat the same\" is irrelevant, and we just insert a <code>panic!</code> where the local would be <code>Err(SizeOverflow)</code></p>",
        "id": 217549926,
        "sender_full_name": "oli",
        "timestamp": 1606049366
    },
    {
        "content": "<p>And maybe emit a lint</p>",
        "id": 217549932,
        "sender_full_name": "oli",
        "timestamp": 1606049385
    },
    {
        "content": "<p>so... we're still stuck with the question around <code>size_of::&lt;[u16; usize::MAX]&gt;()</code></p>",
        "id": 217549984,
        "sender_full_name": "oli",
        "timestamp": 1606049425
    },
    {
        "content": "<p>we (likely) can't make that panic</p>",
        "id": 217549985,
        "sender_full_name": "oli",
        "timestamp": 1606049429
    },
    {
        "content": "<p>Why can't that panic?</p>",
        "id": 217555138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057165
    },
    {
        "content": "<p>It seems reasonable to me that that should evaluate the same as <code>2 * usize::MAX</code></p>",
        "id": 217555147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057195
    },
    {
        "content": "<p>because people may use <code>size_of</code> in unsafe code rn</p>",
        "id": 217555199,
        "sender_full_name": "lcnr",
        "timestamp": 1606057236
    },
    {
        "content": "<p>while expecting that it must not panic</p>",
        "id": 217555204,
        "sender_full_name": "lcnr",
        "timestamp": 1606057243
    },
    {
        "content": "<p>so if we suddenly panic in <code>size_of</code> at least some existing snippets are suddenly unsound</p>",
        "id": 217555222,
        "sender_full_name": "lcnr",
        "timestamp": 1606057276
    },
    {
        "content": "<p>is crashing the compiler an option?</p>",
        "id": 217555323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057400
    },
    {
        "content": "<p>like just say no if you have to monomorphize an impossible type</p>",
        "id": 217555396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057453
    },
    {
        "content": "<p>we are already doing that, but at least i don't want to</p>",
        "id": 217555489,
        "sender_full_name": "lcnr",
        "timestamp": 1606057629
    },
    {
        "content": "<p>or much rather, the current state is a bit inconsistent imo</p>",
        "id": 217555505,
        "sender_full_name": "lcnr",
        "timestamp": 1606057664
    },
    {
        "content": "<p>It seems the dilemma is: either types exist that don't fit in a <code>usize</code>, in which case the type of <code>mem::size_of</code> is a lie and making this visible will cause unsound code, or all types must fit in a <code>usize</code>, in which case the constraints on well formed types get really complicated and in particular are not closed under substitution, which breaks some pre-monomorphization checks</p>",
        "id": 217555557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057713
    },
    {
        "content": "<p>no type fits into a usize</p>",
        "id": 217555569,
        "sender_full_name": "lcnr",
        "timestamp": 1606057739
    },
    {
        "content": "<p>types do not have a size, instances of a type have a size</p>",
        "id": 217555574,
        "sender_full_name": "lcnr",
        "timestamp": 1606057758
    },
    {
        "content": "<p>are we talking about <code>size_of_val</code> here? I thought it was <code>size_of</code></p>",
        "id": 217555585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057786
    },
    {
        "content": "<p>yeah, <code>size_of</code> returns the size of values of <code>T</code></p>",
        "id": 217555633,
        "sender_full_name": "lcnr",
        "timestamp": 1606057806
    },
    {
        "content": "<p>not the size of <code>T</code> itself</p>",
        "id": 217555636,
        "sender_full_name": "lcnr",
        "timestamp": 1606057812
    },
    {
        "content": "<p>because <code>T</code> does not have a size</p>",
        "id": 217555639,
        "sender_full_name": "lcnr",
        "timestamp": 1606057819
    },
    {
        "content": "<p>okay, that's an interesting distinction to make</p>",
        "id": 217555647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057842
    },
    {
        "content": "<p>it's a necessary one though</p>",
        "id": 217555652,
        "sender_full_name": "lcnr",
        "timestamp": 1606057859
    },
    {
        "content": "<p>you can use <code>[u16; usize::MAX]</code> however you want until we try to compute its layout</p>",
        "id": 217555661,
        "sender_full_name": "lcnr",
        "timestamp": 1606057881
    },
    {
        "content": "<p>at which point we currently always emit an error</p>",
        "id": 217555668,
        "sender_full_name": "lcnr",
        "timestamp": 1606057903
    },
    {
        "content": "<p>So we can say that <code>T</code> is associated to a certain value, <code>size_of::&lt;T&gt;()</code>, which is a usize and satisfies the property that every element of the type has that size</p>",
        "id": 217555671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057920
    },
    {
        "content": "<p>in which case for uninhabited types we can pick whatever value we like</p>",
        "id": 217555728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606057959
    },
    {
        "content": "<p>under this definition that's true <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> <code>forall e. f(e) == n</code> is true for every <code>n</code> if <code>|e| == 0</code></p>",
        "id": 217555753,
        "sender_full_name": "lcnr",
        "timestamp": 1606058002
    },
    {
        "content": "<p>If we say it is the minimum value, then uninhabited types get size 0</p>",
        "id": 217555802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606058053
    },
    {
        "content": "<p>my inner mathematician isn't so happy about <code>2 * usize::MAX = 0</code> though</p>",
        "id": 217555810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606058072
    },
    {
        "content": "<p>We could also add a requirement to the auto-implementation of <code>Sized</code> that <code>size_of</code> needs to successfully evaluate. This would be a breaking change, since <code>fn foo&lt;T&gt;() { }</code> can currently be invoked as <code>foo::&lt;[u16; usize::max_value()]&gt;()</code>, and with such a change this would give us a <code>[u16; usize::max_value()]: Sized</code> not satisfied error, requiring <code>foo</code> to have a <code>T: ?Sized</code> bound if it is supposed to be used with types too large to have values of</p>",
        "id": 217556507,
        "sender_full_name": "oli",
        "timestamp": 1606059348
    },
    {
        "content": "<p>Theoretically we can do this in an edition I guess?</p>",
        "id": 217556553,
        "sender_full_name": "oli",
        "timestamp": 1606059407
    },
    {
        "content": "<p>like have a new edition auto-generate some new <code>SizeOf</code> trait bounds everwhere where it generates <code>Sized</code> bounds</p>",
        "id": 217556564,
        "sender_full_name": "oli",
        "timestamp": 1606059438
    },
    {
        "content": "<blockquote>\n<p>Basically [0_u16; usize::MAX] could be replaced by a runtime panic (+ emit a lint), making any code following it unreachable.</p>\n</blockquote>\n<p>I cannot parse this. <code>[0_u16; usize::MAX]</code>is a type, runtime panic an expression, you cannot replace a type by an expression.^^</p>",
        "id": 217557182,
        "sender_full_name": "RalfJ",
        "timestamp": 1606060388
    },
    {
        "content": "<p><code>[0_u16; usize::MAX]</code> is a repeat expression of type <code>[u16; usize::MAX]</code></p>",
        "id": 217557255,
        "sender_full_name": "lcnr",
        "timestamp": 1606060509
    },
    {
        "content": "<p>oh sorry I misread</p>",
        "id": 217557258,
        "sender_full_name": "RalfJ",
        "timestamp": 1606060525
    },
    {
        "content": "<p>TBH it seems silly to compile that into an always-panic, this should just not build...</p>",
        "id": 217557266,
        "sender_full_name": "RalfJ",
        "timestamp": 1606060555
    },
    {
        "content": "<p>also what Oli mentioned above about generic code is even worse -- const-generic code may well assume that <code>[T; N]</code> has size <code>N*size_of::&lt;T&gt;()</code></p>",
        "id": 217557312,
        "sender_full_name": "RalfJ",
        "timestamp": 1606060579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217555574\">said</a>:</p>\n<blockquote>\n<p>types do not have a size, instances of a type have a size</p>\n</blockquote>\n<p>(most) types do have a size, why are you saying this?^^</p>",
        "id": 217557337,
        "sender_full_name": "RalfJ",
        "timestamp": 1606060626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217557312\">said</a>:</p>\n<blockquote>\n<p>also what Oli mentioned above about generic code is even worse -- const-generic code may well assume that <code>[T; N]</code> has size <code>N*size_of::&lt;T&gt;()</code></p>\n</blockquote>\n<p>I certainly did until now, I think I assumed this in some school projects too</p>",
        "id": 217557340,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1606060636
    },
    {
        "content": "<blockquote>\n<p>(most) types do have a size, why are you saying this?</p>\n</blockquote>\n<p>this is really pedantic, but what is the size of <code>u16</code>? Values of type <code>u16</code> have a size of 2 bytes but the type itself does not</p>",
        "id": 217557401,
        "sender_full_name": "lcnr",
        "timestamp": 1606060733
    },
    {
        "content": "<p>in general this issue did get <em>a bit</em> out of control regarding time spent when compared to how much we should be spending on this</p>\n<p>i hope that it is at least enjoyable <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 217557424,
        "sender_full_name": "lcnr",
        "timestamp": 1606060792
    },
    {
        "content": "<p>maybe we need an \"excessive pedantery and tangents\" warning for threads so ppl know they can ignore them if they don't want to play that game <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 217557760,
        "sender_full_name": "oli",
        "timestamp": 1606061272
    },
    {
        "content": "<blockquote>\n<p>this is really pedantic, but what is the size of u16? Values of type u16 have a size of 2 bytes but the type itself does not</p>\n</blockquote>\n<p>the size of u16 is 2</p>",
        "id": 217558670,
        "sender_full_name": "RalfJ",
        "timestamp": 1606062714
    },
    {
        "content": "<p>being really pedantic I find the size of a type easier to define than the size of a value :D</p>",
        "id": 217558711,
        "sender_full_name": "RalfJ",
        "timestamp": 1606062731
    },
    {
        "content": "<p>but FWIW, <a href=\"https://gitlab.mpi-sws.org/iris/lambda-rust\">https://gitlab.mpi-sws.org/iris/lambda-rust</a> is as pedantic as it gets (formalized in Coq) and types have a size :)</p>",
        "id": 217558718,
        "sender_full_name": "RalfJ",
        "timestamp": 1606062765
    },
    {
        "content": "<p>so I feel safe to say that types do have a size :D</p>",
        "id": 217558724,
        "sender_full_name": "RalfJ",
        "timestamp": 1606062787
    },
    {
        "content": "<p>but of course there are many ways to define these things. just, if types dont have a size, we cannot define <code>size_of::&lt;T&gt;</code>, so, uh.^^<br>\nin lambda-rust, values actually do have a size, and we define the size of a type as the size that all its values have (which in particular means all values of a type must have the same size, which is not necessarily given)</p>",
        "id": 217558809,
        "sender_full_name": "RalfJ",
        "timestamp": 1606062900
    },
    {
        "content": "<p>however, with the framework I set up in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md</a>, values dont have a size. types do.</p>",
        "id": 217558818,
        "sender_full_name": "RalfJ",
        "timestamp": 1606062916
    },
    {
        "content": "<p>well, i think of <code>size_of::&lt;T&gt;()</code> to return <code>n</code> with <code>\\forall x: T, size_of_val(&amp;x) == n</code>. This would allow <code>size_of::&lt;!&gt;()</code> and <code>size_of::&lt;[u16; usize::MAX]&gt;()</code> to return whatever we want</p>",
        "id": 217558950,
        "sender_full_name": "lcnr",
        "timestamp": 1606063126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217558818\">said</a>:</p>\n<blockquote>\n<p>however, with the framework I set up in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md</a>, values dont have a size. types do.</p>\n</blockquote>\n<p>i think i've seen that document before but never really took too much time for it</p>",
        "id": 217558973,
        "sender_full_name": "lcnr",
        "timestamp": 1606063174
    },
    {
        "content": "<p>do you know how <code>lambda-rust</code> deals with <code>[u16; usize::MAX]</code>?</p>",
        "id": 217559049,
        "sender_full_name": "lcnr",
        "timestamp": 1606063266
    },
    {
        "content": "<p>does it use arbitrary precision integers for the size or are types without a size allowed?</p>",
        "id": 217559070,
        "sender_full_name": "lcnr",
        "timestamp": 1606063312
    },
    {
        "content": "<p>Hmm, I've sometimes said that <code>size_of::&lt;!&gt;()</code> is actually <code>-inf</code>, but saturates to <code>0</code>.  Maybe we could say that <code>size_of::&lt;[u32; usize::MAX - 1]()</code> also saturates, just to <code>usize::MAX</code>?</p>",
        "id": 217577263,
        "sender_full_name": "scottmcm",
        "timestamp": 1606089429
    },
    {
        "content": "<p>That could work, although it complicates <code>offset_of</code> since now this can fail too. What is the offset of <code>u8</code> in <code>([u16; usize::MAX], u8)</code>?</p>",
        "id": 217577790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606090115
    },
    {
        "content": "<p>perhaps <code>usize::MAX</code>, since the understanding I had of this was essentially that if it actually saturates, then it's impossible to actually have an instant</p>",
        "id": 217578030,
        "sender_full_name": "scottmcm",
        "timestamp": 1606090511
    },
    {
        "content": "<p>It still seems like a footgun to even consider the existence of these kinds of types. Unsafe code authors are <em>not</em> considering this case</p>",
        "id": 217578224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606090813
    },
    {
        "content": "<p>is there any practical application?</p>",
        "id": 217578235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606090846
    },
    {
        "content": "<p>Seems like the main one is not having to put const WF bounds for size_of.</p>",
        "id": 217578502,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606091188
    },
    {
        "content": "<p>I mean, if we crash out eagerly then the type system can continue to pretend that types are unbounded in size and yet <code>size_of</code> returns a usize</p>",
        "id": 217578691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606091479
    },
    {
        "content": "<p>That seems the most similar to the usual way that arithmetic operations cause a panic on overflow: if you haven't considered this case then a crash is appropriate. In this case, the API design doesn't really let us fail nicely on these types, so if they ever arise we can throw a compile error</p>",
        "id": 217578855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606091729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217577263\">said</a>:</p>\n<blockquote>\n<p>Hmm, I've sometimes said that <code>size_of::&lt;!&gt;()</code> is actually <code>-inf</code>, but saturates to <code>0</code>.  Maybe we could say that <code>size_of::&lt;[u32; usize::MAX - 1]()</code> also saturates, just to <code>usize::MAX</code>?</p>\n</blockquote>\n<p>Assigning <code>!</code> any size seems misleading to me. It doesn't have a size (negative infinity or otherwise).</p>",
        "id": 217579556,
        "sender_full_name": "varkor",
        "timestamp": 1606092867
    },
    {
        "content": "<blockquote>\n<p>It still seems like a footgun to even consider the existence of these kinds of types. Unsafe code authors are not considering this case</p>\n</blockquote>\n<p>Yeah, as someone who writes plenty of unsafe code, having to consider this (which seems more likely once min_const_generics come around) seems like a absolute headache that I wouldn't have considered at all before now.</p>",
        "id": 217580300,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606094008
    },
    {
        "content": "<p>IMO ideally size_of on such a type would just produce an error, honestly. The size can't be represented as a usize, so this seems totally reasonable and the best way to adding a footgun</p>",
        "id": 217580398,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606094104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217580398\">said</a>:</p>\n<blockquote>\n<p>IMO ideally size_of on such a type would just produce an error, honestly. The size can't be represented as a usize, so this seems totally reasonable and the best way to adding a footgun</p>\n</blockquote>\n<p>it does report an error, but that fact is not represented in the generic parameters of a function, so <code>size_of::&lt;T&gt;()</code> inside a generic function can fail arbitrarily while monomorphizing the function. Ideally we'd error because some generic bounds on the function aren't satisfied</p>",
        "id": 217594972,
        "sender_full_name": "oli",
        "timestamp": 1606115834
    },
    {
        "content": "<p>I don't see the problem with that. This is a monomorphization time problem</p>",
        "id": 217604855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606123608
    },
    {
        "content": "<p>This is like, generically you can say that <code>n + 1</code> is a number whenever <code>n</code> is but if you use that constructor enough times bad things will happen</p>",
        "id": 217604917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606123656
    },
    {
        "content": "<p>and you can't know in advance how deeply things will nest until monomorphization time</p>",
        "id": 217605000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606123689
    },
    {
        "content": "<p>Monomorphization time errors are bad for usability. There is a reason we don't take the C++ approach, but instead use trait bounds.</p>",
        "id": 217605054,
        "sender_full_name": "bjorn3",
        "timestamp": 1606123726
    },
    {
        "content": "<p>I understand that, but I think <em>this particular problem</em> doesn't make any sense with trait bounds</p>",
        "id": 217605330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606123889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217559049\">said</a>:</p>\n<blockquote>\n<p>do you know how <code>lambda-rust</code> deals with <code>[u16; usize::MAX]</code>?</p>\n</blockquote>\n<p>we use natural numbers for everything. so there's no upper bound.</p>",
        "id": 217683922,
        "sender_full_name": "RalfJ",
        "timestamp": 1606166274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217577263\">said</a>:</p>\n<blockquote>\n<p>Hmm, I've sometimes said that <code>size_of::&lt;!&gt;()</code> is actually <code>-inf</code>, but saturates to <code>0</code>.  Maybe we could say that <code>size_of::&lt;[u32; usize::MAX - 1]()</code> also saturates, just to <code>usize::MAX</code>?</p>\n</blockquote>\n<p>the way things currently stand, it should saturate to <code>isize::MAX as usize</code>, actually...</p>",
        "id": 217683999,
        "sender_full_name": "RalfJ",
        "timestamp": 1606166308
    },
    {
        "content": "<blockquote>\n<p>Hmm, I've sometimes said that size_of::&lt;!&gt;() is actually -inf, but saturates to 0.</p>\n</blockquote>\n<p>FWIW, in lambdaRust (and also with <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>'s derived notion of the size of a type), <code>!</code> can have <em>any possible size</em>. we can literally pick whatever we want and it is correct (as <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> already said above)</p>",
        "id": 217684062,
        "sender_full_name": "RalfJ",
        "timestamp": 1606166360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217579556\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217577263\">said</a>:</p>\n<blockquote>\n<p>Hmm, I've sometimes said that <code>size_of::&lt;!&gt;()</code> is actually <code>-inf</code>, but saturates to <code>0</code>.  Maybe we could say that <code>size_of::&lt;[u32; usize::MAX - 1]()</code> also saturates, just to <code>usize::MAX</code>?</p>\n</blockquote>\n<p>Assigning <code>!</code> any size seems misleading to me. It doesn't have a size (negative infinity or otherwise).</p>\n</blockquote>\n<p>that definitely depends on your definition.^^ since <code>!: Sized</code>, I think saying it doesnt have a size makes no sense. And lambda-rust provides a concrete formal framework in which <code>!</code> can have any possible size, so <code>0</code> seems like the most reasonable choice. (lambda-rust does not cover all of Rust, in particular it does not cover DST, but I see no issue generalizing this approach.)</p>",
        "id": 217684220,
        "sender_full_name": "RalfJ",
        "timestamp": 1606166445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217594972\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217580398\">said</a>:</p>\n<blockquote>\n<p>IMO ideally size_of on such a type would just produce an error, honestly. The size can't be represented as a usize, so this seems totally reasonable and the best way to adding a footgun</p>\n</blockquote>\n<p>it does report an error, but that fact is not represented in the generic parameters of a function, so <code>size_of::&lt;T&gt;()</code> inside a generic function can fail arbitrarily while monomorphizing the function. Ideally we'd error because some generic bounds on the function aren't satisfied</p>\n</blockquote>\n<p>to be clear, this fails during monomorphizaion not just specifically for <code>size_of</code>, right? if the function uses <code>T</code> in any way where its size could possibly matter, monomorphization fails.</p>",
        "id": 217684309,
        "sender_full_name": "RalfJ",
        "timestamp": 1606166506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> </p>\n<blockquote>\n<p>well, i think of size_of::&lt;T&gt;() to return n with \\forall x: T, size_of_val(&amp;x) == n. </p>\n</blockquote>\n<p>So types <em>do</em> have a size after all :) it is the <code>n</code> such that <code>\\forall x: T, size_of_val(&amp;x) == n</code>. That's exactly what lambda-rust does. The size is a <em>defined</em> notion, nothing \"primitive\", but that doesn't mean that it doesn't <em>exist</em>. Almost everything in math is a defined notion, after all.</p>",
        "id": 217684695,
        "sender_full_name": "RalfJ",
        "timestamp": 1606166718
    },
    {
        "content": "<p>yeah, and i think defining <code>n</code> such that <code>\\forall x: T, size_of_val(&amp;x) == n</code> to be the \"size\" of <code>T</code> is not a helpful notion <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 217685768,
        "sender_full_name": "lcnr",
        "timestamp": 1606167397
    },
    {
        "content": "<p>it's a used one though :_</p>",
        "id": 217685843,
        "sender_full_name": "lcnr",
        "timestamp": 1606167445
    },
    {
        "content": "<p>It looks we already fail post-monomorphization on the case though, so it shouldn't be too difficult to just accept it as a post monomorphization error no?</p>\n<p>Aside: monomorphization is terrible to spell</p>",
        "id": 217703508,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606179500
    },
    {
        "content": "<p>yea, we don't have to change anything to keep the post-monomorphization error. What this thread is about is brainstorming whether we can eliminate that post-monomorphization error</p>",
        "id": 217735311,
        "sender_full_name": "oli",
        "timestamp": 1606213818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/213817-t-lang/topic/mem.3A.3Asize_of.3A.20do.20not.20error.20if.20layout.20computations.20fail/near/217685843\">said</a>:</p>\n<blockquote>\n<p>it's a used one though :_</p>\n</blockquote>\n<p><a href=\"#narrow/stream/213817-t-lang/topic/Do.20types.20have.20a.20size.3F\">Continuing here</a></p>",
        "id": 218119751,
        "sender_full_name": "RalfJ",
        "timestamp": 1606502547
    }
]