[
    {
        "content": "<p>Currently, we never emit an 'unused' warning for trait impls - since all trait impls are 'public', we can't know if they might be used by a downstream crate.<br>\nHowever, there are some cases where we can guarnatee that a trait impl is unused. If we implement a non-auto-trait for a type that's not reachable outside of the current crate (as determined by <code>privacy::AccessLevels</code>, then we can be sure that the only possible usages of that trait impl occur within our crate.</p>",
        "id": 249519537,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629043543
    },
    {
        "content": "<p>I think it would be useful to extend the <code>dead_code</code> lint to trait impls using the above logic. We would still be unable to detect unused trait impls within a multi-crate workspace (like rustc), but this would still be an improvement over the status quo.</p>",
        "id": 249519589,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629043597
    },
    {
        "content": "<p>The actual tracking of used trait impls would be done during trait selection/projection (the interaction with incr comp will be tricky, unfortunately)</p>",
        "id": 249519684,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629043721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unused.20impl.20warnings/near/249519684\">said</a>:</p>\n<blockquote>\n<p>The actual tracking of used trait impls would be done during trait selection/projection (the interaction with incr comp will be tricky, unfortunately)</p>\n</blockquote>\n<p>I guess we would collect this information in <code>InferCtxt</code> during typeck, so we could put it into the <code>TypeckResults</code> datastructure returned by the typeck query</p>",
        "id": 249579466,
        "sender_full_name": "oli",
        "timestamp": 1629115466
    },
    {
        "content": "<p>but there may be other places creating their own <code>InferCtxt</code> that we could miss</p>",
        "id": 249579496,
        "sender_full_name": "oli",
        "timestamp": 1629115486
    },
    {
        "content": "<p>It will need to be stored globally, since many implnusages happen in the <code>evaluate_obligation</code> query, which creates a fresh InferCtxt</p>",
        "id": 249623161,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629136364
    },
    {
        "content": "<p>Implementing this turns out be significantly trickier than I thought it would be. Well-formed checking will cause us to 'use' an <code>ImplCandidate</code> for every trait impl (because we try to evaluate <code>MyType as Trait</code> when we see <code>impl Trait for MyType</code>). This causes us to popualte several caches (the query cache for <code>evaluate_obligation</code>, the evaluation cache, etc.), meaning we won't see another <code>ImplCandidate</code> usage for a 'real' usage of the impl</p>",
        "id": 249674184,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629169578
    },
    {
        "content": "<p>Delaying well-formed checking until after 'unused' checking causes a large number of extra errors (and some ICEs) in the test suite, since compilation normally exits early when wf-checking fails</p>",
        "id": 249674204,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629169626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unused.20impl.20warnings/near/249623161\">said</a>:</p>\n<blockquote>\n<p>It will need to be stored globally, since many implnusages happen in the <code>evaluate_obligation</code> query, which creates a fresh InferCtxt</p>\n</blockquote>\n<p>Right. That's what I was afraid of. I still think we should try to come up with a non-global system. Maybe the queries could return a structure containing their result, plus this information ? then we can have a lint that iterates all the queries and aggregates the info?</p>",
        "id": 249697741,
        "sender_full_name": "oli",
        "timestamp": 1629194203
    },
    {
        "content": "<p>We can perform trait selection from any query, so I think this would end up being effectively the same as a global approach</p>",
        "id": 249736189,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629214473
    },
    {
        "content": "<p>do we have anything else that is global like this?</p>",
        "id": 249737731,
        "sender_full_name": "oli",
        "timestamp": 1629215158
    },
    {
        "content": "<p>Diagnostics are the main thing - I did some refactoring around this in <a href=\"https://github.com/rust-lang/rust/pull/87416\">https://github.com/rust-lang/rust/pull/87416</a></p>",
        "id": 249737864,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1629215200
    }
]