[
    {
        "content": "<p>@josh <a href=\"#narrow/stream/213817-t-lang/topic/values.20of.20Rust/near/194229359\" title=\"#narrow/stream/213817-t-lang/topic/values.20of.20Rust/near/194229359\">wrote</a>.</p>\n<blockquote>\n<blockquote>\n<p>it should not be possible to have undefined behavior without the unsafe keyword.</p>\n</blockquote>\n<p>Is it \"undefined behavior\" you want to flag here? That statement is true, but it seems somewhat separate from the primary things unsafe exists to address.</p>\n<p>I feel like that's related to what unsafe means, but not directly what unsafe means.</p>\n</blockquote>\n<p>that thread went elsewhere so I am forking here</p>",
        "id": 194369269,
        "sender_full_name": "RalfJ",
        "timestamp": 1587072214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I would have defined exactly that to be the primary concern of <code>unsafe</code> -- to avoid UB.<br>\nWhat would you have said is \"directly what unsafe means\"?</p>",
        "id": 194369358,
        "sender_full_name": "RalfJ",
        "timestamp": 1587072244
    },
    {
        "content": "<p>At the risk of handwaving on the fly: I feel like <code>unsafe</code> is more closely related to invariants or requirements than to UB specifically.</p>",
        "id": 194369681,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587072427
    },
    {
        "content": "<p>An <code>unsafe</code> method on a type isn't necessarily going to produce UB if you call it with insufficient care.</p>",
        "id": 194369718,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587072451
    },
    {
        "content": "<p>It might just violate an invariant of the type, or produce an assert or panic, for instance. The existence of a check and panic might prevent any actual UB from occurring, but that doesn't mean the method should be marked safe.</p>",
        "id": 194369840,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587072509
    },
    {
        "content": "<p>well you just marked all of indexing unsafe with that rule :P</p>",
        "id": 194370698,
        "sender_full_name": "Lokathor",
        "timestamp": 1587073079
    },
    {
        "content": "<p>I think I know what Josh is getting at: from an end-user's perspective, I don't really care about UB for its own sake. Rather, I care that my program is correct, fast, and not a pain to write. We define UB in rust to achieve rust's balance of these goals.</p>",
        "id": 194460996,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587138605
    },
    {
        "content": "<p>Thinking about it further, I think it's reasonable to describe <code>unsafe</code> as marking regions where the compiler doesn't prevent you from invoking UB (including library UB) and you need to take care not to do so. (Though I'd phrase it somewhat differently when explaining it to a new Rust user than when documenting it for a language definition.) I think there's a certain degree to which I may just be shying away from using \"UB\" as part of a description of a useful concept, because I've mostly seen \"UB\" used as a hammer to hit people over the head with and tell them that their programs were never right to begin with so it's OK for the compiler to break them.</p>",
        "id": 194461453,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587138806
    },
    {
        "content": "<p>I need to learn that not everyone uses the term \"UB\" that way.</p>",
        "id": 194461478,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587138820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194369681\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194369681\">said</a>:</p>\n<blockquote>\n<p>At the risk of handwaving on the fly: I feel like <code>unsafe</code> is more closely related to invariants or requirements than to UB specifically.</p>\n</blockquote>\n<p>hm, interesting. to me, the purpose of these invariants is to prove absence of UB.</p>",
        "id": 194463890,
        "sender_full_name": "RalfJ",
        "timestamp": 1587139792
    },
    {
        "content": "<p>but of course I come from the perspective of a PL researcher, always on the look for a theorem to prove</p>",
        "id": 194463962,
        "sender_full_name": "RalfJ",
        "timestamp": 1587139809
    },
    {
        "content": "<p>\"without unsafe there is no UB\" is a really juicy theorem :D</p>",
        "id": 194463991,
        "sender_full_name": "RalfJ",
        "timestamp": 1587139825
    },
    {
        "content": "<p>do you have interesting examples of invariants people are guarding with <code>unsafe</code> that are unrelated to UB?</p>",
        "id": 194464068,
        "sender_full_name": "RalfJ",
        "timestamp": 1587139880
    },
    {
        "content": "<p>Offhand, I can think of data structures involving multiple coordinated things and using indexes as \"pointers\" into a <code>Vec</code> (because you can't have references and the thing they reference in the same <code>struct</code>), where <code>unsafe</code> methods are the ones that don't guarantee every index has a corresponding Vec element.</p>",
        "id": 194464215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587139960
    },
    {
        "content": "<p>one example I could think of (stealing from PL literature here, people did stuff like that e.g. for Haskell) is having a type that enforces information flow properties, so that no safe program can leak confidential data on untrusted channels. that is another theorem, rather independent from UB.</p>",
        "id": 194464225,
        "sender_full_name": "RalfJ",
        "timestamp": 1587139965
    },
    {
        "content": "<p>Effectively, data-structure invariants rather than language-level UB. If it were <code>std</code>, we'd call it \"library UB\".</p>",
        "id": 194464258,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587139991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194464258\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194464258\">said</a>:</p>\n<blockquote>\n<p>Effectively, data-structure invariants rather than language-level UB. If it were <code>std</code>, we'd call it \"library UB\".</p>\n</blockquote>\n<p>I think user crates can also have \"library UB\", std is not special here.</p>",
        "id": 194464287,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140006
    },
    {
        "content": "<p>OK, I can't help but meme here:<br>\n\"You can't just call everything undefined behavior!\"<br>\n\"haha unsafe go brrr\"</p>",
        "id": 194464416,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140061
    },
    {
        "content": "<p>actually <a href=\"#narrow/stream/122651-general/topic/Library.20level.20Undefined.20Behavior\" title=\"#narrow/stream/122651-general/topic/Library.20level.20Undefined.20Behavior\">this was recently discussed here</a> ;)</p>",
        "id": 194464426,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194464416\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194464416\">said</a>:</p>\n<blockquote>\n<p>OK, I can't help but meme here:<br>\n\"You can't just call everything undefined behavior!\"<br>\n\"haha unsafe go brrr\"</p>\n</blockquote>\n<p>I got to admit this one is lost on me^^</p>",
        "id": 194464468,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140093
    },
    {
        "content": "<p>in std I think a long time ago a policy was set not to use <code>unsafe</code> to guard against non-UB \"dangerous\" API usage. that was when <code>mem::forget</code> became safe.</p>",
        "id": 194464544,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140142
    },
    {
        "content": "<p>Right. I think it's worth observing that not every library follows the same policy as <code>std</code>.</p>",
        "id": 194464614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140164
    },
    {
        "content": "<p>And in particular, I think if I were writing a library crate and there were a method that could leak memory if misused, I'd mark it <code>unsafe</code>.</p>",
        "id": 194464647,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140181
    },
    {
        "content": "<p>As in \"you need to carefully read the requirements of this method before using it, they may not be enforced by the interface\".</p>",
        "id": 194464669,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140194
    },
    {
        "content": "<p>hm, interesting.</p>",
        "id": 194464682,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140208
    },
    {
        "content": "<p>but I am not sure how common that sentiment is</p>",
        "id": 194464720,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140229
    },
    {
        "content": "<p>so \"unsafe is to prevent UB\" might still be the \"least common denominator\", the one thing we <em>have</em> to all agree on to make the ecosystem work</p>",
        "id": 194464761,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140250
    },
    {
        "content": "<p>I don't know either. But given that people can define any method as <code>unsafe</code> to call, they can attach any semantic they want to it.</p>",
        "id": 194464796,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140271
    },
    {
        "content": "<p>that doesn't exclude people from using stronger invariants locally.</p>",
        "id": 194464819,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194464761\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194464761\">said</a>:</p>\n<blockquote>\n<p>so \"unsafe is to prevent UB\" might still be the \"least common denominator\", the one thing we <em>have</em> to all agree on to make the ecosystem work</p>\n</blockquote>\n<p>Right. If something could cause UB, it <em>must</em> be marked as <code>unsafe</code>. But something being marked <code>unsafe</code> doesn't require that it relates to UB.</p>",
        "id": 194464941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140338
    },
    {
        "content": "<p>Some crates don't actually uphold the guarantees laid down in the Nomicon - \"you cannot cause UB without unsafe\" - and expose some functions as safe that are possible, but not easy to misuse, because guarding against all misuse is too costly in terms of performance. <code>libc</code> and <code>glium</code> come to mind</p>",
        "id": 194464987,
        "sender_full_name": "Shnatsel",
        "timestamp": 1587140365
    },
    {
        "content": "<p>I'm curious, what kinds of methods in <code>libc</code> potentially allow UB without being <code>unsafe</code>?</p>",
        "id": 194465177,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that's fair. but even with that I think the relation to UB is so supremely important that it should be part of whatever one-sentence \"pitch\" about unsafe ends up in a \"values\" doument.</p>",
        "id": 194465195,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194465177\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194465177\">said</a>:</p>\n<blockquote>\n<p>I'm curious, what kinds of methods in <code>libc</code> potentially allow UB without being <code>unsafe</code>?</p>\n</blockquote>\n<p><code>fork</code> comes to my mind... I think there's still some crates out there that expose it safely, might not be <code>libc</code>.</p>",
        "id": 194465238,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140479
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/libc/issues/1501\" title=\"https://github.com/rust-lang/libc/issues/1501\">https://github.com/rust-lang/libc/issues/1501</a> for example</p>",
        "id": 194465288,
        "sender_full_name": "Shnatsel",
        "timestamp": 1587140512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> If that's the case, then it needs explanation for the benefit of people who don't know what that document may mean by \"UB\", or who have different associations with the concept than programming language researchers do. :)</p>",
        "id": 194465296,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Before I came to Rust, I understood in general what undefined behavior was, but my association with it very much included a critical subset of \"what standards refuse to define despite it having a practical definition in real-world compilers, and which we have to keep passing more options to those compilers to remind them to stop breaking it\".</p>",
        "id": 194465440,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140607
    },
    {
        "content": "<p>oh I see, you are saying the term is burnt for some people</p>",
        "id": 194465490,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140638
    },
    {
        "content": "<p>yeah I can see that</p>",
        "id": 194465493,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140641
    },
    {
        "content": "<p>Right.</p>",
        "id": 194465540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140644
    },
    {
        "content": "<p>I mean, until some of the most recent C standards, it was UB to assume that integers are two's complement.</p>",
        "id": 194465543,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140646
    },
    {
        "content": "<p>I agree UB in C is... sad :(</p>",
        "id": 194465580,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140671
    },
    {
        "content": "<p>which is why I am working hard to make it better in Rust^^</p>",
        "id": 194465585,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140679
    },
    {
        "content": "<p>And I think it's still UB to cast a pointer to a different type and dereference it, despite that happening <em>all the time</em> in systems programming contexts.</p>",
        "id": 194465607,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140693
    },
    {
        "content": "<p>maybe we shouldnt have re-used the term</p>",
        "id": 194465609,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140693
    },
    {
        "content": "<p>the underlying principle is the same but people can see UB in C and put out the baby with the bathwater</p>",
        "id": 194465662,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140721
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 194465669,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140727
    },
    {
        "content": "<p>There are a <em>lot</em> of people whose fundamental reasoning is \"I know what code this should turn into, and I know what that code does on the machine\". Which is sometimes reasonable, and sometimes not.</p>",
        "id": 194465786,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140777
    },
    {
        "content": "<p>what I mostly dont like about the term is that it's a negative one</p>",
        "id": 194465791,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140780
    },
    {
        "content": "<p>I'd much rather say \"this program is $safe\" ($safe := \"cannot cause UB\"/\"has well-defined semantics\"/\"does not hit an error state in the abstract machine\") than \"this program is UB-free\"</p>",
        "id": 194465853,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140818
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 194465896,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140843
    },
    {
        "content": "<p>I agree with preferring positive statements to negative ones.</p>",
        "id": 194465908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587140852
    },
    {
        "content": "<p>in PL research we sometimes use \"safe\" for that, might be confusing though with \"safe code\"... we'd basically be saying \"even your unsafe code must be safe but then it is your responsibility; safe code is checked to be safe by the compiler\"^^</p>",
        "id": 194466008,
        "sender_full_name": "RalfJ",
        "timestamp": 1587140889
    },
    {
        "content": "<p>Yeah. I wonder sometimes if there was a term like \"unchecked\" we could have used instead of \"unsafe\".</p>",
        "id": 194466355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141035
    },
    {
        "content": "<p>I do think it may be confusing, but can also be helpful. I recall finding it illuminating that \"all code must be safe\", i.e. that unsafe is not an escape hatch into UB is fine.</p>",
        "id": 194466364,
        "sender_full_name": "simulacrum",
        "timestamp": 1587141040
    },
    {
        "content": "<p>\"Abandon all compiler aid, all ye who press enter here\"</p>",
        "id": 194466392,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194466364\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194466364\">said</a>:</p>\n<blockquote>\n<p>I do think it may be confusing, but can also be helpful. I recall finding it illuminating that \"all code must be safe\", i.e. that unsafe is not an escape hatch into UB is fine.</p>\n</blockquote>\n<p>\"statically\" and \"dynamically\" safe woild be possible disambiguations here</p>",
        "id": 194466502,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141109
    },
    {
        "content": "<p>Hm, that's an interesting way of looking at it. I think I may like it :)</p>",
        "id": 194466724,
        "sender_full_name": "simulacrum",
        "timestamp": 1587141212
    },
    {
        "content": "<p>Interesting. How does that interact with things like \"dynamic\" borrow checking, such as <code>Rc</code>?</p>",
        "id": 194466970,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141340
    },
    {
        "content": "<p>hm, if someone said \"dynamic borrow checking\" I'd think they mean Stacked Borrows as that's how I have sometimes described it^^</p>",
        "id": 194467328,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141503
    },
    {
        "content": "<p>and then it is quite parallel with statically/dynamically \"safe\" code</p>",
        "id": 194467353,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141520
    },
    {
        "content": "<p><code>Rc</code> has no equivalent to <code>&amp;mut</code>, so I cannot really see it as a \"dynamic borrow checker\". if anything, that would be <code>RefCell</code>.</p>",
        "id": 194467412,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141551
    },
    {
        "content": "<p>I very much think of stacked borrows as static borrow checking, just <em>smarter</em> static borrow checking.</p>",
        "id": 194467449,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141573
    },
    {
        "content": "<p>but stacked borrows is dynamic</p>",
        "id": 194467472,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141585
    },
    {
        "content": "<p>as in, it runs at \"program run-time\"</p>",
        "id": 194467480,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141592
    },
    {
        "content": "<p>it's not a static analysis that you can run on code without executing said code</p>",
        "id": 194467542,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141605
    },
    {
        "content": "<p>we have a static analysis that approximates stacked borrows, and it is called borrow checking</p>",
        "id": 194467586,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141628
    },
    {
        "content": "<p>I wasn't aware of the dynamic version. I thought that stacked borrows was a model that was being used to analyze and reason about the borrow checker.</p>",
        "id": 194468088,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141873
    },
    {
        "content": "<p>there <em>only</em> is a dynamic version</p>",
        "id": 194468139,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141899
    },
    {
        "content": "<p>it is a model used to analyze the borrow checker, well, one could say that, but analysis happens by \"run this code in miri\"</p>",
        "id": 194468187,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141921
    },
    {
        "content": "<p>/me is confused.</p>",
        "id": 194468201,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141931
    },
    {
        "content": "<p>I thought that the model was a formal reasoning model, as in a set of written rules and theorems for human readers, not a computer implementation.</p>",
        "id": 194468266,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141962
    },
    {
        "content": "<p>we can then prove theorems about programs running with stacked borrows, and those theorems are \"static\" in some sense</p>",
        "id": 194468308,
        "sender_full_name": "RalfJ",
        "timestamp": 1587141969
    },
    {
        "content": "<p>It's a code implementation, first and foremost?</p>",
        "id": 194468314,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587141972
    },
    {
        "content": "<p>Stacked Borrows is...</p>\n<ul>\n<li>a code implementation in Miri, that does some extra checking when running Rust code.</li>\n<li>a formalization of these rules as a formal \"operational semantics\".</li>\n</ul>\n<p>these two are basically equivalent, just one is written in Rust and the other in math/Coq</p>",
        "id": 194468446,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142054
    },
    {
        "content": "<p>Ah, that makes more sense, thank you. I was only aware of the latter, not the former.</p>",
        "id": 194468471,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587142074
    },
    {
        "content": "<p>and both are \"dynamic\" in nature</p>",
        "id": 194468515,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142083
    },
    {
        "content": "<p>in the sense that thy describe program executions</p>",
        "id": 194468530,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142089
    },
    {
        "content": "<p>you wouldn't call Rust \"static\" just because there exists a \"static\" piece of code (Miri) that can run Rust code</p>",
        "id": 194468565,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142110
    },
    {
        "content": "<p>No, certainly not. I was thinking of the formal model, and then of the borrow-checker rules in Rust that that model models.</p>",
        "id": 194468622,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587142141
    },
    {
        "content": "<p>so likewise, these formal \"operational\" rules, while being written for human and mathematical consumption, are as \"dynamic\" as an interpreter</p>",
        "id": 194468626,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142143
    },
    {
        "content": "<p>they have the same information content</p>",
        "id": 194468670,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142172
    },
    {
        "content": "<p>Thanks for the explanation and clarification. :)</p>",
        "id": 194468673,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587142173
    },
    {
        "content": "<p>sure. :) I realize I am using a lot of jargon and don't always know which part of it is confusing.</p>",
        "id": 194468709,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194468314\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194468314\">said</a>:</p>\n<blockquote>\n<p>It's a code implementation, first and foremost?</p>\n</blockquote>\n<p>historical trivia, I did the code implementation first, and then a colleague put everything into math ;)</p>",
        "id": 194468832,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142238
    },
    {
        "content": "<p>In this case, it wasn't the jargon, just information I was missing about the nature of stacked borrows.</p>",
        "id": 194468840,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587142241
    },
    {
        "content": "<p>but in my head both are just different ways to express the same concepts</p>",
        "id": 194468888,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142267
    },
    {
        "content": "<p>that's what I like so much about Miri -- it is an artifact that lets me very clearly communicate details of semantics with people that have no/not much formal background but understand interpreters, and at the same time it is a very precise mathematical specification of Rust behavior, and one that we can even test</p>",
        "id": 194469085,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142358
    },
    {
        "content": "<p>so with my PhD advisor I'd discuss rust semantics via formal mathematical rules, and here on Zulip I'd discuss the same things by pointing at Rust code implementing steps in an interpreter ;)</p>",
        "id": 194469243,
        "sender_full_name": "RalfJ",
        "timestamp": 1587142426
    },
    {
        "content": "<p>One thing I've found valuable about <code>std</code> keeping a fairly hard line about <code>unsafe</code> meaning that misuse can be unsound is that it reduces the tendency for people to \"how bad could it be?\"</p>",
        "id": 194505916,
        "sender_full_name": "scottmcm",
        "timestamp": 1587161016
    },
    {
        "content": "<p>More more APIs that are unsafe for being easy to misuse, the more likely people are to say \"I'm pretty sure that this won't be zero, so I'll just use <code>NonZeroU32::new_unchecked</code>; it's just a correctness hint\".</p>",
        "id": 194506113,
        "sender_full_name": "scottmcm",
        "timestamp": 1587161152
    },
    {
        "content": "<p>I have wanted a separate lint, though likely deny by default, that is basically that middle ground of \"be very careful but not UB\"</p>",
        "id": 194506338,
        "sender_full_name": "simulacrum",
        "timestamp": 1587161326
    },
    {
        "content": "<p>I've never marked code as unsafe if i wasn't worried about UB happening, but I've also often wanted \"hey watch it with this\" signs</p>",
        "id": 194528645,
        "sender_full_name": "Lokathor",
        "timestamp": 1587190421
    },
    {
        "content": "<p>An attribute on functions that rustdoc knows about and that signals a warning by default seems an appropriate solution to this sort of thing</p>",
        "id": 194528709,
        "sender_full_name": "Lokathor",
        "timestamp": 1587190515
    },
    {
        "content": "<p>like the reverse of must_use</p>",
        "id": 194528715,
        "sender_full_name": "Lokathor",
        "timestamp": 1587190536
    },
    {
        "content": "<p>Catching up on this thread:</p>\n<ul>\n<li>I still stand by the principle that <code>unsafe</code> means \"you may create UB\" full-stop, at least in the stdlib. It seems like a <strong>really important</strong> line to me. To me, it's the difference between writing Java/Python code and writing C++, in some sense, in terms of reliability, and that's a huge difference.</li>\n<li>Still, I think that there <em>is</em> a need to be able to mark \"dangerous\" methods that don't cause UB but may have other consequences. </li>\n<li>Of course it's been proposed to let people give \"reasons\" that things are unsafe, or other details, and maybe that's a good compromise. So <code>unsafe</code> is kind of <code>unsafe(ub)</code> today, and maybe there are other invariants that are threatened. </li>\n<li>In practice, safe code <em>can</em> cause UB, yes, the standard example is writing to <code>/proc/mem</code> or whatever. I think that's a tricky line and I don't really know how to think about it, but I suspect I would draw a \"harsher\" than line than some libraries do. I think we have to be <strong>really, really</strong> careful here. (See above about how big a difference it is.)</li>\n<li>I tend to agree the term UB is not great for a variety of reasons. I don't think it sounds as dangerous as it is, for one thing, and I think it's \"poisoned\" by the way it's been conflated with \"implementation dependent\" and some other things. It's also not great that it's negative, but sometimes that's useful too (it's useful to be able to say \"this is dangerous\" and \"this is safe\", in other words).</li>\n</ul>",
        "id": 194539475,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587209021
    },
    {
        "content": "<p>I'm against extending <code>unsafe</code> beyond \"you may create UB\". That's how we ended up with things like <code>AssertUnwindSafe</code> which I feel is a huge API wart.</p>",
        "id": 194549281,
        "sender_full_name": "Amanieu",
        "timestamp": 1587222768
    },
    {
        "content": "<p>Yeah, I would strongly agree about not extending unsafe. I think there may be room for creating something else (different keyword, etc) that is separate, specifically to provide more room for saying \"unsafe is just about UB\"</p>",
        "id": 194549841,
        "sender_full_name": "simulacrum",
        "timestamp": 1587223446
    },
    {
        "content": "<p>ugh me and my fat fingers</p>",
        "id": 194553129,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587227973
    },
    {
        "content": "<p>I like Ralf's description: \"safe\" = \"has well-defined semantics\"</p>",
        "id": 194553179,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587228008
    },
    {
        "content": "<p>^^^ that's what I meant to type</p>",
        "id": 194553186,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587228020
    },
    {
        "content": "<p>I've also really wondered about the practical edge cases in kernel development: in particular, it seems like rust's abstract machine kind of assumes a sane traditional process model in which processes have a normal address space that doesn't change observably during the program. This is absolutely not true for an operating system where parts of the address space may appear or disappear or be modified by hardware (e.g. consider memory-mapped io where a ld/st instruction doesn't mean what it normally means) or paging or switch from 32-bit mode to 64-bit mode... it means that crates like <a href=\"https://docs.rs/x86_64/0.10.1/x86_64/index.html\" title=\"https://docs.rs/x86_64/0.10.1/x86_64/index.html\">x86_64</a> are very hard to make ergonomic because nearly everything can break some assumption about the underlying state of the machine</p>",
        "id": 194553371,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587228314
    },
    {
        "content": "<p>I don't think that Rust's memory model is incompatible with this: such changes are simply concurrent modifications by another \"thread\" (in this case the MMU). All you need is an appropriate fence (either a <code>compiler_fence</code> or an <code>asm!</code> with the \"memory\" clobber)  to avoid data races.</p>",
        "id": 194553524,
        "sender_full_name": "Amanieu",
        "timestamp": 1587228504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I think I agree that it's not incompatible with rust's memory model, but I guess I'm not fully confident that the solution you mentioned is a general solution -- it seems like there could be corner cases. For example, switching modes means that the definition of a pointer changes (64-bit pointers may no longer be valid) and making paging changes may mean that two pointers start aliasing that weren't before. Somehow you need to inform the compiler about that or else use unsafe everywhere... doing it ergonomically is rather hard.</p>",
        "id": 194553778,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587228947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194549281\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194549281\">said</a>:</p>\n<blockquote>\n<p>I'm against extending <code>unsafe</code> beyond \"you may create UB\". That's how we ended up with things like <code>AssertUnwindSafe</code> which I feel is a huge API wart.</p>\n</blockquote>\n<p><code>AssertUnwindSafe</code> is <em>not</em> unsafe though, so it is explicitly <em>not</em> an example for extending unsafe beyond UB.</p>",
        "id": 194585182,
        "sender_full_name": "RalfJ",
        "timestamp": 1587283394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198054\">@mark-i-m</span> those are some valid and seriously hard questions you are raising there</p>",
        "id": 194585185,
        "sender_full_name": "RalfJ",
        "timestamp": 1587283408
    },
    {
        "content": "<p>in terms of academic PL research, most researchers run away screaming when you ask them about page table changes, so there's not a ton of work in that area. ;) even just precisely specifying hardware behavior of these things, or other things like \"what when executing an instructions races with other code that <em>modifies the encoded instruction</em>\", is a niche. I know of no work that tries to then push such low-level shenanigans up through a high-level abstract machine.</p>",
        "id": 194585250,
        "sender_full_name": "RalfJ",
        "timestamp": 1587283526
    },
    {
        "content": "<p>do people really switch address mode between 32 and 64 bit <em>in Rust</em>? like, during the execution of a single rust program? that's... wow.^^</p>",
        "id": 194585299,
        "sender_full_name": "RalfJ",
        "timestamp": 1587283612
    },
    {
        "content": "<p>If you're writing an operating system in Rust, sure. You have to.</p>",
        "id": 194600134,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587306240
    },
    {
        "content": "<p>I thought this would happen sometime in some assembly-written preamble early in the bootloader or so</p>",
        "id": 194600870,
        "sender_full_name": "RalfJ",
        "timestamp": 1587307257
    },
    {
        "content": "<p>but my thoughts in this area are clearly very naive</p>",
        "id": 194600877,
        "sender_full_name": "RalfJ",
        "timestamp": 1587307266
    },
    {
        "content": "<p>also I forgot about running 32bit programs on a 64bit host...</p>",
        "id": 194600881,
        "sender_full_name": "RalfJ",
        "timestamp": 1587307275
    },
    {
        "content": "<p>That's one case; another is booting a 64-bit OS on 32-bit firmware.</p>",
        "id": 194601209,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587307614
    },
    {
        "content": "<p>There will definitely be assembly involved, though.</p>",
        "id": 194601227,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587307653
    },
    {
        "content": "<p>For the actual mode switch.</p>",
        "id": 194601234,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587307667
    },
    {
        "content": "<p>Entering 64-bit mode requires page tables, and I certainly don't want to construct page tables in assembly. I would rather do that in Rust...</p>",
        "id": 194601323,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587307769
    },
    {
        "content": "<p>But at that point I think those might just be separate Rust programs. One compiled as 32-bit and one compiled as 64-bit.</p>",
        "id": 194601384,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1587307827
    },
    {
        "content": "<p>@RalfJ Hmm... that's good to know.</p>\n<p>I am aware of a lot of ongoing work about verifying kernels, file systems, secure enclaves, hypervisors, and hardware (in fact, most recent SOSPs and OSDIs have had at least one track about this). I know they are different problems from specifying an abstract machine (like for a PL), but it seems plausible that work in those areas could be used to inspire an abstract machine specification.  Here is one example of such work: <a href=\"https://dl.acm.org/doi/10.1145/3132747.3132782\" title=\"https://dl.acm.org/doi/10.1145/3132747.3132782\">https://dl.acm.org/doi/10.1145/3132747.3132782</a>. It comes to mind because it talks a bit about some of the crazy things they have to deal with when modeling hardware, and it also shows how they make their proofs scale.</p>\n<blockquote>\n<p>But at that point I think those might just be separate Rust programs. One compiled as 32-bit and one compiled as 64-bit.</p>\n</blockquote>\n<p>Actually, this is how I have tried to deal with it (e.g. context-switching). I've tried to set things up so that at the point where weird things happen, it should be \"equivalent\" to a program ending and another starting. Of course, I don't know if I'm doing it right, which is what prompted my question...</p>",
        "id": 194611661,
        "sender_full_name": "mark-i-m",
        "timestamp": 1587321148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194549281\" title=\"#narrow/stream/213817-t-lang/topic/Unsafe.20and.20UB/near/194549281\">said</a>:</p>\n<blockquote>\n<p>I'm against extending <code>unsafe</code> beyond \"you may create UB\". That's how we ended up with things like <code>AssertUnwindSafe</code> which I feel is a huge API wart.</p>\n</blockquote>\n<p><del>I don't think this is a good example -- there is no unsafe required to use that API.</del> I see <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> made this point already, sorry.</p>",
        "id": 194725321,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587412907
    }
]