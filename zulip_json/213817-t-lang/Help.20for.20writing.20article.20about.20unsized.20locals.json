[
    {
        "content": "<p>Hello rust-lang! I'm currently working on an article summarizing the current state of unsized locals in Rust (eg RFC 1909 and RFC 2884). Would anybody who has done compiler work related to these features be willing to read my draft and check there aren't any gross mistakes?</p>",
        "id": 272802758,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645536902
    },
    {
        "content": "<p>Thanks in advance :)</p>",
        "id": 272802775,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645536911
    },
    {
        "content": "<p>The current draft is here: <a href=\"https://github.com/PoignardAzur/poignardazur.github.io/blob/898fe4fdd13aca5ab9a9e04ac69461d49261a3c6/drafts/rust-design-unsized-vars-returns.md\">https://github.com/PoignardAzur/poignardazur.github.io/blob/898fe4fdd13aca5ab9a9e04ac69461d49261a3c6/drafts/rust-design-unsized-vars-returns.md</a></p>",
        "id": 272803028,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645537040
    },
    {
        "content": "<blockquote>\n<p>Unsized locals have one major use case: passing unsized values to functions and returning unsized values, including trait objects. </p>\n</blockquote>\n<p>Passing unsized valued as arguments has been split into a separate feature. Unsized locals require alloca support from the codegen backend (which eg cranelift doesn't have), but unsized arguments don't as for them a pointer is passed without allocating anything on the stack.</p>",
        "id": 272803652,
        "sender_full_name": "bjorn3",
        "timestamp": 1645537325
    },
    {
        "content": "<p>Oh, right, I forgot about that.</p>",
        "id": 272806235,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645538505
    },
    {
        "content": "<p>But that feature is still under the tracking issue for RFC 1909, right?</p>",
        "id": 272806381,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645538579
    },
    {
        "content": "<h3><em>Quid</em> of <code>&amp;own</code> references</h3>\n<p><code>unsized_locals</code> still seems quite magical to me; while <code>alloca</code> does indeed require backend magic, there is a significant amount of <code>unsized_locals</code>, such as <code>unsized_fn_params</code> already, which can be tackled without it. Without <code>alloca</code>, the key abstraction for the mentioned features are <strong><code>&amp;own</code> references</strong>.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">call</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">())</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Incidentally &amp;own references also allow their own nifty things</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Such as a <code>ManualDrop</code> trait.</p>\n<p>For starters, let's consider such a design but without <code>&amp;own</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(ManualDropFields)]</span><span class=\"w\"> </span><span class=\"c1\">// type Fields = (F, );</span>\n<span class=\"k\">struct</span> <span class=\"nc\">ScopeGuard</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">ManualDrop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">manual_drop</span><span class=\"p\">((</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">)</span>: <span class=\"nc\">Foo</span>::<span class=\"n\">Fields</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// Neither `unsafe`, nor an unnecessary `Option` discriminant!</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cm\">/* Magic: dropping a `Foo` converts it into its raw fields, and calls `manual_drop` */</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But this has the problem of involving extra moving (<em>e.g.</em>, what happens if a field is not <code>Sized</code>? Or if <code>Pin</code>ning is involved?). And at that point we need <strong>owning indirection</strong>, but <strong>not necessarily heap-allocated</strong> —on the contrary!— Enter <code>&amp;own</code> references:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// type Fields&lt;'drop&gt; = (&amp;'drop own F, );</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">ManualDrop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">manual_drop</span><span class=\"p\">((</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">)</span>: <span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"nb\">_</span><span class=\"w\"> </span><span class=\"n\">own</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// Neither `unsafe`, nor an unnecessary `Option` discriminant!</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cm\">/* Magic: dropping a `Foo` generates `&amp;own` handles to each of its fields —in place!— and then calls `manual_drop` */</span><span class=\"w\"></span>\n</code></pre></div>\n</div></div>\n<p>With them, taking <code>unsized_fn_params</code> is as simple as taking <code>&amp;'_ own</code> parameters to them.</p>\n<p>That's it.</p>\n<p>That simple.</p>\n<p>No magic ABI dance, no complex stack explanation with diagrams, compatibility with FFI and any <code>extern \"ABI\"</code> thanks to it being API-based.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">call_me_maybe</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">maybe</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">maybe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// else `drop(f)`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Also, no wondering / pondering about the semantics of <code>let g = f;</code> : by virtue of being a reference, the \"move the pointer\" semantics would be clear (especially meaningful then the <code>!Sized</code> type would be a <code>[u8]</code> with a huge instance behind it), which thus obviously allows to write \"middleware\" / middle-layer functions very easily:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">middlelayer</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Regarding <code>dyn</code>-safety, we <em>could</em> then have the language magically support <code>self: Self</code> receivers by implicitly writing a <code>&amp;own self</code>-based shim, and having the <code>dyn Trait</code>s use that. But until then, users could write it themselves, or with a proc-macro. That's the beauty of a non magic core, to begin with.</p>\n<p>This would be a more Rusty / less LLVM-y way of describing things (API-based implementation, rather than ABI-based), and something that would therefore generalize to giving more fine-grained control to callers and so on:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>The ABI under the API control even for existentials</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<ul>\n<li>Helper notation: since <code>impl</code>'s quantification (existential <em>vs.</em> universal) is position dependent, and the following will explore designs that require existentials in argument position, I'll be using the alternative syntax that the <code>impl Trait</code> RFCs suggested: <code>any Trait</code> for an universal one, and <code>some Trait</code> for an existential one.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">some</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* potentially huge */</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_captured</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">env</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// …</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">goo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">some</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// is the *potentially huge* `foo()` value unnecessarily memcpy-ed here?</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>could become:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">                                               </span><span class=\"c1\">// or `dyn`</span>\n<span class=\"w\">                                               </span><span class=\"c1\">// vvvv</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">storage</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"p\">))</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">storage</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Slot</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">storage</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* … */</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">storage</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_captured</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">env</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// …</span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                                               </span><span class=\"c1\">// or `dyn`</span>\n<span class=\"w\">                                               </span><span class=\"c1\">// vvvv</span>\n<span class=\"k\">fn</span> <span class=\"nf\">goo</span><span class=\"p\">(</span><span class=\"n\">storage</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"p\">))</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">own</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">storage</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// move the small pointer</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">// move the small pointer.</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n</div></div>\n<p>It's easy to see from here how we could even start dealing with some cases of <code>-&gt; dyn</code> in return position, by relying on an <code>&amp;'_ mut (some Storage)</code> existential parameter, with which a <code>-&gt; &amp;_ own dyn</code> would \"connect\".</p>\n<ul>\n<li>(Related to this, <code>with</code> contexts could even alleviate the notation of this parameter).</li>\n</ul>\n<hr>\n<p>Finally, in order to handle <code>dyn</code> safety in this case, and/or re-connect with allocators, a <code>&amp;'frame own T</code>, even for <code>T : ?Sized</code>, could be moved into an allocation by virtue of using <code>Layout::for_value</code> and a manual bitwise move (granted, a technically unnecessary one with full placement new, but I'm confident we'd be able to incrementally improve that aspect afterwards).</p>\n<hr>\n<p>FWIW, most of these things can be implemented in third-party code, and <a href=\"https://docs.rs/stackbox\">have been</a>, but the issue there is that the lifetime of temporaries is a huge hurdle to the ergonomics. With a tiny bit of <code>lang</code> magic, that aspect could easily be soothed, leading to all these powerful abstractions at a very meager implementation cost in the compiler (smaller than special-casing non-<code>Sized</code> values in all the situations that require it).</p>",
        "id": 272810683,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645540465
    },
    {
        "content": "<p>Note that I'm not against the <code>unsized_locals</code> sugar, or the power of non-<code>unsafe</code> <code>alloca</code> (tbh, I've heard in several occasions that <code>alloca</code> is evil / dangerous, so I'm not explicitly for it either; but since I don't know the actual pitfalls of <code>alloca</code> myself, I can't be against it either).<br>\nIt's just that the less magic the language features are, the better, so I do strongly believe the core of this functionality ought to be built atop <code>&amp;own</code> references, and only feature the sugar after that's done / from there.</p>\n<p>All that to say, that if you are writing a blog post about the features, it would be very nice if the tangential topic of <code>&amp;own</code> references could be mentioned as well, <span class=\"user-mention\" data-user-id=\"263609\">@Olivier FAURE</span>, to make more people aware of that pattern <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 272810887,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645540552
    },
    {
        "content": "<p>I am against <code>alloca</code>.<br>\n<code>alloca</code> is a horrible mess that needs to be yeeted off the tallest cliff one can find. <br>\n(Kinda sidetracked from writing the article, though)</p>",
        "id": 272812878,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645541429
    },
    {
        "content": "<p>I'm not a fan of alloca in C, due to various potential hazards, but I'm hopeful that Rust can address those and produce something nicely usable and safe.</p>",
        "id": 272815722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645542610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/272815722\">said</a>:</p>\n<blockquote>\n<p>I'm not a fan of alloca in C, due to various potential hazards, but I'm hopeful that Rust can address those and produce something nicely usable and safe.</p>\n</blockquote>\n<p>Heh.</p>",
        "id": 272818921,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645543880
    },
    {
        "content": "<p><code>&amp;own</code> references and <code>unsized_fn_params</code> are effectively equivalent. Any value in the rust abi not passed in registers gets turned into what is effectively an <code>&amp;own</code> reference.</p>",
        "id": 272820892,
        "sender_full_name": "bjorn3",
        "timestamp": 1645544640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Has there been recent progress (recent being \"in the last 12 months or so\") on <code>unsized_fn_params</code> ? Looking at the code, it sounds like the feature hasn't been modified since it was added.</p>",
        "id": 272824957,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645546121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> That's interesting, but right now I'm trying to summarize existing work, not write a whole new RFC. I don't really want to get into a debate of whether move references would be possible and/or a substitute for unsized fn parameters. (and it would be a pretty long debate, really)</p>",
        "id": 272825541,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645546330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/272824957\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> Has there been recent progress (recent being \"in the last 12 months or so\") on <code>unsized_fn_params</code> ? Looking at the code, it sounds like the feature hasn't been modified since it was added.</p>\n</blockquote>\n<p>Not that I am aware of. I don't think it has any bugs. I think it is mostly blocked on a decision if it should be stabilized.</p>",
        "id": 272827334,
        "sender_full_name": "bjorn3",
        "timestamp": 1645546960
    },
    {
        "content": "<p>Makes sense</p>",
        "id": 272828583,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645547404
    },
    {
        "content": "<p>FWIW, I had been pondering things like <code>&amp;own</code> as a possible way around things like <a href=\"https://github.com/rust-lang/rust/issues/91521\">https://github.com/rust-lang/rust/issues/91521</a> -- I don't know if it's worth adding them overall, but I think there are some interesting avoiding-copying things that they could help, especially if they could be signature-invisible.</p>",
        "id": 272843507,
        "sender_full_name": "scottmcm",
        "timestamp": 1645553292
    },
    {
        "content": "<p><em>sigh</em> I guess I should add a section about those, then.</p>",
        "id": 272843894,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645553506
    },
    {
        "content": "<p>That one could be fixed using a less naive handling of temporaries for calls. Currently the call turns into <code>_2 = move _1; _0 = bar(move _2) -&gt; bb1;</code>, however as <code>_0</code> and <code>_1</code> don't alias (at least if we say that the return place and argument places of a call must never alias as is currently true), it could instead be lowered directly as <code>_0 = bar(move _1) -&gt; bb1</code> which would turn into a <code>jmp bar</code> without anything other instructions at assembly level with even basic optimizations. This is really a problem of how calls are lowered in MIR, not an intrinsic problem needing a new language feature to solve.</p>",
        "id": 272844946,
        "sender_full_name": "bjorn3",
        "timestamp": 1645553929
    },
    {
        "content": "<p>Well, article is up: <a href=\"https://poignardazur.github.io/2022/02/23/rust-unsized-vars-analysis/\">https://poignardazur.github.io/2022/02/23/rust-unsized-vars-analysis/</a></p>",
        "id": 272943347,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645620493
    },
    {
        "content": "<p>So while they are very much not the same thing, I kind of would like to see a \"bounded alloca\" that essentially allows returning <code>[T; M] where M &lt; N</code> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span></p>",
        "id": 273005955,
        "sender_full_name": "Jubilee",
        "timestamp": 1645647589
    },
    {
        "content": "<p>Where N is statically known but M may be decided at runtime.</p>",
        "id": 273006074,
        "sender_full_name": "Jubilee",
        "timestamp": 1645647631
    },
    {
        "content": "<p>is there anything beyond a nice API that we gain from that over <code>ArrayVec</code>?</p>",
        "id": 273006415,
        "sender_full_name": "oli",
        "timestamp": 1645647798
    },
    {
        "content": "<p>The problem arises when N is potentially very high, I think, and so you are trying to make it better than \"always expand the stack by 16KiB.\"</p>",
        "id": 273006947,
        "sender_full_name": "Jubilee",
        "timestamp": 1645648064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273006415\">said</a>:</p>\n<blockquote>\n<p>is there anything beyond a nice API that we gain from that over <code>ArrayVec</code>?</p>\n</blockquote>\n<p>Some performance. In practice I've saw some benefits from <a href=\"https://crates.io/crates/alloca\">https://crates.io/crates/alloca</a> over a big ArrayVec, which includes the cost of a dynamic call.</p>\n<p>I don't know if I think it's worth it though -- it will be very confusing for new users if the direct form of [T] is the one that they almost should never use (and instead they should use <code>&amp;[T]</code>, <code>&amp;mut [T]</code>, <code>Box&lt;[T]&gt;</code>, or <code>Vec&lt;T&gt;</code>).</p>",
        "id": 273010059,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645649661
    },
    {
        "content": "<p>Yeah I don't have a firm claim on whether this is ultimately \"worth it\" per se, just expressing what nice to haves might look like. And syntactically I think it would have to look more like <code>[T; dyn N]</code>, yes.</p>",
        "id": 273010360,
        "sender_full_name": "Jubilee",
        "timestamp": 1645649831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273006947\">said</a>:</p>\n<blockquote>\n<p>The problem arises when N is potentially very high, I think, and so you are trying to make it better than \"always expand the stack by 16KiB.\"</p>\n</blockquote>\n<p>Does it do that for uninit arrays too?</p>",
        "id": 273011102,
        "sender_full_name": "The 8472",
        "timestamp": 1645650171
    },
    {
        "content": "<p>It should as the array may be initialized later in which case the stack space must be allocated.</p>",
        "id": 273011376,
        "sender_full_name": "bjorn3",
        "timestamp": 1645650309
    },
    {
        "content": "<p>Expanding the stack isn't too bad performance-wise, I think, as long as you're not initializing anything.</p>",
        "id": 273098017,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645713872
    },
    {
        "content": "<p>Until you get stack overflow</p>",
        "id": 273098047,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645713888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273098047\">said</a>:</p>\n<blockquote>\n<p>Until you get stack overflow</p>\n</blockquote>\n<p>as long as you're not initializing <strong>anything</strong>, yes.<br>\nI am talking about situations where you wind up partially initializing some fragment of 64KiB.</p>",
        "id": 273122982,
        "sender_full_name": "Jubilee",
        "timestamp": 1645724140
    },
    {
        "content": "<p>\"why did that number jump?\" because I named the actual limit for the datatype in question I am thinking of.</p>",
        "id": 273123139,
        "sender_full_name": "Jubilee",
        "timestamp": 1645724212
    },
    {
        "content": "<blockquote>\n<p>I am talking about situations where you wind up partially initializing some fragment of 64KiB.</p>\n</blockquote>\n<p>I might be missing something, but I'd expect that partially initializing, say, 10 bytes of a 64KiB array isn't particularly expensive? AFAIK, allocating lots of unused stack space doesn't cost anything (except for increased risks of stack overflow). It's not like uninitialized stack memory takes up CPU cache space.</p>",
        "id": 273401409,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1645965397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/213817-t-lang/topic/Help.20for.20writing.20article.20about.20unsized.20locals/near/273401409\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I am talking about situations where you wind up partially initializing some fragment of 64KiB.</p>\n</blockquote>\n<p>I might be missing something, but I'd expect that partially initializing, say, 10 bytes of a 64KiB array isn't particularly expensive? AFAIK, allocating lots of unused stack space doesn't cost anything (except for increased risks of stack overflow). It's not like uninitialized stack memory takes up CPU cache space.</p>\n</blockquote>\n<p>sure?<br>\nuntil you move it. Then you either have to know its size via dynamic constraints orrrr you have to move 64KiB around.</p>",
        "id": 273582090,
        "sender_full_name": "Jubilee",
        "timestamp": 1646100423
    },
    {
        "content": "<p>Specifically I am thinking of a case where the maximum value is so extremely high like that, and also you want to handle <strong>multiple</strong> of them at the same time. :D</p>",
        "id": 273583203,
        "sender_full_name": "Jubilee",
        "timestamp": 1646101673
    }
]