[
    {
        "content": "<p>From <a href=\"https://old.reddit.com/r/rust/comments/ixqzkf/are_there_any_gotchas_to_converting_t_into_t_1/g6ch6el/?context=10000\">Reddit</a>:</p>\n<blockquote>\n<p>This isn't relevant. There isn't a stated guarantee on how [T;N] makes its &amp;Ts. It could allocate space for a T on the heap, shuffle the fields of the correct element into that space, and return a pointer -- leaking the memory. Absurd? Doesn't matter. Doesn't even matter that I could come up with this example. It only matters that it's not stated.</p>\n</blockquote>\n<p>Do we have any guarantees about indexing into arrays and slices like this? And if not, is there a reason we can't/shouldn't?</p>",
        "id": 211078640,
        "sender_full_name": "isHavvy",
        "timestamp": 1600908184
    },
    {
        "content": "<p>We do, I think. I'm not sure <em>where</em> but I would expect that this is something you can definitely rely on.</p>",
        "id": 211078850,
        "sender_full_name": "simulacrum",
        "timestamp": 1600908378
    },
    {
        "content": "<p>The primitive slice docs seem clear to me</p>",
        "id": 211085687,
        "sender_full_name": "cuviper",
        "timestamp": 1600916696
    },
    {
        "content": "<blockquote>\n<p>A dynamically-sized view into a contiguous sequence, [T]. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</p>\n</blockquote>",
        "id": 211085690,
        "sender_full_name": "cuviper",
        "timestamp": 1600916701
    },
    {
        "content": "<p>Oh, is that specifically about arrays? And they suppose that forming a slice could be a leaked heap allocation? Sheesh...</p>",
        "id": 211085875,
        "sender_full_name": "cuviper",
        "timestamp": 1600916927
    },
    {
        "content": "<p>Well, they're not wrong though, that's just so wild no one bothers to say \"we don't do that\"</p>",
        "id": 211085888,
        "sender_full_name": "Lokathor",
        "timestamp": 1600916955
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/reference/types/array.html\">https://doc.rust-lang.org/reference/types/array.html</a></p>",
        "id": 211085981,
        "sender_full_name": "cuviper",
        "timestamp": 1600917087
    },
    {
        "content": "<p>Yeah, nothing there <em>says</em> that the layout of the T values within an array must match the layout of the T values outside of the array.</p>",
        "id": 211086219,
        "sender_full_name": "Lokathor",
        "timestamp": 1600917374
    },
    {
        "content": "<p>It's just \"obviously\" harder to do anything else</p>",
        "id": 211086407,
        "sender_full_name": "cuviper",
        "timestamp": 1600917669
    },
    {
        "content": "<p>Given things like <code>Cell</code>, the leak idea wouldn't even work, because there's no opportunity to copy updates back to your funky array layout</p>",
        "id": 211086491,
        "sender_full_name": "cuviper",
        "timestamp": 1600917794
    },
    {
        "content": "<p>Same for just <code>&amp;mut T</code>, actually</p>",
        "id": 211086502,
        "sender_full_name": "cuviper",
        "timestamp": 1600917814
    },
    {
        "content": "<p>Meh</p>",
        "id": 211086506,
        "sender_full_name": "cuviper",
        "timestamp": 1600917827
    },
    {
        "content": "<p>I mean, you can do it in no-std no-alloc, so it's not allocate-plus-leak.</p>",
        "id": 211087906,
        "sender_full_name": "scottmcm",
        "timestamp": 1600919720
    },
    {
        "content": "<p>This is reminiscent of the horror of C++ <code>vector&lt;bool&gt;</code></p>",
        "id": 211088457,
        "sender_full_name": "cuviper",
        "timestamp": 1600920454
    },
    {
        "content": "<p>FWIW, I think this belongs to Unsafe Code Guidelines. Indeed, the only way the distinction really matters is with <code>unsafe</code> code. If we had to add specifications about layout, they could fit there: <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/arrays-and-slices.html\">https://rust-lang.github.io/unsafe-code-guidelines/layout/arrays-and-slices.html</a></p>",
        "id": 211108819,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1600940551
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 211223091,
        "sender_full_name": "isHavvy",
        "timestamp": 1601015892
    },
    {
        "content": "<p>Cc <span class=\"user-group-mention\" data-user-group-id=\"810\">@WG-unsafe-code-guidelines</span></p>",
        "id": 211227948,
        "sender_full_name": "RalfJ",
        "timestamp": 1601020199
    },
    {
        "content": "<p>as far as I am concerned, <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/arrays-and-slices.html\">https://rust-lang.github.io/unsafe-code-guidelines/layout/arrays-and-slices.html</a> already says that the elements of a <code>[T]</code> are laid out like <code>T</code></p>",
        "id": 211228004,
        "sender_full_name": "RalfJ",
        "timestamp": 1601020215
    },
    {
        "content": "<blockquote>\n<p>Array types, [T; N], store N values of type T with a constant stride. Here, stride is the distance between each pair of consecutive values within the array.</p>\n</blockquote>",
        "id": 211228012,
        "sender_full_name": "RalfJ",
        "timestamp": 1601020223
    },
    {
        "content": "<p>I guess it could be more explicit and use the term \"layout\" instead of \"type T\", is that the question?</p>",
        "id": 211228026,
        "sender_full_name": "RalfJ",
        "timestamp": 1601020243
    },
    {
        "content": "<p>It's the location of the reference generated by indexing into the array. That e.g. <code>&amp;array[2]</code> actually gives you an element from inside the array and not e.g. leaking a new value into existence.</p>",
        "id": 211233879,
        "sender_full_name": "isHavvy",
        "timestamp": 1601024837
    },
    {
        "content": "<p>would it work to standardize that if <code>array: [T; N]</code> then <code>&amp;array[2]</code> is identical to <code>unsafe { (&amp;array as *const [T; N] as *const T).offset(2) as &amp;T }</code>?</p>",
        "id": 211248395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601035246
    },
    {
        "content": "<p>it would be better to do that on a formal syntax but the idea here is to indicate that it is literally the same as a pointer offset operation</p>",
        "id": 211248534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601035346
    },
    {
        "content": "<p>The UCG reference doesn't seem to describe primitive operations at all, only data layout. That should be another chapter of the book at least</p>",
        "id": 211248890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601035559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296643\">isHavvy</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211233879\">said</a>:</p>\n<blockquote>\n<p>It's the location of the reference generated by indexing into the array. That e.g. <code>&amp;array[2]</code> actually gives you an element from inside the array and not e.g. leaking a new value into existence.</p>\n</blockquote>\n<p>I don't think there woukld be opposition to guarantee that <code>&amp;array[x]</code> results in the same pointer as <code>&amp;*array.as_ptr().add(x)</code>. I am not sure what would be a good place to document this though... probably the slice type docs?</p>",
        "id": 211353405,
        "sender_full_name": "RalfJ",
        "timestamp": 1601115596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211248890\">said</a>:</p>\n<blockquote>\n<p>The UCG reference doesn't seem to describe primitive operations at all, only data layout. That should be another chapter of the book at least</p>\n</blockquote>\n<p>UCG is mostly concerned with language-level question. this here is really a libs question.</p>",
        "id": 211353455,
        "sender_full_name": "RalfJ",
        "timestamp": 1601115625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> The behavior of primitive operations on primitive types seems very much like a language question. It is possible that <code>&amp;array[2]</code> gets desugared into a library call like <code>array.index(2)</code> but I would assume that this bottoms out to an intrinsic pretty quickly, and the behavior of that intrinsic is what I'm talking about</p>",
        "id": 211360330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127283
    },
    {
        "content": "<p>I come from the land where languages are defined by a syntax and semantics. On the semantics side, UCG covers the definition of the abstract machine configuration (aka data layout), but not the operational semantics (aka primops)</p>",
        "id": 211360413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127413
    },
    {
        "content": "<p>I cannot even think of another way to implementing the primitive operation that even makes the slightest sense^^ but, fair</p>",
        "id": 211360524,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127559
    },
    {
        "content": "<p>defining MIR operational semantics is something UCG and/or me want to get to eventually. however, most questions are fairly obvious and the ones that are not usually have open questions^^</p>",
        "id": 211360589,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127609
    },
    {
        "content": "<p>I think a good near term goal is to formally state all the obvious and uncontroversial things</p>",
        "id": 211360616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127664
    },
    {
        "content": "<p>(I see defining MIR or simplified \"pseudo-MIR\" semantics as the best avenue for defining Rust semantics; we then can separately define how surface Rust translates to pseudo-MIR. that makes the entire thing much more manageable. this is a common approach for langauges with a large syntactic surface.)</p>",
        "id": 211360617,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211360616\">said</a>:</p>\n<blockquote>\n<p>I think a good near term goal is to formally state all the obvious and uncontroversial things</p>\n</blockquote>\n<p>yeah, I have wanted to start doing that several times. and then each time something more pressing came up.^^</p>",
        "id": 211360631,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127693
    },
    {
        "content": "<p>I have some ideas for how I want things to be structured and phrased, but so far they are just rough ideas in my head</p>",
        "id": 211360642,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127717
    },
    {
        "content": "<p>The post that started this thread seems to be exactly because we didn't state something that was obvious</p>",
        "id": 211360679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127726
    },
    {
        "content": "<p>in particular, different people disagree on what \"formally\" means.^^ for me, it means \"mechanized in Coq\". ;)</p>",
        "id": 211360689,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211360679\">said</a>:</p>\n<blockquote>\n<p>The post that started this thread seems to be exactly because we didn't state something that was obvious</p>\n</blockquote>\n<p>yes. this is the first time such a question came up, compared to many many questions about data layout and validity (the two topics UCG discussed so far, before things basically stalled mid-way through the validity discussions)</p>",
        "id": 211360708,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127795
    },
    {
        "content": "<p>I am on board with that, but actually I think it's not a replacement for the prose spec</p>",
        "id": 211360719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127800
    },
    {
        "content": "<p>These are absolutely relevant questions, it's just a matter of priorization that their answers have not been written down yet</p>",
        "id": 211360725,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127823
    },
    {
        "content": "<p>I'm hoping that the UCG document eventually evolves to that prose spec</p>",
        "id": 211360790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211360719\">said</a>:</p>\n<blockquote>\n<p>I am on board with that, but actually I think it's not a replacement for the prose spec</p>\n</blockquote>\n<p>agreed. though I am thinking of writing a spec in rust instead of prose, as prose tends to be wordy and imprecise.</p>",
        "id": 211360801,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127867
    },
    {
        "content": "<p>ideally with a coq formalization in the back <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 211360805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127871
    },
    {
        "content": "<p>you can see a taste of that in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md</a></p>",
        "id": 211360818,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127892
    },
    {
        "content": "<p>(that still has more prose than I'd like, but you can see how I'd like to use Rust code to make things more precise but still readable without mathematical background)</p>",
        "id": 211360835,
        "sender_full_name": "RalfJ",
        "timestamp": 1601127914
    },
    {
        "content": "<p>yeah that looks nice</p>",
        "id": 211360882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601127971
    },
    {
        "content": "<p>What is your view on specs a la the C/C++ spec?</p>",
        "id": 211360896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601128012
    },
    {
        "content": "<p>i.e. language lawyer style</p>",
        "id": 211360898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601128023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211360801\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211360719\">said</a>:</p>\n<blockquote>\n<p>I am on board with that, but actually I think it's not a replacement for the prose spec</p>\n</blockquote>\n<p>agreed. though I am thinking of writing a spec in rust instead of prose, as prose tends to be wordy and imprecise.</p>\n</blockquote>\n<p>If that implies having the necessary means of writing self-tests in Rust that can be used to test alternative implementations then that would be very beneficial. I consider C++ spec particularly bad in this regard. While, yes, there is a sort of logic that you language lawyer, a very large amount of constraints are simply untestableâ€”not necessarily undecidable but often requiring whole program analysis.</p>",
        "id": 211361107,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601128299
    },
    {
        "content": "<p>I don't think the rust code snippets in Ralf's example are meant to compile</p>",
        "id": 211361226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601128447
    },
    {
        "content": "<p>Isn't unit testing the spec one of the possible uses of Miri?</p>",
        "id": 211361307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601128603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211360896\">said</a>:</p>\n<blockquote>\n<p>What is your view on specs a la the C/C++ spec?</p>\n</blockquote>\n<p>I am not a big fan. (a) I find it very hard to find anything, and (b) they leave many of the interesting questions open. the latter is mostly because these specs are <em>axiomatic</em>, not operational.</p>",
        "id": 211364122,
        "sender_full_name": "RalfJ",
        "timestamp": 1601132584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211361307\">said</a>:</p>\n<blockquote>\n<p>Isn't unit testing the spec one of the possible uses of Miri?</p>\n</blockquote>\n<p>Miri is meant to basically be a compiling and running implementation of the spec -- with some concessions to performance</p>",
        "id": 211364154,
        "sender_full_name": "RalfJ",
        "timestamp": 1601132638
    },
    {
        "content": "<p>however, that seems only loosely related to how testable the spec is? any spec with UB is hard to properly test for in a UB-exploiting compiler.</p>",
        "id": 211364416,
        "sender_full_name": "RalfJ",
        "timestamp": 1601132904
    },
    {
        "content": "<p>for unit testing the spec though, you don't need a really good compiler, just one that detects UB in small examples</p>",
        "id": 211364791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601133453
    },
    {
        "content": "<p>so miri would work fine for that</p>",
        "id": 211364800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601133477
    },
    {
        "content": "<p>you mean detecting spec bugs? sure -- but that requires the spec to be in sync with miri, which is a strong assumption</p>",
        "id": 211367715,
        "sender_full_name": "RalfJ",
        "timestamp": 1601137248
    },
    {
        "content": "<p>miri is still pretty hard to read I think, otehrwise I'd just propose it as the spec ;)</p>",
        "id": 211367718,
        "sender_full_name": "RalfJ",
        "timestamp": 1601137259
    },
    {
        "content": "<blockquote>\n<p>but that requires the spec to be in sync with miri, which is a strong assumption</p>\n</blockquote>\n<p>Is it? Right now I think miri is the closest thing we have to an actual spec</p>",
        "id": 211367958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601137632
    },
    {
        "content": "<p>sure, but once we have \"two specs\" (the markdown file with idealized rust and the actual thing in miri), they will inadvertantly diverge</p>",
        "id": 211370587,
        "sender_full_name": "RalfJ",
        "timestamp": 1601141374
    },
    {
        "content": "<p>also miri does a few things different than the spec for perf reasons</p>",
        "id": 211370590,
        "sender_full_name": "RalfJ",
        "timestamp": 1601141383
    },
    {
        "content": "<p>How essential are those compromises? Is it possible to have a \"reference implementation\" that is like miri but without the perf compromises, or are we talking impossibly slow? I think there is some value in using executable unit tests as a more programmer friendly way of explaining the technical details of a spec without the scary math or legalese</p>",
        "id": 211372815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601144742
    },
    {
        "content": "<p>cg_clif aborts on a few cases of UB instead of exploiting the UB. It by far doesn't check the majority of the UB things.</p>",
        "id": 211373020,
        "sender_full_name": "bjorn3",
        "timestamp": 1601145011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211372815\">said</a>:</p>\n<blockquote>\n<p>How essential are those compromises? Is it possible to have a \"reference implementation\" that is like miri but without the perf compromises, or are we talking impossibly slow? I think there is some value in using executable unit tests as a more programmer friendly way of explaining the technical details of a spec without the scary math or legalese</p>\n</blockquote>\n<p>I think it would probably still fast enough for tiny examples to run in &lt;1min</p>",
        "id": 211406559,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197507
    },
    {
        "content": "<p>but the problem is, to make Rust code actually run reduces readability a bit -- Rust's insistence on making the programmer care about pointer indirections and clones gets in the way here</p>",
        "id": 211406570,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197553
    },
    {
        "content": "<p>so I was aiming for a kind of pseudo-Rust -- some kind of ML with a Rusty syntax -- instead of something that can actually run</p>",
        "id": 211406611,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197577
    },
    {
        "content": "<p>oh and of course there's the question of how to handle non-determinism</p>",
        "id": 211406619,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197599
    },
    {
        "content": "<p>even the document I linked above already has that, saying something like \"pick a representation for the given abstract value\"</p>",
        "id": 211406635,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197643
    },
    {
        "content": "<p>I deliberately wrote the value relation as a <em>relation</em>, not a function, as I felt that makes it easier to understand... but this means it is not fully operational any more</p>",
        "id": 211406718,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197767
    },
    {
        "content": "<p>operationally however you need two functions, one that converts a byte string to an <code>Option&lt;Value&gt;</code> (computing the abstract value represented by this byte string, if any) and one that converts a value to a <code>impl Iterator&lt;Item=Bytes&gt;</code> (computing the possible ways this could be represented) and they need to be consistent with each other. such redundancy is necessary for a proper interpreter but IMO should be avoided in the spec.</p>",
        "id": 211406789,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197881
    },
    {
        "content": "<p>we should of course take care to define the relation in a way that these two functions are both computable</p>",
        "id": 211406798,
        "sender_full_name": "RalfJ",
        "timestamp": 1601197912
    },
    {
        "content": "<p>Wouldn't a more natural way to represent nondeterminism be a call to a pseudorandom number generator?</p>",
        "id": 211416766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601213486
    },
    {
        "content": "<p>And for representing relations you can use a bool returning function</p>",
        "id": 211416770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601213512
    },
    {
        "content": "<p>Granted, these representations will not help very much for defining a miri-like exhaustive state enumeration without having exponential time complexity, but as long as the value of the code is only to be read and not executed (even if it is nominally executable) this would do the job pretty well, I think</p>",
        "id": 211416942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601213764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211416766\">said</a>:</p>\n<blockquote>\n<p>Wouldn't a more natural way to represent nondeterminism be a call to a pseudorandom number generator?</p>\n</blockquote>\n<p>that does not seem natural at all to me</p>",
        "id": 211417397,
        "sender_full_name": "RalfJ",
        "timestamp": 1601214414
    },
    {
        "content": "<p>in formal methods, <code>X -&gt; list T</code>  is the canonical way to represent a computation with input <code>X</code> that non-deterministically produces one of the values of type <code>T</code> as a result. <code>list T</code> satisfies all the required monadic laws to make this a proper model of computation. Rust just doesn't have good support for this monad.^^</p>\n<p>Also, non-determinism is something very different from randomness, so I am somewhat opposed to try and use one to model the other. these two concepts are already confused by too many people, which constantly annoys me.^^</p>",
        "id": 211417410,
        "sender_full_name": "RalfJ",
        "timestamp": 1601214442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211416770\">said</a>:</p>\n<blockquote>\n<p>And for representing relations you can use a bool returning function</p>\n</blockquote>\n<p>yes but that doesnt make them computable. to write an interpreter we need to compute, given a value, some bytestring that relates to the value, and vice versa.</p>",
        "id": 211417416,
        "sender_full_name": "RalfJ",
        "timestamp": 1601214456
    },
    {
        "content": "<p>I am quite aware that nondeterminism is not randomness, but like it or not this is how most programmers conceptualize it. If you use a sufficiently good random number generator you can even get a completeness result if you run the program long enough</p>",
        "id": 211417720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601214930
    },
    {
        "content": "<p>Perhaps rather than saying it is a random number generator, just use an opaque function called <code>nondeterministic()</code> and gloss it as \"this is a nondeterministic value of the type\"</p>",
        "id": 211417777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601214987
    },
    {
        "content": "<p>and you can implement that function for execution purposes as a random number generator, with comments explaining the limitations of this representation</p>",
        "id": 211417791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215019
    },
    {
        "content": "<p>I would argue that X -&gt; list T is also not correct for nondeterminism because you could be selecting from an infinite advice string. X -&gt; 2^T is more correct</p>",
        "id": 211417877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215134
    },
    {
        "content": "<p>X -&gt; list T is a good way to implement a program that enumerates all possible executions of a nondeterministic model, but the model itself is just a relation on states</p>",
        "id": 211417960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211417720\">said</a>:</p>\n<blockquote>\n<p>I am quite aware that nondeterminism is not randomness, but like it or not this is how most programmers conceptualize it.</p>\n</blockquote>\n<p>I certainly dont like it and will push against anything that perpetuates this misunderstanding^^</p>",
        "id": 211418036,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211417877\">said</a>:</p>\n<blockquote>\n<p>I would argue that X -&gt; list T is also not correct for nondeterminism because you could be selecting from an infinite advice string. X -&gt; 2^T is more correct</p>\n</blockquote>\n<p>I guess I could weasle out of this by saying I meant haskell lists which can be infinite ;)</p>",
        "id": 211418050,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215419
    },
    {
        "content": "<p>in Rust, <code>impl Iterator&lt;Item=T&gt;</code> is probably the closest approximation of that</p>",
        "id": 211418055,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215437
    },
    {
        "content": "<p>Even then, it's imposing an order of events that is not natural</p>",
        "id": 211418056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215441
    },
    {
        "content": "<p>the order is not observable inside the monad though</p>",
        "id": 211418099,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215454
    },
    {
        "content": "<p>ah, well, if you've got a monad then that's fine, but you may as well use a monad for A -&gt; set T then</p>",
        "id": 211418108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215482
    },
    {
        "content": "<p>but I think the important thing is that it looks like straight line code</p>",
        "id": 211418118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215506
    },
    {
        "content": "<p>if you try to literally implement a A -&gt; list T function in rust it will have way too many unnecessary things for reading</p>",
        "id": 211418132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215533
    },
    {
        "content": "<p>without support for general monads, Rust cannot make it look like straight-line code. well maybe with generators we can, but... uh</p>",
        "id": 211418133,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215536
    },
    {
        "content": "<p>and anyway none of this matters because this is still a relation we cannot easily compute with</p>",
        "id": 211418136,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215559
    },
    {
        "content": "<p>Like I said, just have an opaque function</p>",
        "id": 211418174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215565
    },
    {
        "content": "<p>that works perfectly fine in rust</p>",
        "id": 211418177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215574
    },
    {
        "content": "<p>I mean besides being unimplementable, yeah</p>",
        "id": 211418186,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215587
    },
    {
        "content": "<p>but also we have 3 or 4 levels down the rabbit hole at this point</p>",
        "id": 211418192,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215620
    },
    {
        "content": "<p>and you can even turn that into something executable with a whole lot of magic, where your calls to <code>nondeterministic()</code> build a graph behind the scenes and you traverse the graph</p>",
        "id": 211418254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215685
    },
    {
        "content": "<p>(I think you are assuming that everything else is pure)</p>",
        "id": 211418260,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215701
    },
    {
        "content": "<p>specifically for the value relation, none of this is very useful as I think we should have a single relation and there's no computable way to get both forward and backward functions from that</p>",
        "id": 211418263,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418036\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211417720\">said</a>:</p>\n<blockquote>\n<p>I am quite aware that nondeterminism is not randomness, but like it or not this is how most programmers conceptualize it.</p>\n</blockquote>\n<p>I certainly dont like it and will push against anything that perpetuates this misunderstanding^^</p>\n</blockquote>\n<p>what's the difference between the two?</p>",
        "id": 211418264,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1601215724
    },
    {
        "content": "<p>(I'm one of those programmers :P)</p>",
        "id": 211418269,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1601215743
    },
    {
        "content": "<p>Nondeterminism is a set of options, randomness is a set of options with probabilities</p>",
        "id": 211418274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215752
    },
    {
        "content": "<p>so in pseudo-code we can write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">pick_value_such_that</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">rep</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">related</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>but we cannot actually implement this</p>",
        "id": 211418275,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215755
    },
    {
        "content": "<p>and pseudorandomness is a deterministic function that hits many of the options</p>",
        "id": 211418283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418274\">said</a>:</p>\n<blockquote>\n<p>Nondeterminism is a set of options, randomness is a set of options with probabilities</p>\n</blockquote>\n<p>I don't quite follow - is that different from having a set of options each with equal probability?</p>",
        "id": 211418325,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1601215812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418274\">said</a>:</p>\n<blockquote>\n<p>Nondeterminism is a set of options, randomness is a set of options with probabilities</p>\n</blockquote>\n<p>right -- randomness is basically a refinement of nondet. when a system is nondet you just say \"a bunch of different things can happen\", when you say a system is random you assume that there is a particular probabiltiy distribution that governs how often the various things happen. that is a strong assumption.</p>",
        "id": 211418327,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215825
    },
    {
        "content": "<p>randomness is <em>predictable</em></p>",
        "id": 211418332,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1601215860
    },
    {
        "content": "<p>I think we can comment our way around this issue though. Just put lots of warning signs saying \"DON'T REASON ABOUT PROBABILITIES HERE\"</p>",
        "id": 211418345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215896
    },
    {
        "content": "<p>every random system can be turned into a nondet system by forgetting the probabilities; that loses a lot of information about the possible behaviors of the system. but nondet systems cannot always be described as random systems, because there's not always a probability distrubiton for their behavior.</p>",
        "id": 211418346,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418345\">said</a>:</p>\n<blockquote>\n<p>I think we can comment our way around this issue though. Just put lots of warning signs saying \"DON'T REASON ABOUT PROBABILITIES HERE\"</p>\n</blockquote>\n<p>sure we can but I'd rather not do that in a spec^^<br>\nI am fine with just imagining that we are in the nondet monad though, and having a \"pick a value from this set\" or \"pick a value satisfying this predicate\" (predicate = Rust function returning <code>bool</code>)</p>",
        "id": 211418400,
        "sender_full_name": "RalfJ",
        "timestamp": 1601215950
    },
    {
        "content": "<p>At least for things a computer can do, it's always possible to give some probability distribution giving every possible option a nonzero probability</p>",
        "id": 211418403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601215964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418332\">said</a>:</p>\n<blockquote>\n<p>randomness is <em>predictable</em></p>\n</blockquote>\n<p>yeah... that's a funny way to say it as people usually think of randomness as being about not having exact predictions, but you are right. you dont get exact predictions on individual outcomes but you do get increasingly exact predictions on increasingly large sets of outcomes.</p>",
        "id": 211418419,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216010
    },
    {
        "content": "<p>Yeah, from the spec point of view it's just an opaque function. The warning comments are for people who start poking into the framework code that makes the unit tests run and looks at the definition of <code>nondeterminism()</code> and sees something odd</p>",
        "id": 211418421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601216032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418325\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418274\">said</a>:</p>\n<blockquote>\n<p>Nondeterminism is a set of options, randomness is a set of options with probabilities</p>\n</blockquote>\n<p>I don't quite follow - is that different from having a set of options each with equal probability?</p>\n</blockquote>\n<p>yes, very different. a system that whose spec is  \"non-deterministically outputs 0 or 1\" is correctly implemented by a program that does <code>print 0</code>. the same is obviously not true when the spec is \"randomly output 0 or 1 with equal probability\". the \"equal probability\" part puts a very strong constraint on what the system is allowed to do when you execute it many times.</p>",
        "id": 211418473,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216099
    },
    {
        "content": "<p><a href=\"https://dilbert.com/strip/2001-10-25\">https://dilbert.com/strip/2001-10-25</a></p>",
        "id": 211418487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601216131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418421\">said</a>:</p>\n<blockquote>\n<p>Yeah, from the spec point of view it's just an opaque function. The warning comments are for people who start poking into the framework code that makes the unit tests run and looks at the definition of <code>nondeterminism()</code> and sees something odd</p>\n</blockquote>\n<p>I honestly doubt we can have such framework code but this is an experiment worth doing^^</p>",
        "id": 211418489,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216132
    },
    {
        "content": "<p>in particular in my pseudo-code I was going to just ignore the fact that Rust recursive types need to have pointer indirections. I dont want to write <code>Box</code> in our spec definitions ever.</p>",
        "id": 211418540,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216184
    },
    {
        "content": "<p>but this means they cannot be legal Rust types</p>",
        "id": 211418542,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418403\">said</a>:</p>\n<blockquote>\n<p>At least for things a computer can do, it's always possible to give some probability distribution giving every possible option a nonzero probability</p>\n</blockquote>\n<p>we are talking about a spec (and its reference interpreter) though, and in a spec it makes a big difference whether we say \"nondet\" or \"random\". <br>\nwhat you are saying is basically that true nondet does not exist in the real world, and I agree. the real world is a constant source of disappointment for only being able to approximate many of the beautiful things that exist in mathematics. ;)</p>",
        "id": 211418608,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216376
    },
    {
        "content": "<p>(lets skip the discussion whether true randomness exists ;)</p>",
        "id": 211418658,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216452
    },
    {
        "content": "<p>well, we're saying \"nondet\", it says it right there in the function name</p>",
        "id": 211418660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601216461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418660\">said</a>:</p>\n<blockquote>\n<p>well, we're saying \"nondet\", it says it right there in the function name</p>\n</blockquote>\n<p>yeah as I said, I am fine with using such an opaque function in the spec wording</p>",
        "id": 211418668,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216483
    },
    {
        "content": "<p>the point about representability using randomness is only to point out that an implementation of nondet() using rand() is not wrong, in the sense that if the random number generator is perfect then if you run it long enough you will almost surely see all possible behaviors</p>",
        "id": 211418720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601216553
    },
    {
        "content": "<p>but the idealized Rust I have in my head as a spec language has other issues so actually running it will be hard for other reasons -- specifically, notice that in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md</a> I define a recursive enum in a way that would not work in Rust</p>",
        "id": 211418723,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/Guarantee.20references.20from.20indexing.20arrays.20and.20slices.3F/near/211418720\">said</a>:</p>\n<blockquote>\n<p>the point about representability using randomness is only to point out that an implementation of nondet() using rand() is not wrong, in the sense that if the random number generator is perfect then if you run it long enough you will almost surely see all possible behaviors</p>\n</blockquote>\n<p>I agree that this is technically correct, and in fact Miri <a href=\"https://github.com/rust-lang/miri/blob/aa832c1133217a079ae5d9af65dd0b7ad96aca07/src/intptrcast.rs#L95\">already does exactly that</a> (in a rather crude way even).<br>\nSo I think we mostly agree here except on details that are only worth discussing once there's actually something there. ;)</p>",
        "id": 211418734,
        "sender_full_name": "RalfJ",
        "timestamp": 1601216617
    }
]