[
    {
        "content": "<p>Nothing from the mir-interpreter side speaks against just making <code>GlobalAlloc</code> work in CTFE. The only problem we have is that we could end up with <code>const FOO: Vec&lt;i32&gt; = vec![42];</code>. This can either be caught at evaluation time (so PMEs for  associated constants of generic types) or with some system like the one from <a href=\"https://github.com/rust-lang/lang-team/issues/129\">https://github.com/rust-lang/lang-team/issues/129</a>. We could, instead of requiring users to use an attribute, automatically track whether a const fn does heap things, and if it does, prevent its result from being used in the value of a constant.</p>",
        "id": 265842930,
        "sender_full_name": "oli",
        "timestamp": 1640201300
    },
    {
        "content": "<p>without the attribute, convering some code from ArrayVec to Vec would be a breaking change</p>",
        "id": 265842992,
        "sender_full_name": "oli",
        "timestamp": 1640201343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I think it'd be <em>valid</em> to use transient heap and then ultimately return a value usable in a constant.</p>",
        "id": 265843030,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201366
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">transient</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265843127,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201403
    },
    {
        "content": "<p>But I can see how that could get abused. For instance, grab a raw pointer allocated on the pseudo-<code>GlobalAlloc</code>, cast it to a <code>usize</code>, return it. miri can catch that, though.</p>",
        "id": 265843283,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640201512
    },
    {
        "content": "<blockquote>\n<p>, instead of requiring users to use an attribute, automatically track whether a const fn does heap things, and if it does, prevent its result from being used in the value of a constant.</p>\n</blockquote>\n<p>it's not clear to me what \"its result\" means, since afaict this includes the set of all constant values it could modify (including <code>&amp;mut</code> parameters and non-<code>Freeze</code> <code>&amp;</code> parameters)</p>",
        "id": 265845245,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1640202793
    },
    {
        "content": "<p>Given that we already allow types with <code>Drop</code> glue (that may reference heap values) to appear in constants, it seems like some kind of heap reachability analysis on the final value is required? That said, I would also expect <code>const FOO: &amp;Vec&lt;i32&gt; = &amp;vec![42];</code> to <em>work</em>, so there's also some analysis required to determine whether the resulting type is able to mutate the heap data (I think it's enough to require that it's behind an immutable reference without an <code>UnsafeCell</code> along the way to the pointer?)</p>",
        "id": 265847463,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1640203902
    },
    {
        "content": "<p>Yes, the MCP has such an analysis and allows for references to owned types and handles interior mutability while maintaining backwards compatibility's</p>",
        "id": 265855058,
        "sender_full_name": "oli",
        "timestamp": 1640208490
    },
    {
        "content": "<p>just checking for <code>UnsafeCell</code> doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">AtomicBox</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AtomicBox</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">clear</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">AtomicU8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Relaxed</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">V</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">AtomicBox</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265855091,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640208506
    },
    {
        "content": "<p>Yea, we currently prevent that with a dataflowish analysis, but once you can heap allocate, that's out the door</p>",
        "id": 265858021,
        "sender_full_name": "oli",
        "timestamp": 1640210314
    },
    {
        "content": "<p>Though... any <code>const_heap</code> function's return type could pessimistically assume raw pointers and unions contain interior mutability</p>",
        "id": 265858295,
        "sender_full_name": "oli",
        "timestamp": 1640210445
    },
    {
        "content": "<p>If we go with an opt in marker, we can add arbitrary restrictions</p>",
        "id": 265858348,
        "sender_full_name": "oli",
        "timestamp": 1640210469
    },
    {
        "content": "<blockquote>\n<p>I can see how that could get abused. For instance, grab a raw pointer allocated on the pseudo-<code>GlobalAlloc</code>, cast it to a <code>usize</code>, return it. miri can catch that, though.</p>\n</blockquote>\n<p>So you're saying we should do a best effort static check and PME for the edge cases?</p>",
        "id": 265860389,
        "sender_full_name": "oli",
        "timestamp": 1640211494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> Interesting. i think I'd been thinking about <code>const V: &amp;T = &amp;...</code> as roughly equivalent to <code>static S: T = ...; const V: &amp;T = &amp;S;</code>, in which case you need to ban interior mutability via <code>UnsafeCell</code>, but the <code>Atomic...</code> case is fine-ish? But if you're thinking about it as a <code>const</code> whose data is not shared between instances, that doesn't make sense.</p>",
        "id": 265861950,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1640212433
    },
    {
        "content": "<p>One possible answer then is that we could allow allocations to leak into statics, but not into constants? Then the <code>UnsafeCell</code>-related restrictions fall out of existing restrictions on statics, and consts can then only reference the created statics</p>",
        "id": 265862232,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1640212568
    },
    {
        "content": "<p>You can still shoot yourself in the foot if you stick atomics inside, mutate them, and expect them not to change elsewhere, but the semantics would at least be consistent with what you wrote (a <code>static</code> + a <code>const</code> reference to it)</p>",
        "id": 265862271,
        "sender_full_name": "Taylor Cramer",
        "timestamp": 1640212607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/transient.20const.20heap/near/265843127\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">transient</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I believe that <code>const CONST: u32 = transient()</code> would be accepted since <code>u32</code> is <code>Send + Copy</code>. If the heap is accessed (<em>e.g.</em>, <code>#[const_heap]</code> / lack of <code>#[const_not_heap]</code>), then the requirements can be tightened to expect the final <code>const</code> value to be <code>Send</code> and <code>Copy</code>. This solves <em>all</em> of the issues, AFAIK, and doesn't even seem that restrictive? I used to suggest a more convoluted mechanism to allow <code>None</code>s or <code>0</code>-capacity <code>Vec</code>/<code>String</code>s to be yielded as well, but since it didn't seem to get that much traction I'm dropping that idea, now.</p>\n<p>Mainly: I don't find <code>ConstSafe</code> / <code>ConstRefSafe</code> to be that relevant: we'll end up with <code>Copy</code> and <code>Send</code> requirements, <em>and those would be enough</em>: <code>ConstSafe = Copy + Send</code> (and <code>ConstRefSafe</code> would thus just be <code>Sync</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// Ok since String::new isn't #[const_heap]</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">B</span>: <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Not OK because of reasons above</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">leak_new</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">));</span><span class=\"w\"> </span><span class=\"c1\">// Ok because &amp;String is `Copy + Send` (because `String` is `Sync`)</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">D</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">).</span><span class=\"n\">leak</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// Ditto</span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">E</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Would this one work? would const-promotion be applicable?</span>\n</code></pre></div>\n<p>The only remaining question would be the <code>E</code> definition: I suspect that for the sake of consistency, one wouldn't be able <code>&amp;</code>-const-promote non-<code>ConstSafe</code> stuff. But I don't know the intricacies of <code>const</code> promotion well-enough, so I'd love to be proven wrong and have <code>E</code> be usable w/o the <code>C</code> workaround <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 266014630,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640366776
    }
]