[
    {
        "content": "<p>This came up with this StackOverflow question: <a href=\"https://stackoverflow.com/q/71761281/7884305\">https://stackoverflow.com/q/71761281/7884305</a></p>\n<p>Is there any reason we don't allow DSTs as the non-last field of a struct and just reorder the fields, or there as just no need for it?</p>",
        "id": 277976823,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649222439
    },
    {
        "content": "<p>there may be no need for it nowadays. IIRC rust didn't actually have the capability to reorder struct fields until 2017 or so, so as of 1.0 this restriction would have been necessary</p>",
        "id": 278021016,
        "sender_full_name": "bstrie",
        "timestamp": 1649250772
    },
    {
        "content": "<p>I guess this would let you drop the DST before other fields. Any other benefit?</p>",
        "id": 278035407,
        "sender_full_name": "cuviper",
        "timestamp": 1649256832
    },
    {
        "content": "<blockquote>\n<p>I guess this would let you drop the DST before other fields. Any other benefit?</p>\n</blockquote>\n<p>I sometimes order fields or group them to improve readability.</p>",
        "id": 278088101,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649280228
    },
    {
        "content": "<p>I'd like to keep this restriction.<br>\nA restriction of \"must not be reordered relative to any other field\" is either to spec, indicate, and to implement then a restriction of \"shall be at the greatest offset of all fields\".</p>",
        "id": 278099406,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649287263
    },
    {
        "content": "<p>AFAICT this is just about the source order, on disk the DST would still have to be the last field</p>",
        "id": 278105771,
        "sender_full_name": "bstrie",
        "timestamp": 1649292907
    },
    {
        "content": "<p>Yeah, that's the part that I would get to spec, indicate, and implement.</p>",
        "id": 278106293,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649293423
    },
    {
        "content": "<p>It's easier to just have a <code>#fixed_relative_order</code> attribute, then a bunch of special case <code>#place_at_end</code> attributes.</p>",
        "id": 278106363,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649293498
    },
    {
        "content": "<p>well presumably you already have to deal with this, since a struct with a DST field can still have its other fields reordered</p>",
        "id": 278108579,
        "sender_full_name": "bstrie",
        "timestamp": 1649296013
    },
    {
        "content": "<p>That's what <code>#fixed_relative_order</code> is for.</p>",
        "id": 278111032,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649299046
    },
    {
        "content": "<p>Having the unsized part always be the last field makes it easier to figure out the underlying unsized type as well as preventing multiple unsized fields. Changing this may complicate the compiler, as we now have to use layout information to figure out whether a struct is unsized, we can't just recurse on the last field</p>",
        "id": 278119429,
        "sender_full_name": "oli",
        "timestamp": 1649309754
    },
    {
        "content": "<p>If we only allow this by having users add an attribute, that maybe less of a problem</p>",
        "id": 278119477,
        "sender_full_name": "oli",
        "timestamp": 1649309792
    },
    {
        "content": "<p>So I think an interesting example to look at is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Baz</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We already have that the layout of <code>Bar</code> and <code>Baz</code> are likely to be distinct, since <code>Bar</code> will probably be laid out as <code>u16 - u8 - [u8; 1]</code> whereas <code>Baz</code> would be free to be laid out as <code>u8 - [u8; 1] - u16</code>.</p>\n<p>This can be kind of surprising, I guess.</p>\n<p>I don't know if being able to have that <code>c</code> field of <code>Foo</code> not be the last, <em>syntactically</em>, would be helpful or not, but I kind of think that the argument of making \"layout rearrangements be visually <em>less</em> surprising\" is kind of moot when the compiler is still free, in many other places, to rearrange stuff however it sees fit <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 278178641,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649344253
    },
    {
        "content": "<p>Indeed. This is true under lccc's ABI. That example is fine, but if you replaced <code>c</code> with something with higher alignment, for example, <code>[u16;1]</code>, then in the first example, the layout would be <code>b - a - c</code>, whereas the second example, <code>c</code> would be moved to before <code>a</code> since it has a higher alignment requirement, thus <code>b - c - a</code></p>",
        "id": 278200817,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649353404
    },
    {
        "content": "<p>(or if <code>T</code> was made to be <code>T: Sized</code>, rather than <code>T: ?Sized</code>)</p>",
        "id": 278200973,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649353466
    }
]