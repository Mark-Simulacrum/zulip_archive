[
    {
        "content": "<p>I see that the grammar / compiler doesn't allow macro invocations inside of a <code>match</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">arm</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">arm</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Does anyone happen to know any deeper reasoning <em>why</em> this is disallowed? Is it \"no one needed it\"?</p>",
        "id": 225315526,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1612540171
    },
    {
        "content": "<p>I mean, <code>macro_rules</code> macros are more often disallowed than allowed.  One can't <code>struct Foo { foo!() }</code> either, <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=21b81c2f0a660dae3235225e930321f8\">for example</a>.</p>\n<p>Or, more directly, it's disallowed because macro_rules aren't just token insertion, and an arm isn't a pattern, expr, or item.</p>",
        "id": 225331989,
        "sender_full_name": "scottmcm",
        "timestamp": 1612547232
    },
    {
        "content": "<p>In my case, it leads to code like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$(</span><span class=\"n\">mirror_owned_token</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">eq_pat</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"cp\">$v_name</span><span class=\"w\"> </span><span class=\"cp\">$($field</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">mirror_owned_token</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">eq_arm</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"cp\">$v_name</span><span class=\"w\"> </span><span class=\"cp\">$($field</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">,)</span><span class=\"o\">*</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which ideally would have been</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$(</span><span class=\"n\">mirror_owned_token</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"cp\">$v_name</span><span class=\"w\"> </span><span class=\"cp\">$($field</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">,)</span><span class=\"o\">*</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 225335674,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1612548890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225331989\">said</a>:</p>\n<blockquote>\n<p>and an arm isn't a pattern, expr, or item.</p>\n</blockquote>\n<p>I'm not sure I'm following 100%; is is a hard rule that a macro can only expand to those 3 things now and forever?</p>",
        "id": 225336165,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1612549109
    },
    {
        "content": "<p>I don't know why it's those.  IIRC it also can't do things like <code>foo!() 2</code> where <code>foo!()</code> expands to <code>1 +</code>.</p>",
        "id": 225341950,
        "sender_full_name": "scottmcm",
        "timestamp": 1612551901
    },
    {
        "content": "<p>This feels to me like one of those \"macro_rules is what-exists-when-cutting-1.0\" things, and maybe <code>macro</code>s will pick up more things, but nobody's working on those AFAIK</p>",
        "id": 225342146,
        "sender_full_name": "scottmcm",
        "timestamp": 1612551984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225336165\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225331989\">said</a>:</p>\n<blockquote>\n<p>and an arm isn't a pattern, expr, or item.</p>\n</blockquote>\n<p>I'm not sure I'm following 100%; is is a hard rule that a macro can only expand to those 3 things now and forever?</p>\n</blockquote>\n<p>(and a type)</p>",
        "id": 225357314,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1612559135
    },
    {
        "content": "<p>One case that I find especially annoying are where clauses / bounds. There has actually been a recent question on URLO about it (<a href=\"https://users.rust-lang.org/t/way-to-combine-traits-bound-for-reference-type/55173/2?u=yandros\">https://users.rust-lang.org/t/way-to-combine-traits-bound-for-reference-type/55173/2?u=yandros</a>), and \"the least bad solution\" for it gets quite unwieldy: for macros to somehow get \"arbitrary-place expansion\" capabilities one needs to use preprocessor patterns with proc-macros or callback-style macros.<br>\nAn example of the latter for <code>foo!() 2</code> would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">with_foo</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$($rules</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">({</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">__emit__</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cp\">$($rules</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">__emit__</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">})}</span><span class=\"w\"></span>\n\n<span class=\"n\">with_foo</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$($one_plus</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">$($one_plus</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c043d0169c39222ece60ba121c4f7b78\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c043d0169c39222ece60ba121c4f7b78</a></li>\n</ul>",
        "id": 225358321,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1612559572
    },
    {
        "content": "<p>My feel is that macros can only emit \"well-grouped things\". Conceptually I can always write <code>(foo!())</code> instead of <code>foo!()</code>. I _think_ the technical phrasing is that a macro returns a single token-tree</p>",
        "id": 225416916,
        "sender_full_name": "Nadrieril",
        "timestamp": 1612625526
    },
    {
        "content": "<p>I think that explains the current limitations. I don't know if that could be relaxed to emit multiple token-trees, but I suspect this would allow some pretty surprising stuff</p>",
        "id": 225416962,
        "sender_full_name": "Nadrieril",
        "timestamp": 1612625607
    },
    {
        "content": "<p><code>(foo!())</code> does not work in item position</p>",
        "id": 225418078,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1612627123
    },
    {
        "content": "<p>There isn't really a single-token-tree limitation, but macro invocations do have to fit in the Rust AST somehow, so they need to be accomodated for in every place they should be supported</p>",
        "id": 225418093,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1612627176
    },
    {
        "content": "<p>I'm not sure why, <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>, we would jump right to \" for macros to somehow get \"arbitrary-place expansion\" capabilities one needs to use preprocessor patterns with proc-macros or callback-style macros.\" Why not just expand the set of places they can be used to include where clauses?</p>",
        "id": 225721762,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890201
    },
    {
        "content": "<p>(Similarly match arms)</p>",
        "id": 225721784,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890208
    },
    {
        "content": "<p>Maybe there are strong reasons :) I can't remember</p>",
        "id": 225721815,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890217
    },
    {
        "content": "<p>I admit I didn't follow the link</p>",
        "id": 225721827,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890221
    },
    {
        "content": "<p>I also think that is likely too strong, but I believe the rule today is that the macro expansion must form a complete item, expression, or pattern (maybe there's more things?) but basically \"complete things\" rather than portions of the tree.</p>",
        "id": 225722747,
        "sender_full_name": "simulacrum",
        "timestamp": 1612890504
    },
    {
        "content": "<p>sure but</p>",
        "id": 225723828,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890935
    },
    {
        "content": "<p>a where-clause is a \"complete thing\"</p>",
        "id": 225723848,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890945
    },
    {
        "content": "<p>at least as much as a \"pattern\" is, for example</p>",
        "id": 225723874,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612890954
    },
    {
        "content": "<p>kind of - I guess for patterns that's true - I think of them as a bit different but I see your point. I agree that it would not be obviously bad to allow more things, though I wouldn't want to allow any token tree I think, makes for confusing code</p>",
        "id": 225724148,
        "sender_full_name": "simulacrum",
        "timestamp": 1612891051
    },
    {
        "content": "<p>(maybe that's on authors though <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> )</p>",
        "id": 225724163,
        "sender_full_name": "simulacrum",
        "timestamp": 1612891059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I was speaking from a user point of view (which I guess I should have clarified, given how this is a <code>t-lang</code> stream <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>): for an arbitrarily-located-within-the-AST expansion, the two always-applicable patterns that \"achieve\" something close to it and which are within any user's reach are macro CPS and preprocessor.</p>\n<p>Regarding where clauses, I would be delighted if macro calls were allowed there <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 225735415,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1612895565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225724148\">said</a>:</p>\n<blockquote>\n<p>kind of - I guess for patterns that's true - I think of them as a bit different but I see your point. I agree that it would not be obviously bad to allow more things, though I wouldn't want to allow any token tree I think, makes for confusing code</p>\n</blockquote>\n<p>I agree with that</p>",
        "id": 225740545,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612897528
    },
    {
        "content": "<p>I sort of like the model of \"macros take the place of 'complete things'\"</p>",
        "id": 225740605,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612897557
    },
    {
        "content": "<p>it is also why I don't expect <code>$a * 3</code> to have issues if <code>$a = x * y</code> (i.e., there is sort of an implied parentheses)</p>",
        "id": 225740730,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612897591
    },
    {
        "content": "<p>although I realize one is a fragment and one is not</p>",
        "id": 225740745,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612897600
    },
    {
        "content": "<p>I guess <code>foo!() * 3</code> is a better example</p>",
        "id": 225740776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612897610
    },
    {
        "content": "<p>it's not just \"pasting tokens\"</p>",
        "id": 225740802,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612897627
    },
    {
        "content": "<p>right; I think allowing expansion to e.g. a where clause makes sense, but expanding to e.g. <code>where A: B</code> and allowing that e.g. in <code>foo!() + C</code> with intent of <code>where A: B + C</code> I would not expect to work.</p>",
        "id": 225740973,
        "sender_full_name": "simulacrum",
        "timestamp": 1612897715
    },
    {
        "content": "<p>but then the parser will have to understand that <code>fn something() a!() {}</code> is valid code, before knowing what <code>a!()</code> expands to, right?</p>",
        "id": 225741461,
        "sender_full_name": "Mara",
        "timestamp": 1612897909
    },
    {
        "content": "<p>i guess that could work, but then a macro in that position will always have to be a where clause, and could never (in the future) be the function body for example. (e.g. <code>fn something() a!()</code> where <code>a!()</code> expands to the body (which is not accepted right now))</p>",
        "id": 225741817,
        "sender_full_name": "Mara",
        "timestamp": 1612898052
    },
    {
        "content": "<p>sure; that's a good reason to potentially not allow where clauses specifically perhaps, but the point of \"whole units\" is the main one I was trying to make.</p>",
        "id": 225741882,
        "sender_full_name": "simulacrum",
        "timestamp": 1612898089
    },
    {
        "content": "<p>one reason to not allow macros there is that, within a function, <code> fn something() a!() { code }</code> can both include and not include the code block, depending on whether the macro expands to a block, for example. So the \"parens\" sort of should prevent you from doing weird things like attaching to outer partial items</p>",
        "id": 225742107,
        "sender_full_name": "simulacrum",
        "timestamp": 1612898181
    },
    {
        "content": "<p>yeah sure. but what i'm trying to say is that the requirement is much stronger than just 'whole units'. it should be possible to parse without expanding the macros.</p>",
        "id": 225742116,
        "sender_full_name": "Mara",
        "timestamp": 1612898189
    },
    {
        "content": "<p>yeah, I think that's right</p>",
        "id": 225742138,
        "sender_full_name": "simulacrum",
        "timestamp": 1612898204
    },
    {
        "content": "<p>so for arms that will be a bit tricky, as <code>match () { a!() =&gt; {} }</code> is already accepted. if <code>a!()</code> could also expand to a whole arm, then the parser will have to check for a  <code>=&gt;</code> or <code>|</code> after the macro to see what it should parse it as, which might make it harder to give clear errors when there's a typo.</p>",
        "id": 225742772,
        "sender_full_name": "Mara",
        "timestamp": 1612898462
    },
    {
        "content": "<p>wouldn't it rather be <code>fn something() where a!() {}</code>? In that case it's clear that <code>a!</code> has to be a where block.</p>",
        "id": 225745848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612899784
    },
    {
        "content": "<p><code>where a!(): Copy</code> is already accepted though, because macros can expand to types</p>",
        "id": 225746212,
        "sender_full_name": "Mara",
        "timestamp": 1612899936
    },
    {
        "content": "<p>What about a special syntax to state the syntax class? That would allow macros to go just about everywhere. For example <code>a!#where()</code> modulo bikeshed</p>",
        "id": 225746949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612900233
    },
    {
        "content": "<p>although I am sure there are some weird syntax classes, like <code>use {foo, bar, m!#use_glob()};</code></p>",
        "id": 225747246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612900339
    },
    {
        "content": "<p>would that really be worth it?</p>",
        "id": 225747374,
        "sender_full_name": "Mara",
        "timestamp": 1612900393
    },
    {
        "content": "<p>it's certainly ugly enough to not be used often, but an ugly syntax for a rarely used feature seems fair to me</p>",
        "id": 225747454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612900432
    },
    {
        "content": "<p>I think it's better than the alternative of CPS macros, which don't respect the AST structure</p>",
        "id": 225747655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612900517
    },
    {
        "content": "<p>but compared to just not supporting it?</p>",
        "id": 225747694,
        "sender_full_name": "Mara",
        "timestamp": 1612900538
    },
    {
        "content": "<p>well not supporting it just means people will find workarounds</p>",
        "id": 225747790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612900564
    },
    {
        "content": "<p>CPS macros such as <span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> showed above being such a workaround</p>",
        "id": 225747855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612900599
    },
    {
        "content": "<p>I think we should avoid using <code>#</code> in new syntax, since <code>quote!</code> effectively has first dibs on nearly all uses</p>",
        "id": 225748723,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1612900964
    },
    {
        "content": "<p>In the case of <code>where</code> clauses, I think macros should be able to expand to one clause, <em>or to a sequence of such clauses</em> (which implementation-wise would be a bit trickier, but would definitely handle the case of complex bounds. Unless <code>implied_bounds</code> or <code>trait_alias</code>ed were implemented, in which case the <code>library</code> could always define a single-clause equivalent).</p>\n<p>But it should never \"include\" the <code>where</code> part:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Ret</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"nc\">Debug</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">library_bounds</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">library_use</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<hr>\n<p>Back to the OP, regarding <code>match</code> arms: I also find that a similar requirement to \"sequence of <code>match</code> arms\" may end up being needed.</p>\n<p>One such example would be syntactical duck-typing:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(PartialEq, Eq, SyntacticalDuckTyping)]</span><span class=\"w\"> </span><span class=\"c1\">// generates an `Example!` macro</span>\n<span class=\"k\">enum</span> <span class=\"nc\">Example</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">U16</span><span class=\"p\">(</span><span class=\"kt\">u16</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">U32</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// more may be added in the future</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">SENTINEL</span>: <span class=\"nc\">Example</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Example</span>::<span class=\"n\">U32</span><span class=\"p\">(</span>::<span class=\"n\">core</span>::<span class=\"kt\">u32</span>::<span class=\"n\">MAX</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">e</span>: <span class=\"nc\">Example</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Example</span>::<span class=\"n\">SENTINEL</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Example</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">uN</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">uN</span><span class=\"p\">.</span><span class=\"n\">to_be_bytes</span><span class=\"p\">().</span><span class=\"n\">to_vec</span><span class=\"p\">())),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cm\">/* expanding to:</span>\n<span class=\"cm\">            Example::U16(uN) =&gt; Some(uN.to_be_bytes().to_vec()),</span>\n<span class=\"cm\">            Example::U32(uN) =&gt; Some(uN.to_be_bytes().to_vec()),</span>\n<span class=\"cm\">        … */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So we are no longer in the realm of \"a macro call matches a 'single AST thing'\" (although for macros expanding to statements this was already the case <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> so it may not be that tricky to implement)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225742772\">said</a>:</p>\n<blockquote>\n<p>so for arms that will be a bit tricky, as <code>match () { a!() =&gt; {} }</code> is already accepted. if <code>a!()</code> could also expand to a whole arm, then the parser will have to check for a  <code>=&gt;</code> or <code>|</code> after the macro to see what it should parse it as, which might make it harder to give clear errors when there's a typo.</p>\n</blockquote>\n<p>Assuming a typo of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">scrutinee</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// typo: using `,` instead of `|`</span>\n<span class=\"w\">    </span><span class=\"n\">expands_to_a_pattern</span><span class=\"o\">!</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">SomeOtherPattern</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The current error message, with macros not being allowed to expand to a full match arm, is:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: unexpected `,` in pattern\n  --&gt; src/main.rs:13:36\n   |\n13 |             expands_to_a_pattern!(), None =&gt; {},\n   |                                    ^\n   |\n</code></pre></div>\n<p>I could imagine the error message now becoming (assuming the pattern is, for instance, <code>Some(_)</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: expected match arm(s), found `Some(_)`  --&gt; src/main.rs:13:38\n   |\n13 |             expands_to_a_pattern!(), None =&gt; {},\n                 ^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre></div>\n<p>I don't really know how these diagnostics work, but when the input to an expected match arm matches the syntax of a pattern, the error message could then be enhanced with suggestions in that regard (taken from the (great!) suggestions in current Rust):</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: expected match arm(s), found `Some(_)`  --&gt; src/main.rs:13:38\n   |\n13 |             expands_to_a_pattern!(), None =&gt; {},\n                 ^^^^^^^^^^^^^^^^^^^^^^^\nhelp: if you intended to use a pattern, try adding parentheses to match on a tuple...\n   |\n13 |             (expands_to_a_pattern!(), None) =&gt; {},\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: ...or a vertical bar to match on multiple alternatives\n   |\n13 |             expands_to_a_pattern!() | None =&gt; {},\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre></div>",
        "id": 225830191,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1612961147
    },
    {
        "content": "<p>yeah it could work. but we'll need to be careful not to paint ourselves into a corner here. for example, <code>type = type</code> is already parsed as a bound in where clauses, and maybe in the future we'll have something like <code>const X: i32 where ... = 1;</code>. then <code>const X: i32 where a!() = Thing</code> will be hard to parse without knowing if <code>a!()</code> expands to <code>type</code> or <code>type = type</code>. this specific example is probably unlikely to happen, but in general it's pretty hard to see how allowing macros to stand for different things in the same place might end up being a problem in the future.</p>",
        "id": 225836071,
        "sender_full_name": "Mara",
        "timestamp": 1612964178
    },
    {
        "content": "<p>for the <code>match</code> arm situation, it'd mean that we can never start accepting <code>match (1, 2) { 1, 2 =&gt; .. }</code> even if we wanted to. this might be fine. but it's hard to list all the future things we're making impossible by allowing full match arm macros</p>",
        "id": 225836260,
        "sender_full_name": "Mara",
        "timestamp": 1612964287
    },
    {
        "content": "<p>That last thing might impact the proposal on never patterns, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 225877829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978956
    },
    {
        "content": "<p>I can imagine this general kind of problem being solved at the compiler level by keeping track of macro calls whose syntax class isn't completely resolved; this may require some backtracking based on tokens that follow the macro call.</p>",
        "id": 225878481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612979185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225742772\">said</a>:</p>\n<blockquote>\n<p>so for arms that will be a bit tricky, as <code>match () { a!() =&gt; {} }</code> is already accepted. if <code>a!()</code> could also expand to a whole arm, then the parser will have to check for a  <code>=&gt;</code> or <code>|</code> after the macro to see what it should parse it as, which might make it harder to give clear errors when there's a typo.</p>\n</blockquote>\n<p>it's not particularly hard to look ahead and see what comes next</p>",
        "id": 225878948,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612979328
    },
    {
        "content": "<p>I agree with the constraint</p>",
        "id": 225879002,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612979346
    },
    {
        "content": "<p>it's just that it can be satisfied in many cases</p>",
        "id": 225879033,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612979356
    },
    {
        "content": "<p>Aside-ish:<br>\n@mara good point; the whole <code>where</code> situation not requiring an extra disambiguating scope can be annoying. Would clause trees make sense in order to feature a completely unambiguous syntax? Like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"nc\">Trait</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(or with <code>[ … ]</code> for the delimiter, may be less weird when dealing with <code>where</code> clauses for a <code>struct</code>).</li>\n</ul>\n<p>That way <code>const X: T where a!() = () = ();</code> could be given the parsing of <code>a!() is a type</code>, and for those wanting the other interpretation (<code>a!()</code> being a clause (tree)), an explicit trailing comma or braces for a clause tree would be useful.</p>\n<p>I mention clause trees since (on top of solving the question of \"expanding to multiple clauses), it also crossed my mind when writing high-order bounds:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"p\">(),)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"p\">(),)</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">},</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Not only would that be a bit more lightweight to write than typing twice the <code>for</code> quantification, it could also maybe help avoid the bugs that we currently have with such higher-order bounds?</p>\n<hr>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/213817-t-lang/topic/macro.20invocations.20as.20match.20arms/near/225878481\">said</a>:</p>\n<blockquote>\n<p>I can imagine this general kind of problem being solved at the compiler level by keeping track of macro calls whose syntax class isn't completely resolved; this may require some backtracking based on tokens that follow the macro call.</p>\n</blockquote>\n<p>I  don't think that going down that road would be worth it; I'm pretty sure that being able to know the expected AST kind of a macro call before expansion is a very nice feature that compiler devs will want to maintain. That being said, regarding the potential new syntax for never patterns (thanks for pointing that out), we could have a \"dummy\" / \"transparent\" wrapping (<em>à la</em> <code>Stmt::Item</code>) from a match arm to a pattern: by allowing match arms not to necessarily have a <code>=&gt; &lt;expr&gt;</code> RHS, I'd expect <code>m!()</code> in <code>match … { m!(), _ =&gt; … }</code> to be seen as a match arm.</p>",
        "id": 225888288,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1612983026
    },
    {
        "content": "<p>we actually already do not know the expected AST kind of macro calls</p>",
        "id": 225901555,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612988604
    },
    {
        "content": "<p>well, it depends on your POV to some extent</p>",
        "id": 225901573,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612988613
    },
    {
        "content": "<p>but e.g. <code>fn foo() { bar!() }</code> could expand to an expression or a function item</p>",
        "id": 225901624,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612988635
    },
    {
        "content": "<p>how does the compiler keep track of that? Is there a <code>ExprOrItem</code> production in the grammar for macro calls?</p>",
        "id": 225901814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612988702
    },
    {
        "content": "<p>Honestly I forget how it works</p>",
        "id": 225901889,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612988724
    },
    {
        "content": "<p>I feel like there's some complexity around this in a few places</p>",
        "id": 225901910,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1612988729
    },
    {
        "content": "<p>I recall some ambiguity coming up with things like <code>fn foo() { bar!() &amp;&amp;true }</code></p>",
        "id": 225902015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612988763
    },
    {
        "content": "<p>or is a trailing semicolon sufficient to disambiguate there?</p>",
        "id": 225902109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612988809
    },
    {
        "content": "<p>maybe it only happens with <code>bar!{} &amp;&amp; true</code></p>",
        "id": 225902145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612988828
    },
    {
        "content": "<p>Oh fun, it looks like the delimiters are required to be different to make these compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo1</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"o\">!</span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 225902976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612989158
    },
    {
        "content": "<p>oh interesting, with a block around it things get confused for real. Is this a bug?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"kc\">false</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// doesn't compile, parsed as two statements</span>\n</code></pre></div>",
        "id": 225904018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612989583
    },
    {
        "content": "<p>oh nvm, the error message makes it clear this is deliberate</p>",
        "id": 225904440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612989771
    },
    {
        "content": "<blockquote>\n<p>but e.g. <code>fn foo() { bar!() }</code> could expand to an expression or a function item</p>\n</blockquote>\n<p>which leads to the interesting case that <code>fn foo() { bar!{} bar!{} }</code> compiles fine even if <code>bar!{}</code> expands to <code>()</code> without a semicolon, because the parser already accepted it before it knew bar!{} was only an expression. (so, the output of <code>--pretty=expanded</code> doesn't even parse)</p>",
        "id": 225912726,
        "sender_full_name": "Mara",
        "timestamp": 1612993246
    }
]