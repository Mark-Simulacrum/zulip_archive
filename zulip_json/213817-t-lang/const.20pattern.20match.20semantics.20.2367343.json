[
    {
        "content": "<p>I honestly cannot remember to what level of detail we had discussed this, so I wanted to try to check here first:</p>",
        "id": 195628438,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588108729
    },
    {
        "content": "<p>I am pretty sure we had previously agreed to adopt <span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> 's approach for using a MIR \"value-based\" semantics for validating that all parts of a <code>const</code> in a pattern match implement <code>PartialEq</code> and <code>Eq</code> via <code>#[derive(..)]</code></p>",
        "id": 195628612,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588108822
    },
    {
        "content": "<p>But the thing I am not certain about is whether we had all agreed that we were okay with using a value-based semantics across crate boundaries</p>",
        "id": 195628648,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588108846
    },
    {
        "content": "<p>(the main alternative I could imagine is to use a type-based semantics across crate boundaries)</p>",
        "id": 195628679,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588108865
    },
    {
        "content": "<p>I guess the point of this is that whether crate authors will realize that changing the value of a <code>const</code> item such that it becomes not structurally-matchable will break downstream crates.</p>",
        "id": 195628897,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588108982
    },
    {
        "content": "<p>I have no memory of this :)</p>",
        "id": 195628960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109017
    },
    {
        "content": "<p>but at this point I just want it resolved</p>",
        "id": 195628972,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109022
    },
    {
        "content": "<p>The relevant note from PR <a href=\"https://github.com/rust-lang/rust/issues/67343\" title=\"https://github.com/rust-lang/rust/issues/67343\">#67343</a> is in its description; I will copy it here for ease of reference: </p>\n<blockquote>\n<p>AFAIK, it's not settled that these are the semantics we actually want: it's just how the <code>Qualif</code> framework happens to work. If the cross-crate part is undesirable, it would be quite easy to change the result of <code>mir_const_qualif().custom_eq</code> to <code>true</code> before encoding it in the crate metadata. This way, other crates would have to assume that all publicly exported constants may not be safe for matching.</p>\n</blockquote>",
        "id": 195628996,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109033
    },
    {
        "content": "<p>that said, I do think that -- in general -- one canot change const values without breakage, right?</p>",
        "id": 195629003,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629003\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629003\">said</a>:</p>\n<blockquote>\n<p>that said, I do think that -- in general -- one canot change const values without breakage, right?</p>\n</blockquote>\n<p>I was indeed wondering that as I was typing</p>",
        "id": 195629050,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109053
    },
    {
        "content": "<p>and if that is the case, then maybe I am making a mountain out of a molehill</p>",
        "id": 195629076,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109068
    },
    {
        "content": "<p>well, it comes I guess to how we wind up settling on equality <em>but</em></p>",
        "id": 195629095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109082
    },
    {
        "content": "<p>In any case, I get the impression that it would be quite easy for <span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> to adopt the more conservative semantics</p>",
        "id": 195629138,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109101
    },
    {
        "content": "<p>this builds for sure</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">B</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 195629192,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109129
    },
    {
        "content": "<p>and I guess the same is true across crates</p>",
        "id": 195629205,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629095\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629095\">said</a>:</p>\n<blockquote>\n<p>well, it comes I guess to how we wind up settling on equality <em>but</em></p>\n</blockquote>\n<p>hmm, I had thought in either case (with or without cross-crate support), we would still be equally able to support structural or semantic equality, no?</p>",
        "id": 195629208,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109137
    },
    {
        "content": "<p>I remember talking about this topic a lot with <span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> and <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> years back but I kind of lost track on this question</p>",
        "id": 195629318,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109180
    },
    {
        "content": "<p>My suspicion is that this is fine</p>",
        "id": 195629342,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109195
    },
    {
        "content": "<p>to me it's always been the \"key\" thing to think and discuss with const generics so I'm frustrated that I don't have a crisp articulation of the current thinking :)</p>",
        "id": 195629357,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109201
    },
    {
        "content": "<p>i.e. that supporting the cross-crate thing here is fine. (In particular, I'm betting that if there was some problem with it, <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> would have raised a ruckus with respect to this PR a long time ago...)</p>",
        "id": 195629411,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629208\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629208\">said</a>:</p>\n<blockquote>\n<p>hmm, I had thought in either case (with or without cross-crate support), we would still be equally able to support structural or semantic equality, no?</p>\n</blockquote>\n<p>I'm not sure I understand</p>",
        "id": 195629412,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629412\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629412\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand</p>\n</blockquote>",
        "id": 195629459,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109263
    },
    {
        "content": "<p>well</p>",
        "id": 195629475,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109271
    },
    {
        "content": "<p>the linked PR is still in service of us being ambivalent of the choice between structural or semantic equality for consts in patterns</p>",
        "id": 195629557,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109304
    },
    {
        "content": "<p>and thus</p>",
        "id": 195629572,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109312
    },
    {
        "content": "<p>I had figured</p>",
        "id": 195629575,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109314
    },
    {
        "content": "<p>even if it allows the more expressive form across crates</p>",
        "id": 195629589,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109323
    },
    {
        "content": "<p>it is <em>still</em> going to be something where the only code that is accepted</p>",
        "id": 195629599,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109331
    },
    {
        "content": "<p>is code that is compatible with structural match or use of <code>PartialEq::eq</code> for its semantics</p>",
        "id": 195629662,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109369
    },
    {
        "content": "<p>I see</p>",
        "id": 195629698,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109396
    },
    {
        "content": "<p>Something else that I had realized, forgotten, and that I am now re-remembering</p>",
        "id": 195629749,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109404
    },
    {
        "content": "<p>is that equality in const generics</p>",
        "id": 195629782,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109421
    },
    {
        "content": "<p>will presumably <em>not</em> be based on <code>PartialEq</code></p>",
        "id": 195629788,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109427
    },
    {
        "content": "<p>but rather a different notion of equality</p>",
        "id": 195629823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109443
    },
    {
        "content": "<p>having said that, it will be pretty wild if we use structural semantics for constants that are defined like <code>const C = if TEST { E::Var1 } else { E::Var2 };</code></p>",
        "id": 195629844,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109457
    },
    {
        "content": "<p>which is kind of neither here nor there <em>I guess</em></p>",
        "id": 195629856,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629844\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629844\">said</a>:</p>\n<blockquote>\n<p>having said that, it will be pretty wild if we use structural semantics for constants that are defined like <code>const C = if TEST { E::Var1 } else { E::Var2 };</code></p>\n</blockquote>\n<p>yes</p>",
        "id": 195629877,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109479
    },
    {
        "content": "<p>similarly <code>const X = some_const_fn(...);</code></p>",
        "id": 195629891,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109489
    },
    {
        "content": "<p>though you might want it, it's very unclear</p>",
        "id": 195629898,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109495
    },
    {
        "content": "<p>ooh boy</p>",
        "id": 195629945,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629823\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629823\">said</a>:</p>\n<blockquote>\n<p>but rather a different notion of equality</p>\n</blockquote>\n<p>was this due to floating point NaN issues? Or something else?</p>",
        "id": 195630013,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109556
    },
    {
        "content": "<p>well</p>",
        "id": 195630243,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109702
    },
    {
        "content": "<p>the obvious example is <code>impl PartialEq for MyType { fn is_eq(&amp;self) -&gt; bool { false } }</code></p>",
        "id": 195630273,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109723
    },
    {
        "content": "<p>two things might be \"equal\" constants (same bitpatterns) but not equal at runtime</p>",
        "id": 195630297,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109737
    },
    {
        "content": "<p>right</p>",
        "id": 195630304,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109742
    },
    {
        "content": "<p>this is very \"close\" to the pattern questions</p>",
        "id": 195630312,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109746
    },
    {
        "content": "<p>that's the classic example that I reference</p>",
        "id": 195630313,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109748
    },
    {
        "content": "<p>but</p>",
        "id": 195630315,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109749
    },
    {
        "content": "<p>I would think that</p>",
        "id": 195630323,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109756
    },
    {
        "content": "<p>if we commit to so-called semantic equality</p>",
        "id": 195630363,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109764
    },
    {
        "content": "<p>i.e. if we commit to dispatching to <code>PartialEq::eq</code></p>",
        "id": 195630374,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109773
    },
    {
        "content": "<p>then all such matches on <code>MyType</code> will just fail?</p>",
        "id": 195630379,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109780
    },
    {
        "content": "<p>but I'm talking about const generics equality</p>",
        "id": 195630389,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109788
    },
    {
        "content": "<p>e.g., given <code>const C: MyType = ..</code>, are <code>Foo&lt;C&gt;</code> and <code>Foo&lt;C&gt;</code> equal types?</p>",
        "id": 195630404,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109807
    },
    {
        "content": "<p>oh right</p>",
        "id": 195630418,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109821
    },
    {
        "content": "<p>what about <code>Foo&lt;C&gt;</code> and <code>Foo&lt;D&gt;</code> where <code>C</code> and <code> D</code> are two distinct constants with same bit pattern</p>",
        "id": 195630428,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109825
    },
    {
        "content": "<p>you all keep reconnecting these two things</p>",
        "id": 195630433,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109828
    },
    {
        "content": "<p>they are distinct for sure</p>",
        "id": 195630443,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109839
    },
    {
        "content": "<p>and I keep acting like we can treat <code>match</code> as living in its own little bubble</p>",
        "id": 195630446,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109842
    },
    {
        "content": "<p>pattern matching is a runtime operation</p>",
        "id": 195630454,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109847
    },
    {
        "content": "<p><em>but</em></p>",
        "id": 195630464,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109854
    },
    {
        "content": "<p>I guess I'm just saying that we <em>will</em> have two notions of equality</p>",
        "id": 195630472,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629782\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629782\">said</a>:</p>\n<blockquote>\n<p>is that equality in const generics</p>\n</blockquote>\n<p>when you wrote this, I read it as \"matching of associated consts\"</p>",
        "id": 195630482,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109869
    },
    {
        "content": "<p>and some of the concerns, e.g., wanting to know that we always have a place to branch to</p>",
        "id": 195630485,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109871
    },
    {
        "content": "<p>or exhaustiveness etc</p>",
        "id": 195630495,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109876
    },
    {
        "content": "<p>which is not at all what you wrote, of course</p>",
        "id": 195630498,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109878
    },
    {
        "content": "<p>seem related</p>",
        "id": 195630544,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109885
    },
    {
        "content": "<p>I guess it softens me to the \"two notions\" of equality, if we can make the \"static-y\" equality for const generics and pattern matching kind of line up</p>",
        "id": 195630573,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109912
    },
    {
        "content": "<p>well my point is that in the end, we can always fall back on having <code>match</code> arms fail to fire</p>",
        "id": 195630574,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109916
    },
    {
        "content": "<p>as long as there is an <code>_</code> arm...</p>",
        "id": 195630604,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109934
    },
    {
        "content": "<p>sure</p>",
        "id": 195630612,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109939
    },
    {
        "content": "<p>presumably the exhautiveness checker will give up in cases where you did not <code>derive</code> the <code>PartialEq</code> impl</p>",
        "id": 195630637,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109961
    },
    {
        "content": "<p>I'm sort of looking for an excuse to give up and embrace the \"syntactic equality\", I guess :)</p>",
        "id": 195630651,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109971
    },
    {
        "content": "<p>and thus you will get errors if you leave out <code>_ =&gt; ...</code></p>",
        "id": 195630654,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109972
    },
    {
        "content": "<p>Wouldn't it be great</p>",
        "id": 195630676,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109985
    },
    {
        "content": "<p>if we used NaN</p>",
        "id": 195630681,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109988
    },
    {
        "content": "<p>as an excuse</p>",
        "id": 195630687,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109990
    },
    {
        "content": "<p>to embrace syntactic equality</p>",
        "id": 195630698,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588109995
    },
    {
        "content": "<p>such totally unrelated linguistic elements</p>",
        "id": 195630755,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110009
    },
    {
        "content": "<p>but also</p>",
        "id": 195630789,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110033
    },
    {
        "content": "<p>hmm</p>",
        "id": 195630812,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110035
    },
    {
        "content": "<p>/me wonders about the <code>Foo&lt;C&gt;</code> example</p>",
        "id": 195630831,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110047
    },
    {
        "content": "<p>like, okay: You go ahead and put in non equivalence relation as your <code>impl PartialEq for MyType</code> ... So in the worst case, if we <em>did</em> use semantic equality even at the type level</p>",
        "id": 195630922,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110120
    },
    {
        "content": "<p>(and, i dunno, used miri within the type checker)</p>",
        "id": 195630976,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110132
    },
    {
        "content": "<p>ignoring the engineering issues that arise</p>",
        "id": 195631009,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110159
    },
    {
        "content": "<p>Just in terms of user experience: What's the worst that happens?</p>",
        "id": 195631023,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195628648\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195628648\">said</a>:</p>\n<blockquote>\n<p>But the thing I am not certain about is whether we had all agreed that we were okay with using a value-based semantics across crate boundaries</p>\n</blockquote>\n<p>When we discussed it in the meeting, that topic didn't come up at all. I do personally agree that cross-crate doesn't need special handling.</p>",
        "id": 195631031,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588110180
    },
    {
        "content": "<p>Someone sees some truly bonkers behavior where the compiler rejects things like the assignment <code>x = x;</code> because the type-checker claims typeof(x) != typeof(x) ?</p>",
        "id": 195631166,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110246
    },
    {
        "content": "<p>The main problem I see there is that, ideally, you'd want very specific feedback about <em>why</em> the expected and actual types are different</p>",
        "id": 195631205,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110277
    },
    {
        "content": "<p>yeah but also</p>",
        "id": 195631218,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110287
    },
    {
        "content": "<p>if you have a <code>PartialEq</code> whose comparison function is not a <code>const fn</code></p>",
        "id": 195631242,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110303
    },
    {
        "content": "<p>it can't be compared</p>",
        "id": 195631250,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110305
    },
    {
        "content": "<p>so we either have to forbid those types from being used as const generics..</p>",
        "id": 195631265,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110317
    },
    {
        "content": "<p>I think that was what bothered me, that it introduced a kind of \"class\" of types</p>",
        "id": 195631285,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110329
    },
    {
        "content": "<p>that is sort of ad-hoc</p>",
        "id": 195631287,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110332
    },
    {
        "content": "<p>I assume in this hypothetical universe, people would actually <em>declare</em> their partial eq method to be a <code>const fn</code></p>",
        "id": 195631362,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110367
    },
    {
        "content": "<p>it would not be e.g. inferred from the structure of its body</p>",
        "id": 195631370,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631031\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631031\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195628648\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195628648\">said</a>:</p>\n<blockquote>\n<p>But the thing I am not certain about is whether we had all agreed that we were okay with using a value-based semantics across crate boundaries</p>\n</blockquote>\n<p>When we discussed it in the meeting, that topic didn't come up at all. I do personally agree that cross-crate doesn't need special handling.</p>\n</blockquote>\n<p>Okay I'm glad I brought this up, at least. I don't know whether we need to make it part of this week's agenda, but I suppose it woudn't hurt. I <em>don't</em> think we need to block landing this PR on it.</p>",
        "id": 195631487,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110425
    },
    {
        "content": "<p>(because I believe that it would be easy to toggle to the other semantics if we did decide in the meeting that would be preferable.)</p>",
        "id": 195631544,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110455
    },
    {
        "content": "<p>I'll add this as an agenda item.</p>",
        "id": 195631578,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631362\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631362\">said</a>:</p>\n<blockquote>\n<p>I assume in this hypothetical universe, people would actually <em>declare</em> their partial eq method to be a <code>const fn</code></p>\n</blockquote>\n<p>How would that interact with #[derive(PartialEq)]? Would the derived impl be const sometimes, always, or never.</p>",
        "id": 195631673,
        "sender_full_name": "Asa Zeren",
        "timestamp": 1588110496
    },
    {
        "content": "<p>... hmm. I had assumed that if you were able to make arbitrary methods of an impl into <code>const fn</code> (assuming their bodies were compatible with being <code>const fn</code>), then we could make <code>derive(PartialEq)</code> do so...</p>",
        "id": 195631757,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110554
    },
    {
        "content": "<p>I suppose there may be things the derived partial eq impl does today that are not expressible in <code>const fn</code></p>",
        "id": 195631776,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110574
    },
    {
        "content": "<p>(e.g. inspecting the discriminant may not be legal in <code>const fn</code> today?)</p>",
        "id": 195631800,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110587
    },
    {
        "content": "<p>its been a long time since I messed around with the innards of those derives...</p>",
        "id": 195631875,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110615
    },
    {
        "content": "<p>It'd be nice if all <code>derive(PartialEq)</code> calls were const if the fields' <code>PartialEq</code> impls are.</p>",
        "id": 195631906,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588110638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"236160\">Asa Zeren</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631673\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631673\">said</a>:</p>\n<blockquote>\n<p>How would that interact with #[derive(PartialEq)]? Would the derived impl be const sometimes, always, or never.</p>\n</blockquote>\n<p>(I guess I was hoping the answer was \"always\", but now I do not know if that's possible...)</p>",
        "id": 195631917,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110649
    },
    {
        "content": "<p>Right: Of course you hit a problem with type parameters</p>",
        "id": 195631964,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110679
    },
    {
        "content": "<p>where a given generic type parameter may have a <code>PartialEq</code> implementation that is itself not a <code>const fn</code> impl ... sigh...</p>",
        "id": 195632009,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110698
    },
    {
        "content": "<p>okay maybe this is all ridiculous then</p>",
        "id": 195632049,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110713
    },
    {
        "content": "<p>if partial eq only sometimes uses <code>const fn</code>s, then there would be no source level indication, and so changing a type (including transitively) would mysteriously break things, and make it very easy to break semver</p>",
        "id": 195632052,
        "sender_full_name": "Asa Zeren",
        "timestamp": 1588110714
    },
    {
        "content": "<p>Perhaps one could go with a new trait <code>ConstPartialEq</code> or some such</p>",
        "id": 195632144,
        "sender_full_name": "Asa Zeren",
        "timestamp": 1588110743
    },
    {
        "content": "<p>another approach would be an opt-in of some kind</p>",
        "id": 195632157,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110748
    },
    {
        "content": "<p>yeah, I was thinking more along the lines of <code>derive(PartialEq(const))</code>, but in any case</p>",
        "id": 195632196,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110763
    },
    {
        "content": "<p>some way to actually signal intent</p>",
        "id": 195632239,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110780
    },
    {
        "content": "<p>which, given how relatively rare generic constants are ... maybe that would be okay?</p>",
        "id": 195632264,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110805
    },
    {
        "content": "<p>The nice thing about a trait is that it would remove the 'ad-hoc' classification of types.</p>",
        "id": 195632271,
        "sender_full_name": "Asa Zeren",
        "timestamp": 1588110808
    },
    {
        "content": "<p>pretty hokey though</p>",
        "id": 195632275,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110808
    },
    {
        "content": "<p>It feels like we need a more systematic way of handling <code>const</code> in traits.</p>",
        "id": 195632291,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588110814
    },
    {
        "content": "<p>(And functions, but especially traits.)</p>",
        "id": 195632301,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588110819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631285\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195631285\">said</a>:</p>\n<blockquote>\n<p>I think that was what bothered me, that it introduced a kind of \"class\" of types</p>\n</blockquote>\n<p>yeah now I think I understand what <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was getting at here</p>",
        "id": 195632317,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110830
    },
    {
        "content": "<p>anyway gotta go afk</p>",
        "id": 195632373,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110848
    },
    {
        "content": "<p>sorry for stirring the pot. :)</p>",
        "id": 195632385,
        "sender_full_name": "pnkfelix",
        "timestamp": 1588110856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629411\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195629411\">said</a>:</p>\n<blockquote>\n<p>i.e. that supporting the cross-crate thing here is fine. (In particular, I'm betting that if there was some problem with it, <span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> would have raised a ruckus with respect to this PR a long time ago...)</p>\n</blockquote>\n<p>we already leak properties cross-crate like whether the value needs destructors or whether it contains UnsafeCell values</p>",
        "id": 195654329,
        "sender_full_name": "eddyb",
        "timestamp": 1588128796
    },
    {
        "content": "<p>as for const generics, we don't want to dispatch to user code <em>at all</em>. it's just not worth it, from a typesystem-must-be-sound-at-any-cost perspective</p>",
        "id": 195654434,
        "sender_full_name": "eddyb",
        "timestamp": 1588128925
    },
    {
        "content": "<p>but we do want to limit the types we allow in const generics to those with structural Eq, to avoid confusing semantics, and limit primitive leaf values to those that are effectively plain integers (while references behave as newtypes, not pointers, because of their by-value-eq semantics)</p>",
        "id": 195654578,
        "sender_full_name": "eddyb",
        "timestamp": 1588129061
    },
    {
        "content": "<p>That last point is not obvious to me.</p>",
        "id": 195689409,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588156710
    },
    {
        "content": "<p>By which I just mean: it avoids confusing semantics, but it shuts out use cases too, and I'm not sure what is best -- especially as \"structural equality\" is this \"latent concept\" right now and not something users can declare. And if it becomes something users can declare, then that's adding another thing to have to understand.</p>",
        "id": 195689488,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588156785
    },
    {
        "content": "<p>Anyway I think it's a good question to defer for the moment, when it comes to const generics, which maybe implies it's ok to defer the question of match semantics too until we're further down the road.</p>",
        "id": 195689566,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588156811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> <a href=\"https://github.com/rust-lang/rust/issues/49146#issuecomment-617862124\" title=\"https://github.com/rust-lang/rust/issues/49146#issuecomment-617862124\">this comment by <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> and some of the replies are relevant</a>, they talk about the 'opacity' of constant definitions vs const fn with respect to the \"precise variant\" analysis</p>",
        "id": 195708902,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588167201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195632291\" title=\"#narrow/stream/213817-t-lang/topic/const.20pattern.20match.20semantics.20.2367343/near/195632291\">said</a>:</p>\n<blockquote>\n<p>It feels like we need a more systematic way of handling <code>const</code> in traits.</p>\n</blockquote>\n<p>This in part seems like the focus of the <a href=\"https://github.com/rust-lang/rfcs/pull/2632\" title=\"https://github.com/rust-lang/rfcs/pull/2632\">generic parameters in const fn RFC</a>. Maybe it's worth starting up a lang WG to discuss these sorts of issues more comprehensively and holistically?</p>",
        "id": 195739612,
        "sender_full_name": "varkor",
        "timestamp": 1588179374
    },
    {
        "content": "<p>(I'm definitely interested in being part of these discussions when they do happen.)</p>",
        "id": 195739763,
        "sender_full_name": "varkor",
        "timestamp": 1588179453
    },
    {
        "content": "<p>I also recently discovered that pattern matching <a href=\"https://github.com/rust-lang/const-eval/issues/42\" title=\"https://github.com/rust-lang/const-eval/issues/42\">places an entire new set of soundness concerns on const-eval</a> that so far  we have not explicitly documented anywhere, and that I was not aware of...</p>",
        "id": 195803709,
        "sender_full_name": "RalfJ",
        "timestamp": 1588229758
    },
    {
        "content": "<p>not sure if that has been discussed in this context already, but the fact that we do pattern-matching through arbitrary reference types places some serious restrictions on use of consts outside patterns. namely, it would otherwise be completely okay to have a const pointing to a (potentially mutable) static; with pattern matching however we must ensure that consts <em>transitively</em> do not point to anything mutable anywhere ever.</p>",
        "id": 195803792,
        "sender_full_name": "RalfJ",
        "timestamp": 1588229840
    },
    {
        "content": "<p>Why would it ever be acceptable to have a reference to a mutable thing and still be able to mutate that thing?</p>",
        "id": 195804131,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588230099
    },
    {
        "content": "<p>That seems like it violates the most fundamental property of the borrow checker.</p>",
        "id": 195804210,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1588230135
    },
    {
        "content": "<p>at leas mutating it through that reference should be fine, right?</p>",
        "id": 195878387,
        "sender_full_name": "RalfJ",
        "timestamp": 1588269938
    },
    {
        "content": "<p>like, <code>&amp;mut SOMETHING_GLOBAL</code> <em>is</em> a constant value, and there seems to be no harm in letting people put it in a constant</p>",
        "id": 195878416,
        "sender_full_name": "RalfJ",
        "timestamp": 1588269958
    },
    {
        "content": "<p>or, more likely, <code>&amp;SOMETHING_GLOBAL_WITH_INTERIOR_MUT</code></p>",
        "id": 195878509,
        "sender_full_name": "RalfJ",
        "timestamp": 1588269991
    },
    {
        "content": "<p>if it wasn't for patterns, consts could refer to interior mutable statics just fine (and there are no aliasing issues because of <code>UnsafeCell</code>)</p>",
        "id": 195878596,
        "sender_full_name": "RalfJ",
        "timestamp": 1588270035
    }
]