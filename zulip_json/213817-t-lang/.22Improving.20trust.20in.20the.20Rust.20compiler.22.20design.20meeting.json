[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> so regarding <a href=\"https://github.com/rust-lang/lang-team/issues/79\">https://github.com/rust-lang/lang-team/issues/79</a>, I am not sure I understand your comment in that issue</p>\n<blockquote>\n<p>I think for the scope of that meeting, \"MIR and MIRI fit the picture well\" is probably the level discussed on, but anything regarding sharp plans there is the scope for more focused sessions.</p>\n</blockquote>\n<p>Are you saying the first meeting will not be very technical (and thus likely not be very interesting for me)?</p>",
        "id": 225414979,
        "sender_full_name": "RalfJ",
        "timestamp": 1612622830
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Ah! It will be somewhat technical, but as there's such a broad picture and aspects to discuss, I just assume that what we discuss will not go very deep into every aspect. I'd love to have your technical perspective around and it will definitely be interesting, but if it can't be made happen, I think it will be easy to watch a recording and pick the conversation up from there.</p>",
        "id": 225465664,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1612707037
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/lang-team/files/5997688/lang-team-proposal-trust-levels-1613584473422.pdf\">https://github.com/rust-lang/lang-team/files/5997688/lang-team-proposal-trust-levels-1613584473422.pdf</a> talks about versioned MIR. Would this just be a highlevel description, or would it be a binary format that could be used as part of .rmeta files?</p>",
        "id": 226700355,
        "sender_full_name": "bjorn3",
        "timestamp": 1613585654
    },
    {
        "content": "<p>Based on reading the meeting notes, having a binary format is the intention.</p>",
        "id": 226702111,
        "sender_full_name": "bjorn3",
        "timestamp": 1613586331
    },
    {
        "content": "<p>In that case it would also be necessary to somehow serialize the whole typesystem.</p>",
        "id": 226702167,
        "sender_full_name": "bjorn3",
        "timestamp": 1613586351
    },
    {
        "content": "<p>As for the point of Josh against letting others produce MIR that some things are less well tested, miri has an open issue about wanting to create arbitrary MIR to be able to test that miri catches certain UB that only happens on MIR that a bug-free rustc wouldn't produce.</p>",
        "id": 226703248,
        "sender_full_name": "bjorn3",
        "timestamp": 1613586655
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/miri/issues/196\">https://github.com/rust-lang/miri/issues/196</a></p>",
        "id": 226703364,
        "sender_full_name": "bjorn3",
        "timestamp": 1613586707
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Absolutely, and I think that's a good idea. The only reason I mentioned it was that <em>until</em> we've done that, the \"surface area\" of MIR that isn't generated by rustc is more problematic.</p>",
        "id": 226703488,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613586749
    },
    {
        "content": "<p>So if there's a desire to be able to do that, we'd want to look closely at that verification work.</p>",
        "id": 226703552,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613586779
    },
    {
        "content": "<p>Also, the idea of generating MIR from another language entirely is really interesting.</p>",
        "id": 226703773,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613586852
    },
    {
        "content": "<p>Indeed</p>",
        "id": 226703866,
        "sender_full_name": "bjorn3",
        "timestamp": 1613586888
    },
    {
        "content": "<p>/me wonders how hard it would be to build a C-to-MIR compiler.</p>",
        "id": 226703874,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613586893
    },
    {
        "content": "<p>Hmmm. Is the expectation that borrow checking will always be based on MIR (in the NLL/Polonius world), or in theory could there be a better way to borrow-check that this would limit us from?</p>",
        "id": 226704134,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613586987
    },
    {
        "content": "<p>there's an MCP for moving it to THIR</p>",
        "id": 226704950,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1613587341
    },
    {
        "content": "<p>accepted MCP, actually <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/refactor.20the.20unsafe.20checking.20to.20work.20on.20t.E2.80.A6.20compiler-team.23402\">https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/refactor.20the.20unsafe.20checking.20to.20work.20on.20t.E2.80.A6.20compiler-team.23402</a></p>",
        "id": 226704984,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1613587355
    },
    {
        "content": "<p>That seems relevant.</p>",
        "id": 226704992,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1613587359
    },
    {
        "content": "<p>\"unsafe checking\" != \"borrow checking\"</p>",
        "id": 226705059,
        "sender_full_name": "pnkfelix",
        "timestamp": 1613587393
    },
    {
        "content": "<p>(i dont think borrow-checking is going to move to THIR.)</p>",
        "id": 226705102,
        "sender_full_name": "pnkfelix",
        "timestamp": 1613587413
    },
    {
        "content": "<p>oh oops, sorry</p>",
        "id": 226705111,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1613587419
    },
    {
        "content": "<p>The current borrow checking needs a CFG of some sort. MIR is <strong>the</strong> CFG representation of rustc.</p>",
        "id": 226705352,
        "sender_full_name": "bjorn3",
        "timestamp": 1613587511
    },
    {
        "content": "<p>I have been thinking about a way to stabilize part of the crate metadata without stabilizing it completely in the past. While I was thinking about having tools like bindgen generate metadata that could directly be embedded into C static archives, I think it would also be useful for this case. Basically the metadata is split into multiple tables. One defining the basic structure of a crate with all module, type and function names. One for type definitions. One for MIR, one for spans and so on. The individual tables could be independently stabilized and versioned. Each tool and compiler would also be allowed to define new table types that are private to that tool. At the time I was thinking about the MIR, span tables and things like that being private to rustc, but in this case the MIR table would not be private, but instead versioned without stabilizing. In my idea the table defining the basic structure of a crate and the one defining type definitions would eventually be stable, but the <code>Rust</code> <code>#[repr]</code> wouldn't be. Only things like <code>C</code> and <code>packed</code>.</p>",
        "id": 226707051,
        "sender_full_name": "bjorn3",
        "timestamp": 1613588191
    },
    {
        "content": "<p>I think it would be <em>plausible</em> to move borrow checking to THIR in a polonius-based world</p>",
        "id": 226707195,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1613588255
    },
    {
        "content": "<blockquote>\n<p>There could be UB in Rust surface syntax that doesn't surface in MIR</p>\n</blockquote>\n<p>This is also a concern for Miri. It can be mitigated by adding special MIR instructions to represent the surface-level UB. I think representing all UB on the MIR level should be an explicit goal of a proper MIR spec -- if we cannot reach that code, surface Rust needs a full self-contained spec on its own, duplicating a lot of effort. If we want to specify surface Rust by translation to (a dialect of) MIR, we need all UB represented in MIR.</p>",
        "id": 227178971,
        "sender_full_name": "RalfJ",
        "timestamp": 1613925540
    },
    {
        "content": "<blockquote>\n<p>stablish MIRI as a minimal but extendable automated prover for MIR</p>\n</blockquote>\n<p>I am not entirely sure what you mean by \"prover\" -- do you really mean to extend Miri with e.g. symbolic execution, or do you mean \"interpreter that is able to 'prove' UB-freedom of a single execution\"?</p>",
        "id": 227179111,
        "sender_full_name": "RalfJ",
        "timestamp": 1613925716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'm wondering if that case can occur outside of unsafe Rust?</p>",
        "id": 227244497,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1613988995
    },
    {
        "content": "<p>From an industry perspective, \"unsafe is out of scope\" for the first iteration is okay.</p>",
        "id": 227244579,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1613989054
    },
    {
        "content": "<p>outside unsafe Rust there's no UB (or so we think :D)... I don't think I understand the question</p>",
        "id": 227245267,
        "sender_full_name": "RalfJ",
        "timestamp": 1613989398
    },
    {
        "content": "<p>Well, I just wanted to understand in which section of the specification process that would become an issue.</p>",
        "id": 227252131,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1613993188
    },
    {
        "content": "<p>Fundamentally, safe rust is a <em>subset</em> of the \"full\" unsafe rust language. So, saying that we can skip over it means that i think your initial specification will have some unfortunate holes. Like saying you want to specify \"English but without adverbs\".</p>",
        "id": 227287829,
        "sender_full_name": "Lokathor",
        "timestamp": 1614009239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> which, in safety-critical industries is - and that's unintuitive - fine. you don't need completeness, you need to know where the holes are.</p>",
        "id": 227288249,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614009389
    },
    {
        "content": "<p>well if you think so then i won't stop you, but you're right that it feels unintuitive.</p>",
        "id": 227288597,
        "sender_full_name": "Lokathor",
        "timestamp": 1614009507
    },
    {
        "content": "<p>Well, the thorny bit is: \"is it blocking anything if we take that approach as a priority guidance\"?</p>",
        "id": 227288726,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614009563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> when you mean \"unsafe is out of scope\", do you mean \"unsafe code the user writes\" or \"unsafe code anywhere in the program\"? The latter seems impractical, but if there's unsafe code <em>anywhere</em> in the program then the spec better be able to talk about it, no?</p>",
        "id": 227396303,
        "sender_full_name": "RalfJ",
        "timestamp": 1614068947
    },
    {
        "content": "<p>You can treat functions with unsafe e.g. stdlib functions as black boxes at that point.</p>",
        "id": 227402452,
        "sender_full_name": "isHavvy",
        "timestamp": 1614072559
    },
    {
        "content": "<p>exactly</p>",
        "id": 227403682,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614073253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/.22Improving.20trust.20in.20the.20Rust.20compiler.22.20design.20meeting/near/227396303\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"215333\">Florian Gilcher</span> when you mean \"unsafe is out of scope\", do you mean \"unsafe code the user writes\" or \"unsafe code anywhere in the program\"? The latter seems impractical, but if there's unsafe code <em>anywhere</em> in the program then the spec better be able to talk about it, no?</p>\n</blockquote>\n<p>What I'm trying to convey is that we have choice of path here. The reason I'm asking for dependencies is that, as Havvy says \"assume all unsafe blocks correct\" is a possible starting point if there's not dependencies.</p>",
        "id": 227403850,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614073339
    },
    {
        "content": "<p>ah, yes, if we just assume unsafe is correct it does narrow the scope quite a bit</p>",
        "id": 227474429,
        "sender_full_name": "Lokathor",
        "timestamp": 1614103053
    },
    {
        "content": "<p>I am confused now. This was (I think) a reaction to my reaction to the statement \"There could be UB in Rust surface syntax that doesn't surface in MIR\". How is that even a concern if we assume unsafe code in the stdlib is correct?</p>",
        "id": 228054452,
        "sender_full_name": "RalfJ",
        "timestamp": 1614427867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> well, my question is rather: _if_ we made the assumption that unsafe blocks are correct for now, would that cause the problems down the line? i'm also not sure where stdlib comes in, because checking libstd is a whole different can of worms.</p>",
        "id": 228207028,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614594214
    },
    {
        "content": "<p>It's rather a question of ordering and untangling the process.</p>",
        "id": 228207068,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614594239
    },
    {
        "content": "<p>I think what Ralf is trying to say is that if \"unsafe blocks are correct\" then \"there is no UB at all\", so the question is what the purpose of the statement \"unsafe blocks are correct\" is.</p>",
        "id": 228209576,
        "sender_full_name": "oli",
        "timestamp": 1614595402
    },
    {
        "content": "<p>ah, i guess we're talking on different levels here. i don't think that statement is useful.</p>",
        "id": 228216328,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614599124
    },
    {
        "content": "<p>I'd call it \"unsafe blocks are unknown and need to be manually verified for now\" is the statement I'm going for.</p>",
        "id": 228216355,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614599145
    },
    {
        "content": "<p>the challenge is: manually verified against <em>what</em></p>",
        "id": 228304776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614632307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> if we ignore <code>unsafe</code> blocks we could write a spec where UB isn't a thing (or where we just cover the \"obvious\" UB but dont try to make it exhaustive). I think that is a useful stepping-stone indeed. However, I'd still do that entirely on the MIR level, and I foresee no problems there -- precisely <em>because</em> we do not want to fully capture UB.<br>\nIt is only when capturing UB becomes a goal that we have to worry \"does MIR reflect all the UB we want to have on the surface level\".</p>",
        "id": 228387604,
        "sender_full_name": "RalfJ",
        "timestamp": 1614681493
    }
]