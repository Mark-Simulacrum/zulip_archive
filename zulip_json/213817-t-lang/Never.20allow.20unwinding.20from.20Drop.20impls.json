[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/lang-team/issues/97\">https://github.com/rust-lang/lang-team/issues/97</a> was posted by Josh T.</p>",
        "id": 242125527,
        "sender_full_name": "Lokathor",
        "timestamp": 1623270710
    },
    {
        "content": "<p>I'm quite honestly baffled at the proposal because I don't see how this can done in a backwards compatible way. Even if it's changed in a new edition then code would have to cope with potentially something from an old edition still being involved.</p>",
        "id": 242125902,
        "sender_full_name": "Lokathor",
        "timestamp": 1623270871
    },
    {
        "content": "<p>And I know that this is intentionally done from time to time. For example, some graphics crates for Vulakn-style APIs will panic in debug mode if a handle is dropped rather than disposed of properly.</p>",
        "id": 242126027,
        "sender_full_name": "Lokathor",
        "timestamp": 1623270935
    },
    {
        "content": "<p>To be clear, I'm <em>not</em> proposing that we can change this universally.</p>",
        "id": 242126535,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623271135
    },
    {
        "content": "<p>Rather, we could potentially plan a transition in which all <em>new</em> code can't rely on this. We could, as one possible path, introduce a variant of <code>panic=unwind</code> that doesn't allow unwind from drop impls, and eventually make that the default. Then, crates would have to explicitly change their panic strategy if they want to allow unwind-from-Drop.</p>",
        "id": 242126736,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623271224
    },
    {
        "content": "<p>And at some point, this may thus become rare enough that it's safe for code to just say \"this crate doesn't support being compiled with unwind-from-Drop allowed\".</p>",
        "id": 242126800,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623271259
    },
    {
        "content": "<p>That sounds good but also makes me think thay there should be a way to say that in a crate's code and not just in the Cargo.toml</p>",
        "id": 242126989,
        "sender_full_name": "Lokathor",
        "timestamp": 1623271341
    },
    {
        "content": "<p>There are also mitigation strategies we could use in concert with the library team, such as automatically wrapping any object received via <code>catch_unwind</code> such that its <code>Drop</code> implementation is wrapped in <code>catch_unwind</code> and then just gets <code>mem::forget</code> called on it if it attempts to unwind-from-Drop.</p>",
        "id": 242126991,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623271343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Thanks for raising the need for clarification. I posted <a href=\"https://github.com/rust-lang/lang-team/issues/97#issuecomment-858087744\">https://github.com/rust-lang/lang-team/issues/97#issuecomment-858087744</a> to capture that in-thread.</p>",
        "id": 242127296,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623271515
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[cfg(not(panic_style=</span><span class=\"s\">\"not-in-drop\"</span><span class=\"cp\">))]</span><span class=\"w\"></span>\n<span class=\"fm\">compile_error!</span><span class=\"p\">(</span><span class=\"s\">\"this crate requires that drop cannot panic\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 242127673,
        "sender_full_name": "Lokathor",
        "timestamp": 1623271682
    },
    {
        "content": "<p>Something along those lines, sure.</p>",
        "id": 242129678,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623272601
    },
    {
        "content": "<p>(The same way that crates should be able to say \"I <em>require</em> panic unwind, and don't support panic abort\", or vice versa.)</p>",
        "id": 242129723,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623272618
    },
    {
        "content": "<p>Tbf, I'm not fond of that approach, if it can't be made universal: <em>library</em> code using <code>catch_unwind</code> will still need to take into account the cases where a downstream user may not disable panics in drops. So using a cfg like <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> has done, then becomes mandatory, which means library authors would need to be aware of the issue: <strong>we are back to square one</strong> (except for the cfg being a bit easier to write than setting up an abort-on-panic guard before dropping the panic payload).</p>",
        "id": 242184865,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1623320272
    },
    {
        "content": "<p>Panic on drop is a huge mess. Even if we are able to handle it soundly in std collections like Vec, it still causes memory leaks since we don't continue dropping elements and freeing the underlying memory after a drop has panicked.</p>",
        "id": 242187607,
        "sender_full_name": "Amanieu",
        "timestamp": 1623322068
    },
    {
        "content": "<p>It's also tricky to handle soundly: in the past <code>smallvec</code> and <code>arrayvec</code> have been unsound when faced with panicking drops. They are fixed now, although they still leak memory.</p>",
        "id": 242187727,
        "sender_full_name": "Amanieu",
        "timestamp": 1623322145
    },
    {
        "content": "<p>I personally feel that panic-on-drop is an anti-feature: you really shouldn't be relying on it, and if you are then you should transition away from it ASAP. Making drops abort on panic will help with this transition.</p>",
        "id": 242187847,
        "sender_full_name": "Amanieu",
        "timestamp": 1623322223
    },
    {
        "content": "<p>In the Vulkan example mentioned by <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>, this is essentially a debugging helper. It would work just as well as an abort rather than as an unwind. Note that the panic message is still printed during an abort, it's just that we refused to unwind past the drop.</p>",
        "id": 242188010,
        "sender_full_name": "Amanieu",
        "timestamp": 1623322336
    },
    {
        "content": "<p>Sorry I should have clarified: I don't think that <em>almost always</em> preventing unwinding from drops is really gonna help that much <em>w.r.t.</em> the related <code>catch_unwind</code> issue, as I mentioned, since the fact this doesn't happen 100% of the cases means special handling is still required, as is the special handling for <code>smallvec</code> and <code>arrayvec</code>. Should the change happen <em>always</em>, then that's another story, but I can imagine how that feature could somehow be relied on by some specific crate (obviously a crater run and other investigation would be required to avoid these speculative assumptions). And I personally do agree that expecting a panic in a drop impl to be recoverable (because this is what the question is all about, since, as you mentioned, the panic hook still gets called before the abort) seems oddly niche, and leads to many footguns. So I am not against the approach <em>per se</em>, I am just skeptical of its usefulness to act as a real anti-footgun tool should it not be made universal, and I agree with <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>'s concerns that making it universal is, <em>potentially</em>, problematic on its own.</p>",
        "id": 242192972,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1623325551
    },
    {
        "content": "<p>I am personally in favor of making it universal, for the reasons I stated above.</p>",
        "id": 242211491,
        "sender_full_name": "Amanieu",
        "timestamp": 1623333923
    },
    {
        "content": "<p>im wondering if there's a missing language feature (other than linear types) that is motivating most of these panic-on-drop types</p>",
        "id": 242243673,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623346828
    },
    {
        "content": "<p>like, I'm agreeing that it's an anti feature but I'm curious what holes in the lang we're leaving / expanding by removing it</p>",
        "id": 242243784,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623346876
    },
    {
        "content": "<p>I wouldn't be surprised if it's often just \"I need to call a close function and that function can return an error\".</p>",
        "id": 242243945,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623346941
    },
    {
        "content": "<p>I think that's kinda just describing linear types again</p>",
        "id": 242244118,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623347036
    },
    {
        "content": "<p>\"I need to make sure this resource is disposed of properly and errors handled\"</p>",
        "id": 242244205,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623347065
    },
    {
        "content": "<p>I should go reread gankra's post on linear types to remind me why they're bad</p>",
        "id": 242244255,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623347096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242243945\">said</a>:</p>\n<blockquote>\n<p>I wouldn't be surprised if it's often just \"I need to call a close function and that function can return an error\".</p>\n</blockquote>\n<p>So one example, going back to the Vulkan-like API stuff: \"I need to call a close function but I can't call it on my own because I don't have all the data.\"</p>\n<p>Say you have a Device and that can spawn a Pool value. Then, to close the Pool you call <code>close_pool(device, pool)</code>. When you drop a Pool value on its own... well it doesn't store the Device it came from, and so it can't call <code>close_pool</code> on its own.</p>",
        "id": 242255266,
        "sender_full_name": "Lokathor",
        "timestamp": 1623352030
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> gankra's blog post on linear types had an interesting suggestion on how to emulate them using closures</p>",
        "id": 242256057,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623352446
    },
    {
        "content": "<p><code>with_step1&lt;R, F: FnOnce(Step1Token) -&gt; (R, Step3Token)&gt;(f: F) -&gt; R</code> is the example she gave</p>",
        "id": 242256149,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623352492
    },
    {
        "content": "<p>so something like <code>with_pool&lt;R, F: FnOnce(&amp;mut Device, Pool) -&gt; (R, ClosedPool)&gt;(f: F) -&gt; R</code></p>",
        "id": 242256260,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623352550
    },
    {
        "content": "<p>hmm, I'm not sure that would work well for graphical API usage. These things are \"usually long lived\" sorts of things, hopefully for the life of the entire program effectively, though sometimes disaster strikes (eg: the user changes some graphical setting) and you have to tear down and rebuild the world in that rare case.</p>",
        "id": 242256819,
        "sender_full_name": "Lokathor",
        "timestamp": 1623352802
    },
    {
        "content": "<p>and it usually sucks when you have to put the entire rest of your program in a closure</p>",
        "id": 242256900,
        "sender_full_name": "Lokathor",
        "timestamp": 1623352820
    },
    {
        "content": "<p>sure, but from my perspective having a debug only assert in a drop impl to try and catch potential misuse is also kinda sucky, gotta get that static verification</p>",
        "id": 242257072,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623352910
    },
    {
        "content": "<p>just trying to find alternatives that don't cause UB but still solve the same problem</p>",
        "id": 242257163,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623352933
    },
    {
        "content": "<p>I'm also wondering, what is it specifically  are the downsides of wrapping your whole program in a closure</p>",
        "id": 242257449,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353046
    },
    {
        "content": "<p>and can we mitigate them?</p>",
        "id": 242257455,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353049
    },
    {
        "content": "<p>well, if i were writing such a lib myself i'd probably just put in a debug-only message in the Drop impl, maybe use track_caller or whatever and then say \"this line dropped me but it shouldn't have\"</p>",
        "id": 242257490,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353068
    },
    {
        "content": "<p>I feel like that's even less likely to get caught before shipping something to prod</p>",
        "id": 242257529,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353091
    },
    {
        "content": "<p>a debug message?</p>",
        "id": 242257567,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353109
    },
    {
        "content": "<p>yea</p>",
        "id": 242257574,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353113
    },
    {
        "content": "<p>unless you're specifically checking the logs for that debug message on all your tests</p>",
        "id": 242257603,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353127
    },
    {
        "content": "<p>oh, haha, \"what tests?\"</p>",
        "id": 242257623,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353139
    },
    {
        "content": "<p>lol</p>",
        "id": 242257647,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353146
    },
    {
        "content": "<p>this is graphics / gamedev, there's generally no automatic tests, you generally just actually run the program</p>",
        "id": 242257710,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353164
    },
    {
        "content": "<p>and once the outer \"shell\" of the program's graphical control flow is set up, there's very rarely a reason to change it</p>",
        "id": 242257781,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353209
    },
    {
        "content": "<p>I see</p>",
        "id": 242257857,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353237
    },
    {
        "content": "<p>okay well actually, going back to your comment on using a debug print instead of a panic</p>",
        "id": 242257886,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353255
    },
    {
        "content": "<p>that seems support the idea that we can remove unwinding from drop without completely ruining the workflow for this vulkan API</p>",
        "id": 242257935,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353279
    },
    {
        "content": "<p>oh absolutely, they don't <em>need</em> to be able to panic in drop (as evidenced by the fact that release builds don't)</p>",
        "id": 242258029,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353311
    },
    {
        "content": "<p>wondering what other examples there are of crates who absolutely need to unwind from a panic</p>",
        "id": 242258090,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353344
    },
    {
        "content": "<p>did you mean \"need to unwind from a drop\"?</p>",
        "id": 242258266,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353417
    },
    {
        "content": "<p>yes</p>",
        "id": 242258563,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353545
    },
    {
        "content": "<p>lol</p>",
        "id": 242258564,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353546
    },
    {
        "content": "<p>the tweet got it right: <a href=\"https://twitter.com/yaahc_/status/1403072447943827458?s=20\">https://twitter.com/yaahc_/status/1403072447943827458?s=20</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/yaahc_/status/1403072447943827458?s=20\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/eeaff3a60f7422ff43d15ea1fba5c17154dd4cc3/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313236303734363233383532373332343136322f6f4d4a48724846435f6e6f726d616c2e6a7067\"></a><p>So, we ran into a cool bug with `catch_unwind` and are considering making panic in drop unconditionally abort. Now we need to get a better idea of what crates depend on this behavior.\n\nCan anyone think of crates that specifically rely on being able to unwind out of `Drop` impls?</p><span>- Yaah ðŸ¦€ (@yaahc_)</span></div></div>",
        "id": 242258585,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623353558
    },
    {
        "content": "<p>The <code>yacurses</code> crate <em>very strongly</em> wants to have an unwind occur rather than an abort</p>",
        "id": 242258628,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353583
    },
    {
        "content": "<p>but the worst that happens in the case of an abort is that your terminal is all thrashed up</p>",
        "id": 242258656,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353598
    },
    {
        "content": "<p>but it doesn't trigger the unwind during Drop, it just wants to get dropped instead of forgotten</p>",
        "id": 242258797,
        "sender_full_name": "Lokathor",
        "timestamp": 1623353656
    },
    {
        "content": "<p>Yeah, I think that unlikely bugs introduced by non-unwinding panics in drop could actually always be circumvented by having the caller use an explicit destroying function. Or, in other words, the only cases where this could be required would only need a special/intrinsic/lang dropping function <code>mem::drop_and_catch_unwind()</code> (such a function could be <code>ManuallyDrop::drop</code>). I definitely prefer a targeted opt-in over the current situation, for sure. The more I think about this, the more I agree that applying this change universally should be fine</p>",
        "id": 242261493,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1623354911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242125902\">said</a>:</p>\n<blockquote>\n<p>I'm quite honestly baffled at the proposal because I don't see how this can done in a backwards compatible way. Even if it's changed in a new edition then code would have to cope with potentially something from an old edition still being involved.</p>\n</blockquote>\n<p>I wanna revisit this comment, specifically, in what ways is this a breaking change?</p>",
        "id": 242268317,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623357941
    },
    {
        "content": "<p>the one I can think of is that panics in drops that were formerly caught would now take down the application</p>",
        "id": 242268328,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623357950
    },
    {
        "content": "<p>this isn't a breaking change from a library perspective because to them panics are already either unwind or abort</p>",
        "id": 242268448,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623358002
    },
    {
        "content": "<p>maybe we don't need to worry about this from a perspective of different edition crates linking together, and instead focus on the edition of the binary itself</p>",
        "id": 242268532,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623358050
    },
    {
        "content": "<p>so it would be \"If the current application is 2021 edition or later and panic = unwind then drops in panics are all aborts\"</p>",
        "id": 242268689,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623358108
    },
    {
        "content": "<p>one case where i think people could be upset by this is the people who want to replace alloc failure==abort with alloc failure==panic. of course, this isn't really breaking, since this isn't a supported configuration at all</p>",
        "id": 242269344,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1623358397
    },
    {
        "content": "<p>even if you compile as panic=unwind though, in general you can't really expect a panic in Drop to always unwind even today, since it will abort if you panic in a drop when already unwinding</p>",
        "id": 242269512,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1623358484
    },
    {
        "content": "<p>one other downside is that crates with this in their drop (imagine <code>some_error</code> is something like an IO error during close)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"fm\">cfg!</span><span class=\"p\">(</span><span class=\"n\">debug_assertions</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"error with blah: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_error</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">log</span>::<span class=\"n\">error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"error with blah: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_error</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>will probably start failing to report a useful message. or at least, the current \"nevermind, just abort\" behavior under panic=unwind doesn't report the message to anything, iirc.</p>",
        "id": 242270060,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1623358749
    },
    {
        "content": "<p>even with an aborting panic the panic hook still runs so you still get your error output</p>",
        "id": 242270687,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1623359022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242268317\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242125902\">said</a>:</p>\n<blockquote>\n<p>...</p>\n</blockquote>\n<p>I wanna revisit this comment, specifically, in what ways is this a breaking change?</p>\n</blockquote>\n<p>Because (to quote the issue) \"decide at the language level to generally not allow unwind from Drop impls\" without any further clarification sounds like \"it's now a build error\" or \"it's not a build error but it's UB\".</p>",
        "id": 242273659,
        "sender_full_name": "Lokathor",
        "timestamp": 1623360439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242270687\">said</a>:</p>\n<blockquote>\n<p>even with an aborting panic the panic hook still runs so you still get your error output</p>\n</blockquote>\n<p>This is true for panic=abort, but at least currently, under panic=unwind, when an aborting panic is performed it's a \"hard\" abort, e.g. core::intrinsics::abort, no hook called. Would this be different?</p>",
        "id": 242274543,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1623360962
    },
    {
        "content": "<p>hooks are a libstd thing, not a language one. So two somewhat different domains. I imagine in that respect panics within drops would either not call any hooks, or once they are invoked (and their hooks run) caught and cause an abort.</p>",
        "id": 242274664,
        "sender_full_name": "nagisa",
        "timestamp": 1623360998
    },
    {
        "content": "<p>Hm, actually now that I think about it, the panic strategy implementation would be able to decide however it wants to implement the panic in the drop glue.</p>",
        "id": 242275419,
        "sender_full_name": "nagisa",
        "timestamp": 1623361490
    },
    {
        "content": "<p>and i bet <code>core::intrinsics::abort</code> can UB on some embedded targets if the program counter doesn't have anywhere to go to.</p>",
        "id": 242276598,
        "sender_full_name": "Lokathor",
        "timestamp": 1623362196
    },
    {
        "content": "<p>I do have a question for this:<br>\nIf you panic in drop, and catch_unwind it before it escapes the drop, would it still abort (assuming it's not rethrown)?</p>",
        "id": 242281537,
        "sender_full_name": "Connor Horman",
        "timestamp": 1623365389
    },
    {
        "content": "<p>I can't imagine how that could possibly abort; the panic/catch might well be in a function called by drop</p>",
        "id": 242283731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623367053
    },
    {
        "content": "<p>What I worry about is that a nonuniversal (opt-out, edition-in, w/e) change is basically no better than no change for library code. Library code still has to handle the case where a caught panic payload panics on drop. So the footgun is still there, just mitigated in the common case (the payload drop aborting rather than panicking). (Good) Library code still has to be written under the assumption that a caught unwind payload could panic on drop.</p>\n<p>On the other hand, I _highly_ doubt that anyone is using the fact that they can unwind from the drop code of a panic payload, and have it \"work\". While the first layer of drop code unwinding is reasonable enough (for e.g. fault tolerant runtimes catching and aborting just the task/thread that failed, not the entire process), the second panic _feels_ like a panic-in-panic that should cause an abort. Dtolnay's posted what seems like a clean implementation strategy for converting the payload's drop code to be aborting rather than unwinding, so it's at least feasible.</p>\n<p>I think I would (theoretically) prefer in general if drop code was guaranteed not to unwind, via an abort-at-edge like <code>extern \"C\"</code> functions are planned to. All existing panics in drops are potential aborts already, and as I understand it, it would make lib and generated code simpler to not have to handle that case. (Lib code that would still have to handle it in the usually-but-not-always abort case.) I just worry about changing this breaking stability, and for what's even technically not a language soundness issue, but \"just\" a (common) stdlib footgun that commonly leads to soundness issues in libraries. Thus fixing <code>catch_unwind</code> feeling like the \"correct\" choice to me.</p>\n<p>One final thing worth noting, though, is that forcing an abort for panics in (unwind payload) drop impls prevents the \"smoothest\" solution: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=42f7dfad88f4a4f664f4e9adc474fe36\">attempt to drop the payload, then leak it if you can't</a>. (This would miss the case of a finite stack of panicking unwind payloads, but that's pretty clearly even _more_ degenerate.) This _could_ be accomplished by a replacement function that returns a custom error type (e.g. <code>UnwindPayload</code>) that wraps <code>Box&lt;dyn Any + Send + 'static&gt;</code> and implements the drop-or-leak semantics.</p>",
        "id": 242286584,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1623369710
    },
    {
        "content": "<p>That's a big message, so TL;DR I'm against making <code>Drop::drop</code> abort when a panic escapes if it only happens less than always (when compiling with rustc &gt;= 1.Future), but would be for either making it abort always (not configurable) or making <code>catch_unwind</code> (or its replacement) suppress the unwind of the caught unwind payload (via leak or abort).</p>",
        "id": 242286820,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1623369901
    },
    {
        "content": "<p>Also, it's worth noting that making it abort-at-edge would trivially make the panic in the drop behave normally and call the hook, since it would still unwind from the throw to the catch-and-abort edge. I would be against making panic-in-drop an instant panic-in-panic style give-up-abort, since that would prevent the use of <code>catch_unwind</code> to prevent the abort. (<code>catch_unwind</code> doesn't currently work to prevent panic-in-panic aborts, but it does work to prevent drop from panicking in the first place.)</p>",
        "id": 242287373,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1623370388
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132829\">@Christopher Durham</span> You make a fair point; while I'd <em>like</em> to just disallow unwind from drop in <em>all</em> cases, it may be more tenable to just disallow unwind from the drop of a panic payload, which is probably something ~nobody is using.</p>",
        "id": 242287480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1623370541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> How does that work? Turn panics into abort for destructors of values that are panic payloads? How does the value's <code>drop</code> method know, at runtime, whether it has been (part of?) a panic payload?</p>",
        "id": 242307552,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1623394751
    },
    {
        "content": "<p>The payloads are boxed as dyn traits. The proposed approach was to substitute the vtable.</p>",
        "id": 242314558,
        "sender_full_name": "The 8472",
        "timestamp": 1623399882
    },
    {
        "content": "<p>Rustc uses a panicking drop impl to ensure that every <code>Diagnostic</code> is either emitted or canceled. If the panic turned into an abort, that would mean that rls crashes if a <code>Diagnostic</code> gets dropped. While for rls I guess it would be fine for the user to restart it, what about if something like this is done in a web server? A panic there should most of the time only cancel the current request (returning a 500 internal server error to the user) and not bring down the whole server as an abort would.</p>",
        "id": 242320309,
        "sender_full_name": "bjorn3",
        "timestamp": 1623403473
    },
    {
        "content": "<p>A while ago I also saw an OS that used rust for software isolation. When a process crashed (panicked or a segv), it would unwind the stack and run all destructors to release resources back to the os. Aborting on panic would either bring down the whole system or unwind anyway.</p>",
        "id": 242321149,
        "sender_full_name": "bjorn3",
        "timestamp": 1623403965
    },
    {
        "content": "<p>Panicking in a drop will most likely leak memory, which is something that you really don't want in a web server.</p>",
        "id": 242336949,
        "sender_full_name": "Amanieu",
        "timestamp": 1623414181
    },
    {
        "content": "<p>FWIW: My crate <code>with-str-bytes</code> would be broken by this change, although I could easily fix it. What it does is makes use of a guard to check that invariants have not been broken after running a closure, fixing the invariants <a href=\"https://github.com/Kestrer/with-str-bytes/blob/master/src/lib.rs#L56\">and panicking</a> if they have been. I am not sure how prevalent this pattern is across the ecosystem though.</p>",
        "id": 242354172,
        "sender_full_name": "Kestrer",
        "timestamp": 1623422226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360486\">@Kestrer</span> this seems like a good use case for my suggested opt-out (<em>e.g.</em>, <code>.drop_and_catch_unwind()</code>).</p>\n<p>That being said, for your very example, you could also move the <code>else</code> logic from the drop body directly into <a href=\"https://github.com/Kestrer/with-str-bytes/blob/c297c835327b986423f0bd2aadda884c437dba48/src/lib.rs#L66\">https://github.com/Kestrer/with-str-bytes/blob/c297c835327b986423f0bd2aadda884c437dba48/src/lib.rs#L66</a>, and everything would Just Workâ„¢</p>",
        "id": 242358095,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1623423986
    },
    {
        "content": "<p>Is that panic meant to inform the developer of a programming error or is the idea that this can occasionally happen during runtime? If it is the former then turning the panic into an abort would still be fine, no?</p>",
        "id": 242359132,
        "sender_full_name": "The 8472",
        "timestamp": 1623424395
    },
    {
        "content": "<p>A panic is only supposed to be used for a programming error or highly unlikely errors. If the error is expected it should be an <code>Result</code>. Depending on the kind of program you have you just may want to catch panics and gracefully fail by for example giving an error for a single http request or only crash a single tab in a browser. Aborting should only happen when it is no longer possible to continue without risking memory safety issues or other security issues.</p>\n<p>expected to sometimes happen: <code>Result</code><br>\nrecoverable highly unlikely or programming error: <code>panic!()</code><br>\nunrecoverable in any way: <code>process::abort()</code></p>",
        "id": 242363057,
        "sender_full_name": "bjorn3",
        "timestamp": 1623426108
    },
    {
        "content": "<p>Yeah, my question was whether the examples given so far fall under the \"highly unlikely\" vs. \"programming error\" category.</p>",
        "id": 242364628,
        "sender_full_name": "The 8472",
        "timestamp": 1623426775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242258797\">said</a>:</p>\n<blockquote>\n<p>but it doesn't trigger the unwind during Drop, it just wants to get dropped instead of forgotten</p>\n</blockquote>\n<p>I dont think there is any proposal to change that? This thread is specifically about triggering the unwind (calling <code>panic!</code>) during Drop</p>",
        "id": 242456128,
        "sender_full_name": "RalfJ",
        "timestamp": 1623511281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242276598\">said</a>:</p>\n<blockquote>\n<p>and i bet <code>core::intrinsics::abort</code> can UB on some embedded targets if the program counter doesn't have anywhere to go to.</p>\n</blockquote>\n<p>that would be a wrong implementation, AFAIK <code>abort</code> is a safe intrinsic these days. It is certainly treated as such by libstd.<br>\nembedded targets can always <code>loop {}</code>.</p>",
        "id": 242456144,
        "sender_full_name": "RalfJ",
        "timestamp": 1623511317
    },
    {
        "content": "<p>Right, I know Ralf. I'm saying \"the closest I can think of is X, even though that isn't the same\".</p>",
        "id": 242456919,
        "sender_full_name": "Lokathor",
        "timestamp": 1623512247
    },
    {
        "content": "<p>Also, as to <code>abort</code>:</p>\n<ul>\n<li><code>core::intrinsics::abort</code> is unsafe and unstable.</li>\n<li><code>std::process::abort</code> is safe and stable.</li>\n</ul>",
        "id": 242457168,
        "sender_full_name": "Lokathor",
        "timestamp": 1623512590
    },
    {
        "content": "<blockquote>\n<p>core::intrinsics::abort is unsafe and unstable.</p>\n</blockquote>\n<p>That's what I am saying: this is wrong.<br>\n<code>intrinsics::abort</code> is <a href=\"https://github.com/rust-lang/rust/blob/003b8eadd7a476c51956fe447894532d6e21937e/compiler/rustc_typeck/src/check/intrinsic.rs#L59\">safe</a> (and unstable).</p>",
        "id": 242460957,
        "sender_full_name": "RalfJ",
        "timestamp": 1623517215
    },
    {
        "content": "<blockquote>\n<p>/// Returns <code>true</code> if the given intrinsic is unsafe to call or not.<br>\npub fn intrinsic_operation_unsafety(intrinsic: Symbol) -&gt; hir::Unsafety {</p>\n</blockquote>\n<p>what a trigger huh</p>",
        "id": 242462037,
        "sender_full_name": "nagisa",
        "timestamp": 1623518960
    },
    {
        "content": "<p>Well, I'm just saying what the standard library calls it. They're the ones calling it unsafe.</p>",
        "id": 242465793,
        "sender_full_name": "Lokathor",
        "timestamp": 1623524261
    },
    {
        "content": "<p>I really don't know how you'd even actually implement a general core abort, is one thing.</p>",
        "id": 242465859,
        "sender_full_name": "Lokathor",
        "timestamp": 1623524303
    },
    {
        "content": "<p>like, a good one i mean</p>",
        "id": 242465904,
        "sender_full_name": "Lokathor",
        "timestamp": 1623524363
    },
    {
        "content": "<p>I'd do it by going through the panic handler with a special flag in <code>PanicInfo</code> which tells the handler to always abort instead of unwind.</p>",
        "id": 242466364,
        "sender_full_name": "Amanieu",
        "timestamp": 1623524914
    },
    {
        "content": "<p>That wouldn't work for</p>\n<div class=\"codehilite\"><pre><span></span><code>fn drop() {\n    panic::catch_unwind(move || { ... })\n}\n</code></pre></div>\n<p>though.</p>",
        "id": 242466455,
        "sender_full_name": "nagisa",
        "timestamp": 1623525044
    },
    {
        "content": "<p>Or would itâ€¦</p>",
        "id": 242466460,
        "sender_full_name": "nagisa",
        "timestamp": 1623525058
    },
    {
        "content": "<p>I don't see the problem?</p>",
        "id": 242466472,
        "sender_full_name": "Amanieu",
        "timestamp": 1623525092
    },
    {
        "content": "<p>So you either make panics in the <code>catch_unwind</code> panic (i.e. the behaviour of passing a special flag transitive somehow), or other arbitrary functions called by drop don't inherit the aborting behaviour if they're called from <code>drop</code>, right?</p>",
        "id": 242466558,
        "sender_full_name": "nagisa",
        "timestamp": 1623525166
    },
    {
        "content": "<p>And making this extend to the functions called by <code>drop</code>s sound like pain.</p>",
        "id": 242466572,
        "sender_full_name": "nagisa",
        "timestamp": 1623525184
    },
    {
        "content": "<p>Basically the drop function has an invisible landing pad that calls <code>core::unwind_out_of_drop_handler</code>. Which would then call the <code>panic_handler</code> with a flag that says to abort immediately instead of unwind.</p>",
        "id": 242466574,
        "sender_full_name": "Amanieu",
        "timestamp": 1623525185
    },
    {
        "content": "<p>I might be confusing the temporal order of when specific things exist and happen, I guess, because my understanding is that our unwinding implementation does not allow for deciding which landing pads will be executed before unwinding is invoked (and we invoke panic hooks before that, I think?).</p>",
        "id": 242466830,
        "sender_full_name": "nagisa",
        "timestamp": 1623525428
    },
    {
        "content": "<p>But I would definitely push for it to be implemented in a pretty similar manner â€“ the same way we implement the guard for unwinding out of <code>extern \"C\"</code> functions.</p>",
        "id": 242466908,
        "sender_full_name": "nagisa",
        "timestamp": 1623525497
    },
    {
        "content": "<p>We already have a perfect place for it too â€“ there's always some drop glue that invokes the <code>Drop::drop</code> hook. Would fit in there pretty easily.</p>",
        "id": 242467033,
        "sender_full_name": "nagisa",
        "timestamp": 1623525634
    },
    {
        "content": "<p>The temporal order would look like this:</p>\n<ol>\n<li>First panic which starts unwinding.</li>\n<li>Second panic inside a drop while unwinding.</li>\n<li>Third panic in the drop glue which forces an abort.</li>\n</ol>",
        "id": 242468379,
        "sender_full_name": "Amanieu",
        "timestamp": 1623527298
    },
    {
        "content": "<p>That's definitely not how it works currently. (Or you've misspoke sightly about order.) Currently, if you are <code>thread::panicking()</code>, causing a panic causes an immediate abort (before printing a message). This behavior is _not_ changed if you enter a <code>catch_unwind</code> landing pad.</p>",
        "id": 242471022,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1623529886
    },
    {
        "content": "<p>My understanding of the specific problematic case is:</p>\n<ol>\n<li>Some unwind is caught by <code>catch_unwind</code>.</li>\n<li>The unwind payload is dropped.</li>\n<li>Whoops, the unwind payload panics on drop!</li>\n<li>The unwind continues through the stack that was catching the prior unwind.</li>\n</ol>\n<p>The general approach of preventing unwinds from escaping drop code:</p>\n<ol>\n<li>Some unwind is caught by <code>catch_unwind</code>.</li>\n<li>The unwind payload is dropped.</li>\n<li>\n<p>In the drop glue, a <code>catch_unwind</code> landing pad is created. </p>\n<ul>\n<li>(For minimal overhead, just one at the base, not for each transitive <code>drop_in_place</code>. I think this is equivalent to providing one for each <code>drop_in_place</code>, modulo knowing which type's drop glue panicked without the stacktrace?)</li>\n</ul>\n</li>\n<li>\n<p>If that <code>catch_unwind</code> catches an unwind, cause an abort.</p>\n</li>\n</ol>\n<p>The minimal, targeted approach of preventing just the above problem case:</p>\n<ol>\n<li>Some unwind is caught by <code>catch_unwind</code>.</li>\n<li>The vtable of the caught payload is changed, such that the <code>drop_in_place</code> pointer is adjusted to an unwind-to-abort wrapped version.</li>\n<li>The unwind payload is dropped.</li>\n<li>The first thing the wrapped drop code does is set <code>thread::panicking</code>.</li>\n<li>The real drop code is called, causing a panic-while-panicking.</li>\n<li>(If the destructor ran successfully, reset <code>thread::panicking</code>.)</li>\n</ol>\n<p>Or, alternatively, the targeted solution could use a landing pad like the general solution described. I personally would like the panic-while-panicking behavior to be handled via a landing pad as well, rather than immediate abort, such that <code>catch_unwind</code> would work while already unwinding, but understand this might raise some new questions w.r.t. unwind safety, since panic-while-panicking would now cause an unwind rather than an immediate abort.</p>\n<p>Or, as a final option, add another flag for \"in unwind payload destructor\" separate from \"currently unwinding,\" and let the panic handler handle it somehow.</p>",
        "id": 242471728,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1623530879
    },
    {
        "content": "<p>I don't think panic payloads panicking is a problem in context of disallowing unwinding from Drop.</p>",
        "id": 242473124,
        "sender_full_name": "nagisa",
        "timestamp": 1623532735
    },
    {
        "content": "<p>Since we'll be aborting anyway, there's no reason for us to bother running <code>Drop</code> for the panic payload in the first place â€“ Rust doesn't guarantee that we drop things after all.</p>",
        "id": 242473139,
        "sender_full_name": "nagisa",
        "timestamp": 1623532765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242465793\">said</a>:</p>\n<blockquote>\n<p>Well, I'm just saying what the standard library calls it. They're the ones calling it unsafe.</p>\n</blockquote>\n<p>they are not... or I am totally misunderstanding what you mean here.</p>",
        "id": 242498535,
        "sender_full_name": "RalfJ",
        "timestamp": 1623573420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242462037\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>/// Returns <code>true</code> if the given intrinsic is unsafe to call or not.<br>\npub fn intrinsic_operation_unsafety(intrinsic: Symbol) -&gt; hir::Unsafety {</p>\n</blockquote>\n<p>what a trigger huh</p>\n</blockquote>\n<p>yeah, I already submitted a PR to fix the comment^^</p>",
        "id": 242498539,
        "sender_full_name": "RalfJ",
        "timestamp": 1623573431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242498535\">said</a>:</p>\n<blockquote>\n<p>or I am totally misunderstanding what you mean here.</p>\n</blockquote>\n<p>I'm saying that <a href=\"https://doc.rust-lang.org/core/intrinsics/fn.abort.html\">core::intrinsics::abort</a>, in the standard library, has a signature of:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub unsafe extern &quot;rust-intrinsic&quot; fn abort() -&gt; !\n</code></pre></div>\n<p>And thus, it is unsafe.</p>\n<p>If it's safe internally in the HIR, that's a different matter.</p>",
        "id": 242520464,
        "sender_full_name": "Lokathor",
        "timestamp": 1623603862
    },
    {
        "content": "<p>That is a rustdoc issue. This compiles fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(core_intrinsics)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">abort</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 242520564,
        "sender_full_name": "bjorn3",
        "timestamp": 1623603977
    },
    {
        "content": "<p>Hence the misunderstanding: I think that <code>::core</code> reporting that instrinsic function as <code>unsafe</code> is a rustdoc bug. EDIT: what <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> said (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=16c0888e90ea186e4513e2984fd85c12\">playground</a>)</p>",
        "id": 242520566,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1623603989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> </p>\n<blockquote>\n<p>core::intrinsics::abort, in the standard library, has a signature of</p>\n</blockquote>\n<p>it doesn't, that's what I keep saying. ;)</p>",
        "id": 242589054,
        "sender_full_name": "RalfJ",
        "timestamp": 1623673909
    },
    {
        "content": "<p>Weirdly, it does in the docs: <a href=\"https://doc.rust-lang.org/nightly/core/intrinsics/fn.abort.html\">https://doc.rust-lang.org/nightly/core/intrinsics/fn.abort.html</a></p>\n<p>All the intrinsics are unsafe.</p>",
        "id": 242590276,
        "sender_full_name": "Chris Denton",
        "timestamp": 1623674604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/213817-t-lang/topic/Never.20allow.20unwinding.20from.20Drop.20impls/near/242520564\">said</a>:</p>\n<blockquote>\n<p>That is a rustdoc issue.</p>\n</blockquote>",
        "id": 242590448,
        "sender_full_name": "bjorn3",
        "timestamp": 1623674691
    },
    {
        "content": "<p>Intrinsics are defined using <code>extern \"rust-intrinsic\" { ... }</code>. Functions defined in <code>extern</code> blocks are normally always unsafe. Typeck however has a hardcoded list of safe intrinsics. Rustdoc likely doesn't know about this list.</p>",
        "id": 242590559,
        "sender_full_name": "bjorn3",
        "timestamp": 1623674755
    },
    {
        "content": "<p>I've filed a PR to clarify in the docs that certain intrinsics are not unsafe to call: <a href=\"https://github.com/rust-lang/rust/pull/86308\">https://github.com/rust-lang/rust/pull/86308</a></p>",
        "id": 242650762,
        "sender_full_name": "bstrie",
        "timestamp": 1623700415
    },
    {
        "content": "<p>the rustdoc issue will be fixed by <a href=\"https://github.com/rust-lang/rust/pull/86327\">https://github.com/rust-lang/rust/pull/86327</a></p>",
        "id": 242767510,
        "sender_full_name": "lqd",
        "timestamp": 1623777452
    }
]