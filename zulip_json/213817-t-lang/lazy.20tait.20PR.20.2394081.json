[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>, so I'm working on a write-up of the semantics of the new inference algorithm:</p>\n<p><a href=\"https://hackmd.io/T4kshpcWRSK5hiymLGAMPA\">https://hackmd.io/T4kshpcWRSK5hiymLGAMPA</a></p>\n<p>My hope is to include some version of this on the impl trait explainer and for the Rust reference. I do have some questions though.</p>",
        "id": 275523054,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442803
    },
    {
        "content": "<p>In your PR, you write:</p>",
        "id": 275523102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442808
    },
    {
        "content": "<blockquote>\n<p>user visible change 2: divergence between RPIT and TAIT in return statements</p>\n</blockquote>",
        "id": 275523115,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442811
    },
    {
        "content": "<p>I think what is going on here is that:</p>",
        "id": 275523321,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442883
    },
    {
        "content": "<ul>\n<li>Each time you constrain the TAIT, you get an \"independent\" constraint (which is different than something I wrote in the hackmd above)</li>\n</ul>",
        "id": 275523360,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442900
    },
    {
        "content": "<p>therefore:</p>",
        "id": 275523377,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442907
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">42</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">empty</span><span class=\"p\">().</span><span class=\"n\">collect</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR `Foo` cannot be built from an iterator</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275523390,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442911
    },
    {
        "content": "<p>the <code>Vec&lt;i32&gt;</code> from the <code>return</code> doesn't influence the <code>collect()</code> call later</p>",
        "id": 275523466,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442925
    },
    {
        "content": "<p>is that .. correct?</p>",
        "id": 275523521,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442942
    },
    {
        "content": "<p>I'm also a bit confused as to why this code doesn't compile, is it the same reason?</p>",
        "id": 275523537,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442950
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">42_</span><span class=\"k\">i32</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">empty</span><span class=\"p\">().</span><span class=\"n\">collect</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">//~^ ERROR `Foo` cannot be built from an iterator over elements of type `_`</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275523552,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442957
    },
    {
        "content": "<p>(that is \"user visible change 3\")</p>",
        "id": 275523571,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442964
    },
    {
        "content": "<p>I remember us discussing this at various points, i.e., where the \"merge\" happens exactly.</p>",
        "id": 275523604,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647442978
    },
    {
        "content": "<p>(Also, if you already had such a write-up, d'oh! I debated about asking you to write it, but then I thought I had a fairly clear vision for how to express it, so I took a stab at it)</p>",
        "id": 275523676,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443005
    },
    {
        "content": "<p>Also, you're alluding to some kind of hack for RPIT, I'm curious what that is, exactly</p>",
        "id": 275523843,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443052
    },
    {
        "content": "<p>user visible change 2 and 3 are different. We can easily support 3 (revert <a href=\"https://github.com/rust-lang/rust/commit/a721052457cf513487fb4266e3ade65c29b272d2\">https://github.com/rust-lang/rust/commit/a721052457cf513487fb4266e3ade65c29b272d2</a>, which removes support for it). Supporting 2 reintroduces the inference-var system that RPIT had, albeit in a more limited manner.</p>",
        "id": 275523939,
        "sender_full_name": "oli",
        "timestamp": 1647443093
    },
    {
        "content": "<p>it seems a bit different to me</p>",
        "id": 275523998,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443118
    },
    {
        "content": "<p>what happens today with this case?</p>",
        "id": 275524101,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443156
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Constraints `Foo = Result&lt;u32, i32&gt;`</span>\n<span class=\"k\">fn</span> <span class=\"nf\">sufficient</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"mi\">22_</span><span class=\"k\">u32</span><span class=\"p\">);</span><span class=\"w\">  </span><span class=\"c1\">// Requires `Result&lt;u32, _&gt;`</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"mi\">22_</span><span class=\"k\">i32</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Requires `Result&lt;_, i32&gt;`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275524168,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/lazy.20tait.20PR.20.2394081/near/275523998\">said</a>:</p>\n<blockquote>\n<p>it seems a bit different to me</p>\n</blockquote>\n<p>(to clarify, I think that the old RPIT scheme and the things required to support case 2 are different)</p>",
        "id": 275524253,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443211
    },
    {
        "content": "<p>that should work even with the lazy TAIT PR as written now, as these types can be unified</p>",
        "id": 275524314,
        "sender_full_name": "oli",
        "timestamp": 1647443237
    },
    {
        "content": "<p>what about</p>",
        "id": 275524355,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443255
    },
    {
        "content": "<p>it's only problematic if you don't actually end up with a type that you can merge into the hidden type</p>",
        "id": 275524358,
        "sender_full_name": "oli",
        "timestamp": 1647443255
    },
    {
        "content": "<p>inference vars get merged with the opaque type, not the hidden one</p>",
        "id": 275524380,
        "sender_full_name": "oli",
        "timestamp": 1647443261
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">42</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">empty</span><span class=\"p\">().</span><span class=\"n\">collect</span><span class=\"p\">(;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275524431,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443281
    },
    {
        "content": "<p>that won't work</p>",
        "id": 275524508,
        "sender_full_name": "oli",
        "timestamp": 1647443293
    },
    {
        "content": "<p>I don't follow why doesn't work but the above one does</p>",
        "id": 275524526,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443299
    },
    {
        "content": "<p>Perhaps it has to do with <em>when</em> the merging occurs</p>",
        "id": 275524545,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443306
    },
    {
        "content": "<p><code>Foo</code> does not implement <code>Extend</code></p>",
        "id": 275524554,
        "sender_full_name": "oli",
        "timestamp": 1647443308
    },
    {
        "content": "<p>or what the trait is ^^, sec I got an <del>example</del> test for this</p>",
        "id": 275524591,
        "sender_full_name": "oli",
        "timestamp": 1647443324
    },
    {
        "content": "<p>OK, OK, I see</p>",
        "id": 275524608,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443329
    },
    {
        "content": "<p>interesting</p>",
        "id": 275524612,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443331
    },
    {
        "content": "<p>so--- case 3 can be made to work because the merge happens before it \"hits\" the <code>Foo</code></p>",
        "id": 275524821,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443407
    },
    {
        "content": "<p>(which I remember us discussing at some point)</p>",
        "id": 275524839,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443413
    },
    {
        "content": "<p>there is, I think, a missing section then</p>",
        "id": 275524872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443426
    },
    {
        "content": "<p>what happens with auto-traits within defining scope exactly</p>",
        "id": 275524891,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443435
    },
    {
        "content": "<p>does this code work?</p>",
        "id": 275524915,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443445
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">is_send</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">ok</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Constrain `Foo = u32`</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22_</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// No problem `Foo = u32` and `u32: Send`</span>\n<span class=\"w\">    </span><span class=\"n\">is_send</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275524920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443446
    },
    {
        "content": "<p>I'm guessing no</p>",
        "id": 275524997,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443475
    },
    {
        "content": "<p>uh... that probably causes a cycle error</p>",
        "id": 275525000,
        "sender_full_name": "oli",
        "timestamp": 1647443476
    },
    {
        "content": "<p>Yeah, ok. This seems ok. I will adjust the write-up. I think we can do better in the future, but I don't see why it should block this PR from landing (nor stabilization).</p>",
        "id": 275525081,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443511
    },
    {
        "content": "<p>ah found the test I was looking for: <a href=\"https://github.com/rust-lang/rust/pull/94081/files#diff-0e96334fc7ab7eea8178318d13179eefa841abfb448fd66c2d5a33d635ebfa7b\">https://github.com/rust-lang/rust/pull/94081/files#diff-0e96334fc7ab7eea8178318d13179eefa841abfb448fd66c2d5a33d635ebfa7b</a> if there is a <code>FromIterator</code> bound on the opaque type, we can collect into it</p>",
        "id": 275525670,
        "sender_full_name": "oli",
        "timestamp": 1647443743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> and do we indeed have a \"special case hack\" for RPIT to support this case?</p>",
        "id": 275525874,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647443809
    },
    {
        "content": "<p>yes, <a href=\"https://github.com/rust-lang/rust/pull/94081/commits/d2850ee9fb05b2f76be0502e7f30141dffcb8bd6\">https://github.com/rust-lang/rust/pull/94081/commits/d2850ee9fb05b2f76be0502e7f30141dffcb8bd6</a> shows most of the sites, but basically the final PR has 3 call sites for replace_opaque_types_with_inference_vars that are all such backwards compat hacks</p>",
        "id": 275526150,
        "sender_full_name": "oli",
        "timestamp": 1647443926
    },
    {
        "content": "<p>I documented these in <a href=\"https://hackmd.io/5t8pLdJcRDmqbfN9ZXje3g#Backwards-compatibility-hacks\">https://hackmd.io/5t8pLdJcRDmqbfN9ZXje3g#Backwards-compatibility-hacks</a></p>",
        "id": 275526275,
        "sender_full_name": "oli",
        "timestamp": 1647443972
    },
    {
        "content": "<p>Hmm, ok.</p>",
        "id": 275526668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647444108
    },
    {
        "content": "<p>So we have to decide how we want to handle those for TAIT in the future.</p>",
        "id": 275526719,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647444121
    },
    {
        "content": "<p>sg, I'll adjust the write-up</p>",
        "id": 275526783,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647444131
    },
    {
        "content": "<p>yes, I just chose the most forward compatible thing at each of them. So we can become more permissive later</p>",
        "id": 275527196,
        "sender_full_name": "oli",
        "timestamp": 1647444309
    },
    {
        "content": "<p>I edited the hackmd, there's just one open point I believe (left a FIXME, as I need to write more tests first)</p>",
        "id": 275624272,
        "sender_full_name": "oli",
        "timestamp": 1647508636
    },
    {
        "content": "<p>We should also make sure that the <code>fudge_inference_if_ok</code> thing does not behave differently between RPIT and TAIT. I've been digging into it to try to avoid it, but I haven't grokked it yet, so I can't even tell all the edge cases that are avoided by it compared with just doing <code>commit_if_ok</code></p>",
        "id": 275624455,
        "sender_full_name": "oli",
        "timestamp": 1647508773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> this example yields a cycle in your branch, right?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">is_send</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">not_good</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Error: this function does not constrain `Foo` to any particular</span>\n<span class=\"w\">    </span><span class=\"c1\">// hidden type, so it cannot rely on `Send` being true.</span>\n<span class=\"w\">    </span><span class=\"n\">is_send</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">ok</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Constrain `Foo = u32`</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22_</span><span class=\"k\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// No problem `Foo = u32` and `u32: Send`</span>\n<span class=\"w\">    </span><span class=\"n\">is_send</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275657938,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526192
    },
    {
        "content": "<p>uh</p>",
        "id": 275658686,
        "sender_full_name": "oli",
        "timestamp": 1647526468
    },
    {
        "content": "<p>nope ^^</p>",
        "id": 275658693,
        "sender_full_name": "oli",
        "timestamp": 1647526472
    },
    {
        "content": "<p>ok, I thought you said it did</p>",
        "id": 275658723,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526484
    },
    {
        "content": "<p>I have to look at what happens with auto-traits</p>",
        "id": 275658731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526490
    },
    {
        "content": "<p><code>not_good</code> works because it never constrains the opaque type, thus is not searched for the opaque type (yea this logic is a bit roundabout), so we can reveal the opaque type by asking <code>type_of</code> to give us the hidden type</p>",
        "id": 275658856,
        "sender_full_name": "oli",
        "timestamp": 1647526546
    },
    {
        "content": "<p>the thing I'm surprised about is <code>ok</code></p>",
        "id": 275658875,
        "sender_full_name": "oli",
        "timestamp": 1647526557
    },
    {
        "content": "<p>I'm a bit surprised that <code>not_good</code> works</p>",
        "id": 275658959,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526576
    },
    {
        "content": "<p>I don't know how that actually works</p>",
        "id": 275658963,
        "sender_full_name": "oli",
        "timestamp": 1647526577
    },
    {
        "content": "<p>We're smarter than I thought, I guess</p>",
        "id": 275658974,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526582
    },
    {
        "content": "<p>/me thinks</p>",
        "id": 275659031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526607
    },
    {
        "content": "<p>during the type-checking of <code>not_good</code>, we need to determine that <code>Foo: Send</code>...</p>",
        "id": 275659067,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526622
    },
    {
        "content": "<p>...which requires knowing its hidden type...</p>",
        "id": 275659083,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526627
    },
    {
        "content": "<p>hold up</p>",
        "id": 275659106,
        "sender_full_name": "oli",
        "timestamp": 1647526636
    },
    {
        "content": "<p>...to know the hidden type, we have to look at the typeck-results (right?) to see whether <code>Foo</code> is constrained...</p>",
        "id": 275659114,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526640
    },
    {
        "content": "<p>I may have messed up testing</p>",
        "id": 275659122,
        "sender_full_name": "oli",
        "timestamp": 1647526642
    },
    {
        "content": "<p>...which we are computing?</p>",
        "id": 275659133,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526646
    },
    {
        "content": "<p>so</p>",
        "id": 275659268,
        "sender_full_name": "oli",
        "timestamp": 1647526684
    },
    {
        "content": "<p>both ok and not_good fail</p>",
        "id": 275659289,
        "sender_full_name": "oli",
        "timestamp": 1647526692
    },
    {
        "content": "<p>ok, that's what I expected</p>",
        "id": 275659315,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526704
    },
    {
        "content": "<p>I was expecting <code>ok</code>, but not <code>not_good</code>, but it does seem obvious in hindsight</p>",
        "id": 275659320,
        "sender_full_name": "oli",
        "timestamp": 1647526705
    },
    {
        "content": "<p>based on your earlier comments</p>",
        "id": 275659331,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526708
    },
    {
        "content": "<p>I expect <code>not_good</code> to fail with a cycle</p>",
        "id": 275659342,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526716
    },
    {
        "content": "<p>I guess I expect both to fail with a cycle</p>",
        "id": 275659351,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526722
    },
    {
        "content": "<p>the \"lesson\" seems to be that when you are <em>inside</em> the defining scope, at least with the current impl, you should prefer to work with the \"hidden type\"</p>",
        "id": 275659396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526744
    },
    {
        "content": "<p>and only use the type alias at the \"end\"</p>",
        "id": 275659409,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526750
    },
    {
        "content": "<p>basically, you have the power to assert <em>arbitrary</em> traits (not just auto traits) by constraining the hidden type and testing <em>that</em></p>",
        "id": 275659481,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526789
    },
    {
        "content": "<p>and that's what you should do</p>",
        "id": 275659485,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526791
    },
    {
        "content": "<p>uh</p>",
        "id": 275659582,
        "sender_full_name": "oli",
        "timestamp": 1647526815
    },
    {
        "content": "<p>so <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> in terms of RPIT, is the idea that we are currently doing the \"rewrite the return type to an inference variable\" thing eagerly in the code?</p>",
        "id": 275659591,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/lazy.20tait.20PR.20.2394081/near/275659481\">said</a>:</p>\n<blockquote>\n<p>basically, you have the power to assert <em>arbitrary</em> traits (not just auto traits) by constraining the hidden type and testing <em>that</em></p>\n</blockquote>\n<p>ah yes, took me a moment. Not revealing, but constraining and testing the known hidden type</p>",
        "id": 275659651,
        "sender_full_name": "oli",
        "timestamp": 1647526852
    },
    {
        "content": "<p>right</p>",
        "id": 275659679,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/lazy.20tait.20PR.20.2394081/near/275659591\">said</a>:</p>\n<blockquote>\n<p>so <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> in terms of RPIT, is the idea that we are currently doing the \"rewrite the return type to an inference variable\" thing eagerly in the code?</p>\n</blockquote>\n<p>yes, we rewrite the return type as seen from <em>inside</em> the function</p>",
        "id": 275659704,
        "sender_full_name": "oli",
        "timestamp": 1647526873
    },
    {
        "content": "<p>which is essentially what we used to do before, too</p>",
        "id": 275659720,
        "sender_full_name": "oli",
        "timestamp": 1647526882
    },
    {
        "content": "<p>you don't \"reveal\" inside the scope, you constrain</p>",
        "id": 275659731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647526884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/213817-t-lang/topic/lazy.20tait.20PR.20.2394081/near/275659591\">said</a>:</p>\n<blockquote>\n<p>so <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> in terms of RPIT, is the idea that we are currently doing the \"rewrite the return type to an inference variable\" thing eagerly in the code?</p>\n</blockquote>\n<p><span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span></p>",
        "id": 275660247,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647527060
    },
    {
        "content": "<p>yea, we do this rewrite, but only in the FnCtxt used to typeck functions. when we get to mir borrowck, we trust all the types that are around (though these are influenced by the FnCtxt)</p>",
        "id": 275660467,
        "sender_full_name": "oli",
        "timestamp": 1647527154
    },
    {
        "content": "<p>ok. so that's why the <code>if { } else { }</code> case behaves differently? The expected type is an inference variable, essentially?</p>",
        "id": 275660742,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647527250
    },
    {
        "content": "<p>yes</p>",
        "id": 275660802,
        "sender_full_name": "oli",
        "timestamp": 1647527274
    },
    {
        "content": "<p>this also has an effect on generic function calls where typeck flows information from the return type to the arguments (<code>fudge_inference_if_ok</code> being the keyword to search in the source for)</p>",
        "id": 275661026,
        "sender_full_name": "oli",
        "timestamp": 1647527346
    },
    {
        "content": "<p>Though I patched that to make them behave the same</p>",
        "id": 275661057,
        "sender_full_name": "oli",
        "timestamp": 1647527361
    },
    {
        "content": "<p>yeah, I remember that function vaguely, have to recall the details :)</p>",
        "id": 275661335,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647527470
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>    // HACK(oli-obk): This is a hack to keep RPIT and TAIT in sync wrt their behaviour.\n    // Without it, the inference\n    // variable will get instantiated with the opaque type. The inference variable often\n    // has various helpful obligations registered for it that help closures figure out their\n    // signature. If we infer the inference var to the opaque type, the closure won&#39;t be able\n    // to find those obligations anymore, and it can&#39;t necessarily find them from the opaque\n    // type itself. We could be more powerful with inference if we *combined* the obligations\n    // so that we got both the obligations from the opaque type and the ones from the inference\n    // variable. That will accept more code than we do right now, so we need to carefully consider\n    // the implications.\n    // Note: this check is pessimistic, as the inference type could be matched with something other\n    // than the opaque type, but then we need a new `TypeRelation` just for this specific case and\n    // can&#39;t re-use `sup` below.\n    // See src/test/ui/impl-trait/hidden-type-is-opaque.rs and\n    // src/test/ui/impl-trait/hidden-type-is-opaque-2.rs for examples that hit this path.\n</code></pre></div>\n\n</blockquote>",
        "id": 275661504,
        "sender_full_name": "oli",
        "timestamp": 1647527532
    }
]