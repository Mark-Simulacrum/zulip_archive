[
    {
        "content": "<p>So, IIRC <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>'s proposal for how to handle UB in <code>const fn</code> was accepted. Does that mean we can start carefully making certain unsafe functions <code>const</code> now?</p>\n<p>In particular, I have some interest in <code>slice get_unchecked</code> (I have a \"fast and non-const\" and \"slow and const\" version of a certain function...</p>",
        "id": 245391734,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625795055
    },
    {
        "content": "<p>Yes. In fact, a big one is already on its way: <a href=\"https://github.com/rust-lang/rust/pull/85769\">https://github.com/rust-lang/rust/pull/85769</a></p>",
        "id": 245413621,
        "sender_full_name": "RalfJ",
        "timestamp": 1625818297
    },
    {
        "content": "<p>I'd say wait until that lands</p>",
        "id": 245413639,
        "sender_full_name": "RalfJ",
        "timestamp": 1625818312
    },
    {
        "content": "<p>and then open the floodgates ;)</p>",
        "id": 245413645,
        "sender_full_name": "RalfJ",
        "timestamp": 1625818318
    },
    {
        "content": "<p>FWIW I am actually a bit surprised that the lang team isn't discussing this a bit more</p>\n<blockquote>\n<p>However, this will still let us write code like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">random</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which would be the first stable const fn that is not guaranteed to behave deterministically at run-time.<br>\nThis function certainly has UB when called at compile-time, but whether it has UB when called at run-time <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/286\">is unclear</a>.</p>\n</blockquote>",
        "id": 245413816,
        "sender_full_name": "RalfJ",
        "timestamp": 1625818419
    },
    {
        "content": "<p>but I guess I won't complain^^</p>",
        "id": 245413822,
        "sender_full_name": "RalfJ",
        "timestamp": 1625818424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245413645\">said</a>:</p>\n<blockquote>\n<p>and then open the floodgates <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I believe all future unsafe const fn are in T-libs territory as long as wg-const-eval also has a look</p>",
        "id": 245437631,
        "sender_full_name": "oli",
        "timestamp": 1625834700
    },
    {
        "content": "<p>Keep in mind for any future PRs that const panic isn't yet stable, so we don't want to give people an escape hatch that's quite dangerous. That's why <code>unreachable_unchecked</code> hasn't yet been made const stably.</p>",
        "id": 245438343,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1625835098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Honestly, I think we're not discussing it more because you already had a very clear pitch for how we should handle UB in const evaluation and that's exactly what we want to use.</p>",
        "id": 245464342,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625847773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> it's not the const UB this is about</p>",
        "id": 245465327,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848237
    },
    {
        "content": "<p>in current stable Rust, when I tell you that some function is declared as <code>const fn() -&gt; usize</code>, you know that when you call this function <em>at runtime</em>, multiple times, it will always produce the same result.</p>",
        "id": 245465448,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848294
    },
    {
        "content": "<p>if we stabilize <code>const_fn_transmute</code> or <code>const_fn_union</code>, we lose that property.</p>",
        "id": 245465493,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848314
    },
    {
        "content": "<p>note that const UB has nothing to do with it, so no amount of handling (or not handling) UB during const evaluation will change anything about this</p>",
        "id": 245465557,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848335
    },
    {
        "content": "<p>But it isn't <code>const fn</code>, it's <code>const unsafe fn</code>. :)</p>",
        "id": 245465589,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848355
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">nondet</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245465635,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848375
    },
    {
        "content": "<p>not sure why that would make any difference^^</p>",
        "id": 245465650,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848382
    },
    {
        "content": "<p>(I was half joking, though in general I do think it's relevant that you can't get such behavior without unsafe.)</p>",
        "id": 245465695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848410
    },
    {
        "content": "<p>the entire point of <code>unsafe</code> is that it can be safely encapsulated :)</p>",
        "id": 245465840,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848467
    },
    {
        "content": "<p>I do wonder if it would make sense to catch at compile time cases where a const function depends on something non-deterministic like a stack address.</p>",
        "id": 245465969,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848533
    },
    {
        "content": "<p>and yes this function is UB to call at compiletime</p>",
        "id": 245465971,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848534
    },
    {
        "content": "<p>but it's (maybe) not UB to call at runtime</p>",
        "id": 245466002,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245465969\">said</a>:</p>\n<blockquote>\n<p>I do wonder if it would make sense to catch at compile time cases where a const function depends on something non-deterministic like a stack address.</p>\n</blockquote>\n<p>we could make an effort but it'll never catch all cases</p>",
        "id": 245466054,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848570
    },
    {
        "content": "<p>so that is a separate discussion</p>",
        "id": 245466059,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848574
    },
    {
        "content": "<p>I'm only interested in ironclad guarantees here, which we'll never achieve with such a check</p>",
        "id": 245466087,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848594
    },
    {
        "content": "<p>Is it just UB at compile time because it returns an address and const evaluation carefully makes a distinction between addresses and numbers?</p>",
        "id": 245466107,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245466107\">said</a>:</p>\n<blockquote>\n<p>Is it just UB at compile time because it returns an address and const evaluation carefully makes a distinction between addresses and numbers?</p>\n</blockquote>\n<p>\"just\" is doing a lot of work here :)</p>",
        "id": 245466134,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848621
    },
    {
        "content": "<p>yes, <a href=\"https://github.com/rust-lang/rust/issues/85769\">#85769</a> documents that it is UB during const-eval to transmute ptrs to ints</p>",
        "id": 245466165,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848644
    },
    {
        "content": "<p>\"just\" here meaning that there isn't any other reason why it's UB, such as something magic involving pointer provenance.</p>",
        "id": 245466179,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848658
    },
    {
        "content": "<p>the distinction between pointers and numbers <em>is</em> pointer provenance</p>",
        "id": 245466212,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848680
    },
    {
        "content": "<p>(avoiding the term \"address\" here as I usually use that for the part of the pointer without the provenance)</p>",
        "id": 245466294,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848706
    },
    {
        "content": "<p>It seems like, at compile time, the distinction is more clear than that.</p>",
        "id": 245466316,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848715
    },
    {
        "content": "<p>well, at compile-time, provenance is non-optional</p>",
        "id": 245466351,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848743
    },
    {
        "content": "<p>Insofar as the compiler is synthesizing locations for use by operations that think they're using memory, but by the end of the operation they need to not be using memory.</p>",
        "id": 245466387,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848765
    },
    {
        "content": "<p>for runtime a provenance-free model is at least conceivable (it's just not matching reality)</p>",
        "id": 245466388,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245466387\">said</a>:</p>\n<blockquote>\n<p>Insofar as the compiler is synthesizing locations for use by operations that think they're using memory, but by the end of the operation they need to not be using memory.</p>\n</blockquote>\n<p>no that's not the reason</p>",
        "id": 245466418,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848785
    },
    {
        "content": "<p>s/reality/LLVM/ :)</p>",
        "id": 245466419,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245466419\">said</a>:</p>\n<blockquote>\n<p>s/reality/LLVM/ :)</p>\n</blockquote>\n<p>s/reality/LLVM+GCC+MSVC+ICC+.../<br>\n;)</p>",
        "id": 245466445,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848799
    },
    {
        "content": "<p>oh and CompCert, too, of course</p>",
        "id": 245466527,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848824
    },
    {
        "content": "<p>the reason provenance is non-optional at compile time is that we dont knoow the physical base addresses yet</p>",
        "id": 245466560,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848844
    },
    {
        "content": "<p>so we have to emit relocations to LLVM, in case the final const value contains pointers</p>",
        "id": 245466589,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245466387\">said</a>:</p>\n<blockquote>\n<p>Insofar as the compiler is synthesizing locations for use by operations that think they're using memory, but by the end of the operation they need to not be using memory.</p>\n</blockquote>\n<p>this ^ is just saying \"programs run in an interpreter\". that makes no difference.</p>",
        "id": 245466612,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848871
    },
    {
        "content": "<p>\"don't know the physical base addresses\" is what I was trying to describe when I said \"synthesizing locations\".</p>",
        "id": 245466644,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848893
    },
    {
        "content": "<p>oh okay. then I dont get the \"need to not be using memory\" part.</p>",
        "id": 245466731,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848930
    },
    {
        "content": "<p>(also, I didn't realize we handled ending up with a pointer yet)</p>",
        "id": 245466735,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848932
    },
    {
        "content": "<p>(oh we handle that since forever)</p>",
        "id": 245466782,
        "sender_full_name": "RalfJ",
        "timestamp": 1625848960
    },
    {
        "content": "<p>I didn't know that; that's awesome. I had thought that was still a work in progress.</p>",
        "id": 245466798,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625848975
    },
    {
        "content": "<p>the CTFE engine is capable of running <em>enormous</em> amounts of Rust code already. like, almost as much as Miri-the-tool.</p>",
        "id": 245466844,
        "sender_full_name": "RalfJ",
        "timestamp": 1625849008
    },
    {
        "content": "<p>Am I misunderstanding something? I thought that was the primary issue with being able to handle something like Vec or Box in const eval?</p>",
        "id": 245466858,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849016
    },
    {
        "content": "<p>the \"only\" thing that's missing is figuring out static checks that ensure this enormously powerful engine doesnt break everything ;)</p>",
        "id": 245466879,
        "sender_full_name": "RalfJ",
        "timestamp": 1625849034
    },
    {
        "content": "<p>no, the issues around Vec and Box are all about how to make this <em>safe</em></p>",
        "id": 245466974,
        "sender_full_name": "RalfJ",
        "timestamp": 1625849073
    },
    {
        "content": "<p>but we should probably not talk about const heap stuff here, that's a mostly separate discussion :)</p>",
        "id": 245467073,
        "sender_full_name": "RalfJ",
        "timestamp": 1625849154
    },
    {
        "content": "<p>what we have on stable is things like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"mi\">4</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>that also involves pointers in the final value</p>",
        "id": 245467214,
        "sender_full_name": "RalfJ",
        "timestamp": 1625849211
    },
    {
        "content": "<p>Got it. Thanks for that explanation; I had been misunderstanding the issue.</p>",
        "id": 245467994,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849593
    },
    {
        "content": "<p>I think the distinction between \"this isn't possible yet\" and \"this isn't possible to make safe for stable\" was not always clear to me, and sometimes got conflated.</p>",
        "id": 245468116,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625849644
    },
    {
        "content": "<p>so, back to the original topic...</p>\n<blockquote>\n<p>in current stable Rust, when I tell you that some function is declared as <code>const fn() -&gt; usize</code>, you know that when you call this function <em>at runtime</em>, multiple times, it will always produce the same result.</p>\n</blockquote>\n<p>This is not a guarantee that we ever explicitly designed, but just \"fell out\" of the const checks, and we made sure to maintain it so far. I know Centril had plans for this, using <code>const</code> as a kind of \"pure\" annotation in Rust.  I am personally not sold on that (effect systems are tricky, const is tricky, we'd make our life a lot harder by mixing them), but it is certainly an interesting idea and I want to be sure that the entire lang team is aware and onboard with what happens. I want to avoid that in 2 years we're like \"oh no if only we had known back then what we are throwing away\".<br>\n(this also pertains to the <code>const_fn_float</code> discussion -- floats are usually not outright non-deterministic, but at least certain NaN payloads can actually differ between when the NaN is created at compiletime vs runtime, and also Wasm explicitly specifies many NaN payloads as non-deterministic and who knows, there might be implementations exploiting that.)</p>",
        "id": 245470365,
        "sender_full_name": "RalfJ",
        "timestamp": 1625850616
    },
    {
        "content": "<p>Arguably, a <em>safe</em> such <code>const fn</code> is \"unsound\" because it has const-UB, and we could use that as our holding ground. That might be enough, for now, but won't help with the NaN problem.</p>",
        "id": 245470630,
        "sender_full_name": "RalfJ",
        "timestamp": 1625850744
    },
    {
        "content": "<p>I know that GCC has a lot of code trying to make sure it can evaluate floats and similar at compile time and produce exactly the same result it would get at runtime. I don't know how well it succeeds, but I know it tries.</p>",
        "id": 245471246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625851058
    },
    {
        "content": "<p>I think arguing edge case definitions doesn't make for a good public image.</p>\n<p>And you can the problem with all safe code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">nondet_as</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245471423,
        "sender_full_name": "Lokathor",
        "timestamp": 1625851139
    },
    {
        "content": "<p>(is that legal code today in stable?)</p>",
        "id": 245471479,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625851172
    },
    {
        "content": "<p>no it's not</p>",
        "id": 245471532,
        "sender_full_name": "Lokathor",
        "timestamp": 1625851203
    },
    {
        "content": "<p>but it's the same \"pointer becomes an integer\" problem, and it's safe as non-const, and it would confuse countless people to say it's unsafe or even unsound but only if in const fn</p>",
        "id": 245471621,
        "sender_full_name": "Lokathor",
        "timestamp": 1625851250
    },
    {
        "content": "<p>Regarding the original question, I'm curious to what degree we could reliably detect the returning of non-deterministic addresses in a const fn. What's the simplest example we can produce that is definitely not reasonable to detect?</p>",
        "id": 245471665,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625851283
    },
    {
        "content": "<p>I think you have to use <code>as</code> or <em>some form</em> of transmutation to get an int from a pointer, but you can be pretty devilish with the transmutation and so you'd probably be able to sidestep the check if you were determined.</p>",
        "id": 245471874,
        "sender_full_name": "Lokathor",
        "timestamp": 1625851401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245471621\">said</a>:</p>\n<blockquote>\n<p>but it's the same \"pointer becomes an integer\" problem, and it's safe as non-const, and it would confuse countless people to say it's unsafe or even unsound but only if in const fn</p>\n</blockquote>\n<p>my plan is to never allow ptr-to-int casts in <code>const fn</code></p>",
        "id": 245473206,
        "sender_full_name": "RalfJ",
        "timestamp": 1625852014
    },
    {
        "content": "<p>not safely, not unsafely, just not at all -- as you said, it's <em>safe</em> during non-const, so making it \"weird\" during const is probably a bad idea. that leaves making it impossible during const the only option.</p>",
        "id": 245473223,
        "sender_full_name": "RalfJ",
        "timestamp": 1625852023
    },
    {
        "content": "<p>so I think we got that case covered</p>",
        "id": 245473233,
        "sender_full_name": "RalfJ",
        "timestamp": 1625852028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245471665\">said</a>:</p>\n<blockquote>\n<p>Regarding the original question, I'm curious to what degree we could reliably detect the returning of non-deterministic addresses in a const fn. What's the simplest example we can produce that is definitely not reasonable to detect?</p>\n</blockquote>\n<p>are you asking for the simplest example of the halting problem? because that's what it sounds like. ;)</p>",
        "id": 245473360,
        "sender_full_name": "RalfJ",
        "timestamp": 1625852083
    },
    {
        "content": "<blockquote>\n<p>I think arguing edge case definitions doesn't make for a good public image.</p>\n</blockquote>\n<p>\"public image\"? we're doing PL design here, not PR...<br>\nand anyway, arguing edge cases is exactly how Rust got its good public image -- \"memory safety\" is a game that consists almost entirely of arguing edge cases; \"soundness\" even more so.</p>",
        "id": 245473578,
        "sender_full_name": "RalfJ",
        "timestamp": 1625852220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245471246\">said</a>:</p>\n<blockquote>\n<p>I know that GCC has a lot of code trying to make sure it can evaluate floats and similar at compile time and produce exactly the same result it would get at runtime. I don't know how well it succeeds, but I know it tries.</p>\n</blockquote>\n<p>yeah and so does LLVM and eddyb ported that code to Rust and that's what we use in CTFE.<br>\nbut some platforms have weird behavior for which bit patterns they use for a NaN (and of course x87 is just ridicolous), so it is my understanding that <em>guaranteeing</em> that we match the runtime bit patterns is unrealistic. Wasm gave up and made it non-deterministic. Wasm is extremely good at what it does, I doubt we can do better.</p>",
        "id": 245473860,
        "sender_full_name": "RalfJ",
        "timestamp": 1625852387
    },
    {
        "content": "<p>IEEE should've just forced exact bitpatterns on everyone :(</p>",
        "id": 245475049,
        "sender_full_name": "eddyb",
        "timestamp": 1625852861
    },
    {
        "content": "<p>I will never stop being mad about it</p>",
        "id": 245475074,
        "sender_full_name": "eddyb",
        "timestamp": 1625852879
    },
    {
        "content": "<p>not only is it entirely plausible, it would've forced vendors to cut less corners</p>",
        "id": 245475159,
        "sender_full_name": "eddyb",
        "timestamp": 1625852905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I have no problem writing off the x87. :)</p>",
        "id": 245475271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625852975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I would ideally like to allow pointer to int and int to pointer casts in const evaluation, as long as whenever you end up dereferencing a pointer, it's actually a valid pointer that you originally got from the const evaluation engine.</p>",
        "id": 245475395,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853026
    },
    {
        "content": "<p>does the i686 target use SSE2? even then, I believe we support targets where hardfloat=x87</p>",
        "id": 245475430,
        "sender_full_name": "eddyb",
        "timestamp": 1625853051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245475395\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I would ideally like to allow pointer to int and int to pointer casts in const evaluation, as long as whenever you end up dereferencing a pointer, it's actually a valid pointer that you originally got from the const evaluation engine.</p>\n</blockquote>\n<p>isn't the reason pointer -&gt; int casts get brought up that people want to modify it as an integer, and observe address bits?</p>",
        "id": 245475546,
        "sender_full_name": "eddyb",
        "timestamp": 1625853119
    },
    {
        "content": "<p>things like having an alignment of 4 bytes and packing something else in the lowest 2 bits</p>",
        "id": 245475637,
        "sender_full_name": "eddyb",
        "timestamp": 1625853146
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Also, no, I'm not asking for an example of the halting problem, I'm specifically asking about cases where we can't prove that the function <em>doesn't</em> do non-deterministic things with pointer values. We are allowed to reject valid programs. So I'm wondering if there's a line we can draw that's practically useful.</p>",
        "id": 245475642,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853153
    },
    {
        "content": "<p>(or more complicated things)</p>",
        "id": 245475646,
        "sender_full_name": "eddyb",
        "timestamp": 1625853155
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Yes, exactly. I don't think that's unreasonable at compile time any more than it is at runtime. Const evaluation should just give you an error if you ever try to dereference a pointer it didn't hand you.</p>",
        "id": 245475723,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853203
    },
    {
        "content": "<p>So if you want to cast a pointer to an end, stuff extra information into the zero bits, then later mask off those bits and dereference the resulting valid pointer, that seems just as reasonable at compile time as it does at runtime.</p>",
        "id": 245475771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245475642\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Also, no, I'm not asking for an example of the halting problem, I'm specifically asking about cases where we can't prove that the function <em>doesn't</em> do non-deterministic things with pointer values. We are allowed to reject valid programs. So I'm wondering if there's a line we can draw that's practically useful.</p>\n</blockquote>\n<p>I guess of the problem is you don't know where pointers are. if you did, you could do conservative taint tracking with dataflow. but doing all of this symbolically wrt memory layout (because of generics) seems hard</p>",
        "id": 245475949,
        "sender_full_name": "eddyb",
        "timestamp": 1625853318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245475723\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> Yes, exactly. I don't think that's unreasonable at compile time any more than it is at runtime. Const evaluation should just give you an error if you ever try to dereference a pointer it didn't hand you.</p>\n</blockquote>\n<p>why is \"dereference\" the problem? you can't give the user a real integer, because no possible value you come up with could be guaranteed to be a valid <em>runtime</em> pointer</p>",
        "id": 245476012,
        "sender_full_name": "eddyb",
        "timestamp": 1625853354
    },
    {
        "content": "<p>you can only at most operate on it symbolically</p>",
        "id": 245476094,
        "sender_full_name": "eddyb",
        "timestamp": 1625853373
    },
    {
        "content": "<p>(IIRC miri used to have, or maybe still does, code to do bitwise/arithmetic operations on <code>abstract base (aligned to N) + known offset</code> pointer values when it was possible to adjust the offset, i.e. the operation was compatible with the value of <code>N</code>)</p>",
        "id": 245476231,
        "sender_full_name": "eddyb",
        "timestamp": 1625853449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> apologies if I'm reiterating previous examples, but this is what I'm thinking of:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">ADDR</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">123</span><span class=\"k\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">^</span><span class=\"w\"> </span><span class=\"mh\">0xdeadbeef</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"n\">ADDR</span><span class=\"w\"> </span><span class=\"o\">^</span><span class=\"w\"> </span><span class=\"mh\">0xdeadbeef</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245476811,
        "sender_full_name": "eddyb",
        "timestamp": 1625853691
    },
    {
        "content": "<p>I don't even believe it's possible to ask a linker to handle a relocation like that for you</p>",
        "id": 245476942,
        "sender_full_name": "eddyb",
        "timestamp": 1625853735
    },
    {
        "content": "<p>Something akin to taint tracking was exactly what I had in mind: effectively, symbolic evaluation on pointers such that the actual base pointer you're operating on is recorded as part of the calculation.</p>",
        "id": 245477201,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853904
    },
    {
        "content": "<p>And if you ever try to do a conditional on the exact value, or something we can't determine from the alignment alone, we stop and complain.</p>",
        "id": 245477261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853927
    },
    {
        "content": "<p>ah but that's the current state</p>",
        "id": 245477298,
        "sender_full_name": "eddyb",
        "timestamp": 1625853939
    },
    {
        "content": "<p>Well, that's exactly the state I was hoping for with respect to allowing pointer to integer and integer to pointer casts. :)</p>",
        "id": 245477370,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625853969
    },
    {
        "content": "<p>so I'm confused as to what is being suggested. you can totally have an <code>usize</code> that contains an <em>abstract</em> pointer, in CTFE miri, today, AFAIK. it's just not <em>a concrete integer value</em></p>",
        "id": 245477415,
        "sender_full_name": "eddyb",
        "timestamp": 1625853991
    },
    {
        "content": "<p>This was in response to Ralf suggesting that he'd rather not allow pointer to integer casts in CTFE at all.</p>",
        "id": 245477489,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854033
    },
    {
        "content": "<p>ahhh. I doubt that covers everything, but that makes more sense now, thanks</p>",
        "id": 245477637,
        "sender_full_name": "eddyb",
        "timestamp": 1625854090
    },
    {
        "content": "<p>(In theory, we might be able to do better regarding exact integer values if we had better linker integration, but I'm going to ignore that possibility for now.)</p>",
        "id": 245477645,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245477201\">said</a>:</p>\n<blockquote>\n<p>Something akin to taint tracking was exactly what I had in mind: effectively, symbolic evaluation on pointers such that the actual base pointer you're operating on is recorded as part of the calculation.</p>\n</blockquote>\n<p>just to clear up a bit my own mention of taint tracking: I was talking about a (conservative) static analysis, as opposed to dynamic tracking during CTFE. since the problem is <em>non-CTFE</em> use of a <code>const fn</code></p>",
        "id": 245477685,
        "sender_full_name": "eddyb",
        "timestamp": 1625854117
    },
    {
        "content": "<p>I have no problem with the idea that we track abstract pointers even when they're in an integer type, and in the end, if what you come up with can be handled with relocation then we do that, or if it can't then we complain that we can't generate code. If you generate an arbitrary swizzled pointer that the linker can't handle, and we can't figure out a way to generate what you asked for, we could just refuse.</p>",
        "id": 245477756,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854174
    },
    {
        "content": "<p>right, that's the state today, the value (bits vs abstract pointer) and the type are independent, but various operations (possibly even just passing the value around) only support some combinations of values and types</p>",
        "id": 245477904,
        "sender_full_name": "eddyb",
        "timestamp": 1625854243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I'm wondering to what extent we could do symbolic evaluation on a const function for the purposes of evaluating whether it misbehaves at runtime. In particular, I'm wondering if we might be able to allow the vast majority of things people want to do while still actually prohibiting non-determinism.</p>",
        "id": 245477918,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854250
    },
    {
        "content": "<p>you'd have to pick monomorphizations to that on, that's one of the things I was alluding to</p>",
        "id": 245477979,
        "sender_full_name": "eddyb",
        "timestamp": 1625854292
    },
    {
        "content": "<p>Fair point.</p>",
        "id": 245477992,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854302
    },
    {
        "content": "<p>Though, in theory, we know all the monomorphizations at compile time, right?</p>",
        "id": 245478067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854327
    },
    {
        "content": "<p>doing it generically is harder, because you have to treat things like ADTs symbolically, which miri pretty much does the opposite of (i.e. it handles flat memory, and only abstract pointers are symbolic)</p>",
        "id": 245478135,
        "sender_full_name": "eddyb",
        "timestamp": 1625854369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245478067\">said</a>:</p>\n<blockquote>\n<p>Though, in theory, we know all the monomorphizations at compile time, right?</p>\n</blockquote>\n<p>the definition would compile until you call it from runtime, which could happen in a different crate</p>",
        "id": 245478183,
        "sender_full_name": "eddyb",
        "timestamp": 1625854394
    },
    {
        "content": "<p>in general I'm strongly against so-called \"post-monomorphization errors\"</p>",
        "id": 245478369,
        "sender_full_name": "eddyb",
        "timestamp": 1625854477
    },
    {
        "content": "<p>When you say \"harder\", what scale are we on? Do you mean that such abstract evaluation is something we could do but it'd be a pain, or are we in \"someone needs to do a dissertation or two on how to do that\" territory? :)</p>",
        "id": 245478590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854601
    },
    {
        "content": "<p>miri had that approach before it had the flat memory, so I can link you to the report which I believe compares the two to some extent</p>",
        "id": 245478748,
        "sender_full_name": "eddyb",
        "timestamp": 1625854685
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/miri#history\">https://github.com/rust-lang/miri#history</a> -&gt; <a href=\"https://solson.me/miri-report.pdf\">https://solson.me/miri-report.pdf</a></p>",
        "id": 245478833,
        "sender_full_name": "eddyb",
        "timestamp": 1625854737
    },
    {
        "content": "<p>anyway I <em>personally</em> don't think it's that useful to force <code>const fn</code>s to promise anything about runtime behavior predictability, but I'm not against preventing the more egregious issues, if it's not too difficult I suppose</p>",
        "id": 245479046,
        "sender_full_name": "eddyb",
        "timestamp": 1625854841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245471423\">said</a>:</p>\n<blockquote>\n<p>I think arguing edge case definitions doesn't make for a good public image.</p>\n<p>And you can the problem with all safe code:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">nondet_as</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>we could catch this as \"escaping pointer to local\", I guess, but a big problem is not being able to know about \"laundering gadgets\"</p>",
        "id": 245479161,
        "sender_full_name": "eddyb",
        "timestamp": 1625854900
    },
    {
        "content": "<p>if you have a separate function that you pass the address of one of your locals to, how do you prevent it returning that address back to you? you have to also look at <em>its body</em></p>",
        "id": 245479336,
        "sender_full_name": "eddyb",
        "timestamp": 1625854983
    },
    {
        "content": "<p>I guess this is why <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> brought up the halting problem, since that's what you run into if you try to make this perfect. sadly it still applies to more restricted analyses, and I'm worried anything we could pull off would be too limited for real-world code</p>",
        "id": 245479627,
        "sender_full_name": "eddyb",
        "timestamp": 1625855136
    },
    {
        "content": "<p>code that passes around references <em>everywhere</em></p>",
        "id": 245479644,
        "sender_full_name": "eddyb",
        "timestamp": 1625855143
    },
    {
        "content": "<p>anyway, I gotta take off for the weekend, sorry if I forget to follow up on this</p>",
        "id": 245479751,
        "sender_full_name": "eddyb",
        "timestamp": 1625855183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245475395\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I would ideally like to allow pointer to int and int to pointer casts in const evaluation, as long as whenever you end up dereferencing a pointer, it's actually a valid pointer that you originally got from the const evaluation engine.</p>\n</blockquote>\n<p>I think this is extremely unlikely to happen. like, even if we allowed ptr-to-int cast, doing any int operation on the result would be UB since it's not actually an integer. we could accumulate an increasing amount of hacks to permit a small subset of those operations, but this doesnt scale and just results in accumulating more and more complex code to handle an increasing amount of corner cases -- Miri used to do that, and I concluded it's a bad idea. Miri nowadays just picks proper integer base addresses for allocations. CTFE can't do that. I think the only sustainable option here is to disallow ptr-int-casts in CTFE entirely.<br>\nactually needing ptr-int-casts is extremely rare, so I don't think this is a big loss.</p>",
        "id": 245480614,
        "sender_full_name": "RalfJ",
        "timestamp": 1625855615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245475771\">said</a>:</p>\n<blockquote>\n<p>So if you want to cast a pointer to an end, stuff extra information into the zero bits, then later mask off those bits and dereference the resulting valid pointer, that seems just as reasonable at compile time as it does at runtime.</p>\n</blockquote>\n<p>to me, it really doesn't.^^ (or, well, maybe it does, but only insofar as I think this is a rather unreasonable thing to do even at runtime. ;) to wit: all the \"fun\" we are having due to provenance. there <em>is</em> a very reasonable way to do ptr-int-roundtrips at runtime, but sadly that's not what C did so here we are...)<br>\nif we want to support something like this, I'd much rather add const intrinsics to directly manipulate the low bits of a ptr value, than support ptr-int-casts.</p>",
        "id": 245480756,
        "sender_full_name": "RalfJ",
        "timestamp": 1625855688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245476231\">said</a>:</p>\n<blockquote>\n<p>(IIRC miri used to have, or maybe still does, code to do bitwise/arithmetic operations on <code>abstract base (aligned to N) + known offset</code> pointer values when it was possible to adjust the offset, i.e. the operation was compatible with the value of <code>N</code>)</p>\n</blockquote>\n<p>yeah it used to have that. it was a maintenance nightmare. I'm so happy that code is gone. I don't think it's worth it.<br>\n(this is the \"increasing amount of hacks\" I referred to above.)</p>",
        "id": 245480841,
        "sender_full_name": "RalfJ",
        "timestamp": 1625855738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245477415\">said</a>:</p>\n<blockquote>\n<p>so I'm confused as to what is being suggested. you can totally have an <code>usize</code> that contains an <em>abstract</em> pointer, in CTFE miri, today, AFAIK. it's just not <em>a concrete integer value</em></p>\n</blockquote>\n<p>yes and it is UB to do that (per the docs that are being added in <a href=\"https://github.com/rust-lang/rust/issues/85769\">#85769</a>). you could not do anyting useful with that <code>usize</code> anyway, <em>any</em> arithmetic operation on it would abort CTFE.</p>",
        "id": 245481015,
        "sender_full_name": "RalfJ",
        "timestamp": 1625855843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245475642\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Also, no, I'm not asking for an example of the halting problem, I'm specifically asking about cases where we can't prove that the function <em>doesn't</em> do non-deterministic things with pointer values. We are allowed to reject valid programs. So I'm wondering if there's a line we can draw that's practically useful.</p>\n</blockquote>\n<p>oh I see. hm... you'd basically have to detect when ptr-to-int transmute might happen. It would not be that hard to reject a <code>transmute</code> if it might turn a ptr into an int, though not sure how many reasonable usecases that would kill. However... I think once we have raw ptrs in const, that is basically impossible to do -- any read of a <code>*const usize</code> might actually read a pointer. If we want a sound analysis here, I don't think we can make this analysis accept enough code for this to be useful. If we don't want a sound analysis then it is irrelevant for this discussion IMO.</p>",
        "id": 245481488,
        "sender_full_name": "RalfJ",
        "timestamp": 1625856043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> \"public image\" might be not quite the right term. Maybe I should have said \"understandability\".</p>\n<p>Essentially, with each edge case the rules become harder to use. Unsafe Rust is already harder to use properly than C in some cases because of how pointers and references interact. We should try our best not to exacerbate things.</p>",
        "id": 245485828,
        "sender_full_name": "Lokathor",
        "timestamp": 1625858427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> So, I feel like that kinda dodges the real question about pointers and non-determinism somewhat.</p>",
        "id": 245492191,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625861747
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Playing with the low bits of pointers, or otherwise swizzling and unswizzling pointers, is the kind of trick people reasonably expect to be able to do with a systems programming language; they do it with C and they do it with Rust. If the compiler tries to prevent people from doing that, people are going to start searching for the \"stop that\" hammer until the compiler relents.</p>",
        "id": 245492388,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625861834
    },
    {
        "content": "<p>CTFE is another matter, and if there's a genuine reason why we <em>can't</em> support it there, that'd be unfortunate but <em>might</em> not be a showstopper. But it always needs to remain possible at runtime, and I generally feel that anything we can do at runtime that doesn't depend on runtime inputs should be possible at compile time as well.</p>",
        "id": 245492536,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625861907
    },
    {
        "content": "<p>I do appreciate that compilers make provenance a thing, and that we have to cope with that. That may limit the degree to which people can pull even more exotic tricks that might jump from one pointer to a different one, without explicitly informing the compiler about the provenance of the pointer they're using. But provenance shouldn't prevent taking pointer A, reversibly swizzling it, unswizzling it back to pointer A, and dereferencing it, as long as the compiler remembers that it was pointer A with the provenance of pointer A.</p>",
        "id": 245492691,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625861988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245481488\">said</a>:</p>\n<blockquote>\n<p>However... I think once we have raw ptrs in const, that is basically impossible to do -- any read of a <code>*const usize</code> might actually read a pointer. If we want a sound analysis here, I don't think we can make this analysis accept enough code for this to be useful.</p>\n</blockquote>\n<p>I'm definitely talking about a sound analysis. Setting aside the current CTFE architecture for a moment, isn't this possible by tracking abstract pointers even when they're stored in ints, and doing symbolic evaluation on them while treating the abstract pointer value as opaque? For a first pass, this could just error out the moment you do something that depends on the value of the pointer other than the bits determined by its alignment; that alone would be enough to handle usage of the low-bits, for instance.</p>",
        "id": 245493133,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862199
    },
    {
        "content": "<p>I <em>think</em> you'd just need \"what is this an abstract pointer to\" and \"what's the current offset from the abstract pointer\" to make that work.</p>",
        "id": 245493171,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862224
    },
    {
        "content": "<p><code>struct AbstractPointerInt(AbstractPointer, target_usize)</code></p>",
        "id": 245493262,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862263
    },
    {
        "content": "<p>That would be enough to, for instance, do CTFE involving a hash table that makes use of low pointer bits.</p>",
        "id": 245493438,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Can.20we.20make.20more.20.60const.20unsafe.60.20now.3F/near/245492388\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> Playing with the low bits of pointers, or otherwise swizzling and unswizzling pointers, is the kind of trick people reasonably expect to be able to do with a systems programming language; they do it with C and they do it with Rust. If the compiler tries to prevent people from doing that, people are going to start searching for the \"stop that\" hammer until the compiler relents.</p>\n</blockquote>\n<p>I'm not opposed to manipulating the low bits of a pointer. I am just saying that casting the ptr to an int, doing the manipulation there, and casting back, is a <em>horrible</em> API for this purpose. It's a bad API even for runtime code, since it loses provenance (making compiler analyses a lot harder or even impossible). It's even worse for CTFE, since losing provenance there is a deal breaker.</p>\n<p>So, I don't want to take away these tricks from anyone. I just want those tricks to be provided with a sane API. Rust has in many cases decided to provide better APIs than C does (this is most apparent around integers: no implicit integer type promotion, no implicit UB on overflow, nice methods to perform checked arithmetic... also leading <code>0</code> does not implicitly mean \"octal\", and tons of things like that). I am saying Rust should do the same for \"low-level pointer tricks\". Just because C does it one way, doesn't mean that's the best way to do it.</p>",
        "id": 245536027,
        "sender_full_name": "RalfJ",
        "timestamp": 1625902921
    },
    {
        "content": "<p>The smallest change we could do to the API is to remove int-to-ptr casts, and replace them by</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">int_to_ptr</span><span class=\"p\">(</span><span class=\"n\">addr</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">provenance</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which is specified to combine the address of <code>addr</code> with the provenance of <code>provenance</code>, and return the resulting pointer. <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> has been saying all along that that's a much saner way to to int-to-ptr casts, and some colleagues that are formally verifying low-level C code (some hypervisor implementation) used this as a compromise with the engineers: the engineers said we really need ptr-int-casts, the verification people said but those are horrible to verify, and they found that with this API verification people could live fine and the hope is engineers are also okay with it. ;)  (EDIT: turns out what thy do is a lot more subtle than this, oh well)<br>\nIf I could just make a single breaking change in Rust, I think it would be this.</p>",
        "id": 245536358,
        "sender_full_name": "RalfJ",
        "timestamp": 1625903407
    },
    {
        "content": "<p>For CTFE it's a bit more tricky since we don't have absolute addresses... basically if you use a different provenance than what you started with when casting the ptr to an int, you get nonsense. If you inspect the int, you'll notice it's just the offset from the beginning of the allocation -- like a \"relative\" address. So I am not sure if that is sufficiently understandable in <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>'s terms. It'd basically mean that <code>ptr as usize</code> works (deterministically) at const-time but has a very different meaning.<br>\nI think we might be better off providing more targeted, fully deterministic APIs for the things people need to do on pointers (such as working with the low bits).</p>",
        "id": 245536457,
        "sender_full_name": "RalfJ",
        "timestamp": 1625903548
    },
    {
        "content": "<p>However, we have now diverged very far from my original question. we started with determinism in <code>const fn</code>, now we are talking about how to support ptr-int casts in <code>const fn</code>. Lucky enough we have <a href=\"#narrow/stream/213817-t-lang/topic/Stabilize.20const_fn_transmute.2C.20const_fn_union\">another thread</a> in T-lang, so we can continue the original discussion there.^^</p>",
        "id": 245536592,
        "sender_full_name": "RalfJ",
        "timestamp": 1625903802
    }
]