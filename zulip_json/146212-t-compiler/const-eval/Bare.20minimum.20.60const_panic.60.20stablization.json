[
    {
        "content": "<p>The blocking concern of stabilising const panic in <a href=\"https://github.com/rust-lang/rust/issues/85194\">#85194</a> is the edition 2021 difference. Given that there is <a href=\"https://github.com/rust-lang/rust/issues/86998\">#86998</a>, would it make sense to stabilise the bare minimum of <code>const_panic</code>, aka <code>panic!(literal)</code> where the literal does not contain <code>{</code> or <code>}</code>? Stabilisation of <code>panic!(const_str)</code> or <code>panic!(\"{}\", const_str)</code> could be deferred.</p>",
        "id": 252870367,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631321814
    },
    {
        "content": "<p>I think we should just put in the work to get <code>panic!(\"{}\", some_str)</code> working. It seems like it wouldn't really need that much more work to get working</p>",
        "id": 252903594,
        "sender_full_name": "oli",
        "timestamp": 1631360522
    },
    {
        "content": "<p>It would require ~const.</p>",
        "id": 252913812,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631371246
    },
    {
        "content": "<p>actually it probably would just require a macro match arm to match on \"{}\" and convert that to just the some_str</p>",
        "id": 252914370,
        "sender_full_name": "Lokathor",
        "timestamp": 1631371866
    },
    {
        "content": "<p>assuming some_str must also be a static string</p>",
        "id": 252914379,
        "sender_full_name": "Lokathor",
        "timestamp": 1631371879
    },
    {
        "content": "<p>It's ok for literal</p>",
        "id": 252920679,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631378296
    },
    {
        "content": "<p>But ~const is needed for computed strings</p>",
        "id": 252920682,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631378302
    },
    {
        "content": "<p>The <code>const_format</code> assertion macros need to be able to panic with a <code>&amp;'static str</code> non-literal constant,<br>\nthough that could be done with a function instead of the panic macro.<br>\nIt's a false dichotomy to say that it must be either \"just literal panic messages\" or \"full support for compile-time formatting\"</p>",
        "id": 252932281,
        "sender_full_name": "matt1992",
        "timestamp": 1631391146
    },
    {
        "content": "<p>I don't think it's desirable to have additional functions just for panicking in const context.</p>",
        "id": 252932486,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391424
    },
    {
        "content": "<p>We already have <code>panic_str</code>, but that should be the <em>temporary</em> solution.</p>",
        "id": 252932496,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391450
    },
    {
        "content": "<p>I propose to just have <code>panic!(literal)</code> stabilised because it's better than nothing. We can still improve later and allow more types of const panic</p>",
        "id": 252932573,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391533
    },
    {
        "content": "<p>isn't 2021 moving away from that though?</p>",
        "id": 252932603,
        "sender_full_name": "Lokathor",
        "timestamp": 1631391580
    },
    {
        "content": "<p>i thought that was the whole issue</p>",
        "id": 252932609,
        "sender_full_name": "Lokathor",
        "timestamp": 1631391589
    },
    {
        "content": "<p>Yes, so that's why I want to enforce that the literal does not contain { or }</p>",
        "id": 252932670,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391619
    },
    {
        "content": "<p>Because we don't want to introduce things possible in 2015/18 but not in 2021.</p>",
        "id": 252932681,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391641
    },
    {
        "content": "<p>would one be allowed to use {{ and }} like a normal format situation?</p>",
        "id": 252932700,
        "sender_full_name": "Lokathor",
        "timestamp": 1631391674
    },
    {
        "content": "<p>I would say it should be allowed in 2021, but not in 2018 (because it'll print {{}} verbatim rather than {}).</p>",
        "id": 252932725,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391716
    },
    {
        "content": "<p>that can at least be explained to the public without feeling inconsistent</p>",
        "id": 252932849,
        "sender_full_name": "Lokathor",
        "timestamp": 1631391807
    },
    {
        "content": "<p>My rough plan is to scan the first token of non-2021 <code>panic</code> invocation. If it's a literal that does not contain { or }, then forward it to <code>panic_2021</code> instead <code>panic_2015</code>. Then we could stabilise <code>const_panic</code> for panic_fmt but keep panic_str and panic_any still gated.</p>",
        "id": 252932867,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631391837
    },
    {
        "content": "<p>Turns out this plan doesn't quite work, because panic_2015 has a <code>{...}</code> wrapper while panic_2021 doesn't. And that causes subtle difference: <a href=\"https://github.com/rust-lang/rust/issues/80846\">#80846</a>.</p>",
        "id": 252950440,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631412197
    },
    {
        "content": "<p>Could we just stabilise const panic only for Rust 2021 but not 2015/18?</p>",
        "id": 252950513,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631412270
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> since you probably know the most about panic macros.</p>",
        "id": 252950622,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631412419
    },
    {
        "content": "<p>yeah, only stabilizing it for rust 2021 is probably the easiest way to go</p>",
        "id": 252979850,
        "sender_full_name": "Mara",
        "timestamp": 1631446094
    },
    {
        "content": "<p>(const panic for <code>panic!(\"literal\")</code> already works in 2021, behind the feature gate)</p>",
        "id": 252981753,
        "sender_full_name": "Mara",
        "timestamp": 1631448316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Bare.20minimum.20.60const_panic.60.20stablization/near/252913812\">said</a>:</p>\n<blockquote>\n<p>It would require ~const.</p>\n</blockquote>\n<p>we can cheat... knowing that compilation will fail anyway, we can just ignore const rules and evaluate any debug impl</p>",
        "id": 253072505,
        "sender_full_name": "oli",
        "timestamp": 1631531930
    },
    {
        "content": "<p>I wonder if a MCP is needed for that; it doesn't sound trivial to do and we likely need to add a machine for that</p>",
        "id": 253113246,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631548339
    },
    {
        "content": "<p>Or at least modifying the current one by quite a lot, so that it doesn't use mir_for_ctfe and do all the checks etc.. It sounds a little bit more powerful than unleash miri.</p>",
        "id": 253113443,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631548421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Bare.20minimum.20.60const_panic.60.20stablization/near/253072505\">said</a>:</p>\n<blockquote>\n<p>we can cheat... knowing that compilation will fail anyway, we can just ignore const rules and evaluate any debug impl</p>\n</blockquote>\n<p>I prototyped this idea and it doesn't seem to work well. Without having <code>const</code> and often not having <code>#[inline]</code>, many functions needed don't have MIR available.</p>",
        "id": 253155558,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631565114
    },
    {
        "content": "<p>hmm... makes sense. Maybe we can convince T-libs and T-lang that impl const Display for &amp;str is something we could stabilize without stabilizing the feature</p>",
        "id": 253223569,
        "sender_full_name": "oli",
        "timestamp": 1631612569
    },
    {
        "content": "<p><code>impl Display for str</code> is implemented as <code>f.pad(self)</code>: <a href=\"https://github.com/rust-lang/rust/blob/9f85cd6f2ab2769c16e89dcdddb3e11d9736b351/library/core/src/fmt/mod.rs#L2124\">https://github.com/rust-lang/rust/blob/9f85cd6f2ab2769c16e89dcdddb3e11d9736b351/library/core/src/fmt/mod.rs#L2124</a></p>\n<p><code>Formatter::pad</code> is a non-trivial function calling many other functions: <a href=\"https://github.com/rust-lang/rust/blob/master/library/core/src/fmt/mod.rs#L1372-L1417\">https://github.com/rust-lang/rust/blob/master/library/core/src/fmt/mod.rs#L1372-L1417</a></p>",
        "id": 253226435,
        "sender_full_name": "bjorn3",
        "timestamp": 1631614205
    },
    {
        "content": "<p>none of which will get called if width and precision are <code>None</code>, which is why I would have thought the \"just wing it\" solution could work</p>",
        "id": 253226578,
        "sender_full_name": "oli",
        "timestamp": 1631614308
    },
    {
        "content": "<p>so <code>const Display</code> is likely out of scope, and we need to figure out how to make the writing to stderr that the panic does simpler in const contexts</p>",
        "id": 253226835,
        "sender_full_name": "oli",
        "timestamp": 1631614461
    },
    {
        "content": "<p>or, as long as we get <code>format_args!(\"{}\", some_str)</code> to work in const contexts, we can make the panic logic in CTFE deconstruct the ArgumentV1 of the string and figure out how to print it itself.</p>",
        "id": 253226953,
        "sender_full_name": "oli",
        "timestamp": 1631614553
    },
    {
        "content": "<p>that may actually be the least hacky solution</p>",
        "id": 253226957,
        "sender_full_name": "oli",
        "timestamp": 1631614558
    },
    {
        "content": "<p>I often arrive at a solution where we add some sort of function <code>is_in_const_context</code> where when called at runtime we evaluate it to <code>false</code>, but when evaluated by the CTFE engine it returns <code>true</code>...</p>",
        "id": 253257212,
        "sender_full_name": "fee1-dead",
        "timestamp": 1631628513
    },
    {
        "content": "<p>It is so bad that it shouldn't even be exposed as a nightly feature...</p>",
        "id": 253257341,
        "sender_full_name": "fee1-dead",
        "timestamp": 1631628566
    },
    {
        "content": "<p>well.... we will need something like that <em>anyway</em> if we ever want to use SIMD or other stuff in libstd functions that should also be const fn</p>",
        "id": 253258006,
        "sender_full_name": "oli",
        "timestamp": 1631628788
    },
    {
        "content": "<p>there has been lots of discussion around \"fast runtime path\" vs \"const fn path\"</p>",
        "id": 253258082,
        "sender_full_name": "oli",
        "timestamp": 1631628815
    },
    {
        "content": "<p>and both co-existing for the same const fn, but only one getting picked depending on the caller context</p>",
        "id": 253258193,
        "sender_full_name": "oli",
        "timestamp": 1631628844
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/const-eval/issues/7#issuecomment-576243335\">https://github.com/rust-lang/const-eval/issues/7#issuecomment-576243335</a> is my idea for this</p>",
        "id": 253258350,
        "sender_full_name": "oli",
        "timestamp": 1631628902
    },
    {
        "content": "<p>it would also make it possible to \"add\" logging/tracing libraries to your const fn code</p>",
        "id": 253258559,
        "sender_full_name": "oli",
        "timestamp": 1631628966
    },
    {
        "content": "<p>I mean... technically we could add a magic generic parameter to all const fn that is <code>PhantomConst&lt;true&gt;</code> if in a const context and <code>PhantomConst&lt;false&gt;</code> otherwise. Then you can implement <code>const MyTrait for MyStruct&lt;PhantomConst&lt;true&gt;&gt;</code> and <code>MyTrait for MyStruct&lt;PhantomConst&lt;false&gt;&gt;</code>, and everything works out. If your impl is the same, you can do <code>impl&lt;const constness: bool&gt; const MyTrait for MyStruct&lt;PhantomConst&lt;constness&gt;&gt;</code> to cover both cases automatically.</p>",
        "id": 253261831,
        "sender_full_name": "oli",
        "timestamp": 1631630116
    },
    {
        "content": "<p>now we just need to make that process painless XD</p>",
        "id": 253261849,
        "sender_full_name": "oli",
        "timestamp": 1631630124
    },
    {
        "content": "<p>inside a <code>const fn</code> you could then invoke this as <code>&lt;MyStruct&lt;MAGIC&gt; as MyTrait&gt;::my_method()</code></p>",
        "id": 253262047,
        "sender_full_name": "oli",
        "timestamp": 1631630187
    },
    {
        "content": "<p>Or maybe, just special-case <code>panic!(\"{}\", ...)</code>? I have an alternative way here: <a href=\"https://github.com/nbdd0121/rust/commit/23a85bf74d0cae2841da86bf0cdf56769b2dd364\">https://github.com/nbdd0121/rust/commit/23a85bf74d0cae2841da86bf0cdf56769b2dd364</a></p>",
        "id": 253297433,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631643355
    },
    {
        "content": "<p>Wonderful. Wow. It's so simple and we can just remove it when const trait impls are a thing. I love it.</p>",
        "id": 253304099,
        "sender_full_name": "oli",
        "timestamp": 1631645881
    },
    {
        "content": "<p>While the simple trick works for const panic, I think in the long term we still want a const_eval_select. Is there anyone currently working on it?</p>",
        "id": 253317053,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631650654
    },
    {
        "content": "<p>PR filed <a href=\"https://github.com/rust-lang/rust/issues/88954\">#88954</a></p>",
        "id": 253354409,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631673686
    },
    {
        "content": "<p>I took a stab but I didn’t know how to generate the correct code on the LLVM side.</p>",
        "id": 254521674,
        "sender_full_name": "fee1-dead",
        "timestamp": 1632397953
    },
    {
        "content": "<p>When it generates function calls, it takes a slice of Values, but for the intrinsics codegen I have a slice of Operands.</p>",
        "id": 254522278,
        "sender_full_name": "fee1-dead",
        "timestamp": 1632398289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Bare.20minimum.20.60const_panic.60.20stablization/near/254522278\">said</a>:</p>\n<blockquote>\n<p>When it generates function calls, it takes a slice of Values, but for the intrinsics codegen I have a slice of Operands.</p>\n</blockquote>\n<p>the code that codegens function calls also starts out with operands, maybe forward to that? or, hopefully less intrusive: at the site where we decide a call is an intrinsic, replace the instance with the runtime instance and proceed on the non-intri path</p>",
        "id": 254524738,
        "sender_full_name": "oli",
        "timestamp": 1632399524
    },
    {
        "content": "<p>I wonder if instead of <code>const_eval_select&lt;ARG, F, G, RET&gt;(ARG, F, G) -&gt; RET</code> we could have <code>call_if_rt&lt;ARG, F&gt;(F, ARG) -&gt; Option&lt;(F as Fn&lt;Arg&gt;)::Output&gt;</code>. The later will allow us to keep the const logic in the same function, and can have bound on F enforced by typeck without special code.</p>",
        "id": 254566096,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632415328
    },
    {
        "content": "<p>oh heh, that's a neat trick</p>",
        "id": 254590208,
        "sender_full_name": "oli",
        "timestamp": 1632425026
    },
    {
        "content": "<p>could even simplify it more by making it return a bool and having F not have any return type or arguments</p>",
        "id": 254590301,
        "sender_full_name": "oli",
        "timestamp": 1632425049
    },
    {
        "content": "<p>then we just use a closure and pass arguments by using local vars from the outside scope</p>",
        "id": 254590458,
        "sender_full_name": "oli",
        "timestamp": 1632425123
    },
    {
        "content": "<p>in const mode, the closure is still created, but that's fine, as long as we don't call it, there is no error</p>",
        "id": 254590499,
        "sender_full_name": "oli",
        "timestamp": 1632425144
    },
    {
        "content": "<p>Returning bool is problematic because dataflow does not know if the local vars are initialized. With <code>Option</code> you can just do a <code>if let Some(x) = call_if_rt(... ) { return x; }</code>. Passing no arguments might be okay.</p>",
        "id": 254594808,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632426938
    },
    {
        "content": "<p>oh duh, right</p>",
        "id": 254693271,
        "sender_full_name": "oli",
        "timestamp": 1632485493
    },
    {
        "content": "<p>I have dug into it again, and I found a pretty simple method, using <code>codegen_call_terminator</code> within itself:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">intrinsic</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">sym</span>::<span class=\"n\">const_eval_select</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// We don't need anything more at this point.</span>\n<span class=\"w\">            </span><span class=\"c1\">// we just need to codegen this as a call to the third argument with a single argument</span>\n<span class=\"w\">            </span><span class=\"c1\">// passed (that is the first element of this function call).</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">codegen_call_terminator</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">helper</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">bx</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">terminator</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"o\">&amp;</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"o\">&amp;</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"o\">..=</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">destination</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">cleanup</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">fn_span</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And then I get a linker error:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: linking with `cc` failed: exit status: 1\n   |\n   = note: &quot;cc&quot; &quot;-m64&quot; -snip-\n\n   = note: /usr/bin/ld: /rust/build/x86_64-unknown-linux-musl/test/ui/intrinsics/const-eval-select-x86_64/a.const_eval_select_x86_64.d828b235-cgu.0.rcgu.o: in function `const_eval_select_x86_64::main&#39;:\n           const_eval_select_x86_64.d828b235-cgu.0:(.text._ZN24const_eval_select_x86_644main17h3b2c5442a737866cE+0x36): undefined reference to `const_eval_select_x86_64::eq_rt&#39;\n           /usr/bin/ld: const_eval_select_x86_64.d828b235-cgu.0:(.text._ZN24const_eval_select_x86_644main17h3b2c5442a737866cE+0x67): undefined reference to `const_eval_select_x86_64::eq_rt&#39;\n           collect2: error: ld returned 1 exit status\n\n   = help: some `extern` functions couldn&#39;t be found; some native libraries may need to be installed or have their path specified\n   = note: use the `-l` flag to specify native libraries to link\n   = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n\nerror: aborting due to previous error\n</code></pre></div>",
        "id": 254847400,
        "sender_full_name": "fee1-dead",
        "timestamp": 1632583127
    },
    {
        "content": "<p>oh wow XD Probably need to collect the runtime function in <a href=\"https://github.com/rust-lang/rust/blob/97032a6dfacdd3548e4bff98c90a6b3875a14077/compiler/rustc_monomorphize/src/collector.rs\">https://github.com/rust-lang/rust/blob/97032a6dfacdd3548e4bff98c90a6b3875a14077/compiler/rustc_monomorphize/src/collector.rs</a>, but I'm not sure where</p>",
        "id": 254847998,
        "sender_full_name": "oli",
        "timestamp": 1632583680
    },
    {
        "content": "<p>Thanks for the pointer, I found it. and if the tests pass I will be submitting a PR soon.</p>",
        "id": 254849114,
        "sender_full_name": "fee1-dead",
        "timestamp": 1632584663
    },
    {
        "content": "<p>I came up with a new approach that does the same thing but requires no codegen changes at all, inspired from panic_fmt and const_panic_fmt</p>",
        "id": 254863794,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632597859
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[lang = </span><span class=\"s\">\"call_if_rt\"</span><span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">call_if_rt</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Copy</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[lang = </span><span class=\"s\">\"const_call_if_rt\"</span><span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">const_call_if_rt</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Copy</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 254863846,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632597931
    },
    {
        "content": "<p>We can simply redirect the call_if_rt to const_call_if_rt just like what we do for panic_fmt and const_panic_fmt.</p>",
        "id": 254863957,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632598021
    },
    {
        "content": "<p>I like this a lot</p>",
        "id": 254932918,
        "sender_full_name": "oli",
        "timestamp": 1632664248
    },
    {
        "content": "<p>Needs no codegen or typeck changes and just a small thing in ctfe to switch the function</p>",
        "id": 254932937,
        "sender_full_name": "oli",
        "timestamp": 1632664275
    }
]