[
    {
        "content": "<p>What are the odds that a \"dedicated beginner\" (me) could implement dataflow-based const qualification?</p>\n<p>I've read some of the background information (<a href=\"https://github.com/rust-lang/rust/issues/53819\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/53819\">#53819</a>), so I have a rough idea of what is needed. I think this is the next logical step now that <a href=\"https://github.com/rust-lang/rust/issues/58403\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/58403\">#58403</a> has been merged. I'll briefly explain how I would implement this so you can tell me if I'm way off base.</p>\n<p>There's currently 4 different qualifications: <code>HasMutInterior</code>, <code>NeedsDrop</code>, <code>IsNotPromotable</code>, <code>IsNotImplicitlyPromotable</code>. Dataflow analysis would track the whether each local is definitely not <code>Qual</code> or maybe <code>Qual</code> (where <code>Qual</code> is one of the aforementioned qualifications). A const block like <code>let a = if 1 == 2 { Some(Vec::new()) } else { None }</code> would result in <code>a</code> being maybe <code>NeedsDrop</code>. There's already a generic framework for bitvector dataflow analysis on MIR, but I'm not sure if it will work here. The <code>join</code> operation for this analysis is  just a union (if a local is maybe qualified from one entrypoint and definitely not qualified from another, it becomes maybe qualifed), but <code>trans</code> is a bit more complex since when one local is assigned to another, its qualification bits must also be copied over. I don't think a simple <code>gen</code>/<code>kill</code> framework allows this.</p>\n<p>I don't want to slow down implementation of this feature if it's already on someone's todo list, since I will probably be pretty slow. But if @eddyb is super busy, maybe I could help move this along?</p>",
        "id": 167138317,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559508982
    },
    {
        "content": "<p>Sorry for the extensive edits; this got posted while I was editing it.</p>",
        "id": 167138833,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559509926
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/60166/files#r289447620\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/60166/files#r289447620\">https://github.com/rust-lang/rust/pull/60166/files#r289447620</a> should probably also land before this is tackled</p>",
        "id": 167139022,
        "sender_full_name": "RalfJ",
        "timestamp": 1559510315
    },
    {
        "content": "<p>Oh and is there any reason <code>IsNotPromotable</code> is not called <code>IsNotConst</code>? I thought implicit promotion is the only promotion we'd have, I never saw the other thing (\"normal const stuff\") be called \"promotion\".</p>",
        "id": 167139042,
        "sender_full_name": "RalfJ",
        "timestamp": 1559510388
    },
    {
        "content": "<p>In my reading, I found PR <a href=\"https://github.com/rust-lang/rust/issues/59796\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/59796\">#59796</a> that made the change. The justification appears in <a href=\"https://github.com/rust-lang/rust/pull/58403#discussion_r265978523\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/58403#discussion_r265978523\">https://github.com/rust-lang/rust/pull/58403#discussion_r265978523</a>, but I don't understand the second bullet point under \"explicit promotion\".</p>",
        "id": 167141130,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559513706
    },
    {
        "content": "<p>so seems like this is about <code>&amp;</code> in <code>const</code> context? Hm. But something also has to check things like <code>foo</code> in <code>const X = foo</code> to e.g. not call run-time methods etc...</p>",
        "id": 167161573,
        "sender_full_name": "RalfJ",
        "timestamp": 1559546286
    },
    {
        "content": "<p>Yea.... <code>IsNotPromotable</code> is a bad name and should be <code>IsNotConst</code>, We only have special code for <code>IsNotImplicitlyPromotable</code> since we don't promote const fn calls in regular functions</p>",
        "id": 167163279,
        "sender_full_name": "oli",
        "timestamp": 1559547636
    },
    {
        "content": "<p>but <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> in that post linked above seems to say we renamed it from <code>IsNotConst</code> to <code>IsNotImplicitlyPromotable</code>?</p>",
        "id": 167167437,
        "sender_full_name": "RalfJ",
        "timestamp": 1559551176
    },
    {
        "content": "<p>I guess part of the problem here is that in <code>const X: &amp;i32 = &amp;foo();</code>, this is also called \"promotion\".</p>",
        "id": 167167526,
        "sender_full_name": "RalfJ",
        "timestamp": 1559551207
    },
    {
        "content": "<p>yea</p>",
        "id": 167169379,
        "sender_full_name": "oli",
        "timestamp": 1559552885
    },
    {
        "content": "<p>but then by which name does the analysis go that checks the part \"outside the <code>&amp;</code> in a <code>const</code>?</p>",
        "id": 167169919,
        "sender_full_name": "RalfJ",
        "timestamp": 1559553414
    },
    {
        "content": "<p>well, that's not one analysis, but two: <code>IsNotConst</code> and <code>IsNotImplicitlyPromotable</code></p>",
        "id": 167170224,
        "sender_full_name": "oli",
        "timestamp": 1559553640
    },
    {
        "content": "<p>inside a const you only run <code>IsNotConst</code></p>",
        "id": 167170232,
        "sender_full_name": "oli",
        "timestamp": 1559553646
    },
    {
        "content": "<p>I thought <code>IsNotConst</code> aka <code>IsNotPromotable</code> is what gets used inside the <code>&amp;</code>? Or is that the same thing as outside? (IIRC not, because of concerns like interior mutability)</p>",
        "id": 167170772,
        "sender_full_name": "RalfJ",
        "timestamp": 1559554018
    },
    {
        "content": "<p>wait what</p>",
        "id": 167173460,
        "sender_full_name": "eddyb",
        "timestamp": 1559556186
    },
    {
        "content": "<p>I thought we decided <code>IsNotConst</code> was a pointless name?</p>",
        "id": 167173479,
        "sender_full_name": "eddyb",
        "timestamp": 1559556209
    },
    {
        "content": "<p>\"not const\" is either \"not promotable\" or \"an error anyway\"</p>",
        "id": 167173501,
        "sender_full_name": "eddyb",
        "timestamp": 1559556241
    },
    {
        "content": "<p>depending on context</p>",
        "id": 167173543,
        "sender_full_name": "eddyb",
        "timestamp": 1559556245
    },
    {
        "content": "<blockquote>\n<p>but then by which name does the analysis go that checks the part \"outside the <code>&amp;</code> in a const?</p>\n</blockquote>\n<p>it doesn't have a qualification name, that just emits errors</p>",
        "id": 167173571,
        "sender_full_name": "eddyb",
        "timestamp": 1559556284
    },
    {
        "content": "<p>like, the qualifications are properties of values, and \"const-checking errored\" isn't really one</p>",
        "id": 167173601,
        "sender_full_name": "eddyb",
        "timestamp": 1559556320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> does that make sense?</p>",
        "id": 167173606,
        "sender_full_name": "eddyb",
        "timestamp": 1559556328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> \"There's already a generic framework for bitvector dataflow analysis on MIR, but I'm not sure if it will work here\" - yes, that is precisely what we mean by \"dataflow\"</p>",
        "id": 167173688,
        "sender_full_name": "eddyb",
        "timestamp": 1559556390
    },
    {
        "content": "<p>I <em>never</em> intended for anyone to write a dataflow implementation themselves, I'm sorry if that was ever an interpretation of anything I said</p>",
        "id": 167173705,
        "sender_full_name": "eddyb",
        "timestamp": 1559556413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> so, each <code>Qualif</code> becomes one dataflow implementation (and, yeah, <code>IsNotX</code> should become <code>MaybeNotX</code> and the rest get prefixed with <code>Maybe</code>) - you can do this generically, using the <code>Qualif</code> trait, FWIW</p>",
        "id": 167173882,
        "sender_full_name": "eddyb",
        "timestamp": 1559556582
    },
    {
        "content": "<p>union is <code>|</code> and on assignment you <code>gen</code> (which is <code>|=</code>, really)</p>",
        "id": 167173962,
        "sender_full_name": "eddyb",
        "timestamp": 1559556605
    },
    {
        "content": "<p>you'd never kill anything atm (maybe in the future if we allow an assignment to \"clear\" flags)</p>",
        "id": 167173981,
        "sender_full_name": "eddyb",
        "timestamp": 1559556625
    },
    {
        "content": "<p>oh I guess you do kill <code>MaybeNeedsDrop</code> on an <code>Operand::Move</code>, sorry</p>",
        "id": 167173996,
        "sender_full_name": "eddyb",
        "timestamp": 1559556651
    },
    {
        "content": "<p>but that's it</p>",
        "id": 167173999,
        "sender_full_name": "eddyb",
        "timestamp": 1559556656
    },
    {
        "content": "<p>like, <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/impls/storage_liveness.rs\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/impls/storage_liveness.rs\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/impls/storage_liveness.rs</a> is pretty okay template to start off with</p>",
        "id": 167174035,
        "sender_full_name": "eddyb",
        "timestamp": 1559556708
    },
    {
        "content": "<p>computing the dataflow should be easy, the slightly trickier part is inspecting the results (because we don't have an ergonomic cursor for it yet)</p>",
        "id": 167174092,
        "sender_full_name": "eddyb",
        "timestamp": 1559556744
    },
    {
        "content": "<p>or, actually, we don't have to rename anything, you could have <code>Maybe&lt;NeedsDrop&gt;</code> where <code>Maybe</code> is the wrapper that does dataflow</p>",
        "id": 167174125,
        "sender_full_name": "eddyb",
        "timestamp": 1559556791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> the most important thing is something like <code>some_simd_intrinsic_with_required_const_arg(a, b, 123)</code> - that's forceful promotion so it allows <code>const fn</code> calls, unlike implicit promotion</p>",
        "id": 167174253,
        "sender_full_name": "eddyb",
        "timestamp": 1559556916
    },
    {
        "content": "<blockquote>\n<p>like, the qualifications are properties of values, and \"const-checking errored\" isn't really one</p>\n</blockquote>\n<p>that's weird, where is const-checking happening then?^^</p>",
        "id": 167174680,
        "sender_full_name": "RalfJ",
        "timestamp": 1559557254
    },
    {
        "content": "<blockquote>\n<p>that's forceful promotion so it allows const fn calls, unlike implicit promotion</p>\n</blockquote>\n<p>this is still not syntactically visible as <code>const</code> context. Seems dangerous to me.</p>",
        "id": 167174806,
        "sender_full_name": "RalfJ",
        "timestamp": 1559557324
    },
    {
        "content": "<p>Last time we were like \"sure let's just allow <code>const fn</code> there\" we painted ourselves into a very bad corner. Did we just repeat that mistake...? :(</p>",
        "id": 167174838,
        "sender_full_name": "RalfJ",
        "timestamp": 1559557359
    },
    {
        "content": "<p>also, \"calls <code>const fn</code>\" is not a property of a value, so I am very confused now about what these \"qualifications\" are</p>",
        "id": 167174906,
        "sender_full_name": "RalfJ",
        "timestamp": 1559557416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> ^</p>",
        "id": 167193911,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571415
    },
    {
        "content": "<p>const-checking \"just happens\". it emits errors</p>",
        "id": 167194102,
        "sender_full_name": "eddyb",
        "timestamp": 1559571516
    },
    {
        "content": "<p>it's not reified into flags. it either errors and prevents compilation from succeeding, or doesn't</p>",
        "id": 167194151,
        "sender_full_name": "eddyb",
        "timestamp": 1559571544
    },
    {
        "content": "<p>\"the computation of this value may involve a <code>const fn</code> call\" is a better description, I guess</p>",
        "id": 167194210,
        "sender_full_name": "eddyb",
        "timestamp": 1559571581
    },
    {
        "content": "<blockquote>\n<p>const-checking \"just happens\". it emits errors</p>\n</blockquote>\n<p>well that does not seem to work: <a href=\"https://github.com/rust-lang/rust/pull/61399#discussion_r289727281\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/61399#discussion_r289727281\">https://github.com/rust-lang/rust/pull/61399#discussion_r289727281</a></p>",
        "id": 167194214,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571583
    },
    {
        "content": "<p>there we have code that calls a non-const intrinsic, which is allowed -- the check supposed to prevent that is in <code>IsNotPromotable::in_call</code></p>",
        "id": 167194295,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571606
    },
    {
        "content": "<blockquote>\n<p>\"the computation of this value may involve a <code>const fn</code> call\" is a better description, I guess</p>\n</blockquote>\n<p>it's not <em>values</em> then that matter, but locals? because \"the computation of a value\" is a nonesneical statement, a value (e.g. <code>3</code>) is already computed</p>",
        "id": 167194357,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571639
    },
    {
        "content": "<p>I'd love if these qualifications could be stated as syntactic appromximations of dynamic properties of a semantic value, but that is seemingly not the case</p>",
        "id": 167194407,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571668
    },
    {
        "content": "<p>I don't mean a concrete value, but things like <code>Operand</code>s</p>",
        "id": 167194422,
        "sender_full_name": "eddyb",
        "timestamp": 1559571675
    },
    {
        "content": "<p>so, expressions?</p>",
        "id": 167194448,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571691
    },
    {
        "content": "<p>they're not \"expressions\" in MIR, that's my point</p>",
        "id": 167194473,
        "sender_full_name": "eddyb",
        "timestamp": 1559571705
    },
    {
        "content": "<p>well the closest we got to a consensus in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/pull/40\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/pull/40\">https://github.com/rust-lang/unsafe-code-guidelines/pull/40</a> was to use \"expression\" for not-yet-computed things</p>",
        "id": 167194592,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571761
    },
    {
        "content": "<p>they're certainly not values either, FWIW :)</p>",
        "id": 167194613,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571774
    },
    {
        "content": "<p><code>NeedsDrop</code> and <code>HasInteriorMut</code> are properties of values</p>",
        "id": 167194656,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571799
    },
    {
        "content": "<p>though I am also sometimes confused about <code>NeedsDrop</code>, because sometimes it seems to be about whether the  computed value needs dropping, and sometimes about whether computing the value requires dropping some other stuff</p>",
        "id": 167194698,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571832
    },
    {
        "content": "<p>the latter really being a \"calling non-const fn\" kind of check</p>",
        "id": 167194758,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571844
    },
    {
        "content": "<p>no, it's definitely not the latter</p>",
        "id": 167194761,
        "sender_full_name": "eddyb",
        "timestamp": 1559571844
    },
    {
        "content": "<p>drops aren't part of the computation, they're side-effects that aren't tracked by any of this</p>",
        "id": 167194884,
        "sender_full_name": "eddyb",
        "timestamp": 1559571906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I guess you could s/expression/dataflow (sub)graph</p>",
        "id": 167194918,
        "sender_full_name": "eddyb",
        "timestamp": 1559571923
    },
    {
        "content": "<p>the point is, we have some checks for stuff that need to happen in const context -- such as only calling const fn, not doing forbidden operations (ptr-int casts or so), and so on. the same checks are also relevant when determining candidates for implicit promotion, and the same checks apply in \"explicit promotion\". So I thought this would all be the same framework.</p>",
        "id": 167194938,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571933
    },
    {
        "content": "<blockquote>\n<p>drops aren't part of the computation, they're side-effects that aren't tracked by any of this</p>\n</blockquote>\n<p>drops are definitely part of the computation though... at least the drops happening during the computation</p>",
        "id": 167194973,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571954
    },
    {
        "content": "<p>we don't actually look at <code>Drop</code> terminators</p>",
        "id": 167195047,
        "sender_full_name": "eddyb",
        "timestamp": 1559571975
    },
    {
        "content": "<p>oO</p>",
        "id": 167195067,
        "sender_full_name": "RalfJ",
        "timestamp": 1559571986
    },
    {
        "content": "<p>so I don't know why you thought that</p>",
        "id": 167195082,
        "sender_full_name": "eddyb",
        "timestamp": 1559571995
    },
    {
        "content": "<p>well because its the only thing that makes sense?^^</p>",
        "id": 167195102,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572004
    },
    {
        "content": "<p>maybe you confused with the side-effect <code>Operand::Move</code> has?</p>",
        "id": 167195109,
        "sender_full_name": "eddyb",
        "timestamp": 1559572007
    },
    {
        "content": "<p>why would it make sense?</p>",
        "id": 167195120,
        "sender_full_name": "eddyb",
        "timestamp": 1559572013
    },
    {
        "content": "<p>the only reason we want to prevent drops is to avoid calling drop glue that is not a <code>const fn</code> right?</p>",
        "id": 167195161,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572033
    },
    {
        "content": "<p><code>NeedsDrop</code> is \"<code>Drop(x)</code> might not be a noop\"</p>",
        "id": 167195165,
        "sender_full_name": "eddyb",
        "timestamp": 1559572037
    },
    {
        "content": "<p>so for normal calls we look at <code>Call</code> terminators, and then we also need to separately take care of the implicit drop calls</p>",
        "id": 167195178,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572051
    },
    {
        "content": "<p>that's the dynamic property we actually care about: dont execute a <code>Drop</code> terminator</p>",
        "id": 167195186,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572062
    },
    {
        "content": "<p>brb then I'll look at the code and explain this a bit better</p>",
        "id": 167195195,
        "sender_full_name": "eddyb",
        "timestamp": 1559572071
    },
    {
        "content": "<p>but anyway, in const contexts, we emit errors. whether we emit all the errors we should is another story, and consititutes bugs, basically</p>",
        "id": 167195278,
        "sender_full_name": "eddyb",
        "timestamp": 1559572096
    },
    {
        "content": "<p><code>NeedsDrop</code> is a different thing, I understand that. we also need to make sure <code>const</code> dont need dropping or so.</p>",
        "id": 167195280,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572097
    },
    {
        "content": "<p>but the other thing also has to be checked somewhere</p>",
        "id": 167195289,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572102
    },
    {
        "content": "<p>but taking a step back -- <code>IsNotPromotable::in_call</code> performs some crucial checks that should be done for <em>any function call in const context</em>. and that makes sense, after all this is about whether some function call can be (explicitly?) promoted to context context. So to me this really sounds like an <code>IsNotConst</code> analysis. And the fact that we don't treat it as such seems to already cause bugs -- and I don't understand how we even ended up there.</p>",
        "id": 167195595,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572242
    },
    {
        "content": "<p>I dont see a qualitative difference between the kind of checks that need to be done in <code>const</code> context to determine if this is okay, and the kind of checks that need to be done \"on parts of the MIR of a normal function\" to determine if we can promote it. many of the checks are very similar, just the latter case should be a bit more restrictive.<br>\nThe fact that we have <em>two different</em> kinds of things working \"on parts of the MIR of a normal function\" makes me very uneasy. I don't see any good argument for that. We already have a way to explicitly ask for const context (and hence get everything \"promoted\"): make it a <code>const</code> item.</p>",
        "id": 167195878,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572381
    },
    {
        "content": "<p>I don't think the niche usecase of SIMD intrinsics with some arguments having to be <code>const</code> justifies making promotability analysis (an extremely subtle piece of code with a history of bugs) more complicated</p>",
        "id": 167195952,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572430
    },
    {
        "content": "<p><em>sigh</em></p>",
        "id": 167196020,
        "sender_full_name": "eddyb",
        "timestamp": 1559572447
    },
    {
        "content": "<p>so, <code>Drop</code>: we <em>read</em> <code>NeedsDrop</code>, but not <em>write</em> it: <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1357\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1357\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1357</a></p>",
        "id": 167196170,
        "sender_full_name": "eddyb",
        "timestamp": 1559572530
    },
    {
        "content": "<p>does this make sense?</p>",
        "id": 167196205,
        "sender_full_name": "eddyb",
        "timestamp": 1559572555
    },
    {
        "content": "<p><code>NeedsDrop</code> doesn't capture that a <code>Drop</code> has happened or might happen or anything like that</p>",
        "id": 167196311,
        "sender_full_name": "eddyb",
        "timestamp": 1559572593
    },
    {
        "content": "<p>this looks wrong tho <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L489\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L489\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L489</a></p>",
        "id": 167196402,
        "sender_full_name": "eddyb",
        "timestamp": 1559572650
    },
    {
        "content": "<p>yeah I got that :) now I am not sure where \"the other\" drop analysis is happening though but that's okay. probably the same place as some of the other things that I dont know where they are happening.</p>",
        "id": 167196436,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572676
    },
    {
        "content": "<p>uhm, there is no other analysis?</p>",
        "id": 167196498,
        "sender_full_name": "eddyb",
        "timestamp": 1559572691
    },
    {
        "content": "<p>I really don't know what you're talking about</p>",
        "id": 167196505,
        "sender_full_name": "eddyb",
        "timestamp": 1559572696
    },
    {
        "content": "<p>\"const checking\", wherever that is in the code</p>",
        "id": 167196538,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572727
    },
    {
        "content": "<p>no, that is the check</p>",
        "id": 167196585,
        "sender_full_name": "eddyb",
        "timestamp": 1559572755
    },
    {
        "content": "<p>you're looking at it</p>",
        "id": 167196589,
        "sender_full_name": "eddyb",
        "timestamp": 1559572758
    },
    {
        "content": "<p>that's const-checking</p>",
        "id": 167196594,
        "sender_full_name": "eddyb",
        "timestamp": 1559572761
    },
    {
        "content": "<p>the \"other drop analysis\" is the one that makes this an error:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">).</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>",
        "id": 167196714,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572808
    },
    {
        "content": "<p>what I linked is what causes that error</p>",
        "id": 167196756,
        "sender_full_name": "eddyb",
        "timestamp": 1559572841
    },
    {
        "content": "<p>it really is that simple</p>",
        "id": 167196795,
        "sender_full_name": "eddyb",
        "timestamp": 1559572862
    },
    {
        "content": "<p>simple?!??</p>",
        "id": 167196820,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572874
    },
    {
        "content": "<p>this is all crazy complicated^^</p>",
        "id": 167196825,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572879
    },
    {
        "content": "<p>simple would be \"walk the MIR, if there is a <code>Drop</code> terminator then complain\". or something like that.</p>",
        "id": 167196857,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572898
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1370-L1371\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1370-L1371\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1370-L1371</a></p>",
        "id": 167196865,
        "sender_full_name": "eddyb",
        "timestamp": 1559572902
    },
    {
        "content": "<p>it's right here</p>",
        "id": 167196868,
        "sender_full_name": "eddyb",
        "timestamp": 1559572905
    },
    {
        "content": "<p>yes, this is what this is <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1348\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1348\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1348</a></p>",
        "id": 167196879,
        "sender_full_name": "eddyb",
        "timestamp": 1559572913
    },
    {
        "content": "<p>this is just a visit of the MIR</p>",
        "id": 167196882,
        "sender_full_name": "eddyb",
        "timestamp": 1559572916
    },
    {
        "content": "<p>but this is... not part of any qualif...?</p>",
        "id": 167196965,
        "sender_full_name": "RalfJ",
        "timestamp": 1559572949
    },
    {
        "content": "<p>it checks <code>NeedsDrop</code> because this runs pre-elaboration (drop elaboration has to run after borrowck but this code must run before borrowck)</p>",
        "id": 167196970,
        "sender_full_name": "eddyb",
        "timestamp": 1559572953
    },
    {
        "content": "<p>no, it's inside this impl block <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L923-L928\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L923-L928\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L923-L928</a></p>",
        "id": 167196999,
        "sender_full_name": "eddyb",
        "timestamp": 1559572977
    },
    {
        "content": "<p>hm okay</p>",
        "id": 167197062,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573036
    },
    {
        "content": "<p>the qualifs have been split out, so everything should be fairly readable now</p>",
        "id": 167197133,
        "sender_full_name": "eddyb",
        "timestamp": 1559573070
    },
    {
        "content": "<p>the overall structure is still making my head explode</p>",
        "id": 167197141,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573083
    },
    {
        "content": "<p>they are computed structurally, and then read by the checking code</p>",
        "id": 167197147,
        "sender_full_name": "eddyb",
        "timestamp": 1559573088
    },
    {
        "content": "<p>like, so where's the thing that prevents <code>&amp;(0, Foo).0</code> from being promoted?</p>",
        "id": 167197152,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573098
    },
    {
        "content": "<p>once we move to dataflow they'll be even more decoupled</p>",
        "id": 167197167,
        "sender_full_name": "eddyb",
        "timestamp": 1559573106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> that is the promotion check also reading <code>NeedsDrop</code></p>",
        "id": 167197179,
        "sender_full_name": "eddyb",
        "timestamp": 1559573117
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L760\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L760\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L760</a></p>",
        "id": 167197199,
        "sender_full_name": "eddyb",
        "timestamp": 1559573137
    },
    {
        "content": "<p>can't be that check because that shows an error (those <code>mode != Fn</code> things are very hard to understand... I got it now but there's no comments, at least not the places where these decisions are being made)</p>",
        "id": 167197206,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573144
    },
    {
        "content": "<p>(and yes it did get better than it was before, but the structure is still different from what I'd expect so I am still confused^^)</p>",
        "id": 167197368,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573257
    },
    {
        "content": "<p><code>mode != Fn</code> means this is not a runtime-only <code>Fn</code></p>",
        "id": 167197463,
        "sender_full_name": "eddyb",
        "timestamp": 1559573320
    },
    {
        "content": "<p>maybe <code>Fn</code> should be named <code>RuntimeFn</code>?</p>",
        "id": 167197471,
        "sender_full_name": "eddyb",
        "timestamp": 1559573329
    },
    {
        "content": "<p>would that help?</p>",
        "id": 167197478,
        "sender_full_name": "eddyb",
        "timestamp": 1559573336
    },
    {
        "content": "<p>yeah so this is basuically <code>if mode.is_const_context()</code>?</p>",
        "id": 167197481,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573337
    },
    {
        "content": "<p>yes</p>",
        "id": 167197496,
        "sender_full_name": "eddyb",
        "timestamp": 1559573344
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 167197503,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573350
    },
    {
        "content": "<p>or, rather <code>.may_const_eval</code> (since <code>ConstFn</code> can be called at runtime too)</p>",
        "id": 167197528,
        "sender_full_name": "eddyb",
        "timestamp": 1559573379
    },
    {
        "content": "<p>sure but that's still \"const context\" as far as I am concerned</p>",
        "id": 167197540,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573392
    },
    {
        "content": "<p>and \"const context\" is ambiguous because it could be interpreted as <code>Mode::Const</code></p>",
        "id": 167197543,
        "sender_full_name": "eddyb",
        "timestamp": 1559573394
    },
    {
        "content": "<p>right</p>",
        "id": 167197549,
        "sender_full_name": "eddyb",
        "timestamp": 1559573399
    },
    {
        "content": "<p>\"const context\" means \"typechecked according to the rules of the const-type-system\"</p>",
        "id": 167197614,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573412
    },
    {
        "content": "<p><code>may_const_eval</code> is somewhat ambiguous becuase code in a <code>RuntimeFn</code> may const-eval if it gets promoted</p>",
        "id": 167197654,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573454
    },
    {
        "content": "<p>hmm right</p>",
        "id": 167197674,
        "sender_full_name": "eddyb",
        "timestamp": 1559573468
    },
    {
        "content": "<p>crap</p>",
        "id": 167197695,
        "sender_full_name": "eddyb",
        "timestamp": 1559573491
    },
    {
        "content": "<p>that <code>return true</code> is indeed a bug</p>",
        "id": 167197704,
        "sender_full_name": "eddyb",
        "timestamp": 1559573497
    },
    {
        "content": "<p>which is the other thing that I am not clear about yet (and where I think we have a bug)</p>",
        "id": 167197707,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573498
    },
    {
        "content": "<p>ARGH</p>",
        "id": 167197708,
        "sender_full_name": "eddyb",
        "timestamp": 1559573498
    },
    {
        "content": "<p>there are no tests for it!</p>",
        "id": 167197714,
        "sender_full_name": "eddyb",
        "timestamp": 1559573504
    },
    {
        "content": "<p>it deeply saddens me that we got <em>two</em> kinds of promotion :(</p>",
        "id": 167197724,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573513
    },
    {
        "content": "<p>for what?</p>",
        "id": 167197730,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573515
    },
    {
        "content": "<p>ah</p>",
        "id": 167197739,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> we merged a boolean confusion back in my refactor and no tests caught it</p>",
        "id": 167197791,
        "sender_full_name": "eddyb",
        "timestamp": 1559573529
    },
    {
        "content": "<p>so it should be... <code>return false</code>? no that makes less sense?</p>",
        "id": 167197794,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573533
    },
    {
        "content": "<p>the <code>_ =&gt; {}</code> should be <code>_ =&gt; return true</code></p>",
        "id": 167197821,
        "sender_full_name": "eddyb",
        "timestamp": 1559573561
    },
    {
        "content": "<p>it's a whitelist</p>",
        "id": 167197823,
        "sender_full_name": "eddyb",
        "timestamp": 1559573567
    },
    {
        "content": "<p>ah and the <code>return true</code> should be <code>{}</code>?</p>",
        "id": 167197838,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573582
    },
    {
        "content": "<p>that entire match is useless where it is</p>",
        "id": 167197870,
        "sender_full_name": "oli",
        "timestamp": 1559573603
    },
    {
        "content": "<p>it should be in <a href=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1229\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1229\">https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1229</a> I believe</p>",
        "id": 167197889,
        "sender_full_name": "oli",
        "timestamp": 1559573620
    },
    {
        "content": "<p>that was the point I was getting to. which of the \"qualifs\" are used for \"const checking\"? I saw <code>NeedsDrop</code> is used, but what about the others? like, checking that calls are <code>const fn</code>?</p>",
        "id": 167197921,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573642
    },
    {
        "content": "<p>seems like most of \"const checking\" is also relevant for deciding if something should get promoted, which is why I originally thought that this was all done inside \"qualifs\"</p>",
        "id": 167197978,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573667
    },
    {
        "content": "<p>but it seems instead we have some of that duplicated (like checking for <code>NeedsDrop</code> at the <code>Drop</code> terminator for \"const checking\", and checking for <code>NeedsDrop</code> somewhere in the <code>IsNotPromotable</code> analysis)</p>",
        "id": 167198051,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573751
    },
    {
        "content": "<p>we don't check for <code>NeedsDrop</code> in <code>IsNotPromotable</code></p>",
        "id": 167198111,
        "sender_full_name": "eddyb",
        "timestamp": 1559573774
    },
    {
        "content": "<p>like, the <code>IsNot</code> are general-purpose \"for other reasons\"</p>",
        "id": 167198124,
        "sender_full_name": "eddyb",
        "timestamp": 1559573789
    },
    {
        "content": "<p>well we check for \"is there any qualif set\"</p>",
        "id": 167198132,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573803
    },
    {
        "content": "<p>at <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L760\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L760\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L760</a> as you showed me</p>",
        "id": 167198169,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573831
    },
    {
        "content": "<p>that is basically a duplicate of the <code>Drop</code> terminator check</p>",
        "id": 167198177,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573840
    },
    {
        "content": "<p>yeah</p>",
        "id": 167198181,
        "sender_full_name": "eddyb",
        "timestamp": 1559573842
    },
    {
        "content": "<p>where I thought that this would be shared (not just the analysis, but the check itself) -- part of why I was so confused</p>",
        "id": 167198208,
        "sender_full_name": "RalfJ",
        "timestamp": 1559573874
    },
    {
        "content": "<p>I mean the check is... just asking if it's set</p>",
        "id": 167198324,
        "sender_full_name": "eddyb",
        "timestamp": 1559573944
    },
    {
        "content": "<p>anyway, let's focus on figuring out this intrinsic-related bug :/</p>",
        "id": 167198366,
        "sender_full_name": "eddyb",
        "timestamp": 1559573992
    },
    {
        "content": "<p>and then same with the <code>const fn</code> checks, which we seem to have at <a href=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1243\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1243\">https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1243</a> and <a href=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L495\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L495\">https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L495</a></p>",
        "id": 167198379,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574001
    },
    {
        "content": "<blockquote>\n<p>I mean the check is... just asking if it's set</p>\n</blockquote>\n<p>sure but it has to remember to do that in a place that has nothing to do with <code>Drop</code>.</p>",
        "id": 167198474,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574038
    },
    {
        "content": "<p>yes because that's how we defined the <code>&amp;rvalue</code> promotion</p>",
        "id": 167198515,
        "sender_full_name": "eddyb",
        "timestamp": 1559574069
    },
    {
        "content": "<p>we defined the extensional effect, not how it gets achieved.</p>",
        "id": 167198546,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574092
    },
    {
        "content": "<p>as opposed to checking if there is a <code>Drop</code> for that temporary</p>",
        "id": 167198548,
        "sender_full_name": "eddyb",
        "timestamp": 1559574097
    },
    {
        "content": "<p>which we can technically do nowadays</p>",
        "id": 167198568,
        "sender_full_name": "eddyb",
        "timestamp": 1559574116
    },
    {
        "content": "<p>it was just never considered</p>",
        "id": 167198571,
        "sender_full_name": "eddyb",
        "timestamp": 1559574119
    },
    {
        "content": "<p>I see</p>",
        "id": 167198652,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574145
    },
    {
        "content": "<p>the <code>Drop</code> check came <em>later</em></p>",
        "id": 167198668,
        "sender_full_name": "eddyb",
        "timestamp": 1559574159
    },
    {
        "content": "<p>and it was a relaxation of <code>NeedsDrop</code> values being completely banned from compile-time</p>",
        "id": 167198682,
        "sender_full_name": "eddyb",
        "timestamp": 1559574178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> confirmed boolean confusion <a href=\"https://github.com/rust-lang/rust/commit/f04424acd1bf894d1dc930c2a347871ea8b96dfa#diff-c2552a106550d05b69d5e07612f0f812L391\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/commit/f04424acd1bf894d1dc930c2a347871ea8b96dfa#diff-c2552a106550d05b69d5e07612f0f812L391\">https://github.com/rust-lang/rust/commit/f04424acd1bf894d1dc930c2a347871ea8b96dfa#diff-c2552a106550d05b69d5e07612f0f812L391</a></p>",
        "id": 167198757,
        "sender_full_name": "eddyb",
        "timestamp": 1559574239
    },
    {
        "content": "<p>do you want to fix this or should I?</p>",
        "id": 167198801,
        "sender_full_name": "eddyb",
        "timestamp": 1559574245
    },
    {
        "content": "<p>I want this fixed before we move anything around</p>",
        "id": 167198816,
        "sender_full_name": "eddyb",
        "timestamp": 1559574256
    },
    {
        "content": "<p>so what this did is allow calls to intrinsics <em>other</em> than those listed, to be promoted</p>",
        "id": 167198895,
        "sender_full_name": "eddyb",
        "timestamp": 1559574322
    },
    {
        "content": "<p><em>lol</em></p>",
        "id": 167198917,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574344
    },
    {
        "content": "<p>but does that mean that so far nobody can actually use these intrinsics in a <code>rustc_const_arg</code>? So we could just stick to not allowing them there?</p>",
        "id": 167198982,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574366
    },
    {
        "content": "<p>basically the <code>{}</code> and <code>return true</code> are swapped :(</p>",
        "id": 167198983,
        "sender_full_name": "eddyb",
        "timestamp": 1559574366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> it's important for SIMD people to be able to call their <code>const fn</code>s for these arguments</p>",
        "id": 167199023,
        "sender_full_name": "eddyb",
        "timestamp": 1559574406
    },
    {
        "content": "<p>like, this is already considered settled</p>",
        "id": 167199030,
        "sender_full_name": "eddyb",
        "timestamp": 1559574415
    },
    {
        "content": "<p>and on stable AFAIK</p>",
        "id": 167199045,
        "sender_full_name": "eddyb",
        "timestamp": 1559574422
    },
    {
        "content": "<p>swapping the two branches is not enough though</p>",
        "id": 167199068,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574449
    },
    {
        "content": "<p>because currently we also allow <em>all</em> intrinsics to be called in a <code>const fn</code></p>",
        "id": 167199080,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574458
    },
    {
        "content": "<p>(except for <code>transmute</code>)</p>",
        "id": 167199088,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574464
    },
    {
        "content": "<p>yes but I want this to be fixed, with a test. and maybe evaluate the impact</p>",
        "id": 167199177,
        "sender_full_name": "eddyb",
        "timestamp": 1559574523
    },
    {
        "content": "<p>how many intrinsics have we exposed on stable?</p>",
        "id": 167199187,
        "sender_full_name": "eddyb",
        "timestamp": 1559574533
    },
    {
        "content": "<p>IIRC just <code>transmute</code> nowadays</p>",
        "id": 167199211,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574547
    },
    {
        "content": "<p>(we un-exposed some of them recently)</p>",
        "id": 167199217,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574552
    },
    {
        "content": "<p>oh I see</p>",
        "id": 167199228,
        "sender_full_name": "eddyb",
        "timestamp": 1559574558
    },
    {
        "content": "<p>but that's for \"core intrinsics\"</p>",
        "id": 167199231,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574559
    },
    {
        "content": "<p>doesnt SIMD have a metric shit-ton of intrinsics and expose them all?</p>",
        "id": 167199242,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574571
    },
    {
        "content": "<p>kinda</p>",
        "id": 167199256,
        "sender_full_name": "eddyb",
        "timestamp": 1559574589
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> it's important for SIMD people to be able to call their <code>const fn</code>s for these arguments</p>\n</blockquote>\n<p>that makes sense. but is there any way we could let those things be checked by \"const checking\"? Seems reasonable to accept the same things there and in <code>const</code> items, without having to write the check twice...</p>",
        "id": 167199275,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574602
    },
    {
        "content": "<p>they also abuse \"linking\" to LLVM intrinsics directly, which is a nightmare</p>",
        "id": 167199322,
        "sender_full_name": "eddyb",
        "timestamp": 1559574605
    },
    {
        "content": "<p>so it might be that SIMD intrinsics are callable from <code>const fn</code> this way</p>",
        "id": 167199360,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574630
    },
    {
        "content": "<p>I really don't know what you mean by \"twice\"</p>",
        "id": 167199374,
        "sender_full_name": "eddyb",
        "timestamp": 1559574647
    },
    {
        "content": "<p>like  <a href=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1243\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1243\">https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L1243</a> and <a href=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L495\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L495\">https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L495</a></p>",
        "id": 167199388,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574660
    },
    {
        "content": "<p>which both separately rule out non-const-fn calls</p>",
        "id": 167199418,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574676
    },
    {
        "content": "<p>I am not sure where the other things are enforced for both of these... like using unsafe operations or casting ptrs to ints</p>",
        "id": 167199456,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574713
    },
    {
        "content": "<p>ah I see</p>",
        "id": 167199512,
        "sender_full_name": "eddyb",
        "timestamp": 1559574727
    },
    {
        "content": "<p>well, for const-checking they need to emit errors</p>",
        "id": 167199528,
        "sender_full_name": "eddyb",
        "timestamp": 1559574737
    },
    {
        "content": "<p>that depend on various things</p>",
        "id": 167199541,
        "sender_full_name": "eddyb",
        "timestamp": 1559574747
    },
    {
        "content": "<p>for <code>rustc_const_arg</code> they also need to emit errors</p>",
        "id": 167199555,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574761
    },
    {
        "content": "<p>the error is very different</p>",
        "id": 167199579,
        "sender_full_name": "eddyb",
        "timestamp": 1559574776
    },
    {
        "content": "<p><code>rustc_const_arg</code> doesn't cause the argument to be checked as a constant</p>",
        "id": 167199609,
        "sender_full_name": "eddyb",
        "timestamp": 1559574794
    },
    {
        "content": "<p>is there any reason it should be? \"you wrote a thing that can't be CTFE'd in a place where we must do CTFE\".</p>",
        "id": 167199620,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574803
    },
    {
        "content": "<p>although it would be interesting to try...</p>",
        "id": 167199624,
        "sender_full_name": "eddyb",
        "timestamp": 1559574806
    },
    {
        "content": "<p>but it would require a much stranger scheme</p>",
        "id": 167199714,
        "sender_full_name": "eddyb",
        "timestamp": 1559574846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223879\">@Mahmut Bulut</span> is looking into statically checking intrinsics in const eval, let's see how bad the fallout is first I guess?</p>",
        "id": 167199716,
        "sender_full_name": "oli",
        "timestamp": 1559574847
    },
    {
        "content": "<p>right now we just compute forward</p>",
        "id": 167199727,
        "sender_full_name": "eddyb",
        "timestamp": 1559574851
    },
    {
        "content": "<p>I mean I guess a slong as \"can call <code>const fn</code>\" is the <em>only</em> difference between implicit and explicit promotion we should be good (as in, we should have fairly reasonable test coverage)</p>",
        "id": 167199752,
        "sender_full_name": "RalfJ",
        "timestamp": 1559574871
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> please ping me here or on IRC about this so I don't keep track of it</p>",
        "id": 167199761,
        "sender_full_name": "eddyb",
        "timestamp": 1559574878
    },
    {
        "content": "<p>will do</p>",
        "id": 167199774,
        "sender_full_name": "oli",
        "timestamp": 1559574889
    },
    {
        "content": "<p>to be clear, are you including the <code>return true</code> bug?</p>",
        "id": 167199809,
        "sender_full_name": "eddyb",
        "timestamp": 1559574909
    },
    {
        "content": "<p>(but seriously, I want that in isolation, because when I made that mistake <em>we had no tests</em> - and we clearly still don't)</p>",
        "id": 167199826,
        "sender_full_name": "eddyb",
        "timestamp": 1559574925
    },
    {
        "content": "<p>yes, I'll make sure they are separate PRs then</p>",
        "id": 167199854,
        "sender_full_name": "oli",
        "timestamp": 1559574950
    },
    {
        "content": "<p>okay ping me on IRC and I'll r+ ASAP</p>",
        "id": 167200152,
        "sender_full_name": "eddyb",
        "timestamp": 1559575129
    },
    {
        "content": "<p>there's also some overlap between the <code>IsNotPromotable</code> vs <code>IsNotImplicitlyPromotable</code>, and <code>mode</code>. We want to allow <code>const fn</code> calls both inside <code>const</code> items and inside <code>rustc_const_arg</code> arguments.</p>",
        "id": 167200666,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575385
    },
    {
        "content": "<p>Seems weird to have <code>IsNotImplicitlyPromotable</code> look at the mode at all TBH</p>",
        "id": 167200701,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575409
    },
    {
        "content": "<p>I did leave a few comments about some stuff like that</p>",
        "id": 167200727,
        "sender_full_name": "eddyb",
        "timestamp": 1559575431
    },
    {
        "content": "<p>although I'm not sure what you mean</p>",
        "id": 167200746,
        "sender_full_name": "eddyb",
        "timestamp": 1559575439
    },
    {
        "content": "<p>why does <code>IsNotImplicitlyPromotable</code> look at the mode? instead I'd think that in situations like <code>static X: T := &amp;foo</code>, we'd only look at <code>IsNotPromotable</code></p>",
        "id": 167201240,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575669
    },
    {
        "content": "<p>similar to how we only look at <code>IsNotPromotable</code> for <code>rustc_const_arg</code></p>",
        "id": 167201257,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575681
    },
    {
        "content": "<p>you're saying that's explicit promotion?</p>",
        "id": 167201320,
        "sender_full_name": "eddyb",
        "timestamp": 1559575696
    },
    {
        "content": "<p>yes</p>",
        "id": 167201329,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575701
    },
    {
        "content": "<p>with the same argument</p>",
        "id": 167201338,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575706
    },
    {
        "content": "<p>its happening inside a context where we have to use <code>const</code></p>",
        "id": 167201343,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575713
    },
    {
        "content": "<p>but that's not even promotion :P</p>",
        "id": 167201349,
        "sender_full_name": "eddyb",
        "timestamp": 1559575717
    },
    {
        "content": "<p>well it is currently treated as such is it not?</p>",
        "id": 167201369,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575730
    },
    {
        "content": "<p>that's just <code>&amp;'static</code> without any promotion happening</p>",
        "id": 167201382,
        "sender_full_name": "eddyb",
        "timestamp": 1559575737
    },
    {
        "content": "<p>when I did some testing it behaves the same</p>",
        "id": 167201387,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575740
    },
    {
        "content": "<p>ah sorry take a variant of this like <code>(0, &amp;foo)</code></p>",
        "id": 167201415,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575752
    },
    {
        "content": "<p>you need something like <code>f(&amp;g())</code>, I think</p>",
        "id": 167201433,
        "sender_full_name": "eddyb",
        "timestamp": 1559575760
    },
    {
        "content": "<p>for some reason those are treated differently...</p>",
        "id": 167201437,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575761
    },
    {
        "content": "<p>yeah something like that</p>",
        "id": 167201457,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575769
    },
    {
        "content": "<p>not sure why that makes any difference FWIW^^</p>",
        "id": 167201464,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575774
    },
    {
        "content": "<p><code>Some(&amp;foo)</code> was my usual way to get there IIRC</p>",
        "id": 167201486,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575784
    },
    {
        "content": "<p>tuple might still be top-level, I don't remember</p>",
        "id": 167201489,
        "sender_full_name": "eddyb",
        "timestamp": 1559575786
    },
    {
        "content": "<p>it's the rule from <code>let x = &amp;f();</code></p>",
        "id": 167201520,
        "sender_full_name": "eddyb",
        "timestamp": 1559575803
    },
    {
        "content": "<p>I cant remember because in my head it makes no sense to treat them differently than top-level <code>&amp;</code>^^</p>",
        "id": 167201584,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575812
    },
    {
        "content": "<p>yeah, <code>Some(&amp;foo())</code> needs promotion</p>",
        "id": 167201595,
        "sender_full_name": "eddyb",
        "timestamp": 1559575816
    },
    {
        "content": "<p>well, top-level allows more</p>",
        "id": 167201622,
        "sender_full_name": "eddyb",
        "timestamp": 1559575836
    },
    {
        "content": "<p>but why?</p>",
        "id": 167201630,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575842
    },
    {
        "content": "<p>like, <code>&amp;String::new()</code> works but <code>Some(&amp;String::new())</code> doesn't</p>",
        "id": 167201644,
        "sender_full_name": "eddyb",
        "timestamp": 1559575851
    },
    {
        "content": "<p>but why?^^</p>",
        "id": 167201658,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575859
    },
    {
        "content": "<p>because that's the only thing that fit the constraints we had?</p>",
        "id": 167201691,
        "sender_full_name": "eddyb",
        "timestamp": 1559575873
    },
    {
        "content": "<p>I dont know what that means</p>",
        "id": 167201716,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575883
    },
    {
        "content": "<p>it used to be more relaxed, actually, which was very bad</p>",
        "id": 167201729,
        "sender_full_name": "eddyb",
        "timestamp": 1559575888
    },
    {
        "content": "<p>but I dont know of any soundness reason to treat them differently</p>",
        "id": 167201738,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575892
    },
    {
        "content": "<p>like, anything you are allowed top-level, you should also be allowed \"further in\"</p>",
        "id": 167201768,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575910
    },
    {
        "content": "<p>if we rely on promotion for the top-level, some things are impossible</p>",
        "id": 167201772,
        "sender_full_name": "eddyb",
        "timestamp": 1559575912
    },
    {
        "content": "<p>unless we start allowing to promote them</p>",
        "id": 167201782,
        "sender_full_name": "eddyb",
        "timestamp": 1559575920
    },
    {
        "content": "<p>well is there anything we want to allow top-level but not allow in <em>explicit</em> promotion?</p>",
        "id": 167201858,
        "sender_full_name": "RalfJ",
        "timestamp": 1559575943
    },
    {
        "content": "<p>and we don't want to promote <code>Some(&amp;ThisNeedsDrop)</code> <em>anywhere</em></p>",
        "id": 167201870,
        "sender_full_name": "eddyb",
        "timestamp": 1559575952
    },
    {
        "content": "<p>since we want drops to have consistent semantics</p>",
        "id": 167201894,
        "sender_full_name": "eddyb",
        "timestamp": 1559575972
    },
    {
        "content": "<p>I mean I'd also be fine not considering that to be part of promotion at all, neither top-level nor nested. it's mostly the inconsistency that bothers me.</p>",
        "id": 167201960,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576006
    },
    {
        "content": "<p>but we used to allow <code>Some(&amp;anything)</code></p>",
        "id": 167201980,
        "sender_full_name": "eddyb",
        "timestamp": 1559576023
    },
    {
        "content": "<p>where?</p>",
        "id": 167201994,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576033
    },
    {
        "content": "<p>in constants</p>",
        "id": 167202115,
        "sender_full_name": "eddyb",
        "timestamp": 1559576081
    },
    {
        "content": "<p>well there need to be some checks, but the same checks as for top-level</p>",
        "id": 167202395,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576249
    },
    {
        "content": "<p>@oli I dont understand the comment at  <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1212\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1212\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L1212</a><br>\n<code>// never promote transmute calls</code> but this doesn't even do anything for runtime-functions (i.e., where promotion would matter)</p>",
        "id": 167202429,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576277
    },
    {
        "content": "<p>that comment belongs to <a href=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L488\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L488\">https://github.com/rust-lang/rust/blob/7096ff0ce16b0544b717986ec335798b3151dd8e/src/librustc_mir/transform/qualify_consts.rs#L488</a></p>",
        "id": 167202739,
        "sender_full_name": "oli",
        "timestamp": 1559576412
    },
    {
        "content": "<p>yeah but that's not what that code does^^ okay</p>",
        "id": 167202944,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> for another insteance of a duplicate check, see the two occurrences of <code>is_union</code> in that file</p>",
        "id": 167202970,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576539
    },
    {
        "content": "<p>we basically have most checks twice and it's very hard to tell if they are properly in sync</p>",
        "id": 167202987,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576549
    },
    {
        "content": "<p>also why is it correct to do the \"dont promote things that would execute drop during their evaluation\" check only on temporaries?</p>",
        "id": 167203655,
        "sender_full_name": "RalfJ",
        "timestamp": 1559576982
    },
    {
        "content": "<p>because we don't promote non-temporaries</p>",
        "id": 167204552,
        "sender_full_name": "eddyb",
        "timestamp": 1559577567
    },
    {
        "content": "<p>ah</p>",
        "id": 167204857,
        "sender_full_name": "RalfJ",
        "timestamp": 1559577769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> before my change the whitelist, this doesn't do anything <a href=\"https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src/librustc_mir/transform/qualify_consts.rs#L875\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src/librustc_mir/transform/qualify_consts.rs#L875\">https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src/librustc_mir/transform/qualify_consts.rs#L875</a></p>",
        "id": 167204906,
        "sender_full_name": "eddyb",
        "timestamp": 1559577826
    },
    {
        "content": "<p>oh god there was an ICE I removed <a href=\"https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src/librustc_mir/transform/qualify_consts.rs#L1038-L1041\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src/librustc_mir/transform/qualify_consts.rs#L1038-L1041\">https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src/librustc_mir/transform/qualify_consts.rs#L1038-L1041</a></p>",
        "id": 167204916,
        "sender_full_name": "eddyb",
        "timestamp": 1559577840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> it does something, it keeps <code>is_const_fn</code> at <code>false</code></p>",
        "id": 167204975,
        "sender_full_name": "oli",
        "timestamp": 1559577858
    },
    {
        "content": "<p>load-bearing <code>delay_span_bug</code>s Q_Q</p>",
        "id": 167204978,
        "sender_full_name": "eddyb",
        "timestamp": 1559577861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> but there are no errors attached to <code>is_const_fn</code>!</p>",
        "id": 167205352,
        "sender_full_name": "eddyb",
        "timestamp": 1559578182
    },
    {
        "content": "<p>I tried to cast some of the things you told me into comments <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> , please have a look at <a href=\"https://github.com/rust-lang/rust/pull/61492\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/61492\">https://github.com/rust-lang/rust/pull/61492</a> and check that they reflect what you wanted to say</p>",
        "id": 167205379,
        "sender_full_name": "RalfJ",
        "timestamp": 1559578201
    },
    {
        "content": "<p>yea <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span> I just saw it.</p>",
        "id": 167205435,
        "sender_full_name": "oli",
        "timestamp": 1559578206
    },
    {
        "content": "<p>so basically people added intrinsics to the whitelist to disable the ICE</p>",
        "id": 167205450,
        "sender_full_name": "eddyb",
        "timestamp": 1559578217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I still think \"const context\" is ambiguous :/</p>",
        "id": 167205510,
        "sender_full_name": "eddyb",
        "timestamp": 1559578280
    },
    {
        "content": "<p>I'm sure my original implementation didn't have an ICE...</p>",
        "id": 167205519,
        "sender_full_name": "oli",
        "timestamp": 1559578284
    },
    {
        "content": "<p>not sure what I broke from then on</p>",
        "id": 167205530,
        "sender_full_name": "oli",
        "timestamp": 1559578295
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> I still think \"const context\" is ambiguous :/</p>\n</blockquote>\n<p>hm. it is terminology I have been using for a bit, including in some blog posts. and so far nobody complained^^</p>",
        "id": 167205690,
        "sender_full_name": "RalfJ",
        "timestamp": 1559578415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> wait, there is one way to fix this: rename <code>Mode::Const</code> to <code>Mode::OtherConst</code></p>",
        "id": 167205694,
        "sender_full_name": "eddyb",
        "timestamp": 1559578417
    },
    {
        "content": "<p>sure I can do that. I guess when I rename things I can also rename <code>Fn</code> to <code>NonConstFn</code> or so?</p>",
        "id": 167205779,
        "sender_full_name": "RalfJ",
        "timestamp": 1559578447
    },
    {
        "content": "<p>it's very much contextually ambiguous :P</p>",
        "id": 167205785,
        "sender_full_name": "eddyb",
        "timestamp": 1559578451
    },
    {
        "content": "<p>hmm sure</p>",
        "id": 167205795,
        "sender_full_name": "eddyb",
        "timestamp": 1559578459
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> wait, there is one way to fix this: rename <code>Mode::Const</code> to <code>Mode::OtherConst</code></p>\n</blockquote>\n<p>what about <code>Mode::ConstItem</code>?</p>",
        "id": 167205991,
        "sender_full_name": "RalfJ",
        "timestamp": 1559578618
    },
    {
        "content": "<p>no, because it's a catch-all for anon consts too</p>",
        "id": 167206012,
        "sender_full_name": "eddyb",
        "timestamp": 1559578636
    },
    {
        "content": "<p>like <code>[T; 0]</code>, <code>Array&lt;T, 1&gt;</code> etc.</p>",
        "id": 167206020,
        "sender_full_name": "eddyb",
        "timestamp": 1559578652
    },
    {
        "content": "<p><code>const_mode: Option&lt;ConstMode&gt;</code>, where <code>Fn</code> is <code>None</code> instead of a variant on <code>Mode</code>?</p>",
        "id": 167206095,
        "sender_full_name": "oli",
        "timestamp": 1559578683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ftr, the duplication would slowly go away as we allow more things in the const context</p>",
        "id": 167206165,
        "sender_full_name": "eddyb",
        "timestamp": 1559578733
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> ftr, the duplication would slowly go away as we allow more things in the const context</p>\n</blockquote>\n<p>that's a good point</p>",
        "id": 167206492,
        "sender_full_name": "RalfJ",
        "timestamp": 1559578968
    },
    {
        "content": "<p>in the \"endgame\", what is left to check for general const context? calling only <code>const fn</code>, which you guys are currently struggling to fix for intrinsics ;) , and maybe some <code>unconst</code> stuff? But there'll still be <code>Drop</code> terminator checks, too, and something about interior mutability. (and hopefully <code>Sync</code>...)</p>",
        "id": 167206563,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579026
    },
    {
        "content": "<p>I mean having const checks is not a problem</p>",
        "id": 167206741,
        "sender_full_name": "eddyb",
        "timestamp": 1559579129
    },
    {
        "content": "<p>the annoying thing is that some logic must be replicated for qualifying promotion</p>",
        "id": 167206762,
        "sender_full_name": "eddyb",
        "timestamp": 1559579148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> it's taking me a while to see what you mean but some of the more fine-grained duplication... is part of the cleanup</p>",
        "id": 167206831,
        "sender_full_name": "eddyb",
        "timestamp": 1559579172
    },
    {
        "content": "<p>before it was unduplicated because the qualification was done by mutating <em>while</em> checking!</p>",
        "id": 167206850,
        "sender_full_name": "eddyb",
        "timestamp": 1559579189
    },
    {
        "content": "<p>whereas we want to move to just using the dataflow framework</p>",
        "id": 167206881,
        "sender_full_name": "eddyb",
        "timestamp": 1559579215
    },
    {
        "content": "<blockquote>\n<p>the annoying thing is that some logic must be replicated for qualifying promotion</p>\n</blockquote>\n<p>yes</p>",
        "id": 167206927,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579251
    },
    {
        "content": "<p>the cleanup did remove some other duplication though I feel -- or at least made the overall structure much clearer -- that that was still definitely a good step IMO</p>",
        "id": 167206953,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> anyway, I don't think I managed to get across why top-level borrows are \"leaked\" to <code>'static</code> instead of promoted</p>",
        "id": 167207001,
        "sender_full_name": "eddyb",
        "timestamp": 1559579283
    },
    {
        "content": "<p>diagnostics aside, can we phrase \"const checking\" as \"making sure an <code>IsNotConst</code> qualif is not set anywhere\"? and then make <code>IsNotPromotable</code> basically a minor extension of that qualif if at all needed?</p>",
        "id": 167207066,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579322
    },
    {
        "content": "<p>but that doesn't mean anything :/</p>",
        "id": 167207098,
        "sender_full_name": "eddyb",
        "timestamp": 1559579341
    },
    {
        "content": "<p>qualifications are of \"value\"s. whatever you want to call them</p>",
        "id": 167207132,
        "sender_full_name": "eddyb",
        "timestamp": 1559579360
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> anyway, I don't think I managed to get across why top-level borrows are \"leaked\" to <code>'static</code> instead of promoted</p>\n</blockquote>\n<p>well I understand the checks are weaker. and it makes sense that they would be weaker than promotion un runtime <code>fn</code>. I dont know where that is implemented though.</p>",
        "id": 167207146,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579368
    },
    {
        "content": "<p>there are side-effects that don't produce a value</p>",
        "id": 167207171,
        "sender_full_name": "eddyb",
        "timestamp": 1559579387
    },
    {
        "content": "<p>like a <code>-&gt; !</code> <code>const fn</code></p>",
        "id": 167207184,
        "sender_full_name": "eddyb",
        "timestamp": 1559579395
    },
    {
        "content": "<p>or, idk, maybe <code>InlineAsm</code>?</p>",
        "id": 167207281,
        "sender_full_name": "eddyb",
        "timestamp": 1559579417
    },
    {
        "content": "<p>or <code>Drop</code>, I guess</p>",
        "id": 167207297,
        "sender_full_name": "eddyb",
        "timestamp": 1559579425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> no, I mean, why <code>&amp;f()</code> allows more than <code>Some(&amp;f())</code> - both in constants</p>",
        "id": 167207362,
        "sender_full_name": "eddyb",
        "timestamp": 1559579458
    },
    {
        "content": "<p>anyway, you can disable that behavior by getting rid of this (and using the <code>visit_expr</code> from the \"then\" side of the <code>if</code> in all cases <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L1280-L1301\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L1280-L1301\">https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L1280-L1301</a></p>",
        "id": 167207474,
        "sender_full_name": "eddyb",
        "timestamp": 1559579523
    },
    {
        "content": "<p>and then do a crater run to see what breaks</p>",
        "id": 167207498,
        "sender_full_name": "eddyb",
        "timestamp": 1559579531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> aside from back-compat, I <em>really</em> want <code>&amp;String::from(\"foo\")</code> to work one day</p>",
        "id": 167207525,
        "sender_full_name": "eddyb",
        "timestamp": 1559579551
    },
    {
        "content": "<p>and if you're not at the top-level there is no way that would ever be <code>&amp;'static</code> (unless we add a way to say that <code>String</code>'s <code>Drop</code> is \"promotable away\")</p>",
        "id": 167207583,
        "sender_full_name": "eddyb",
        "timestamp": 1559579598
    },
    {
        "content": "<p>but at the top-level we can use the <code>let</code> rules and say that the \"enclosing scope\" is <code>'static</code></p>",
        "id": 167207634,
        "sender_full_name": "eddyb",
        "timestamp": 1559579636
    },
    {
        "content": "<p>it's both backwards and forwards compatible</p>",
        "id": 167207705,
        "sender_full_name": "eddyb",
        "timestamp": 1559579654
    },
    {
        "content": "<p>that's why we did it that way</p>",
        "id": 167207715,
        "sender_full_name": "eddyb",
        "timestamp": 1559579662
    },
    {
        "content": "<p>why would <code>Some(&amp;String::from(\"foo\"))</code> not work?</p>",
        "id": 167208006,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579831
    },
    {
        "content": "<p>because that already means something</p>",
        "id": 167208019,
        "sender_full_name": "eddyb",
        "timestamp": 1559579845
    },
    {
        "content": "<p>the way we intern consts, anything that lives when the const is done computing can be interned</p>",
        "id": 167208024,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579847
    },
    {
        "content": "<p>like, <code>f(&amp;String::from(\"foo\"))</code> means \"call <code>f</code> then drop the <code>String</code>\"</p>",
        "id": 167208134,
        "sender_full_name": "eddyb",
        "timestamp": 1559579904
    },
    {
        "content": "<p>hm</p>",
        "id": 167208164,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579931
    },
    {
        "content": "<p>really, look at how <code>let x = &amp;f();</code> rules work</p>",
        "id": 167208185,
        "sender_full_name": "eddyb",
        "timestamp": 1559579945
    },
    {
        "content": "<p>there are literally over 6 years of history here</p>",
        "id": 167208197,
        "sender_full_name": "eddyb",
        "timestamp": 1559579954
    },
    {
        "content": "<p>okay when I ran into this I didnt think about <code>Drop</code>, I was more surprised that <code>Some(&amp;Cell::new(0))</code> does not work. there's no good reason at all for that IMO...</p>",
        "id": 167208204,
        "sender_full_name": "RalfJ",
        "timestamp": 1559579958
    },
    {
        "content": "<p>you mean <code>&amp;AtomicUsize</code>, right?</p>",
        "id": 167208224,
        "sender_full_name": "eddyb",
        "timestamp": 1559579980
    },
    {
        "content": "<p>cause that's not <code>Sync</code></p>",
        "id": 167208229,
        "sender_full_name": "eddyb",
        "timestamp": 1559579985
    },
    {
        "content": "<p>yeah (thought we dont always properly check <code>Sync</code> during promotion but that's another thing)</p>",
        "id": 167208281,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580003
    },
    {
        "content": "<p>but you agree <code>f(&amp;AtomicUsize::new(0))</code> shouldn't promote, yeah?</p>",
        "id": 167208377,
        "sender_full_name": "eddyb",
        "timestamp": 1559580091
    },
    {
        "content": "<p>(if it promotes, executing that code more than once may see a non-<code>0</code> there)</p>",
        "id": 167208478,
        "sender_full_name": "eddyb",
        "timestamp": 1559580137
    },
    {
        "content": "<p><code>Some</code> is a special-case of an ADT constructor that looks like a function call</p>",
        "id": 167208496,
        "sender_full_name": "eddyb",
        "timestamp": 1559580155
    },
    {
        "content": "<p>we can change things about it if we wanted to. it's a red herring</p>",
        "id": 167208514,
        "sender_full_name": "eddyb",
        "timestamp": 1559580177
    },
    {
        "content": "<p>actual functions are far more important</p>",
        "id": 167208523,
        "sender_full_name": "eddyb",
        "timestamp": 1559580184
    },
    {
        "content": "<blockquote>\n<p>but you agree <code>f(&amp;AtomicUsize::new(0))</code> shouldn't promote, yeah?</p>\n</blockquote>\n<p>I dont know what \"promotion\" means any more. ;) but I think <code>static FOO = f(&amp;AtomicUsize::new(0))</code> should work (and same for <code>const</code>)</p>",
        "id": 167208556,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580222
    },
    {
        "content": "<p>well maybe not for <code>const</code> if the reference ends up in the result</p>",
        "id": 167208615,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580248
    },
    {
        "content": "<p>interior mutability and const, yada yada (we'll hopefully soon have interning check for that)</p>",
        "id": 167208632,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580268
    },
    {
        "content": "<p>but for <code>static</code></p>",
        "id": 167208636,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580273
    },
    {
        "content": "<p>it's too tenuous IMO</p>",
        "id": 167208658,
        "sender_full_name": "eddyb",
        "timestamp": 1559580289
    },
    {
        "content": "<p>you'd agree <code>x = f(&amp;AtomicUsize::new(0))</code> in a loop <em>even in a <code>static</code></em> should never be promoted, right?</p>",
        "id": 167208701,
        "sender_full_name": "eddyb",
        "timestamp": 1559580312
    },
    {
        "content": "<p>...?</p>",
        "id": 167208730,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580335
    },
    {
        "content": "<p>again I dont know what promotion means here</p>",
        "id": 167208736,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580342
    },
    {
        "content": "<p>but I see no reason not to just execute that code using normal CTFE rules and then intern the result</p>",
        "id": 167208747,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580353
    },
    {
        "content": "<p>of coruse it shouldnt \"factor out\" the <code>AtomicUsize::new</code></p>",
        "id": 167208810,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580370
    },
    {
        "content": "<p>promotion means there is only one <code>AtomicUsize</code> and it gets reused instead of each iteration having its own</p>",
        "id": 167208811,
        "sender_full_name": "eddyb",
        "timestamp": 1559580371
    },
    {
        "content": "<p>so I guess it'd be more like what you call \"leaking\"</p>",
        "id": 167208821,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580380
    },
    {
        "content": "<p>you can't \"leak\" in a loop</p>",
        "id": 167208831,
        "sender_full_name": "eddyb",
        "timestamp": 1559580395
    },
    {
        "content": "<p>you only have one local</p>",
        "id": 167208844,
        "sender_full_name": "eddyb",
        "timestamp": 1559580410
    },
    {
        "content": "<p>so?</p>",
        "id": 167208884,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580437
    },
    {
        "content": "<p>there is something special about \"this only happens once\" that can make this work, but it's very much a special-case</p>",
        "id": 167208893,
        "sender_full_name": "eddyb",
        "timestamp": 1559580443
    },
    {
        "content": "<p>hm. seems like my mental model for <code>&amp;</code> in <code>static</code> is just off</p>",
        "id": 167209002,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580510
    },
    {
        "content": "<p>if you think of <code>const</code> and <code>static</code> RHSes as <code>const fn</code> functions that are used to initialize them, that would help a lot</p>",
        "id": 167209048,
        "sender_full_name": "eddyb",
        "timestamp": 1559580549
    },
    {
        "content": "<p>my idea was to just compile to MIR and evaluate that, and because we dont drop the top \"stack frame\" (corresponding to the body of the item) we can just leak everything in that frame that we still need</p>",
        "id": 167209056,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580562
    },
    {
        "content": "<p>your mental model might be that of the pre-miri evaluator which did something very silly for <code>&amp;foo</code></p>",
        "id": 167209071,
        "sender_full_name": "eddyb",
        "timestamp": 1559580573
    },
    {
        "content": "<blockquote>\n<p>if you think of <code>const</code> and <code>static</code> RHSes as <code>const fn</code> functions that are used to initialize them, that would help a lot</p>\n</blockquote>\n<p>well but that does not explain why <code>&amp;foo()</code> works</p>",
        "id": 167209103,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> so, what happens to per-loop iteration <code>StorageLive...StorageDead</code>?</p>",
        "id": 167209105,
        "sender_full_name": "eddyb",
        "timestamp": 1559580600
    },
    {
        "content": "<p>yes, <code>&amp;foo()</code> is very much a special case</p>",
        "id": 167209158,
        "sender_full_name": "eddyb",
        "timestamp": 1559580609
    },
    {
        "content": "<p>well sure if there's a <code>StorageDead</code> that cannot be used in the final value</p>",
        "id": 167209190,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580643
    },
    {
        "content": "<p>everything except the top-level special-case has <code>Drop</code>s and <code>StorageDead</code>s!</p>",
        "id": 167209203,
        "sender_full_name": "eddyb",
        "timestamp": 1559580661
    },
    {
        "content": "<blockquote>\n<p>yes, <code>&amp;foo()</code> is very much a special case</p>\n</blockquote>\n<p>in particular it's a special case not just for the analysis but for MIR generation as well, right?</p>",
        "id": 167209229,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580685
    },
    {
        "content": "<p>it's like a regulat function</p>",
        "id": 167209237,
        "sender_full_name": "eddyb",
        "timestamp": 1559580690
    },
    {
        "content": "<p><code>&amp;foo()</code> is a special-case <em>only</em> for MIR generation</p>",
        "id": 167209249,
        "sender_full_name": "eddyb",
        "timestamp": 1559580702
    },
    {
        "content": "<p>all of the behavior falls out of that</p>",
        "id": 167209259,
        "sender_full_name": "eddyb",
        "timestamp": 1559580712
    },
    {
        "content": "<blockquote>\n<p><code>&amp;foo()</code> is a special-case <em>only</em> for MIR generation</p>\n</blockquote>\n<p>well you linked me to some part where it's a special case of the analysis?</p>",
        "id": 167209265,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580719
    },
    {
        "content": "<p>what analysis? <code>middle::region</code>?</p>",
        "id": 167209325,
        "sender_full_name": "eddyb",
        "timestamp": 1559580734
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L1280-L1301\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L1280-L1301\">https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L1280-L1301</a><br>\noh wait that's not in const_qualif</p>",
        "id": 167209333,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580743
    },
    {
        "content": "<p>lol</p>",
        "id": 167209339,
        "sender_full_name": "eddyb",
        "timestamp": 1559580749
    },
    {
        "content": "<p>I assumed it had to be^^</p>",
        "id": 167209347,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580753
    },
    {
        "content": "<p>no, because it's <em>not promotion</em></p>",
        "id": 167209366,
        "sender_full_name": "eddyb",
        "timestamp": 1559580768
    },
    {
        "content": "<blockquote>\n<p>all of the behavior falls out of that</p>\n</blockquote>\n<p>okay that helps a lot!</p>",
        "id": 167209373,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580776
    },
    {
        "content": "<p>you can just not run the promotion pass and top-level in const/static would still have the behavior of top-level in <code>let</code></p>",
        "id": 167209395,
        "sender_full_name": "eddyb",
        "timestamp": 1559580796
    },
    {
        "content": "<blockquote>\n<p>you can just not run the promotion pass and top-level in const/static would still have the behavior of top-level in <code>let</code></p>\n</blockquote>\n<p>that's not what I meant though, I meant <code>&amp;</code> in statics could generally be \"not promotion\". but at least I understand now where the distinction is coming from.</p>",
        "id": 167209469,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580851
    },
    {
        "content": "<p>you could do that but then you can't have normal drops</p>",
        "id": 167209480,
        "sender_full_name": "eddyb",
        "timestamp": 1559580878
    },
    {
        "content": "<p>and I'd rather \"doesn't get dropped\" be the exception not the rule</p>",
        "id": 167209489,
        "sender_full_name": "eddyb",
        "timestamp": 1559580895
    },
    {
        "content": "<p>like, I want <code>{ let mut v = vec![]; ... v.iter().sum() }</code> to very much behave like runtime code</p>",
        "id": 167209525,
        "sender_full_name": "eddyb",
        "timestamp": 1559580930
    },
    {
        "content": "<p>and drop the <code>Vec</code></p>",
        "id": 167209541,
        "sender_full_name": "eddyb",
        "timestamp": 1559580947
    },
    {
        "content": "<p>you can't have that and \"all <code>&amp;</code> are <code>&amp;'static</code>\"</p>",
        "id": 167209595,
        "sender_full_name": "eddyb",
        "timestamp": 1559580967
    },
    {
        "content": "<p>not to mention conflicting borrows</p>",
        "id": 167209602,
        "sender_full_name": "eddyb",
        "timestamp": 1559580977
    },
    {
        "content": "<p>well we clean up the CTFE context</p>",
        "id": 167209608,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580982
    },
    {
        "content": "<p>so drop-or-no-drop is not observable</p>",
        "id": 167209612,
        "sender_full_name": "RalfJ",
        "timestamp": 1559580991
    },
    {
        "content": "<p>that doesn't matter, it still needs to be <em>checked</em></p>",
        "id": 167209615,
        "sender_full_name": "eddyb",
        "timestamp": 1559580997
    },
    {
        "content": "<p>we used to <em>not have a const checking pass</em></p>",
        "id": 167209645,
        "sender_full_name": "eddyb",
        "timestamp": 1559581021
    },
    {
        "content": "<p>and just eval'd it which did whatever</p>",
        "id": 167209663,
        "sender_full_name": "eddyb",
        "timestamp": 1559581030
    },
    {
        "content": "<p>and we used to just not run the borrowck on const expressions</p>",
        "id": 167209680,
        "sender_full_name": "eddyb",
        "timestamp": 1559581044
    },
    {
        "content": "<p>and that was bad?</p>",
        "id": 167209722,
        "sender_full_name": "RalfJ",
        "timestamp": 1559581080
    },
    {
        "content": "<p>I actually hope to equip CTFE/Miri with enough checks that that should still reject anything we have to reject</p>",
        "id": 167209778,
        "sender_full_name": "RalfJ",
        "timestamp": 1559581100
    },
    {
        "content": "<p>yes, for the same reason we have a borrow-checker!</p>",
        "id": 167209795,
        "sender_full_name": "eddyb",
        "timestamp": 1559581131
    },
    {
        "content": "<p>and that's universal quantification</p>",
        "id": 167209817,
        "sender_full_name": "eddyb",
        "timestamp": 1559581152
    },
    {
        "content": "<p>on generics, on ambient state, and on dataflow paths</p>",
        "id": 167209828,
        "sender_full_name": "eddyb",
        "timestamp": 1559581169
    },
    {
        "content": "<p>sure the checks would get delayed to instantiation time</p>",
        "id": 167209849,
        "sender_full_name": "RalfJ",
        "timestamp": 1559581187
    },
    {
        "content": "<p>which is probably not great</p>",
        "id": 167209857,
        "sender_full_name": "RalfJ",
        "timestamp": 1559581192
    },
    {
        "content": "<p>it's not just not great, it's counter to almost everything Rust stands for!</p>",
        "id": 167210763,
        "sender_full_name": "eddyb",
        "timestamp": 1559581857
    },
    {
        "content": "<p>uh... hyperbole etc?^^</p>",
        "id": 167211061,
        "sender_full_name": "RalfJ",
        "timestamp": 1559582093
    },
    {
        "content": "<p>no, I mean, Rust is all about detecting statically detectable things ahead of time</p>",
        "id": 167211104,
        "sender_full_name": "eddyb",
        "timestamp": 1559582135
    },
    {
        "content": "<p>generics and traits in Rust are designed with polymorphic checks (mainly borrowck) in mind</p>",
        "id": 167211176,
        "sender_full_name": "eddyb",
        "timestamp": 1559582179
    },
    {
        "content": "<p>and also, being able to reason about runtime functions without knowing <em>anything</em> about their bodies</p>",
        "id": 167211200,
        "sender_full_name": "eddyb",
        "timestamp": 1559582210
    },
    {
        "content": "<p>well the failure mode is less catastrophic when \"uncheked\" code gets executed in CTFE vs. \"for real\" (aka, no UB). but I do agree that it makes sense to have these analyses! I just usually understand analysis by first understanding the dynamic property they want to prove, and then relating things to that. but that's not how const-qualif is explained, documented or designed (from what I can see).</p>",
        "id": 167213469,
        "sender_full_name": "RalfJ",
        "timestamp": 1559583902
    },
    {
        "content": "<p>IOW I am just lamenting not having made enough progress on <a href=\"https://github.com/rust-rfcs/const-eval/issues/17\" target=\"_blank\" title=\"https://github.com/rust-rfcs/const-eval/issues/17\">https://github.com/rust-rfcs/const-eval/issues/17</a> ^^</p>",
        "id": 167213992,
        "sender_full_name": "RalfJ",
        "timestamp": 1559584212
    },
    {
        "content": "<p>Based on the ensuing discussion, I think the answer to my first question:</p>\n<blockquote>\n<p>What are the odds that a \"dedicated beginner\" (me) could implement dataflow-based const qualification?</p>\n</blockquote>\n<p>Is \"no\" for most definitions of \"beginner\" and \"dedicated\". I may be able to help with other things like writing tests and collecting knowledge about promotion into one place.</p>\n<p>I would like to explain my mental model after watching oli-obk's compiler lecture on miri and reading some of the relevant bits of rustc over the weekend. Obviously I've probably overlooked some things.</p>\n<p>There's two kinds of validation we want to run on <code>const</code> blocks (I know the definition of \"valid\" changes subtly depending on the exact context): a pre-monomorphization static check and a dynamic check that occurs as miri is running. The goal is to catch errors as early as possible in the analysis while providing good diagnostics. Some operations (e.g. calls to non-const functions or casting pointers to integers) can be forbidden statically with a flow-insensitive analysis (iterating over the basic blocks). However, some requirements of <code>const</code> blocks (e.g. whether a value with interior mutability appears in the return place) require a path-sensitive analysis.</p>\n<p>Currently, control-flow is forbidden in CTFE, so there is only one possible execution path (unwind edges are ignored). We can enumerate this path simply by iterating over the basic blocks, meaning our naive analysis is actually path-sensitive for this simple class of CFGs. However, there are still some cases (associated consts) where errors can only be caught post-monomorphization.</p>\n<p>We want to extend CTFE to arbitrarily complex CFGs but still catch as many errors statically as possible. We can do a conservative flow-sensitive analysis (dataflow) to find all places where a value definitely, maybe, or definitely does not meet a condition (e.g. <code>HasMutInterior</code>) (the tri-state comes from the combination two separate dataflow passes as in <code>MaybeUninitializedPlaces</code> and <code>MaybeInitializedPlaces</code>). I don't know whether you've decided to only allow things that can be statically proven to be const-safe, or if you want to run miri when something is only maybe const-safe. The first would disallow  stuff like <code>const x: Option&lt;&amp;Cell&lt;u32&gt;&gt; = if true { None } else { Some(&amp;Cell::new(0)) }</code>, but the second would allow it (I'm still not 100% on the promotion rules, maybe this example is wrong).</p>",
        "id": 167227111,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559593046
    },
    {
        "content": "<p>definitely only allow if static checks succeeded</p>",
        "id": 167227507,
        "sender_full_name": "eddyb",
        "timestamp": 1559593303
    },
    {
        "content": "<blockquote>\n<p>like, I want <code>{ let mut v = vec![]; ... v.iter().sum() }</code> to very much behave like runtime code</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> A somewhat unrelated question, could we short-circuit qualification with a simple type-based analysis for this example assuming the vec holds a primitive type?</p>",
        "id": 167227866,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559593527
    },
    {
        "content": "<p>If we know type of the result of CTFE cannot possibly have interior mutability or a drop impl, we don't need to do any of the path-sensitive analysis right?</p>",
        "id": 167228108,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559593676
    },
    {
        "content": "<blockquote>\n<p>collecting knowledge about promotion into one place.</p>\n</blockquote>\n<p>yes that would be great! that place would be <a href=\"https://github.com/rust-rfcs/const-eval/\" target=\"_blank\" title=\"https://github.com/rust-rfcs/const-eval/\">https://github.com/rust-rfcs/const-eval/</a></p>",
        "id": 167229863,
        "sender_full_name": "RalfJ",
        "timestamp": 1559594628
    },
    {
        "content": "<p>I plan to incorporate some of what I learned today, but I am not sure when I will have time :/</p>",
        "id": 167229939,
        "sender_full_name": "RalfJ",
        "timestamp": 1559594648
    },
    {
        "content": "<blockquote>\n<p>However, there are still some cases (associated consts) where errors can only be caught post-monomorphization.</p>\n</blockquote>\n<p>we use the types in those cases and remain conservative</p>",
        "id": 167230061,
        "sender_full_name": "RalfJ",
        "timestamp": 1559594741
    },
    {
        "content": "<p>so, the checks in miri should actually never fire as of right now. (once we allow transmutes and fn ptrs in const code this will change though.)</p>",
        "id": 167230135,
        "sender_full_name": "RalfJ",
        "timestamp": 1559594777
    },
    {
        "content": "<p>I tried using <code> _ =&gt; {} </code> and also <code>return false</code>. It is not visiting that point in qualify_const for a test case I am testing on. It is compiling anyway. I don't know where is the whitelist checks for intrinsics occurs.</p>",
        "id": 167308770,
        "sender_full_name": "vertexclique",
        "timestamp": 1559663915
    },
    {
        "content": "<p>For both cases I used this test</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#![feature(core_intrinsics)]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">std</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>",
        "id": 167309078,
        "sender_full_name": "vertexclique",
        "timestamp": 1559664067
    },
    {
        "content": "<p>I didn't understand where <code>const</code> context but not <code>const fn</code> checks are…</p>",
        "id": 167309289,
        "sender_full_name": "vertexclique",
        "timestamp": 1559664198
    },
    {
        "content": "<p>I think this is just dead code that you removed. Not dead in the sense that it wasn't ever hit, but that its value is irrelevant, because the actual checks are elsewhere</p>",
        "id": 167311054,
        "sender_full_name": "oli",
        "timestamp": 1559665305
    },
    {
        "content": "<p>My understanding is same.</p>",
        "id": 167311234,
        "sender_full_name": "vertexclique",
        "timestamp": 1559665427
    },
    {
        "content": "<p>oh, I have an idea, gimme a sec</p>",
        "id": 167311334,
        "sender_full_name": "oli",
        "timestamp": 1559665488
    },
    {
        "content": "<p>hm, no, didn't pan out</p>",
        "id": 167311632,
        "sender_full_name": "oli",
        "timestamp": 1559665689
    },
    {
        "content": "<blockquote>\n<p>For both cases I used this test</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#![feature(core_intrinsics)]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">std</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>\n\n\n</blockquote>\n<p>that's not promotion -- top-level <code>&amp;</code> is special</p>",
        "id": 167319207,
        "sender_full_name": "RalfJ",
        "timestamp": 1559670690
    },
    {
        "content": "<p>if you want to test promotion, do it with something like <code>let x: &amp;'static _ = &amp;intrinsics::...</code></p>",
        "id": 167319233,
        "sender_full_name": "RalfJ",
        "timestamp": 1559670710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> I really don't understand your question - how can the <code>Vec</code> element type matter? <code>Vec</code> has a <code>Drop</code> impl regardless of the element type</p>",
        "id": 167377310,
        "sender_full_name": "eddyb",
        "timestamp": 1559732525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I still disagree with this FWIW but I don't have the energy today to give you a good explanation <a href=\"https://github.com/rust-lang/rust/pull/61492/files#r289985850\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/61492/files#r289985850\">https://github.com/rust-lang/rust/pull/61492/files#r289985850</a></p>",
        "id": 167380578,
        "sender_full_name": "eddyb",
        "timestamp": 1559735782
    },
    {
        "content": "<p>if you <em>really</em> want we could do the on-side-effect checking, and disqualify a local from promotion that way</p>",
        "id": 167380634,
        "sender_full_name": "eddyb",
        "timestamp": 1559735835
    },
    {
        "content": "<p>at which point it could be its own self-encapsulated check</p>",
        "id": 167380716,
        "sender_full_name": "eddyb",
        "timestamp": 1559735907
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> I still disagree with this FWIW but I don't have the energy today to give you a good explanation <a href=\"https://github.com/rust-lang/rust/pull/61492/files#r289985850\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/61492/files#r289985850\">https://github.com/rust-lang/rust/pull/61492/files#r289985850</a></p>\n</blockquote>\n<p>what's your argument beside the historical coincidence about the order in which they were added to the code base?</p>",
        "id": 167380723,
        "sender_full_name": "RalfJ",
        "timestamp": 1559735916
    },
    {
        "content": "<p>but you'd still need to do <em>the other checks</em></p>",
        "id": 167380725,
        "sender_full_name": "eddyb",
        "timestamp": 1559735918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I think it's a coincidence that they both care about drops</p>",
        "id": 167380770,
        "sender_full_name": "eddyb",
        "timestamp": 1559735971
    },
    {
        "content": "<p>the const-checking one would need to eventually start allowing <code>const impl Drop</code></p>",
        "id": 167380796,
        "sender_full_name": "eddyb",
        "timestamp": 1559736000
    },
    {
        "content": "<p>while promotion in fn's can never do that, since the respective drop is at runtime</p>",
        "id": 167380884,
        "sender_full_name": "eddyb",
        "timestamp": 1559736028
    },
    {
        "content": "<p>so they'd eventually use two flags instead of one <code>NeedsDrop</code></p>",
        "id": 167380904,
        "sender_full_name": "eddyb",
        "timestamp": 1559736053
    },
    {
        "content": "<p>like, <code>NeedsNonConstDrop</code> and <code>NeedsDrop</code></p>",
        "id": 167380937,
        "sender_full_name": "eddyb",
        "timestamp": 1559736089
    },
    {
        "content": "<p>one is about not executing implicit non-<code>const fn</code> <code>Drop::drop</code> calls, the other is about preserving observable behavior</p>",
        "id": 167381015,
        "sender_full_name": "eddyb",
        "timestamp": 1559736137
    },
    {
        "content": "<p>it gets weirder when there are multiple uses of a promoted local, and only some of them are promoted</p>",
        "id": 167381163,
        "sender_full_name": "eddyb",
        "timestamp": 1559736276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> tried to make some changes in this area</p>",
        "id": 167381170,
        "sender_full_name": "eddyb",
        "timestamp": 1559736282
    },
    {
        "content": "<p>even if they both checked <code>Drop</code> terminators, the checks would be quite different</p>",
        "id": 167381188,
        "sender_full_name": "eddyb",
        "timestamp": 1559736296
    },
    {
        "content": "<p>anyway, after <a href=\"https://github.com/rust-lang/rust/issues/61539\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/61539\">https://github.com/rust-lang/rust/issues/61539</a>, I <em>really</em> need a break</p>",
        "id": 167381237,
        "sender_full_name": "eddyb",
        "timestamp": 1559736350
    },
    {
        "content": "<p>I did some cleanups, but I don't think I went through with everything I wanted</p>",
        "id": 167383699,
        "sender_full_name": "oli",
        "timestamp": 1559738270
    },
    {
        "content": "<p>I really need a todo list</p>",
        "id": 167383702,
        "sender_full_name": "oli",
        "timestamp": 1559738276
    },
    {
        "content": "<blockquote>\n<p>while promotion in fn's can never do that, since the respective drop is at runtime</p>\n</blockquote>\n<p>well, <em>If</em> the drop is <code>const impl</code> we could allow promoting (that is assuming we are willing to promote arbitrary <code>const fn</code> calls -- which is less of a problem for calls that don't return anything, like <code>drop</code>)</p>",
        "id": 167393884,
        "sender_full_name": "RalfJ",
        "timestamp": 1559744890
    },
    {
        "content": "<blockquote>\n<p>one is about not executing implicit non-<code>const fn</code> <code>Drop::drop</code> calls, the other is about preserving observable behavior</p>\n</blockquote>\n<p>but in that case then, wouldnt we want to ignore some \"qualif\"s in the promotion part because they are only relevant for const checking?</p>",
        "id": 167394139,
        "sender_full_name": "RalfJ",
        "timestamp": 1559745010
    },
    {
        "content": "<blockquote>\n<p>well, <em>If</em> the drop is <code>const impl</code> we could allow promoting (that is assuming we are willing to promote arbitrary <code>const fn</code> calls -- which is less of a problem for calls that don't return anything, like <code>drop</code>)</p>\n</blockquote>\n<p>not a good idea imo. User code will \"randomly\" (from the perspective of someone who doesn't know about promotion) start to stop running destructors</p>",
        "id": 167395882,
        "sender_full_name": "oli",
        "timestamp": 1559745977
    },
    {
        "content": "<p>it won't stop running them, it'll run them at CTFE time</p>",
        "id": 167403375,
        "sender_full_name": "RalfJ",
        "timestamp": 1559750350
    },
    {
        "content": "<p><strong>@eddyb</strong> my point was merely that we could skip running dataflow as an optimization if the result type of the const block cannot have interior mutability behind a reference and is not needs drop.</p>",
        "id": 167408248,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1559753655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> IMO that's both a premature optimization <em>and</em> dangerous <em>even if</em> it's sound now (which I don't know if it is)</p>",
        "id": 168419154,
        "sender_full_name": "eddyb",
        "timestamp": 1560876399
    },
    {
        "content": "<p>because if we change some things in the \"unoptimized\" version and the <em>condition</em> for using the \"optimized\" version don't take that into account, they can be out of sync</p>",
        "id": 168419240,
        "sender_full_name": "eddyb",
        "timestamp": 1560876462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> also I don't understand why \"reaching definition\" might be needed</p>",
        "id": 168419256,
        "sender_full_name": "eddyb",
        "timestamp": 1560876476
    },
    {
        "content": "<p>(from the other thread)</p>",
        "id": 168419323,
        "sender_full_name": "eddyb",
        "timestamp": 1560876508
    },
    {
        "content": "<p>I feel bad because it seems like I'm just confusing everyone with something that should be otherwise not that complicated :(</p>",
        "id": 168419356,
        "sender_full_name": "eddyb",
        "timestamp": 1560876539
    },
    {
        "content": "<p>Unfortunately I have a pretty low threshold for confusion :) Reaching definitions lets us create a use-def chain, which we can use to enumerate all possible rvalues that could get assigned to the return place</p>",
        "id": 168419526,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560876644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> that's implying a full rewrite of the pass though?</p>",
        "id": 168419575,
        "sender_full_name": "eddyb",
        "timestamp": 1560876683
    },
    {
        "content": "<p>as opposed to just computing the same bits as today, but using the dataflow framework</p>",
        "id": 168419591,
        "sender_full_name": "eddyb",
        "timestamp": 1560876699
    },
    {
        "content": "<p>which handles control-flow unlike the limitation of linear control-flow today</p>",
        "id": 168419608,
        "sender_full_name": "eddyb",
        "timestamp": 1560876716
    },
    {
        "content": "<p>not to mention it's hard to encode everything touching a local in an use-def chain</p>",
        "id": 168419692,
        "sender_full_name": "eddyb",
        "timestamp": 1560876774
    },
    {
        "content": "<p>we're reaching VSDG-level of complexity</p>",
        "id": 168419718,
        "sender_full_name": "eddyb",
        "timestamp": 1560876788
    },
    {
        "content": "<p>I think it would yes.</p>",
        "id": 168419829,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560876861
    },
    {
        "content": "<p>also, what would you do for loops? forward dataflow can track properties of locals modified by a loop, but \"pulling\" the definition from an Use-Def chain would need to handle the fixpoint of loops which is where most of the complexity of VSDG comes from</p>",
        "id": 168419831,
        "sender_full_name": "eddyb",
        "timestamp": 1560876863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay but I never suggested any of this?</p>",
        "id": 168419844,
        "sender_full_name": "eddyb",
        "timestamp": 1560876881
    },
    {
        "content": "<p>I guess I was confused when you mentioned the existing dataflow framework above</p>",
        "id": 168419854,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560876893
    },
    {
        "content": "<p>this is why I think that maybe I should do it myself because I don't seem to get across just how simple this is supposed to be</p>",
        "id": 168419883,
        "sender_full_name": "eddyb",
        "timestamp": 1560876914
    },
    {
        "content": "<p>I do not have a problem with that :)</p>",
        "id": 168419929,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560876941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> \"dataflow analysis\" aka (forward) propagation of 1 bit of information per local variable, not \"dataflow graph\"</p>",
        "id": 168419945,
        "sender_full_name": "eddyb",
        "timestamp": 1560876950
    },
    {
        "content": "<p>yeah the only issue is that  I keep accumulating TODO items faster than I can dispatch them :(</p>",
        "id": 168420002,
        "sender_full_name": "eddyb",
        "timestamp": 1560876966
    },
    {
        "content": "<p>So, reaching defs keeps a bit for each assignment in the program, not for each local</p>",
        "id": 168420085,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877038
    },
    {
        "content": "<p>(not sure if I'm repeating stuff you already know)</p>",
        "id": 168420111,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877059
    },
    {
        "content": "<p>yeah I know. I just have no idea why you'd switch to something incredibly more difficult</p>",
        "id": 168420127,
        "sender_full_name": "eddyb",
        "timestamp": 1560877070
    },
    {
        "content": "<p>(unless you don't want to handle loops?)</p>",
        "id": 168420134,
        "sender_full_name": "eddyb",
        "timestamp": 1560877078
    },
    {
        "content": "<p>Why does reaching definitions not handle loops?</p>",
        "id": 168420234,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877123
    },
    {
        "content": "<p>(even then it's more work unless you reconstruct a DAG version of the MIR, more VSDG-like. that would be useful for unification of \"type-level const expressions\" in the context of const generics :P)</p>",
        "id": 168420238,
        "sender_full_name": "eddyb",
        "timestamp": 1560877124
    },
    {
        "content": "<p>back-edges in the CFG are handled fine I believe</p>",
        "id": 168420252,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> it's not really the \"reaching definitions\" but rather how you plan to use them</p>",
        "id": 168420259,
        "sender_full_name": "eddyb",
        "timestamp": 1560877141
    },
    {
        "content": "<p>to \"pull\" the definition of a value</p>",
        "id": 168420277,
        "sender_full_name": "eddyb",
        "timestamp": 1560877152
    },
    {
        "content": "<p>this is bad because in a loop, a value can depend on things in previous iterations</p>",
        "id": 168420305,
        "sender_full_name": "eddyb",
        "timestamp": 1560877172
    },
    {
        "content": "<p>forward dataflow can saturate a property, and we know that's sound (especially since it runs in the same direction the code would run at runtime :P), but if you do it by \"pulling\" things, you run into soundness concerns of cyclic analyses</p>",
        "id": 168420450,
        "sender_full_name": "eddyb",
        "timestamp": 1560877245
    },
    {
        "content": "<p>we'd have this problem if we wanted to, say, promote a  value that was constructed by a loop</p>",
        "id": 168420500,
        "sender_full_name": "eddyb",
        "timestamp": 1560877276
    },
    {
        "content": "<p>we'd have to represent the cyclical control-flow around the assignments, too</p>",
        "id": 168420543,
        "sender_full_name": "eddyb",
        "timestamp": 1560877305
    },
    {
        "content": "<p>Rephrasing, I'll get the set of definitions which are live, but those definitions may depend on earlier values</p>",
        "id": 168420544,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877306
    },
    {
        "content": "<p>in the loop iteration</p>",
        "id": 168420553,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877315
    },
    {
        "content": "<p>?</p>",
        "id": 168420560,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877321
    },
    {
        "content": "<p>yes. and you need a fixpoint algorithm</p>",
        "id": 168420598,
        "sender_full_name": "eddyb",
        "timestamp": 1560877325
    },
    {
        "content": "<p>and I'm not sure I can think of one</p>",
        "id": 168420614,
        "sender_full_name": "eddyb",
        "timestamp": 1560877340
    },
    {
        "content": "<p>not to mention this is harder than doing the (straight)forward dataflow the rest of the compiler uses</p>",
        "id": 168420642,
        "sender_full_name": "eddyb",
        "timestamp": 1560877364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> so, today, we have one bitvec per <code>Qualif</code> implementor and we mutate them on every <code>Assign</code>/<code>Call</code>. and this works only for linear control-flow. if we switched to using the dataflow framework, we'd have one dataflow result for each <code>Qualif</code> implementor, that we could advance, and it gives us access to one bitvec each</p>",
        "id": 168420765,
        "sender_full_name": "eddyb",
        "timestamp": 1560877450
    },
    {
        "content": "<p>so for linear control-flow we'd just observe the same values in those bitvecs</p>",
        "id": 168420787,
        "sender_full_name": "eddyb",
        "timestamp": 1560877473
    },
    {
        "content": "<p>but more interesting control-flow would also \"just work\"</p>",
        "id": 168420816,
        "sender_full_name": "eddyb",
        "timestamp": 1560877499
    },
    {
        "content": "<p>and most of the code won't have to change at all to account for this</p>",
        "id": 168420857,
        "sender_full_name": "eddyb",
        "timestamp": 1560877528
    },
    {
        "content": "<p>Okay, so you were thinking of something like the strategy that I mentioned  at the top of this (one bit per local representing qualif-state)</p>",
        "id": 168420866,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877532
    },
    {
        "content": "<p>yeah which is literally what we do today</p>",
        "id": 168420891,
        "sender_full_name": "eddyb",
        "timestamp": 1560877548
    },
    {
        "content": "<p>but I wasn't sure how to fit this into the \"gen-kill\" framework</p>",
        "id": 168420899,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877555
    },
    {
        "content": "<p>those are silly names for set/unset</p>",
        "id": 168420950,
        "sender_full_name": "eddyb",
        "timestamp": 1560877569
    },
    {
        "content": "<p>or I should say, \"historical names\"</p>",
        "id": 168420957,
        "sender_full_name": "eddyb",
        "timestamp": 1560877577
    },
    {
        "content": "<p>since the transfer function depends on whether another bit in the dataflow is set</p>",
        "id": 168420984,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877606
    },
    {
        "content": "<p>which might change as we're iterating</p>",
        "id": 168420994,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877618
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 168420998,
        "sender_full_name": "eddyb",
        "timestamp": 1560877621
    },
    {
        "content": "<p>oh</p>",
        "id": 168421019,
        "sender_full_name": "eddyb",
        "timestamp": 1560877645
    },
    {
        "content": "<p>OH</p>",
        "id": 168421021,
        "sender_full_name": "eddyb",
        "timestamp": 1560877647
    },
    {
        "content": "<p>/me facepalms</p>",
        "id": 168421031,
        "sender_full_name": "eddyb",
        "timestamp": 1560877659
    },
    {
        "content": "<p>So if I have <code>_1 = _2</code>, I only want to gen <code>_1</code> if the qualif bit for <code>_2</code> is set</p>",
        "id": 168421033,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877661
    },
    {
        "content": "<p>I'm sorry it took me so long to find out that this is was your issue :(</p>",
        "id": 168421098,
        "sender_full_name": "eddyb",
        "timestamp": 1560877692
    },
    {
        "content": "<p>that's okay, I'm maybe a bit too shy</p>",
        "id": 168421141,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877732
    },
    {
        "content": "<p>I kept wondering what am I missing, but this makes sense</p>",
        "id": 168421161,
        "sender_full_name": "eddyb",
        "timestamp": 1560877747
    },
    {
        "content": "<p>I can do this in a generic dataflow algorithm, but not in the <code>BitDenotation</code>-based one.</p>",
        "id": 168421198,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560877793
    },
    {
        "content": "<p>I was so intent of removing dependencies between the various bits... that I forgot how dataflow analysis works</p>",
        "id": 168421202,
        "sender_full_name": "eddyb",
        "timestamp": 1560877796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay yeah it can still be bit-based, and it should reach fixpoint, you just can't compute the effects in isolation...</p>",
        "id": 168421414,
        "sender_full_name": "eddyb",
        "timestamp": 1560877944
    },
    {
        "content": "<p>I still think \"pull\" would be too much of a change :(</p>",
        "id": 168421429,
        "sender_full_name": "eddyb",
        "timestamp": 1560877965
    },
    {
        "content": "<p>\"pull\"?</p>",
        "id": 168421548,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560878046
    },
    {
        "content": "<p>the thing you were talking about, to walk to the definition</p>",
        "id": 168421562,
        "sender_full_name": "eddyb",
        "timestamp": 1560878058
    },
    {
        "content": "<p>you're \"pulling\" the definition. whereas right now we're \"pushing\" properties to the use</p>",
        "id": 168421582,
        "sender_full_name": "eddyb",
        "timestamp": 1560878079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> so uhhh we technically could add <code>bits[i] = bits[j]</code> / <code>bits[i] |= bits[j]</code> on top of the <code>bits[i] = constant</code> that gen/kill represent, to the existing dataflow framework, but <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> might hate us :D</p>",
        "id": 168423548,
        "sender_full_name": "eddyb",
        "timestamp": 1560878161
    },
    {
        "content": "<p>we would have to change the <code>Qualif</code> methods to do something quite different than just <code>-&gt; bool</code>, but it shouldn't be that bad (and we could do it today, with the linear controlflow restriction, before messing with the dataflow framework)</p>",
        "id": 168423677,
        "sender_full_name": "eddyb",
        "timestamp": 1560878240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> A custom dataflow  algorithm isn't  that hard, there's already one here for liveness (that I think could have been implemented on top of `BitDenotation?)</p>",
        "id": 168423784,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560878323
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src/librustc_mir/util/liveness.rs#L59\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src/librustc_mir/util/liveness.rs#L59\">https://github.com/rust-lang/rust/blob/9606f6fa64926a84d82e3c62dbdc57f5c10f756d/src/librustc_mir/util/liveness.rs#L59</a></p>",
        "id": 168423787,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560878325
    },
    {
        "content": "<p>yeah I know I'd just hate myself and maybe risk making it unsound</p>",
        "id": 168423818,
        "sender_full_name": "eddyb",
        "timestamp": 1560878349
    },
    {
        "content": "<p>I think the liveness one is separate because liveness is backwards dataflow IIRC</p>",
        "id": 168423835,
        "sender_full_name": "eddyb",
        "timestamp": 1560878360
    },
    {
        "content": "<p>I have a branch on which I wrote a thing I called \"eventflow\" that was bidirectional and was focused on tracking \"something may have happened in the past/future\" as opposed to \"stateful properties\"</p>",
        "id": 168423951,
        "sender_full_name": "eddyb",
        "timestamp": 1560878426
    },
    {
        "content": "<p>(like, it was saturating, <code>gen</code>-only so to speak, whereas <code>liveness</code> uses <code>kill</code>)</p>",
        "id": 168424004,
        "sender_full_name": "eddyb",
        "timestamp": 1560878473
    },
    {
        "content": "<p>ah, that's right</p>",
        "id": 168424007,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560878475
    },
    {
        "content": "<p>(<a href=\"https://github.com/eddyb/rust/blob/copy-elision/src/librustc_mir/analysis/eventflow.rs\" target=\"_blank\" title=\"https://github.com/eddyb/rust/blob/copy-elision/src/librustc_mir/analysis/eventflow.rs\">https://github.com/eddyb/rust/blob/copy-elision/src/librustc_mir/analysis/eventflow.rs</a>)</p>",
        "id": 168424229,
        "sender_full_name": "eddyb",
        "timestamp": 1560878608
    },
    {
        "content": "<p>so, I'm a bit conflicted now. I certainly think that some sort of sparse array of \"where should the value for this output bit come from? unchanged, constant (gen/kill), or some other input bit?\", generated the same way gen/kill sets are today, could be faster to compute with than re-doing all the per-statement logic on every propagation</p>",
        "id": 168426387,
        "sender_full_name": "eddyb",
        "timestamp": 1560878782
    },
    {
        "content": "<p>but I'm not sure what we should be doing. at least I'm still more confident in forward dataflow for reasoning about the state of locals at some point in the control-flow</p>",
        "id": 168426436,
        "sender_full_name": "eddyb",
        "timestamp": 1560878833
    },
    {
        "content": "<p>So we could keep the \"gen/kill\" set, then add an ancillary \"steal\" sparse map per CFG-edge</p>",
        "id": 168426929,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560879147
    },
    {
        "content": "<p>The normal dataflow analyses would all have empty \"steal\" maps so I don't think it would slow things down too much in the normal case</p>",
        "id": 168427260,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560879348
    },
    {
        "content": "<p>There's one other thing that I found confusing and that may be applicable: the current framework lets you inspect the initial state of each block (and optionally the initial state at each statement) when defining your transfer function. I'm not 100% sure why this is useful. I <em>think</em> it helps the rate of convergence since if we have<code>_1 = Some(Cell::new()); _2 = _1;</code>, we could immediately gen the bit for <code>_2</code> instead of \"steal\"-ing from <code>_1</code></p>",
        "id": 168438280,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560880309
    },
    {
        "content": "<p>The only place that parameter is actually used is here: <a href=\"https://github.com/rust-lang/rust/blob/44fb88d25282d9362774536965f2455f677734f3/src/librustc_mir/dataflow/impls/borrows.rs#L207\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/44fb88d25282d9362774536965f2455f677734f3/src/librustc_mir/dataflow/impls/borrows.rs#L207\">https://github.com/rust-lang/rust/blob/44fb88d25282d9362774536965f2455f677734f3/src/librustc_mir/dataflow/impls/borrows.rs#L207</a></p>",
        "id": 168438581,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560880477
    },
    {
        "content": "<p>wait</p>",
        "id": 168439717,
        "sender_full_name": "eddyb",
        "timestamp": 1560881113
    },
    {
        "content": "<p>let me actually check the propagation :|</p>",
        "id": 168439747,
        "sender_full_name": "eddyb",
        "timestamp": 1560881121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> it's intra-block only &lt;<a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/mod.rs#L574-L597\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/mod.rs#L574-L597\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/mod.rs#L574-L597</a>&gt;</p>",
        "id": 168439930,
        "sender_full_name": "eddyb",
        "timestamp": 1560881252
    },
    {
        "content": "<p>which makes sense, the gen/kill sets are only computed once per block</p>",
        "id": 168440021,
        "sender_full_name": "eddyb",
        "timestamp": 1560881285
    },
    {
        "content": "<p>So that flag changes whether you can see the effects of previous statements in the block applied to the initial entry set when defining transfer functions for later statements</p>",
        "id": 168440088,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881342
    },
    {
        "content": "<p>Otherwise every statement in the block sees only the effect from <code>start_block_effect</code></p>",
        "id": 168440278,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881486
    },
    {
        "content": "<p>which is either all-ones or all-zeros, IIRC</p>",
        "id": 168440381,
        "sender_full_name": "eddyb",
        "timestamp": 1560881538
    },
    {
        "content": "<p>No, you can have custom <code>start_block_effect</code>s. Like marking all parameters to a function as <code>DefinitelyInitialized</code></p>",
        "id": 168440442,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881593
    },
    {
        "content": "<p>hmm but that's invalid except for the start block?</p>",
        "id": 168440471,
        "sender_full_name": "eddyb",
        "timestamp": 1560881612
    },
    {
        "content": "<p>everything else should assume the most conservative thing possible</p>",
        "id": 168440491,
        "sender_full_name": "eddyb",
        "timestamp": 1560881630
    },
    {
        "content": "<p>(e.g. you can move out of those argument locals)</p>",
        "id": 168440560,
        "sender_full_name": "eddyb",
        "timestamp": 1560881651
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/44fb88d25282d9362774536965f2455f677734f3/src/librustc_mir/dataflow/mod.rs#L201\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/44fb88d25282d9362774536965f2455f677734f3/src/librustc_mir/dataflow/mod.rs#L201\">https://github.com/rust-lang/rust/blob/44fb88d25282d9362774536965f2455f677734f3/src/librustc_mir/dataflow/mod.rs#L201</a></p>",
        "id": 168440584,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881675
    },
    {
        "content": "<p>Right, so <code>on_entry</code> will have the value from <code>start_block_effect</code></p>",
        "id": 168440640,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881712
    },
    {
        "content": "<p>while defining transfer functions in <em>all</em> basic blocks</p>",
        "id": 168440781,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881780
    },
    {
        "content": "<p>It's just not useful there</p>",
        "id": 168440795,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881787
    },
    {
        "content": "<p>Oh wait. I'm wrong, it just has those effects in the<code>START_BLOCK</code></p>",
        "id": 168440979,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881913
    },
    {
        "content": "<p><em>phew</em></p>",
        "id": 168441006,
        "sender_full_name": "eddyb",
        "timestamp": 1560881930
    },
    {
        "content": "<p>All other blocks will have see the entry set be either all zeros or all ones like you said</p>",
        "id": 168441022,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1560881939
    },
    {
        "content": "<p>@eddyb, I did another readthrough of <code>qualify_consts.rs</code> in my free time yesterday. I think I  want to make <code>BitDenotation</code> variant over transfer functions, so if/when <a href=\"https://github.com/rust-lang/rust/issues/61787\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/61787\">#61787</a>  lands, <code>GenKillSet</code> will become the canonical implementer but const-qualification will have one that adds the ability to copy bits from other locals (this operation will be pretty slow if there's a lot of assignments).</p>",
        "id": 168608696,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046354
    },
    {
        "content": "<p>I then want to split <code>qualify_consts</code> into two logical passes, the first checks for const correctness (e.g. calling non-const fns, accessing mutable statics, etc.). The second is where we run dataflow.</p>",
        "id": 168608835,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 168609071,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046632
    },
    {
        "content": "<p>That is :)</p>",
        "id": 168609078,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046638
    },
    {
        "content": "<p>so, the way I imagined this would go</p>",
        "id": 168609160,
        "sender_full_name": "eddyb",
        "timestamp": 1561046696
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 168609174,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046705
    },
    {
        "content": "<p>is that we would keep the current pass</p>",
        "id": 168609205,
        "sender_full_name": "eddyb",
        "timestamp": 1561046722
    },
    {
        "content": "<p>but run the dataflow <em>before</em> it, such that we can seek the results at any <code>Location</code> we need</p>",
        "id": 168609248,
        "sender_full_name": "eddyb",
        "timestamp": 1561046746
    },
    {
        "content": "<p>so most of the code would remain unchanged (risking little to no bugs :P)</p>",
        "id": 168609315,
        "sender_full_name": "eddyb",
        "timestamp": 1561046770
    },
    {
        "content": "<p>My next thought was \"I'm worried about creating a massive, unreviewable diff since the control flow in <code>qualify_consts</code> is pretty hard to separate out\" :)</p>",
        "id": 168609358,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046822
    },
    {
        "content": "<p>like, the way things are set up right now is that very little of the code actually <em>writes</em> the bitvecs, most of it reads them</p>",
        "id": 168609388,
        "sender_full_name": "eddyb",
        "timestamp": 1561046867
    },
    {
        "content": "<p>That makes things easier, so <code>ConstCx</code> will also store dataflow results, and <code>in_local</code> will fetch the results of dataflow analysis</p>",
        "id": 168609399,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561046881
    },
    {
        "content": "<p>and if we have the dataflow results we should be able to seek them as we do the const-checking</p>",
        "id": 168609445,
        "sender_full_name": "eddyb",
        "timestamp": 1561046898
    },
    {
        "content": "<p>yupp :D</p>",
        "id": 168609447,
        "sender_full_name": "eddyb",
        "timestamp": 1561046900
    },
    {
        "content": "<p>I'm planning to work on this in the evenings (I'm UTC-8:00, so in 9 hours or so), so I'll keep doing progress reports and ask questions if I get stuck</p>",
        "id": 168609734,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561047141
    },
    {
        "content": "<p>I haven't considered abstracting dataflow before at the level of \"ahead-of-time computation for each whole block\" but I really like the idea!</p>",
        "id": 168609797,
        "sender_full_name": "eddyb",
        "timestamp": 1561047212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> have you had a chance to discuss this with <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> or <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> yet?</p>",
        "id": 168609808,
        "sender_full_name": "eddyb",
        "timestamp": 1561047224
    },
    {
        "content": "<p>if modular enough NLL borrowck might be able to use it to enhance some aspects of, say, error reporting (cc <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> I guess?)</p>",
        "id": 168609877,
        "sender_full_name": "eddyb",
        "timestamp": 1561047258
    },
    {
        "content": "<p>No, I think niko is unavailable, but i can try to have a sync talk with <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> if he's not too busy.</p>",
        "id": 168609951,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561047318
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>, I got a bit side-tracked while trying to customize dataflow analysis (see <a href=\"https://github.com/rust-lang/rust/issues/62010\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/62010\">#62010</a>, <a href=\"https://github.com/rust-lang/rust/issues/62062\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/62062\">#62062</a>, <a href=\"https://github.com/rust-lang/rust/issues/61787\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/61787\">#61787</a>).  I'm returning to const-qualification now. However, I think there's a problem with adding a general-purpose assign operator (<code>bit[i] = bit[j]</code>) to transfer functions. The reason the \"gen-kill\" paradigm is useful is that it composes nicely, allowing us to build up a single pair of bit-vectors which apply the transfer functions of all statements in the block. As soon as we add and assign operator, however, we can no longer coalesce transfer functions in this way, since the order of assignments relative to gens and kills matters. For example, I believe the following cannot be expressed by a single gen/kill set and a single, ordered list of assignments:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_1</span><span class=\"w\"></span>\n<span class=\"n\">_1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"n\">_3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_2</span><span class=\"w\"></span>\n<span class=\"n\">_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"n\">_1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_2</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>This means that such a transfer function can't be nicely added to the existing dataflow execution engine. We would need a separate, slower one which goes statement-by-statement.</p>",
        "id": 169050825,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561569375
    },
    {
        "content": "<p>I considered whether transfer functions could be split into three components, assign before gen-kill, gen-kill, and assign after gen-kill, but I think  that's not possible for every basic block.</p>",
        "id": 169051541,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561569944
    },
    {
        "content": "<p>Can't come up with a good example though</p>",
        "id": 169051602,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561569968
    },
    {
        "content": "<p>Hmm, maybe I'm wrong</p>",
        "id": 169052715,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561570760
    },
    {
        "content": "<p>If the RHS has been <code>gen</code>-ed or <code>kill</code>-ed earlier in the block, instead of assigning, you just <code>gen</code>/<code>kill</code> it. And assignments are always applied before <code>gen</code> and <code>kill</code>.</p>",
        "id": 169053060,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561570942
    },
    {
        "content": "<p>The other issue here is that the dataflow at location APIs rely on transfer functions being idempotent (<code>trans(trans(v)) == trans(v)</code>). A transfer function like  <code>_1 = _2; _2 = _3</code> does not meet this assumption.</p>",
        "id": 169074441,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561578939
    },
    {
        "content": "<p>sooo there's a less efficient but still per-block view of this: per-element (e.g. per-local) <code>Unchanged | Clear | Set | CopyFrom(OtherElement)</code></p>",
        "id": 169128749,
        "sender_full_name": "eddyb",
        "timestamp": 1561637848
    },
    {
        "content": "<p>kill/gen is a 2-bit encoding of <code>Unchanged | Clear | Set</code>, split into two bit vectors for efficiency reasons</p>",
        "id": 169128772,
        "sender_full_name": "eddyb",
        "timestamp": 1561637879
    },
    {
        "content": "<p>if you want to use kill/gen bitvecs + another vec for \"copy from\", you'll have to clear the 2 you're not using, for any action</p>",
        "id": 169128841,
        "sender_full_name": "eddyb",
        "timestamp": 1561637924
    },
    {
        "content": "<p>gen/kill are <em>already</em> exclusive. this \"two bitvecs and one regular vec\" would still have to be exclusive</p>",
        "id": 169128880,
        "sender_full_name": "eddyb",
        "timestamp": 1561637962
    },
    {
        "content": "<p>although, come to think of it, <code>A | B | C | ... | Z(Local)</code> is the same size as <code>Local</code>, thanks to <code>newtype_index!</code> and <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>'s attribute hacks for validity ranges</p>",
        "id": 169128956,
        "sender_full_name": "eddyb",
        "timestamp": 1561638008
    },
    {
        "content": "<p>How do you encode the relative order of assignments in that scheme (e.g. <code>_1 = _2; _2 = _3</code>)? I think you need a collection that maintains the order of <code>CopyFrom(OtherElement)</code> within a block.</p>",
        "id": 169156752,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561657362
    },
    {
        "content": "<p>Does this make you reconsider the reaching definitions formulation of const-qualification at all? I'm starting to think that building a use-def chain would be simpler than supporting <code>CopyFrom</code></p>",
        "id": 169156936,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1561657478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> sorry, I didn't see that question. I would assume you would just do the SSA thing?</p>",
        "id": 169462009,
        "sender_full_name": "eddyb",
        "timestamp": 1562055660
    },
    {
        "content": "<p>like, you would end up with an <code>state</code> array for which <code>state[1] == CopyFrom(_2)</code> and <code>state[2] == CopyFrom(_3)</code></p>",
        "id": 169462101,
        "sender_full_name": "eddyb",
        "timestamp": 1562055729
    },
    {
        "content": "<p>but you can only get <code>CopyFrom(x)</code> if <code>state[x]</code> is <code>Unchanged</code> at that point in the block  when <code>CopyFrom</code> would've been emitted</p>",
        "id": 169462258,
        "sender_full_name": "eddyb",
        "timestamp": 1562055875
    },
    {
        "content": "<p>that is, <code>CopyFrom</code> uses <em>the on-entry</em> value</p>",
        "id": 169462289,
        "sender_full_name": "eddyb",
        "timestamp": 1562055904
    },
    {
        "content": "<p>so you could imagine it in another way: <code>AtBlockEntry(Local) | Clear | Set</code></p>",
        "id": 169462343,
        "sender_full_name": "eddyb",
        "timestamp": 1562055953
    },
    {
        "content": "<p>where everything is initialized to <code>AtBlockEntry(Local)</code></p>",
        "id": 169462389,
        "sender_full_name": "eddyb",
        "timestamp": 1562055966
    },
    {
        "content": "<p>and on <code>Assign(x, y)</code> you literally just go <code>state[x] = state[y]</code>, copying the intra-block state</p>",
        "id": 169462425,
        "sender_full_name": "eddyb",
        "timestamp": 1562056001
    },
    {
        "content": "<p>which <em>might</em> be <code>AtBlockEntry(y)</code> but could be anything else</p>",
        "id": 169462806,
        "sender_full_name": "eddyb",
        "timestamp": 1562056316
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> wait, what about something like <code>x = (y, z);</code> - that needs to <code>|</code> two other locals' bits together, so you do need a list of <code>|=</code> operations instead...</p>",
        "id": 169463535,
        "sender_full_name": "eddyb",
        "timestamp": 1562056997
    },
    {
        "content": "<p>this is turning into an SSA-like DAG of operations isn't it :P</p>",
        "id": 169463779,
        "sender_full_name": "eddyb",
        "timestamp": 1562057269
    },
    {
        "content": "<p>Hmm, yes. While we could solve that particular case by tracking individual move paths (e.g. <code>a.b.c</code>) and doing  deaggregation, we can't handle successive assignments to an array index (e.g. <code>a[x]</code>) without <code>|</code>. At that point I think there's no way to efficiently concatenate statement transfer functions; you have to step through each basic block statement-by-statement.</p>\n<p>As the transfer function of the per-local approach becomes more expensive, I become more convinced that a reaching definitions formulation would be comparable in performance. While you have to store a bit for each definition of a local (instead of each local), you only have to run a single dataflow analysis for all 4 qualifications.</p>\n<p>The big question is how to handle cycles in the use-def chain while propagating qualifications, but I believe a simple graph traversal is sufficient. To start, each definition of a local is unconditionally qualified, unconditionally not qualified, or qualified if any one of a set of locals may be qualified. When the last case happens, we add all definitions of the aforementioned set of locals that reach the current point to a work queue, and recursively process them until we find one that is definitely qualified or we run out of definitions in the queue. If we encounter a cyclical dependency (as would occur in <code>loop { x = x + 1}</code>), that definition will already be on the work queue. We should be able to simply skip these tautologies (<code>qualif(x = x + 1) -&gt; qualif(x = x+ 1)</code>), since the only way the condition can be qualified is if one of the other definitions (in this case of <code>x</code>) on the work queue is qualified.</p>\n<p>I have been continuing work on a reaching definitions pass a bit (I extended <code>rustc_peek</code> and wrote a test, and started on a use-def chain). I'm worried about the memory overhead of storing all reaching definitions for every use of a local in the body. It would be nice to compute these on-demand, but accessing intra-block dataflow state requires processing all previous statements in the block, so without processing them in order at the beginning, we would be quadratic in the worst case.</p>",
        "id": 169497551,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562086362
    },
    {
        "content": "<p>Sorry for the brain dump <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> <span aria-label=\"silence\" class=\"emoji emoji-1f910\" role=\"img\" title=\"silence\">:silence:</span></p>",
        "id": 169497697,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562086477
    },
    {
        "content": "<p>given what I've seen regarding VSDG, I'm really scared of relying on \"reaching definitions\" in an analysis</p>",
        "id": 169499823,
        "sender_full_name": "eddyb",
        "timestamp": 1562087979
    },
    {
        "content": "<p><em>at most</em> I would create some sort of data structure to help do forward dataflow, with a restriction like single-dominating-definition</p>",
        "id": 169499997,
        "sender_full_name": "eddyb",
        "timestamp": 1562088052
    },
    {
        "content": "<p>you can even build the equivalent of \"decision trees\" except without conditions. so they're more like \"merge trees\"</p>",
        "id": 169500254,
        "sender_full_name": "eddyb",
        "timestamp": 1562088201
    },
    {
        "content": "<p>as long as you don't touch backedges</p>",
        "id": 169500271,
        "sender_full_name": "eddyb",
        "timestamp": 1562088220
    },
    {
        "content": "<p>and then you propagate along those merge edges until fixpoint, like the current dataflow algorithm</p>",
        "id": 169500321,
        "sender_full_name": "eddyb",
        "timestamp": 1562088243
    },
    {
        "content": "<p>this is what I get for assuming one could just slap dataflow onto qualify_consts....</p>",
        "id": 169500410,
        "sender_full_name": "eddyb",
        "timestamp": 1562088305
    },
    {
        "content": "<p>VSDG is value state dependence graph?</p>",
        "id": 169502747,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562089812
    },
    {
        "content": "<p>Yes it is</p>",
        "id": 169507021,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1562092399
    },
    {
        "content": "<p>yeah</p>",
        "id": 169624742,
        "sender_full_name": "eddyb",
        "timestamp": 1562222705
    },
    {
        "content": "<p>the soundness of converting a CFG to VSDG is pretty much all in the loops, you have to get them right - if you have a DAG (so no backedges, no looping) it's almost trivial to convert the branches at the splits to selects at the merges</p>",
        "id": 169624819,
        "sender_full_name": "eddyb",
        "timestamp": 1562222803
    },
    {
        "content": "<p>(and an entire function would be SESE, or at least very easy to turn SEME into SESE)</p>",
        "id": 169624847,
        "sender_full_name": "eddyb",
        "timestamp": 1562222863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> frankly, the sensible thing to do would probably be to convert each block into something <em>like</em> \"reaching definition\", but without needing the existing dataflow analysis to do (I guess \"still-live-on-block-exit writes to this local\" is more or less what I'd want there), and then do dataflow-like propagation of bits, but without caching the results or anything, just keep redoing each block's work (based on those \"known writes\") until fixpoint</p>",
        "id": 169627816,
        "sender_full_name": "eddyb",
        "timestamp": 1562226842
    },
    {
        "content": "<p>we could reuse some of the dataflow framework for \"propagate until fixpoint\" but the transfer function would be more involved than <code>(bits - kill) | gen</code></p>",
        "id": 169627893,
        "sender_full_name": "eddyb",
        "timestamp": 1562226917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I wrote up a summary of my thoughts on this on <a href=\"https://github.com/rust-lang/rust/issues/53819\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/53819\">#53819</a>. I still don't understand your concerns regarding VSDGs since I don't have the theoretical background. Basically, I think that the custom dataflow analysis which propagates qualif bits each iteration will be as sound/precise as one that computes the use-def chain ahead of time and then propagates qualification bits on that.</p>",
        "id": 170568002,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562784192
    },
    {
        "content": "<p>There's some justification for this idea at the end of my post, but I'm not sure how convincing you'll find it :)</p>",
        "id": 170568050,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562784228
    },
    {
        "content": "<p>I don't really understand how you even plan to use a def-use chain</p>",
        "id": 170605396,
        "sender_full_name": "eddyb",
        "timestamp": 1562826231
    },
    {
        "content": "<p>if you want to handle mutation</p>",
        "id": 170605400,
        "sender_full_name": "eddyb",
        "timestamp": 1562826242
    },
    {
        "content": "<p>anyway, I don't see how you can be correct around loops without a lot of painful work</p>",
        "id": 170605446,
        "sender_full_name": "eddyb",
        "timestamp": 1562826286
    },
    {
        "content": "<p>whereas dataflow sidesteps the problem by <em>interpreting the loop</em></p>",
        "id": 170605454,
        "sender_full_name": "eddyb",
        "timestamp": 1562826307
    },
    {
        "content": "<p>It feels like we're talking past each other a bit. Do you think you could provide a more concrete example of how this falls apart around loops? A use-def chain is built via a dataflow analysis, so I'm not really sure what you mean with your last statement</p>",
        "id": 170605741,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562826703
    },
    {
        "content": "<p>I guess that would be hard if you don't understand how I plan to use a use-def chain in the first place</p>",
        "id": 170605815,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562826772
    },
    {
        "content": "<p>are you mapping locations of uses to definitions?</p>",
        "id": 170605828,
        "sender_full_name": "eddyb",
        "timestamp": 1562826794
    },
    {
        "content": "<p>Yes</p>",
        "id": 170605833,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562826807
    },
    {
        "content": "<p>because that's already an improvement, and not really a def-use chain</p>",
        "id": 170605837,
        "sender_full_name": "eddyb",
        "timestamp": 1562826819
    },
    {
        "content": "<p>Uses of each local to definitions of that lovey</p>",
        "id": 170605841,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562826828
    },
    {
        "content": "<p>that's \"reaching definition\"</p>",
        "id": 170605842,
        "sender_full_name": "eddyb",
        "timestamp": 1562826830
    },
    {
        "content": "<p>Local</p>",
        "id": 170605846,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562826836
    },
    {
        "content": "<p>but not all definitions, surely? only the reaching ones?</p>",
        "id": 170605894,
        "sender_full_name": "eddyb",
        "timestamp": 1562826859
    },
    {
        "content": "<p>Correct</p>",
        "id": 170605898,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562826871
    },
    {
        "content": "<p>yeah I think we should say \"reaching defs\" not \"def-use chain\"</p>",
        "id": 170605906,
        "sender_full_name": "eddyb",
        "timestamp": 1562826887
    },
    {
        "content": "<p>the latter makes more sense when you have one def and many uses and you can use an intrusive linked list or something</p>",
        "id": 170605922,
        "sender_full_name": "eddyb",
        "timestamp": 1562826908
    },
    {
        "content": "<p>like, for SSA</p>",
        "id": 170605926,
        "sender_full_name": "eddyb",
        "timestamp": 1562826917
    },
    {
        "content": "<p>it's useful for visiting all uses of a def, because use -&gt; def in that sort if situation is already provided</p>",
        "id": 170605999,
        "sender_full_name": "eddyb",
        "timestamp": 1562826986
    },
    {
        "content": "<p>okay so what do you do for <code>local.field = ...;</code>?</p>",
        "id": 170606014,
        "sender_full_name": "eddyb",
        "timestamp": 1562827016
    },
    {
        "content": "<p>does it count as a \"def\"? I would probably switch to \"reaching writes\"</p>",
        "id": 170606030,
        "sender_full_name": "eddyb",
        "timestamp": 1562827041
    },
    {
        "content": "<p>My impression was that a UD chain is a data structure which one can build after doing a reaching definitions analysis</p>",
        "id": 170606033,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827052
    },
    {
        "content": "<p>it doesn't make sense when you have mutations though</p>",
        "id": 170606084,
        "sender_full_name": "eddyb",
        "timestamp": 1562827087
    },
    {
        "content": "<p>in SSA, you get a use-def chain for free (since each variable is only defined once)</p>",
        "id": 170606090,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827104
    },
    {
        "content": "<p>not exactly, you get use-&gt;def for free, but not def-&gt;uses</p>",
        "id": 170606101,
        "sender_full_name": "eddyb",
        "timestamp": 1562827130
    },
    {
        "content": "<p>anyway, regardless of terminology (which I'm not 100% sure of either, I'd defer to <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>)</p>",
        "id": 170606136,
        "sender_full_name": "eddyb",
        "timestamp": 1562827172
    },
    {
        "content": "<p>Okay so when you have mutations, there are multiple points where any one local can be \"defined\"</p>",
        "id": 170606144,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827184
    },
    {
        "content": "<p>do you track both partial mutations and merging branches?</p>",
        "id": 170606155,
        "sender_full_name": "eddyb",
        "timestamp": 1562827196
    },
    {
        "content": "<p>(I'm using defined to mean: \"any part of this variable can be written\")</p>",
        "id": 170606197,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827205
    },
    {
        "content": "<p>yeah that's prone to confusion, I'd just call that a write or mutation</p>",
        "id": 170606215,
        "sender_full_name": "eddyb",
        "timestamp": 1562827223
    },
    {
        "content": "<p>Yes. Partial mutations are tracked. Any assignment to a projection of a local is a \"partial definition\"</p>",
        "id": 170606230,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827242
    },
    {
        "content": "<p>e.g. <code>if c { x = a; } else { x = b; } x.f = y; use(x);</code></p>",
        "id": 170606276,
        "sender_full_name": "eddyb",
        "timestamp": 1562827277
    },
    {
        "content": "<p>re: merging branches, are you refering to the join operator for reaching defs dataflow ?</p>",
        "id": 170606278,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827280
    },
    {
        "content": "<p><code>use(x)</code> -&gt; <code>[\"x =a\", \"x =b\", \"x.f=y\"]</code></p>",
        "id": 170606340,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827333
    },
    {
        "content": "<p>Would be the use-def chain that the current analysis builds</p>",
        "id": 170606345,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827350
    },
    {
        "content": "<p>okay so.....</p>",
        "id": 170606378,
        "sender_full_name": "eddyb",
        "timestamp": 1562827397
    },
    {
        "content": "<p>but <code>if c { x.f = a } else {x.f = b} x = y; use(x);</code> would result in  <code>[\"x = y\"]</code></p>",
        "id": 170606383,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827401
    },
    {
        "content": "<p>how do you evaluate that?</p>",
        "id": 170606385,
        "sender_full_name": "eddyb",
        "timestamp": 1562827402
    },
    {
        "content": "<p>that's basically my overall question: you're building the equivalent of a VSDG fragment, except less principled</p>",
        "id": 170606397,
        "sender_full_name": "eddyb",
        "timestamp": 1562827431
    },
    {
        "content": "<p>Reaching definitions analysis is what's doing the work here</p>",
        "id": 170606471,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827481
    },
    {
        "content": "<p>no, I mean, not how you compute it</p>",
        "id": 170606477,
        "sender_full_name": "eddyb",
        "timestamp": 1562827493
    },
    {
        "content": "<p>how do you evaluate a property of <code>x</code> on that chain</p>",
        "id": 170606482,
        "sender_full_name": "eddyb",
        "timestamp": 1562827502
    },
    {
        "content": "<p>Ah, you need to look at the rvalue of each assignment</p>",
        "id": 170606503,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827545
    },
    {
        "content": "<p>but in what order/</p>",
        "id": 170606508,
        "sender_full_name": "eddyb",
        "timestamp": 1562827560
    },
    {
        "content": "<p>in pseudo-VSDG it would be something like <code>select(c, { x = a; }, { x = b; }) &gt;&gt;= { x.f = y; }</code></p>",
        "id": 170606562,
        "sender_full_name": "eddyb",
        "timestamp": 1562827590
    },
    {
        "content": "<p>What do you mean by \"order\"?</p>",
        "id": 170606593,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827630
    },
    {
        "content": "<p>how do you combine <code>a</code>, <code>b</code> and <code>y</code> into <code>x</code>?</p>",
        "id": 170606600,
        "sender_full_name": "eddyb",
        "timestamp": 1562827645
    },
    {
        "content": "<p>or more high-level: <code>x = Foo { f: y, ..select(c, a, b) }</code></p>",
        "id": 170606611,
        "sender_full_name": "eddyb",
        "timestamp": 1562827655
    },
    {
        "content": "<p>γ is basically <code>select</code> or the C <code>?:</code> operator</p>",
        "id": 170606616,
        "sender_full_name": "eddyb",
        "timestamp": 1562827668
    },
    {
        "content": "<p>okay it's actually indistinguishable from y, dammit</p>",
        "id": 170606677,
        "sender_full_name": "eddyb",
        "timestamp": 1562827694
    },
    {
        "content": "<p>I'll replace it with <code>select</code></p>",
        "id": 170606690,
        "sender_full_name": "eddyb",
        "timestamp": 1562827716
    },
    {
        "content": "<p>the union of the qualification bits for each of <code>a</code>, <code>b</code> and <code>y</code></p>",
        "id": 170606691,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827717
    },
    {
        "content": "<p>so you just union every write together?</p>",
        "id": 170606706,
        "sender_full_name": "eddyb",
        "timestamp": 1562827754
    },
    {
        "content": "<p>(If <code>c</code> is the condition, it's not considered)</p>",
        "id": 170606711,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827760
    },
    {
        "content": "<p>Every write which could possible reach that point in the program yes</p>",
        "id": 170606727,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827779
    },
    {
        "content": "<p>no matter the order.... hmmmmm</p>",
        "id": 170606737,
        "sender_full_name": "eddyb",
        "timestamp": 1562827795
    },
    {
        "content": "<p>I'm really confused why the order matters</p>",
        "id": 170606784,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827808
    },
    {
        "content": "<p>well, you're side-stepping it partially by mapping locations of uses</p>",
        "id": 170606795,
        "sender_full_name": "eddyb",
        "timestamp": 1562827828
    },
    {
        "content": "<p>so you at least have correct reaching writes for any use at the point of any other write</p>",
        "id": 170606812,
        "sender_full_name": "eddyb",
        "timestamp": 1562827856
    },
    {
        "content": "<p>If <code>x</code> has multiple reaching definitions, if any one of them is maybe qualified, we need to assume that <code>x</code> is maybe qualifed</p>",
        "id": 170606816,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562827863
    },
    {
        "content": "<p>for const qualif, sure</p>",
        "id": 170606824,
        "sender_full_name": "eddyb",
        "timestamp": 1562827877
    },
    {
        "content": "<p>so this works specifically because the writes are order-independent</p>",
        "id": 170606918,
        "sender_full_name": "eddyb",
        "timestamp": 1562827980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay, so, let me know if you've written this down before</p>",
        "id": 170606949,
        "sender_full_name": "eddyb",
        "timestamp": 1562828032
    },
    {
        "content": "<p>The order of writes is handled by the dataflow analysis. If there's a whole definition of <code>x</code> followed by  a partial definition of <code>x</code>, both will reach a \"use\" further down</p>",
        "id": 170607004,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828058
    },
    {
        "content": "<p>When there's multiple entries, the reaching definitions at exit of all predecessors are unioned</p>",
        "id": 170607044,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828095
    },
    {
        "content": "<p>for every local <code>x</code>, you're propagating a conservative approximation <code>f(x)</code> to every use of <code>x</code>, made by merging all the writes to <code>x</code> uniformly</p>",
        "id": 170607077,
        "sender_full_name": "eddyb",
        "timestamp": 1562828113
    },
    {
        "content": "<p>to do this, you're first propagating a <code>writes(x)</code> set, and <code>f(x)</code> at any given point is <code>writes(x).map(f).fold(merge)</code> at that point</p>",
        "id": 170607105,
        "sender_full_name": "eddyb",
        "timestamp": 1562828158
    },
    {
        "content": "<p>Yes. Can we change <code>f(x)</code> to <code>qualif(x)</code></p>",
        "id": 170607161,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828188
    },
    {
        "content": "<p>propagating <code>f</code> directly is equivalent to propagating <code>writes</code>, but the latter is more reusable, for multiple functions</p>",
        "id": 170607165,
        "sender_full_name": "eddyb",
        "timestamp": 1562828192
    },
    {
        "content": "<p>yeah I just meant dataflow in general</p>",
        "id": 170607173,
        "sender_full_name": "eddyb",
        "timestamp": 1562828201
    },
    {
        "content": "<p>Yes!</p>",
        "id": 170607182,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828216
    },
    {
        "content": "<p>okay so I see why this is sound, it's because of the unordered <code>merge</code> (ignoring full writes)</p>",
        "id": 170607191,
        "sender_full_name": "eddyb",
        "timestamp": 1562828230
    },
    {
        "content": "<p>(and it can be done using only gens and kills</p>",
        "id": 170607197,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828238
    },
    {
        "content": "<p>you couldn't use this for constant folding, for example</p>",
        "id": 170607201,
        "sender_full_name": "eddyb",
        "timestamp": 1562828247
    },
    {
        "content": "<p>(I'm a bit worried that naively doing this with the gen/kill dataflow framework might be less efficient than other alternatives but that's unrelated to my other concerns)</p>",
        "id": 170607257,
        "sender_full_name": "eddyb",
        "timestamp": 1562828288
    },
    {
        "content": "<p>I'm pretty sure you can't, because then you need a lattice containing all possible values</p>",
        "id": 170607264,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828302
    },
    {
        "content": "<p>for the constant</p>",
        "id": 170607268,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828314
    },
    {
        "content": "<p>hmm, you could handle <code>a += 1</code> because you'd be seeing <code>a = a + 1</code> and it's like <code>a@2 = a@1 + 1</code></p>",
        "id": 170607298,
        "sender_full_name": "eddyb",
        "timestamp": 1562828352
    },
    {
        "content": "<p>what you couldn't handle is the distinction between <code>if/else</code> and the entry vs backedge of a loop</p>",
        "id": 170607324,
        "sender_full_name": "eddyb",
        "timestamp": 1562828392
    },
    {
        "content": "<p>but even then, if your <code>merge(a, b)</code> is <code>if a? == b? { a } else { None }</code>... that's still order-independent</p>",
        "id": 170607428,
        "sender_full_name": "eddyb",
        "timestamp": 1562828472
    },
    {
        "content": "<p>The analysis  I have in mind doesn't assume anything about conditionals, so the <code>a? == b?</code> is confusing to me</p>",
        "id": 170607498,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay, so, full writes are SSA-like which is very good, and having multiple of them is always from a \"CFG merge\", so only partial writes can be order-dependent</p>",
        "id": 170607500,
        "sender_full_name": "eddyb",
        "timestamp": 1562828558
    },
    {
        "content": "<p>I meant for constant-folding: keep the value only if it's equal on all edges</p>",
        "id": 170607512,
        "sender_full_name": "eddyb",
        "timestamp": 1562828582
    },
    {
        "content": "<p>okay so if you were doing symbolic tracking of ADTs, or even using miri allocations, then my previous example with <code>a</code>, <code>b</code> and <code>y</code> flowing into <code>x</code> would be a problem</p>",
        "id": 170607595,
        "sender_full_name": "eddyb",
        "timestamp": 1562828651
    },
    {
        "content": "<p>pretty much because you don't have a <code>merge</code>, you have side-effects</p>",
        "id": 170607627,
        "sender_full_name": "eddyb",
        "timestamp": 1562828703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay... what else, how do you handle <code>&amp;mut x</code>?</p>",
        "id": 170607649,
        "sender_full_name": "eddyb",
        "timestamp": 1562828739
    },
    {
        "content": "<p>or borrows in general, I guess, not just mutable ones</p>",
        "id": 170607659,
        "sender_full_name": "eddyb",
        "timestamp": 1562828751
    },
    {
        "content": "<p>It's what you proposed on nagisa's PR</p>",
        "id": 170607704,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828767
    },
    {
        "content": "<p>(since <code>&amp;Cell&lt;T&gt;</code> could still mutate <code>T</code>)</p>",
        "id": 170607706,
        "sender_full_name": "eddyb",
        "timestamp": 1562828771
    },
    {
        "content": "<p>assume the worst, based on the type?</p>",
        "id": 170607717,
        "sender_full_name": "eddyb",
        "timestamp": 1562828786
    },
    {
        "content": "<p>do you track it in the chain though?</p>",
        "id": 170607725,
        "sender_full_name": "eddyb",
        "timestamp": 1562828802
    },
    {
        "content": "<p>I use <code>HaveBeenBorrowedLocals</code> to see if a pointer to <code>x</code> could possible exist at a given program point</p>",
        "id": 170607728,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828803
    },
    {
        "content": "<p>oh</p>",
        "id": 170607740,
        "sender_full_name": "eddyb",
        "timestamp": 1562828821
    },
    {
        "content": "<p>If so, I mark any indirect definitions as <em>possibly</em> writing to <code>x</code></p>",
        "id": 170607762,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828837
    },
    {
        "content": "<p>(Indirect definitions are <code>*p = ...</code>)</p>",
        "id": 170607770,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828848
    },
    {
        "content": "<p>that's not enough, and it could be wrong qualif-wise</p>",
        "id": 170607785,
        "sender_full_name": "eddyb",
        "timestamp": 1562828868
    },
    {
        "content": "<p>counterexample?</p>",
        "id": 170607833,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828886
    },
    {
        "content": "<p>function calls</p>",
        "id": 170607837,
        "sender_full_name": "eddyb",
        "timestamp": 1562828893
    },
    {
        "content": "<p>Those are handled</p>",
        "id": 170607843,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828899
    },
    {
        "content": "<p>so what do you do then?</p>",
        "id": 170607849,
        "sender_full_name": "eddyb",
        "timestamp": 1562828908
    },
    {
        "content": "<p>(one moment</p>",
        "id": 170607853,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828913
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/62547/files#diff-f7260434bc49a5d0402c7cf7f08ea77cR58\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/62547/files#diff-f7260434bc49a5d0402c7cf7f08ea77cR58\">https://github.com/rust-lang/rust/pull/62547/files#diff-f7260434bc49a5d0402c7cf7f08ea77cR58</a></p>",
        "id": 170607887,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828953
    },
    {
        "content": "<p>here</p>",
        "id": 170607892,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562828958
    },
    {
        "content": "<p>I'm scared of opening that :D</p>",
        "id": 170607899,
        "sender_full_name": "eddyb",
        "timestamp": 1562828970
    },
    {
        "content": "<p>I mean your can look at the domain</p>",
        "id": 170607980,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829007
    },
    {
        "content": "<p>?</p>",
        "id": 170607989,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829018
    },
    {
        "content": "<p>or go to <a href=\"https://github.com/rust-lang/rust/issues/62547\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/62547\">#62547</a></p>",
        "id": 170608002,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829036
    },
    {
        "content": "<p>I'm scared of looking at the PR <em>right</em> now</p>",
        "id": 170608005,
        "sender_full_name": "eddyb",
        "timestamp": 1562829041
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>        // We can&#39;t know (without MIR inlining or explicit annotation) whether a callee mutates\n        // data behind a pointer. If the address of one of our locals is observable, it may be the\n        // target of such a mutation. A type-based analysis (e.g. does this function take any type\n        // containing a mutable reference as a parameter?) is insufficient, since raw pointers can\n        // be laundered through any integral type.\n</pre></div>",
        "id": 170608011,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829053
    },
    {
        "content": "<p>So we treat all function calls as \"indirect definitions\"</p>",
        "id": 170608026,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829085
    },
    {
        "content": "<p>This is not precise, but it's not clear to me how one would do any better</p>",
        "id": 170608086,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829141
    },
    {
        "content": "<p>okay, yeah, that sounds fine (I already wrote a similar analysis last year. ugh I really need to get all of that merged)</p>",
        "id": 170608116,
        "sender_full_name": "eddyb",
        "timestamp": 1562829183
    },
    {
        "content": "<p>but anyway, from all of this what I gather is:<br>\n1. \"use-def\" confused the hell out of me, \"reaching writes\" makes a lot more sense<br>\n2. \"merge all writes\", in an order-independent way, is what makes this work, and it should be somehow put up front (maybe make it a literal <code>bool</code> that gets <code>|</code>'d by the framework?)</p>",
        "id": 170608144,
        "sender_full_name": "eddyb",
        "timestamp": 1562829233
    },
    {
        "content": "<p>\"use-def chain\" and \"reaching definitions\" are terms of art so I'm loathe to change them. If more people chime in I will. AFAICT I'm using them correctly.</p>",
        "id": 170608225,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829310
    },
    {
        "content": "<p>and qualify_consts should have the 2 type-based qualif's simply ignore the qualification if the type isn't even susceptible to it</p>",
        "id": 170608229,
        "sender_full_name": "eddyb",
        "timestamp": 1562829312
    },
    {
        "content": "<p>The \"def\" part is confusing though</p>",
        "id": 170608233,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829318
    },
    {
        "content": "<p>they are terms of art that apply much better in more SSA-like situations :P</p>",
        "id": 170608250,
        "sender_full_name": "eddyb",
        "timestamp": 1562829351
    },
    {
        "content": "<p>actually, hmm, for the 2 non-type-based qualifs (the promotable stuff), you want borrows to just set them</p>",
        "id": 170608297,
        "sender_full_name": "eddyb",
        "timestamp": 1562829378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> so maybe just treat non-frozen borrows as resetting to the \"worst case for that type\"?</p>",
        "id": 170608306,
        "sender_full_name": "eddyb",
        "timestamp": 1562829417
    },
    {
        "content": "<p>I agree you can bail out for <code>HasInteriorMut</code> and <code>NeedsDrop</code></p>",
        "id": 170608307,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829421
    },
    {
        "content": "<p>Well, why not wait until there's actually a write to the target of a pointer?</p>",
        "id": 170608330,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829463
    },
    {
        "content": "<p>which for the unpromotability qualifs, the worst case doesn't depend on the type and it's 1/<code>true</code></p>",
        "id": 170608331,
        "sender_full_name": "eddyb",
        "timestamp": 1562829465
    },
    {
        "content": "<p>tracking indirect writes is neat but IMO too expensive, and it's not like we promote anything you can borrow more than once anyway?</p>",
        "id": 170608389,
        "sender_full_name": "eddyb",
        "timestamp": 1562829500
    },
    {
        "content": "<p>(I'm still not 100% on how this extends to promotability, my mental model has been exclusively <code>HasInteriorMut</code> and <code>NeedsDrop</code>)</p>",
        "id": 170608396,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829525
    },
    {
        "content": "<p>like, we don't allow user variables, only temps, in the MIR of promoted expressions, so anything you could borrow yourself and mutate doesn't need to be allowed</p>",
        "id": 170608424,
        "sender_full_name": "eddyb",
        "timestamp": 1562829549
    },
    {
        "content": "<p>yeah for those two it's just easier to assume that they're type-based once they're borrowed</p>",
        "id": 170608448,
        "sender_full_name": "eddyb",
        "timestamp": 1562829588
    },
    {
        "content": "<p>this would be easier, IMO, if you weren't restricted by using the existing dataflow framework, for creating the chains (or \"sets\", really)</p>",
        "id": 170608532,
        "sender_full_name": "eddyb",
        "timestamp": 1562829660
    },
    {
        "content": "<p>since you could have richer enums describing the kind of write</p>",
        "id": 170608546,
        "sender_full_name": "eddyb",
        "timestamp": 1562829683
    },
    {
        "content": "<p>I think it is likely  to be more efficient, I think it would take more implementation work though.</p>",
        "id": 170608624,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829782
    },
    {
        "content": "<p>I did propose a custom dataflow framework at the top of this thread</p>",
        "id": 170608634,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829796
    },
    {
        "content": "<p>fair enough</p>",
        "id": 170608635,
        "sender_full_name": "eddyb",
        "timestamp": 1562829799
    },
    {
        "content": "<p>I'm a bit mad that we have to transfer information between locals. that's the only reason what I had in mind doesn't work :(</p>",
        "id": 170608651,
        "sender_full_name": "eddyb",
        "timestamp": 1562829828
    },
    {
        "content": "<blockquote>\n<p>I <em>never</em> intended for anyone to write a dataflow implementation themselves, I'm sorry if that was ever an interpretation of anything I said</p>\n</blockquote>\n<p>XD</p>",
        "id": 170608659,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562829841
    },
    {
        "content": "<p>oh well now I can pretend this took ages to happen because it's actually hard</p>",
        "id": 170608704,
        "sender_full_name": "eddyb",
        "timestamp": 1562829846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> maybe we should have a discussion with <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> and <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> and <span class=\"user-mention\" data-user-id=\"116266\">@Santiago Pastorino</span> to pick some terminology that we all agree on?</p>",
        "id": 170608755,
        "sender_full_name": "eddyb",
        "timestamp": 1562829912
    },
    {
        "content": "<p>I think \"reaching writes set\" is the most accurate</p>",
        "id": 170608767,
        "sender_full_name": "eddyb",
        "timestamp": 1562829930
    },
    {
        "content": "<p>and you could also use a different \"ever borrowed\" kill/gen dataflow (might already exist for generators)</p>",
        "id": 170608821,
        "sender_full_name": "eddyb",
        "timestamp": 1562829970
    },
    {
        "content": "<p>well, no, you need \"ever mutably borrowed\"</p>",
        "id": 170608846,
        "sender_full_name": "eddyb",
        "timestamp": 1562830019
    },
    {
        "content": "<p>Yes that would be nice. I'm fine with \"reaching writes set\", although I think the actual implementor of <code>BitDenotation</code> should be called <code>ReachingDefinitions</code>.</p>",
        "id": 170608867,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830042
    },
    {
        "content": "<p><code>ReachingDefs</code> is okay I guess</p>",
        "id": 170608881,
        "sender_full_name": "eddyb",
        "timestamp": 1562830060
    },
    {
        "content": "<p>As long as it's not doing anything special</p>",
        "id": 170608884,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830062
    },
    {
        "content": "<p>the \"ever mutably borrowed\" would be to gate whether you're assuming the worst or actually merging the writes set</p>",
        "id": 170608895,
        "sender_full_name": "eddyb",
        "timestamp": 1562830080
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> can we land a \"reaching defs\" that ignores indirect writes or borrows and has no infra for doing the \"merge RHSes of writes\" style of dataflow?</p>",
        "id": 170608970,
        "sender_full_name": "eddyb",
        "timestamp": 1562830127
    },
    {
        "content": "<p>How do you mean \"ignores writes\"?</p>",
        "id": 170608989,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830147
    },
    {
        "content": "<p>typo, sorry. anyway I think  such a PR would be easier to review</p>",
        "id": 170609007,
        "sender_full_name": "eddyb",
        "timestamp": 1562830164
    },
    {
        "content": "<p>oh and I keep forgetting, I should ping <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> to look at this stuff</p>",
        "id": 170609014,
        "sender_full_name": "eddyb",
        "timestamp": 1562830184
    },
    {
        "content": "<p>So the \"merge RHSes of writes\" is seperate from the dataflow pass</p>",
        "id": 170609127,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830292
    },
    {
        "content": "<p>in the current PR</p>",
        "id": 170609129,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830296
    },
    {
        "content": "<p>I could take out all handling of indirect writes/borrows  and only do dataflow on defs locals that are never borrowed</p>",
        "id": 170609186,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830330
    },
    {
        "content": "<p>but I don't know how much easier that would be to review.</p>",
        "id": 170609198,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830355
    },
    {
        "content": "<p>oh I guess you could use one bit for \"was borrowed\"</p>",
        "id": 170609203,
        "sender_full_name": "eddyb",
        "timestamp": 1562830361
    },
    {
        "content": "<p>That's already been implemented in  the<code>HaveBeenBorrowedLocals</code> dataflow analysis</p>",
        "id": 170609232,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830390
    },
    {
        "content": "<p>(which was meant for generators originally)</p>",
        "id": 170609239,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830400
    },
    {
        "content": "<p>and <code>&amp;mut x</code> would act as if it was a <code>x = unknown()</code> but not in the program</p>",
        "id": 170609246,
        "sender_full_name": "eddyb",
        "timestamp": 1562830408
    },
    {
        "content": "<p>well, in your case, frozen borrows are fine</p>",
        "id": 170609256,
        "sender_full_name": "eddyb",
        "timestamp": 1562830420
    },
    {
        "content": "<p>What if I have <code>let p = &amp;mut x; x = 2; *p = 4;</code></p>",
        "id": 170609318,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562830458
    },
    {
        "content": "<p>ah drat I see</p>",
        "id": 170609332,
        "sender_full_name": "eddyb",
        "timestamp": 1562830480
    },
    {
        "content": "<p>okay, fine</p>",
        "id": 170609355,
        "sender_full_name": "eddyb",
        "timestamp": 1562830503
    },
    {
        "content": "<p>I'm off to bed. If you like you can take a look at the reaching definitions analysis itself</p>",
        "id": 170610299,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562831491
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/62547/files#diff-f7260434bc49a5d0402c7cf7f08ea77c\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/62547/files#diff-f7260434bc49a5d0402c7cf7f08ea77c\">https://github.com/rust-lang/rust/pull/62547/files#diff-f7260434bc49a5d0402c7cf7f08ea77c</a></p>",
        "id": 170610300,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562831493
    },
    {
        "content": "<p>I think it's comprehensible (but then again I wrote it)</p>",
        "id": 170610370,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562831539
    },
    {
        "content": "<p>This is separate from the \"chain\" data structure which determines precisely which subset of writes are reachable for a use of a given local</p>",
        "id": 170610434,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562831598
    },
    {
        "content": "<p>the output of \"reaching definitions\" is all definitions of <strong>any</strong> local which reach a given statement</p>",
        "id": 170610779,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1562831905
    },
    {
        "content": "<p>I've rebased <a href=\"https://github.com/rust-lang/rust/issues/62547\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/62547\">#62547</a> with some fixes and additional documentation in the hopes of clearing up some of the confusion. I've also left some comments on github justifying the naming of <code>UseDefChain</code> and <code>ReachingDefinitions</code> and discussing how this could be used to implement const propagation.</p>",
        "id": 170854445,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1563148313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 170854449,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1563148321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Could I pick your brain for a little while about the current logic around const qualification?</p>",
        "id": 171013711,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1563301776
    },
    {
        "content": "<p>pinging <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 171095449,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1563382293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> this line in <code>const_qualify.rs</code> makes dataflow-based const qualification a bit harder, since it makes the <code>IsNotPromotable</code> pass dependent on <code>HasMutInterior</code>. Is there a better way to express this?</p>",
        "id": 171448696,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1563815362
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/4bc1ce7bdb7f5dc9ea07c0b630c087d8e11140e4/src/librustc_mir/transform/qualify_consts.rs#L768\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/4bc1ce7bdb7f5dc9ea07c0b630c087d8e11140e4/src/librustc_mir/transform/qualify_consts.rs#L768\">https://github.com/rust-lang/rust/blob/4bc1ce7bdb7f5dc9ea07c0b630c087d8e11140e4/src/librustc_mir/transform/qualify_consts.rs#L768</a></p>",
        "id": 171448705,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1563815370
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Is there someone who can help clarify the current logic in <code>qualify_consts.rs</code> for me?</p>",
        "id": 171769750,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564144639
    },
    {
        "content": "<p>I can help</p>",
        "id": 171783289,
        "sender_full_name": "oli",
        "timestamp": 1564154985
    },
    {
        "content": "<p>The comment in the link you posted suggests that the dependency exists just to reduce duplicate diagnostics. Maybe we can dedup another way</p>",
        "id": 171783604,
        "sender_full_name": "oli",
        "timestamp": 1564155235
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>! So the basic idea is to replace <code>Qualifs::in_local</code>, which is currently only kept up to date within a block, with a flow-sensitive version derived from dataflow analysis (either reaching definitions based or using a not-yet-implemented custom dataflow analysis). I'm a bit confused because \"const qualification\" is also run in normal functions to mark candidates for promotion, but I can't really imagine what it means to track promotability across basic blocks.</p>",
        "id": 171851398,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564244990
    },
    {
        "content": "<p>we only track promotability across asserts and uncoditional jump I believe</p>",
        "id": 171851503,
        "sender_full_name": "oli",
        "timestamp": 1564245144
    },
    {
        "content": "<p>we won't ever expand that</p>",
        "id": 171851505,
        "sender_full_name": "oli",
        "timestamp": 1564245151
    },
    {
        "content": "<p>I think I'm just trying to clarify what exactly the semantics are around <code>Qualifs[Is{Implicitly,}Promotable]</code> in this particular pass. If we have <code>a = if x { b } else { c }</code> where both <code>b</code> and <code>c</code> are promotable, we could never really promote <code>a</code> right?</p>",
        "id": 171851508,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245161
    },
    {
        "content": "<p>no, not ever</p>",
        "id": 171851512,
        "sender_full_name": "oli",
        "timestamp": 1564245176
    },
    {
        "content": "<p>WIthout doing const-prop/dead-code elimination first (but that's a ways off)</p>",
        "id": 171851518,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245189
    },
    {
        "content": "<p>may not even promote <code>b</code> or <code>c</code> if they depend on values created before the <code>if</code></p>",
        "id": 171851521,
        "sender_full_name": "oli",
        "timestamp": 1564245195
    },
    {
        "content": "<p>const prop isn't happening before promotion</p>",
        "id": 171851522,
        "sender_full_name": "oli",
        "timestamp": 1564245216
    },
    {
        "content": "<p>promotion needs to happen in a guaranteed manner</p>",
        "id": 171851523,
        "sender_full_name": "oli",
        "timestamp": 1564245223
    },
    {
        "content": "<p>const prop is opportunistic</p>",
        "id": 171851526,
        "sender_full_name": "oli",
        "timestamp": 1564245232
    },
    {
        "content": "<p>So does it even make sense to track<code>IsPromotable</code> in a flow-sensitive manner?</p>",
        "id": 171851567,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245253
    },
    {
        "content": "<p>I think we just need to do this for <code>HasMutInterior</code> and <code>NeedsDrop</code></p>",
        "id": 171851591,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245321
    },
    {
        "content": "<p>I thought it was necessary for const eval?</p>",
        "id": 171851592,
        "sender_full_name": "oli",
        "timestamp": 1564245322
    },
    {
        "content": "<p>oh right</p>",
        "id": 171851593,
        "sender_full_name": "oli",
        "timestamp": 1564245325
    },
    {
        "content": "<p>those are enough</p>",
        "id": 171851594,
        "sender_full_name": "oli",
        "timestamp": 1564245328
    },
    {
        "content": "<p>Okay good! I think that simplifies things for me</p>",
        "id": 171851650,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245396
    },
    {
        "content": "<p>I'm going to try and refactor <code>qualif_consts.rs</code> to use a flow-sensitive backend to determine <code>HasMutInterior</code> and <code>NeedsDrop</code> for each local at each program point.</p>",
        "id": 171851703,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245483
    },
    {
        "content": "<p>And then try to get a proof of concept going that uses <a href=\"https://github.com/rust-lang/rust/issues/62547\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/62547\">#62547</a> to build that flow-sensitive backend</p>",
        "id": 171851725,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245569
    },
    {
        "content": "<p>A few more clarifications around promotion; I believe the main use-case is R-value static promotion like <code>let x = &amp;5</code>. We only need to promote things when their reference is taken. Otherwise things are just handled by const-eval?</p>",
        "id": 171851934,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564245920
    },
    {
        "content": "<p>Yes</p>",
        "id": 171856135,
        "sender_full_name": "oli",
        "timestamp": 1564253608
    },
    {
        "content": "<p>Const prop to be exact</p>",
        "id": 171856136,
        "sender_full_name": "oli",
        "timestamp": 1564253619
    },
    {
        "content": "<p>Well, also there's repeat expression initializers</p>",
        "id": 171856177,
        "sender_full_name": "oli",
        "timestamp": 1564253658
    },
    {
        "content": "<p>And the hack for SIMD</p>",
        "id": 171856180,
        "sender_full_name": "oli",
        "timestamp": 1564253669
    },
    {
        "content": "<p>Where function arguments are promoted</p>",
        "id": 171856193,
        "sender_full_name": "oli",
        "timestamp": 1564253684
    },
    {
        "content": "<p>Okay. I just saw these in <code>Candidate</code>  enum over in <code>promote_consts.rs</code>.</p>",
        "id": 171858656,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564258733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> Just a heads up. I'm going to start on this this evening, but I will be pretty slow. I've tried to get started a few times before, but ground to a halt. I think a lack of understanding around promotion as well as the cyclomatic complexity of some functions were the problem. Hopefully the first one will be less of a problem now :)</p>",
        "id": 171955225,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1564413854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> Hey, how's progress out of curiosity?</p>",
        "id": 172930985,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1565454658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124069\">@Alexander Regueiro</span> Short answer: stalled.</p>",
        "id": 172956416,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124069\">@Alexander Regueiro</span> Long answer: I'm doubtful that I'm able to move this forward since whenever I've tried to extend the current qualification logic to more complex CFGs, it requires a pretty large re-architecting. This makes preserving the existing behavior of the const qualifier difficult, and makes me worry that my work won't get merged. I can't help but feel that <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>  has a much simpler solution in mind that I am unable to see, which is a bit discouraging.</p>",
        "id": 172956604,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505431
    },
    {
        "content": "<p>ugh I fell behind this again :(</p>",
        "id": 172956608,
        "sender_full_name": "eddyb",
        "timestamp": 1565505465
    },
    {
        "content": "<p>If you're interested in working on this, either by yourself or in collaboration, let me know and we can have a synchronous discussion.</p>",
        "id": 172956609,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505466
    },
    {
        "content": "<p>(also, last week I was away on vacation)</p>",
        "id": 172956615,
        "sender_full_name": "eddyb",
        "timestamp": 1565505482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> so the problem you hit is that there are still interactions between the different bits, right?</p>",
        "id": 172956662,
        "sender_full_name": "eddyb",
        "timestamp": 1565505503
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> No problem.</p>",
        "id": 172956663,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505512
    },
    {
        "content": "<p>is it that silly thing that has a comment on it saying it's to improve error quality?</p>",
        "id": 172956665,
        "sender_full_name": "eddyb",
        "timestamp": 1565505517
    },
    {
        "content": "<p>we could try turning it off in the current code and see what happens</p>",
        "id": 172956669,
        "sender_full_name": "eddyb",
        "timestamp": 1565505529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Yes, that's the only explicit dependency</p>",
        "id": 172956670,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505533
    },
    {
        "content": "<p>maybe we can massage the diagnostics so they make sense</p>",
        "id": 172956671,
        "sender_full_name": "eddyb",
        "timestamp": 1565505537
    },
    {
        "content": "<p>actually, hmm</p>",
        "id": 172956681,
        "sender_full_name": "eddyb",
        "timestamp": 1565505590
    },
    {
        "content": "<p>I think that if we just clear one flag and not set the other, it might cause bugs</p>",
        "id": 172956725,
        "sender_full_name": "eddyb",
        "timestamp": 1565505613
    },
    {
        "content": "<p>e.g. <code>&amp;&amp;Cell::new(0)</code> might try to promote the outer reference even if the inner one isn't allowed to be promoted</p>",
        "id": 172956742,
        "sender_full_name": "eddyb",
        "timestamp": 1565505694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay, new idea: you know how the actual promotion works? the part that mutates?</p>",
        "id": 172956783,
        "sender_full_name": "eddyb",
        "timestamp": 1565505770
    },
    {
        "content": "<p>mutates the MIR? In <code>promote_consts.rs</code>?</p>",
        "id": 172956794,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505793
    },
    {
        "content": "<p>it traverses all the intermediary Rvalue's by using the \"promotability state\" information to know where the <em>only</em> assignment to a local is</p>",
        "id": 172956797,
        "sender_full_name": "eddyb",
        "timestamp": 1565505802
    },
    {
        "content": "<p>so basically it's like an SSA tree</p>",
        "id": 172956798,
        "sender_full_name": "eddyb",
        "timestamp": 1565505811
    },
    {
        "content": "<p>we could do that same traversal and check that every borrow is actually promotable</p>",
        "id": 172956845,
        "sender_full_name": "eddyb",
        "timestamp": 1565505844
    },
    {
        "content": "<p><em>after</em> having computed everything locally</p>",
        "id": 172956848,
        "sender_full_name": "eddyb",
        "timestamp": 1565505857
    },
    {
        "content": "<p>so <code>&amp;expr</code> would always have no bits set</p>",
        "id": 172956851,
        "sender_full_name": "eddyb",
        "timestamp": 1565505870
    },
    {
        "content": "<p>My understanding was that only temporaries which are assigned to exactly once are considered for promotion</p>",
        "id": 172956854,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505882
    },
    {
        "content": "<p>This is what you're saying?</p>",
        "id": 172956859,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505897
    },
    {
        "content": "<p>yeah, but you have to keep in mind that you can have e.g. <code>&amp;(1 + 2, false)</code> which is several Rvalue's</p>",
        "id": 172956865,
        "sender_full_name": "eddyb",
        "timestamp": 1565505905
    },
    {
        "content": "<p>so they form a tree, similar to the AST for the expression</p>",
        "id": 172956868,
        "sender_full_name": "eddyb",
        "timestamp": 1565505922
    },
    {
        "content": "<p>That would be translated to <code>_1 = 1+2; _2 = false; _3 = (_1, _2); _4 = &amp;_3</code>?</p>",
        "id": 172956874,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505950
    },
    {
        "content": "<p>something like that yeah</p>",
        "id": 172956875,
        "sender_full_name": "eddyb",
        "timestamp": 1565505959
    },
    {
        "content": "<p>give or take a panic on arithmetic overflow?</p>",
        "id": 172956916,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565505974
    },
    {
        "content": "<p>yupp</p>",
        "id": 172956919,
        "sender_full_name": "eddyb",
        "timestamp": 1565505979
    },
    {
        "content": "<p>once we compute the bits for what locals <em>contain</em> then we can do a tentative promotion (maybe even in the mutating code, just make it failible? but that might be too hard)</p>",
        "id": 172956924,
        "sender_full_name": "eddyb",
        "timestamp": 1565506007
    },
    {
        "content": "<p>and bail out if we find anything fishy</p>",
        "id": 172956926,
        "sender_full_name": "eddyb",
        "timestamp": 1565506022
    },
    {
        "content": "<p>so &amp;&amp;Cell::new(0) would not mind the outer reference <em>by itself</em> but also look inside, and in the inner reference, it would find Cell::new(0) with interior mutability</p>",
        "id": 172956935,
        "sender_full_name": "eddyb",
        "timestamp": 1565506061
    },
    {
        "content": "<p>this could mean we might be able to even remove some of the uses of the qualification bits</p>",
        "id": 172956940,
        "sender_full_name": "eddyb",
        "timestamp": 1565506076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> wow I feel so dumb</p>",
        "id": 172956981,
        "sender_full_name": "eddyb",
        "timestamp": 1565506099
    },
    {
        "content": "<p>What does the MIR look like for <code>&amp;&amp;Cell::new(0)</code>? I'm not quite sure what problem you're solving here.</p>",
        "id": 172956984,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506114
    },
    {
        "content": "<p>yeah we only need to support the promotion usecases for \"SSA tree equivalent to linear control-flow\"</p>",
        "id": 172956987,
        "sender_full_name": "eddyb",
        "timestamp": 1565506123
    },
    {
        "content": "<p>Right, we don't need to do dataflow for promotion.</p>",
        "id": 172956992,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506142
    },
    {
        "content": "<p>the problem is that right now the inner &amp;Cell::new(0) is marked as Unpromotable</p>",
        "id": 172956994,
        "sender_full_name": "eddyb",
        "timestamp": 1565506143
    },
    {
        "content": "<p><em>because</em> the temp it borrows, holding a Cell&lt;i32&gt;, is InteriorMut</p>",
        "id": 172957000,
        "sender_full_name": "eddyb",
        "timestamp": 1565506165
    },
    {
        "content": "<p>and that's the dependency between two qualif bits that you hit</p>",
        "id": 172957004,
        "sender_full_name": "eddyb",
        "timestamp": 1565506181
    },
    {
        "content": "<p>Since we have an additional rule that \"promotable temps can only be assigned to exactly once\"</p>",
        "id": 172957005,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506182
    },
    {
        "content": "<p>wait so what do we need dataflow for? the interiormut/needsdrop?</p>",
        "id": 172957051,
        "sender_full_name": "eddyb",
        "timestamp": 1565506214
    },
    {
        "content": "<p>Yes. Exactly those two qualifs I believe.</p>",
        "id": 172957054,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506231
    },
    {
        "content": "<p>are you interested in changing the code on master to rely on the \"SSA-like tree\" for promotion checking? assuming we never write the qualifs again after initialization for promotable temps, we should already be able to use local_qualifs to do this second pass</p>",
        "id": 172957109,
        "sender_full_name": "eddyb",
        "timestamp": 1565506331
    },
    {
        "content": "<p>Okay, so this is the genesis behind the current code clearing <code>HasMutInterior</code> and replacing it with <code>IsNotPromotable</code>.</p>",
        "id": 172957112,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506348
    },
    {
        "content": "<p>I could also look into it since I have a bit more free time now (long story)</p>",
        "id": 172957113,
        "sender_full_name": "eddyb",
        "timestamp": 1565506351
    },
    {
        "content": "<p>how did I miss this lmao</p>",
        "id": 172957115,
        "sender_full_name": "eddyb",
        "timestamp": 1565506358
    },
    {
        "content": "<p>on assignment</p>",
        "id": 172957120,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506370
    },
    {
        "content": "<p>yeah that's done so anything containing the unpromotable reference isn't accidentally considered promotable itself</p>",
        "id": 172957131,
        "sender_full_name": "eddyb",
        "timestamp": 1565506407
    },
    {
        "content": "<p>for a second I thought you could just keep HasMutInterior but that's a really bad idea</p>",
        "id": 172957132,
        "sender_full_name": "eddyb",
        "timestamp": 1565506419
    },
    {
        "content": "<p>because things will clear it based on type</p>",
        "id": 172957134,
        "sender_full_name": "eddyb",
        "timestamp": 1565506428
    },
    {
        "content": "<p>Regarding your \"SSA-like tree\" framing, how is that different from the current code?</p>",
        "id": 172957191,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506518
    },
    {
        "content": "<p>It currently relies on a linear CFG because one always exists in <code>const fn</code>s since jumps are disallowed, and it can assume that promotable temps exist in a subset of the CFG which is linear because promotable temps can only be assigned to once in the <code>mir::Body</code></p>",
        "id": 172957247,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506613
    },
    {
        "content": "<p>what I mean is not relying on the bits to be propagated correctly</p>",
        "id": 172957300,
        "sender_full_name": "eddyb",
        "timestamp": 1565506733
    },
    {
        "content": "<p>Let me know how I can clarify that. (That sentence confuses me and I wrote it)</p>",
        "id": 172957301,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506735
    },
    {
        "content": "<p>hmm, actually...</p>",
        "id": 172957307,
        "sender_full_name": "eddyb",
        "timestamp": 1565506750
    },
    {
        "content": "<p>if we could somehow avoid code duplication (by making the step-wise stuff, like the current Qualif trait implementors, general enough)</p>",
        "id": 172957311,
        "sender_full_name": "eddyb",
        "timestamp": 1565506786
    },
    {
        "content": "<p>we might be able to just write a promotion-checking pass with no dataflow</p>",
        "id": 172957313,
        "sender_full_name": "eddyb",
        "timestamp": 1565506801
    },
    {
        "content": "<p>more like your def-use idea, but simpler because no branching</p>",
        "id": 172957358,
        "sender_full_name": "eddyb",
        "timestamp": 1565506825
    },
    {
        "content": "<p>and then we can figure out how to implement const-checking with the same primitives</p>",
        "id": 172957364,
        "sender_full_name": "eddyb",
        "timestamp": 1565506858
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> might like this direction?</p>",
        "id": 172957378,
        "sender_full_name": "eddyb",
        "timestamp": 1565506902
    },
    {
        "content": "<p>right now the code is a mess because it sort of does two (quite related) things at the same time</p>",
        "id": 172957415,
        "sender_full_name": "eddyb",
        "timestamp": 1565506923
    },
    {
        "content": "<p>the dataflow concerns are enough for me to want to split it up if possible</p>",
        "id": 172957420,
        "sender_full_name": "eddyb",
        "timestamp": 1565506946
    },
    {
        "content": "<blockquote>\n<p>right now the code is a mess because it sort of does two (quite related) things at the same time</p>\n</blockquote>\n<p>This has been a big struggle for me :)</p>",
        "id": 172957421,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565506955
    },
    {
        "content": "<p>I'm really sorry Q_Q</p>",
        "id": 172957424,
        "sender_full_name": "eddyb",
        "timestamp": 1565506964
    },
    {
        "content": "<p>Yes, my original thought was that we want a linear pass which does promotion and a dataflow-based pass which checks for <code>HasMutInterior</code> and <code>NeedsDrop</code></p>",
        "id": 172957437,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507029
    },
    {
        "content": "<p>yeah, it's just that the linear pass can be nicer because it can look at the \"SSA-like trees\" instead of being stateful</p>",
        "id": 172957479,
        "sender_full_name": "eddyb",
        "timestamp": 1565507058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> I have... an evil idea...</p>",
        "id": 172957491,
        "sender_full_name": "eddyb",
        "timestamp": 1565507115
    },
    {
        "content": "<p>that I should've had ages ago :(</p>",
        "id": 172957493,
        "sender_full_name": "eddyb",
        "timestamp": 1565507120
    },
    {
        "content": "<p>but there's a line in the current code which replaces <code>HasMutInterior</code> with <code>IsNotPromotable</code> when an assignment like <code>_1 = &amp;_2</code> occurs</p>",
        "id": 172957494,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507131
    },
    {
        "content": "<p>we can do conservative approximations</p>",
        "id": 172957495,
        "sender_full_name": "eddyb",
        "timestamp": 1565507132
    },
    {
        "content": "<p>So the two seem linked in some way that I still don't fully understand</p>",
        "id": 172957500,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507153
    },
    {
        "content": "<blockquote>\n<p>we can do conservative approximations</p>\n</blockquote>\n<p>?</p>",
        "id": 172957542,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507167
    },
    {
        "content": "<p>so, that line is irrelevant for const-checking: an error would've always been emitted for that assignment, so it doesn't matter what you do as long as you don't cause more errors</p>",
        "id": 172957544,
        "sender_full_name": "eddyb",
        "timestamp": 1565507175
    },
    {
        "content": "<blockquote>\n<p>so, that line is irrelevant for const-checking: an error would've always been emitted for that assignment, so it doesn't matter what you do as long as you don't cause more errors</p>\n</blockquote>\n<p>So it really is just for diagnostics (as the comment suggests)</p>",
        "id": 172957548,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507197
    },
    {
        "content": "<p>so ideally you would just turn off the HasInteriorMut flag (&amp;T is always Freeze anyway, regardless of &amp;)</p>",
        "id": 172957549,
        "sender_full_name": "eddyb",
        "timestamp": 1565507202
    },
    {
        "content": "<p>but for promotion, you do need to keep track that you have an unpromotable reference so you don't promote something larger that contains it</p>",
        "id": 172957555,
        "sender_full_name": "eddyb",
        "timestamp": 1565507231
    },
    {
        "content": "<p>because e.g. &amp;&amp;0 is promoted as &amp;'static &amp;'static 0, at the outermost reference (the inner one isn't promoted separately)</p>",
        "id": 172957558,
        "sender_full_name": "eddyb",
        "timestamp": 1565507256
    },
    {
        "content": "<p>anyway, the conservative approx: we don't care about the order and just gather dependencies between locals, i.e. what <em>may</em> flow into what (note that this could be a cyclic graph because of loops)</p>",
        "id": 172957609,
        "sender_full_name": "eddyb",
        "timestamp": 1565507375
    },
    {
        "content": "<p>and then we saturate it to fixpoint</p>",
        "id": 172957654,
        "sender_full_name": "eddyb",
        "timestamp": 1565507410
    },
    {
        "content": "<p>we only need to specially handle one thing, which is initialization state</p>",
        "id": 172957657,
        "sender_full_name": "eddyb",
        "timestamp": 1565507439
    },
    {
        "content": "<p>if a local is <em>definitely moved out of fully</em> at a drop, then what the local contained in it when it was initialized doesn't matter</p>",
        "id": 172957664,
        "sender_full_name": "eddyb",
        "timestamp": 1565507467
    },
    {
        "content": "<p>but that can be done with an existing dataflow analysis pass</p>",
        "id": 172957668,
        "sender_full_name": "eddyb",
        "timestamp": 1565507481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> gah I wish I wasn't so stubborn to come up with this before you spent time working on a framework Q_Q</p>",
        "id": 172957670,
        "sender_full_name": "eddyb",
        "timestamp": 1565507511
    },
    {
        "content": "<p>or, wait, how close is this to what you have?</p>",
        "id": 172957711,
        "sender_full_name": "eddyb",
        "timestamp": 1565507528
    },
    {
        "content": "<blockquote>\n<p>anyway, the conservative approx: we don't care about the order and just gather dependencies between locals, i.e. what <em>may</em> flow into what (note that this could be a cyclic graph because of loops)</p>\n</blockquote>\n<p>This part seems pretty simlar?</p>",
        "id": 172957715,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507552
    },
    {
        "content": "<p>because if I did another dumb thing and described the code you've already written,,, then we'll just use that</p>",
        "id": 172957716,
        "sender_full_name": "eddyb",
        "timestamp": 1565507556
    },
    {
        "content": "<p>I guess I'mm still waking up here</p>",
        "id": 172957717,
        "sender_full_name": "eddyb",
        "timestamp": 1565507564
    },
    {
        "content": "<blockquote>\n<p>I guess I'mm still waking up here</p>\n</blockquote>\n<p>I'm falling asleep here, so at least it's fair XD</p>",
        "id": 172957725,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507607
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie</span> gah I wish I wasn't so stubborn to come up with this before you spent time working on a framework Q_Q</p>\n</blockquote>\n<p>I'm only interested in helping to get <a href=\"https://github.com/rust-lang/rust/issues/49146\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/49146\">#49146</a> (and friends) implemented</p>",
        "id": 172957784,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507756
    },
    {
        "content": "<p>okay, so we have 2 tasks we could do on master:</p>\n<p>1. remove the Operand::Move side-effect of clearning the NeedsDrop qualif bit, and use a dataflow initialization analysis to know when a drop is dead<br>\n2. compute promotion candidates in promote_consts instead of qualify_consts (i.e. all of them, without checking), and validate them by traversing the tree of temps</p>",
        "id": 172957827,
        "sender_full_name": "eddyb",
        "timestamp": 1565507772
    },
    {
        "content": "<p>and then I think we can \"just\" land your PR?!</p>",
        "id": 172957829,
        "sender_full_name": "eddyb",
        "timestamp": 1565507788
    },
    {
        "content": "<p>do you think you'd want to do one of these or should I take a stab at it?</p>",
        "id": 172957832,
        "sender_full_name": "eddyb",
        "timestamp": 1565507808
    },
    {
        "content": "<p>You should take a stab at it. I think both steps are productive. However, I think we should think about using a custom dataflow analysis and not my PR.</p>",
        "id": 172957935,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507896
    },
    {
        "content": "<p>if your PR is order-agnostic then it's not that different from my conservative idea</p>",
        "id": 172957939,
        "sender_full_name": "eddyb",
        "timestamp": 1565507921
    },
    {
        "content": "<p>In order to use it i was going to have to change each <code>in_x</code> method from <code>Qualif</code> to return an enum like</p>",
        "id": 172957954,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507958
    },
    {
        "content": "<p>like, you still need 1. with your PR, right? otherwise, you couldn't deal with the distinction between moved-out locals and still-initialized, drop-wise</p>",
        "id": 172957959,
        "sender_full_name": "eddyb",
        "timestamp": 1565507960
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>Definitely\nConditionally(Vec&lt;Local&gt;)\nNot\n</pre></div>",
        "id": 172957963,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565507988
    },
    {
        "content": "<p>yeah that is reasonable</p>",
        "id": 172957966,
        "sender_full_name": "eddyb",
        "timestamp": 1565507997
    },
    {
        "content": "<p>I think we can make it more efficient, but that is sort of the thing we need to do in order to be generic enough to handle this</p>",
        "id": 172958010,
        "sender_full_name": "eddyb",
        "timestamp": 1565508027
    },
    {
        "content": "<p>Okay, in that case doing it on top of my PR would be fine. It just seemed really heavy on allocations.</p>",
        "id": 172958011,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565508044
    },
    {
        "content": "<p>ahh, see</p>",
        "id": 172958013,
        "sender_full_name": "eddyb",
        "timestamp": 1565508053
    },
    {
        "content": "<p>that's where you have to get clever :P</p>",
        "id": 172958015,
        "sender_full_name": "eddyb",
        "timestamp": 1565508059
    },
    {
        "content": "<p>And my PR is already really heavy on allocations</p>",
        "id": 172958020,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565508069
    },
    {
        "content": "<p>lemme show you an example of avoiding allocations</p>",
        "id": 172958022,
        "sender_full_name": "eddyb",
        "timestamp": 1565508072
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/mir/mod.rs#L1235\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc/mir/mod.rs#L1235\">https://github.com/rust-lang/rust/blob/master/src/librustc/mir/mod.rs#L1235</a></p>",
        "id": 172958064,
        "sender_full_name": "eddyb",
        "timestamp": 1565508127
    },
    {
        "content": "<p>wow this doesn't even use Cow anymore</p>",
        "id": 172958065,
        "sender_full_name": "eddyb",
        "timestamp": 1565508132
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> frankly, once we get rid of the two promotability qualifs, things are going to be muuuch better</p>",
        "id": 172958074,
        "sender_full_name": "eddyb",
        "timestamp": 1565508194
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie</span> frankly, once we get rid of the two promotability qualifs, things are going to be muuuch better</p>\n</blockquote>\n<p>Agreed</p>",
        "id": 172958076,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565508220
    },
    {
        "content": "<p>Needs more existential types</p>",
        "id": 172958078,
        "sender_full_name": "oli",
        "timestamp": 1565508224
    },
    {
        "content": "<p>because the other two are about value properties, <em>not</em> how you got a value. how many ways do you know to get one value from another?</p>",
        "id": 172958084,
        "sender_full_name": "eddyb",
        "timestamp": 1565508233
    },
    {
        "content": "<p>projection and construction</p>",
        "id": 172958124,
        "sender_full_name": "eddyb",
        "timestamp": 1565508246
    },
    {
        "content": "<p>that's... it</p>",
        "id": 172958127,
        "sender_full_name": "eddyb",
        "timestamp": 1565508258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> so what's going to be left is, uhh, a Ty -&gt; bool and AggregateKind -&gt; bool</p>",
        "id": 172958141,
        "sender_full_name": "eddyb",
        "timestamp": 1565508339
    },
    {
        "content": "<p>that's it I'm pretty sure</p>",
        "id": 172958142,
        "sender_full_name": "eddyb",
        "timestamp": 1565508345
    },
    {
        "content": "<p>types are an upper bound, aggregates are a lower bound, everything else is the same between !Freeze and NeedsDrop</p>",
        "id": 172958193,
        "sender_full_name": "eddyb",
        "timestamp": 1565508428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> we could probably even dedup the \"promotable locals\" by basically using your \"where is this written to\" information and limiting to one full initialization</p>",
        "id": 172958358,
        "sender_full_name": "eddyb",
        "timestamp": 1565508800
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I think I need to go to bed now, but hopefully you could try implementing your ideas and see what problems arise. When I tried implementing qualification on top of my PR I had to make<code>Qualif::in_local</code> recursive (memoization was necessary to keep this reasonably efficient). Perhaps your ideas are simpler and don't require as much storage. I think maybe I do better when looking at code than talking in the abstract (the exception being the current implementation of <code>qualify_consts</code> I guess :)</p>",
        "id": 172958404,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565508880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> status: making sure that commenting this out results in a test failure <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L771\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L771\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L771</a></p>",
        "id": 172958420,
        "sender_full_name": "eddyb",
        "timestamp": 1565508935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Yes, one nice side-effect of the use-def pass is you can answer queries like \"give me all the temporaries which have exactly one definition\"</p>",
        "id": 172958473,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509030
    },
    {
        "content": "<p>wait, \"def-use\"... but, we don't care about the uses :P</p>",
        "id": 172958586,
        "sender_full_name": "eddyb",
        "timestamp": 1565509284
    },
    {
        "content": "<p>Well yes, basically anything that enumerates \"def\"s can give you that (for some definition of \"def\")</p>",
        "id": 172958641,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509396
    },
    {
        "content": "<p>can we just call it \"find_accesses\"? or \"accesses\"?</p>",
        "id": 172958646,
        "sender_full_name": "eddyb",
        "timestamp": 1565509422
    },
    {
        "content": "<p>or \"find_writes\" idk</p>",
        "id": 172958649,
        "sender_full_name": "eddyb",
        "timestamp": 1565509430
    },
    {
        "content": "<p>\"find_writes\" is fine with me.</p>",
        "id": 172958692,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509470
    },
    {
        "content": "<p>(\"access\" would include both reads and writes, not sure if that's what you're going for)</p>",
        "id": 172958698,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509514
    },
    {
        "content": "<p>Totally unrelated, I have a branch which tried to split the propagation of qualifs between locals from the use of those qualifs into separate passes</p>",
        "id": 172958744,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509585
    },
    {
        "content": "<p><a href=\"https://github.com/ecstatic-morse/rust/tree/qualifs\" target=\"_blank\" title=\"https://github.com/ecstatic-morse/rust/tree/qualifs\">https://github.com/ecstatic-morse/rust/tree/qualifs</a></p>",
        "id": 172958747,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509604
    },
    {
        "content": "<p>If you find yourself doing something similar, maybe it would be useful to look at?</p>",
        "id": 172958755,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509639
    },
    {
        "content": "<p>thanks!</p>",
        "id": 172958756,
        "sender_full_name": "eddyb",
        "timestamp": 1565509652
    },
    {
        "content": "<p>The end goal was to replace <code>QualifsPerLocal</code> with something based on dataflow (at least for <code>HasMutInterior</code> and <code>NeedsDrop</code>)</p>",
        "id": 172958759,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509677
    },
    {
        "content": "<p>This was the least intrusive approach I could see</p>",
        "id": 172958799,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1565509702
    },
    {
        "content": "<blockquote>\n<p>error: internal compiler error: src/librustc_mir/interpret/intern.rs:183: const qualif failed to prevent mutable references</p>\n</blockquote>",
        "id": 172958801,
        "sender_full_name": "eddyb",
        "timestamp": 1565509703
    },
    {
        "content": "<p>I guess that's my confirmation and also assurance that even if we screw up, miri will catch us</p>",
        "id": 172958804,
        "sender_full_name": "eddyb",
        "timestamp": 1565509728
    },
    {
        "content": "<blockquote>\n<p>I guess that's my confirmation and also assurance that even if we screw up, miri will catch us</p>\n</blockquote>\n<p>well, sometimes. we started building that safety net with <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> 's refactoring of interning.</p>",
        "id": 172960928,
        "sender_full_name": "RalfJ",
        "timestamp": 1565514051
    },
    {
        "content": "<p>I am not sure yet if we catch <em>all</em> errors. but that is the goal.</p>",
        "id": 172960934,
        "sender_full_name": "RalfJ",
        "timestamp": 1565514064
    },
    {
        "content": "<p>this goes hand-in-hand with documenting in <a href=\"https://github.com/rust-rfcs/const-eval\" target=\"_blank\" title=\"https://github.com/rust-rfcs/const-eval\">https://github.com/rust-rfcs/const-eval</a> what exactly <em>needs</em> to be checked</p>",
        "id": 172960937,
        "sender_full_name": "RalfJ",
        "timestamp": 1565514087
    },
    {
        "content": "<p>help with that would be much appreciated, as UCG is taking up basically all of my Rust time these days</p>",
        "id": 172960940,
        "sender_full_name": "RalfJ",
        "timestamp": 1565514106
    },
    {
        "content": "<p>and please report a bug if you find something that miri does not catch :D</p>",
        "id": 172960988,
        "sender_full_name": "RalfJ",
        "timestamp": 1565514170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> I see. Thanks. Maybe worth another chat with him in that case... otherwise, a rearchitecting isn't necessarily a terrible thing.</p>",
        "id": 172973302,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1565538307
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie</span> I see. Thanks. Maybe worth another chat with him in that case... otherwise, a rearchitecting isn't necessarily a terrible thing.</p>\n</blockquote>\n<p>Oh gosh... I see I missed a long conversation between the two of you before I even replied hah. Good to see anyway.</p>",
        "id": 172977786,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1565546744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> feel free to ping me daily or so - I haven't gotten to it because I decided to look into fixing miri's substs situation</p>",
        "id": 173033828,
        "sender_full_name": "eddyb",
        "timestamp": 1565624014
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> one down! <a href=\"https://github.com/rust-lang/rust/pull/63518\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/63518\">https://github.com/rust-lang/rust/pull/63518</a></p>",
        "id": 173108408,
        "sender_full_name": "eddyb",
        "timestamp": 1565699406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> on no :( <a href=\"https://github.com/rust-lang/rust/pull/63518#issuecomment-521117822\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/63518#issuecomment-521117822\">https://github.com/rust-lang/rust/pull/63518#issuecomment-521117822</a></p>",
        "id": 173178360,
        "sender_full_name": "eddyb",
        "timestamp": 1565763859
    },
    {
        "content": "<p>Huh, idk what change caused this to become legal</p>",
        "id": 173179177,
        "sender_full_name": "oli",
        "timestamp": 1565765062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> it was always legal, I'm just dumb</p>",
        "id": 173179185,
        "sender_full_name": "eddyb",
        "timestamp": 1565765087
    },
    {
        "content": "<p>moving out of a variable clears its NeedsDrop</p>",
        "id": 173179195,
        "sender_full_name": "eddyb",
        "timestamp": 1565765101
    },
    {
        "content": "<p>and what's allowed on beta/nightly is reassigning locals</p>",
        "id": 173179268,
        "sender_full_name": "eddyb",
        "timestamp": 1565765170
    },
    {
        "content": "<p>Ah. Yea I remember a change there</p>",
        "id": 173179288,
        "sender_full_name": "oli",
        "timestamp": 1565765220
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> I started on the second thing, I'm thinking I should do a crater run that ensures both strategies produce the same results</p>",
        "id": 173188724,
        "sender_full_name": "eddyb",
        "timestamp": 1565775780
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Sorry, I wasn't able to be at a computer for most of last week. I've been able to work on the refactor this weekend though.</p>",
        "id": 173507207,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566172377
    },
    {
        "content": "<p>I'll try to get my branch to a more easily understandable state and publish it ASAP so I can get your feedback.</p>",
        "id": 173507325,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566172599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> okay I finally got around to doing it: <a href=\"https://github.com/rust-lang/rust/compare/master...eddyb:promo-sanity\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/compare/master...eddyb:promo-sanity\">https://github.com/rust-lang/rust/compare/master...eddyb:promo-sanity</a></p>",
        "id": 173829680,
        "sender_full_name": "eddyb",
        "timestamp": 1566419618
    },
    {
        "content": "<p>gtg now but I will report tomorrow wiith test results</p>",
        "id": 173829688,
        "sender_full_name": "eddyb",
        "timestamp": 1566419630
    },
    {
        "content": "<p>@eddyb Awesome. I'm almost done with my branch. I'll publish tomorrow morning. Sorry for the lack of coordination. I've been a bit busy.</p>",
        "id": 173853588,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566451042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> <a href=\"https://github.com/rust-lang/rust/compare/master...ecstatic-morse:qualifs-temp\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/compare/master...ecstatic-morse:qualifs-temp\">https://github.com/rust-lang/rust/compare/master...ecstatic-morse:qualifs-temp</a></p>",
        "id": 173899589,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492675
    },
    {
        "content": "<p>So I ended up doing a custom dataflow implementation, not the use-def chain based one</p>",
        "id": 173899619,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492712
    },
    {
        "content": "<p>heh, nice</p>",
        "id": 173899624,
        "sender_full_name": "eddyb",
        "timestamp": 1566492714
    },
    {
        "content": "<p>wait, I didn't realize that</p>",
        "id": 173899668,
        "sender_full_name": "eddyb",
        "timestamp": 1566492727
    },
    {
        "content": "<p>The reason was that I wanted to allow const-qualification to still run in the old, RPO mode</p>",
        "id": 173899682,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492761
    },
    {
        "content": "<p>Since we don't actually need to have dataflow-based qualification for non-const fns</p>",
        "id": 173899702,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492783
    },
    {
        "content": "<p>aaaah I see</p>",
        "id": 173899720,
        "sender_full_name": "eddyb",
        "timestamp": 1566492802
    },
    {
        "content": "<p>And the use-def chain required implementing <code>Q::in_{operand,rvalue,...}</code> differently for each mode</p>",
        "id": 173899732,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492814
    },
    {
        "content": "<p>right, and eventually we can rip out most of that and do it on-demand</p>",
        "id": 173899737,
        "sender_full_name": "eddyb",
        "timestamp": 1566492819
    },
    {
        "content": "<p>Whereas with a custom dataflow impl, all the <code>Qualif</code> methods stay pretty much the same</p>",
        "id": 173899789,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492847
    },
    {
        "content": "<p>while trying to share as much logic as possible (I went the other way, duplicating logic, for my initial test of the separate checker)</p>",
        "id": 173899800,
        "sender_full_name": "eddyb",
        "timestamp": 1566492867
    },
    {
        "content": "<p>and I can just implement another <code>Resolver</code> that runs in the old mode</p>",
        "id": 173899823,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492887
    },
    {
        "content": "<p>Yeah, so you're trying to separate promotion from qualification which I think is a good idea.</p>",
        "id": 173899855,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492923
    },
    {
        "content": "<p>Promotion never actually needs to run in dataflow mode, because only temporaries with exactly one assignment are promotable</p>",
        "id": 173899935,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566492971
    },
    {
        "content": "<p>I kept running into confusing issues where if you have errors, promotion is limited one way or another</p>",
        "id": 173899967,
        "sender_full_name": "eddyb",
        "timestamp": 1566492996
    },
    {
        "content": "<p>like min_const_fn will promote nothing if there are min_const_fn check errors</p>",
        "id": 173899982,
        "sender_full_name": "eddyb",
        "timestamp": 1566493015
    },
    {
        "content": "<p>and then if you have non-trivial control-flow, the linear checker will just not see entire parts of it</p>",
        "id": 173900012,
        "sender_full_name": "eddyb",
        "timestamp": 1566493051
    },
    {
        "content": "<p>like my promoter chose to promote this <a href=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const-eval/issue-52475.rs#L10\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const-eval/issue-52475.rs#L10\">https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const-eval/issue-52475.rs#L10</a></p>",
        "id": 173900042,
        "sender_full_name": "eddyb",
        "timestamp": 1566493081
    },
    {
        "content": "<p>because, well, it can promote in anything just as well as it can promote in runtime functions</p>",
        "id": 173900152,
        "sender_full_name": "eddyb",
        "timestamp": 1566493149
    },
    {
        "content": "<p>dataflow only needs to handle two bits, really, HasMutInterior and NeedsDrop</p>",
        "id": 173900177,
        "sender_full_name": "eddyb",
        "timestamp": 1566493168
    },
    {
        "content": "<p>Hmm, can we not promote <code>&amp;0</code> there?</p>",
        "id": 173900201,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493181
    },
    {
        "content": "<p><code>check_const</code> never looks at the body of the <code>while</code></p>",
        "id": 173900228,
        "sender_full_name": "eddyb",
        "timestamp": 1566493200
    },
    {
        "content": "<p>so it never picks up promotion candidates from within</p>",
        "id": 173900290,
        "sender_full_name": "eddyb",
        "timestamp": 1566493216
    },
    {
        "content": "<p>anyway this just means I need another special-case</p>",
        "id": 173900351,
        "sender_full_name": "eddyb",
        "timestamp": 1566493259
    },
    {
        "content": "<p>Oh wow. that's because the body gets rejected by <code>min_const_fn</code></p>",
        "id": 173900382,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493278
    },
    {
        "content": "<p>?</p>",
        "id": 173900386,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493281
    },
    {
        "content": "<p>no, min_const_fn applies only to <code>const fn</code></p>",
        "id": 173900423,
        "sender_full_name": "eddyb",
        "timestamp": 1566493316
    },
    {
        "content": "<p>this is an array length</p>",
        "id": 173900470,
        "sender_full_name": "eddyb",
        "timestamp": 1566493324
    },
    {
        "content": "<p>Ah yes, duh</p>",
        "id": 173900493,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493351
    },
    {
        "content": "<p>So I thought the const checking code does look at loop bodies</p>",
        "id": 173900554,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493393
    },
    {
        "content": "<p>it gives up the moment it sees a branch, I guess if it were an infinite loop it would have seen the body :P</p>",
        "id": 173900586,
        "sender_full_name": "eddyb",
        "timestamp": 1566493422
    },
    {
        "content": "<p>When it traverses basic blocks, if it sees one that was already visited (a back-edge in the CFG) it calls <code>non_const</code></p>",
        "id": 173900596,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493430
    },
    {
        "content": "<p>this gets promoted btw <a href=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const-eval/issue-52475.rs#L4\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const-eval/issue-52475.rs#L4\">https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const-eval/issue-52475.rs#L4</a></p>",
        "id": 173900610,
        "sender_full_name": "eddyb",
        "timestamp": 1566493440
    },
    {
        "content": "<p>Does the promotion logic give up as soon as it sees a branch</p>",
        "id": 173900655,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493448
    },
    {
        "content": "<p>?</p>",
        "id": 173900659,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493449
    },
    {
        "content": "<p>not just one that was visited. also note the None</p>",
        "id": 173900665,
        "sender_full_name": "eddyb",
        "timestamp": 1566493456
    },
    {
        "content": "<p>it takes a linear path, so it gives up if there are multiple targets</p>",
        "id": 173900704,
        "sender_full_name": "eddyb",
        "timestamp": 1566493481
    },
    {
        "content": "<p>wow Zulip is so laggy for me now</p>",
        "id": 173900754,
        "sender_full_name": "eddyb",
        "timestamp": 1566493516
    },
    {
        "content": "<p>Oh, <code>SwitchInt</code> is <code>None</code> here</p>",
        "id": 173900887,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493583
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/07ea2604075d6f896addce0e6949c7cf25dd3715/src/librustc_mir/transform/qualify_consts.rs#L323\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/07ea2604075d6f896addce0e6949c7cf25dd3715/src/librustc_mir/transform/qualify_consts.rs#L323\">https://github.com/rust-lang/rust/blob/07ea2604075d6f896addce0e6949c7cf25dd3715/src/librustc_mir/transform/qualify_consts.rs#L323</a></p>",
        "id": 173900923,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493610
    },
    {
        "content": "<p>I understand now</p>",
        "id": 173900932,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566493614
    },
    {
        "content": "<p>yeah all of these <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L950-L956\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L950-L956\">https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs#L950-L956</a></p>",
        "id": 173900963,
        "sender_full_name": "eddyb",
        "timestamp": 1566493638
    },
    {
        "content": "<p>and, success!</p>",
        "id": 173901112,
        "sender_full_name": "eddyb",
        "timestamp": 1566493730
    },
    {
        "content": "<p>So there's still a ton to do on my branch, I need to implement the <code>TempOnlyResolver</code>, then check to see that the cursor is actually observing the proper set of effects. Basically, because qualif propagation was intertwined with const checking in the original code, some of the checks may be run before e.g. the return place of a call is given qualifs and some may be run after.</p>",
        "id": 173901961,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566494244
    },
    {
        "content": "<p>Separating the existing pass into three: qualif propagation, const checking, and promotion is I think a noble goal. Splitting up the latter two (which your PR does) makes validating the separation of \"qualif propagation\" a lot easier.</p>",
        "id": 173902833,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566494804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> here it is, sorry for the delays <a href=\"https://github.com/rust-lang/rust/pull/63812\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/63812\">https://github.com/rust-lang/rust/pull/63812</a></p>",
        "id": 173904190,
        "sender_full_name": "eddyb",
        "timestamp": 1566495669
    },
    {
        "content": "<p>So I opened <a href=\"https://github.com/rust-lang/rust/issues/63860\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63860\">#63860</a>, which contains a write-up of the changes in my branch. I'm working on splitting up <code>assign</code> in the current pass since its main purpose is obsoleted now that we don't actually propagate qualifs in <code>Checker</code>. I guess after implementing <code>TempOnlyResolver</code> I'll see if I can get the tests passing (the build/test cycle takes forever on my local machine, so I'll probably abuse CI for this).</p>",
        "id": 174049005,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566670426
    },
    {
        "content": "<p>The latest version of <a href=\"https://github.com/rust-lang/rust/issues/63860\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63860\">#63860</a> results in an index out of bounds ICE here: <a href=\"https://github.com/rust-lang/rust/blob/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06/src/librustc_mir/borrow_check/nll/type_check/mod.rs#L427\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06/src/librustc_mir/borrow_check/nll/type_check/mod.rs#L427\">https://github.com/rust-lang/rust/blob/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06/src/librustc_mir/borrow_check/nll/type_check/mod.rs#L427</a></p>",
        "id": 174187265,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566865841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Do you have any idea how this would get triggered?</p>",
        "id": 174187327,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566865926
    },
    {
        "content": "<p>That can only happen on broken mir</p>",
        "id": 174198879,
        "sender_full_name": "oli",
        "timestamp": 1566885407
    },
    {
        "content": "<p>Maybe promotion does something only halfway?</p>",
        "id": 174198893,
        "sender_full_name": "oli",
        "timestamp": 1566885470
    },
    {
        "content": "<p>@oli like perhaps my PR is now incorrectly marking something for promotion something that the code that does promotion can't translate to a Body?</p>",
        "id": 174199045,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566885657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span></p>",
        "id": 174199054,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566885671
    },
    {
        "content": "<p>Sounds like it</p>",
        "id": 174199430,
        "sender_full_name": "oli",
        "timestamp": 1566886265
    },
    {
        "content": "<p>What code is causing the ICE?</p>",
        "id": 174199436,
        "sender_full_name": "oli",
        "timestamp": 1566886284
    },
    {
        "content": "<p>I don't have the error message in front of me now, but I'll have a look at it as well as the generated MIR tomorrow. Do you have any other tips for debugging promotion?</p>",
        "id": 174199598,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566886496
    },
    {
        "content": "<p>(the name of the function being processed appears in the query stack)</p>",
        "id": 174199619,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566886538
    },
    {
        "content": "<p>I believe we have some debug tracing in <a href=\"http://promote.rs\" target=\"_blank\" title=\"http://promote.rs\">promote.rs</a></p>",
        "id": 174200954,
        "sender_full_name": "oli",
        "timestamp": 1566888216
    },
    {
        "content": "<p>I can have a look at your PR later, maybe I'll see sth</p>",
        "id": 174200964,
        "sender_full_name": "oli",
        "timestamp": 1566888236
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/num/dec2flt/rawfp.rs#L260\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/num/dec2flt/rawfp.rs#L260\">https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/num/dec2flt/rawfp.rs#L260</a></p>",
        "id": 174243403,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566921790
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/0\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/0\">#0</a> [mir_borrowck] processing <code>num::dec2flt::rawfp::round_normal</code></p>",
        "id": 174243491,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566921837
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>thread &#39;rustc&#39; panicked at &#39;index out of bounds: the len is 6 but the index is 7&#39;, /home/mackendy/src/rust/rust/src/libcore/slice/mod.rs:2715:10\nstack backtrace:\n   0: std::sys_common::backtrace::print\n   1: std::panicking::default_hook::{{closure}}\n   2: std::panicking::default_hook\n   3: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::Fn&lt;A&gt;&gt;::call\n             at ./src/liballoc/boxed.rs:936\n   4: rustc::util::common::panic_hook\n             at src/librustc/util/common.rs:43\n   5: std::panicking::rust_panic_with_hook\n   6: std::panicking::continue_panic_fmt\n   7: rust_begin_unwind\n   8: core::panicking::panic_fmt\n   9: core::panicking::panic_bounds_check\n  10: rustc_mir::borrow_check::nll::type_check::TypeVerifier::sanitize_place::{{closure}}\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:0\n  11: rustc::mir::Place::iterate_over::iterate_over2\n             at ./src/librustc/mir/mod.rs:1932\n  12: rustc::mir::visit::Visitor::super_rvalue\n             at ./src/librustc/mir/visit.rs:0\n  13: &lt;rustc_mir::borrow_check::nll::type_check::TypeVerifier as rustc::mir::visit::Visitor&gt;::visit_rvalue\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:332\n  14: rustc::mir::visit::Visitor::super_assign\n             at ./src/librustc/mir/visit.rs:410\n  15: rustc::mir::visit::Visitor::visit_assign\n             at ./src/librustc/mir/visit.rs:99\n  16: rustc::mir::visit::Visitor::super_statement\n             at ./src/librustc/mir/visit.rs:348\n  17: rustc::mir::visit::Visitor::visit_statement\n             at ./src/librustc/mir/visit.rs:92\n  18: rustc::mir::visit::Visitor::super_basic_block_data\n             at ./src/librustc/mir/visit.rs:315\n  19: rustc::mir::visit::Visitor::visit_basic_block_data\n             at ./src/librustc/mir/visit.rs:81\n  20: rustc::mir::visit::Visitor::super_body\n             at ./src/librustc/mir/visit.rs:273\n  21: &lt;rustc_mir::borrow_check::nll::type_check::TypeVerifier as rustc::mir::visit::Visitor&gt;::visit_body\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:382\n  22: rustc_mir::borrow_check::nll::type_check::TypeVerifier::sanitize_promoted\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:554\n  23: rustc_mir::borrow_check::nll::type_check::TypeVerifier::sanitize_place::{{closure}}\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:458\n  24: rustc::mir::Place::iterate_over::iterate_over2\n             at ./src/librustc/mir/mod.rs:1932\n  25: rustc::mir::visit::Visitor::super_rvalue\n             at ./src/librustc/mir/visit.rs:0\n  26: &lt;rustc_mir::borrow_check::nll::type_check::TypeVerifier as rustc::mir::visit::Visitor&gt;::visit_rvalue\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:332\n  27: rustc::mir::visit::Visitor::super_assign\n             at ./src/librustc/mir/visit.rs:410\n  28: rustc::mir::visit::Visitor::visit_assign\n             at ./src/librustc/mir/visit.rs:99\n  29: rustc::mir::visit::Visitor::super_statement\n             at ./src/librustc/mir/visit.rs:348\n  30: rustc::mir::visit::Visitor::visit_statement\n             at ./src/librustc/mir/visit.rs:92\n  31: rustc::mir::visit::Visitor::super_basic_block_data\n             at ./src/librustc/mir/visit.rs:315\n  32: rustc::mir::visit::Visitor::visit_basic_block_data\n             at ./src/librustc/mir/visit.rs:81\n  33: rustc::mir::visit::Visitor::super_body\n             at ./src/librustc/mir/visit.rs:273\n  34: &lt;rustc_mir::borrow_check::nll::type_check::TypeVerifier as rustc::mir::visit::Visitor&gt;::visit_body\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:382\n  35: rustc_mir::borrow_check::nll::type_check::type_check_internal\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:204\n  36: rustc_mir::borrow_check::nll::type_check::type_check\n             at src/librustc_mir/borrow_check/nll/type_check/mod.rs:156\n  37: rustc_mir::borrow_check::nll::compute_regions\n             at src/librustc_mir/borrow_check/nll/mod.rs:107\n  38: rustc_mir::borrow_check::do_mir_borrowck\n             at src/librustc_mir/borrow_check/mod.rs:187\n  39: rustc_mir::borrow_check::mir_borrowck::{{closure}}\n             at src/librustc_mir/borrow_check/mod.rs:96\n  40: rustc::infer::InferCtxtBuilder::enter::{{closure}}\n             at ./src/librustc/infer/mod.rs:522\n  41: rustc::ty::context::GlobalCtxt::enter_local::{{closure}}::{{closure}}\n             at ./src/librustc/ty/context.rs:1624\n  42: rustc::ty::context::tls::enter_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1847\n  43: rustc::ty::context::tls::set_tlv\n             at ./src/librustc/ty/context.rs:1780\n  44: rustc::ty::context::tls::enter_context\n             at ./src/librustc/ty/context.rs:1846\n  45: rustc::ty::context::GlobalCtxt::enter_local::{{closure}}\n             at ./src/librustc/ty/context.rs:1623\n  46: rustc::ty::context::tls::with_related_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1953\n  47: rustc::ty::context::tls::with_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1936\n  48: rustc::ty::context::tls::with_context_opt\n             at ./src/librustc/ty/context.rs:1925\n  49: rustc::ty::context::tls::with_context\n             at ./src/librustc/ty/context.rs:1936\n  50: rustc::ty::context::tls::with_related_context\n             at ./src/librustc/ty/context.rs:1949\n  51: rustc::ty::context::GlobalCtxt::enter_local\n             at ./src/librustc/ty/context.rs:1615\n  52: rustc::infer::InferCtxtBuilder::enter\n             at ./src/librustc/infer/mod.rs:521\n  53: rustc_mir::borrow_check::mir_borrowck\n             at src/librustc_mir/borrow_check/mod.rs:93\n  54: rustc::ty::query::&lt;impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::mir_borrowck&gt;::compute::{{closure}}\n             at ./src/librustc/ty/query/plumbing.rs:999\n  55: rustc::ty::query::__query_compute::mir_borrowck\n             at ./src/librustc/ty/query/plumbing.rs:950\n  56: rustc::ty::query::&lt;impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::mir_borrowck&gt;::compute\n             at ./src/librustc/ty/query/plumbing.rs:991\n  57: rustc::dep_graph::graph::DepGraph::with_task_impl::{{closure}}::{{closure}}\n             at ./src/librustc/dep_graph/graph.rs:277\n  58: rustc::ty::context::tls::enter_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1847\n  59: rustc::ty::context::tls::set_tlv\n             at ./src/librustc/ty/context.rs:1780\n  60: rustc::ty::context::tls::enter_context\n             at ./src/librustc/ty/context.rs:1846\n  61: rustc::dep_graph::graph::DepGraph::with_task_impl::{{closure}}\n             at ./src/librustc/dep_graph/graph.rs:276\n  62: rustc::ty::context::tls::with_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1936\n  63: rustc::ty::context::tls::with_context_opt\n             at ./src/librustc/ty/context.rs:1925\n  64: rustc::ty::context::tls::with_context\n             at ./src/librustc/ty/context.rs:1936\n  65: rustc::dep_graph::graph::DepGraph::with_task_impl\n             at ./src/librustc/dep_graph/graph.rs:270\n  66: rustc::dep_graph::graph::DepGraph::with_task\n             at ./src/librustc/dep_graph/graph.rs:202\n  67: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::force_query_with_job::{{closure}}::{{closure}}\n             at ./src/librustc/ty/query/plumbing.rs:558\n  68: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::start_query::{{closure}}::{{closure}}\n             at ./src/librustc/ty/query/plumbing.rs:277\n  69: rustc::ty::context::tls::enter_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1847\n  70: rustc::ty::context::tls::set_tlv\n             at ./src/librustc/ty/context.rs:1780\n  71: rustc::ty::context::tls::enter_context\n             at ./src/librustc/ty/context.rs:1846\n  72: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::start_query::{{closure}}\n             at ./src/librustc/ty/query/plumbing.rs:276\n  73: rustc::ty::context::tls::with_related_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1953\n  74: rustc::ty::context::tls::with_context::{{closure}}\n             at ./src/librustc/ty/context.rs:1936\n  75: rustc::ty::context::tls::with_context_opt\n             at ./src/librustc/ty/context.rs:1925\n  76: rustc::ty::context::tls::with_context\n             at ./src/librustc/ty/context.rs:1936\n  77: rustc::ty::context::tls::with_related_context\n             at ./src/librustc/ty/context.rs:1949\n  78: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::start_query\n             at ./src/librustc/ty/query/plumbing.rs:265\n  79: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::force_query_with_job::{{closure}}\n             at ./src/librustc/ty/query/plumbing.rs:550\n  80: rustc::ty::query::plumbing::with_diagnostics\n             at ./src/librustc/ty/query/plumbing.rs:210\n  81: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::force_query_with_job\n             at ./src/librustc/ty/query/plumbing.rs:549\n  82: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::get_query\n             at ./src/librustc/ty/query/plumbing.rs:431\n  83: rustc::ty::query::plumbing::&lt;impl rustc::ty::context::TyCtxt&gt;::ensure_query\n             at ./src/librustc/ty/query/plumbing.rs:612\n  84: rustc::ty::query::TyCtxtEnsure::mir_borrowck\n             at ./src/librustc/ty/query/plumbing.rs:1027\n  85: rustc_interface::passes::analysis::{{closure}}::{{closure}}\n             at src/librustc_interface/passes.rs:957\n  86: rustc::ty::&lt;impl rustc::ty::context::TyCtxt&gt;::par_body_owners::{{closure}}\n             at ./src/librustc/ty/mod.rs:2771\n  87: core::iter::traits::iterator::Iterator::for_each::call::{{closure}}\n             at ./src/libcore/iter/traits/iterator.rs:613\n  88: &lt;core::slice::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::fold\n             at ./src/libcore/slice/mod.rs:3211\n  89: core::iter::traits::iterator::Iterator::for_each\n ```\n</pre></div>",
        "id": 174243612,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566921889
    },
    {
        "content": "<p>So there's the failing function body as well as a backtrace for good measure. Although there's no line number for the closure in `sanitize_place, I did verify what statement was failing</p>",
        "id": 174243825,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566922024
    },
    {
        "content": "<p>Surprisingly, replacing the body of that function with <code>unimplemented</code> allows all of <code>core</code> to compile.</p>",
        "id": 174244064,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566922167
    },
    {
        "content": "<p>Which implies that only that function triggers the problem.</p>",
        "id": 174244112,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566922199
    },
    {
        "content": "<p>I'm assuming that removing the assert_eq will pass, too</p>",
        "id": 174248016,
        "sender_full_name": "oli",
        "timestamp": 1566924871
    },
    {
        "content": "<p>If so, you're somehow losing the argument marker for x.f</p>",
        "id": 174248047,
        "sender_full_name": "oli",
        "timestamp": 1566924906
    },
    {
        "content": "<p>Yes, commenting out <code>assert_eq</code> works as well</p>",
        "id": 174248383,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925145
    },
    {
        "content": "<p>Can you say more about argument markers <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> ?</p>",
        "id": 174248393,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925158
    },
    {
        "content": "<p>Do you mean that I'm trying to promote <code>x.f</code> even though it's a field of an argument?</p>",
        "id": 174248695,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925359
    },
    {
        "content": "<p>btw, I figured out <code>-Zdump-mir=func_name</code> so I have the MIR after promotion.</p>",
        "id": 174248819,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925460
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>        _63 = &amp;(promoted[0]: (&amp;&#39;static str, u32, u32)); // bb7[4]: scope 4 at src/libcore/macros.rs:19:38: 19:92\n        _62 = &amp;(*_63);                   // bb7[5]: scope 4 at src/libcore/macros.rs:19:38: 19:92\n        const panicking::panic_fmt(move _34, move _62) -&gt; bb1; // bb7[6]: scope 4 at src/libcore/macros.rs:18:9: 19:93\n</pre></div>",
        "id": 174248855,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> do you think you could breifly explain the <code>promoted[0]</code> syntax to me?</p>",
        "id": 174248968,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925585
    },
    {
        "content": "<p>I'm guessing <code>promoted[0]</code> refers to the newly created <code>mir::Body</code> that computes the promoted value.</p>",
        "id": 174249018,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925635
    },
    {
        "content": "<p>And <code>(&amp;'static str, u32, u32)</code> is the return type of that <code>mir::Body</code>?</p>",
        "id": 174249044,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925660
    },
    {
        "content": "<p>There's two promoteds, one holds a <code>[&str; 3]</code> with some strings for assert, and this one holds the filename, line number, and column number.</p>",
        "id": 174249508,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566925969
    },
    {
        "content": "<p>The second <code>promoted</code> seems like it has almost the right number of locals to cause <code>index is 7, len is 6</code></p>",
        "id": 174250219,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566926499
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>promoted[1] in  num::dec2flt::rawfp::round_normal: [&amp;str; 3] = {\n    let mut _0: [&amp;str; 3];               // return place in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _1: [&amp;str; 3];               // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _2: &amp;str;                    // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _3: &amp;&#39;static str;            // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _4: &amp;str;                    // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _5: &amp;&#39;static str;            // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _6: &amp;str;                    // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _7: &amp;&#39;static str;            // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    scope 1 {\n        scope 2 {\n            scope 3 {\n                scope 4 {\n                    scope 5 {\n                    }\n                }\n                scope 6 {\n                }\n            }\n        }\n    }\n\n    bb0: {\n        _3 = const &quot;assertion failed: `(left == right)`\\n  left: `&quot;; // bb0[0]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 96, 40, 108, 101, 102, 116, 32, 61, 61, 32, 114, 105, 103, 104, 116, 41, 96, 10, 32, 32, 108, 101, 102, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [35184372088831], len: Size { raw: 45 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 45 }\n                                         // mir::Constant\n                                         // + span: src/libcore/macros.rs:53:28: 55:17\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 96, 40, 108, 101, 102, 116, 32, 61, 61, 32, 114, 105, 103, 104, 116, 41, 96, 10, 32, 32, 108, 101, 102, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [35184372088831], len: Size { raw: 45 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 45 } }\n        _2 = &amp;(*_3);                     // bb0[1]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _5 = const &quot;`,\\n right: `&quot;;      // bb0[2]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [96, 44, 10, 32, 114, 105, 103, 104, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 12 }\n                                         // mir::Constant\n                                         // + span: src/libcore/macros.rs:53:28: 55:17\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [96, 44, 10, 32, 114, 105, 103, 104, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 12 } }\n        _4 = &amp;(*_5);                     // bb0[3]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _7 = const &quot;`&quot;;                  // bb0[4]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 1 }\n                                         // mir::Constant\n                                         // + span: src/libcore/macros.rs:53:28: 55:17\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 1 } }\n        _6 = &amp;(*_7);                     // bb0[5]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _1 = [move _2, move _4, move _6]; // bb0[6]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _0 = move _1;                    // bb0[7]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        return;                          // bb0[8]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n    }\n}\n</pre></div>",
        "id": 174250233,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566926507
    },
    {
        "content": "<p>Maybe something happens in a later pass?</p>",
        "id": 174250331,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566926573
    },
    {
        "content": "<p>Also, after commenting out that line, building continues on to stage 1 std artifacts (the previous failure in core was from stage 0 std artifacts???) and fails on <code>ptr::&lt;impl cmp::Ord for *const T&gt;::cmp</code></p>",
        "id": 174250870,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566926955
    },
    {
        "content": "<p>I believe that is here <a href=\"https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src/libcore/ptr/mod.rs#L2885\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src/libcore/ptr/mod.rs#L2885\">https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src/libcore/ptr/mod.rs#L2885</a></p>",
        "id": 174251028,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566927036
    },
    {
        "content": "<p>No later pass removes a local AFAICT. I think I'll need more guidance to debug this.</p>",
        "id": 174253588,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566928887
    },
    {
        "content": "<p>this wouldnt have anything to do with the ICE I noted at <a href=\"https://github.com/rust-lang/rust/pull/63580#issuecomment-525164084\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/63580#issuecomment-525164084\">https://github.com/rust-lang/rust/pull/63580#issuecomment-525164084</a>, would it?</p>",
        "id": 174256054,
        "sender_full_name": "RalfJ",
        "timestamp": 1566930566
    },
    {
        "content": "<p>I think that ICE is occurring because we're running the <code>Inliner</code> optimization pass. I need to investigate more though...</p>",
        "id": 174256378,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1566930754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  Seems plausible. I can revert that PR and see if it helps</p>",
        "id": 174257004,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566931183
    },
    {
        "content": "<p>We don't run mir opts on libcore I think</p>",
        "id": 174266105,
        "sender_full_name": "oli",
        "timestamp": 1566936460
    },
    {
        "content": "<p>Do you still have the mir of promoted 0 at hand?</p>",
        "id": 174266745,
        "sender_full_name": "oli",
        "timestamp": 1566936828
    },
    {
        "content": "<p>@oli I don't, and I'm having trouble getting <code>x.py</code> to resume from the right place.</p>",
        "id": 174268424,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566937787
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> Is there something specific you're looking for?</p>",
        "id": 174268492,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566937808
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>// MIR for `num::dec2flt::rawfp::round_normal`\n// source = MirSource { instance: Item(DefId(0:519 ~ core[b842]::num[0]::dec2flt[0]::rawfp[0]::round_normal[0])), promoted: Some(promoted[0]) }\n// pass_name = QualifyAndPromoteConstants\n// disambiguator = after\n\npromoted[0] in  num::dec2flt::rawfp::round_normal: (&amp;&#39;static str, u32, u32) = {\n    let mut _0: (&amp;&#39;static str, u32, u32); // return place in scope 0 at src/libcore/macros.rs:19:38: 19:92\n    let mut _1: (&amp;&#39;static str, u32, u32); // in scope 0 at src/libcore/macros.rs:19:39: 19:92\n    scope 1 {\n        scope 2 {\n            scope 3 {\n                scope 4 {\n                    scope 5 {\n                    }\n                }\n                scope 6 {\n                }\n            }\n        }\n    }\n\n    bb0: {\n        _1 = (const &quot;src/libcore/num/dec2flt/rawfp.rs&quot;, const 264u32, const 5u32); // bb0[0]: scope 0 at src/libcore/macros.rs:19:39: 19:92\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [115, 114, 99, 47, 108, 105, 98, 99, 111, 114, 101, 47, 110, 117, 109, 47, 100, 101, 99, 50, 102, 108, 116, 47, 114, 97, 119, 102, 112, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [4294967295], len: Size { raw: 32 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 32 }\n                                         // mir::Constant\n                                         // + span: src/libcore/num/dec2flt/rawfp.rs:264:5: 264:40\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [115, 114, 99, 47, 108, 105, 98, 99, 111, 114, 101, 47, 110, 117, 109, 47, 100, 101, 99, 50, 102, 108, 116, 47, 114, 97, 119, 102, 112, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [4294967295], len: Size { raw: 32 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 32 } }\n                                         // ty::Const\n                                         // + ty: u32\n                                         // + val: Scalar(0x00000108)\n                                         // mir::Constant\n                                         // + span: src/libcore/num/dec2flt/rawfp.rs:264:5: 264:40\n                                         // + ty: u32\n                                         // + literal: Const { ty: u32, val: Scalar(0x00000108) }\n                                         // ty::Const\n                                         // + ty: u32\n                                         // + val: Scalar(0x00000005)\n                                         // mir::Constant\n                                         // + span: src/libcore/num/dec2flt/rawfp.rs:264:5: 264:40\n                                         // + ty: u32\n                                         // + literal: Const { ty: u32, val: Scalar(0x00000005) }\n        _0 = move _1;                    // bb0[1]: scope 0 at src/libcore/macros.rs:19:38: 19:92\n        return;                          // bb0[2]: scope 0 at src/libcore/macros.rs:19:38: 19:92\n    }\n}\n</pre></div>",
        "id": 174313743,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566943157
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>// MIR for `num::dec2flt::rawfp::round_normal`\n// source = MirSource { instance: Item(DefId(0:519 ~ core[b842]::num[0]::dec2flt[0]::rawfp[0]::round_normal[0])), promoted: Some(promoted[1]) }\n// pass_name = QualifyAndPromoteConstants\n// disambiguator = after\n\npromoted[1] in  num::dec2flt::rawfp::round_normal: [&amp;str; 3] = {\n    let mut _0: [&amp;str; 3];               // return place in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _1: [&amp;str; 3];               // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _2: &amp;str;                    // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _3: &amp;&#39;static str;            // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _4: &amp;str;                    // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _5: &amp;&#39;static str;            // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _6: &amp;str;                    // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    let mut _7: &amp;&#39;static str;            // in scope 0 at src/libcore/macros.rs:53:28: 55:17\n    scope 1 {\n        scope 2 {\n            scope 3 {\n                scope 4 {\n                    scope 5 {\n                    }\n                }\n                scope 6 {\n                }\n            }\n        }\n    }\n\n    bb0: {\n        _3 = const &quot;assertion failed: `(left == right)`\\n  left: `&quot;; // bb0[0]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 96, 40, 108, 101, 102, 116, 32, 61, 61, 32, 114, 105, 103, 104, 116, 41, 96, 10, 32, 32, 108, 101, 102, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [35184372088831], len: Size { raw: 45 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 45 }\n                                         // mir::Constant\n                                         // + span: src/libcore/macros.rs:53:28: 55:17\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [97, 115, 115, 101, 114, 116, 105, 111, 110, 32, 102, 97, 105, 108, 101, 100, 58, 32, 96, 40, 108, 101, 102, 116, 32, 61, 61, 32, 114, 105, 103, 104, 116, 41, 96, 10, 32, 32, 108, 101, 102, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [35184372088831], len: Size { raw: 45 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 45 } }\n        _2 = &amp;(*_3);                     // bb0[1]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _5 = const &quot;`,\\n right: `&quot;;      // bb0[2]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [96, 44, 10, 32, 114, 105, 103, 104, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 12 }\n                                         // mir::Constant\n                                         // + span: src/libcore/macros.rs:53:28: 55:17\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [96, 44, 10, 32, 114, 105, 103, 104, 116, 58, 32, 96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [4095], len: Size { raw: 12 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 12 } }\n        _4 = &amp;(*_5);                     // bb0[3]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _7 = const &quot;`&quot;;                  // bb0[4]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n                                         // ty::Const\n                                         // + ty: &amp;&#39;static str\n                                         // + val: Slice { data: Allocation { bytes: [96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 1 }\n                                         // mir::Constant\n                                         // + span: src/libcore/macros.rs:53:28: 55:17\n                                         // + ty: &amp;&#39;static str\n                                         // + literal: Const { ty: &amp;&#39;static str, val: Slice { data: Allocation { bytes: [96], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [1], len: Size { raw: 1 } }, align: Align { pow2: 0 }, mutability: Immutable, extra: () }, start: 0, end: 1 } }\n        _6 = &amp;(*_7);                     // bb0[5]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _1 = [move _2, move _4, move _6]; // bb0[6]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        _0 = move _1;                    // bb0[7]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n        return;                          // bb0[8]: scope 0 at src/libcore/macros.rs:53:28: 55:17\n    }\n}\n</pre></div>",
        "id": 174313794,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566943247
    },
    {
        "content": "<p>This is right after promotion</p>",
        "id": 174313809,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566943270
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I have the mir dumps from all passes again, let me know what you want me to look for. I didn't see anything super obvious</p>",
        "id": 174318233,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566947714
    },
    {
        "content": "<p>Same error occurs with Wesley Wiser's PR reverted</p>",
        "id": 174321537,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1566951424
    },
    {
        "content": "<p>this is super odd. if the len is 6, that means the max index is 5, so it can't be promoted[1]</p>",
        "id": 174337127,
        "sender_full_name": "oli",
        "timestamp": 1566974638
    },
    {
        "content": "<p>how many locals does the mir::Body of the function itself have?</p>",
        "id": 174337171,
        "sender_full_name": "oli",
        "timestamp": 1566974660
    },
    {
        "content": "<p>maybe we're not inside a promoted?</p>",
        "id": 174337177,
        "sender_full_name": "oli",
        "timestamp": 1566974672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> it would be a good idea to compare the two computation methods and ensure they always agree, like I do in my PR</p>",
        "id": 174348513,
        "sender_full_name": "eddyb",
        "timestamp": 1566986741
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 174372250,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567005262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> about 60 XD</p>",
        "id": 174372278,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567005283
    },
    {
        "content": "<p>oh</p>",
        "id": 174372295,
        "sender_full_name": "oli",
        "timestamp": 1567005298
    },
    {
        "content": "<p>nevermind then</p>",
        "id": 174372296,
        "sender_full_name": "oli",
        "timestamp": 1567005301
    },
    {
        "content": "<p>no clue what's going on, this is very odd</p>",
        "id": 174372311,
        "sender_full_name": "oli",
        "timestamp": 1567005311
    },
    {
        "content": "<p>Okay, I'm gonna have a go at compare mode</p>",
        "id": 174375891,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567007422
    },
    {
        "content": "<p>It will take some time though, so if you have ideas in the meantime I'm all ears</p>",
        "id": 174375969,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567007464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> FWIW I meant <em>just</em> for the <code>promotion_candidates</code> list</p>",
        "id": 174377220,
        "sender_full_name": "eddyb",
        "timestamp": 1567008237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I was planning on putting the old code into a module and calling old::Checker::check_const, then comparing the output</p>",
        "id": 174377794,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567008621
    },
    {
        "content": "<p>This is about what you had in mind?</p>",
        "id": 174377812,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567008637
    },
    {
        "content": "<p>I guess? I'm not sure how involved your changes are</p>",
        "id": 174377830,
        "sender_full_name": "eddyb",
        "timestamp": 1567008658
    },
    {
        "content": "<p>I guess I could try to run them as part of the same code path</p>",
        "id": 174378064,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567008810
    },
    {
        "content": "<p>The whole hog approach might be quicker, I'll take a look today</p>",
        "id": 174378087,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567008830
    },
    {
        "content": "<p>I've implemented a compare mode. It appears that promotion qualifs are not being properly detected when there's a <code>Deref</code> involved. I'll look into the underlying causes tomorrow.</p>",
        "id": 174513117,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567136757
    },
    {
        "content": "<p>It turned out to be  a simple bug: I wasn't initializing the dataflow state for the start block properly. As a result, I believe I was trying to promote some temporaries whose value came from an argument. I thought I would have seen this in the dumped MIR however (perhaps I was looking at stale output?). I'll make sure to check timestamps in the future.</p>",
        "id": 174571403,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567190223
    },
    {
        "content": "<p>The dataflow-based code is still missing some candidates for promotion however. It appears to be static slices in complex CFGs. I'll keep debugging.</p>",
        "id": 174571525,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567190310
    },
    {
        "content": "<p>I've figured out the source of the missed promotions.</p>",
        "id": 174578391,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567195566
    },
    {
        "content": "<p>The flow-sensitive qualification code checks to see if the address of a local has been observed at a given program point. Temporary slices in loops will always have their address observed at the definition site (is this clear?). The flow-sensitive code is very conservative, and if it sees a pointer write or a function call, it assumes that any local whose address is observable may have been mutated, and thus may now contain any qualif.</p>",
        "id": 174578562,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567195766
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/ecca4b8c4bea678615175e1673ffcb647a94eb4a/src/libsyntax/attr/builtin.rs#L371\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/ecca4b8c4bea678615175e1673ffcb647a94eb4a/src/libsyntax/attr/builtin.rs#L371\">https://github.com/rust-lang/rust/blob/ecca4b8c4bea678615175e1673ffcb647a94eb4a/src/libsyntax/attr/builtin.rs#L371</a></p>",
        "id": 174578687,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567195836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Since we know that the type <code>&amp;[&amp;str]</code> is always <code>Freeze</code>, we can assume that indirect writes don't mutate it. And a temporary like the RHS of <code>let x: &amp;'static [Cell&lt;u32&gt;] = &amp;[]</code> is not promotable anyway since it <code>HasInteriorMut</code>. Is this correct?</p>",
        "id": 174579319,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567196352
    },
    {
        "content": "<p>If so, I guess we need to track whether a local has been mutably borrowed, or has been borrowed and is not <code>Freeze</code>.</p>",
        "id": 174579728,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567196732
    },
    {
        "content": "<p>iirc we even promote <code>&amp;mut []</code>, but that may just be inside static mut</p>",
        "id": 174584659,
        "sender_full_name": "oli",
        "timestamp": 1567201120
    },
    {
        "content": "<p>But in general: this is awesome news!</p>",
        "id": 174584819,
        "sender_full_name": "oli",
        "timestamp": 1567201264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  <code>&amp;mut []</code> is indeed promoted in non-const <code>fn</code>s. We'll need to figure out a way to justify this inside CFGs with back-edges to be backwards compatible.</p>",
        "id": 174585052,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567201492
    },
    {
        "content": "<p>Perhaps the answer is to wait for <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> s PR to get merged that separates promotion and const-qualification entirely</p>",
        "id": 174585166,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567201588
    },
    {
        "content": "<p>I'm also running flow-based qualification for <code>IsNotPromotable</code> and <code>IsNotImplicitlyPromotable</code>, which is not necessary, so implementing a linear <code>TempOnlyQualifier</code> that preserves the current behavior could make this go away.</p>",
        "id": 174585225,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567201654
    },
    {
        "content": "<p>The tests should be running on CI now. Hopefully we see some regressions since <code>HasMutInterior</code> is no longer replaced with <code>IsNotPromotable</code></p>",
        "id": 174586028,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567202358
    },
    {
        "content": "<p>There's 18 failing tests, reflecting about 4-5 bugs in my PR. I'm going to fix the trivial ones, then implement<code>TempOnlyQualifier</code>.</p>",
        "id": 174604143,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567231854
    },
    {
        "content": "<p>I think the failure in <a href=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const_arg_promotable.rs\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const_arg_promotable.rs\">https://github.com/rust-lang/rust/blob/master/src/test/ui/consts/const_arg_promotable.rs</a> may be caused because we no longer swap <code>HasMutInterior</code> for <code>IsNotPromotable</code>. I don't know this for sure though. It's pretty easy to fix this particular case: simply check for <code>HasMutInterior</code> as well as <code>IsNotPromotable</code> when making sure args are promotable, but I suspect there's a deeper reason to exchange those two qualifs.</p>",
        "id": 174604257,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567232142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> btw, since you are working on const-qualif, your input on <a href=\"https://github.com/rust-rfcs/const-eval/pull/27\" target=\"_blank\" title=\"https://github.com/rust-rfcs/const-eval/pull/27\">https://github.com/rust-rfcs/const-eval/pull/27</a> (and on the information in that repo in general) would be much appreciated :)</p>",
        "id": 174606024,
        "sender_full_name": "RalfJ",
        "timestamp": 1567235398
    },
    {
        "content": "<p>if there's things you learned that you think the next person working on const qualif should be able to just read somewhere, please add them there</p>",
        "id": 174606073,
        "sender_full_name": "RalfJ",
        "timestamp": 1567235424
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> in case you don’t know, dylan is ecstatic-morse; just mentioning this as they’ve already commented on that PR)</p>",
        "id": 174606505,
        "sender_full_name": "lqd",
        "timestamp": 1567236283
    },
    {
        "content": "<p>(I did not know that, thanks!)</p>",
        "id": 174609479,
        "sender_full_name": "RalfJ",
        "timestamp": 1567242203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie</span> yeaaaaaah crater takes forever though</p>",
        "id": 174615884,
        "sender_full_name": "eddyb",
        "timestamp": 1567254719
    },
    {
        "content": "<p>I changed my Zulip name to be consistent with my github. Someday I'll go full name everywhere, but not today XD</p>",
        "id": 174639091,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567297723
    },
    {
        "content": "<p>I won't have a lot of time over the weekend to work on this, so expect some more progress on Tuesday</p>",
        "id": 174639101,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567297752
    },
    {
        "content": "<p>After fixing some minor bugs, CI is now green for <a href=\"https://github.com/rust-lang/rust/issues/63860\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63860\">#63860</a>. This version of the PR still includes my hack to enable <code>&amp;mut []</code> promotion within loops (I'm currently trying to devise a test which demonstrates its unsoundness), which can be removed once I stop using a  flow-sensitive for promotion and go back to the temp-only one. I'll post an update here once that is implemented</p>",
        "id": 174843914,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567560164
    },
    {
        "content": "<p>Okay, so the latest commit on <a href=\"https://github.com/rust-lang/rust/issues/63860\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63860\">#63860</a> contains a <code>TempOnlyResolver</code> that doesn't use dataflow, but instead applies the transfer function which underlies the dataflow analysis (expressed in <code>QualifPropagator</code>) linearly, similar to how the existing qualification scheme works.</p>",
        "id": 174917130,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567627143
    },
    {
        "content": "<p>I've also removed the hack that enabled <code>&amp;mut []</code>, and CI is still passing, so any lingering soundness holes are unknown to me.</p>",
        "id": 174917276,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567627214
    },
    {
        "content": "<p>The latest version of this PR leaves intact the existing mutation of qualifs, and uses the <code>compare</code> function to log when their results differ from the new <code>Resolver</code>-based ones.</p>",
        "id": 174917364,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567627277
    },
    {
        "content": "<p>However, only the <code>Resolver</code> based ones are actually used</p>",
        "id": 174917435,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567627319
    },
    {
        "content": "<p>There are occasionally different results, but any difference I observe now is benign (usually a type being <code>IsNotImplicitlyPromotable</code> in addition to <code>IsNotPromotable</code>)</p>",
        "id": 174917577,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567627416
    },
    {
        "content": "<p>It looks like no <code>rustc</code> tests fail due to the absence of the <code>HasMutInterior -&gt; IsNotPromotable</code> replacement. I still have no idea what form a test case for this would take.</p>",
        "id": 174917748,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567627549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> So I think we should have a sync discussion about the next steps here. There's a way to implement <code>if</code> and (eventually) <code>loop</code> in const contexts with minimal changes.Basically, we continue running the old-style propagation logic but overriding it with the results from the <code>FlowSensitiveResolver</code> if we're in a <code>const</code> context. I'm a bit worried about this, because it will exercise new, untested code paths in the existing checker now by traversing the entire <code>mir::Body</code> instead of stopping at <code>SwitchInt</code>. </p>\n<p>Alternatively, we could also work towards a greenfield system that separates promotion and const-checking. I envision something roughly like this:<br>\n- Compute the dataflow results for <code>HasMutInterior</code> and <code>NeedsDrop</code> (if in a const context).<br>\n- Visit the <code>mir::Body</code> looking for violations of const safety (if in a const context). This pass would be much simpler than the existing const checking logic because it is no longer stateful: it doesn't need to keep track of promotable values and can simply use the dataflow cursor when it needs to query for <code>HasMutInterior</code> and <code>NeedsDrop</code>. The end-goal would be to unify this with the logic in <code>qualify_min_const_fn</code>.<br>\n- Compute the structural promotability of temps. This is the logic in <code>promote_consts</code> where we count the number of definitions of each temporary to see if they are eligible for promotion.<br>\n- Promote temps.  If we are running in a const context, we can reuse dataflow results for <code>HasMutInterior</code> and <code>NeedsDrop</code>. Otherwise, we'll need to compute them on-demand using <code>TempOnlyResolver</code>. Then we propagate <code>IsNotPromotable</code> and <code>IsNotImplicitlyPromotable</code>, also using <code>TempOnlyResolver</code>.<br>\n- Finally, validate the arguments passed to functions with <code>#[rustc_args_required_const(...)]</code>. This could maybe be folded into the previous step.</p>\n<p>Most of the work here would be in separating const-checking and promotion logic. You've already done some of this in <a href=\"https://github.com/rust-lang/rust/issues/63812\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63812\">#63812</a>. We could run the newly separated pass in a compare-mode with the old one until we are happy with its correctness.</p>",
        "id": 174925028,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1567632782
    },
    {
        "content": "<p>I implemented this in <a href=\"https://github.com/rust-lang/rust/issues/64470\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a></p>",
        "id": 175720067,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568498349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> ^</p>",
        "id": 175720068,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568498356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I switched to a more conservative analysis for doing qualification in the presence of indirect writes (<code>*p = x</code>) that is closer to the pre-dataflow approach. However, it's kind of hacky as I explain in the most recent comment on <a href=\"https://github.com/rust-lang/rust/issues/64470\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a>. Perhaps you'd like to weigh in on what we should do here long term to enable mutable borrows?</p>",
        "id": 175771327,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568589814
    },
    {
        "content": "<p>ugh I'm going to lose my notifications if I jump right in here</p>",
        "id": 175783969,
        "sender_full_name": "eddyb",
        "timestamp": 1568611099
    },
    {
        "content": "<p>I can't spend too much time on this until the crater run finishes (I wish I never bothered with crater, it's so bad nowadays...)</p>",
        "id": 175783972,
        "sender_full_name": "eddyb",
        "timestamp": 1568611126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> but, what I think is that a non-frozen borrow should assume the worst about the contents of the local being borrowed</p>",
        "id": 175783987,
        "sender_full_name": "eddyb",
        "timestamp": 1568611159
    },
    {
        "content": "<p>that is, indirect writes can be ignored because they <em>can't make it worse</em> than what the borrow already assumed</p>",
        "id": 175783997,
        "sender_full_name": "eddyb",
        "timestamp": 1568611197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> Specifically, how do you want to handle <code>const fn ident&lt;T&gt;(x: T) -&gt; T { x }</code>?</p>",
        "id": 175784066,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568611302
    },
    {
        "content": "<p><code>x</code> has to have <code>HasMutInterior</code></p>",
        "id": 175784074,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568611319
    },
    {
        "content": "<p>One way is to separate \"can be mutated through a reference\" from \"is not <code>Freeze</code>\".</p>",
        "id": 175784139,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568611394
    },
    {
        "content": "<p>(right now const validation uses <code>HasMutInterior</code> for both)</p>",
        "id": 175784146,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568611411
    },
    {
        "content": "<p>Anyways, I'll ping you once your crater run is done</p>",
        "id": 175784334,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568611767
    },
    {
        "content": "<p>hey, sorry to bother you? but what are you working on? I've been seeing the notifications for a couple weeks and I've grown curious about this :P</p>",
        "id": 175784388,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1568611822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132916\">@Christian Poveda</span> The first comment on  <a href=\"https://github.com/rust-lang/rust/issues/63860\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63860\">#63860</a> gives some background</p>",
        "id": 175784470,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568611953
    },
    {
        "content": "<p>Ohh ok thanks!</p>",
        "id": 175784536,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1568612069
    },
    {
        "content": "<p>I don't understand why that function is interesting at all</p>",
        "id": 175784604,
        "sender_full_name": "eddyb",
        "timestamp": 1568612180
    },
    {
        "content": "<p>it's just <code>_0 = _1</code></p>",
        "id": 175784606,
        "sender_full_name": "eddyb",
        "timestamp": 1568612186
    },
    {
        "content": "<blockquote>\n<p><code>x</code> has to have <code>HasMutInterior</code></p>\n</blockquote>\n<p>yes... and?</p>",
        "id": 175784635,
        "sender_full_name": "eddyb",
        "timestamp": 1568612227
    },
    {
        "content": "<p>if you take a reference to it, <em>it could be used to mutate <code>x</code></em></p>",
        "id": 175784645,
        "sender_full_name": "eddyb",
        "timestamp": 1568612242
    },
    {
        "content": "<blockquote>\n<p>One way is to separate \"can be mutated through a reference\" from \"is not <code>Freeze</code>\".</p>\n</blockquote>\n<p>they... are the same thing tho</p>",
        "id": 175784657,
        "sender_full_name": "eddyb",
        "timestamp": 1568612280
    },
    {
        "content": "<p>I really don't know why the identity function is significant</p>",
        "id": 175784716,
        "sender_full_name": "eddyb",
        "timestamp": 1568612343
    },
    {
        "content": "<p>I mean within that body, no references exist to it, so it cannot be mutated through a reference</p>",
        "id": 175784789,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568612450
    },
    {
        "content": "<p>yes it can!</p>",
        "id": 175784800,
        "sender_full_name": "eddyb",
        "timestamp": 1568612466
    },
    {
        "content": "<p>if you borrow it and pass it to some function <em>even without any bounds</em> it can use specialization to access some <code>Cell</code> inside</p>",
        "id": 175784809,
        "sender_full_name": "eddyb",
        "timestamp": 1568612493
    },
    {
        "content": "<p>but <code>x</code> could be runtime so this is largely irrelevant - it's unpromotable anyway</p>",
        "id": 175784816,
        "sender_full_name": "eddyb",
        "timestamp": 1568612513
    },
    {
        "content": "<p>Promotion is irrelevant here. The issue is <code>NeedsDrop</code></p>",
        "id": 175784891,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568612622
    },
    {
        "content": "<p>the risk of reinitialization?</p>",
        "id": 175784945,
        "sender_full_name": "eddyb",
        "timestamp": 1568612652
    },
    {
        "content": "<p>There's a drop Terminator at the end of <code>ident</code></p>",
        "id": 175784960,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568612666
    },
    {
        "content": "<p>So when we do <code>_0 = _1</code>, we clear <code>NeedsDrop</code> but not <code>HasMutInterior</code></p>",
        "id": 175784981,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568612749
    },
    {
        "content": "<p>wait but you can clear both</p>",
        "id": 175785026,
        "sender_full_name": "eddyb",
        "timestamp": 1568612777
    },
    {
        "content": "<p>wait are we worried about indirect accesses reinitializing something?</p>",
        "id": 175785039,
        "sender_full_name": "eddyb",
        "timestamp": 1568612809
    },
    {
        "content": "<p>Yes</p>",
        "id": 175785043,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568612817
    },
    {
        "content": "<p>aaaaaaaah</p>",
        "id": 175785049,
        "sender_full_name": "eddyb",
        "timestamp": 1568612823
    },
    {
        "content": "<p>okay yeah for that you need \"was ever borrowed\" or \"may have ever been borrowed before this point\"</p>",
        "id": 175785056,
        "sender_full_name": "eddyb",
        "timestamp": 1568612847
    },
    {
        "content": "<p>the former is a decent approximation</p>",
        "id": 175785063,
        "sender_full_name": "eddyb",
        "timestamp": 1568612868
    },
    {
        "content": "<p>sorry, when you said \"can be mutated through a reference\" I thought there was implied that you'd know whether there was a reference</p>",
        "id": 175785117,
        "sender_full_name": "eddyb",
        "timestamp": 1568612910
    },
    {
        "content": "<p><code>HasMutInterior</code> tells you that <em>if</em> you have a reference, it can be used to mutate even if it's not a mutable reference</p>",
        "id": 175785124,
        "sender_full_name": "eddyb",
        "timestamp": 1568612932
    },
    {
        "content": "<p>Yep sounds good. Btw this is not a blocker until we wanna unlock mutable references in const bodies</p>",
        "id": 175785126,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568612933
    },
    {
        "content": "<p>this is confusing me a bit</p>",
        "id": 175785197,
        "sender_full_name": "eddyb",
        "timestamp": 1568613025
    },
    {
        "content": "<p>since I can't easily tell what depends on what</p>",
        "id": 175785200,
        "sender_full_name": "eddyb",
        "timestamp": 1568613040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> I guess the conservative thing to do for indirect accesses, function calls and <code>InlineAsm</code>, is to assume that anything that was borrowed mutably <em>or</em> sharedly with a <code>!Frozen</code> type, may be mutated</p>",
        "id": 175785217,
        "sender_full_name": "eddyb",
        "timestamp": 1568613105
    },
    {
        "content": "<p>you can't really rely on <code>HasInteriorMut</code> easily because <code>HasInteriorMut</code> can be affected by this... I think?</p>",
        "id": 175785262,
        "sender_full_name": "eddyb",
        "timestamp": 1568613145
    },
    {
        "content": "<p>or maybe <code>NeedsDrop</code> can</p>",
        "id": 175785264,
        "sender_full_name": "eddyb",
        "timestamp": 1568613153
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I guess</p>",
        "id": 175785269,
        "sender_full_name": "eddyb",
        "timestamp": 1568613166
    },
    {
        "content": "<p>can a <code>&amp;Option&lt;UnsafeCell&lt;T&gt;&gt;</code> ever go from <code>None</code> to <code>Some</code>, under any model?</p>",
        "id": 175785283,
        "sender_full_name": "eddyb",
        "timestamp": 1568613196
    },
    {
        "content": "<p>if not then I guess you can make anything borrow-related depend on <code>HasInteriorMut</code></p>",
        "id": 175785301,
        "sender_full_name": "eddyb",
        "timestamp": 1568613240
    },
    {
        "content": "<p>Wow, Zulip is awful on Android :)</p>",
        "id": 175785379,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568613347
    },
    {
        "content": "<p>be careful, it also drains my battery really fast</p>",
        "id": 175785423,
        "sender_full_name": "eddyb",
        "timestamp": 1568613365
    },
    {
        "content": "<blockquote>\n<p>Wow, Zulip is awful on Android :)</p>\n</blockquote>\n<p>yes... your messages arrive after 30 mins or so...</p>",
        "id": 175785426,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1568613366
    },
    {
        "content": "<p>There was an example that made me uneasy about using <code>HasInteriorMut</code> to track whether a local could be mutated indirectly, but I don't remember it off the top of my head.</p>",
        "id": 175785437,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568613411
    },
    {
        "content": "<p>I have to hold the back button to kill the app and remove lag (which was noticeably in other apps) and not risk depleting my battery in a few minutes</p>",
        "id": 175785440,
        "sender_full_name": "eddyb",
        "timestamp": 1568613418
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span> I guess the conservative thing to do for indirect accesses, function calls and <code>InlineAsm</code>, is to assume that anything that was borrowed mutably <em>or</em> sharedly with a <code>!Frozen</code> type, may be mutated</p>\n</blockquote>\n<p>I think I will implement a dataflow pass that detects this, then check it along with <code>NeedsDrop</code> at <code>Drop</code> terminators.</p>",
        "id": 175785539,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568613596
    },
    {
        "content": "<p>There's already <code>HaveBeenBorrowedLocals</code>; I just need a slight variation on this.</p>",
        "id": 175785596,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568613634
    },
    {
        "content": "<blockquote>\n<p>if not then I guess you can make anything borrow-related depend on <code>HasInteriorMut</code></p>\n</blockquote>\n<p>I think this may be correct, but for some reason I'm wary. I guess because it may get cleared accidentally?</p>",
        "id": 175785764,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568613875
    },
    {
        "content": "<p>(This isn't an issue now, but may be in the future if we get more aggressive about clearing qualifs when locals are assigned to or moved out of)</p>",
        "id": 175785853,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568613988
    },
    {
        "content": "<blockquote>\n<p>can a <code>&amp;Option&lt;UnsafeCell&lt;T&gt;&gt;</code> ever go from <code>None</code> to <code>Some</code>, under any model?</p>\n</blockquote>\n<p>well... with <code>&amp;Option&lt;UnsafeCell&lt;bool&gt;&gt;</code> I think Stacked Borrows lets it go from <code>Some</code> to <code>None</code>, yes. I also see no way (that Miri could implement) to forbid that.<br>\nenum layout optimizations are really annoying that way...</p>",
        "id": 175799817,
        "sender_full_name": "RalfJ",
        "timestamp": 1568629249
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> yeah, see <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2932bbee72bee2461e104410964f925d\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2932bbee72bee2461e104410964f925d\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2932bbee72bee2461e104410964f925d</a>. interior mutability in Stacked Borrows is a per-location thing, so if the discriminant shares locations with the interior, it can be mutated...</p>",
        "id": 175800315,
        "sender_full_name": "RalfJ",
        "timestamp": 1568629903
    },
    {
        "content": "<p>miri can overwrite the <code>layout_of</code> query and remove all layout optimizations :D</p>",
        "id": 175802730,
        "sender_full_name": "oli",
        "timestamp": 1568632482
    },
    {
        "content": "<p>lol</p>",
        "id": 175803042,
        "sender_full_name": "RalfJ",
        "timestamp": 1568632844
    },
    {
        "content": "<p>that doesn't help for defining UB though ;)</p>",
        "id": 175803054,
        "sender_full_name": "RalfJ",
        "timestamp": 1568632852
    },
    {
        "content": "<p>could miri record what value ranges may be written to an interior mut location?</p>",
        "id": 175803695,
        "sender_full_name": "oli",
        "timestamp": 1568633535
    },
    {
        "content": "<p>maybe. in my nightmares.^^</p>",
        "id": 175804611,
        "sender_full_name": "RalfJ",
        "timestamp": 1568634598
    },
    {
        "content": "<p>I assumed as much</p>",
        "id": 175804920,
        "sender_full_name": "oli",
        "timestamp": 1568634959
    },
    {
        "content": "<p>I'm now happy with the analysis in <a href=\"https://github.com/rust-lang/rust/issues/64470\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a>. I'd like to split that PR up a bit, so that the generic dataflow engine and the new <code>IndirectlyMutableLocals</code> analysis can get a proper review. However, the code in the <code>check_consts</code> directory is ready to be reviewed in its current state.</p>",
        "id": 175864037,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568678189
    },
    {
        "content": "<p>I also wanted to float the idea of putting the new, dataflow-based validation pass behind a feature gate. In other words, only enable it if <code>#![feature(const_if)]</code> or <code>#![feature(const_loop)]</code> is enabled. We can use the existing pass for promotion if we add a flag to it that disables the validation errors (the ones that are currently commented out on my PR). This would mean that <a href=\"https://github.com/rust-lang/rust/issues/64470\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a> could advance independently of <a href=\"https://github.com/rust-lang/rust/issues/63812\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63812\">#63812</a>.</p>",
        "id": 175864322,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568678479
    },
    {
        "content": "<p>I want to put the new qualification pass behind a feature flag because I'm worried about accidentally allowing a const operation that was previously banned. Such a change will be insta-stable unless the new pass is behind a flag. While a <code>crater</code> run will be able to tell us if my PR regresses currently valid code, there's not a corpus of currently broken const code beyond the test suite. Letting people play around with <code>#![feature(const_if)]</code> should give us some more data.</p>",
        "id": 175864606,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568678772
    },
    {
        "content": "<p>sounds like a good idea to proceed carefully</p>",
        "id": 175867418,
        "sender_full_name": "centril",
        "timestamp": 1568682185
    },
    {
        "content": "<p>Oh btw <code>let mut x: Option&lt;Cell&lt;i32&gt;&gt; = None; let p = &amp;mut x; *p = Some(Cell::new(4));</code> is enough to require that we track <code>HasMutInterior</code> separate from <code>IsIndirectlyMutable</code> with the current rules. It wouldn't be too hard to extend them, but I think it's premature to try to combine the two concepts.</p>",
        "id": 175877395,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568698034
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I'm gonna start splitting up my PR now. I'm also gonna rebase changes in <code>check_consts</code> since there's currently 3 different forms of the analysis in the git history (I'll keep the original series of commits on my fork)</p>",
        "id": 175943269,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568750493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I rebased <a href=\"https://github.com/rust-lang/rust/issues/64470\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a> so that it can be reviewed commit-by-commit. Specifically the changes in <code>qualifs.rs</code> should be easier to review now. I also removed some of the unused code in <code>resolver.rs</code> that will be required to combine with <a href=\"https://github.com/rust-lang/rust/issues/63812\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/63812\">#63812</a>. Finally, I split out the dataflow portion of the PR in <a href=\"https://github.com/rust-lang/rust/issues/64566\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64566\">#64566</a> since there's a lot of design space there.</p>",
        "id": 175962524,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568768317
    },
    {
        "content": "<p>I don't think I'm going to split out the addition of the <code>IndirectlyMutableLocals</code> dataflow pass into its own PR, since it's not very big and pretty closely coupled to this PR, so comment away if you see problems.</p>",
        "id": 175962596,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568768407
    },
    {
        "content": "<blockquote>\n<p>I want to put the new qualification pass behind a feature flag because I'm worried about accidentally allowing a const operation that was previously banned. Such a change will be insta-stable unless the new pass is behind a flag.</p>\n</blockquote>\n<p>or we could have migration mode like we did for the borrow checker: run both, warn/ICE/whatever if they disagree.</p>",
        "id": 176046162,
        "sender_full_name": "RalfJ",
        "timestamp": 1568840458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I both love (T-lang) and hate (T-release) that idea -- it's gonna be fun for rollups :P</p>",
        "id": 176059820,
        "sender_full_name": "centril",
        "timestamp": 1568853790
    },
    {
        "content": "<p>yeah</p>",
        "id": 176073816,
        "sender_full_name": "RalfJ",
        "timestamp": 1568876112
    },
    {
        "content": "<p>well actually, I was not suggesting the thing with two runs of the test suite</p>",
        "id": 176074015,
        "sender_full_name": "RalfJ",
        "timestamp": 1568876324
    },
    {
        "content": "<p>I was suggesting the thing we do right now where we run both AST and NLL borrowck in production</p>",
        "id": 176074021,
        "sender_full_name": "RalfJ",
        "timestamp": 1568876336
    },
    {
        "content": "<blockquote>\n<p>I was suggesting the thing we do right now where we run both AST and NLL borrowck in production</p>\n</blockquote>\n<p>The current code always runs the new, dataflow-based validator but prevents it from emitting any errors. Then it compares the errors (<code>Span</code> plus <code>fmt::Debug</code> for the error struct) and ICEs if the sequence of errors is not identical with the old validator.</p>",
        "id": 176140492,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568926046
    },
    {
        "content": "<p>I'm not really sure how to present this to the user. I guess we could emit a warning to nightly users saying \"we messed something up, could you create an issue with your code so we can debug it\"?</p>",
        "id": 176140620,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568926139
    },
    {
        "content": "<p>Btw, I have a proof-of-concept branch that enables <code>if</code> and <code>match</code> in consts behind a feature flag so I can write better tests for the dataflow-based validator.</p>",
        "id": 176140847,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568926323
    },
    {
        "content": "<p><a href=\"https://github.com/ecstatic-morse/rust/tree/const-if\" target=\"_blank\" title=\"https://github.com/ecstatic-morse/rust/tree/const-if\">https://github.com/ecstatic-morse/rust/tree/const-if</a></p>",
        "id": 176140914,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568926365
    },
    {
        "content": "<blockquote>\n<p>I'm not really sure how to present this to the user. I guess we could emit a warning to nightly users saying \"we messed something up, could you create an issue with your code so we can debug it\"?</p>\n</blockquote>\n<p>Isn't that just an ICE?</p>",
        "id": 176144536,
        "sender_full_name": "centril",
        "timestamp": 1568929025
    },
    {
        "content": "<p>I guess an ICE seems a little extreme to me, but y'all have more experience with this stuff than I do</p>",
        "id": 176144983,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1568929377
    },
    {
        "content": "<p>ICEs are a perfect fit for \"we messed something up\"</p>",
        "id": 176145413,
        "sender_full_name": "centril",
        "timestamp": 1568929694
    },
    {
        "content": "<p>that's why they exist :D</p>",
        "id": 176145421,
        "sender_full_name": "centril",
        "timestamp": 1568929700
    },
    {
        "content": "<p>not quite, in this case I think we'd want it as a future incompat warning</p>",
        "id": 176167569,
        "sender_full_name": "oli",
        "timestamp": 1568959578
    },
    {
        "content": "<p>if it's an ICE we'd be breaking user code</p>",
        "id": 176167575,
        "sender_full_name": "oli",
        "timestamp": 1568959592
    },
    {
        "content": "<p>we want to be able to crater it and to wait for ppl to tell us about their woes</p>",
        "id": 176167579,
        "sender_full_name": "oli",
        "timestamp": 1568959616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> sure, but after cratering we should make it an ICE</p>",
        "id": 176263881,
        "sender_full_name": "centril",
        "timestamp": 1569070826
    },
    {
        "content": "<p>crater takes too long</p>",
        "id": 176263899,
        "sender_full_name": "oli",
        "timestamp": 1569070867
    },
    {
        "content": "<p>I have made a different suggestion on the PR</p>",
        "id": 176263902,
        "sender_full_name": "oli",
        "timestamp": 1569070874
    },
    {
        "content": "<p>just only ICE on nightly for now :D</p>",
        "id": 176263906,
        "sender_full_name": "oli",
        "timestamp": 1569070880
    },
    {
        "content": "<p>I'm working on a fix for <a href=\"https://github.com/rust-lang/rust/issues/64945\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64945\">#64945</a> now. My local git repo for rust was corrupted somehow, so I'm trying to fix those concurrently.</p>",
        "id": 177078284,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1569951127
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I opened <a href=\"https://github.com/rust-lang/rust/issues/64967\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64967\">#64967</a> to fix <a href=\"https://github.com/rust-lang/rust/issues/64945\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64945\">#64945</a>. I'll continue investigating whether similar mismatches are possible.</p>",
        "id": 177088926,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1569957856
    },
    {
        "content": "<p>Also, I think <code>IndirectlyMutableLocals</code> is currently unsound in the presence of unsafe code and aggregates.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[derive(Default)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">PartialInteriorMut</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PartialInteriorMut</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pa</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Doesn&#39;t cause `x` to get marked as indirectly mutable</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pb</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"n\">pa</span><span class=\"p\">.</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pb</span><span class=\"p\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\">  </span><span class=\"c1\">// Mutates `x` indirectly even though `x` is not marked indirectly mutable!!!</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Basically, we need to look at the type of the place base (not the type of the place after projections) to see whether to mark it as indirectly mutable.</p>",
        "id": 177089587,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1569958301
    },
    {
        "content": "<p>that code is UB though according to current Stacked Borrows</p>",
        "id": 177709683,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625219
    },
    {
        "content": "<p>but then this might or might not be what our final aliasing model says</p>",
        "id": 177709695,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625231
    },
    {
        "content": "<p>mixed interior mut is a contentious case</p>",
        "id": 177709716,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625244
    },
    {
        "content": "<p>oh I guess this is <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134#issuecomment-538678208\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134#issuecomment-538678208\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134#issuecomment-538678208</a></p>",
        "id": 177709840,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625304
    },
    {
        "content": "<p>in any case, good catch!</p>",
        "id": 177709946,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625400
    },
    {
        "content": "<p>that comment makes me wonder if this is more about using raw pointers outside their original range, or partial interior mutability</p>",
        "id": 177710023,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625432
    },
    {
        "content": "<p>it also raises some policy questions: if const-code has UB, do we care if our const-qualification analyses are incorrect?</p>",
        "id": 177710055,
        "sender_full_name": "RalfJ",
        "timestamp": 1570625457
    },
    {
        "content": "<p>what's the latest on this, out of curiosity? do we have some form of dataflow-based CTFE  in rustc nightly yet?</p>",
        "id": 177999733,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1570903251
    },
    {
        "content": "<p>It was merged in <a href=\"https://github.com/rust-lang/rust/issues/64470\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a>. See <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Next.20steps.20for.20promotion.20and.20validation\" title=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Next.20steps.20for.20promotion.20and.20validation\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Next.20steps.20for.20promotion.20and.20validation</a> for the latest news.</p>",
        "id": 178000842,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1570904978
    }
]