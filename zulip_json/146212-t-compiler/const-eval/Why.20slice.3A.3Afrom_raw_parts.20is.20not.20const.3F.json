[
    {
        "content": "<p>It's surprising that <code>slice::from_raw_parts</code> is not <code>const</code> while <code>ptr::from_raw_parts</code> (the more general version) and <code>ptr::slice_from_raw_parts</code> (pointer version) <strong>are</strong> <code>const</code>.</p>\n<p>Are there any reasons for that? The tracking issue (<a href=\"https://github.com/rust-lang/rust/issues/67456\">#67456</a>) talks about <code>is_aligned_and_not_null</code> check, but it's debug-only, not used in <code>ptr::from_raw_parts</code> and a similar check was disabled for <code>copy[_nonoverlapping]</code>.</p>",
        "id": 257928720,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634486175
    },
    {
        "content": "<p>well... now that we have const_eval_select, we can essentially just ask T-lang and T-libs if they are alright with using that to create alignment/null checks only in runtime mode, and skip them in const eval.</p>",
        "id": 257930531,
        "sender_full_name": "oli",
        "timestamp": 1634487932
    },
    {
        "content": "<p>then we can re-enable them in copy_nonoverlapping, too</p>",
        "id": 257930539,
        "sender_full_name": "oli",
        "timestamp": 1634487941
    },
    {
        "content": "<p>probably worth a separate issue that is labeled for both teams</p>",
        "id": 257930606,
        "sender_full_name": "oli",
        "timestamp": 1634487978
    },
    {
        "content": "<p>So I can open issues for checks in copy and from raw parts and tag T-lang and T-libs?</p>",
        "id": 257934091,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634491146
    },
    {
        "content": "<p>yea</p>",
        "id": 257940180,
        "sender_full_name": "oli",
        "timestamp": 1634497014
    },
    {
        "content": "<p>Couldn't we just make is_aligned_and_not_null const?</p>",
        "id": 257940802,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634497565
    },
    {
        "content": "<p>I think the problem with <code>is_aligned_and_not_null</code> is the ptr-&gt;int cast in it? (that allows checking for the alignment)</p>",
        "id": 257941570,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634498314
    },
    {
        "content": "<p>Yea, we can't really make that const other than adding more intrinsics or magic that are only somewhat correct. You can never tell if something is aligned to a higher alignment than the one used to allocate it if you are in const eval. Like if you allocate a [42; u8], the address you get is symbolic, and all you know is that it has 1 byte alignment. No matter which element of the array you check, the alignment is never known to be more than 1, as we don't know the \"true\" base address of the entire array</p>",
        "id": 257947246,
        "sender_full_name": "oli",
        "timestamp": 1634503467
    },
    {
        "content": "<p>This is a fundamental limit of const eval.</p>",
        "id": 257947264,
        "sender_full_name": "oli",
        "timestamp": 1634503494
    },
    {
        "content": "<p>I thought the <code>align</code> field of <code>Allocation</code> is used for misalignment detection</p>",
        "id": 257957685,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634513545
    },
    {
        "content": "<p>(I tried to create an unaligned read and it's not detected though)</p>",
        "id": 257957739,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634513605
    },
    {
        "content": "<p>In miri, yea, but const eval doesn't care mostly. The thing is, that alignment is the alignment of the first byte of the alloc. So if that alignment is 1 that does not mean if you take the second byte's address you get an alignment of 2, unlike at runtime</p>",
        "id": 257994183,
        "sender_full_name": "oli",
        "timestamp": 1634545992
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/rust-lang/rust/issues/90011\">#90011</a> (<code>slice::from_raw_parts[_mut]</code>) and <a href=\"https://github.com/rust-lang/rust/issues/90012\">#90012</a> (<code>copy[_nonoverlapping]</code>). Hopefully I didn't mess anything up <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 258019330,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634559617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Why.20slice.3A.3Afrom_raw_parts.20is.20not.20const.3F/near/257994183\">said</a>:</p>\n<blockquote>\n<p>In miri, yea, but const eval doesn't care mostly. The thing is, that alignment is the alignment of the first byte of the alloc. So if that alignment is 1 that does not mean if you take the second byte's address you get an alignment of 2, unlike at runtime</p>\n</blockquote>\n<p>I think we can just record the known alignment and reject anything that is not sufficiently aligned. I don't think we need to know the actual alignment.</p>",
        "id": 258096271,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634589572
    },
    {
        "content": "<p>E.g. given an allocation <code>alloc1</code> with alignment 1, fail the alignment check for all of <code>alloc1 + N</code> with any N if a slice of alignment &gt; 1 is created.</p>",
        "id": 258096507,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634589660
    },
    {
        "content": "<p>This should be fine since const eval code cannot convert ptr to int so it has no way to know the actual alignment.</p>",
        "id": 258096578,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634589691
    },
    {
        "content": "<p>Sure we can do that, but that requires a new intrinsic or lang item for a debug assertion that is never executed outside a custom built libstd. I don't think it's worth the effort, especially as we rarely check alignment in CTFE, so why go the extra mile here ?</p>",
        "id": 258102032,
        "sender_full_name": "oli",
        "timestamp": 1634591901
    }
]