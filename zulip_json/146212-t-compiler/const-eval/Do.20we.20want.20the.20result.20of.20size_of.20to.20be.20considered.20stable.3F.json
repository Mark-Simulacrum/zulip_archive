[
    {
        "content": "<p>From the \"How do we want const generics to impact stability?\" topic:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276353752\">said</a>:</p>\n<blockquote>\n<p>I do actually want to be able to write code like <code>let a: [u8; std::mem::size_of::&lt;Foo&gt;()] = [1, 2, 3, 4]</code>. And I would <em>expect</em> it to stop compiling if Foo changed size.</p>\n</blockquote>",
        "id": 276359123,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052245
    },
    {
        "content": "<p>There's a good argument to be made that the above code should be a deny-by-default lint, because it can be a breaking change if the internals of Foo change.</p>",
        "id": 276359352,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052319
    },
    {
        "content": "<p>To be specific, there are multiple scenarios where the above code breaks:</p>\n<ul>\n<li>(Acceptable) Foo is defined in your crate, and you added a field.</li>\n<li>(Bad) Foo is imported from another crate. The developer added a private field, and you just updated your dependencies (maybe without even realizing it).</li>\n<li>(Bad) Foo didn't change, but you upgraded your compiler, and the way Foo is laid out changed, its size is now different.</li>\n</ul>",
        "id": 276359798,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052488
    },
    {
        "content": "<p>Scenario 1 isn't a problem (you changed the fields yourself, you can expect the size to change)</p>",
        "id": 276359973,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052538
    },
    {
        "content": "<p>Scenario 2 can be guarded against: say that <code>size_of</code> returns an opaque const value if the type has private fields, or is marked as <code>#[non_exhaustive]</code>.</p>",
        "id": 276360257,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052640
    },
    {
        "content": "<p>Scenario 3 is harder to guard against: you have to say that <code>size_of</code> is opaque unless &lt;previous conditions&gt; AND the type has a representation that is guaranteed to be fixed (currently this is only <code>repr(C)</code>).</p>",
        "id": 276360549,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Do.20we.20want.20the.20result.20of.20size_of.20to.20be.20considered.20stable.3F/near/276360257\">said</a>:</p>\n<blockquote>\n<p>Scenario 2 can be guarded against: say that <code>size_of</code> returns an opaque const value if the type has private fields, or is marked as <code>#[non_exhaustive]</code>.</p>\n</blockquote>\n<p>Can't that already break today, via dependencies on <code>size_of</code>? You could write an assert.</p>",
        "id": 276360769,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648052788
    },
    {
        "content": "<p>?</p>",
        "id": 276360826,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052808
    },
    {
        "content": "<p>You mean break at runtime?</p>",
        "id": 276360849,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052816
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[test]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">mytest</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">ForeignType</span><span class=\"o\">&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276361089,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648052883
    },
    {
        "content": "<p>Sure</p>",
        "id": 276361115,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052891
    },
    {
        "content": "<p>You're allowed to write that today. Is that \"breakage\"?</p>",
        "id": 276361134,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648052898
    },
    {
        "content": "<p>the difference IMO is that you can still compile the crate</p>",
        "id": 276361164,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648052910
    },
    {
        "content": "<p>(static assert exists, so that also breaks at compile time)</p>",
        "id": 276361238,
        "sender_full_name": "lcnr",
        "timestamp": 1648052942
    },
    {
        "content": "<p>though imo that difference doesn't really matter too much, does it?</p>",
        "id": 276361269,
        "sender_full_name": "lcnr",
        "timestamp": 1648052951
    },
    {
        "content": "<p>i think the context is making static assert not work for sizes of thigns not guaranteed isnt it</p>",
        "id": 276361308,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648052962
    },
    {
        "content": "<p>I think this is like the difference between using regular references and using refcells.</p>",
        "id": 276361391,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052997
    },
    {
        "content": "<p>well yes, but that's a breaking change, which is the issue raised by <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> afaict</p>",
        "id": 276361446,
        "sender_full_name": "lcnr",
        "timestamp": 1648053004
    },
    {
        "content": "<p><em>or maybe not, a bit confused</em> <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>",
        "id": 276361549,
        "sender_full_name": "lcnr",
        "timestamp": 1648053041
    },
    {
        "content": "<p>That's what I was wondering as well.</p>",
        "id": 276361668,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648053082
    },
    {
        "content": "<p>If your dependency uses refcells internally, it may suddenly break at runtime it changes how types are stored or whatever. Making sure it doesn't happen is the responsibility of the upstream maintainer, because they decided to \"abandon\" the guarantees of the rust type system to do things manually.</p>",
        "id": 276361733,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053105
    },
    {
        "content": "<p>It would also be a breaking change to make <code>let x = [0; size_of::&lt;ForeignType&gt;()];</code> stop working, right?</p>",
        "id": 276361773,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648053121
    },
    {
        "content": "<p>That works today AFAICT.</p>",
        "id": 276361838,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648053128
    },
    {
        "content": "<p>It wouldn't stop working</p>",
        "id": 276361881,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053141
    },
    {
        "content": "<p>It'd just break to match it up with another constant at compile time? For instance, <code>let x: [0; 4] = [0; size_of::&lt;ForeignType&gt;()];</code>?</p>",
        "id": 276362075,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648053218
    },
    {
        "content": "<p>Yeah</p>",
        "id": 276362107,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053228
    },
    {
        "content": "<p>Quoting the examples again:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">make_array</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ALLOWED</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">make_array</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ALLOWED</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// MAYBE ALLOWED</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ERROR</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ERROR</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276362191,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053243
    },
    {
        "content": "<p>(note that I have no idea how difficult any of this would be to implement)</p>",
        "id": 276362252,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053268
    },
    {
        "content": "<blockquote>\n<p>It would also be a breaking change to make <code>let x = [0; size_of::&lt;ForeignType&gt;()];</code> stop working, right?</p>\n</blockquote>\n<p>To be clear, everything mentioned so far would be a breaking change. That's why I said this should be a lint.</p>",
        "id": 276362535,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Do.20we.20want.20the.20result.20of.20size_of.20to.20be.20considered.20stable.3F/near/276362535\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It would also be a breaking change to make <code>let x = [0; size_of::&lt;ForeignType&gt;()];</code> stop working, right?</p>\n</blockquote>\n<p>To be clear, all of this would be a breaking change. That's why I said this should be a lint.</p>\n</blockquote>\n<p>I see. So you want to add a lint in the current edition, and not actually make it breaking until a future edition?</p>",
        "id": 276362670,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648053437
    },
    {
        "content": "<p>Sure</p>",
        "id": 276362938,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053524
    },
    {
        "content": "<p>Also, to finish my summary:</p>\n<blockquote>\n<p>Scenario 3 is harder to guard against: you have to say that size_of is opaque unless &lt;previous conditions&gt; AND the type has a representation that is guaranteed to be fixed (currently this is only repr(C)).</p>\n</blockquote>\n<p>Josh argues that this too restrictive, because the ecosystem expects to be able to use the size of a known type to eg transmute it to bytes; though the semantics of safe_transmute are still being hashed out. Josh argues that there may already be an assumption in the ecosystem that the size of a type will not change if its fields don't change, even if the compiler makes no such guarantee. I argued that the ecosystem would definitely be wrong to make such an assumption, because there's a (subjectively) very common understanding that the compiler may add new niches to enums in the future, which would definitely change layouts.</p>\n<p>I also suggested that the language could add multiple stable representations over time, eg <code>repr(rust2021)</code>, <code>repr(rust2024)</code>, etc, so that <code>repr(C)</code> isn't the only way to have some stability in how a type is laid out.</p>",
        "id": 276365088,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648054285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276361919\">said</a>:</p>\n<blockquote>\n<p>The question is, unless it gets specified, how prolific do you want those reprs to be.<br>\nI have a similar thing planned (unstable) for lccc, where the central abi defines the layout in that version, and then you can reach for <code>repr(lcrust_v0)</code> to get the layout from a particular version, and there will be one for each new layout, but there won't be that many because I expect to redefine the layout very infrequently: for the most part, only as required.  <br>\nThat comes with the trade off of having far less optimization opportunities as they have to be weighed against the cost of adding to that.</p>\n</blockquote>\n<p>I'd say \"roughly one representation per edition\".</p>",
        "id": 276365286,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648054360
    },
    {
        "content": "<p>Ok, that's fair.</p>",
        "id": 276365371,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648054392
    },
    {
        "content": "<p>Note that these representations would only be for types that <em>need</em> a fixed layout.</p>",
        "id": 276365377,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648054394
    },
    {
        "content": "<p>These layouts would likely have to be specified, as to what transformations are allowed to be performed. <br>\nI can help with that</p>",
        "id": 276365470,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648054439
    },
    {
        "content": "<p>So given eg</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foobar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>: <span class=\"nc\">Foo</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the layout of Foobar would still be implementation-defined</p>",
        "id": 276365518,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648054445
    },
    {
        "content": "<p>But </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(rust2021)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foobar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>: <span class=\"nc\">Foo</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would have a fixed representation</p>",
        "id": 276365608,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648054481
    },
    {
        "content": "<p>(I assume you mean unspecified, rather than implementation-defined. I don't see rustc ever documented repr(Rust))</p>",
        "id": 276365619,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648054486
    },
    {
        "content": "<p>Right</p>",
        "id": 276365639,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648054493
    },
    {
        "content": "<p>note that <code>transmute</code> already does such a size check, so if you transmute a repr(Rust) thing to something else, you opt into size change breakage already</p>",
        "id": 276370554,
        "sender_full_name": "oli",
        "timestamp": 1648056295
    },
    {
        "content": "<p>doing that explicitly via size_of is just a convenient way to opt into breakage <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 276370604,
        "sender_full_name": "oli",
        "timestamp": 1648056313
    },
    {
        "content": "<p>And then we have one (or two if you count usize and isize separately) size that changes depending on target_pointer_width.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(generic_arg_infer)]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ZEROS1</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">from_ne_bytes</span><span class=\"p\">([</span><span class=\"sc\">b'0'</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">usize</span>::<span class=\"n\">BITS</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ZEROS2</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">from_ne_bytes</span><span class=\"p\">([</span><span class=\"sc\">b'0'</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()]);</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ZEROS3</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">from_ne_bytes</span><span class=\"p\">([</span><span class=\"sc\">b'0'</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">from_ne_bytes</span><span class=\"p\">(</span><span class=\"n\">bytes</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">()])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// SAFETY: integers are plain old datatypes so we can always transmute to them</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276371741,
        "sender_full_name": "Bot+",
        "timestamp": 1648056763
    },
    {
        "content": "<p>I think that a change in size_of is only reasonably a semver break <em>if</em> you're already prevented from adding/removing fields by semver. However, if at least one field is private then you're allowed to add more private fields, so you're allowed to change your size_of.</p>",
        "id": 276391905,
        "sender_full_name": "Lokathor",
        "timestamp": 1648065832
    },
    {
        "content": "<p>Or <code>#[non_exhaustive]</code></p>",
        "id": 276408059,
        "sender_full_name": "cuviper",
        "timestamp": 1648073558
    },
    {
        "content": "<p>This all really reminds me of those whole \"there should be a derive to opt into stable layout\" conversation in safe-transmute, distinct from the underlying marker trait that checks whether it's <em>currently</em> ok.</p>",
        "id": 276418841,
        "sender_full_name": "scottmcm",
        "timestamp": 1648080367
    },
    {
        "content": "<p>where's repr(linear) when you need it?</p>\n<p>if only someone from T-lang was here</p>",
        "id": 276418895,
        "sender_full_name": "Lokathor",
        "timestamp": 1648080464
    },
    {
        "content": "<p>I have trouble seeing how this works with <code>const foo: usize = std::mem::size_of::&lt;Foo&gt;();</code>, <code>[0; foo]</code>, I'm somewhat thinking about some places, i've had to stash the size_of in a traits associated const (for reasons)... generally these are newtype of a primitive + a phantom data, where the primitive is hidden behind a bunch of trait bounds.</p>",
        "id": 276445962,
        "sender_full_name": "matt rice",
        "timestamp": 1648111860
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">foo</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>my impl idea was that the value of <code>foo</code> is opaque cause <code>foo</code> uses <code>std::mem::size_of::&lt;Foo&gt;()</code> which is opaque</p>",
        "id": 276446182,
        "sender_full_name": "lcnr",
        "timestamp": 1648111990
    },
    {
        "content": "<p>but i haven't thought much about it tbh</p>",
        "id": 276446198,
        "sender_full_name": "lcnr",
        "timestamp": 1648111997
    },
    {
        "content": "<p>FWIW, the lib where I think these things are hard to track, <a href=\"https://github.com/ratmice/enum_extra/blob/main/lib/src/lib.rs#L86\">https://github.com/ratmice/enum_extra/blob/main/lib/src/lib.rs#L86</a>, which eventually bottoms out at some <code>std::mem::size_of::&lt;T&gt;::()</code> in some macro call.</p>",
        "id": 276447025,
        "sender_full_name": "matt rice",
        "timestamp": 1648112473
    },
    {
        "content": "<p>I guess it should work, because T in this case is always some ground primitive type, but i'm not actually sure if I can show that that is the case, as the type is being pulled out of some macro type, and it just happens that the compiler only allows primitive types there...</p>",
        "id": 276447851,
        "sender_full_name": "matt rice",
        "timestamp": 1648113006
    },
    {
        "content": "<p>I use <code>const _: [(); 12] = [(); std::mem::size_of::&lt;Foo&gt;()];</code> all the time to check the size of my type at compile time or assert that it has a specific size for performance reasons. Yes I am aware this is architecture and compiler specific, I want to be informed if the size of my type is affected as a result. There are loads of examples of this use case in rustc, like <a href=\"https://github.com/rust-lang/rust/blob/600a80dedf71ce02e778e59f4884866c3030c819/compiler/rustc_ast/src/ast.rs#L1127-L1129\">this</a>. I don't think this practice should be discouraged, let alone banned.</p>",
        "id": 276452913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648116082
    },
    {
        "content": "<blockquote>\n<p>I don't think this practice should be discouraged, let alone banned.</p>\n</blockquote>\n<p>I think for your use-case, it would make sense to require a static assert; eg, something that says \"I want compilation to fail if this predicate is false, but the predicate isn't guaranteed by the type system\".</p>",
        "id": 276456934,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648118379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254366\">matt rice</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Do.20we.20want.20the.20result.20of.20size_of.20to.20be.20considered.20stable.3F/near/276445962\">said</a>:</p>\n<blockquote>\n<p>I have trouble seeing how this works with <code>const foo: usize = std::mem::size_of::&lt;Foo&gt;();</code>, <code>[0; foo]</code>, I'm somewhat thinking about some places, i've had to stash the size_of in a traits associated const (for reasons)... generally these are newtype of a primitive + a phantom data, where the primitive is hidden behind a bunch of trait bounds.</p>\n</blockquote>\n<p>Yeah, the only way opaque consts would make sense if they are infectious. Eg, the following code would be forbidden:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[opaque]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Y</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276457086,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648118473
    },
    {
        "content": "<blockquote>\n<p>Eg, the following code is forbidden:</p>\n</blockquote>\n<p>why forbidden? can't <code>Y</code> be forced to be opaque as well?</p>",
        "id": 276457137,
        "sender_full_name": "lcnr",
        "timestamp": 1648118510
    },
    {
        "content": "<p>Sure, that's what I mean by infectious</p>",
        "id": 276457199,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648118530
    },
    {
        "content": "<p>Eg you'd have to write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[opaque]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[opaque]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Y</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276457230,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648118552
    },
    {
        "content": "<p>Although... other semantics are possible:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[opaque]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Y</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">a</span>::<span class=\"p\">{</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// OK</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">array</span>: <span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"c1\">// ERROR</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">array</span>: <span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276459048,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648119631
    },
    {
        "content": "<p>In any case, this is probably something you'd want an escape hatch; a way to say \"yes, I know these values aren't guaranteed to unify in future version, but I'm pretty sure they will, so don't bother me\".</p>",
        "id": 276459272,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648119768
    },
    {
        "content": "<p>I'm not certain about that second semantics in the case where we have trait associated consts, and you have one trait impl which is opaque and another concrete.  but kind of melts my brain tbh...</p>",
        "id": 276459435,
        "sender_full_name": "matt rice",
        "timestamp": 1648119877
    },
    {
        "content": "<p>I guess it'd need to be checked when doing the impl or whatever....</p>",
        "id": 276459498,
        "sender_full_name": "matt rice",
        "timestamp": 1648119930
    },
    {
        "content": "<p>You can imagine it'd work like RPITs.</p>",
        "id": 276460721,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648120626
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">A</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">B</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">get_value</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">get_value</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[opaque]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">get_value</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Display</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">a</span>::<span class=\"p\">{</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// OK</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">array</span>: <span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">A</span>::<span class=\"n\">X</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// OK</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span>::<span class=\"n\">get_value</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"c1\">// ERROR</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">array</span>: <span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">B</span>::<span class=\"n\">X</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// ERROR</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">B</span>::<span class=\"n\">get_value</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276460943,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648120792
    },
    {
        "content": "<p>(keeping in mind semantics for RPITs-in-traits aren't stable, etc)</p>",
        "id": 276461014,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648120826
    },
    {
        "content": "<p>Yeah, I think the case i'm worried about is where we do something to the effect of:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">MyTrait</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"c1\">// ??</span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span>::<span class=\"n\">X</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276461387,
        "sender_full_name": "matt rice",
        "timestamp": 1648121050
    },
    {
        "content": "<p>Anyhow that is how these consts propagate in that url i linked above.</p>",
        "id": 276461500,
        "sender_full_name": "matt rice",
        "timestamp": 1648121134
    },
    {
        "content": "<p>In that case the constant is already opaque in current Rust, I think?</p>",
        "id": 276461870,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648121378
    },
    {
        "content": "<p>Never mind. I tested some variants in the playground and the compiler doesn't really support the relevant features, so \"current rust\" doesn't really have an opinion on the subject.</p>",
        "id": 276462340,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648121708
    },
    {
        "content": "<p>Ahh perhaps, I'm not sure I haven't looked into the compiler guts a whole lot at this point</p>",
        "id": 276462458,
        "sender_full_name": "matt rice",
        "timestamp": 1648121785
    },
    {
        "content": "<p>It makes sense that, in your example, <code>T::X</code> would be opaque from the point of view of Foo, because there is no guarantee <code>T::X</code> would have any specific value.</p>",
        "id": 276462580,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648121881
    }
]