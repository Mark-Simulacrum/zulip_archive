[
    {
        "content": "<p>If we have two impls that we want to check for overlap, like <code>impl&lt;const N: usize&gt; Default for [T; N + 1]</code> and one for <code>impl Default for [T; 0]</code>, what we actually want to prove is <code>0 != N + 1</code></p>\n<p>Similarly if we have <code>impl&lt;const N: u32&gt; Trait&lt;Some(N)&gt; for Struct</code> and <code>impl Trait&lt;None&gt; for Struct</code>, we want to prove <code>None != Some(N)</code></p>\n<p>Can we explore the space of designs that don't evaluate but equate expressions? Or are there obvious examples that make this unfeasible? I mean, the moment you stop having expressions and go into statements it's game over of course, but are these cases interesting?</p>",
        "id": 276320077,
        "sender_full_name": "oli",
        "timestamp": 1648035276
    },
    {
        "content": "<p>so for unification, even with concrete values, we start by staying fully syntactic?</p>",
        "id": 276320281,
        "sender_full_name": "lcnr",
        "timestamp": 1648035407
    },
    {
        "content": "<p>and a bunch of rules for both \"does unify\" + \"does not unify\"</p>",
        "id": 276320376,
        "sender_full_name": "lcnr",
        "timestamp": 1648035462
    },
    {
        "content": "<p>Well, proving <code>5 != 4</code> is trivial, but yea, not sure what to do about <code>5 != 3 + 1</code></p>",
        "id": 276320389,
        "sender_full_name": "oli",
        "timestamp": 1648035471
    },
    {
        "content": "<blockquote>\n<p>Can we explore the space of designs that don't evaluate but equate expressions?</p>\n</blockquote>\n<p>we can</p>",
        "id": 276320452,
        "sender_full_name": "lcnr",
        "timestamp": 1648035490
    },
    {
        "content": "<p>I am getting closer and closer to make my own a-mir-formality</p>",
        "id": 276320472,
        "sender_full_name": "lcnr",
        "timestamp": 1648035504
    },
    {
        "content": "<p>but actually as a separate prog lang so i can also experiment with polymorphization</p>",
        "id": 276320522,
        "sender_full_name": "lcnr",
        "timestamp": 1648035524
    },
    {
        "content": "<p>without having to deal with rustc being horrible</p>",
        "id": 276320529,
        "sender_full_name": "lcnr",
        "timestamp": 1648035530
    },
    {
        "content": "<p>or well, I can probably just go ahead and do that as part of a-mir-formality</p>",
        "id": 276320576,
        "sender_full_name": "lcnr",
        "timestamp": 1648035566
    },
    {
        "content": "<p>which would be a good introduction to it for me</p>",
        "id": 276320608,
        "sender_full_name": "lcnr",
        "timestamp": 1648035579
    },
    {
        "content": "<p>but idk if that's something we should add already, as it will be pretty damn experimental</p>",
        "id": 276320652,
        "sender_full_name": "lcnr",
        "timestamp": 1648035601
    },
    {
        "content": "<blockquote>\n<p>and a bunch of rules for both \"does unify\" + \"does not unify\"</p>\n</blockquote>\n<p>Yea, I was considering just implementing a bunch of rules first and only allowing them. Staying forward compatible with more powerful designs</p>",
        "id": 276320879,
        "sender_full_name": "oli",
        "timestamp": 1648035713
    },
    {
        "content": "<blockquote>\n<p>I am getting closer and closer to make my own a-mir-formality</p>\n</blockquote>\n<p>I was considering a librarification of AbstractConst and adding the equating algorithms there</p>",
        "id": 276321007,
        "sender_full_name": "oli",
        "timestamp": 1648035766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/equation.20solving.20in.20const.20generics.20.28say.20no.20to.20SFINAE.20try.202.29/near/276320576\">said</a>:</p>\n<blockquote>\n<p>or well, I can probably just go ahead and do that as part of a-mir-formality</p>\n</blockquote>\n<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> your take on adding cg support to a-mir-formality this early</p>",
        "id": 276321061,
        "sender_full_name": "lcnr",
        "timestamp": 1648035798
    },
    {
        "content": "<p>or well, an idealized cg version</p>",
        "id": 276321077,
        "sender_full_name": "lcnr",
        "timestamp": 1648035814
    },
    {
        "content": "<blockquote>\n<p>librarification of AbstractConst</p>\n</blockquote>\n<p>that's actually fairly straightforward I think?</p>",
        "id": 276321485,
        "sender_full_name": "lcnr",
        "timestamp": 1648036068
    },
    {
        "content": "<p>like, doable in a few hours</p>",
        "id": 276321496,
        "sender_full_name": "lcnr",
        "timestamp": 1648036075
    },
    {
        "content": "<p>Yes</p>",
        "id": 276328963,
        "sender_full_name": "oli",
        "timestamp": 1648040432
    },
    {
        "content": "<p>Likely a few days total work time but the initial PR should be simple enough</p>",
        "id": 276329125,
        "sender_full_name": "oli",
        "timestamp": 1648040508
    },
    {
        "content": "<blockquote>\n<p>Can we explore the space of designs that don't evaluate but equate expressions?</p>\n</blockquote>\n<p>how does that work when unifying <code>generic_fn::&lt;N&gt;() + 3</code> with let's say <code>7</code></p>",
        "id": 276330164,
        "sender_full_name": "lcnr",
        "timestamp": 1648041042
    },
    {
        "content": "<p>once <code>N</code> is concrete?</p>",
        "id": 276330176,
        "sender_full_name": "lcnr",
        "timestamp": 1648041046
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> my take is that I would love to do that</p>",
        "id": 276364138,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1648053948
    },
    {
        "content": "<p>(adding CG)</p>",
        "id": 276364146,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1648053951
    },
    {
        "content": "<p>it's kind of exactly what I feel I need to be able to explain how it fits into things in the \"big picture\"</p>",
        "id": 276364179,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1648053961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/equation.20solving.20in.20const.20generics.20.28say.20no.20to.20SFINAE.20try.202.29/near/276320077\">said</a>:</p>\n<blockquote>\n<p>If we have two impls that we want to check for overlap, like <code>impl&lt;const N: usize&gt; Default for [T; N + 1]</code> and one for <code>impl Default for [T; 0]</code>, what we actually want to prove is <code>0 != N + 1</code></p>\n</blockquote>\n<p>I've been wondering about this for a while. I think this is definitely intuitively the right way to write such patterns, but it hits a semantic issue in that <code>usize</code> is not \"peano natural numbers\", <code>0 != N + 1</code> does not (necessarily) hold since <code>usize::MAX + 1 = 0</code> on release</p>",
        "id": 276449253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648113858
    },
    {
        "content": "<p>perhaps a more sensible model is something like a const <code>match</code> expression, although this gets syntactically weird. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Default</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">.</span><span class=\"n\">checked_sub</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">default</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">default</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276449610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648114097
    },
    {
        "content": "<blockquote>\n<p>I've been wondering about this for a while. I think this is definitely intuitively the right way to write such patterns, but it hits a semantic issue in that <code>usize</code> is not \"peano natural numbers\", <code>0 != N + 1</code> does not (necessarily) hold since <code>usize::MAX + 1 = 0</code> on release</p>\n</blockquote>\n<p>const items always have overflow checks on, sadly const fn do not. I wonder if we could fix that</p>",
        "id": 276451753,
        "sender_full_name": "oli",
        "timestamp": 1648115416
    },
    {
        "content": "<blockquote>\n<p>sadly const fn do not.</p>\n</blockquote>\n<p>not even during ctfe? don't we have different mir for ctfe</p>",
        "id": 276456277,
        "sender_full_name": "lcnr",
        "timestamp": 1648117954
    },
    {
        "content": "<p>we could at least reasonable keep the overflow checks until the <code>mir_for_ctfe</code></p>",
        "id": 276456302,
        "sender_full_name": "lcnr",
        "timestamp": 1648117970
    },
    {
        "content": "<p>and only remove them later during optimizations</p>",
        "id": 276456308,
        "sender_full_name": "lcnr",
        "timestamp": 1648117976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/equation.20solving.20in.20const.20generics.20.28say.20no.20to.20SFINAE.20try.202.29/near/276449610\">said</a>:</p>\n<blockquote>\n<p>perhaps a more sensible model is something like a const <code>match</code> expression, although this gets syntactically weird.</p>\n</blockquote>\n<p>Maybe this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Default</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Default</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">Default</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276456457,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648118079
    },
    {
        "content": "<p>Carving out the subset of interest is only half of the problem though. You can make subsets using where clauses, but then you want to know that in that subset certain operations are valid and live in other subsets. (This is getting <em>really</em> close to dependent types.) If you have <code>N in 1..</code> then this should imply that <code>N - 1</code> is a valid expression without having to bubble up some constraint to the caller. This is problematic in general for the same reason that it is hard to statically check that <code>if foo.is_some() { foo.unwrap() } else { 0 }</code> doesn't panic. Using <code>checked_sub(1)</code> and a match ties the two aspects together so that the compiler doesn't need to do linear algebra to compile the code</p>",
        "id": 276465223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648123456
    }
]