[
    {
        "content": "<p>new topic to discuss how this should be implemented. Relevant discussions in <a href=\"https://github.com/rust-lang/rust/issues/68436\">#68436</a> and <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstEvaluatable.60.20generic.20functions/\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstEvaluatable.60.20generic.20functions/</a>.</p>",
        "id": 204812573,
        "sender_full_name": "lcnr",
        "timestamp": 1595518023
    },
    {
        "content": "<blockquote>\n<p>you can implement the required_const_bounds by creating a query that runs on mir_const or mir_validated</p>\n</blockquote>\n<p>I am actually not quite sure what you mean there</p>",
        "id": 204812626,
        "sender_full_name": "lcnr",
        "timestamp": 1595518051
    },
    {
        "content": "<p>so my idea would be the following</p>",
        "id": 204812641,
        "sender_full_name": "lcnr",
        "timestamp": 1595518058
    },
    {
        "content": "<p>for each const in the where bounds, add a <code>PredicateKind::ConstEvaluatable</code> to <code>param_env.caller_bounds</code></p>",
        "id": 204812794,
        "sender_full_name": "lcnr",
        "timestamp": 1595518120
    },
    {
        "content": "<p>and if we then have a <code>PredicateKind::ConstEvaluatable</code> in the body, we first check if it is const evaluatable using the implementation in <a href=\"https://github.com/rust-lang/rust/issues/74595\">#74595</a></p>",
        "id": 204812909,
        "sender_full_name": "lcnr",
        "timestamp": 1595518186
    },
    {
        "content": "<p>and if this is not the case, we check if a <code>PredicateKind::ConstEvaluatable</code> exists in the caller bounds whose mir can be \"unified\" with the mir of what we want to check</p>",
        "id": 204813063,
        "sender_full_name": "lcnr",
        "timestamp": 1595518251
    },
    {
        "content": "<hr>",
        "id": 204813248,
        "sender_full_name": "lcnr",
        "timestamp": 1595518360
    },
    {
        "content": "<p>What I am now still unsure of is how can we correctly \"unify\" mir here</p>",
        "id": 204813439,
        "sender_full_name": "lcnr",
        "timestamp": 1595518452
    },
    {
        "content": "<p>I do <strong>not</strong> want to use <code>optimized_mir</code> because that makes us dependent on optimizations during typeck, which is bad™</p>",
        "id": 204813559,
        "sender_full_name": "lcnr",
        "timestamp": 1595518522
    },
    {
        "content": "<p>So we probably need a query as described by <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> which we call for anon consts before stealing either <code>mir_const</code> or <code>mir_validated</code></p>",
        "id": 204813712,
        "sender_full_name": "lcnr",
        "timestamp": 1595518580
    },
    {
        "content": "<p>whose result we then compare here to check if an expression is implied by the where bounds</p>",
        "id": 204813764,
        "sender_full_name": "lcnr",
        "timestamp": 1595518614
    },
    {
        "content": "<p>What should that query return?</p>",
        "id": 204813946,
        "sender_full_name": "lcnr",
        "timestamp": 1595518705
    },
    {
        "content": "<p>Just cloning the given mir and then walking that seems okish, if quite bad for perf</p>",
        "id": 204814169,
        "sender_full_name": "lcnr",
        "timestamp": 1595518813
    },
    {
        "content": "<p>Also, how stable is the generated mir? I kind of fear that 2 slightly different expressions end up having the same mir and breaking due to internal changes</p>",
        "id": 204814629,
        "sender_full_name": "lcnr",
        "timestamp": 1595519060
    },
    {
        "content": "<p>there's no need to clone, you can just process that generated MIR and emit the list of where clauses that must be held</p>",
        "id": 204820644,
        "sender_full_name": "oli",
        "timestamp": 1595521867
    },
    {
        "content": "<p>not sure what format these should be in, but probably something like <code>Predicates</code> iirc?</p>",
        "id": 204820700,
        "sender_full_name": "oli",
        "timestamp": 1595521894
    },
    {
        "content": "<blockquote>\n<p>emit the list of where clauses</p>\n</blockquote>\n<p>So if we have <code>[0; std::mem::size_of::&lt;T&gt; + N + 7]</code></p>",
        "id": 204820825,
        "sender_full_name": "lcnr",
        "timestamp": 1595521933
    },
    {
        "content": "<p>I would expect us to require exactly one where clause, being <code>ConstEvaluatable(std::mem::size_of::&lt;T&gt; + N + 7)</code></p>",
        "id": 204820883,
        "sender_full_name": "lcnr",
        "timestamp": 1595521962
    },
    {
        "content": "<p>yes</p>",
        "id": 204820893,
        "sender_full_name": "oli",
        "timestamp": 1595521968
    },
    {
        "content": "<p>that's what I'd expect, too</p>",
        "id": 204820924,
        "sender_full_name": "oli",
        "timestamp": 1595521986
    },
    {
        "content": "<p>so you can even just return a <code>&amp;'tcx [&amp;'tcx ty::Const&lt;'tcx&gt;]</code></p>",
        "id": 204820969,
        "sender_full_name": "oli",
        "timestamp": 1595522007
    },
    {
        "content": "<p>?</p>",
        "id": 204821029,
        "sender_full_name": "lcnr",
        "timestamp": 1595522034
    },
    {
        "content": "<p>you want to return <code>ty::Const</code> here</p>",
        "id": 204821077,
        "sender_full_name": "lcnr",
        "timestamp": 1595522043
    },
    {
        "content": "<p>wait. First of all, on what do you want to call this query?</p>",
        "id": 204821106,
        "sender_full_name": "lcnr",
        "timestamp": 1595522056
    },
    {
        "content": "<p>on the <code>DefId</code> of the function</p>",
        "id": 204821127,
        "sender_full_name": "oli",
        "timestamp": 1595522066
    },
    {
        "content": "<p>well, when walking the MIR, what do you do? you collect all constants and want them as where clauses</p>",
        "id": 204821147,
        "sender_full_name": "oli",
        "timestamp": 1595522078
    },
    {
        "content": "<p>I want to only walk the mir of <code>std::mem::size_of::&lt;T&gt; + N + 7</code> here</p>",
        "id": 204821202,
        "sender_full_name": "lcnr",
        "timestamp": 1595522111
    },
    {
        "content": "<p>huh wait what?</p>",
        "id": 204821214,
        "sender_full_name": "oli",
        "timestamp": 1595522120
    },
    {
        "content": "<p>so when typechecking a function, we end up with a bunch of <code>PredicateKind::ConstEvaluatable</code> for every unevaluated constant</p>",
        "id": 204821237,
        "sender_full_name": "lcnr",
        "timestamp": 1595522134
    },
    {
        "content": "<blockquote>\n<p>lcnr: and if we then have a PredicateKind::ConstEvaluatable in the body, we first check if it is const evaluatable using the implementation in <a href=\"https://github.com/rust-lang/rust/issues/74595\">#74595</a></p>\n<p>lcnr: and if this is not the case, we check if a PredicateKind::ConstEvaluatable exists in the caller bounds whose mir can be \"unified\" with the mir of what we want to check</p>\n</blockquote>",
        "id": 204821361,
        "sender_full_name": "lcnr",
        "timestamp": 1595522176
    },
    {
        "content": "<p>oh, I got a bit confused there, I thought the query was gonna run on the function</p>",
        "id": 204821363,
        "sender_full_name": "oli",
        "timestamp": 1595522177
    },
    {
        "content": "<p>so we don't miss any anon consts</p>",
        "id": 204821373,
        "sender_full_name": "oli",
        "timestamp": 1595522182
    },
    {
        "content": "<p>Hmm, that seems weird to me considering that we already have most of the infrastructure for const wf implemented</p>",
        "id": 204821502,
        "sender_full_name": "lcnr",
        "timestamp": 1595522245
    },
    {
        "content": "<p>yea</p>",
        "id": 204821522,
        "sender_full_name": "oli",
        "timestamp": 1595522254
    },
    {
        "content": "<p>I just misunderstood</p>",
        "id": 204821530,
        "sender_full_name": "oli",
        "timestamp": 1595522258
    },
    {
        "content": "<p>didn't think this through and just went with what I understood</p>",
        "id": 204821545,
        "sender_full_name": "oli",
        "timestamp": 1595522269
    },
    {
        "content": "<p>So e.g. walking mir also has to consider trait bounds which were generated during typeck which I don't think is that easily doable</p>",
        "id": 204821607,
        "sender_full_name": "lcnr",
        "timestamp": 1595522286
    },
    {
        "content": "<p>so... you basically want a query that returns <code>true</code> when the anon const uses generics</p>",
        "id": 204821665,
        "sender_full_name": "oli",
        "timestamp": 1595522316
    },
    {
        "content": "<p>We already have that in <a href=\"https://github.com/rust-lang/rust/issues/74595\">#74595</a>, don't we?</p>",
        "id": 204821716,
        "sender_full_name": "lcnr",
        "timestamp": 1595522348
    },
    {
        "content": "<p>I want to check if a anon const is found in the caller bounds of a given function</p>",
        "id": 204821772,
        "sender_full_name": "lcnr",
        "timestamp": 1595522385
    },
    {
        "content": "<p>jop, but you need the MIR, and I don't know if computing the MIR for anon consts of a function causes cylces during typeck</p>",
        "id": 204821782,
        "sender_full_name": "oli",
        "timestamp": 1595522392
    },
    {
        "content": "<p>We already have to built the MIR to check that rn <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> so that won't cause additional cycle errors here</p>",
        "id": 204821881,
        "sender_full_name": "lcnr",
        "timestamp": 1595522423
    },
    {
        "content": "<p>I think the only missing piece for me is how to check if two different MIR are equal</p>",
        "id": 204822157,
        "sender_full_name": "lcnr",
        "timestamp": 1595522533
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204822271,
        "sender_full_name": "lcnr",
        "timestamp": 1595522584
    },
    {
        "content": "<p>ok, cool</p>",
        "id": 204822273,
        "sender_full_name": "oli",
        "timestamp": 1595522584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>  already sketched that out</p>",
        "id": 204822295,
        "sender_full_name": "oli",
        "timestamp": 1595522594
    },
    {
        "content": "<p>so how can I check if the anon const in the where bound is the same as the anon const in repeat expr</p>",
        "id": 204822314,
        "sender_full_name": "lcnr",
        "timestamp": 1595522604
    },
    {
        "content": "<p>iirc it's to implement <code>TyRelation</code> for, but it may have been some other relation/comparison thing</p>",
        "id": 204822422,
        "sender_full_name": "oli",
        "timestamp": 1595522650
    },
    {
        "content": "<p>searching</p>",
        "id": 204822437,
        "sender_full_name": "oli",
        "timestamp": 1595522660
    },
    {
        "content": "<p>yea, <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/relate/trait.Relate.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/relate/trait.Relate.html</a></p>",
        "id": 204822752,
        "sender_full_name": "oli",
        "timestamp": 1595522830
    },
    {
        "content": "<p>just checking local types and all basic block contents likely suffices, but better double check that</p>",
        "id": 204822862,
        "sender_full_name": "oli",
        "timestamp": 1595522888
    },
    {
        "content": "<p>basically skip all things like variable names, debug info and other things that don't influence the semantics of the MIR</p>",
        "id": 204822912,
        "sender_full_name": "oli",
        "timestamp": 1595522917
    },
    {
        "content": "<p>can we implement a desugaring manually and get the same mir?</p>",
        "id": 204822950,
        "sender_full_name": "lcnr",
        "timestamp": 1595522942
    },
    {
        "content": "<p>so e.g. reimplement a <code>for</code> loop using <code>while</code></p>",
        "id": 204822983,
        "sender_full_name": "lcnr",
        "timestamp": 1595522958
    },
    {
        "content": "<p>likely</p>",
        "id": 204823016,
        "sender_full_name": "oli",
        "timestamp": 1595522979
    },
    {
        "content": "<p>but not if you check the relevant info in MIR</p>",
        "id": 204823047,
        "sender_full_name": "oli",
        "timestamp": 1595522999
    },
    {
        "content": "<p>yeah, that's probably the hard part <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I really don't want to leak implementation details this way</p>",
        "id": 204823133,
        "sender_full_name": "lcnr",
        "timestamp": 1595523029
    },
    {
        "content": "<p>I guess we could compute equivalence on the HIR... Not sure, let's let some others weigh in</p>",
        "id": 204823608,
        "sender_full_name": "oli",
        "timestamp": 1595523262
    },
    {
        "content": "<p>hir is also partially desugared afaik (but it should be less dangerous than mir)</p>",
        "id": 204823986,
        "sender_full_name": "lcnr",
        "timestamp": 1595523471
    },
    {
        "content": "<p>we might also start by slowly increasing the working subset, so it should be fairly safe to only start with builtin integer arithmetic</p>",
        "id": 204824175,
        "sender_full_name": "lcnr",
        "timestamp": 1595523545
    },
    {
        "content": "<p>I have a solution for you, gimme a sec</p>",
        "id": 204824207,
        "sender_full_name": "oli",
        "timestamp": 1595523566
    },
    {
        "content": "<p>ok</p>",
        "id": 204824852,
        "sender_full_name": "oli",
        "timestamp": 1595523860
    },
    {
        "content": "<p>so.</p>",
        "id": 204824856,
        "sender_full_name": "oli",
        "timestamp": 1595523863
    },
    {
        "content": "<p>we can go several evil ways, and all of them are cool</p>",
        "id": 204824874,
        "sender_full_name": "oli",
        "timestamp": 1595523874
    },
    {
        "content": "<p>Evil way number 1 (the one that I'm all for, but has maybe questions on how to extend in the future): symbolically execute the MIR of the anon const and generate a symbol (term tree) that represents that MIR abstractly</p>",
        "id": 204824962,
        "sender_full_name": "oli",
        "timestamp": 1595523928
    },
    {
        "content": "<p>Evil way number 2: similar to number 1, but instead of doing symbolic execution, build an SSA dependency graph and  use that as the abstract representation of the MIR</p>",
        "id": 204825085,
        "sender_full_name": "oli",
        "timestamp": 1595523973
    },
    {
        "content": "<p>Both ways just error out whenever you hit a terminator other than <code>Goto</code>, <code>Return</code> or <code>Assert</code>.</p>",
        "id": 204825154,
        "sender_full_name": "oli",
        "timestamp": 1595523997
    },
    {
        "content": "<p>oh, function calls are also ok</p>",
        "id": 204825188,
        "sender_full_name": "oli",
        "timestamp": 1595524018
    },
    {
        "content": "<p>I am a bit lost on this conversation. Can I ask about the basics a little bit?<br>\nLike (1): why do we want to know if a const generic type is well formed before computing it? Apart from performance reasons. I ask because if I understand it correctly, we can catch all ill-formed cases at monomorphization time, right?<br>\nAnd to accompany that, (2): is it feasible <em>at all</em> to <strong>not</strong> bubble up the const expressions in <code>where</code> clauses (i.e. infer them) and at the same time, decide if the type is well formed? And is it possible to do so <strong>before monomorphization</strong>?</p>",
        "id": 204826081,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595524512
    },
    {
        "content": "<p>we can autogenerate the where bounds</p>",
        "id": 204826343,
        "sender_full_name": "oli",
        "timestamp": 1595524670
    },
    {
        "content": "<p>so you don't need to write them</p>",
        "id": 204826396,
        "sender_full_name": "oli",
        "timestamp": 1595524683
    },
    {
        "content": "<p>that means that changing the body of a function will be semver breaking</p>",
        "id": 204826425,
        "sender_full_name": "oli",
        "timestamp": 1595524705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/204826425\">said</a>:</p>\n<blockquote>\n<p>that means that changing the body of a function will be semver breaking</p>\n</blockquote>\n<p>This has strong implications upon RFC 2000 then, right? In the sense that the feature that const generics will be has some usability constraints that have to be discussed</p>",
        "id": 204826660,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595524869
    },
    {
        "content": "<p>/ addressed</p>",
        "id": 204826668,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595524877
    },
    {
        "content": "<p>On the other hand... for which primitive types is this a concern? Only <code>usize</code> and <code>isize</code>, right?</p>",
        "id": 204826947,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595525023
    },
    {
        "content": "<p>Because for overflowing arithmetic in <code>uX</code> and <code>iX</code>, the API owner could define what semantics to use (clamping arithmetic =&gt; <code>a::MAX + 1</code> results in <code>a::MAX</code>, and cyclic arithmetic, where <code>a::MAX + 1</code> results in <code>a::MIN</code>.</p>",
        "id": 204827326,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595525242
    },
    {
        "content": "<p>Unless I'm missing other malformed operations, which I probably am tbh</p>",
        "id": 204827376,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595525272
    },
    {
        "content": "<p>Also, this is sort of... a weird problem. Like, this suppossedly only affects very extreme cases, right? Maybe we could address those issues by relaxing some constraint whenever we hit those cases. Like, this is probably a bad fallback, but imagine that if you went past <code>uX::MAX</code>, you could fallback into a type with the same semantics (up to memory layout differences) but with different layout, like <code>u(2X)</code>.</p>",
        "id": 204827572,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595525399
    },
    {
        "content": "<p>I dunno. Maybe it's not that weird. Maybe you can just bubble up the operations and it'll feel natural. But that's how I feel about this topic.</p>",
        "id": 204827696,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595525460
    },
    {
        "content": "<p><em>(bbl, lunch time)</em></p>",
        "id": 204827785,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595525519
    },
    {
        "content": "<p>sry for just skipping over the comments by <span class=\"user-mention silent\" data-user-id=\"212698\">Félix Fischer</span> here. i don't have a good and satisfying answer for this myself, and find it fairly exhausting</p>",
        "id": 204828552,
        "sender_full_name": "lcnr",
        "timestamp": 1595525924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/204824962\">said</a>:</p>\n<blockquote>\n<p>Evil way number 1 (the one that I'm all for, but has maybe questions on how to extend in the future): symbolically execute the MIR of the anon const and generate a symbol (term tree) that represents that MIR abstractly</p>\n</blockquote>\n<p>does this solve problems we have with looking at mir directly?</p>",
        "id": 204828637,
        "sender_full_name": "lcnr",
        "timestamp": 1595525976
    },
    {
        "content": "<blockquote>\n<p>oh, function calls are also ok</p>\n</blockquote>\n<p>so we pretty much require any more complex operations to be inside of functions</p>",
        "id": 204828884,
        "sender_full_name": "lcnr",
        "timestamp": 1595526092
    },
    {
        "content": "<p>or constants / associated consts</p>",
        "id": 204828902,
        "sender_full_name": "lcnr",
        "timestamp": 1595526103
    },
    {
        "content": "<p>which actually looks like a good solution to me</p>",
        "id": 204828924,
        "sender_full_name": "lcnr",
        "timestamp": 1595526122
    },
    {
        "content": "<p>I think</p>",
        "id": 204828965,
        "sender_full_name": "lcnr",
        "timestamp": 1595526125
    },
    {
        "content": "<p>so for things like <code>N + M + 4</code> we don't have to worry about syntactic sugar and stuff</p>",
        "id": 204829050,
        "sender_full_name": "lcnr",
        "timestamp": 1595526173
    },
    {
        "content": "<p>and for more complex operations methods are more useful anyways, as we otherwise have to duplicate a lot of code</p>",
        "id": 204829085,
        "sender_full_name": "lcnr",
        "timestamp": 1595526199
    },
    {
        "content": "<p>So this would mean that const generic expressions may contain basic arithmetic and calls to arbitrary <code>const fn</code>, which should be fairly simple to learn <em>for users</em></p>",
        "id": 204829644,
        "sender_full_name": "lcnr",
        "timestamp": 1595526441
    },
    {
        "content": "<p>So to get this forward we probably have to do the following:</p>\n<ol>\n<li>write a short summary of why this is needed (which should hopefully answer <span class=\"user-mention silent\" data-user-id=\"212698\">Félix Fischer</span>s questions)</li>\n<li>write a short summary of how we want to implement this (what I wrote above, but slightly cleaner)</li>\n<li>get the <code>const-eval</code> team and <span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> + <span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> to agree that this is the right way forward</li>\n<li>lang team + compiler MCP</li>\n<li>implement</li>\n</ol>",
        "id": 204830403,
        "sender_full_name": "lcnr",
        "timestamp": 1595526730
    },
    {
        "content": "<p>so I personally feel motivated to push 2-5 forward <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> can I get you to write a summary for 1?</p>",
        "id": 204830496,
        "sender_full_name": "lcnr",
        "timestamp": 1595526779
    },
    {
        "content": "<p>or firstly, do you also think this is the right approach. I hope I didn't misunderstand what you wanted to achieve here</p>",
        "id": 204830554,
        "sender_full_name": "lcnr",
        "timestamp": 1595526810
    },
    {
        "content": "<p>yeaaa. I owe you a summary, the tab is still open</p>",
        "id": 204830658,
        "sender_full_name": "oli",
        "timestamp": 1595526851
    },
    {
        "content": "<p>ok, yea that plan and your comments above it make total sense</p>",
        "id": 204830766,
        "sender_full_name": "oli",
        "timestamp": 1595526909
    },
    {
        "content": "<p>I'll start writing that summary now</p>",
        "id": 204830784,
        "sender_full_name": "oli",
        "timestamp": 1595526916
    },
    {
        "content": "<p>It's okay <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>, don't worry, take care of yourself <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 204832130,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595527469
    },
    {
        "content": "<p>And fwiw, I don't think any programming language community has tried to answer these questions before? Not with Rust's restrictions, at any rate (I'm thinking that probably some dependently typed langs have dwelved into this, but again as far as I'm aware, they have less restrictions than Rust does)</p>",
        "id": 204832265,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595527545
    },
    {
        "content": "<p>(After reading the rest): I like your plan <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 204832623,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595527744
    },
    {
        "content": "<p>Summary written... time to turn off the internet and hope I'm still happy reading notifications tomorrow</p>",
        "id": 204843505,
        "sender_full_name": "oli",
        "timestamp": 1595532614
    },
    {
        "content": "<p>:)</p>",
        "id": 204843992,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595532902
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>!</p>",
        "id": 204844001,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595532908
    },
    {
        "content": "<p>I'm now reading at right after Proposal no. 1, and I have to say, this has been really illuminating so far. Thank you!!</p>",
        "id": 204844133,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595532971
    },
    {
        "content": "<p>Oli's summary can be found here: <a href=\"https://github.com/rust-lang/rust/issues/68436#issuecomment-663190861\">summary</a></p>",
        "id": 204844169,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595533006
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"212698\">@Félix Fischer</span> <a href=\"https://github.com/rust-lang/rust/issues/68436#issuecomment-663200323\">https://github.com/rust-lang/rust/issues/68436#issuecomment-663200323</a> oh no</p>",
        "id": 204846037,
        "sender_full_name": "lcnr",
        "timestamp": 1595534069
    },
    {
        "content": "<p>that's something I didn't think about before</p>",
        "id": 204846067,
        "sender_full_name": "lcnr",
        "timestamp": 1595534084
    },
    {
        "content": "<p>so you can \"fix\" things like this by using</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo_wf_condition</span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>as the wf condition</p>",
        "id": 204846298,
        "sender_full_name": "lcnr",
        "timestamp": 1595534205
    },
    {
        "content": "<p>but hmm, I don't think control flow aware bounds work in the general case, good old mr turing is at it once again here</p>",
        "id": 204846509,
        "sender_full_name": "lcnr",
        "timestamp": 1595534299
    },
    {
        "content": "<p>wait, your function is fine</p>",
        "id": 204846555,
        "sender_full_name": "lcnr",
        "timestamp": 1595534329
    },
    {
        "content": "<p>we only require expressions using const parameters to be wf if they are used inside of types</p>",
        "id": 204846577,
        "sender_full_name": "lcnr",
        "timestamp": 1595534344
    },
    {
        "content": "<p>so you have to add 0 bounds to foo</p>",
        "id": 204846594,
        "sender_full_name": "lcnr",
        "timestamp": 1595534357
    },
    {
        "content": "<p>you would have to add bounds when using foo in an array length</p>",
        "id": 204846613,
        "sender_full_name": "lcnr",
        "timestamp": 1595534371
    },
    {
        "content": "<p>at which point you can just bind on <code>foo</code> itself</p>",
        "id": 204846642,
        "sender_full_name": "lcnr",
        "timestamp": 1595534387
    },
    {
        "content": "<p>and you can't really \"conditionally use a type\", so you would probably always directly use <code>foo</code> as a bound</p>",
        "id": 204846758,
        "sender_full_name": "lcnr",
        "timestamp": 1595534426
    },
    {
        "content": "<p>well, answered on the issue itself <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 204848347,
        "sender_full_name": "lcnr",
        "timestamp": 1595535328
    },
    {
        "content": "<p>Yas, now it's a lot clearer. Thanks <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span></p>",
        "id": 204849854,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595536182
    },
    {
        "content": "<p>:)</p>",
        "id": 204849856,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595536185
    },
    {
        "content": "<p>Will still have to clean this up, but a basic version for the second bullet point can be found here: <a href=\"https://hackmd.io/z7LKv6WKRkiw2WC7KDkvYw?view\">https://hackmd.io/z7LKv6WKRkiw2WC7KDkvYw?view</a></p>\n<p>Still have to proof read it a few times and do some cleanup here</p>",
        "id": 204883025,
        "sender_full_name": "lcnr",
        "timestamp": 1595571715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> that's why we want to limit this to basic math and assignments for now. This way we don't really have to care about desugarings. If we want to be super super strict, we can also just allow const fn calls and expect you to move more complex things to function calls</p>",
        "id": 204905928,
        "sender_full_name": "oli",
        "timestamp": 1595590899
    },
    {
        "content": "<p>(or introduce generic constants)</p>",
        "id": 204905998,
        "sender_full_name": "oli",
        "timestamp": 1595590937
    },
    {
        "content": "<p>but I think starting out with a version that supports math and no control flow makes sense</p>",
        "id": 204906033,
        "sender_full_name": "oli",
        "timestamp": 1595590968
    },
    {
        "content": "<p>you can still get control flow by using const fns</p>",
        "id": 204906037,
        "sender_full_name": "oli",
        "timestamp": 1595590977
    },
    {
        "content": "<p>Oh... I should read the entire post before commenting</p>",
        "id": 204906077,
        "sender_full_name": "oli",
        "timestamp": 1595591026
    },
    {
        "content": "<p>sorry</p>",
        "id": 204906079,
        "sender_full_name": "oli",
        "timestamp": 1595591027
    },
    {
        "content": "<p>the terminator list should contain <code>Call</code>, too</p>",
        "id": 204906141,
        "sender_full_name": "oli",
        "timestamp": 1595591059
    },
    {
        "content": "<p>I'm not sure if a query taking the param env scales well from the query system perspective. Instead I propose to add a query going from <code>DefId</code> to the abstract representation and then appyling that to the anon const in the param env, the anon const in the body and relating those abstract things</p>",
        "id": 204906502,
        "sender_full_name": "oli",
        "timestamp": 1595591409
    },
    {
        "content": "<p>so you basically get a <code>query anon_to_abstract(DefId) -&gt; AbstractConst</code></p>",
        "id": 204906522,
        "sender_full_name": "oli",
        "timestamp": 1595591435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/204906522\">said</a>:</p>\n<blockquote>\n<p>so you basically get a <code>query anon_to_abstract(DefId) -&gt; AbstractConst</code></p>\n</blockquote>\n<p>Thanks for looking at this. </p>\n<p>That's what I meant, I want to use  <code>query anon_to_abstract(DefId) -&gt; AbstractConst</code> or more likely <code>query anon_to_abstract(DefId) -&gt; Option&lt;AbstractConst&gt;</code>. We can then cache this on disk and don't have to worry about invalidating other queries as often</p>",
        "id": 204916138,
        "sender_full_name": "lcnr",
        "timestamp": 1595598049
    },
    {
        "content": "<p>Will update this, if you want I can also give you editing permission</p>",
        "id": 204916203,
        "sender_full_name": "lcnr",
        "timestamp": 1595598102
    },
    {
        "content": "<p>the hackmd is now just part of <code>RustLang</code> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 204918166,
        "sender_full_name": "lcnr",
        "timestamp": 1595599111
    },
    {
        "content": "<p>So, <code>Option</code> because the query is fallible, but only fallible in cases of errors, right?</p>",
        "id": 204919019,
        "sender_full_name": "oli",
        "timestamp": 1595599473
    },
    {
        "content": "<p>In that case we can move to <code>Result&lt;AbstractConst, ErrorReported&gt;</code></p>",
        "id": 204919044,
        "sender_full_name": "oli",
        "timestamp": 1595599492
    },
    {
        "content": "<p>The abstract representations of constants in the mir bodies don't need to be preserved cross crate, right? only those in the where bounds</p>",
        "id": 204919564,
        "sender_full_name": "oli",
        "timestamp": 1595599764
    },
    {
        "content": "<p>we could have two queries in that case, which should cut down the new metadata from this by about half, when compared to the full version</p>",
        "id": 204919620,
        "sender_full_name": "oli",
        "timestamp": 1595599794
    },
    {
        "content": "<p>We only need <code>AbstractConst</code> for polymorphic anonymous constants</p>",
        "id": 204923856,
        "sender_full_name": "lcnr",
        "timestamp": 1595601703
    },
    {
        "content": "<p>We can either check this before calling <code>anon_to_abstract</code>, in which case the calling query probably depends on <code>tcx.def_kind</code></p>",
        "id": 204923964,
        "sender_full_name": "lcnr",
        "timestamp": 1595601736
    },
    {
        "content": "<p>or check this inside of <code>anon_to_abstract</code> and return a dummy value (None) in this case</p>",
        "id": 204924002,
        "sender_full_name": "lcnr",
        "timestamp": 1595601753
    },
    {
        "content": "<p>So checking this inside of <code>anon_to_abstract</code> seems both more error resistant, i.e. if we end up with an inconsistent <code>ConstEvaluatable</code> due to a previous error and then call <code>anon_to_abstract</code> we would ICE if we didn't call it inside of <code>mir_const</code> as the mir is now stolen</p>",
        "id": 204924305,
        "sender_full_name": "lcnr",
        "timestamp": 1595601886
    },
    {
        "content": "<p>and might be more efficient, as we don't have to recompute <code>mir_const</code> if the <code>def_kind</code> changes (we probably have to do so anyways because when does the <code>def_kind</code> change and the mir stays exactly the same) so that point is fairly moot</p>",
        "id": 204924521,
        "sender_full_name": "lcnr",
        "timestamp": 1595601979
    },
    {
        "content": "<blockquote>\n<p>but only fallible in cases of errors</p>\n</blockquote>\n<p>We can either also return <code>None</code> here, or actually use <code>Result&lt;Option&lt;AbstractConst&gt;, ErrorReported&gt;</code></p>",
        "id": 204924675,
        "sender_full_name": "lcnr",
        "timestamp": 1595602048
    },
    {
        "content": "<p>I am not exactly sure how to deal with this, but that's also something which should be more clear once we actually start implementing this</p>",
        "id": 204924923,
        "sender_full_name": "lcnr",
        "timestamp": 1595602158
    },
    {
        "content": "<p>sgtm</p>",
        "id": 204927127,
        "sender_full_name": "oli",
        "timestamp": 1595603092
    },
    {
        "content": "<p>The pi types rfc is a damn treat (reading this rn because I want to see how that wanted to handle this)</p>",
        "id": 204927491,
        "sender_full_name": "lcnr",
        "timestamp": 1595603278
    },
    {
        "content": "<blockquote>\n<p>it has some severe disadvantages: most importantly, the type checking becomes undecidable.</p>\n</blockquote>\n<p>rusts type checking already is <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>",
        "id": 204927854,
        "sender_full_name": "lcnr",
        "timestamp": 1595603487
    },
    {
        "content": "<p>O_o?</p>",
        "id": 204927891,
        "sender_full_name": "oli",
        "timestamp": 1595603510
    },
    {
        "content": "<p><a href=\"https://www.reddit.com/r/rust/comments/5y4x9r/challenge_rusts_type_system_is_not_turing_complete/\">https://www.reddit.com/r/rust/comments/5y4x9r/challenge_rusts_type_system_is_not_turing_complete/</a></p>",
        "id": 204927997,
        "sender_full_name": "lcnr",
        "timestamp": 1595603550
    },
    {
        "content": "<p>i think somewhere in the RFC says that this already happens in the compiler</p>",
        "id": 204928092,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595603607
    },
    {
        "content": "<p>probably in the new one, the old (closed) pi types rfc did not mention it afaik. I am looking at <a href=\"https://github.com/rust-lang/rfcs/pull/1931\">https://github.com/rust-lang/rfcs/pull/1931</a> rn, I think the merged const generics rfc (rfcs/pull/2000) mostly dodges that question iirc</p>",
        "id": 204928351,
        "sender_full_name": "lcnr",
        "timestamp": 1595603731
    },
    {
        "content": "<p>i think this is the wrong topic :D</p>",
        "id": 204928398,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595603749
    },
    {
        "content": "<p>for this discussion? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> it most definitely is</p>",
        "id": 204928469,
        "sender_full_name": "lcnr",
        "timestamp": 1595603771
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 204928491,
        "sender_full_name": "lcnr",
        "timestamp": 1595603782
    },
    {
        "content": "<p>So that rfc is actually interesting here and somewhat on topic (it intruduces const wf bounds for the old pi types design)</p>",
        "id": 204929118,
        "sender_full_name": "lcnr",
        "timestamp": 1595604029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/204929118\">said</a>:</p>\n<blockquote>\n<p>So that rfc is actually interesting here and somewhat on topic (it intruduces const wf bounds for the old pi types design)</p>\n</blockquote>\n<p>with <em>that rfc</em> I meant <a href=\"https://github.com/rust-lang/rfcs/pull/1932\">https://github.com/rust-lang/rfcs/pull/1932</a></p>",
        "id": 204929907,
        "sender_full_name": "lcnr",
        "timestamp": 1595604418
    },
    {
        "content": "<p>so I think <a href=\"https://hackmd.io/z7LKv6WKRkiw2WC7KDkvYw\">https://hackmd.io/z7LKv6WKRkiw2WC7KDkvYw</a> is fine now. It isn't a master work but it should serve as a good enough summary.</p>\n<p>Anything I should still mention here/elaborate on?</p>",
        "id": 204933242,
        "sender_full_name": "lcnr",
        "timestamp": 1595606207
    },
    {
        "content": "<p>I think it's ready, too, though I don't know how detailed T-lang MCPs are supposed to be</p>",
        "id": 204935124,
        "sender_full_name": "oli",
        "timestamp": 1595607226
    },
    {
        "content": "<p>Yeah, will have to look into this and also maybe get <span class=\"user-mention silent\" data-user-id=\"256759\">boats</span>  involved then</p>",
        "id": 204935454,
        "sender_full_name": "lcnr",
        "timestamp": 1595607397
    },
    {
        "content": "<p>So, @t-compiler/const-eval, <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span></p>\n<p>@oli and me have a plan to move const wf bounds forward, the plan as well as the link to what we want to fix here can be found in <a href=\"https://hackmd.io/z7LKv6WKRkiw2WC7KDkvYw\">https://hackmd.io/z7LKv6WKRkiw2WC7KDkvYw</a></p>\n<p>In case there are any questions, concerns or suggestions here, please speak up.</p>",
        "id": 204935849,
        "sender_full_name": "lcnr",
        "timestamp": 1595607611
    },
    {
        "content": "<p>Can't ping the working group <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> not sure who else is interested in this</p>",
        "id": 204935910,
        "sender_full_name": "lcnr",
        "timestamp": 1595607648
    },
    {
        "content": "<p>what does well-formed mean in this context?</p>",
        "id": 204936136,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595607749
    },
    {
        "content": "<p>that they can be evaluated with any given concrete value</p>",
        "id": 204938182,
        "sender_full_name": "lcnr",
        "timestamp": 1595608797
    },
    {
        "content": "<p>so <code>N - 1</code> is not well formed in general, as <code>0 - 1</code> would cause a const eval error</p>",
        "id": 204938278,
        "sender_full_name": "lcnr",
        "timestamp": 1595608830
    },
    {
        "content": "<p>A good example, where requiring this is useful, is something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204938808,
        "sender_full_name": "lcnr",
        "timestamp": 1595609136
    },
    {
        "content": "<p>Is <code>Foo</code> implemented for <code>()</code>? There is certainly no where bound preventing this here</p>",
        "id": 204938909,
        "sender_full_name": "lcnr",
        "timestamp": 1595609178
    },
    {
        "content": "<p>but any code which tries to actually use this ends up with an error. This error would only happen with at least <code>cargo build</code>. <code>cargo check</code> wouldn't actually catch anything here</p>",
        "id": 204939057,
        "sender_full_name": "lcnr",
        "timestamp": 1595609276
    },
    {
        "content": "<p>Here is a more interesting example where incorrect const expressions are quite bad: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c1f6a435b64e660354935e996e80e6e8\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c1f6a435b64e660354935e996e80e6e8</a></p>",
        "id": 204940071,
        "sender_full_name": "lcnr",
        "timestamp": 1595609809
    },
    {
        "content": "<p>If we allow expressions in array lengths this can happen a lot easier, for example if one method uses <code>N - 1</code> as an array length.</p>",
        "id": 204940176,
        "sender_full_name": "lcnr",
        "timestamp": 1595609877
    },
    {
        "content": "<p>hmmm interesting</p>",
        "id": 204943412,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595611653
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 204943422,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595611658
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 204943450,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595611675
    },
    {
        "content": "<p>and how strict would this be? Should the user always add bounds to guarantee well-formedness or it is just a warning?</p>",
        "id": 204944236,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595611996
    },
    {
        "content": "<p>because that'd mean that stuff like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">duplicate</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">}]</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>would need a <code>where {2 * N &lt; usize::max_value() }</code> to be accepted by the compiler</p>",
        "id": 204944510,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595612124
    },
    {
        "content": "<p>I also have a more implementation related question, what should happen with this <code>AbstractConst</code>?</p>",
        "id": 204945079,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595612375
    },
    {
        "content": "<p>consts in the signature are automatically treated the same way as where bounds</p>",
        "id": 204945364,
        "sender_full_name": "oli",
        "timestamp": 1595612494
    },
    {
        "content": "<p>so you don't need a where bound, and if you had <code>[u32; {2 * N}]</code> in the body of the function, you'd need a <code>where (2 * N)</code> where bound</p>",
        "id": 204945488,
        "sender_full_name": "oli",
        "timestamp": 1595612546
    },
    {
        "content": "<p>you don't need to specify ranges or anything, there's no proof system checking whether your where bounds enable the constants in the body. There's \"simply\"  a system that checks that all constants in the body exist in the  where bounds, too</p>",
        "id": 204945598,
        "sender_full_name": "oli",
        "timestamp": 1595612621
    },
    {
        "content": "<p>(unless the constant contains no generics, then it is evaluated, which also satisfies well-formedness or errors)</p>",
        "id": 204945688,
        "sender_full_name": "oli",
        "timestamp": 1595612649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132916\">Christian Poveda</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20wf.20bounds.20implementation/near/204945079\">said</a>:</p>\n<blockquote>\n<p>I also have a more implementation related question, what should happen with this <code>AbstractConst</code>?</p>\n</blockquote>\n<p>that's covered in the last paragraph of the hackmd, if its use was unclear, let's extend the hackmd</p>",
        "id": 204945852,
        "sender_full_name": "oli",
        "timestamp": 1595612746
    },
    {
        "content": "<p>oh OK now I get it</p>",
        "id": 204946292,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595612998
    },
    {
        "content": "<p>so basically the idea behind <code>AbstractConst</code> is to be able to check which constants inside a function's body satisfy <code>ConstEvaluatable</code>. Is that right?</p>",
        "id": 204947027,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595613400
    },
    {
        "content": "<p>or did I misinterpret the doc?</p>",
        "id": 204947091,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595613446
    },
    {
        "content": "<p>The root idea of <code>AbstractConst</code> is that we have something that we can compare against another <code>AbstractConst</code>, because we can't really compare <code>mir::Body</code> in a useful manner. So we compute an <code>AbstractConst</code> which is similar to what you did with <code>sire</code></p>",
        "id": 204948973,
        "sender_full_name": "oli",
        "timestamp": 1595614398
    },
    {
        "content": "<p>and yes, then we use that to compare a constant's <code>AbstractConst</code> with all <code>where</code> bound <code>AbstractConst</code>s</p>",
        "id": 204949016,
        "sender_full_name": "oli",
        "timestamp": 1595614430
    },
    {
        "content": "<p>if there's a match, the constant is considered well formed</p>",
        "id": 204949029,
        "sender_full_name": "oli",
        "timestamp": 1595614441
    },
    {
        "content": "<p>Man this sounds exciting</p>",
        "id": 204950510,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595615264
    },
    {
        "content": "<p>I like it</p>",
        "id": 204950514,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595615268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> can this method be used to do CTFE check of properties of a const generic parameter?</p>",
        "id": 204952936,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616624
    },
    {
        "content": "<p>uh, what are \"properties\" in this situation?</p>",
        "id": 204952974,
        "sender_full_name": "oli",
        "timestamp": 1595616647
    },
    {
        "content": "<p>you can specify arbitrary bounds that are not required by the body</p>",
        "id": 204952980,
        "sender_full_name": "oli",
        "timestamp": 1595616657
    },
    {
        "content": "<p>just like you can specify excessive trait bounds</p>",
        "id": 204952997,
        "sender_full_name": "oli",
        "timestamp": 1595616663
    },
    {
        "content": "<p>Like for example I do <code>where (is_even(N))</code><br>\nAnd <code>is_even</code> is a function that does nothing if the number is even and panics if it is odd</p>",
        "id": 204953009,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616671
    },
    {
        "content": "<p>sure</p>",
        "id": 204953029,
        "sender_full_name": "oli",
        "timestamp": 1595616684
    },
    {
        "content": "<p>Is a <code>const fn</code>*</p>",
        "id": 204953030,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616685
    },
    {
        "content": "<p>Really??</p>",
        "id": 204953039,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616690
    },
    {
        "content": "<p>That is so fancy!</p>",
        "id": 204953048,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616695
    },
    {
        "content": "<p>I love it!</p>",
        "id": 204953059,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616703
    },
    {
        "content": "<p>you can't use this knowledge inside at compile-time except for the return value of <code>is_even(N)</code>, but you can use this knowledge arbitrarily in the runtime code</p>",
        "id": 204953145,
        "sender_full_name": "oli",
        "timestamp": 1595616746
    },
    {
        "content": "<p>I don't understand that last message at all XD</p>",
        "id": 204953219,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616811
    },
    {
        "content": "<p>Well, <code>is_even</code> in this case would not return anything</p>",
        "id": 204953239,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616825
    },
    {
        "content": "<p>It would just panic if the number is not even</p>",
        "id": 204953250,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616835
    },
    {
        "content": "<p>=&gt; giving a compile-time error</p>",
        "id": 204953295,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616846
    },
    {
        "content": "<p>Maybe instead of panicking I would do an <code>assert!</code></p>",
        "id": 204953377,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616902
    },
    {
        "content": "<p>But you get what I mean?</p>",
        "id": 204953394,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616910
    },
    {
        "content": "<p>I'd be piggybacking on the WF check to do arbitrary (CTFE-restricted) checks</p>",
        "id": 204953433,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616943
    },
    {
        "content": "<p>sure that works, my question is: what do you want to do with these checks?</p>",
        "id": 204953501,
        "sender_full_name": "oli",
        "timestamp": 1595616967
    },
    {
        "content": "<p>like what does an example (arbitrarily artificial is totally ok) look like?</p>",
        "id": 204953522,
        "sender_full_name": "oli",
        "timestamp": 1595616984
    },
    {
        "content": "<p>Ensure soundness of const-generic types at compile time</p>",
        "id": 204953547,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595616999
    },
    {
        "content": "<p>Ah okay</p>",
        "id": 204953549,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617001
    },
    {
        "content": "<p>Em</p>",
        "id": 204953551,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617002
    },
    {
        "content": "<p>So I've been wanting to do a const-generic toy thing for years now with integers and prime numbers</p>",
        "id": 204953584,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617023
    },
    {
        "content": "<p>Basically a library for computations in integers-modulo-p numbers, where p is a prime</p>",
        "id": 204953626,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617052
    },
    {
        "content": "<p>Where const generics help is in ensuring that you're never adding two integers that have a different p</p>",
        "id": 204953658,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617077
    },
    {
        "content": "<p>Right? Because 1 mod 2 is not the same as 1 mod 3</p>",
        "id": 204953717,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617093
    },
    {
        "content": "<p>oh I have a simpler example: there are certain operations that are illegal on zsts, but only exhibit bad behaviour at runtime, so you can now slap an <code>where (assert!(size_of::&lt;T&gt;() != 0))</code> on your function/datastructure</p>",
        "id": 204953735,
        "sender_full_name": "oli",
        "timestamp": 1595617106
    },
    {
        "content": "<p>Therefore adding, substracting, equality, etc, make no sense between two numbers with different p</p>",
        "id": 204953752,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617117
    },
    {
        "content": "<p>YES!</p>",
        "id": 204953781,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617135
    },
    {
        "content": "<p>That's exactly it</p>",
        "id": 204953787,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617141
    },
    {
        "content": "<p>Where it also helps with my example is with ensuring that p is a prime</p>",
        "id": 204953806,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617155
    },
    {
        "content": "<p>That way you don't have to assert it every time you create one of these numbers</p>",
        "id": 204953831,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617172
    },
    {
        "content": "<p>another thing is that we can now make <code>transmute</code> not-so-special anymore, because we can just slap <code>where (assert!(size_of::&lt;T&gt;() == size_of::&lt;U&gt;()))</code> on the intrinsic and let the regular system handle</p>",
        "id": 204953832,
        "sender_full_name": "oli",
        "timestamp": 1595617173
    },
    {
        "content": "<p>oh yea, and ranged integer types!</p>",
        "id": 204953859,
        "sender_full_name": "oli",
        "timestamp": 1595617189
    },
    {
        "content": "<p>See? This is super cool!</p>",
        "id": 204953926,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617206
    },
    {
        "content": "<p>XD</p>",
        "id": 204953930,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595617209
    },
    {
        "content": "<p>the cool thing about the transmute thing is that you can bubble this information upwards now, so you can finally use transmute on generic parameters</p>",
        "id": 204953933,
        "sender_full_name": "oli",
        "timestamp": 1595617212
    },
    {
        "content": "<p>I'm imagining a bunch of dark bounds for arrays right now</p>",
        "id": 204956825,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595618910
    },
    {
        "content": "<p>like for</p>\n<div class=\"codehilite\"><pre><span></span><code>fn split_in_half&lt;const N: usize&gt;(a: [u32; N]) -&gt; [u32; N / 2]\n</code></pre></div>",
        "id": 204956891,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595618977
    },
    {
        "content": "<p>or things like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">get</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"n\">N</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"nc\">where</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204957258,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595619213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> these transmute uses may be of interest to <span class=\"user-mention\" data-user-id=\"224872\">@Ryan Levick</span> , <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> and maybe <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> who are working on a related RFC in a WG.</p>",
        "id": 204973070,
        "sender_full_name": "pachi",
        "timestamp": 1595629713
    },
    {
        "content": "<p>const transmute? did that merge or something?</p>",
        "id": 204973117,
        "sender_full_name": "Lokathor",
        "timestamp": 1595629764
    },
    {
        "content": "<p>inside of constants and statics, I think <a href=\"https://github.com/rust-lang/rust/issues/72920\">#72920</a> is the most recent PR here</p>",
        "id": 204975813,
        "sender_full_name": "lcnr",
        "timestamp": 1595632622
    },
    {
        "content": "<p>But from what I can tell this discussion isn't really about const transmute, but instead on expressing the current bounds of <code>transmute</code> as const well-formed bounds instead of checking it as part of the intrinsic</p>",
        "id": 204976761,
        "sender_full_name": "lcnr",
        "timestamp": 1595633763
    },
    {
        "content": "<p>So with const wf bounds we will be able to write <code>fn transmute&lt;T, U&gt;(v: T) -&gt; U where (assert_eq!(std::mem::size_of::&lt;T&gt;(), std::mem::size_of::&lt;U&gt;())), { ... }</code></p>",
        "id": 204976802,
        "sender_full_name": "lcnr",
        "timestamp": 1595633838
    },
    {
        "content": "<p>which will work the same way as the current checks on transmute, but can actually be propagated upwards by functions using transmute once this lands on stable (which will take a while).</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">from_bits</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"o\">&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()))),</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204976976,
        "sender_full_name": "lcnr",
        "timestamp": 1595634046
    },
    {
        "content": "<p>This is still fairly far from getting finalized though, so we might be putting the cart in front of the horse here</p>",
        "id": 204977636,
        "sender_full_name": "lcnr",
        "timestamp": 1595634861
    },
    {
        "content": "<p>is it there an equivalent concept to specialization in this kind of bounds?</p>",
        "id": 205060957,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595785941
    },
    {
        "content": "<p>Hmm, not really <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> (edit: read the rest, this comment is somewhat misleading)</p>",
        "id": 205061445,
        "sender_full_name": "lcnr",
        "timestamp": 1595786857
    },
    {
        "content": "<p>So all const wf bounds will be opaque and will always be assumed to be potentially overlapping, so the following will not work</p>",
        "id": 205061489,
        "sender_full_name": "lcnr",
        "timestamp": 1595786887
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 205061502,
        "sender_full_name": "lcnr",
        "timestamp": 1595786949
    },
    {
        "content": "<p>In terms of how this will interact with specialization, it will probably work like others bound</p>",
        "id": 205061557,
        "sender_full_name": "lcnr",
        "timestamp": 1595787025
    },
    {
        "content": "<p>So it should be possible to write the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">default</span> <span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;default&quot;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)),</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;specialized&quot;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 205061573,
        "sender_full_name": "lcnr",
        "timestamp": 1595787112
    },
    {
        "content": "<p>You can mostly specialize here by just branching on const values though, so that's always an option:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;Hey&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;Ho&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 205061692,
        "sender_full_name": "lcnr",
        "timestamp": 1595787288
    },
    {
        "content": "<p>Ohh!</p>",
        "id": 205062055,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595787959
    },
    {
        "content": "<p>Branching is a really good idea</p>",
        "id": 205062092,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595787966
    },
    {
        "content": "<p>Because with compile-time opts the branching can be eliminated <span aria-label=\"rainbow\" class=\"emoji emoji-1f308\" role=\"img\" title=\"rainbow\">:rainbow:</span><span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>",
        "id": 205062096,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595787988
    },
    {
        "content": "<p>I'm really liking this</p>",
        "id": 205062101,
        "sender_full_name": "Christian Poveda",
        "timestamp": 1595787999
    },
    {
        "content": "<p>(Me too!)</p>",
        "id": 205062105,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1595788020
    },
    {
        "content": "<p>I also just realized that this should be the same as const equality checks, i.e. this is a way to compare two const expressions, so we should also be able to allow the following with this <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> we better get this right <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 205476289,
        "sender_full_name": "lcnr",
        "timestamp": 1596114760
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">test</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 205476347,
        "sender_full_name": "lcnr",
        "timestamp": 1596114784
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"256759\">@boats</span>, it would seem really weird to be able to equate two constants for the sake of const well-formedness while not being able to unify them during typeck</p>",
        "id": 205476791,
        "sender_full_name": "lcnr",
        "timestamp": 1596114978
    },
    {
        "content": "<p>What's appropriate here if we want to implement this from the view of the lang team? (without caring about stabilization for now)</p>",
        "id": 205477050,
        "sender_full_name": "lcnr",
        "timestamp": 1596115104
    },
    {
        "content": "<p>is an MCP enough or do we need an FCP here or even an eRFC?</p>",
        "id": 205477145,
        "sender_full_name": "lcnr",
        "timestamp": 1596115148
    },
    {
        "content": "<p>well, I wrote a text for <code>T-lang</code>... not sure what to do with it</p>",
        "id": 205628044,
        "sender_full_name": "lcnr",
        "timestamp": 1596221664
    },
    {
        "content": "<p><a href=\"#narrow/stream/213817-t-lang/topic/const.20equality.20.2B.20wf\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/const.20equality.20.2B.20wf</a></p>",
        "id": 205628879,
        "sender_full_name": "lcnr",
        "timestamp": 1596222118
    }
]