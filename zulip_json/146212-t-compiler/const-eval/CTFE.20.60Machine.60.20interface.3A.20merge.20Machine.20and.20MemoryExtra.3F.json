[
    {
        "content": "<p>When implementing a Machine instance, it is somewhat arbitrary to put things into the Machine itself vs putting them into MemoryExtra. Both exist exactly once globally. However, MemoryExtra is actually available in more places, so ultimately putting things there is \"more powerful\". In Miri we have thus gradually moved fields from the machine to MemoryExtra.<br>\nI wonder if we should just go all-in on this, and move the <code>machine: M</code> field from <code>InterpCx</code> to <code>Memory</code>, and entirely remove <code>MemoryExtra</code>. Does anyone see a problem with that approach (other than it being slightly odd)?</p>",
        "id": 275852989,
        "sender_full_name": "RalfJ",
        "timestamp": 1647632410
    },
    {
        "content": "<p>honestly at that point there is barely anything left in <code>InterpCx</code>: the <code>tcx</code> is duplicated in <code>Memory</code>, so what's left is param_env and recursion_limit. So the alternative would be to just make all the methods on <code>Memory</code> (that need access to <code>machine</code> or <code>tcx</code> or so) instead methods on <code>InterpCx</code> (and get rid of both <code>MemoryExtra</code> and the <code>tcx</code> field in <code>Memory</code>). I think I like that more, TBH. The memory split predates splitting <code>Allocation</code> into its entirely own thing so we still have <em>some</em> layering going on even after basically merging the InterpCx and Memory layers.</p>",
        "id": 275853223,
        "sender_full_name": "RalfJ",
        "timestamp": 1647632551
    },
    {
        "content": "<p>I like making memory more independent!</p>",
        "id": 275907216,
        "sender_full_name": "oli",
        "timestamp": 1647691602
    },
    {
        "content": "<p>We could consider moving memory earlier in the compilation, too, basically making it only depend on allocations and the basic mir interpret types</p>",
        "id": 275907236,
        "sender_full_name": "oli",
        "timestamp": 1647691644
    },
    {
        "content": "<p>I am proposing to make memory <em>less</em> independent</p>",
        "id": 275913653,
        "sender_full_name": "RalfJ",
        "timestamp": 1647701017
    },
    {
        "content": "<p>basically I am suggesting that the attempt to make it independent doesn't actually work, as we keep having to move things into memory so that they are available in places where we need them</p>",
        "id": 275913699,
        "sender_full_name": "RalfJ",
        "timestamp": 1647701059
    },
    {
        "content": "<p>the parts of memory that can reasonable be made independent are already moved to <code>Allocation</code></p>",
        "id": 275913718,
        "sender_full_name": "RalfJ",
        "timestamp": 1647701119
    },
    {
        "content": "<p>Well... memory operations moved onto InterpCx makes the Memory struct more independent, as it can stop caring about the things that need the machine</p>",
        "id": 275925109,
        "sender_full_name": "oli",
        "timestamp": 1647717612
    },
    {
        "content": "<p>Just offering this up because I think it's related.</p>\n<p>The \"tag was created here and invalidated here\" diagnostics I'm working on currently produce much better errors than things like a use after free. I glanced over the code related to use after free errors and it wasn't clear to me that I could implement similar diagnostics for them, because I couldn't find a good place to add all the state that is required.</p>\n<p>I kind of feel like the end state (heh) is having an InterpCx passed to most/all functions so that we can retrieve information about interpreter state when errors happen, or store state in it when certain events happen.</p>\n<p>An alternative, which I implemented in an earlier branch, is doing a <code>map_err</code> once an error bubbles up to a function that has an InterpCx and thus can paste on the additional information. That doesn't seem like a good design to me.</p>",
        "id": 275926031,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647718975
    },
    {
        "content": "<p>For example, stacked borrows is very neatly factored... Except for the &amp;GlobalState that is passed to nearly everything that doesn't have an InterpCx.</p>",
        "id": 275926143,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647719122
    },
    {
        "content": "<p>we'll never be able to pass an <code>InterpCx</code> to the <code>memory_{read,written}</code> hooks, since those <em>also</em> borrow an <code>Allocation</code> that is part of the <code>InterpCx</code></p>",
        "id": 275990205,
        "sender_full_name": "RalfJ",
        "timestamp": 1647813779
    },
    {
        "content": "<p>otherwise I think we already pass it basically everywhere?</p>",
        "id": 275990214,
        "sender_full_name": "RalfJ",
        "timestamp": 1647813816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/CTFE.20.60Machine.60.20interface.3A.20merge.20Machine.20and.20MemoryExtra.3F/near/275926143\">said</a>:</p>\n<blockquote>\n<p>For example, stacked borrows is very neatly factored... Except for the &amp;GlobalState that is passed to nearly everything that doesn't have an InterpCx.</p>\n</blockquote>\n<p>how is GlobalState violating the \"neat factoring\"? being passed to everything is exactly its point :)</p>",
        "id": 275990218,
        "sender_full_name": "RalfJ",
        "timestamp": 1647813835
    },
    {
        "content": "<p>I prepared a PR for this: <a href=\"https://github.com/rust-lang/rust/pull/95620\">https://github.com/rust-lang/rust/pull/95620</a></p>",
        "id": 277654297,
        "sender_full_name": "RalfJ",
        "timestamp": 1649011178
    }
]