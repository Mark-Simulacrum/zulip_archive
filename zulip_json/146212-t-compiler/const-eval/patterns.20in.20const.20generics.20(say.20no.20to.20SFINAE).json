[
    {
        "content": "<p>Really short version: no silent CTFE errors, but specify legal patterns in the generics.</p>\n<p>When checking whether an impl overlaps with another, we first check the pattern, if that has no overlap, we compute the constants with loud errors.</p>\n<p>Syntactically I am thinking something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"w\"> </span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;</span><span class=\"n\">C</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now I get that this is not perfectly general (no way to specify logic for even vs odd array sizes or special case all powers of two), but it would cover this recurring use case of special casing ranges.</p>",
        "id": 276306608,
        "sender_full_name": "oli",
        "timestamp": 1648027814
    },
    {
        "content": "<blockquote>\n<p>Now I get that this is not perfectly general (no way to specify logic for even vs odd array sizes or special case all powers of two), but it would cover this recurring use case of special casing ranges.</p>\n</blockquote>\n<p>Yeah, but that's something we definitely want to support, don't we?</p>",
        "id": 276306968,
        "sender_full_name": "lcnr",
        "timestamp": 1648028085
    },
    {
        "content": "<p>so we still need silent CTFE errors</p>",
        "id": 276306982,
        "sender_full_name": "lcnr",
        "timestamp": 1648028094
    },
    {
        "content": "<p>generally I am not completely happy with having fallible patterns here</p>",
        "id": 276307034,
        "sender_full_name": "lcnr",
        "timestamp": 1648028143
    },
    {
        "content": "<p>though xd</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">OPT</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">)</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MaybeLen</span><span class=\"o\">&lt;</span><span class=\"n\">OPT</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276307128,
        "sender_full_name": "lcnr",
        "timestamp": 1648028193
    },
    {
        "content": "<p>avoiding the need for constraining impls :3</p>",
        "id": 276307137,
        "sender_full_name": "lcnr",
        "timestamp": 1648028203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/patterns.20in.20const.20generics.20.28say.20no.20to.20SFINAE.29/near/276307128\">said</a>:</p>\n<blockquote>\n<p>though xd</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">OPT</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">)</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MaybeLen</span><span class=\"o\">&lt;</span><span class=\"n\">OPT</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>idk, it feels a bit like a hack to me especially this. And if we can't avoid anything impl wise with this approach, I don't think adding it is worth the additional complexity</p>",
        "id": 276307283,
        "sender_full_name": "lcnr",
        "timestamp": 1648028294
    },
    {
        "content": "<p>both impl wise and learnability for the user</p>",
        "id": 276307294,
        "sender_full_name": "lcnr",
        "timestamp": 1648028306
    },
    {
        "content": "<blockquote>\n<p>Yeah, but that's something we definitely want to support, don't we?</p>\n</blockquote>\n<p>I don't know... it's cool to be able to do it, but do we have valid use cases?</p>\n<p>we should probably bring patterns up as a valid, but limited alternative. </p>\n<p>OK back to my drawing board</p>",
        "id": 276314992,
        "sender_full_name": "oli",
        "timestamp": 1648032554
    },
    {
        "content": "<p>even <code>impl&lt;const OPT @ Some(N): Option&lt;usize&gt; MaybeLen&lt;OPT&gt; {}</code> is something I don't want to write</p>",
        "id": 276315151,
        "sender_full_name": "lcnr",
        "timestamp": 1648032626
    },
    {
        "content": "<p>I want to instead write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MaybeLen</span><span class=\"o\">&lt;</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">OPT</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276315219,
        "sender_full_name": "lcnr",
        "timestamp": 1648032663
    },
    {
        "content": "<p>and that does have quite a few valid use cases</p>",
        "id": 276315247,
        "sender_full_name": "lcnr",
        "timestamp": 1648032679
    },
    {
        "content": "<p>i would generally assume that people will use \"non-patternable\" conditions during candidate selection</p>",
        "id": 276315345,
        "sender_full_name": "lcnr",
        "timestamp": 1648032723
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyExt</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">fn</span> <span class=\"nf\">arr_and_slice</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyExt</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">some_function</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">)];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">arr_and_slice</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyExt</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">arr_and_slice</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276315731,
        "sender_full_name": "lcnr",
        "timestamp": 1648032915
    },
    {
        "content": "<p>if we want to <code>array_where_some_function_panics.arr_and_slice()</code> to use the slice version instead, we have to add a condition to prevent a loud error</p>",
        "id": 276315837,
        "sender_full_name": "lcnr",
        "timestamp": 1648032968
    },
    {
        "content": "<p>idk if that pattern seems too likely</p>",
        "id": 276315850,
        "sender_full_name": "lcnr",
        "timestamp": 1648032978
    }
]