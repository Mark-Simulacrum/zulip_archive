[
    {
        "content": "<p>If my reading of <a href=\"https://github.com/rust-lang/rfcs/issues/2920\">rfc#2920</a> is correct, inline const blocks are basically just const items with types inferred. But currently it can refer to const parameters like array repeat length (well, since it's implemented with the same code). This seems to be more powerful than the RFC suggests it should be.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(inline_const)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">V</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Not allowed</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// Okay</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// Okay, but should it?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249434158,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628908130
    },
    {
        "content": "<p>From the RFC:</p>\n<blockquote>\n<p>the long-term goal is to allow array length expressions to use generic parameters. When this happens, inline const expressions and patterns will also be allowed to refer to in-scope generics.</p>\n</blockquote>",
        "id": 249434792,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628909060
    },
    {
        "content": "<p>I believe the RFC text talks about type parameters but didn't mention about const parameters</p>",
        "id": 249434815,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628909106
    },
    {
        "content": "<p>const parameters are a kind of generic parameter</p>",
        "id": 249434856,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628909142
    },
    {
        "content": "<p>I guess that means the</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">UNIQUE_IDENT</span>: <span class=\"nc\">Ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"> </span><span class=\"n\">UNIQUE_IDENT</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>part is not very accurate then. Personally I am okay with it being either restrictive or expressive, but I just want to make sure that this isn't an oversight</p>",
        "id": 249435294,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628909880
    },
    {
        "content": "<p>Why isn't <code>const X: usize = V;</code> allowed?</p>",
        "id": 249435595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628910252
    },
    {
        "content": "<p>That's <a href=\"https://doc.rust-lang.org/error-index.html#E0401\">E0401</a>.</p>",
        "id": 249437271,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628911111
    },
    {
        "content": "<p>It turns out <a href=\"https://github.com/rust-lang/rust/issues/82518\">#82518</a> is caused by inline consts being too powerful. \"Investigate handling of const parameters in patterns.\" is still listed as a remaining issue of const generics.</p>",
        "id": 249437280,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628911149
    },
    {
        "content": "<p>Now I am leaning towards restricting inline consts from accessing generic parameters.</p>",
        "id": 249437346,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628911216
    },
    {
        "content": "<p>What did you expect to happen there?<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4427534951a1342079ee8292a9fda0ea\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4427534951a1342079ee8292a9fda0ea</a></p>\n<div class=\"codehilite\"><pre><span></span><code>fn foo&lt;const V: usize&gt;() {\n  match 0 {\n    V =&gt; {},\n    _ =&gt; {},\n  }\n}\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error[E0158]: const parameters cannot be referenced in patterns\n --&gt; src/lib.rs:4:5\n  |\n4 |     V =&gt; {},\n  |     ^\n\nerror: aborting due to previous error\n</code></pre></div>",
        "id": 249437995,
        "sender_full_name": "matt1992",
        "timestamp": 1628912108
    },
    {
        "content": "<p>I think <code>const</code> items <em>should</em> be able to refer to the generic parameters of the enclosing function, the fact that they can't seems like an artificial limitation.</p>",
        "id": 249438418,
        "sender_full_name": "matt1992",
        "timestamp": 1628912679
    },
    {
        "content": "<p>inline consts can be used in pattern position. We could say that \"only inline consts in expression position can refer to const params\" but that'll be confusing</p>",
        "id": 249438807,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628913239
    },
    {
        "content": "<p>From my perspective, you're arguing that being able to use generic parameters in scope should be more verbose, because one is forced to use associated constants.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">V</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Not allowed</span>\n<span class=\"w\">    </span><span class=\"s\">\"Ab\"</span><span class=\"p\">.</span><span class=\"n\">repeat</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>↕↕↕↕<br>\n(this side compiles)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">V</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">V</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"Ab\"</span><span class=\"p\">.</span><span class=\"n\">repeat</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"o\">&lt;</span><span class=\"mi\">3</span><span class=\"o\">&gt;</span>::<span class=\"n\">call</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249438960,
        "sender_full_name": "matt1992",
        "timestamp": 1628913392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/inline.20const.20too.20powerful.3F/near/249438807\">said</a>:</p>\n<blockquote>\n<p>We could say that \"only inline consts in expression position can refer to const params\" but that'll be confusing</p>\n</blockquote>\n<p>Those are already the rules for associated constants that use generic parameters(eg: <code>Foo::&lt;X&gt;::BAR</code>) in patterns:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: constant pattern depends on a generic parameter\n --&gt; src/lib.rs:9:9\n  |\n9 |         Foo::&lt;X&gt;::BAR =&gt; 100,\n  |         ^^^^^^^^^^^^^\n</code></pre></div>\n<p>and directly using the const parameter as a pattern:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0158]: const parameters cannot be referenced in patterns\n --&gt; src/lib.rs:4:5\n  |\n4 |     V =&gt; {},\n  |     ^\n\nerror: aborting due to previous error\n</code></pre></div>",
        "id": 249440104,
        "sender_full_name": "matt1992",
        "timestamp": 1628915042
    },
    {
        "content": "<p>those follow very different code path from inline consts though</p>",
        "id": 249440433,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628915455
    },
    {
        "content": "<p>E.g. const params in patterns are checked in THIR construction</p>",
        "id": 249440444,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628915497
    },
    {
        "content": "<p>While inline consts are eagerly evaluated so that their values are known before THIR of the containing function is even constructed</p>",
        "id": 249440498,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628915572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/inline.20const.20too.20powerful.3F/near/249440498\">said</a>:</p>\n<blockquote>\n<p>While inline consts are eagerly evaluated so that their values are known before THIR of the containing function is even constructed</p>\n</blockquote>\n<p>Huh? Why is that how inline const has to always work?</p>",
        "id": 249440514,
        "sender_full_name": "matt1992",
        "timestamp": 1628915640
    },
    {
        "content": "<p>This looks to me like you're looking into how it's currently implemented, and then saying \"welp, no way it can work how you want it to\".</p>",
        "id": 249440611,
        "sender_full_name": "matt1992",
        "timestamp": 1628915750
    },
    {
        "content": "<p>It should be possible for inline consts that don't refer to any generic parameters in scope to be evaluated eagerly, while those that do wouldn't be <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 249440990,
        "sender_full_name": "matt1992",
        "timestamp": 1628916321
    },
    {
        "content": "<p>I suppose what's currently doable without duplicating diagnostic generation is to check ty::Const for Param during THIR construction, so it'll be</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0158]: const parameters cannot be referenced in patterns\n --&gt; src/lib.rs:5:11\n  |\n5 |     const { V } =&gt; {},\n  |           ^^^^^\n</code></pre></div>\n<p>couldn't pinpoint to V anymore since AnonConst has been evaluated already, but good enough for now.</p>",
        "id": 249442142,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628918333
    },
    {
        "content": "<p>Analogous to <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/inline.20const.20too.20powerful.3F/near/249440990\">what I said</a> about inline const,<br>\nassociated constants that come from concrete types are evaluated eagerly,<br>\nso that this generic function errors without ever being used<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=00b7ceaa472fd1226360542cf5c88921\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=00b7ceaa472fd1226360542cf5c88921</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">Foo</span>::<span class=\"n\">X</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error: this operation will panic at runtime\n --&gt; src/lib.rs:8:13\n  |\n8 |     let _ = [0][Foo::X];\n  |             ^^^^^^^^^^^ index out of bounds: the length is 1 but the index is 10\n  |\n  = note: `#[deny(unconditional_panic)]` on by default\n</code></pre></div>\n<p>While constants coming from generic types<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0862a8b35ba9e24f34788f1fd92ebe11\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0862a8b35ba9e24f34788f1fd92ebe11</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">marker</span>::<span class=\"n\">PhantomData</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"k\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"p\">{};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Bar</span>::<span class=\"n\">X</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>are only evaluated when the function is called with concrete types</p>\n<div class=\"codehilite\"><pre><span></span><code>error: any use of this value will cause an error\n --&gt; src/main.rs:6:26\n  |\n6 |     const X: Option&lt;T&gt; = loop{};\n  |     ---------------------^^^^^^-\n  |                          |\n  |                          exceeded interpreter step limit (see `#[const_eval_limit]`)\n  |\n  = note: `#[deny(const_err)]` on by default\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #71800 &lt;https://github.com/rust-lang/rust/issues/71800&gt;\n\nerror: aborting due to previous error\n</code></pre></div>\n<p>(this doesn't error when <code>foo::&lt;u32&gt;()</code> is commented out)</p>",
        "id": 249442505,
        "sender_full_name": "matt1992",
        "timestamp": 1628918998
    },
    {
        "content": "<p>Basically I keep seeing parallels between associated constants and inline const, so it woudn't seem at all confusing if the error was the same for both</p>\n<div class=\"codehilite\"><pre><span></span><code>error: constant pattern depends on a generic parameter\n --&gt; src/lib.rs:9:9\n  |\n9 |         Foo::&lt;X&gt;::BAR =&gt; 100,\n  |         ^^^^^^^^^^^^^\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error: inline const pattern depends on a generic parameter\n --&gt; src/lib.rs:9:9\n  |\n9 |         const{ foo(X) } =&gt; 100,\n  |         ^^^^^^^^^^^^^^^\n</code></pre></div>",
        "id": 249442780,
        "sender_full_name": "matt1992",
        "timestamp": 1628919392
    },
    {
        "content": "<blockquote>\n<p>let _ = [0][Foo::X];</p>\n</blockquote>\n<p>IIRC This is done by MIR const prop pass, so it's pretty late</p>",
        "id": 249443635,
        "sender_full_name": "Gary Guo",
        "timestamp": 1628920908
    },
    {
        "content": "<p>Can we stick to user-facing semantics? I don't care how this is implemented.</p>\n<p>If I had just learnt about inline const, I would expect it to just work with generic parameters, and would find it more surprising that it doesn't work at all than I would find that \"inline const pattern depends on a generic parameter\" error.</p>",
        "id": 249444342,
        "sender_full_name": "matt1992",
        "timestamp": 1628922241
    },
    {
        "content": "<p>patterns are special here, they participate in exhaustiveness checking, which needs to know the actual value. we can treat them as unknown/opaque, but that needs an rfc. inline consts in expressions should def support generics, following the same rules as array lengths</p>",
        "id": 249452181,
        "sender_full_name": "oli",
        "timestamp": 1628935499
    },
    {
        "content": "<p>yeah generics should work -- and indeed then the desugaring does not literally work any more, though morally it is still accruate</p>",
        "id": 249459186,
        "sender_full_name": "RalfJ",
        "timestamp": 1628946457
    }
]