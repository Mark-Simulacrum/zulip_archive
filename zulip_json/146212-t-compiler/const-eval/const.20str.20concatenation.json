[
    {
        "content": "<p>Is it possible, using current const evaluation, to do the equivalent of <code>concat!</code> with values that are all either literals or constants of type <code>&amp;str</code>?</p>",
        "id": 205074803,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1595811870
    },
    {
        "content": "<p>(I don't need full string formatting, just concatenation.)</p>",
        "id": 205074919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1595812142
    },
    {
        "content": "<p>I think that to do it in a general const context (non-macro) would take const allocation, and i'm pretty sure it'd be all over the news if that was supported, even just in nightly.</p>",
        "id": 205076689,
        "sender_full_name": "Lokathor",
        "timestamp": 1595815640
    },
    {
        "content": "<p>well, you can cheat with a large enough array, but that limits the maximum length of your concat invocation. You can make that length configurable though. The main blocker for even that is unsafe things</p>",
        "id": 205082651,
        "sender_full_name": "oli",
        "timestamp": 1595827032
    },
    {
        "content": "<p>So, the fact that they're all <code>&amp;'static str</code> values doesn't help in any way?</p>",
        "id": 205148902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1595873018
    },
    {
        "content": "<p>If you are just interested in getting it to work for now, using macros is a solution: <a href=\"https://stackoverflow.com/a/35159310/155423\">How to concatenate static strings in Rust</a></p>",
        "id": 205150069,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1595873647
    },
    {
        "content": "<p>I was able to make a macro to concatenate constant <code>&amp;'static str</code> (that don't come from generic parameters):<br>\n<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=1555757f31d8b98f514806c4f94b634c\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=1555757f31d8b98f514806c4f94b634c</a><br>\nIt relies on the layout of <code>&amp;[u8]</code> and <code>&amp;str</code> (the pointer itself) being the same.</p>",
        "id": 205435481,
        "sender_full_name": "matt1992",
        "timestamp": 1596075601
    },
    {
        "content": "<p>whoa whoa, nice!</p>",
        "id": 205449824,
        "sender_full_name": "oli",
        "timestamp": 1596095000
    },
    {
        "content": "<p>this old one seemed nice to use as well <a href=\"https://github.com/Vurich/const-concat/blob/master/src/lib.rs\">https://github.com/Vurich/const-concat/blob/master/src/lib.rs</a></p>",
        "id": 205459768,
        "sender_full_name": "lqd",
        "timestamp": 1596102701
    },
    {
        "content": "<p>So you know how <code>concat!</code> errors during its expansion if the args aren't literals (or macro calls that expanded to literals)... what if we caught that error during expansion and instead expanded the arguments to str concat via CTFE?</p>",
        "id": 269633824,
        "sender_full_name": "oli",
        "timestamp": 1643315743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> So, anything constant-time evaluatable to a string would work?</p>",
        "id": 269651271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643323246
    },
    {
        "content": "<p>Up to and including <code>const fn arbitrary_func(arbitrary: &amp;Args) -&gt; &amp;str</code>?</p>",
        "id": 269651313,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643323269
    },
    {
        "content": "<p>ooh...compile-time compiler: <code>global_asm!(concat!(generate_asm()));</code></p>",
        "id": 269653363,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643324295
    },
    {
        "content": "<p>Where's the <code>.incbin</code> version of that.</p>",
        "id": 269657756,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643326532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20str.20concatenation/near/269633824\">said</a>:</p>\n<blockquote>\n<p>So you know how <code>concat!</code> errors during its expansion if the args aren't literals (or macro calls that expanded to literals)... what if we caught that error during expansion and instead expanded the arguments to str concat via CTFE?</p>\n</blockquote>\n<p>With const heap, is this \"hack\" really needed?</p>",
        "id": 269697477,
        "sender_full_name": "fee1-dead",
        "timestamp": 1643355830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20str.20concatenation/near/269697477\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const.20str.20concatenation/near/269633824\">said</a>:<br>\nWith const heap, is this \"hack\" really needed?</p>\n</blockquote>\n<p>yeah, i mean, you can actually do this basically already with ctfe without const heap.</p>\n<p>i showed the basic technique in <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.5BT.5D.3A.3Ajoin\">https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.5BT.5D.3A.3Ajoin</a>, but its not that hard to write, and can probably be improved from there (one note is that iirc <code>concat!</code> works with some types that my macro doesn't / couldn't.</p>\n<p>despite this, i'm 1000% in support of <code>concat!</code> just doing this out of the box. tbh, i don't see the downside to just doing the thing the programmer intended there.</p>",
        "id": 269704758,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643360199
    },
    {
        "content": "<p>Yea, I don't see it as a hack, but as supporting it in the libstd convenience macro that is already there. Even if we support this completely on stable in user code without gotchas, just calling <code>concat!</code> seems like a convenient thing</p>",
        "id": 269707256,
        "sender_full_name": "oli",
        "timestamp": 1643361574
    },
    {
        "content": "<p>well...if <code>concat!</code> gains const-eval skills, then a proc-macro can interact with the compiler's const evaluator bidirectionally by using the nightly i-forgot-its-name api for evaluating macros eagerly...</p>",
        "id": 269712662,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643364393
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/proc_macro/struct.TokenStream.html#method.expand_expr\">https://doc.rust-lang.org/nightly/proc_macro/struct.TokenStream.html#method.expand_expr</a></p>",
        "id": 269712781,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643364461
    },
    {
        "content": "<p>by calling <code>quote!{concat!(my_ctfe())}.expand_expr()</code> it can evaluate <code>const fn my_ctfe() -&gt; &amp;'static str</code></p>",
        "id": 269713042,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643364594
    },
    {
        "content": "<p><code>quote!{asm!(\"...\")}.expand_expr()</code> doesn't result in a value representing the return value of <code>asm!()</code> either. <code>asm!()</code> expands to a magic ast expression kind you can't directly write that lowers to an <code>Asm</code> statement at MIR level. <code>concat!()</code> could do something similar.</p>",
        "id": 269713834,
        "sender_full_name": "bjorn3",
        "timestamp": 1643365058
    },
    {
        "content": "<p>There will be no evaluation happening until all macros have been expanded</p>",
        "id": 269732569,
        "sender_full_name": "oli",
        "timestamp": 1643375301
    },
    {
        "content": "<p>Sorry, xD no bidirectional data exchange between proc macros and CTFE</p>",
        "id": 269732607,
        "sender_full_name": "oli",
        "timestamp": 1643375324
    },
    {
        "content": "<p>Concat will just generate an inline const expression with the logic to concat strings, not eagerly doing the concat during macro expansion</p>",
        "id": 269732858,
        "sender_full_name": "oli",
        "timestamp": 1643375432
    },
    {
        "content": "<p>So <code>concat!(FOO, \".bar\")</code> will become <code>const { some_method(FOO, \".bar\") }</code> and plainly dump that expression, no eager logic happening or being possible</p>",
        "id": 269733016,
        "sender_full_name": "oli",
        "timestamp": 1643375506
    },
    {
        "content": "<p>i guess concat! with many entries would just combine the first two entries over and over via concat_method?</p>",
        "id": 269759006,
        "sender_full_name": "Lokathor",
        "timestamp": 1643385999
    },
    {
        "content": "<p>we can be smarter about the desugaring, but initially for minimal impl work, yes</p>",
        "id": 269761207,
        "sender_full_name": "oli",
        "timestamp": 1643386935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> Would this also mean that the various macros built into the compiler (like <code>asm!</code>) that currently special-case <code>concat!</code> in their arguments can stop doing so?</p>",
        "id": 269799755,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643402655
    },
    {
        "content": "<p>There's some hand-rolled \"expand my argument\" code in several places in the compiler's built-in macro impls.</p>",
        "id": 269799790,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643402672
    },
    {
        "content": "<p>Probably not, the asm macro, just like the format macro, need to do name matching between their string input and expression arguments, that cannot happen in CTFE, it must happen in macro expansion</p>",
        "id": 269805608,
        "sender_full_name": "oli",
        "timestamp": 1643405553
    },
    {
        "content": "<p>Ah. Which would mean you can't actually do the CTFE part there?</p>",
        "id": 269805838,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643405665
    },
    {
        "content": "<p>No. Also I think the only way to be backwards compatible is to try to do it at expansion time and only fall back to CTFE if we would error anyway</p>",
        "id": 269807138,
        "sender_full_name": "oli",
        "timestamp": 1643406371
    },
    {
        "content": "<p>Presumably the same would be true of the <code>format!</code> family.</p>",
        "id": 269807224,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643406429
    },
    {
        "content": "<p>Yes</p>",
        "id": 269808353,
        "sender_full_name": "oli",
        "timestamp": 1643407031
    }
]