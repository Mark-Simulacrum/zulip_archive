[
    {
        "content": "<p>From what I understand of the design document, the goal is to be able to write something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_zero</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_zero</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_zero</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u64</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But then, let's say a user of the above crate writes a function like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">MyType</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">MyType</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span>::<span class=\"n\">get_zero</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That code would compile as-is... but it would be pretty brittle. If the user MyType adds a field to MyType (or if MyType is an imported type, and the upstream library adds a field), the code suddenly stops compiling. Worse, if the compiler changes how MyType is laid out, the program could also stop compiling, even if the code and the dependencies stay the same.</p>",
        "id": 276341760,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046034
    },
    {
        "content": "<p>Also, if the user writes this code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">BACKGROUND_COLOR</span>: <span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">250</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">240</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">BACKGROUND_COLOR</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span>::<span class=\"n\">get_zero</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Their crate now depends on the value of BACKGROUND_COLOR; changing that value now requires a semver bump. This is the case even if the value was exported from another crate.</p>",
        "id": 276341889,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046079
    },
    {
        "content": "<p>changing the value of a <code>const</code> is already technically a breaking change</p>",
        "id": 276342113,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648046164
    },
    {
        "content": "<p>Note that both these problems <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3b3846b92f78c7880c5cbf997869d901\">already exist in stable Rust</a>. They're just a lot less likely to occur in practice.</p>",
        "id": 276342193,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046193
    },
    {
        "content": "<p>I don't think there's a perfect solution to these kinds of stability problems, but I think at the very least they should be shown in the design document.</p>",
        "id": 276342276,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276342113\">said</a>:</p>\n<blockquote>\n<p>changing the value of a <code>const</code> is already technically a breaking change</p>\n</blockquote>\n<p>I don't doubt you, but how documented is this assumption? In particular, is there a documented rule that goes \"If you change a const value, you should bump semver?\"</p>",
        "id": 276342743,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046398
    },
    {
        "content": "<p>I dont know, when i say breaking cahnge I just mean that i may stop code compiling</p>",
        "id": 276342829,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648046418
    },
    {
        "content": "<p>i.e. <code>let a: [u8; std::mem::size_of::&lt;Foo&gt;()] = [1, 2, 3, 4]</code></p>",
        "id": 276342923,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648046452
    },
    {
        "content": "<p>Sure. That's why I say there's no perfect solution. There's lot of stuff you can do in your crate that isn't \"officially\" a semver-breaking change, but that can break downstream libraries in practice.</p>",
        "id": 276343351,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046616
    },
    {
        "content": "<p>See also: <a href=\"https://doc.rust-lang.org/std/char/constant.UNICODE_VERSION.html\">https://doc.rust-lang.org/std/char/constant.UNICODE_VERSION.html</a></p>",
        "id": 276343717,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648046753
    },
    {
        "content": "<blockquote>\n<p>I don't doubt you, but how documented is this assumption? In particular, is there a documented rule that goes \"If you change a const value, you should bump semver?\"</p>\n</blockquote>\n<p><a href=\"https://doc.rust-lang.org/cargo/reference/semver.html\">https://doc.rust-lang.org/cargo/reference/semver.html</a> is the best user facing documentation, and it needs love.</p>",
        "id": 276345180,
        "sender_full_name": "Eh2406",
        "timestamp": 1648047299
    },
    {
        "content": "<p>Honestly, I think a \"shiny future\" design should deprecate the <code>let a: [u8; std::mem::size_of::&lt;Foo&gt;()] = [1, 2, 3, 4]</code> case</p>",
        "id": 276346139,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648047651
    },
    {
        "content": "<p>So:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">make_array</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ALLOWED</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">make_array</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ALLOWED</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// MAYBE ALLOWED</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ERROR</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ERROR</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()];</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276346941,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648047930
    },
    {
        "content": "<p>So <code>size_of&lt;X&gt;</code> would be allowed in const expressions, but only if type-checking doesn't depend on <code>size_of&lt;X&gt;</code> having any particular value.</p>",
        "id": 276347167,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648048008
    },
    {
        "content": "<p>If we want to get <em>really</em> fancy, we could give the compiler the information \"sizeof(X) &gt;= the sum of sizes of all public fields of X\" because that's stable.</p>",
        "id": 276347538,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648048144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276347167\">said</a>:</p>\n<blockquote>\n<p>So <code>size_of&lt;X&gt;</code> would be allowed in const expressions, but only if type-checking doesn't depend on <code>size_of&lt;X&gt;</code> having any particular value.</p>\n</blockquote>\n<p>I like this ^^ I think it would be good that saying \"this can be evaluated at compile time\" does not imply \"the exact return value for each input is a semver guarantee\"</p>",
        "id": 276348550,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648048511
    },
    {
        "content": "<p>Right. You could have an annotation for consts, const functions, etc, that says \"the exact CTFE value of this is/isn't a semver guarantee\".</p>",
        "id": 276349196,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648048773
    },
    {
        "content": "<p>i would probably just reuse the \"opaque\" consts stuff</p>",
        "id": 276349245,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648048792
    },
    {
        "content": "<p>and say that opaque consts cant be normalized even when fully concrete</p>",
        "id": 276349261,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648048799
    },
    {
        "content": "<p>I think there's overlap with specialization too</p>",
        "id": 276349392,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648048844
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/project-const-generics/issues/39\">https://github.com/rust-lang/project-const-generics/issues/39</a></p>",
        "id": 276349602,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648048925
    },
    {
        "content": "<p>:D</p>",
        "id": 276349609,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1648048927
    },
    {
        "content": "<blockquote>\n<p>We could consider some concrete constants to be opaque, meaning that they only unify with themselves, or potentially with other constants with an equal abstract representation.</p>\n</blockquote>\n<p>This implies that \"opaqueness\" would be a boolean state? I think it could be more like trait coherence.</p>",
        "id": 276350016,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648049088
    },
    {
        "content": "<p>You could declare that a const is \"opaque\", and the compiler is still allowed to unify it with its value, but only within the scope of the crate that declares it</p>",
        "id": 276350135,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648049140
    },
    {
        "content": "<p>(though sizeof would always be opaque, since it exposes compiler internals)</p>",
        "id": 276350296,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648049206
    },
    {
        "content": "<p>it should be possible to lint when doing \"opaque == not opaque\"</p>",
        "id": 276351453,
        "sender_full_name": "lcnr",
        "timestamp": 1648049685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276350135\">said</a>:</p>\n<blockquote>\n<p>You could declare that a const is \"opaque\", and the compiler is still allowed to unify it with its value, but only within the scope of the crate that declares it</p>\n</blockquote>\n<p>yes</p>",
        "id": 276351459,
        "sender_full_name": "lcnr",
        "timestamp": 1648049690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276349602\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-lang/project-const-generics/issues/39\">https://github.com/rust-lang/project-const-generics/issues/39</a></p>\n</blockquote>\n<p>i am still unsure of the best way of getting that info from threads like this into the documentation</p>",
        "id": 276353210,
        "sender_full_name": "lcnr",
        "timestamp": 1648050355
    },
    {
        "content": "<p>i could wait a few days and manually do it myself, but that seems both stressful and its fairly likely that I will forget to do it</p>",
        "id": 276353296,
        "sender_full_name": "lcnr",
        "timestamp": 1648050379
    },
    {
        "content": "<p>I could write a summary of the discussion, alternatives proposed, etc.</p>",
        "id": 276353372,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648050401
    },
    {
        "content": "<p>would be great</p>",
        "id": 276353386,
        "sender_full_name": "lcnr",
        "timestamp": 1648050407
    },
    {
        "content": "<p>using github issues isn't perfect, but they are far better than mdbook at representing N-M relationships</p>",
        "id": 276353421,
        "sender_full_name": "lcnr",
        "timestamp": 1648050423
    },
    {
        "content": "<p>by using labels</p>",
        "id": 276353430,
        "sender_full_name": "lcnr",
        "timestamp": 1648050427
    },
    {
        "content": "<p>and automatic references</p>",
        "id": 276353454,
        "sender_full_name": "lcnr",
        "timestamp": 1648050440
    },
    {
        "content": "<p>To expand on opaque constants, another example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[opaque_const]</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VALUE</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Array</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span>: <span class=\"nc\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Display</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_printable</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_printable</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_printable</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u64</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276353722,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648050548
    },
    {
        "content": "<p>I do actually want to be able to write code like <code>let a: [u8; std::mem::size_of::&lt;Foo&gt;()] = [1, 2, 3, 4]</code>. And I would <em>expect</em> it to stop compiling if Foo changed size.</p>",
        "id": 276353752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648050561
    },
    {
        "content": "<p>I think that, given the above code</p>",
        "id": 276353755,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648050561
    },
    {
        "content": "<p>Breaking compilation is a feature in that case, it means my code needs updating.</p>",
        "id": 276353801,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648050583
    },
    {
        "content": "<p>For instance, if the very next line is going to be a transmute to Foo.</p>",
        "id": 276353876,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648050603
    },
    {
        "content": "<p>For that matter, safe transmute would <em>also</em> stop code from compiling if a size changed.</p>",
        "id": 276354138,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648050697
    },
    {
        "content": "<p>I think that, given the code I quoted above, this should (maybe) compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">VALUE</span><span class=\"p\">]).</span><span class=\"n\">get_printable</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and this should fail:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// THIS SHOULD FAIL</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">VALUE</span><span class=\"p\">]).</span><span class=\"n\">get_printable</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276354269,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648050729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276354269\">said</a>:</p>\n<blockquote>\n<p>I think that, given the code I quoted above, this should (maybe) compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">VALUE</span><span class=\"p\">]).</span><span class=\"n\">get_printable</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and this should fail:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// THIS SHOULD FAIL</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">VALUE</span><span class=\"p\">]).</span><span class=\"n\">get_printable</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>alright, that just got a lot more difficult to implement <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 276354733,
        "sender_full_name": "lcnr",
        "timestamp": 1648050926
    },
    {
        "content": "<blockquote>\n<p>For that matter, safe transmute would also stop code from compiling if a size changed.</p>\n</blockquote>\n<p>I don't remember, how does safe_transmute handle size? I think the latest proposal did something with public and private fields?</p>",
        "id": 276355045,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051033
    },
    {
        "content": "<p>I think that's one of the things it's currently stalled on.</p>",
        "id": 276355110,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051056
    },
    {
        "content": "<p>Which is more of a policy question than a mechanism question.</p>",
        "id": 276355122,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051064
    },
    {
        "content": "<p>But that's just about how and whether such information should cross semver boundaries.</p>",
        "id": 276355161,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051079
    },
    {
        "content": "<p>All the solutions I've seen would allow relying on size <em>within</em> a module, at least.</p>",
        "id": 276355246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051096
    },
    {
        "content": "<p>Right, but what I proposed wouldn't change that</p>",
        "id": 276355329,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051117
    },
    {
        "content": "<p>Wait, yes, nevermind</p>",
        "id": 276355388,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276350296\">said</a>:</p>\n<blockquote>\n<p>(though sizeof would always be opaque, since it exposes compiler internals)</p>\n</blockquote>\n<p>we could implement a visibility component for this</p>",
        "id": 276355467,
        "sender_full_name": "lcnr",
        "timestamp": 1648051157
    },
    {
        "content": "<p>though we would have to add attributes to functions which themselves should be transparent</p>",
        "id": 276355531,
        "sender_full_name": "lcnr",
        "timestamp": 1648051175
    },
    {
        "content": "<p>By \"compiler internals\", I meant \"how the compiler lays fields out\"</p>",
        "id": 276355541,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051181
    },
    {
        "content": "<p>which seems bad enough for me to not want that</p>",
        "id": 276355543,
        "sender_full_name": "lcnr",
        "timestamp": 1648051182
    },
    {
        "content": "<p>Sure, if size_of were opaque iff you can't see all the fields that determine that size, that could work...</p>",
        "id": 276355564,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051188
    },
    {
        "content": "<p>It would be more like \"size_of is opaque iff you can't see all the fields that determine its size OR it's non_exhaustive OR its layout is subject to change with a compiler update\"</p>",
        "id": 276355859,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051259
    },
    {
        "content": "<p>(so <code>repr(C)</code> structs are non-opaque, everything else is probably opaque)</p>",
        "id": 276355959,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051291
    },
    {
        "content": "<p>That last one seems a little more debatable. (This is the kind of thing that led safe-transmute down the bikeshed path.)</p>",
        "id": 276356119,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051328
    },
    {
        "content": "<p>safe-transmute, at least, was leaning towards \"you can assume two structs with the same fields have the same layout\".</p>",
        "id": 276356188,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051354
    },
    {
        "content": "<p>Also, if you have a struct containing (u16, u16), it's <em>really</em> debatable how much we want to reserve the right to lay that out differently.</p>",
        "id": 276356410,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051423
    },
    {
        "content": "<p>I mean, ultimately, that depends on what stability guarantees the compiler give. Do we assume that, for the same fields in the same order, the compiler will always return the same size?</p>",
        "id": 276356416,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051423
    },
    {
        "content": "<p>Sure</p>",
        "id": 276356451,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276356416\">said</a>:</p>\n<blockquote>\n<p>I mean, ultimately, that depends on what stability guarantees the compiler give. Do we assume that, for the same fields in the same order, the compiler will always return the same size?</p>\n</blockquote>\n<p>s/Do we assume/Does the ecosystem assume/</p>",
        "id": 276356464,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051439
    },
    {
        "content": "<p>If you want to be specific, it's more \"Does the spec tell the ecosystem that it can assume that ...\"</p>",
        "id": 276356660,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051495
    },
    {
        "content": "<p>I said what I meant. :)</p>",
        "id": 276356696,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051504
    },
    {
        "content": "<p>Well, that's above my pay grade :D</p>",
        "id": 276356815,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051536
    },
    {
        "content": "<p>If the ecosystem assumes it, then the question becomes \"Is this proposed layout change worth breaking the ecosystem\".</p>",
        "id": 276356822,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648051538
    },
    {
        "content": "<p>Okay, point taken.</p>",
        "id": 276357069,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051603
    },
    {
        "content": "<p>There's probably an argument for saying \"sizeof is assumed to be stable for a type whose fields you control\"</p>",
        "id": 276357190,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051632
    },
    {
        "content": "<p>Although that's for structs and tuples.</p>",
        "id": 276357228,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051644
    },
    {
        "content": "<p>There's a pretty strong argument for assuming the layout of an enum may change: the compiler might add niches.</p>",
        "id": 276357406,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051683
    },
    {
        "content": "<p>Well, as rustc (et. al) gets better at optimizing struct layouts, that would change struct/tuple layout as well.</p>",
        "id": 276357667,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648051774
    },
    {
        "content": "<p>I think on the long term, you might have something like <code>repr(rust2021)</code>, <code>repr(rust2024)</code>, etc</p>",
        "id": 276358084,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051902
    },
    {
        "content": "<p>or <code>repr(rust_abi_1)</code>, <code>repr(rust_abi_2)</code>, etc</p>",
        "id": 276358099,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648051910
    },
    {
        "content": "<p>Kind of like Rust currently has a symbol mangling \"v0\", with the implication there'll be others</p>",
        "id": 276358438,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052023
    },
    {
        "content": "<p>I'm creating another topic for the \"sizeof\" discussion</p>",
        "id": 276358901,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648052169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276358084\">said</a>:</p>\n<blockquote>\n<p>I think on the long term, you might have something like <code>repr(rust2021)</code>, <code>repr(rust2024)</code>, etc</p>\n</blockquote>\n<p>Oooh, I like that idea!</p>",
        "id": 276359852,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648052502
    },
    {
        "content": "<p>The question is, unless it gets specified, how prolific do you want those reprs to be.<br>\nI have a similar thing planned (unstable) for lccc, where the central abi defines the layout in that version, and then you can reach for <code>repr(lcrust_v0)</code> to get the layout from a particular version, and there will be one for each new layout, but there won't be that many because I expect to redefine the layout very infrequently: for the most part, only as required.  <br>\nThat comes with the trade off of having far less optimization opportunities as they have to be weighed against the cost of adding to that.</p>",
        "id": 276361919,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648053154
    },
    {
        "content": "<blockquote>\n<p>alright, that just got a lot more difficult to implement <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> </p>\n</blockquote>\n<p>I can guess what you mean, but can you expand?</p>",
        "id": 276362045,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053206
    },
    {
        "content": "<blockquote>\n<p>I can guess what you mean, but can you expand?</p>\n</blockquote>\n<p>here you go from an opaque const value through the trait system and up in a type, so we have to remember \"this is opaque\" for types as well.</p>",
        "id": 276362370,
        "sender_full_name": "lcnr",
        "timestamp": 1648053319
    },
    {
        "content": "<p>its also only allowed if it's possible if we do <a href=\"https://github.com/rust-lang/project-const-generics/issues/26\">https://github.com/rust-lang/project-const-generics/issues/26</a></p>",
        "id": 276362524,
        "sender_full_name": "lcnr",
        "timestamp": 1648053376
    },
    {
        "content": "<p>but yeah, having special opaque const values seems fine</p>",
        "id": 276362568,
        "sender_full_name": "lcnr",
        "timestamp": 1648053393
    },
    {
        "content": "<p>doing anything special with them is a lot less fine</p>",
        "id": 276362594,
        "sender_full_name": "lcnr",
        "timestamp": 1648053404
    },
    {
        "content": "<p>e.g. specialization - which is pretty much how merging impls to be exhaustive would work - is definitely something i would not try to support</p>",
        "id": 276362673,
        "sender_full_name": "lcnr",
        "timestamp": 1648053438
    },
    {
        "content": "<blockquote>\n<p>e.g. specialization - which is pretty much how merging impls to be exhaustive would work - is definitely something i would not try to support</p>\n</blockquote>\n<p>I think that's what you'd want, though.</p>",
        "id": 276362886,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053504
    },
    {
        "content": "<p>Or at least I see parallels between the semantics</p>",
        "id": 276362918,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053514
    },
    {
        "content": "<p>don't think I would agree to that (that being: <em>add support for this in the compiler</em>), at least not in the near future</p>",
        "id": 276363232,
        "sender_full_name": "lcnr",
        "timestamp": 1648053612
    },
    {
        "content": "<p>adding opaque const values is something I would be fine with rn</p>",
        "id": 276363257,
        "sender_full_name": "lcnr",
        "timestamp": 1648053626
    },
    {
        "content": "<blockquote>\n<p>(that being: add support for this in the compiler)</p>\n</blockquote>\n<p>Right, I'm just doing armchair design, I'm probably not going to be the one to implement this ^^</p>",
        "id": 276363421,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053695
    },
    {
        "content": "<p>But then if we follow the logic \"opaque value means you're not allowed to break semver if the value changes\", then opaque values can't be used in a where clause at all, right?</p>",
        "id": 276363707,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1648053801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276361919\">said</a>:</p>\n<blockquote>\n<p>The question is, unless it gets specified, how prolific do you want those reprs to be.<br>\nI have a similar thing planned (unstable) for lccc, where the central abi defines the layout in that version, and then you can reach for <code>repr(lcrust_v0)</code> to get the layout from a particular version, and there will be one for each new layout, but there won't be that many because I expect to redefine the layout very infrequently: for the most part, only as required.  <br>\nThat comes with the trade off of having far less optimization opportunities as they have to be weighed against the cost of adding to that.</p>\n</blockquote>\n<p>So, fundamentally, if we're considering a stability concept for <code>repr(Rust)</code>, it would have to actually be specified, and then anything supporting <code>repr(Rust)</code> would have to use the specified layout. (Unlike today where it can mean \"whatever the impl wants to do\".)</p>",
        "id": 276371819,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648056801
    },
    {
        "content": "<p>I was considering the idea of \"In a particular rustc version, you can rely upon the layout of repr(Rust), and also we define <code>repr(rustc_abi_vn)</code> so you can stabily refer to the current or any past version of repr(Rust)\" which is what lccc's abi specifies, but comes at a cost of either severely limiting when you change the repr (and thus, the kinds of changes you can make), or ending up with may too many <code>repr(rustc_abi_n)</code>s. Exponentially so if it is indeed not specified. Having it specified goes to the former camp, if it changes at all.</p>",
        "id": 276375724,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648058426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276375724\">said</a>:</p>\n<p>I had an idea for a way for userland code/crates to specify custom struct layouts, but when I went to look at the compiler the idea seemed kind of a nonstarter. Would still love it if there was a way, without too much hackery, to experiment with alternative ABIs and layouts though.</p>",
        "id": 276380660,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648060520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I think if we're going to have <code>repr(Rust2024)</code> or similar, it'd be because <em>in</em> Rust 2024 code you can count on the default <code>repr(Rust)</code> being that.</p>",
        "id": 276385988,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648062881
    },
    {
        "content": "<p>Otherwise it might as well be v1, v2, v3, yeah.</p>",
        "id": 276386015,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648062899
    },
    {
        "content": "<p>So I'd expect that <em>if</em> we went that route, structs without an explicit repr would still be able to rely on it being the current-edition repr.</p>",
        "id": 276386100,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648062944
    },
    {
        "content": "<p>I think this is a good place to bring up my old <code>impl const usize</code> idea from <a href=\"https://github.com/rust-lang/rfcs/pull/2545#issuecomment-661305546\">https://github.com/rust-lang/rfcs/pull/2545#issuecomment-661305546</a></p>\n<p>(Which does not at all have the details worked out, but would solve these problems if it does, I think.)</p>",
        "id": 276418980,
        "sender_full_name": "scottmcm",
        "timestamp": 1648080510
    },
    {
        "content": "<p>Basically, this is the const generics version of <code>impl Trait</code> -- I want to be able to return something, but be able to change it later, so long as it meets the \"bounds\" you put in the signature.</p>",
        "id": 276419127,
        "sender_full_name": "scottmcm",
        "timestamp": 1648080623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276353210\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/How.20do.20we.20want.20const.20generics.20to.20impact.20stability.3F/near/276349602\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-lang/project-const-generics/issues/39\">https://github.com/rust-lang/project-const-generics/issues/39</a></p>\n</blockquote>\n<p>i am still unsure of the best way of getting that info from threads like this into the documentation</p>\n</blockquote>\n<p>FWIW I did a summary of my proposal: <a href=\"https://gist.github.com/PoignardAzur/97939c758cec19795282126ae1260514\">https://gist.github.com/PoignardAzur/97939c758cec19795282126ae1260514</a></p>",
        "id": 278303402,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1649424389
    }
]