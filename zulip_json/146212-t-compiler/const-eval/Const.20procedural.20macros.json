[
    {
        "content": "<p>Hey, I don’t know if this has been brought up before (I didn’t see an issue on the const-eval repo). But have people thought about using <code>const</code> for procedural macros?</p>\n<p>This is blocked on things like const heap alloc, but I was thinking down the the road it could be nice. Since if it could be evaluated by miri, then it can be in a regular crate right? It would also allow you to use non-FFI safe types like Result in procedural macro signatures. You could do more interesting things like having traits for the different kinds macros, for example: imagine if implementing a derive looked like this.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// core::derive</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Derive</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">fn</span> <span class=\"nf\">derive</span><span class=\"p\">(</span><span class=\"n\">stream</span>: <span class=\"nc\">TokenStream</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">TokenStream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CompilerError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Derive</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">fn</span> <span class=\"nf\">derive</span><span class=\"p\">(</span><span class=\"n\">stream</span>: <span class=\"nc\">TokenStream</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">TokenStream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CompilerError</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">parse_macro_input</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">syn</span>::<span class=\"n\">DeriveInput</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">quote</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Generate Clone impl...</span>\n<span class=\"w\">    </span><span class=\"p\">}.</span><span class=\"n\">into</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 253864700,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1631967707
    },
    {
        "content": "<p>We don't need procedural macro signatures to be ffi safe today already?</p>",
        "id": 253864874,
        "sender_full_name": "simulacrum",
        "timestamp": 1631967819
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Result is FFI safe? I always assumed proc macros were <code>fn (TokenStream) -&gt; TokenStream</code>, because they couldn’t have Result.</p>",
        "id": 253865097,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1631968014
    },
    {
        "content": "<p>Result isn't FFI safe, but proc macros don't need to be</p>",
        "id": 253865110,
        "sender_full_name": "simulacrum",
        "timestamp": 1631968030
    },
    {
        "content": "<p>we already have custom serialization/deserialization code for all proc macro calls / APIs that passes things over ffi in safe way</p>",
        "id": 253865125,
        "sender_full_name": "simulacrum",
        "timestamp": 1631968064
    },
    {
        "content": "<p>I mean, now I’m more curious why it’s not Result. It’s a bit annoying that proc macro error handling is different from everything else.</p>",
        "id": 253865217,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1631968169
    },
    {
        "content": "<p>Either way, the  main benefit would still be being able to put everything in one crate and avoiding the triangle of crates I run into today of <code>crate</code>, <code>crate-macros</code>, and <code>crate-shared</code> when I have code I want to share between macros and the runtime, such as string parsing code.</p>",
        "id": 253865438,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1631968429
    },
    {
        "content": "<p>One issue is type checking, this would need to determine the macros with type checking... which affects macro expansion, which affects type checking.</p>",
        "id": 253865525,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631968508
    },
    {
        "content": "<p>(It also pushes macro expansion later)</p>",
        "id": 253865644,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631968643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> That’s a good point about type checking, how would it push macro expansion later?</p>",
        "id": 253865728,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1631968717
    },
    {
        "content": "<p>It seems like it would push macro expansion closer to codegen, sometime after monomorphization. Although I guess this might not be a fundamental problem.</p>",
        "id": 253865826,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631968813
    },
    {
        "content": "<p>hold up. there's two things being mixed here.</p>\n<ol>\n<li>defining a proc macro in a crate that also uses said proc macro</li>\n<li>running proc macros in CTFE (or maybe simply in miri)</li>\n</ol>",
        "id": 253875070,
        "sender_full_name": "oli",
        "timestamp": 1631978382
    },
    {
        "content": "<p>the latter is straight forward (but not simple) to do, and if we use miri instead of CTFE we already got everything like heap, files and stuff working and can nicely sandbox it. The miri thing is the same idea as just doing it by compiling the proc macro to wasm and running that.</p>",
        "id": 253875165,
        "sender_full_name": "oli",
        "timestamp": 1631978472
    },
    {
        "content": "<p>defining proc macros inline is slightly more involved. Especially defining them in libcore XD. I mean... do we keep two separate dependency graphs for inline proc macros and the actual crate? Otherwise you can't have a heap in libcore as you don't have Box or Vec. If we keep two separate dependency graphs... what is the libcore of the proc macro? the one rustc was built with? Are we using proc macros in libcore today? It seems to me like that would be a first intermediate step</p>",
        "id": 253875509,
        "sender_full_name": "oli",
        "timestamp": 1631978864
    },
    {
        "content": "<p>As a less confusing example: How would you handle the heap in such proc macros for targets that have no liballoc?</p>",
        "id": 253875569,
        "sender_full_name": "oli",
        "timestamp": 1631978921
    },
    {
        "content": "<p>we'd have to fall back to using the host. But now you're mixing host code and target code in one crate. I don't know if we can possibly keep that sane</p>",
        "id": 253875591,
        "sender_full_name": "oli",
        "timestamp": 1631978955
    },
    {
        "content": "<p>don't proc macros always run on the host using host code?</p>",
        "id": 253878594,
        "sender_full_name": "Lokathor",
        "timestamp": 1631982163
    },
    {
        "content": "<p>They wouldn't when if const proc macros were to be introduced.</p>",
        "id": 253879046,
        "sender_full_name": "bjorn3",
        "timestamp": 1631982678
    },
    {
        "content": "<p>but the host is doing the compiling, and the proc macro must be fully compiled and executed before the overall compilation is done. Even if it's const, the host is still doing it.</p>",
        "id": 253883625,
        "sender_full_name": "Lokathor",
        "timestamp": 1631987602
    },
    {
        "content": "<p>Sure, but in case of const proc macro, the proc macro is part of the crate that uses it AFAIUI. This crate will be compiled for the target and not host when it isn't used by a build script.</p>",
        "id": 253890868,
        "sender_full_name": "bjorn3",
        "timestamp": 1631995829
    },
    {
        "content": "<p>Probably off topic, but why are proc macro crates set up like this? It seems like they should be compile time only and should not cause a literal crate dependency that could cause proc macro code to get linked in with stuff compiled for the target</p>",
        "id": 253891062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631996078
    },
    {
        "content": "<p>They don't get linked with target crates, Cargo knows that they're proc macro crates and only builds them for the host</p>",
        "id": 253891175,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1631996223
    },
    {
        "content": "<p>is that the same distinction as <code>dependencies</code> vs <code>dev-dependencies</code>?</p>",
        "id": 253891258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631996298
    },
    {
        "content": "<p>because IIRC proc macro crates look like regular dependencies in the Cargo.toml file</p>",
        "id": 253891286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631996338
    },
    {
        "content": "<p>Cargo does this automatically for proc macros</p>",
        "id": 253892028,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1631997142
    },
    {
        "content": "<p><code>dev-dependencies</code> get built for the target, so it's not the same thing</p>",
        "id": 253892048,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1631997178
    },
    {
        "content": "<p><code>build-dependencies</code> get built for the host, so it's closer to that</p>",
        "id": 253892060,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1631997196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Const.20procedural.20macros/near/253883625\">said</a>:</p>\n<blockquote>\n<p>but the host is doing the compiling, and the proc macro must be fully compiled and executed before the overall compilation is done. Even if it's const, the host is still doing it.</p>\n</blockquote>\n<p>Const eval is executed as target though. If you are crossing from 64-bit host to 32-bit target, then in const eval <code>size_of::&lt;usize&gt;()</code> is 4, but in proc macro <code>size_of::&lt;usize&gt;()</code> is 8.</p>",
        "id": 253895300,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632000893
    },
    {
        "content": "<p>I don't think there is any contradiction here, because of the two \"meta-levels\" involved. Inside the proc macro, <code>size_of::&lt;usize&gt;()</code> evaluates to 8, but you can construct a <code>TokenTree</code> representing <code>\"size_of::&lt;usize&gt;()\"</code> and that will eventually be compiled as target and evaluate to 4</p>",
        "id": 253895872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632001577
    },
    {
        "content": "<p>although maybe I'm missing a subtlety about what is \"const\" in this proposal</p>",
        "id": 253895904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632001637
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I think you have it, at least that’s how I would expect it to work, but I think that does show that having it in one crate is a bit of a double-edged sword. For example; the following might not behave like you expect.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">PTR_SIZE</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">derive</span><span class=\"p\">(</span><span class=\"n\">TokenStream</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">TokenStream</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"c1\">// 4 or 8?</span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PTR_SIZE</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 253912939,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1632021691
    },
    {
        "content": "<p>I don't know whether that is the sort of thing that people will guess wrong and cause bugs, but I would hope that that returns 8. Everything in and upstream of a proc macro crate should be relative to the host parameters</p>",
        "id": 253913077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632021845
    },
    {
        "content": "<p>Is it possible for the downstream crate to use <code>PTR_SIZE</code>? Or does cargo's proc-macro handling mean that functions and constants are not really linked in or available</p>",
        "id": 253913123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632021932
    },
    {
        "content": "<p>Ah...</p>\n<div class=\"codehilite\"><pre><span></span><code>error: `proc-macro` crate types currently cannot export any items other than functions tagged with `#[proc_macro]`, `#[proc_macro_derive]`, or `#[proc_macro_attribute]`\n  --&gt; bar/src/lib.rs:16:1\n   |\n16 | pub const FOO: usize = std::mem::size_of::&lt;usize&gt;();\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre></div>",
        "id": 253913481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632022323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Const.20procedural.20macros/near/253913123\">said</a>:</p>\n<blockquote>\n<p>Is it possible for the downstream crate to use <code>PTR_SIZE</code>? Or does cargo's proc-macro handling mean that functions and constants are not really linked in or available</p>\n</blockquote>\n<p>The way you do that today is you have to a third regular crate that exposes all of your shared code between proc-macros and regular code, that you depend on in both <code>crate</code> and <code>crate-macros</code>.</p>",
        "id": 253941253,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1632053905
    }
]