[
    {
        "content": "<p>Does anything speak against stabilizing panicking, if, match, loop and short circuiting ops? It's been on nightly for a few months, we're using it for libstd stuff already. cc <span class=\"user-group-mention\" data-user-group-id=\"1916\">@WG-const-eval</span></p>",
        "id": 190596894,
        "sender_full_name": "oli",
        "timestamp": 1584191335
    },
    {
        "content": "<p>How comfortable everyone is committing to value-based dataflow analysis, which determines whether e.g. a particular value of <code>Option&lt;Box&lt;T&gt;&gt;</code> has a meaningful destructor, as the engine that powers const-checking? You can imagine a world in which, before <code>let</code> bindings were stabilized in a const context, we only did the value-based analysis for single expressions (e.g., <code>const NULL: Option&lt;Box&lt;T&gt;&gt; = None;</code>). My concern is that we are committing to an implementation that has some compile-time overhead and will be difficult to explain to users (especially once <code>&amp;mut</code> is legal in a const context) without a lot of motivating use cases: the value based analysis allows users to write code such as the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 190611723,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584215923
    },
    {
        "content": "<p>Is code in that style worth the additional runtime complexity? Or should we just use type-based analysis once a local is assigned multiple times.</p>",
        "id": 190611809,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584216056
    },
    {
        "content": "<p>Did you mean to write <code>None</code> twice?</p>",
        "id": 190611810,
        "sender_full_name": "bjorn3",
        "timestamp": 1584216056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> yes</p>",
        "id": 190611815,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584216067
    },
    {
        "content": "<p>I can't think of a motivating use case at the moment, but basically the value-based dataflow analysis allows the user to assign to a local multiple times as long as the final assignment on all code paths does not have a meaningful <code>Drop</code> impl.</p>",
        "id": 190611879,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584216158
    },
    {
        "content": "<p>While I'm fine with the type based analysis, won't it be confusing for users if some things only work in the trailing expression of a const initializer? We can't regress anything there so we need to keep it around anyway.</p>",
        "id": 190613045,
        "sender_full_name": "oli",
        "timestamp": 1584217808
    },
    {
        "content": "<p>That said, we can always start with a type based version and keep the value based one behind a feature gate</p>",
        "id": 190613079,
        "sender_full_name": "oli",
        "timestamp": 1584217877
    },
    {
        "content": "<p>It's strictly forward compatible</p>",
        "id": 190613081,
        "sender_full_name": "oli",
        "timestamp": 1584217886
    },
    {
        "content": "<p>We allow the code like the following today, so I'm not really sure what a reduced version of the value-based analysis would look like. The  \"assigned once\" rule isn't backwards compatible.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>",
        "id": 190613529,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584218615
    },
    {
        "content": "<p>Performance hasn't been an issue so far, but in a world in which the majority of functions are <code>const fn</code> that may no longer be true.</p>",
        "id": 190613603,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584218739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190613529\" title=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190613529\">said</a>:</p>\n<blockquote>\n<p>We allow the code like the following today, so I'm not really sure what a reduced version of the value-based analysis would look like. The  \"assigned once\" rule isn't backwards compatible.</p>\n</blockquote>\n<p>So maybe we have no realistic option besides the status quo, but it's probably good to explore the solution space a bit.</p>",
        "id": 190613773,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584218993
    },
    {
        "content": "<p>before stabilizing</p>",
        "id": 190613814,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1584219004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190613603\" title=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190613603\">said</a>:</p>\n<blockquote>\n<p>Performance hasn't been an issue so far, but in a world in which the majority of functions are <code>const fn</code> that may no longer be true.</p>\n</blockquote>\n<p>We could benchmark this. We can run the const fn analysis without emitting errors on all functions</p>",
        "id": 190957407,
        "sender_full_name": "oli",
        "timestamp": 1584524918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> a more realistic example would choose between multiple variants, none of which need drop or w/e</p>",
        "id": 191491472,
        "sender_full_name": "eddyb",
        "timestamp": 1584977919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190957407\" title=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190957407\">said</a>:</p>\n<blockquote>\n<p>We could benchmark this. We can run the const fn analysis without emitting errors on all functions</p>\n</blockquote>\n<p>see <a href=\"https://github.com/rust-lang/rust/issues/70450\" title=\"https://github.com/rust-lang/rust/issues/70450\">#70450</a></p>",
        "id": 191963383,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585266762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <a href=\"https://perf.rust-lang.org/compare.html?start=93dc97a85381cc52eb872d27e50e4d518926a27c&amp;end=51cf313c7946365d5be38113950703c6aea9f2f3\" title=\"https://perf.rust-lang.org/compare.html?start=93dc97a85381cc52eb872d27e50e4d518926a27c&amp;end=51cf313c7946365d5be38113950703c6aea9f2f3\">https://perf.rust-lang.org/compare.html?start=93dc97a85381cc52eb872d27e50e4d518926a27c&amp;end=51cf313c7946365d5be38113950703c6aea9f2f3</a></p>",
        "id": 193536822,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586492042
    },
    {
        "content": "<p>This runs the dataflow analyses required for const-checking on every function that doesn't return an opaque type, which caused query cycles.</p>",
        "id": 193536844,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586492094
    },
    {
        "content": "<p>up to 5% slower on check builds</p>",
        "id": 193537004,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586492347
    },
    {
        "content": "<p>which may be acceptable?</p>",
        "id": 193537026,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586492375
    },
    {
        "content": "<p>Also, <code>wg-grammar</code> had a different cycle error, so there's no results for it</p>",
        "id": 193537080,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586492437
    },
    {
        "content": "<p>3% average, remembering that this is worst case that won't happen in many many years, feels very acceptable</p>",
        "id": 193642691,
        "sender_full_name": "centril",
        "timestamp": 1586581025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190613079\" title=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/190613079\">said</a>:</p>\n<blockquote>\n<p>That said, we can always start with a type based version and keep the value based one behind a feature gate</p>\n</blockquote>\n<p>I would prefer doing this. I think it's better to roll out a more conservative version first, then see how it's used and extend if necessary. It would also be easier from the POV of specification and testing, and I would have an easier time to sign-off as it would be something I could understand, unlike the dataflow version (though I need to immerse myself in that).</p>",
        "id": 193682524,
        "sender_full_name": "centril",
        "timestamp": 1586643580
    },
    {
        "content": "<p>No promises that the type based version will not also have a similar slowdown ;)</p>",
        "id": 193894590,
        "sender_full_name": "oli",
        "timestamp": 1586870187
    },
    {
        "content": "<p>I'm not too concerned about that aspect <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 193934505,
        "sender_full_name": "centril",
        "timestamp": 1586886938
    },
    {
        "content": "<p>So the conservative version is basically: Look for a <code>SwitchInt</code> terminator in the body. If one exists, fall back to type-based qualification (we only need to consider <code>SwitchInt</code> since we don't const-check the unwind path). Otherwise use the existing dataflow-based qualification since it's equivalent to a linear approach. There's probably some edge-cases around e.g. exhaustive single-arm match statements.</p>\n<p>This will be difficult to explain to users if they are relying on value-based const qualification. For example, adding an unrelated <code>assert</code> to <code>foo</code> will cause it to no longer compile  (taking a reference is only legal if  we can prove<code>T: Freeze</code>).</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nb\">&#39;static</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>I'd like to talk about this at a lang team meeting. It's worth noting that we could put off running dataflow until we actually see a <code>Drop</code> terminator or <code>Rvalue::Ref</code> for a type that <em>may</em> have <code>NeedsDrop</code> or <code>Rvalue::Ref</code>, so the worst-case is probably less than 2-5%.</p>",
        "id": 193944644,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586891810
    },
    {
        "content": "<p>OTOH, I'm guessing that many real-world uses of branchy <code>const fn</code> are  using primitive integer types, which will work just fine with the conservative approach. Of course, these are the same examples that would benefit from lazily doing dataflow.</p>",
        "id": 193945059,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586892016
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> that const fn doesn't compile without such an assert either</p>",
        "id": 194019256,
        "sender_full_name": "oli",
        "timestamp": 1586952608
    },
    {
        "content": "<p>I believe a better example is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Option</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>::<span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 194019505,
        "sender_full_name": "oli",
        "timestamp": 1586952723
    },
    {
        "content": "<p>I wrote up <a href=\"https://github.com/rust-lang/rust/issues/49146#issuecomment-614012476\" title=\"https://github.com/rust-lang/rust/issues/49146#issuecomment-614012476\">https://github.com/rust-lang/rust/issues/49146#issuecomment-614012476</a> and nominated it for T-lang discussion</p>",
        "id": 194022699,
        "sender_full_name": "oli",
        "timestamp": 1586954287
    },
    {
        "content": "<p>imo we should just go with the full version to keep the implementation and language simple</p>",
        "id": 194022735,
        "sender_full_name": "oli",
        "timestamp": 1586954313
    },
    {
        "content": "<p>special cases just breed problems</p>",
        "id": 194022747,
        "sender_full_name": "oli",
        "timestamp": 1586954322
    },
    {
        "content": "<p>This was discussed during the lang team meeting today. I'm going to write up a stabilization report and propose we start FCP. I'll post a draft here before I put in on GitHub.</p>\n<p>One of the things niko asked for was a recommendation from const-eval people. I know that <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> and I are both in favor of stabilizing the current behavior, which I'll note in the proposal. <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  lemme know if you have thoughts that you want included in the stabilization report.</p>",
        "id": 194393440,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587095247
    },
    {
        "content": "<p>Hm, I mostly stayed out of const-checking discussion and I am not familiar with the new const-checking framework (just very happy to see the old mess gone).</p>",
        "id": 194398883,
        "sender_full_name": "RalfJ",
        "timestamp": 1587104665
    },
    {
        "content": "<p>My focus for const-eval is the Miri engine itself, and I am fairly confident that that correctly implements all Rust control flow operators and that at least post-monomorphization, we also catch all const-correctness concerns (modulo what is tracked in <a href=\"https://github.com/rust-lang/const-eval/issues/17\" title=\"https://github.com/rust-lang/const-eval/issues/17\">https://github.com/rust-lang/const-eval/issues/17</a>).</p>",
        "id": 194398910,
        "sender_full_name": "RalfJ",
        "timestamp": 1587104726
    },
    {
        "content": "<p>Since stabilization concerns seem to be mostly about the static const-checking, I'm afraid I don't think I have much to contribute, and I probably won't have the time to dig into that code to give an informed opinion. I trust you guys on that. :)</p>",
        "id": 194398993,
        "sender_full_name": "RalfJ",
        "timestamp": 1587104796
    },
    {
        "content": "<h1>Summary</h1>\n<p>I propose that we stabilize <code>#![feature(const_if_match)]</code> with the current<br>\nsemantics.</p>\n<p>Specifically, <code>if</code> and <code>match</code> expressions as well as the short-circuiting<br>\nlogic operators <code>&amp;&amp;</code> and <code>||</code> will become legal in all const contexts. A const<br>\ncontext is any of the following:</p>\n<ul>\n<li>The initializer of a <code>const</code>, <code>static</code>, <code>static mut</code> or enum discriminant.</li>\n<li>The body of a <code>const fn</code>.</li>\n<li>The value of a const generic.</li>\n<li>The length of an array type (<code>[u8; 3]</code>) or an array repeat expression (<code>[0u8; 3]</code>).</li>\n</ul>\n<p>Furthermore, the short-circuiting logic operators will no longer be lowered to<br>\ntheir bitwise equivalents (<code>&amp;</code> and <code>|</code> respectively) in <code>const</code> and <code>static</code><br>\ninitializers (see <a href=\"https://github.com/rust-lang/rust/issues/57175\" title=\"https://github.com/rust-lang/rust/issues/57175\">#57175</a>). As a result, <code>let</code> bindings can be used alongside<br>\nshort-circuiting logic in those initializers.</p>\n<p>Tracking issue: <a href=\"https://github.com/rust-lang/rust/issues/49146\" title=\"https://github.com/rust-lang/rust/issues/49146\">#49146</a><br>\nVersion target: 1.45 (2020-06-16)</p>\n<h2>Implementation History</h2>\n<p><a href=\"https://github.com/rust-lang/rust/issues/64470\" title=\"https://github.com/rust-lang/rust/issues/64470\">#64470</a> implemented a value-based static analysis that supported conditional<br>\ncontrol-flow and was based on dataflow. This, along with <a href=\"https://github.com/rust-lang/rust/issues/63812\" title=\"https://github.com/rust-lang/rust/issues/63812\">#63812</a>, allowed us<br>\nto replace the old const-checking code with one that worked on complex<br>\ncontrol-flow graphs. The old const-checker was run in parallel with the<br>\ndataflow-based one for a time to make sure that they agreed on programs with<br>\nsimple control flow. <a href=\"https://github.com/rust-lang/rust/issues/66385\" title=\"https://github.com/rust-lang/rust/issues/66385\">#66385</a> removed the old const-checker in favor of the<br>\ndataflow-based one.</p>\n<p><a href=\"https://github.com/rust-lang/rust/issues/66507\" title=\"https://github.com/rust-lang/rust/issues/66507\">#66507</a> implemented the <code>#![feature(const_if_match)]</code> feature gate with the<br>\nsemantics that are now being proposed for stabilization.</p>\n<h2>Const Qualification</h2>\n<h3>Background</h3>\n<p>[Miri] has powered compile-time function evaluation (CTFE) in <code>rustc</code> for<br>\nseveral years now, and has been able to evaluate conditional statements for at<br>\nleast that long. During CTFE, we must avoid certain operations, such<br>\nas calling custom <code>Drop</code> impls or taking a reference to a value with interior<br>\nmutability. Collectively, these disqualifying properties are known as<br>\n\"qualifications\", and the process of determining whether a value has a<br>\nqualification at a specific point in the program is known as \"const<br>\nqualification\".</p>\n<p>Miri is perfectly capable of emitting an error when it encounters an illegal<br>\noperation on a qualified value, and it can do so with no false positives.<br>\nHowever, CTFE occurs post-monomorphization, meaning it cannot know if constants<br>\ndefined in a generic context are valid until they are instantiated by a<br>\ndownstream crate. To get pre-monomorphization errors, we must implement a<br>\nstatic analysis that does const qualification. In general, const qualification<br>\nis undecidable (it is isomorphic to the halting problem), so any static<br>\nanalysis can only approximate the checks that Miri performs during CTFE.</p>\n<p>Our static analysis must forbid a reference to a type with interior mutability<br>\n(e.g. <code>&amp;Cell&lt;i32&gt;</code>) from appearing in the final value of a <code>const</code>.  If this<br>\nwere allowed, a <code>const</code> could be modified at run-time.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// ILLEGAL: A reference to a type with interior mutability cannot appear in the final value of a `const`.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">std</span>::<span class=\"n\">cell</span>::<span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">std</span>::<span class=\"n\">cell</span>::<span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// 0</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// 42</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>However, we allow the user to define a <code>const</code> whose <em>type</em> has interior<br>\nmutability (<code>!Freeze</code>) as long as we can prove that the final <em>value</em> of that<br>\n<code>const</code> does not. For example, the following has compiled since [the first<br>\nedition of stable rust][rustv1]:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_X</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"nb\">&#39;static</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">cell</span>::<span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>This approach to static analysis, which I will call value-based as opposed to<br>\ntype-based, is also used to check for code that may result in a custom <code>Drop</code><br>\nimpl being called. Calling <code>Drop</code> impls is problematic because they are not<br>\nconst-checked and thus can contain code that would not be allowed in a const<br>\ncontext. Value-based reasoning was extended to support <code>let</code> statements,<br>\nmeaning the following [compiles on rust 1.42.0 stable][drop].</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"nb\">Vec</span>::<span class=\"n\">new</span><span class=\"p\">());</span><span class=\"w\"> </span><span class=\"c1\">// Causes the old value in `y` to be dropped.</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>\n\n\n<h3>Current Semantics</h3>\n<p>The current behavior of <code>#![feature(const_if_match)]</code> extends the value-based<br>\nsemantics to work on complex control-flow graphs by using dataflow. In other<br>\nwords, we try to prove that a variable does not have the qualification in<br>\nquestion along <em>all possible paths</em> through the program.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">enum</span> <span class=\"nc\">Int</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Zero</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">One</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Many</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// Dropping this variant is not allowed in a `const fn`...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ...but the following code is legal under this proposal...</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">good</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>::<span class=\"n\">Zero</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>::<span class=\"n\">One</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// ...because `i` is never `Int::Many` on any possible path through the program.</span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>All possible paths through the program include ones that may never be reached<br>\nin practice as long as they exist in the source code. An example, using the<br>\nsame <code>Int</code> enum as above:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bad</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Int</span>::<span class=\"n\">One</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Int</span>::<span class=\"n\">Zero</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// This branch is dead code. It can never be reached in practice.</span>\n<span class=\"w\">        </span><span class=\"c1\">// However, const qualification treats it as a possible path because it</span>\n<span class=\"w\">        </span><span class=\"c1\">// exists in the source code.</span>\n<span class=\"w\">        </span><span class=\"n\">Int</span>::<span class=\"n\">Many</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// ILLEGAL: `i` was assigned the `Int::Many` variant on at least one code path.</span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>This analysis treats function calls as opaque, assuming that their return value<br>\nmay contain any value of its type. We also fall back to a type-based analysis<br>\nfor a variable as soon as a mutable reference to it is created. Note that<br>\ncreating a mutable reference in a const context is currently forbidden on<br>\nstable rust.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#![feature(const_mut_refs)]</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">none</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ILLEGAL: We must assume that `none` may return any value of type `Option&lt;Cell&lt;i32&gt;&gt;`.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">BAD</span>: <span class=\"kp\">&amp;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">also_bad</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Option</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span>::<span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// ILLEGAL: because a mutable reference to `x` was created, we can no</span>\n<span class=\"w\">    </span><span class=\"c1\">// longer assume anything about its value.</span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<h2>Alternatives</h2>\n<p>I've found it difficult to come up with practical, backwards compatible<br>\nalternatives to the existing approach. We could fall back to type-based<br>\nanalysis for all variables as soon as conditionals are used in a const context.<br>\nHowever, that would also be difficult to explain to users, since seemingly<br>\nunrelated additions would cause code to no longer compile, such as the <code>assert</code><br>\nin the following example from @oli-obk.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">b</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Option</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>::<span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>The increased expressiveness of the dataflow-based analysis is not free. A<br>\nperf run that did const qualification on all item bodies, not just <code>const</code><br>\nones, showed up to a [5% regression on check builds][perf]. This is a<br>\nworst-case scenario, as it assumes that all items will be made <code>const</code> at some<br>\npoint in the future. It also assumes no further optimizations are done to const<br>\nqualification. Some possible ones are discussed earlier in this thread.</p>\n<h2>Future work</h2>\n<p>At the moment, const-checking is run before drop elaboration, meaning some drop<br>\nterminators remain in the MIR that are unreachable in practice. This is<br>\npreventing <code>Option::unwrap</code> from becoming <code>const fn</code> (see <a href=\"https://github.com/rust-lang/rust/issues/66753\" title=\"https://github.com/rust-lang/rust/issues/66753\">#66753</a>). This is<br>\nnot too hard to resolve, but it will require splitting the const-checking pass<br>\ninto two phases (pre- and post-drop elaboration).</p>\n<p>Once <code>#![feature(const_if_match)]</code> is stabilized, a great deal of library<br>\nfunctions can be made <code>const fn</code>. This includes many methods on primitive<br>\ninteger types, which have been enumerated in <a href=\"https://github.com/rust-lang/rust/issues/53718\" title=\"https://github.com/rust-lang/rust/issues/53718\">#53718</a>.</p>\n<p>Loops in a const context are blocked on the same const qualification question<br>\nthat was blocking conditionals. The dataflow-based analysis extends to cyclic<br>\nCFGs as well, so if <code>#![feature(const_if_match)]</code> is stabilized, the main<br>\nblocker for loops will be gone.</p>\n<h2>Acknowledgements</h2>\n<p>Special thanks are due to @oli-obk and @eddyb, who were the primary reviewers<br>\nfor most of the implementation work, as well as the rest of<br>\n@rust-lang/wg-const-eval for helping me understand the relevant issues<br>\naround const qualification. None of this would be possible without Miri,<br>\nwhich was created by @solson and now maintained by @RalfJ and @oli-obk.</p>\n<p>[Miri]: <a href=\"https://github.com/rust-lang/miri\" title=\"https://github.com/rust-lang/miri\">https://github.com/rust-lang/miri</a><br>\n[rustv1]: <a href=\"https://rust.godbolt.org/z/Md59pg\" title=\"https://rust.godbolt.org/z/Md59pg\">https://rust.godbolt.org/z/Md59pg</a><br>\n[drop]: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2b35bd82d1899cc69c7d46aeaed87e50\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2b35bd82d1899cc69c7d46aeaed87e50\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2b35bd82d1899cc69c7d46aeaed87e50</a><br>\n[perf]: <a href=\"https://perf.rust-lang.org/compare.html?start=93dc97a85381cc52eb872d27e50e4d518926a27c&amp;end=51cf313c7946365d5be38113950703c6aea9f2f3\" title=\"https://perf.rust-lang.org/compare.html?start=93dc97a85381cc52eb872d27e50e4d518926a27c&amp;end=51cf313c7946365d5be38113950703c6aea9f2f3\">https://perf.rust-lang.org/compare.html?start=93dc97a85381cc52eb872d27e50e4d518926a27c&amp;end=51cf313c7946365d5be38113950703c6aea9f2f3</a></p>",
        "id": 194499695,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587157461
    },
    {
        "content": "<p>Phew, that's quite long, but hopefully gives enough background that I don't have to explain the history of const qualification anymore.</p>",
        "id": 194499805,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587157539
    },
    {
        "content": "<p>Lemme know if I missed anything, particularly in the implementation work section, since I basically just included my own stuff.</p>",
        "id": 194499933,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587157590
    },
    {
        "content": "<p>wow that looks awesome</p>",
        "id": 194509161,
        "sender_full_name": "eddyb",
        "timestamp": 1587163639
    },
    {
        "content": "<p>I remain in awe of <a href=\"https://github.com/rust-lang/rust/issues/67712\" title=\"https://github.com/rust-lang/rust/issues/67712\">#67712</a>.</p>",
        "id": 194509513,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587163965
    },
    {
        "content": "<p>okay now that is just showing off</p>",
        "id": 194509574,
        "sender_full_name": "eddyb",
        "timestamp": 1587164017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> this is great, thanks a lot for the write-up!</p>",
        "id": 194533583,
        "sender_full_name": "RalfJ",
        "timestamp": 1587199285
    },
    {
        "content": "<p>I think we might be able to copy some of that into the rustc-dev-guide verbatim, like the interaction of pre-mono const qualification and post-mono miri checks. Cc <a href=\"https://github.com/rust-lang/rustc-dev-guide/pull/676\" title=\"https://github.com/rust-lang/rustc-dev-guide/pull/676\">https://github.com/rust-lang/rustc-dev-guide/pull/676</a></p>",
        "id": 194533630,
        "sender_full_name": "RalfJ",
        "timestamp": 1587199330
    },
    {
        "content": "<blockquote>\n<p>Furthermore, the short-circuiting logic operators will no longer be lowered to<br>\ntheir bitwise equivalents (&amp; and | respectively) in const and static<br>\ninitializers</p>\n</blockquote>\n<p>I am <em>so</em> happy to see this hack die! <span aria-label=\"flame\" class=\"emoji emoji-1f525\" role=\"img\" title=\"flame\">:flame:</span></p>",
        "id": 194533634,
        "sender_full_name": "RalfJ",
        "timestamp": 1587199341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/194533630\" title=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilize.20control.20flow/near/194533630\">said</a>:</p>\n<blockquote>\n<p>I think we might be able to copy some of that into the rustc-dev-guide verbatim, like the interaction of pre-mono const qualification and post-mono miri checks. Cc <a href=\"https://github.com/rust-lang/rustc-dev-guide/pull/676\" title=\"https://github.com/rust-lang/rustc-dev-guide/pull/676\">https://github.com/rust-lang/rustc-dev-guide/pull/676</a></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> ohh yes, as <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> have said, would be great if we copy some of this stuff to the rustc-dev-guide <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 194598677,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1587304280
    },
    {
        "content": "<p>Sounds good. I'll wait until that PR is merged and come over the top with something.</p>",
        "id": 194615222,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587326225
    },
    {
        "content": "<p>I was hoping to get <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>'s eyes on this before uploading. I'll wait until tonight (in ~8 hours) and then post it.</p>",
        "id": 194615304,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587326343
    },
    {
        "content": "<p>reading now</p>",
        "id": 194804047,
        "sender_full_name": "oli",
        "timestamp": 1587477053
    },
    {
        "content": "<p>general note: maybe some things could use links to the reference (e.g. for const contexts)</p>",
        "id": 194804601,
        "sender_full_name": "oli",
        "timestamp": 1587477296
    },
    {
        "content": "<p>We should mention that it may be desirable to stabilize loops at the same time, as otherwise users can just write \"loops\" via recursion, which may cause weird crates to be created just to work around the issue that we don't have loops stabilized</p>",
        "id": 194806553,
        "sender_full_name": "oli",
        "timestamp": 1587478029
    },
    {
        "content": "<p>One related thing is that we have the chance to make <a href=\"https://github.com/rust-lang/rust/issues/62411\" title=\"https://github.com/rust-lang/rust/issues/62411\">https://github.com/rust-lang/rust/issues/62411</a> a hard error in const fns</p>",
        "id": 194819469,
        "sender_full_name": "oli",
        "timestamp": 1587483014
    },
    {
        "content": "<p>I added a link to const contexts to the summary. I think the next two would be good \"concern\"s? Or do we wanna try to resolve those ahead of time?</p>",
        "id": 194821248,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587483729
    },
    {
        "content": "<p>both are just concerns, we should ask what the lang team thinks first</p>",
        "id": 194821747,
        "sender_full_name": "oli",
        "timestamp": 1587483945
    }
]