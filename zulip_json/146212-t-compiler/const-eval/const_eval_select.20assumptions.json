[
    {
        "content": "<p>I only just noticed this in the const_eval_select docs</p>\n<blockquote>\n<p>The Rust compiler assumes that it is sound to replace a call to a const fn with the result produced by evaluating it at compile-time. If evaluating the function at run-time were to produce a different result, or have any other observable side-effects, the behavior is undefined.</p>\n</blockquote>\n<p>I don't think this is a good idea. This kind of UB is at best extremely hard to check for -- it is very hard to even define properly. <br>\n(Defining it properly requires defining what \"same result\" means, and equality is hard -- in particular since in this case this is equality of the whole machine state due to possible side-effects.)<br>\nWe shouldnt have UB that we can not properly define or test for. Hence I dont think we should allow the compiler to do such replacement.</p>",
        "id": 262595905,
        "sender_full_name": "RalfJ",
        "timestamp": 1637764272
    },
    {
        "content": "<p>yea, it's more \"library-UB\" than anything else</p>",
        "id": 262597480,
        "sender_full_name": "oli",
        "timestamp": 1637765138
    },
    {
        "content": "<p>it pretty clearly says \"the compiler assumes\" though, which cannot be library UB</p>",
        "id": 262626166,
        "sender_full_name": "RalfJ",
        "timestamp": 1637779120
    },
    {
        "content": "<p>Yea, that's mostly suboptimal formulation. I don't believe anyone has plans to actually do this. I don't see a reason for it. It's just the same problem with any other optimization that eagerly evaluates a const fn call or memoizes it at runtime. We have no way of knowing whether a const fn is pure</p>",
        "id": 262626701,
        "sender_full_name": "oli",
        "timestamp": 1637779449
    },
    {
        "content": "<p>Hm, I wondering what it would even mean for this to be \"library UB\", given that it is a language intrinsic...</p>",
        "id": 262941915,
        "sender_full_name": "RalfJ",
        "timestamp": 1638124539
    },
    {
        "content": "<p>and I think there is an interesting underlying safety question here: given a safe crate <code>evil</code>, is it sound to write code like this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">dont_be_evil</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">evil</span>::<span class=\"n\">do_something</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">evil</span>::<span class=\"n\">do_something</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">unreachable_unchecked</span><span class=\"p\">()</span>: <span class=\"p\">}}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262941983,
        "sender_full_name": "RalfJ",
        "timestamp": 1638124607
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/91325\">https://github.com/rust-lang/rust/pull/91325</a></p>",
        "id": 262943108,
        "sender_full_name": "RalfJ",
        "timestamp": 1638126069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const_eval_select.20assumptions/near/262597480\">said</a>:</p>\n<blockquote>\n<p>yea, it's more \"library-UB\" than anything else</p>\n</blockquote>\n<p>I am pretty sure we are already violating this with <code>align_offset</code>...<br>\n<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8118d91a56a277ecb6653c8c70a66641\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8118d91a56a277ecb6653c8c70a66641</a><br>\nOr maybe I misinterpreted what you meant by \"library UB\". My interpretation of it is you want <code>dont_be_evil</code> to be sound. But it already isnt (using unstable features).</p>",
        "id": 262943421,
        "sender_full_name": "RalfJ",
        "timestamp": 1638126563
    },
    {
        "content": "<p>I think we basically either have to make <code>const_align_offset</code> <code>unsafe</code> (putting an obligation on the caller that the compiletime/runtime distinction is <em>not observable</em>), or we have to entirely get rid of this <code>const_eval_select</code> side-condition and just live with the fact that the same function can behave vastly differently at compiletime and runtime.</p>",
        "id": 262943703,
        "sender_full_name": "RalfJ",
        "timestamp": 1638126967
    },
    {
        "content": "<p>having functions behave differently at compile and runtime also helps unblock floating point in const</p>",
        "id": 262944978,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1638128988
    },
    {
        "content": "<p>honestly, i think that condition is way more trouble than its worth, even if it seems like it might be nice for the compiler to be able to do things like that</p>",
        "id": 262945030,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1638129018
    },
    {
        "content": "<p>I dont think the compiler should be able to do things like that (and I tried to make that clear above, in fact my first message in this thread complains exactly about that... not sure how I could have been more clear here. :/ ). But possibly other libraries (in particular unsafely implemented ones) should.</p>",
        "id": 262945385,
        "sender_full_name": "RalfJ",
        "timestamp": 1638129561
    },
    {
        "content": "<p>I think we'll end up violating the \"equality rule\" (whatever equality would mean) anyway, once we get const heap. I would very much like const_eval_select to be safe and public. It feels to me similarly footgunny like mem::forget, but I can't really say why it should be unsafe forever. We just declared it as such because it was the safe (heh) choice to start out with</p>",
        "id": 262947868,
        "sender_full_name": "oli",
        "timestamp": 1638133258
    },
    {
        "content": "<p>Yeah, it seems too easy for people to add stuff like debug assertions or logging to the non-const version (we even do the former in the stdlib â€” we only do it in cases where the assertion would be UB if it triggered, but i could easily see people wanting to use it for a correctness check, not realizing the issue)</p>",
        "id": 262954693,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1638142559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const_eval_select.20assumptions/near/262945385\">said</a>:</p>\n<blockquote>\n<p>I tried to make that clear above, in fact my first message in this thread complains exactly about that... not sure how I could have been more clear here. :/</p>\n</blockquote>\n<p>You were clear, I was agreeing. Sorry if it came off as a disagreement.</p>",
        "id": 262954750,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1638142626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const_eval_select.20assumptions/near/262947868\">said</a>:</p>\n<blockquote>\n<p>I think we'll end up violating the \"equality rule\" (whatever equality would mean) anyway, once we get const heap. I would very much like const_eval_select to be safe and public. It feels to me similarly footgunny like mem::forget, but I can't really say why it should be unsafe forever. We just declared it as such because it was the safe (heh) choice to start out with</p>\n</blockquote>\n<p>it's a safe choice only as long as we follow our own rules ;)</p>",
        "id": 262957169,
        "sender_full_name": "RalfJ",
        "timestamp": 1638146364
    }
]