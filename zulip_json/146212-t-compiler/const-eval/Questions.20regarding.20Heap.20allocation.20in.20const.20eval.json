[
    {
        "content": "<p>I'm trying to read up on heap allocation and in const eval, and I have a lot of questions <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>the first comment on the issue says</p>\n<div class=\"codehilite\"><pre><span></span><code>const B: String = String::from(&quot;foo&quot;); // Not OK\n</code></pre></div>\n<p>Is this going to be never supported?</p>",
        "id": 216632678,
        "sender_full_name": "vn-ki",
        "timestamp": 1605283732
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"hi\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Isn't <code>drop</code> similar to a destructor? Having a non copyable value dropping twice feels weird to me.</p>",
        "id": 216634146,
        "sender_full_name": "vn-ki",
        "timestamp": 1605284257
    },
    {
        "content": "<p>well... if you can create multiple somethings by using a constant twice, you could also create the same thing by repeating the initializer expression of the constant directly in your code.</p>",
        "id": 216634975,
        "sender_full_name": "oli",
        "timestamp": 1605284625
    },
    {
        "content": "<p>I guess this is where private fields become interesting, since you could have a public constant but no other way to construct values of something</p>",
        "id": 216635048,
        "sender_full_name": "oli",
        "timestamp": 1605284648
    },
    {
        "content": "<p>That said, your code already works on stable <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 216635121,
        "sender_full_name": "oli",
        "timestamp": 1605284689
    },
    {
        "content": "<p>the same with <code>const FOO: String = String::new();</code></p>",
        "id": 216635183,
        "sender_full_name": "oli",
        "timestamp": 1605284718
    },
    {
        "content": "<p>when i do</p>\n<div class=\"codehilite\"><pre><span></span><code>let f = FOO;\n</code></pre></div>\n<p>isn't it more or less doing an implicit copy of the struct?</p>",
        "id": 216724129,
        "sender_full_name": "vn-ki",
        "timestamp": 1605354164
    },
    {
        "content": "<p>yes, BUT... <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 216726310,
        "sender_full_name": "oli",
        "timestamp": 1605356913
    },
    {
        "content": "<p>if you can write <code>let f = String::new();</code> and <code>const FOO: String = String::new();</code> then you can write <code>let f = FOO;</code> as you could just have taken the body of <code>FOO</code> and written <code>let f = String::new();</code></p>",
        "id": 216726322,
        "sender_full_name": "oli",
        "timestamp": 1605356952
    },
    {
        "content": "<p>basically we have the invariant that all constants are <em>values</em> that can be bitwise copied, even if their <em>types</em> forbid copying values</p>",
        "id": 216726330,
        "sender_full_name": "oli",
        "timestamp": 1605356976
    },
    {
        "content": "<p>this is why the const heap situation is so complicated. <code>const FOO: String = \"foo\".to_string();</code> can never be legal.</p>",
        "id": 216726386,
        "sender_full_name": "oli",
        "timestamp": 1605357029
    },
    {
        "content": "<p>because that is a value that cannot be bitwise copied, it must be cloned.</p>",
        "id": 216726390,
        "sender_full_name": "oli",
        "timestamp": 1605357042
    },
    {
        "content": "<p>(copying here means bitwise copies, editing my messages to reflect that)</p>",
        "id": 216726396,
        "sender_full_name": "oli",
        "timestamp": 1605357060
    },
    {
        "content": "<p>okay, i think i'm a bit confused here.</p>\n<p>in DMs you had said <code>const fn muh() -&gt; Vec&lt;i32&gt; { vec![42] }</code> is something we'd want to support in the future,</p>\n<p>So, if i'm reading it correctly, we'd support <code>const fn muh() -&gt; Vec&lt;i32&gt; { vec![42] }</code> but not <code>const V: Vec&lt;i32&gt; = muh()</code>. is this right?</p>",
        "id": 216727248,
        "sender_full_name": "vn-ki",
        "timestamp": 1605357852
    },
    {
        "content": "<p>yes, but now comes the freaky part, we already support <code>const fn blub() -&gt; Vec&lt;i32&gt; { Vec::new() } const W: Vec&lt;i32&gt; = blub();</code> and we want to keep supporting it.</p>\n<p>If memory serves (and a quick skim of the const-eval#20 confirms), we'll want to forbid doing actual heap allocations via the generic <a href=\"https://doc.rust-lang.org/std/alloc/struct.Global.html\"><code>Global</code> heap</a>, and require a specific <code>ConstHeap</code> to be used. Once <code>Vec</code> gets a second generic parameter for its allocator (just like <code>Box</code> has), <code>Vec::new()</code> will still be in the <code>impl&lt;T, A&gt; Vec&lt;T, A&gt;</code> block, where <em>no</em> bounds are on <code>A</code>, so we know at compile-time that this function can be called just fine without specifying an allocator, but any use of an <a href=\"https://doc.rust-lang.org/std/alloc/trait.AllocRef.html\"><code>AllocRef</code></a> that is not <code>ConstAlloc</code> will not work <em>anyway</em> because we just won't mark them <code>const impl</code></p>",
        "id": 216728136,
        "sender_full_name": "oli",
        "timestamp": 1605358897
    },
    {
        "content": "<p>This is a bad brain dump, I apologize. Let's write up a hackmd? I think that serves the design purpose better than a chat</p>",
        "id": 216728187,
        "sender_full_name": "oli",
        "timestamp": 1605358940
    },
    {
        "content": "<p>yeah, that's better. i'll start doing that,</p>",
        "id": 216728483,
        "sender_full_name": "vn-ki",
        "timestamp": 1605359489
    },
    {
        "content": "<p>Here's the empty (for now) hackmd: <a href=\"https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA\">https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA</a></p>",
        "id": 216728541,
        "sender_full_name": "vn-ki",
        "timestamp": 1605359590
    },
    {
        "content": "<p>I don't remember that \"alternative allocator\" approach but it is intriguing</p>",
        "id": 216728941,
        "sender_full_name": "RalfJ",
        "timestamp": 1605360346
    },
    {
        "content": "<p>I wonder however if it is not too restrictive -- making existing code const-callable would now require also making it generic over the allocator</p>",
        "id": 216728985,
        "sender_full_name": "RalfJ",
        "timestamp": 1605360381
    },
    {
        "content": "<p>if that is an okay restriction, it seems however quite elegant indeed :D</p>",
        "id": 216728987,
        "sender_full_name": "RalfJ",
        "timestamp": 1605360394
    },
    {
        "content": "<p>the issue still links to <a href=\"https://github.com/rust-lang/const-eval/issues/20#issuecomment-468657992\">this</a> as the current state, is that accurate?</p>",
        "id": 216728999,
        "sender_full_name": "RalfJ",
        "timestamp": 1605360442
    },
    {
        "content": "<blockquote>\n<p>I've been reading const-eval#20, if I understand it correctly, we haven't reached a consensus on the design yet? Or is this more or less the consensus ?</p>\n<p>oli<br>\nwell.. yes and no. The \"yes\" part is that we need that anyway for anything that will get stabilized. The reason for that is that we have a static/dynamic check system which guarantees that the dynamic checks are the ones making everything sound and the static checks approximate the dynamic checks (so they reject more code than the dynamic checks) in order to make everything sane (read: not footgunny and easier to understand)<br>\nso we do need the dynamic checks on the final value, but for stabilization we'll also need to come up with a static check system</p>\n</blockquote>",
        "id": 216729114,
        "sender_full_name": "vn-ki",
        "timestamp": 1605360610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216728985\">said</a>:</p>\n<blockquote>\n<p>I wonder however if it is not too restrictive -- making existing code const-callable would now require also making it generic over the allocator</p>\n</blockquote>\n<p>We do not need to change existing const-callable code, as long as you don't actually allocate, you won't be calling code which contains any allocators. Only when you extend the allocating parts of your code will you need to make it generic</p>",
        "id": 216729162,
        "sender_full_name": "oli",
        "timestamp": 1605360720
    },
    {
        "content": "<p>this is all very confusing, thus my ramblings above. We'll write down all the details and then present it.</p>",
        "id": 216729220,
        "sender_full_name": "oli",
        "timestamp": 1605360747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216729220\">said</a>:</p>\n<blockquote>\n<p>this is all very confusing, thus my ramblings above. We'll write down all the details and then present it.</p>\n</blockquote>\n<p>using the type system to track what kind of allocation you have is the least confusing proposal in this space that I have seen so far^^</p>",
        "id": 216729691,
        "sender_full_name": "RalfJ",
        "timestamp": 1605361275
    },
    {
        "content": "<blockquote>\n<p>We do not need to change existing const-callable code, as long as you don't actually allocate, you won't be calling code which contains any allocators. Only when you extend the allocating parts of your code will you need to make it generic</p>\n</blockquote>\n<p>What I mean is, when I want to, dunno, use serde_json during CTFE, then not only will serde_json have to add <code>const</code> everywhere, it'll also have to be made generic over the allocator</p>",
        "id": 216729779,
        "sender_full_name": "RalfJ",
        "timestamp": 1605361343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216729779\">said</a>:</p>\n<blockquote>\n<p>What I mean is, when I want to, dunno, use serde_json during CTFE, then not only will serde_json have to add <code>const</code> everywhere, it'll also have to be made generic over the allocator</p>\n</blockquote>\n<p>Maybe we can come up with some advanced hackery for transient allocations?</p>",
        "id": 216730423,
        "sender_full_name": "oli",
        "timestamp": 1605362043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216730423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216729779\">said</a>:</p>\n<blockquote>\n<p>What I mean is, when I want to, dunno, use serde_json during CTFE, then not only will serde_json have to add <code>const</code> everywhere, it'll also have to be made generic over the allocator</p>\n</blockquote>\n<p>Maybe we can come up with some advanced hackery for transient allocations?</p>\n</blockquote>\n<p>that's actually not hard <em>in principle</em> -- interning could reject <code>Global</code> allocations and accept only <code>ConstHeap</code> allocations</p>",
        "id": 216730646,
        "sender_full_name": "RalfJ",
        "timestamp": 1605362315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216730646\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216730423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/216729779\">said</a>:</p>\n<blockquote>\n<p>What I mean is, when I want to, dunno, use serde_json during CTFE, then not only will serde_json have to add <code>const</code> everywhere, it'll also have to be made generic over the allocator</p>\n</blockquote>\n<p>Maybe we can come up with some advanced hackery for transient allocations?</p>\n</blockquote>\n<p>that's actually not hard <em>in principle</em> -- interning could reject <code>Global</code> allocations and accept only <code>ConstHeap</code> allocations</p>\n</blockquote>\n<p>I was hoping for a static check</p>",
        "id": 216730655,
        "sender_full_name": "oli",
        "timestamp": 1605362346
    },
    {
        "content": "<p>that seems like a problem very similar to <code>&amp;mut</code> -- allwoing things internally but not allowing them to \"leak\" to the final value</p>",
        "id": 216730876,
        "sender_full_name": "RalfJ",
        "timestamp": 1605362708
    },
    {
        "content": "<p>yea, I was thinking about a dataflow analysis, too, but in contrast to <code>&amp;mut</code> we don't have the borrowchecker that handles this for us</p>",
        "id": 216731417,
        "sender_full_name": "oli",
        "timestamp": 1605363570
    },
    {
        "content": "<p>like <code>const FOO: &amp;mut i32 = { let mut x = 42; &amp;mut x };</code> doesn't work because of the borrowchecker, not because of the dataflow analysis that prevents <code>const FOO: &amp;mut i32 = &amp;mut 42;</code></p>",
        "id": 216731473,
        "sender_full_name": "oli",
        "timestamp": 1605363621
    },
    {
        "content": "<p>with heap stuff we have owned things, so we'd need to prevent <code>const FOO: String = { let s = \"foo\".to_string(); s };</code>. If transient heap allocations use <code>Global</code>, what prevents us from putting them into the final value?</p>",
        "id": 216731545,
        "sender_full_name": "oli",
        "timestamp": 1605363741
    },
    {
        "content": "<p>the borrow checker will sop helping even for <code>&amp;mut</code> the moment we make <code>Box::leak</code> a <code>const fn</code></p>",
        "id": 216732165,
        "sender_full_name": "RalfJ",
        "timestamp": 1605364591
    },
    {
        "content": "<p>I don't think that <code>Box::leak</code> is relevant here, it has the appropriate lifetimes. If <code>T: 'a</code>and <code>'a != 'static</code> you'll get a <code>&amp;'a T</code> and never a <code>&amp;'static T</code></p>",
        "id": 216732407,
        "sender_full_name": "oli",
        "timestamp": 1605364869
    },
    {
        "content": "<p>So if you do <code>Box::leak(Box::new(&amp;mut x))</code> for <code>let mut x = 42;</code>, then you can't move that into the return value except by going through raw pointers, which will just cause a dangling pointer error</p>",
        "id": 216732437,
        "sender_full_name": "oli",
        "timestamp": 1605364917
    },
    {
        "content": "<p>what I mean is, you end up with <code>const FOO: &amp;mut i32 = { let mut x = 42; Box::leak(Box::new(x)) };</code></p>",
        "id": 216733390,
        "sender_full_name": "RalfJ",
        "timestamp": 1605365862
    },
    {
        "content": "<p>so we can now have <code>&amp;mut</code> leak into the final value</p>",
        "id": 216733392,
        "sender_full_name": "RalfJ",
        "timestamp": 1605365873
    },
    {
        "content": "<p>oh heh</p>",
        "id": 216733437,
        "sender_full_name": "oli",
        "timestamp": 1605365902
    },
    {
        "content": "<p>What about requiring the final <code>const</code> to be <code>Copy</code> if it contains any pointers to allocated data?</p>",
        "id": 216825547,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1605490956
    },
    {
        "content": "<p>non-<code>Copy</code> types work if you have the final <code>const</code>be a shared reference to your type.</p>",
        "id": 216825578,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1605491028
    },
    {
        "content": "<p>The problem is that any scheme which analyzes the final value for heap pointers will not work for associated consts of generic traits</p>",
        "id": 216852566,
        "sender_full_name": "oli",
        "timestamp": 1605521564
    },
    {
        "content": "<p>because you don't have a final value yet</p>",
        "id": 216852583,
        "sender_full_name": "oli",
        "timestamp": 1605521578
    },
    {
        "content": "<p>So you may have broken code that only errors when you use it in the end. This can cause situations similar to duck typing generics</p>",
        "id": 216852621,
        "sender_full_name": "oli",
        "timestamp": 1605521606
    },
    {
        "content": "<p>So... I've been typing up <a href=\"https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA\">https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA</a> and realized that trying some sort of <code>ConstAlloc</code> scheme can't really work, because we won't be able to track that through <code>const fn foo() -&gt; SomeStruct { SomeStruct { v: vec![42] } }</code> as no part of the function call requires any alloc scheme. Even if we made <code>Global</code>'s <code>Alloc</code> impl not <code>const</code>, we could have <code>foo</code> but the type of <code>v</code> is <code>Vec&lt;i32, ConstAlloc&gt;</code>, and we'd again not see this via any kind of static analysis</p>",
        "id": 217146146,
        "sender_full_name": "oli",
        "timestamp": 1605711953
    },
    {
        "content": "<p>we could add a \"look at bodies\" scheme for finding heap operations in <code>const fn</code>, but I'd really like to come up with something that does not require that</p>",
        "id": 217146275,
        "sender_full_name": "oli",
        "timestamp": 1605711996
    },
    {
        "content": "<p>Is the following possible?</p>\n<p>Can we only do <code>ConstSafe</code> for Vec with ConstAlloc</p>\n<div class=\"codehilite\"><pre><span></span><code>unsafe impl&lt;A: ConstAllocTrait, T&gt; ConstSafe for Vec&lt;T, A&gt;\n</code></pre></div>\n<p>?</p>",
        "id": 217181603,
        "sender_full_name": "vn-ki",
        "timestamp": 1605726355
    },
    {
        "content": "<p>On second thought, even if it's possible, it'll break <code>Vec::new()</code>, I guess</p>",
        "id": 217182107,
        "sender_full_name": "vn-ki",
        "timestamp": 1605726595
    },
    {
        "content": "<p>what about adding a new <code>const(alloc)</code> function type (there's probably a better name) which would allow associated/plain constants to enforce that their initializers must either not contain any <code>const(alloc)</code> function calls or their types must be copy (or at least not require any <code>Drop</code> code to be run). That way:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// works since `new` is not const(alloc)</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S2</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">format</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"blah {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// works since final type is `Copy`</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S3</span>: <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"a\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// error because you called a const(alloc) fn and final type is not Copy</span>\n</code></pre></div>",
        "id": 217183981,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1605727437
    },
    {
        "content": "<p>I think Copy would be required otherwise you could have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"nc\">ManuallyDrop</span><span class=\"o\">&lt;</span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"s\">\"a\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">into_inner</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// UB</span>\n</code></pre></div>",
        "id": 217185318,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1605727995
    },
    {
        "content": "<p>Isn't there still a possibility that a const(alloc) function would be using an associated trait?</p>",
        "id": 217187021,
        "sender_full_name": "vn-ki",
        "timestamp": 1605728768
    },
    {
        "content": "<blockquote>\n<p>So you may have broken code that only errors when you use it in the end. This can cause situations similar to duck typing generics</p>\n</blockquote>\n<p>This won't be avoidable in that case</p>",
        "id": 217187063,
        "sender_full_name": "vn-ki",
        "timestamp": 1605728798
    },
    {
        "content": "<p>yea... an effect sytem (so something similar to the <code>const(alloc)</code> thing) is a big big hammer with lots of nuance that we may want to avoid</p>",
        "id": 217240133,
        "sender_full_name": "oli",
        "timestamp": 1605774373
    },
    {
        "content": "<p>We can essentially achieve <code>const(alloc)</code> by forbidding the use of the <code>Const</code> allocator in <code>const fn</code>, thus all <code>const fn</code> must either not allocate or have a generic parameter that const and static items (which are allowed to use it), can then pass in</p>",
        "id": 217240438,
        "sender_full_name": "oli",
        "timestamp": 1605774628
    },
    {
        "content": "<p>though this would completely forbid the use of <code>serde_json</code> without making it very generic</p>",
        "id": 217240468,
        "sender_full_name": "oli",
        "timestamp": 1605774660
    },
    {
        "content": "<p>I think <code>const(alloc)</code> (or something with similar effect) and specifically using the default Rust allocator for const allocation would be more ergonomic to use, since we don't have to use different allocator types everywhere just to enable const alloc. We could potentially have a <code>ConstAllocSafe</code> auto trait that types implement to indicate that they don't deallocate pointers that could come from constants. So, <code>Box&lt;String&gt;</code> would implement <code>ConstAllocSafe</code> because using a <code>const</code> <code>&amp;Box&lt;String&gt;</code> can't cause deallocation of the <code>const</code>'s pointers. Nearly all types would be <code>ConstAllocSafe</code>. (I can't think of any counter-examples off the top of my head...)</p>",
        "id": 217370254,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1605858448
    },
    {
        "content": "<p>My problem with a <code>const(alloc)</code> approach is that I think this would mean we would also have to have this on function pointers, dynamic trait objects, generic bounds</p>",
        "id": 217380623,
        "sender_full_name": "oli",
        "timestamp": 1605866251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/217146146\">said</a>:</p>\n<blockquote>\n<p>So... I've been typing up <a href=\"https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA\">https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA</a> and realized that trying some sort of <code>ConstAlloc</code> scheme can't really work, because we won't be able to track that through <code>const fn foo() -&gt; SomeStruct { SomeStruct { v: vec![42] } }</code> as no part of the function call requires any alloc scheme. Even if we made <code>Global</code>'s <code>Alloc</code> impl not <code>const</code>, we could have <code>foo</code> but the type of <code>v</code> is <code>Vec&lt;i32, ConstAlloc&gt;</code>, and we'd again not see this via any kind of static analysis</p>\n</blockquote>\n<p>basically, to support this the code would need to change to <code>const fn foo() -&gt; SomeStruct&lt;Alloc&gt;</code></p>",
        "id": 217499992,
        "sender_full_name": "RalfJ",
        "timestamp": 1605962026
    },
    {
        "content": "<p>everything needs to be generic</p>",
        "id": 217500049,
        "sender_full_name": "RalfJ",
        "timestamp": 1605962102
    },
    {
        "content": "<p>the weirdest part though is that the type of an allocation depends on whether it happens at runtime or compiletime... no idea how to do that...^^</p>",
        "id": 217500056,
        "sender_full_name": "RalfJ",
        "timestamp": 1605962126
    },
    {
        "content": "<p>my problem is that <code>ConstAlloc</code> would be \"globally available\", so you can just create a <code>struct Foo(*mut i32);</code> and from that noone can tell whether an alloc happened or not. So if we have a <code>const fn foo() -&gt; Foo</code>, how do we analyze the body of that function to ensure it does not put a heap pointer into the result?</p>",
        "id": 217547951,
        "sender_full_name": "oli",
        "timestamp": 1606046191
    },
    {
        "content": "<p>One way would be to make <code>ConstAlloc</code> only be available in <code>const</code> and <code>static</code> items and not in <code>const fn</code>. Thus it would need to get passed via generics, otherwise you don't have any way to create heap allocs</p>",
        "id": 217547971,
        "sender_full_name": "oli",
        "timestamp": 1606046249
    },
    {
        "content": "<p>this would not require any fancy scheme and would just work <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span></p>",
        "id": 217548019,
        "sender_full_name": "oli",
        "timestamp": 1606046311
    },
    {
        "content": "<p>but it would require everything to become generic over the alloc type</p>",
        "id": 217548025,
        "sender_full_name": "oli",
        "timestamp": 1606046331
    },
    {
        "content": "<p>Since things like <code>serde_json</code> would need to put <code>const</code> everywhere in order to be come usable in const, it doesn't seem too bad to also require being generic over the <code>Alloc</code> type as long as we have defaults for parameters, too</p>",
        "id": 217548043,
        "sender_full_name": "oli",
        "timestamp": 1606046381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/217547951\">said</a>:</p>\n<blockquote>\n<p>my problem is that <code>ConstAlloc</code> would be \"globally available\", so you can just create a <code>struct Foo(*mut i32);</code> and from that noone can tell whether an alloc happened or not. So if we have a <code>const fn foo() -&gt; Foo</code>, how do we analyze the body of that function to ensure it does not put a heap pointer into the result?</p>\n</blockquote>\n<p>I thought with <code>ConstAlloc</code> we don't need to tell that any more, is the entire point</p>",
        "id": 217548366,
        "sender_full_name": "RalfJ",
        "timestamp": 1606046886
    },
    {
        "content": "<p>oh... because it doesn't do anything on drop <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 217548455,
        "sender_full_name": "oli",
        "timestamp": 1606047114
    },
    {
        "content": "<p>I completely confused myself</p>",
        "id": 217548457,
        "sender_full_name": "oli",
        "timestamp": 1606047118
    },
    {
        "content": "<p>so yea, we can't do transient allocations via <code>Global</code> at all, because we can't really enforce that you don't transmute things so badly that we lose track of them, but if we just never make the <code>Alloc</code> impl for <code>Global</code> <code>const</code>, and only do <code>impl const Alloc for ConstAlloc</code>, then we're absolutely fine</p>",
        "id": 217548510,
        "sender_full_name": "oli",
        "timestamp": 1606047205
    },
    {
        "content": "<blockquote>\n<p>the weirdest part though is that the type of an allocation depends on whether it happens at runtime or compiletime... no idea how to do that...^^</p>\n</blockquote>\n<p>can you elaborate on that? I'm not sure what you mean</p>",
        "id": 217548519,
        "sender_full_name": "oli",
        "timestamp": 1606047239
    },
    {
        "content": "<blockquote>\n<p>so yea, we can't do transient allocations via Global at all, because we can't really enforce that you don't transmute things so badly that we lose track of them,</p>\n</blockquote>\n<p>We can, but only dynamically</p>",
        "id": 217556846,
        "sender_full_name": "RalfJ",
        "timestamp": 1606059891
    },
    {
        "content": "<p>yea, that's true</p>",
        "id": 217557116,
        "sender_full_name": "oli",
        "timestamp": 1606060306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/217548519\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>the weirdest part though is that the type of an allocation depends on whether it happens at runtime or compiletime... no idea how to do that...^^</p>\n</blockquote>\n<p>can you elaborate on that? I'm not sure what you mean</p>\n</blockquote>\n<p>if we want to have a function that e.g. creates a Box and works both at compiletime and runtime... in one case it returns <code>Box&lt;T, Global&gt;</code>, in the other <code>Box&lt;T, ConstGlobal&gt;</code></p>",
        "id": 217557122,
        "sender_full_name": "RalfJ",
        "timestamp": 1606060321
    },
    {
        "content": "<p>well... you'd have to specify this <code>Alloc</code> type somewhere, we won't have magical insertion of <code>ConstGlobal</code> just because you are in a const context. At least I have no idea how we could do that. So yea, as I see it, we'll have different types, but invoking <code>Box::new(42)</code> will <em>always</em> return a <code>Box&lt;i32, Global&gt;</code>, unless inference figures out that we need a <code>ConstGlobal</code></p>",
        "id": 217557389,
        "sender_full_name": "oli",
        "timestamp": 1606060694
    },
    {
        "content": "<p>yeah. this means code that returns allocated objects needs to not just be made <code>const fn</code> but be adjusted to be able to work with different allocators. not sure how people would react to that.</p>",
        "id": 217558882,
        "sender_full_name": "RalfJ",
        "timestamp": 1606063033
    },
    {
        "content": "<p>This may also be messy around trait methods returning <code>Box</code>es and similar, as we want to keep them object safe if they were before. But I guess these problems <em>also</em> come up if you just consider custom allocators in isolation</p>",
        "id": 217559226,
        "sender_full_name": "oli",
        "timestamp": 1606063495
    },
    {
        "content": "<p>I was thinking for a moment that we could also just use <code>Global</code> and do some magic at the <code>const</code>/<code>static</code> item boundary that changes the type to <code>ConstGlobal</code>, but that won't work if you have a <code>struct Foo(*mut i32);</code> that has methods to take out the inner thing's ownership and yield a <code>Box&lt;i32, Global&gt;</code></p>",
        "id": 217559318,
        "sender_full_name": "oli",
        "timestamp": 1606063602
    },
    {
        "content": "<p>I mean... that could all work if we want transient allocations anyway and just permit types with <code>unsafe impl Const(Ref)Safe</code> impls</p>",
        "id": 217559351,
        "sender_full_name": "oli",
        "timestamp": 1606063670
    },
    {
        "content": "<p>if we take the post-monomorphization error on leaked heap allocs <em>anyway</em>, we can also go full in and only implement <code>ConstRefSafe</code> for <code>Box&lt;T,  Global&gt;</code> but not auto-implement for any types beyond the primitives</p>",
        "id": 217559419,
        "sender_full_name": "oli",
        "timestamp": 1606063737
    },
    {
        "content": "<p>Then <code>Foo</code> would not be valid in the final value of a constant</p>",
        "id": 217559440,
        "sender_full_name": "oli",
        "timestamp": 1606063793
    },
    {
        "content": "<p>ok... So... I found a problem with our current plan. It would be a breaking change. When looking at <a href=\"https://github.com/rust-lang/rust/pull/78461\">https://github.com/rust-lang/rust/pull/78461</a> by <span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> I realized that <a href=\"https://github.com/rust-lang/wg-allocators/issues/1#issuecomment-488990394\">it's a breaking change</a> to make <code>Vec::new</code> generic over the <code>AllocRef</code> being used. I'm not sure in what situations it's a problem.</p>",
        "id": 218075911,
        "sender_full_name": "oli",
        "timestamp": 1606472561
    },
    {
        "content": "<p>Maybe I confused my self thoroughly with all the back and forth. So let's start from the beginning</p>",
        "id": 218076019,
        "sender_full_name": "oli",
        "timestamp": 1606472643
    },
    {
        "content": "<p>We want</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to keep working</p>",
        "id": 218076071,
        "sender_full_name": "oli",
        "timestamp": 1606472664
    },
    {
        "content": "<p>That desugars to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>since <a href=\"https://github.com/rust-lang/rust/issues/78461\">#78461</a></p>",
        "id": 218076135,
        "sender_full_name": "oli",
        "timestamp": 1606472705
    },
    {
        "content": "<p>considering that we don't have an <code>impl const AllocRef for Global</code> that is problematic, and we should probably close that hole</p>",
        "id": 218076186,
        "sender_full_name": "oli",
        "timestamp": 1606472739
    },
    {
        "content": "<p>basically the const safety checks do not check defaulted generic parameters</p>",
        "id": 218076259,
        "sender_full_name": "oli",
        "timestamp": 1606472765
    },
    {
        "content": "<p>because if the impl were <code>impl&lt;T, A: AllocRef&gt; Vec&lt;T, A&gt;</code> then we would get an error</p>",
        "id": 218076341,
        "sender_full_name": "oli",
        "timestamp": 1606472815
    },
    {
        "content": "<p>but while writing this I realized that it's</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which is fine, since we can't possibly call any methods on <code>Global</code> unless they are inherent and <code>const</code></p>",
        "id": 218076414,
        "sender_full_name": "oli",
        "timestamp": 1606472865
    },
    {
        "content": "<p>so... TLDR: Everything works, but we won't be able to use <code>Vec::new()</code> if we later want to <code>push</code></p>",
        "id": 218076490,
        "sender_full_name": "oli",
        "timestamp": 1606472891
    },
    {
        "content": "<p>reading that API I think that the type based approach really is the right way to go about all of this. We'll just never turn <code>impl AllocRef for Global</code> into a <code>const</code> impl, thus statically preventing any such allocations in const eval. For transient allocations we can then let the user choose a favorite crate that implements <code>AllocRef</code> for some stack/array based arena allocator.</p>",
        "id": 218077027,
        "sender_full_name": "oli",
        "timestamp": 1606473219
    },
    {
        "content": "<p>For non-transient allocations we'll provide <code>ConstGlobal</code> which never deallocates and requires the use of the cross <code>AllocRef</code> APIs</p>",
        "id": 218077116,
        "sender_full_name": "oli",
        "timestamp": 1606473255
    },
    {
        "content": "<p>it's not the magic bullet that gives us transient <code>serde_json</code> without threading a generic <code>AllocRef</code> parameter through everywhere, but it's completely sound and easy to understand imo</p>",
        "id": 218077209,
        "sender_full_name": "oli",
        "timestamp": 1606473332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/218075911\">said</a>:</p>\n<blockquote>\n<p>ok... So... I found a problem with our current plan. It would be a breaking change. When looking at <a href=\"https://github.com/rust-lang/rust/pull/78461\">https://github.com/rust-lang/rust/pull/78461</a> by <span class=\"user-mention silent\" data-user-id=\"216785\">Tim Diekmann</span> I realized that <a href=\"https://github.com/rust-lang/wg-allocators/issues/1#issuecomment-488990394\">it's a breaking change</a> to make <code>Vec::new</code> generic over the <code>AllocRef</code> being used. I'm not sure in what situations it's a problem.</p>\n</blockquote>\n<p>Currently this is a breaking change but I think this could be solved, if the compiler takes default generics into account when infering the type. But as you noted, this is not a problem here.</p>\n<blockquote>\n<p>Everything works, but we won't be able to use <code>Vec::new()</code> if we later want to <code>push</code></p>\n</blockquote>\n<p>Is this even true if <code>A == Global</code>? If so: Is it possible to work around this with specialization?</p>",
        "id": 218100412,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606489048
    },
    {
        "content": "<p><code>Global</code> will not have an <code>impl const AllocRef for Global</code>, so you won't be able to invoke <code>push</code> which has an <code>A: AllocRef</code> bound</p>",
        "id": 218100694,
        "sender_full_name": "oli",
        "timestamp": 1606489207
    },
    {
        "content": "<p>I'm not sure how specialization could help here</p>",
        "id": 218100895,
        "sender_full_name": "oli",
        "timestamp": 1606489323
    },
    {
        "content": "<p>as the type of the <code>Vec</code> would be wrong (<code>Vec&lt;T, Global&gt;</code>)</p>",
        "id": 218100934,
        "sender_full_name": "oli",
        "timestamp": 1606489338
    },
    {
        "content": "<p>If this could compile, we would be fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">AllocRef</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">push</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">push</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218101581,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606489758
    },
    {
        "content": "<p>well... the other way around with the <code>const</code>, but yes</p>",
        "id": 218101895,
        "sender_full_name": "oli",
        "timestamp": 1606489954
    },
    {
        "content": "<p>thanks, that explains the specialization case very well</p>",
        "id": 218101909,
        "sender_full_name": "oli",
        "timestamp": 1606489961
    },
    {
        "content": "<p>I don't know much about const-eval, just trying to help here :)</p>",
        "id": 218102080,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606490051
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 218120343,
        "sender_full_name": "RalfJ",
        "timestamp": 1606503090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/218076414\">said</a>:</p>\n<blockquote>\n<p>but while writing this I realized that it's</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which is fine, since we can't possibly call any methods on <code>Global</code> unless they are inherent and <code>const</code></p>\n</blockquote>\n<p>I am very confused, why would it be fine here but not for any other trait?<br>\nEDIT: Oh, is it because the function is not actually generic? Ah makes sense.</p>",
        "id": 218120489,
        "sender_full_name": "RalfJ",
        "timestamp": 1606503183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/218077027\">said</a>:</p>\n<blockquote>\n<p>reading that API I think that the type based approach really is the right way to go about all of this. We'll just never turn <code>impl AllocRef for Global</code> into a <code>const</code> impl, thus statically preventing any such allocations in const eval. For transient allocations we can then let the user choose a favorite crate that implements <code>AllocRef</code> for some stack/array based arena allocator.</p>\n</blockquote>\n<p>to be clear, you still agree we could have transient allocations with <code>Global</code> but we'd have to check post-monomorphization that none of these global ptrs make it to the final value?</p>",
        "id": 218120639,
        "sender_full_name": "RalfJ",
        "timestamp": 1606503319
    },
    {
        "content": "<p>yes</p>",
        "id": 218121114,
        "sender_full_name": "oli",
        "timestamp": 1606503724
    },
    {
        "content": "<p>I still think we should have some opt-in or sth, but we can bikeshed that later and just have it behind a feature gate in the beginning</p>",
        "id": 218121160,
        "sender_full_name": "oli",
        "timestamp": 1606503763
    },
    {
        "content": "<p>I think my write up on const heap is now up to date to the discussion here: <a href=\"https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA\">https://hackmd.io/h2O2vkj3RimrBTfm9hvZWA</a></p>",
        "id": 218161004,
        "sender_full_name": "oli",
        "timestamp": 1606564388
    },
    {
        "content": "<p>The <code>push</code> issue also arose to me when I thought about this some more, and it is unfortunate indeed</p>",
        "id": 218304219,
        "sender_full_name": "RalfJ",
        "timestamp": 1606751262
    },
    {
        "content": "<p>I think what I am missing is a clear sense for what people would like to sue heap-in-const <em>for</em>, to determine where the priorities are and how severe the various problems are that we uncovered.</p>",
        "id": 218304333,
        "sender_full_name": "RalfJ",
        "timestamp": 1606751300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"355545\">@vn-ki</span> will be/is working on this, so we'll have <em>something</em> really unstable to play with</p>",
        "id": 218320616,
        "sender_full_name": "oli",
        "timestamp": 1606758454
    },
    {
        "content": "<p>I think if we go with the full \"no <code>Global</code>\" system to start out with, then we have at least the minimal subset that I currently believe is sound. Any extensions can go behind other feature gates and we can then discuss them separately</p>",
        "id": 218320817,
        "sender_full_name": "oli",
        "timestamp": 1606758550
    },
    {
        "content": "<blockquote>\n<p>what people would like to sue heap-in-const <em>for</em></p>\n</blockquote>\n<p>A key one I’ve seen though Stack Overflow is something effectively:</p>\n<div class=\"codehilite\"><pre><span></span><code>const FOO: &amp;str = “a”.repeat(10);\n</code></pre></div>\n<p>Or similar; build up a value that could be expressed as a constant but is more understandable as the construction process.</p>",
        "id": 218417635,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606827328
    },
    {
        "content": "<p>API wise, how bad do you think it is that you'll need a <code>leak</code> call or change the type to <code>String&lt;ConstGlobal&gt;</code>?</p>",
        "id": 218417970,
        "sender_full_name": "oli",
        "timestamp": 1606827495
    },
    {
        "content": "<p>Should we put a focus on making <code>const FOO: &amp;str = &amp;some_heap_string;</code> work via autoderef?</p>",
        "id": 218418003,
        "sender_full_name": "oli",
        "timestamp": 1606827522
    },
    {
        "content": "<p>or, alternatively, focus on transient allocations and how to safely \"transport\" them to the runtime world</p>",
        "id": 218418056,
        "sender_full_name": "RalfJ",
        "timestamp": 1606827560
    },
    {
        "content": "<p>yea... I just realized that making <code>repeat</code> return a <code>String&lt;ConstGlobal&gt;</code> may not be doable backwards compatibly</p>",
        "id": 218418192,
        "sender_full_name": "oli",
        "timestamp": 1606827635
    },
    {
        "content": "<p>It may be, but I haven't read up enough on this</p>",
        "id": 218418221,
        "sender_full_name": "oli",
        "timestamp": 1606827653
    },
    {
        "content": "<p>Still waking up completely morning thought, could something like <code>const{}</code> transfer <code>String&lt;GlobalAlloc&gt;</code> to <code>&lt;ConstAlloc&gt;</code></p>",
        "id": 218418478,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606827800
    },
    {
        "content": "<p>Or maybe a <code>.to_const()</code></p>",
        "id": 218418512,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606827833
    },
    {
        "content": "<p>(<code>leak</code> sounds wrong to me)</p>",
        "id": 218418579,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606827861
    },
    {
        "content": "<p>I don't think so, someone may have created a <code>struct MyString(*const ())</code> which actually points to a <code>Box&lt;Global&gt;</code> that was <code>Box::into_raw</code>ed.</p>",
        "id": 218418598,
        "sender_full_name": "oli",
        "timestamp": 1606827881
    },
    {
        "content": "<p>so we wouldn't know any of this from the type system at all</p>",
        "id": 218418617,
        "sender_full_name": "oli",
        "timestamp": 1606827893
    },
    {
        "content": "<p>I do have a setup that can work, but it will cause post-monorphization errors</p>",
        "id": 218418659,
        "sender_full_name": "oli",
        "timestamp": 1606827918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> I'm talking about <code>leak</code> because of <a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\">https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak</a></p>",
        "id": 218418759,
        "sender_full_name": "oli",
        "timestamp": 1606827970
    },
    {
        "content": "<p>The autoderef and copying transient data path feels like it would cover a lot of goals that people would want. It’s not quite as logically consistent s as what it sounds like y’all would want though.</p>",
        "id": 218419075,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606828131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> sure, but you don’t really need to <em>leak</em> anything in a bunch of these cases. The String would be allocated and deallocated at compile time and the string data “interned” in the generated code.</p>",
        "id": 218419786,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606828559
    },
    {
        "content": "<p>well... that is leaking <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 218419842,
        "sender_full_name": "oli",
        "timestamp": 1606828579
    },
    {
        "content": "<p>(in my mind)</p>",
        "id": 218419860,
        "sender_full_name": "oli",
        "timestamp": 1606828591
    },
    {
        "content": "<p>I don't think we have a good picture yet of what is achievable, so we're mostly collecting data and building prototypes</p>",
        "id": 218419898,
        "sender_full_name": "oli",
        "timestamp": 1606828618
    },
    {
        "content": "<p>There is one system that is very verbose that will work (<code>ConstGlobal</code> everywhere), and we may want it in general as the first step and figure out better things on top of it</p>",
        "id": 218419939,
        "sender_full_name": "oli",
        "timestamp": 1606828648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/218419939\">said</a>:</p>\n<blockquote>\n<p>There is one system that is very verbose that will work (<code>ConstGlobal</code> everywhere), and we may want it in general as the first step and figure out better things on top of it</p>\n</blockquote>\n<p>I feel like that is orthogonal to the <code>ConstHeapSafeRef</code> thing</p>",
        "id": 218420062,
        "sender_full_name": "RalfJ",
        "timestamp": 1606828715
    },
    {
        "content": "<p>Regarding <a href=\"https://github.com/rust-lang/rust/pull/79594#discussion_r533389909\">this comment</a>, what does leak exactly mean?</p>",
        "id": 218420266,
        "sender_full_name": "vn-ki",
        "timestamp": 1606828806
    },
    {
        "content": "<p>If it's a memory leak, isnt heap leaking rn because we dont dealloc memory?</p>",
        "id": 218420296,
        "sender_full_name": "vn-ki",
        "timestamp": 1606828825
    },
    {
        "content": "<p>I think that verbose makes sense as a complete base case. It’s also nice if you can provide some small syntax sugar for the common cases (e.g. the auto deref thing)</p>",
        "id": 218420348,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606828866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355545\">vn-ki</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Questions.20regarding.20Heap.20allocation.20in.20const.20eval/near/218420266\">said</a>:</p>\n<blockquote>\n<p>Regarding <a href=\"https://github.com/rust-lang/rust/pull/79594#discussion_r533389909\">this comment</a>, what does leak exactly mean?</p>\n</blockquote>\n<p>leaking is used by miri to make sure the program deallocates all memory</p>",
        "id": 218420421,
        "sender_full_name": "RalfJ",
        "timestamp": 1606828912
    },
    {
        "content": "<p>I think it currently has no effect for CTFE</p>",
        "id": 218420427,
        "sender_full_name": "RalfJ",
        "timestamp": 1606828917
    },
    {
        "content": "<p>so I'd vote for doing the sensible thing and considering ConstHeap allocs not allwoed to leak</p>",
        "id": 218420488,
        "sender_full_name": "RalfJ",
        "timestamp": 1606828935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> an alternative might be to make <code>ConstHeap</code> part of the <code>MachineMemory</code> variants in the CTFE machine instance, like what Miri does.</p>",
        "id": 218420532,
        "sender_full_name": "RalfJ",
        "timestamp": 1606828956
    },
    {
        "content": "<p>Hmm... that's true, I wonder if that also applies to other variants like <code>Vtable</code>?</p>",
        "id": 218420708,
        "sender_full_name": "oli",
        "timestamp": 1606829046
    },
    {
        "content": "<blockquote>\n<p>leaking is used by miri to make sure the program deallocates all memory </p>\n</blockquote>\n<p>I’m sure this makes sense somehow, but that’s a silly sentence 🤪</p>",
        "id": 218421596,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606829530
    },
    {
        "content": "<p>I think the long version is: if a memory kind is marked as \"leaking\", then it is ignored by the leak checker in miri. The leak checker will go through all allocations after a program is done and inform you about all leaked allocations. So if heap were marked as leaking, then any left over heap allocations that weren't deallocated would be ignored. Since this is about <code>ConstHeap</code>, that's actually what we want, but irrelevant anyway as miri (the tool) will never create any of these. So we can mark it as non-leaking and thus catch more bugs</p>",
        "id": 218421934,
        "sender_full_name": "oli",
        "timestamp": 1606829743
    },
    {
        "content": "<p>I guess for us out of the loop, it might be better described as being marked as <em>deliberately</em> leaked</p>",
        "id": 218422824,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606830216
    },
    {
        "content": "<p>I dont think we usually talk about \"marking memory as leaking\"... the method is called <code>may_leak</code></p>",
        "id": 218427119,
        "sender_full_name": "RalfJ",
        "timestamp": 1606832290
    },
    {
        "content": "<p>This might require GATs, but could we do something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">ConvertAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">Alloc</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">to_allocator</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;</span><span class=\"n\">Alloc</span><span class=\"o\">&gt;</span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">constify</span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">ConvertAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">ConstAlloc</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"cm\">/* or maybe HKTs... */</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">todo</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Used as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Foo</span>: <span class=\"nb\">String</span><span class=\"o\">&lt;</span><span class=\"n\">ConstAlloc</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">constify</span><span class=\"p\">({</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Merry String actions</span>\n<span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218427291,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606832373
    },
    {
        "content": "<p>sure, we can add more sugar, but the root problem is that people who do not use it will break the system, because there's no way to (statically) prevent them from putting a <code>String&lt;Global&gt;</code> into a constant</p>",
        "id": 218428528,
        "sender_full_name": "oli",
        "timestamp": 1606832930
    },
    {
        "content": "<p>With dynamic checks we can prevent that, right?</p>",
        "id": 218429861,
        "sender_full_name": "vn-ki",
        "timestamp": 1606833557
    },
    {
        "content": "<p>I edited and added <code>(statically)</code></p>",
        "id": 218429933,
        "sender_full_name": "oli",
        "timestamp": 1606833594
    },
    {
        "content": "<p>I think I forgot why we absolutely prefer static over dynamic checks. can you clarify it to me _once_ more</p>",
        "id": 218430147,
        "sender_full_name": "vn-ki",
        "timestamp": 1606833712
    },
    {
        "content": "<p>Re-reading this helped: <a href=\"https://github.com/rust-lang/const-eval/blob/master/const_checks.md\">https://github.com/rust-lang/const-eval/blob/master/const_checks.md</a></p>",
        "id": 218430727,
        "sender_full_name": "vn-ki",
        "timestamp": 1606833983
    },
    {
        "content": "<p>dynamic checks are similar to duck typing. Everything works until it doesn't, and it may fail in arbitrary crates, not necessarily in the one that did the mistake, often without a real way to figure out how the error relates to the mistake</p>",
        "id": 218431026,
        "sender_full_name": "oli",
        "timestamp": 1606834110
    },
    {
        "content": "<p>And Rust programmers in general prefer things to be caught at compile time. Part of liking Rust.</p>",
        "id": 218440276,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606837995
    },
    {
        "content": "<p>jup, even if said runtime is a const eval VM that is actually only used for compile-time stuff in rustc</p>",
        "id": 218440653,
        "sender_full_name": "oli",
        "timestamp": 1606838138
    },
    {
        "content": "<p>Should have just created a new LLVM backend for the Miri VM. Should make things easier <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 218440863,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606838200
    },
    {
        "content": "<p>Rewrite it in Wasm. Or eBPF.</p>",
        "id": 218443152,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606839017
    },
    {
        "content": "<p>you really know the best kinds of gasoline to throw onto a fire</p>",
        "id": 218443227,
        "sender_full_name": "oli",
        "timestamp": 1606839060
    },
    {
        "content": "<p>Obviously I don't want any of that because it will delay my const-eval gratification</p>",
        "id": 218444605,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1606839485
    },
    {
        "content": "<p>A Cranelift backend would compile faster <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 218447286,
        "sender_full_name": "bjorn3",
        "timestamp": 1606840592
    }
]