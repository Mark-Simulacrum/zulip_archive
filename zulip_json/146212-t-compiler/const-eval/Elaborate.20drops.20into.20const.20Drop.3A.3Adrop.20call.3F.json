[
    {
        "content": "<p>Is it possible, to transform all <code>Drop</code> terminators into a <code>Call</code> to the type's const <code>Drop</code> impl? Then, when we do the const checking, we make a special case for calls to <code>Drop::drop</code> and use the same message as <code>ops::LiveDrop</code> when we find out that it does not have a const drop impl.</p>",
        "id": 251332727,
        "sender_full_name": "fee1-dead",
        "timestamp": 1630386538
    },
    {
        "content": "<p>You also need to hande drop of their fields first.</p>",
        "id": 251335725,
        "sender_full_name": "bjorn3",
        "timestamp": 1630389356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/Elaborate.20drops.20into.20const.20Drop.3A.3Adrop.20call.3F/near/251335725\">said</a>:</p>\n<blockquote>\n<p>You also need to hande drop of their fields first.</p>\n</blockquote>\n<p>yea this is the problem. The type may not impl <code>Drop</code>, but one of its fields may. We could convert the <code>Drop</code> terminators into calls to the drop glue, but I'm not sure we'd gain anything</p>",
        "id": 251377381,
        "sender_full_name": "oli",
        "timestamp": 1630413661
    },
    {
        "content": "<p>we'd need to figure out whether the drop glue is const by looking at the fields, that sounds easier to do by looking at the drop terminator than looking at the drop call</p>",
        "id": 251377562,
        "sender_full_name": "oli",
        "timestamp": 1630413735
    }
]