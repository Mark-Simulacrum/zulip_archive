[
    {
        "content": "<p>Is it reasonable to stabilize <a href=\"https://github.com/rust-lang/rust/issues/72447\">#72447</a>? The <code>to_bits</code> and <code>from_bits</code> methods are simple transmutes, which are already permitted in <code>const</code> contexts and can trivially be done by users. The <code>to_{ne|be|le}_bytes</code> calls are performed by the relevant methods on integers, all of which are already stable <code>const fn</code>.<br>\nAre these methods affected by <a href=\"https://github.com/rust-lang/rust/issues/57241\">#57241</a>? I wouldn't think so, as that's specific to arithmetic. If they're not, I think we should stabilize this as-is to prevent users from using the unsafe <code>transmute</code> to work around <code>to_bits</code> and <code>from_bits</code>.</p>",
        "id": 274748877,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646858240
    },
    {
        "content": "<p>I think it's not quite equal going both directions...<br>\nMy question is what happens when someone transmutes a NaN representation, and what happens when someone transmutes a denormal representation? <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> ?</p>",
        "id": 274753008,
        "sender_full_name": "Jubilee",
        "timestamp": 1646860313
    },
    {
        "content": "<p>Copying my latest remark:</p>\n<blockquote>\n<p>per @burrbull in <a href=\"https://github.com/rust-lang/rust/issues/57241#issuecomment-909858133\">#57241 (comment)</a> \"<code>const fn transmute</code> is already stabilized\"</p>\n<p>This allows routing around these using <code>unsafe</code> const code. I think that the question now is whether we want to stabilize the safe methods or to instead fix the bugs that can cause unconst behavior (and thus, continue to make people <code>unsafe</code>ly assert that they believe the result will be const or, in effect, that it will not cause problems) and then stabilize them.</p>\n</blockquote>",
        "id": 274756028,
        "sender_full_name": "Jubilee",
        "timestamp": 1646861893
    },
    {
        "content": "<p>some of the plans to support FP arithmetic involve having \"opaque machine values\" for float NaNs (akin to pointers). in that case <code>to_bits</code> would be unimplementable in CTFE.</p>",
        "id": 274770513,
        "sender_full_name": "RalfJ",
        "timestamp": 1646870241
    },
    {
        "content": "<p>Floats really are that bad? I did some searching earlier trying to find IEEE 754 before realizing you have to pay for it <span aria-label=\"rolling eyes\" class=\"emoji emoji-1f644\" role=\"img\" title=\"rolling eyes\">:rolling_eyes:</span>  But don't floats behave in well-defined ways? I meanâ€¦there are software implementations of IEEE 754.</p>",
        "id": 274770778,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646870384
    },
    {
        "content": "<p>IEEE specifies the behaviour of NaNs pretty exactly:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>IEEE 754-2019 6.2.1 NaN encodings in binary interchange formats </p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<blockquote>\n<p>All binary NaN bit strings have the sign bit S set to 0 or 1 and all the bits of the biased exponent field E set<br>\nto 1 (see 3.4). A quiet NaN bit string should be encoded with the first bit (d1) of the trailing significand<br>\nfield T being 1. A signaling NaN bit string should be encoded with the first bit of the trailing significand<br>\nfield being 0. If the first bit of the trailing significand field is 0, some other bit of the trailing significand<br>\nfield must be non-zero to distinguish the NaN from infinity. In the preferred encoding just described, a<br>\nsignaling NaN shall be quieted by setting d1 to 1, leaving the remaining bits of T unchanged. Bits d2 d3 ...<br>\ndp âˆ’1 of the trailing significand field contain the encoding of the payload, which might be diagnostic<br>\ninformation (see 6.2).</p>\n</blockquote>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>IEEE 754-2019 6.2.3 NaN propagation</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<blockquote>\n<p>An operation that propagates a NaN operand to its result and has a single NaN as an input should produce a<br>\nNaN with the payload of the input NaN if representable in the destination format.</p>\n<p>If two or more inputs are NaN, then the payload of the resulting NaN should be identical to the payload of<br>\none of the input NaNs if representable in the destination format. This standard does not specify which of<br>\nthe input NaNs will provide the payload.</p>\n<p>Conversion of a quiet NaN from a narrower format to a wider format in the same radix, and then back to<br>\nthe same narrower format, should not change the quiet NaN payload in any way except to make it<br>\ncanonical.</p>\n<p>Conversion of a quiet NaN to a floating-point format of the same or a different radix that does not allow<br>\nthe payload to be preserved shall return a quiet NaN that should provide some language-defined diagnostic<br>\ninformation.</p>\n<p>There should be means to read and write payloads from and to external character sequences (see 5.12.1).<br>\nExcept for the operations specified otherwise in 5.5, a NaN result shall be canonical, even if that NaN<br>\nresult were derived from a non-canonical NaN operand.</p>\n</blockquote>\n</div></div>\n<p>Whether implementations conform to the standard is another matter entirelyâ€¦</p>",
        "id": 274772593,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1646871376
    },
    {
        "content": "<p>The concern isn't \"does the implementation give a NaN correctly?\", the concern is \"which NaN does the implementation give?\"</p>",
        "id": 274778835,
        "sender_full_name": "Lokathor",
        "timestamp": 1646876032
    },
    {
        "content": "<p><code>NaN != NaN</code>, so why does it actually matter?</p>",
        "id": 274778911,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646876088
    },
    {
        "content": "<p>NaN is effectively an opaque value, no?</p>",
        "id": 274778939,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646876117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt ðŸ‡ºðŸ‡¦</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274778911\">said</a>:</p>\n<blockquote>\n<p><code>NaN != NaN</code>, so why does it actually matter?</p>\n</blockquote>\n<p>The actual bit-pattern of the NaN is observable if you transmute to <code>u32</code>/<code>u64</code>,  use <code>total_cmp</code> (which corresponds to  IEEE 754 <strong>totalOrder</strong>), or use <code>is_sign_negative</code> (which corresponds to IEEE 754 <strong>isSignMinus</strong>; NaNs can have positive or negative sign).</p>",
        "id": 274781306,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1646878368
    },
    {
        "content": "<p>The casts to integers I knew, but wasn't thinking about the rest. I'm working on some other things right now, but I'm sure I'll come back around to this eventually. Worth asking, at least.</p>",
        "id": 274781522,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646878643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt ðŸ‡ºðŸ‡¦</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274778939\">said</a>:</p>\n<blockquote>\n<p>NaN is effectively an opaque value, no?</p>\n</blockquote>\n<p>Even without the casts, <code>copysign</code> also works.</p>",
        "id": 274787301,
        "sender_full_name": "Jubilee",
        "timestamp": 1646885294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt ðŸ‡ºðŸ‡¦</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274770778\">said</a>:</p>\n<blockquote>\n<p>Floats really are that bad? I did some searching earlier trying to find IEEE 754 before realizing you have to pay for it <span aria-label=\"rolling eyes\" class=\"emoji emoji-1f644\" role=\"img\" title=\"rolling eyes\">:rolling_eyes:</span> </p>\n</blockquote>\n<p>I thought there was a (maybe draft) copy online somewhere but I couldn't find it.  If you want I can send you a copy though.</p>",
        "id": 274889432,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1646943358
    },
    {
        "content": "<p>Eh, I was just curious how much effort it would be to create a software implementation that strictly follows the spec. Not a big deal since it sounds like it's not worth it.</p>",
        "id": 274889537,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943402
    },
    {
        "content": "<p>A software impl for consteval? Yes.<br>\nA software impl for runtime? Bad idea.</p>",
        "id": 274889605,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943440
    },
    {
        "content": "<p>Of course. I meant as part of MIRI to avoid any platform-specific behavior.</p>",
        "id": 274889655,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943477
    },
    {
        "content": "<p>We do have that I think</p>",
        "id": 274889726,
        "sender_full_name": "oli",
        "timestamp": 1646943498
    },
    {
        "content": "<p>I think rustc already has one. rustc_apfloat.</p>",
        "id": 274889748,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943508
    },
    {
        "content": "<p>It should be conformant, without any platform specific, behaviour</p>",
        "id": 274889787,
        "sender_full_name": "oli",
        "timestamp": 1646943533
    },
    {
        "content": "<p>And it is 100% deterministic</p>",
        "id": 274889794,
        "sender_full_name": "oli",
        "timestamp": 1646943541
    },
    {
        "content": "<p>Waitâ€¦if there already is one, then why the concerns?</p>",
        "id": 274889807,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943549
    },
    {
        "content": "<p>Especially if it's deterministic.</p>",
        "id": 274889813,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943555
    },
    {
        "content": "<p>Because at runtime const fns aren't deterministic  if they have floats</p>",
        "id": 274889851,
        "sender_full_name": "oli",
        "timestamp": 1646943578
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 274889865,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943585
    },
    {
        "content": "<p><span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 274889880,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943596
    },
    {
        "content": "<p>So the issue is that <em>platforms</em> don't follow the spec?</p>",
        "id": 274889956,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943615
    },
    {
        "content": "<p>Jup</p>",
        "id": 274889964,
        "sender_full_name": "oli",
        "timestamp": 1646943622
    },
    {
        "content": "<p>Or well</p>",
        "id": 274889973,
        "sender_full_name": "oli",
        "timestamp": 1646943625
    },
    {
        "content": "<p>delighful</p>",
        "id": 274889975,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943626
    },
    {
        "content": "<p>They interpret the details differently</p>",
        "id": 274889997,
        "sender_full_name": "oli",
        "timestamp": 1646943634
    },
    {
        "content": "<p>Also, platforms that do follow the spec can differ in unspecified behaviour.</p>",
        "id": 274890018,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943645
    },
    {
        "content": "<p>And at the very least use the parts where they may differ</p>",
        "id": 274890027,
        "sender_full_name": "oli",
        "timestamp": 1646943650
    },
    {
        "content": "<p>It also means you can observe whether <code>let x = foo(5.0f32);</code> is evaluated at compile time, or runtime.</p>",
        "id": 274890068,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943674
    },
    {
        "content": "<p>(If <code>foo</code> is <code>const fn</code>)</p>",
        "id": 274890087,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943690
    },
    {
        "content": "<p>Unspecified behavior could be a compile errorâ€¦in theory. Not sure that's the best of ideas. So the only way to do actual const stuff (not opaque values) would be to emulate the oddities of every platform we support?</p>",
        "id": 274890182,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943732
    },
    {
        "content": "<p>Yea.... we've gone in circles on this topic several times. At this point my preference is to just not allow floats <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 274890435,
        "sender_full_name": "oli",
        "timestamp": 1646943877
    },
    {
        "content": "<p>Which isn't ideal. Setting aside diagnostics, I know I could replace a proc macro from the time crate with <code>macro_rules!</code> if floats were supported.</p>",
        "id": 274890509,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943926
    },
    {
        "content": "<p>Part of me says if const eval follows the spec, that should be sufficient</p>",
        "id": 274890615,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646943978
    },
    {
        "content": "<p>Yea... we could just roll with it. Maybe we need to write a doc explaining all the downsides and why they are irrelevant and then bring it to the lang team.</p>",
        "id": 274891075,
        "sender_full_name": "oli",
        "timestamp": 1646944277
    },
    {
        "content": "<p>Yeah. FWIW, C++ allows floats in constant expressions, and C++20 allows you to <code>bit_cast</code> float/double into same-size integer types in constant expressions.</p>",
        "id": 274891083,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646944282
    },
    {
        "content": "<p>Maybe we'll get that <code>NonNanF32</code> type at some point, at which point we could consider making some things on it <code>const fn</code> without needing to worry about <code>NAN</code>s</p>",
        "id": 274894942,
        "sender_full_name": "scottmcm",
        "timestamp": 1646946443
    },
    {
        "content": "<p>How would that work? The operations on non-NaN floats aren't closed (I think that's the right term).</p>",
        "id": 274895076,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646946498
    },
    {
        "content": "<p>I think that's the right word, yeah.  But maybe <code>NonNanF32: Add&lt;Output = Option&lt;NonNanF32&gt;&gt;</code>.</p>",
        "id": 274895395,
        "sender_full_name": "scottmcm",
        "timestamp": 1646946703
    },
    {
        "content": "<p>(There's a bunch of unknown design work, yeah.)</p>",
        "id": 274895469,
        "sender_full_name": "scottmcm",
        "timestamp": 1646946730
    },
    {
        "content": "<p>Obviously far from ideal, but it's something that could work.</p>",
        "id": 274895520,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646946751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt ðŸ‡ºðŸ‡¦</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274895076\">said</a>:</p>\n<blockquote>\n<p>How would that work? The operations on non-NaN floats aren't closed (I think that's the right term).</p>\n</blockquote>\n<p>I think <code>/</code> is the only one that is not closed, so you'd get <code>checked_div</code> + regular arithmetic?</p>",
        "id": 274895975,
        "sender_full_name": "RalfJ",
        "timestamp": 1646946992
    },
    {
        "content": "<p>If that's the case, that isn't that bad actually. Something that could be nice to have even aside from const contexts</p>",
        "id": 274896024,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947030
    },
    {
        "content": "<p>Infinity + -Infinity</p>",
        "id": 274896025,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947030
    },
    {
        "content": "<p>argh damnit it, okay</p>",
        "id": 274896040,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947043
    },
    {
        "content": "<p>why did they have to give infinity a sign anyway...</p>",
        "id": 274896047,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947049
    },
    {
        "content": "<p>Also, Infinity*0</p>",
        "id": 274896056,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947056
    },
    {
        "content": "<p><code>ActuallyANumberF32</code></p>",
        "id": 274896057,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274896047\">said</a>:</p>\n<blockquote>\n<p>why did they have to give infinity a sign anyway...</p>\n</blockquote>\n<p>Because it is signed?</p>",
        "id": 274896068,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947069
    },
    {
        "content": "<p>(Also, even if it wasn't, Infinity-Infinity)</p>",
        "id": 274896084,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947080
    },
    {
        "content": "<p>having only one kind of infinity is also well-defined, just a different arbitrary choice. its not like infinity is a number anyway.</p>",
        "id": 274896161,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947110
    },
    {
        "content": "<p>(but also, that)</p>",
        "id": 274896168,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947113
    },
    {
        "content": "<p>I sort of treat Infinity/-Infinity signed-zero as respectively, <code>lim[x-&gt;0+](1/x)</code>, <code>lim[x-&gt;0-](1/x)</code>, <code>lim[x-&gt;0+](x)</code>, <code>lim[x-&gt;0-](x)</code>.</p>",
        "id": 274896177,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947120
    },
    {
        "content": "<p>really we should have surreal numbers, where 1/+infinity = +epsilon ;)</p>",
        "id": 274896216,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947146
    },
    {
        "content": "<p>they were thinking of infinity being a projective infinity (unsigned infinity), that ended up in the x87 FPU as an option</p>",
        "id": 274896236,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646947156
    },
    {
        "content": "<p>Eh. I like calculus definition better. Makes my algebraic reasoning easier. Not that it makes it any more correct.</p>",
        "id": 274896293,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947190
    },
    {
        "content": "<p>also apfloat does have bugs but that is a separate concern -- <span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt ðŸ‡ºðŸ‡¦</span> check the transitive closure of <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/237\">https://github.com/rust-lang/unsafe-code-guidelines/issues/237</a> for all the horror ;)</p>",
        "id": 274896374,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947209
    },
    {
        "content": "<p>Although I guess 0*sin(Infinity) is still NaN.</p>",
        "id": 274896383,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947215
    },
    {
        "content": "<p>imho surreal numbers make calculus waay easier to define</p>",
        "id": 274896401,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646947229
    },
    {
        "content": "<p>Isn't calculus defined to not need the Surreals/Infinitintessimals?</p>",
        "id": 274896489,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947278
    },
    {
        "content": "<p>depends on who you ask...</p>",
        "id": 274896513,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646947296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt ðŸ‡ºðŸ‡¦</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274890182\">said</a>:</p>\n<blockquote>\n<p>Unspecified behavior could be a compile errorâ€¦in theory. Not sure that's the best of ideas. So the only way to do actual const stuff (not opaque values) would be to emulate the oddities of every platform we support?</p>\n</blockquote>\n<p>basically that would make every NaN-producing operation a (post-monomorphization) compiler error. so not great either.<br>\nwe should probably have a summary of these 4 or 5 alternatives that have each been discussed at least twice at this point...</p>",
        "id": 274896517,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274896489\">said</a>:</p>\n<blockquote>\n<p>Isn't calculus defined to not need the Surreals/Infinitintessimals?</p>\n</blockquote>\n<p>calculus doesnt have infinity either ;) just limits</p>",
        "id": 274896587,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947324
    },
    {
        "content": "<p>Having a summary somewhere would be great for everyone involved. I'm not as familiar with the formal stuff you all are discussing.</p>",
        "id": 274896652,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947361
    },
    {
        "content": "<p>It does have the limit of x as x increases without bound, though. <br>\nOr the limit of 1/x as x approaches 0 from the left/right.</p>",
        "id": 274896664,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947372
    },
    {
        "content": "<p>most of that formal stuff is off-topic anyway</p>",
        "id": 274896668,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947373
    },
    {
        "content": "<p>I figured as much</p>",
        "id": 274896694,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947387
    },
    {
        "content": "<p>the relevant part for Rust is that yes IEEE precisely specifies <em>most</em> things, but leaves some things open -- in particular the bits in a NaN.</p>",
        "id": 274896853,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947455
    },
    {
        "content": "<p>and then we also have the concern that in Rust, <code>const fn</code> <em>could</em> be interpreted to mean \"this function is deterministic <em>even at runtime</em>\"</p>",
        "id": 274896895,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947478
    },
    {
        "content": "<p>and as long as we want to keep that option open, stabilizing floating point operations is... a problem</p>",
        "id": 274896935,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947501
    },
    {
        "content": "<p>however, didnt we stabilize something last year that already breaks this? I seem to recall an FCP that felt quite significant for this...</p>",
        "id": 274896987,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947534
    },
    {
        "content": "<p>const_fn_transmute already basically breaks that.</p>",
        "id": 274897005,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947551
    },
    {
        "content": "<p>Not to my knowledge. You might be thinking of const transmute/union, but UB is caught there. It's just not guaranteed to be caught.</p>",
        "id": 274897063,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947571
    },
    {
        "content": "<p>ah right, we are teetering the edge of breaking that property but there might still be ways to salvage it</p>",
        "id": 274897178,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947648
    },
    {
        "content": "<p>for the calculus stuff: <a href=\"https://en.wikipedia.org/wiki/Nonstandard_analysis\">https://en.wikipedia.org/wiki/Nonstandard_analysis</a></p>",
        "id": 274897197,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646947659
    },
    {
        "content": "<p>IIRC it was your RFC, actually</p>",
        "id": 274897311,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947703
    },
    {
        "content": "<p>the RFC was just about const-time UB</p>",
        "id": 274897388,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947760
    },
    {
        "content": "<p>true</p>",
        "id": 274897505,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947807
    },
    {
        "content": "<p><code>const_eval_select</code> would also ruin that property though if we were to ever stabilize it</p>",
        "id": 274897549,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947835
    },
    {
        "content": "<p>I thought that was intended to remain unstable forever.</p>",
        "id": 274897625,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947883
    },
    {
        "content": "<p>I am not sure we can get away with that, given that C++ has something similar</p>",
        "id": 274897777,
        "sender_full_name": "RalfJ",
        "timestamp": 1646947958
    },
    {
        "content": "<p>C++ has a lot of stuff that Rust doesn't have in consteval, to be fair.</p>",
        "id": 274897805,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947981
    },
    {
        "content": "<p>Why do we have to follow their track?</p>",
        "id": 274897807,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1646947982
    },
    {
        "content": "<p>Like, 90% of the language, and 85% of the standard library as of C++20.</p>",
        "id": 274897831,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646947995
    },
    {
        "content": "<p>we dont have to. but people will ask for it. so we better have good reasons for not having it.<br>\nand making <code>const fn</code> runtime-deterministic is extremely speculative.</p>",
        "id": 274897901,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948041
    },
    {
        "content": "<p>we have good reasons in other cases, like having a very different safety story -- like with templates vs traits, Rust is designed so we can check things in advance, not post-mono. and of course we have to ensure safety which makes e.g. compile-time heap allocation a lot more tricky.</p>",
        "id": 274898034,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948100
    },
    {
        "content": "<p>TBH, I don't see a reason for guaranteeing runtime-determinism anyways, as long as it's unspecified whether non-required constant expressions are evaluated at compile time (but <code>const_eval_select</code>, would choose the runtime branch outside of required-constant-expressions, I'd assume).</p>",
        "id": 274898085,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646948136
    },
    {
        "content": "<p>ironically our CTFE engine is probably <em>more</em> capable than the one in C++ compilers (it can power Miri which can do many things that are not possible in C++ consteval)</p>",
        "id": 274898176,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948170
    },
    {
        "content": "<p>so it's kind of a shame that we cant reap the benefits of that for CTFE (yet)...</p>",
        "id": 274898217,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274898085\">said</a>:</p>\n<blockquote>\n<p>TBH, I don't see a reason for guaranteeing runtime-determinism anyways, as long as it's unspecified whether non-required constant expressions are evaluated at compile time (but <code>const_eval_select</code>, would choose the runtime branch outside of required-constant-expressions, I'd assume).</p>\n</blockquote>\n<p>it's basically an effect system. there are things unsafe code could do if it could ask the user to provide a <em>deterministic</em> function. that can be very useful.</p>",
        "id": 274898294,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948251
    },
    {
        "content": "<p>not sure what a non-required constant expression is, but please let's not mix up this discussion with constant propagation (the optimization) -- that has nothing to do with CTFE :)</p>",
        "id": 274898326,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948277
    },
    {
        "content": "<p>in Rust it all code is either compile-time evaluated or run-time evaluated, this is never unspecified.</p>",
        "id": 274898533,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274898326\">said</a>:</p>\n<blockquote>\n<p>not sure what a non-required constant expression is, but please let's not mix up this discussion with constant propagation (the optimization) -- that has nothing to do with CTFE :)</p>\n</blockquote>\n<p>Evaluating an expression that is a core-constant-expression, at compile time, even though not required to (and the expression isn't required to be a constant-expression).</p>",
        "id": 274898565,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646948390
    },
    {
        "content": "<p>not sure why one would even want that. of course the compiler can optimize 2+2 to 4 but IMO something is wrong if the spec needs to even talk about this fact. that's just an unobservable detail of how the compiler chooses to implement the abstract machine.</p>",
        "id": 274898719,
        "sender_full_name": "RalfJ",
        "timestamp": 1646948464
    },
    {
        "content": "<p>At least in C++, some things apply to all constant expressions, reguardless of whether they're required-constant-expressions (or the C++20 <em>manifestly constant evaluated</em> term, which is required+static initializer+const initializer for an object of an integral/enumeration type).</p>",
        "id": 274898927,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646948547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274896047\">said</a>:</p>\n<blockquote>\n<p>why did they have to give infinity a sign anyway...</p>\n</blockquote>\n<p>Because otherwise <code>&lt;</code> gets even weirder.  And it's handy to have <code>exp(-âˆž) =&gt; +0</code> but <code>exp(+âˆž) =&gt; +âˆž</code>.</p>",
        "id": 274911863,
        "sender_full_name": "scottmcm",
        "timestamp": 1646955639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/274897178\">said</a>:</p>\n<blockquote>\n<p>ah right, we are teetering the edge of breaking that property but there might still be ways to salvage it</p>\n</blockquote>\n<p>const_fn_transmute, but of course there's that huge mess with integer transmutes at runtime :p... Why is everything so interlinked these days</p>",
        "id": 274920537,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1646961903
    },
    {
        "content": "<p>Hmm, Isn't <code>const_eval_select</code> unsafe? Why wouldn't it be a precondition that it can't be return-changing?</p>",
        "id": 275068614,
        "sender_full_name": "Jubilee",
        "timestamp": 1647047599
    },
    {
        "content": "<p>I know <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> wanted me to ping him again about this.</p>",
        "id": 275068815,
        "sender_full_name": "Jubilee",
        "timestamp": 1647047848
    },
    {
        "content": "<p>Anyways, <code>from_bits</code> and <code>to_bits</code> proooobably can be made const if we can make them fail compilation if a NaN flows through them at all.</p>",
        "id": 275069745,
        "sender_full_name": "Jubilee",
        "timestamp": 1647049290
    },
    {
        "content": "<p>Here's some of our problems for stabilizing const float ops if we want to preserve the const-time vs. runtime semantics:</p>\n<ul>\n<li>x87 FPUs. Most annoying because it breaks several things about our implied float contract and also is technically present on every x86 machine and ALSO unlike the next entry is technically IEEE754 conformant... even if in the most annoying possible ways. I have some ideas for how to eliminate this concern for our tier 1 platforms at least. Once we do that, floats start to get a lot easier to do conformance testing on.</li>\n<li>Denormal-flushing FPUs. These are just straight up non-IEEE754 compliant in any sense so we could rule them out of existence if we like, actually, i.e. they break the implicit floating point contract. However, they mean that e.g. <code>div(1.0_f32 / 1e-38_f32)</code> returns <code>inf</code> instead of <code>1.0000001e38</code> which means a successive operation on that <code>inf</code> can return <code>NaN</code>.</li>\n<li>LLVM glossing over IEEE754 NaN semantics: this is annoying and probably should be straight-up fixed by LLVM.</li>\n</ul>",
        "id": 275070519,
        "sender_full_name": "Jubilee",
        "timestamp": 1647050410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/275068614\">said</a>:</p>\n<blockquote>\n<p>Hmm, Isn't <code>const_eval_select</code> unsafe? Why wouldn't it be a precondition that it can't be return-changing?</p>\n</blockquote>\n<p>basically I dont think we should say \"it is UB if this can be used to distinguish compiletime and runtime\", since that kind of UB is much more nasty than any other kind we have in the sense that it basically cannot be checked by tools like Miri. \"equivalent behavior\" is a very high-level and undecidable notion, not something I would like to see in our definition of UB.</p>",
        "id": 275100974,
        "sender_full_name": "RalfJ",
        "timestamp": 1647097159
    },
    {
        "content": "<p>it's library UB <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>",
        "id": 275103622,
        "sender_full_name": "Jubilee",
        "timestamp": 1647100552
    },
    {
        "content": "<p>I do wonder how cursed the proposal for CanonlicalizingNanf32 for const float arithmetic would get... It could even have many niches. And you could even have a macro rewrite a function with ... some degree of success.</p>",
        "id": 275108283,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1647107010
    },
    {
        "content": "<p>Anyways, is it possible to panic only on the const route of a const_eval_select method?</p>",
        "id": 275118444,
        "sender_full_name": "Jubilee",
        "timestamp": 1647121101
    },
    {
        "content": "<p>yes</p>",
        "id": 275130116,
        "sender_full_name": "fee1-dead",
        "timestamp": 1647141384
    },
    {
        "content": "<p>Nice, then I think it might be possible to stabilize this, yes.</p>",
        "id": 275130131,
        "sender_full_name": "Jubilee",
        "timestamp": 1647141415
    },
    {
        "content": "<p>The requirement would be \"const panic (and thus fail compilation) whenever these methods touch a nonzero denormal or a NaN\", coming or going.</p>",
        "id": 275130187,
        "sender_full_name": "Jubilee",
        "timestamp": 1647141502
    },
    {
        "content": "<p>because it fails compilation it wouldn't be UB for <code>const_eval_select</code> to panic only in compile time</p>",
        "id": 275130579,
        "sender_full_name": "fee1-dead",
        "timestamp": 1647142144
    },
    {
        "content": "<p>and doing \"different but same logic\" in compile time and in runtime is exactly what <code>const_eval_select</code> is for</p>",
        "id": 275130595,
        "sender_full_name": "fee1-dead",
        "timestamp": 1647142191
    },
    {
        "content": "<p>yeah.</p>",
        "id": 275130721,
        "sender_full_name": "Jubilee",
        "timestamp": 1647142392
    },
    {
        "content": "<p>imho denormals should be allowed at compile-time since they <em>are</em> a requirement of IEEE and are often generated/used intentionally/unintentionally, and it would be very surprising to panic because your number was randomly very small. Also, llvm and gcc support denormals basically everywhere for scalars.</p>",
        "id": 275133306,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647146837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/275133306\">said</a>:</p>\n<blockquote>\n<p>imho denormals should be allowed at compile-time since they <em>are</em> a requirement of IEEE and are often generated/used intentionally/unintentionally, and it would be very surprising to panic because your number was randomly very small. Also, llvm and gcc support denormals basically everywhere for scalars.</p>\n</blockquote>\n<p>not until we figure out a story addressing thumbv7neon</p>",
        "id": 275133533,
        "sender_full_name": "Jubilee",
        "timestamp": 1647147229
    },
    {
        "content": "<p>simple as that, tbh.</p>",
        "id": 275133537,
        "sender_full_name": "Jubilee",
        "timestamp": 1647147236
    },
    {
        "content": "<p>Note that it's forward compatible to deny them now and permit them later.</p>",
        "id": 275133580,
        "sender_full_name": "Jacob Pratt ðŸ‡ºðŸ‡¦",
        "timestamp": 1647147254
    },
    {
        "content": "<p>yeah.</p>",
        "id": 275133584,
        "sender_full_name": "Jubilee",
        "timestamp": 1647147264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/146212-t-compiler.2Fconst-eval/topic/stabilizing.20.60const_float_bits_conv.60/near/275103622\">said</a>:</p>\n<blockquote>\n<p>it's library UB <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>\n</blockquote>\n<p>nope I wont let you get away with that ;) it's an intrinsic, so it's a lang thing, not a libs thing.</p>",
        "id": 275534727,
        "sender_full_name": "RalfJ",
        "timestamp": 1647446997
    },
    {
        "content": "<p>we have so far avoided having dynamic checks during CTFE -- those are a problem because when crate A provides a generic constant and crate B instantiates the constant, the error will only occur in crate B but its author is unlikely to be able to do much about this</p>",
        "id": 275535201,
        "sender_full_name": "RalfJ",
        "timestamp": 1647447140
    },
    {
        "content": "<p>basically this is Rust-style trait checking vs C++-style template instantiation</p>",
        "id": 275535241,
        "sender_full_name": "RalfJ",
        "timestamp": 1647447152
    },
    {
        "content": "<p>hmm.</p>",
        "id": 275549540,
        "sender_full_name": "Jubilee",
        "timestamp": 1647452180
    }
]