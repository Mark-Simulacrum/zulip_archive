[
    {
        "content": "<p>Does anyone know, do dynamic linkers ignore dylibs if they are built for a different target?  For example, if it is trying to find <code>libfoo.so</code> (or .dylib or .dll), and it finds one that is built for a different target, will it just ignore it?  (On all platforms?)</p>",
        "id": 276671440,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648238413
    },
    {
        "content": "<p>They ignore dylibs that use a different object file format. PE and MachO also contain which OS they are built for AFAIK. ELF technically has also this, but most of the time the OS is specified as ELFOSABI_NONE independent of the actual target OS.</p>",
        "id": 276674245,
        "sender_full_name": "bjorn3",
        "timestamp": 1648239759
    },
    {
        "content": "<p>So on ELF there is nothing preventing you from loading a dylib built for another OS that uses ELF. In the best case you will have missing libraries or symbols, in the worst case you have a mismatching ABI.</p>",
        "id": 276674316,
        "sender_full_name": "bjorn3",
        "timestamp": 1648239807
    },
    {
        "content": "<p>Bionic linker seems to have some sanity checking <a href=\"https://android.googlesource.com/platform/bionic/+/refs/heads/master/linker/linker_phdr.cpp#221\">https://android.googlesource.com/platform/bionic/+/refs/heads/master/linker/linker_phdr.cpp#221</a></p>",
        "id": 276675160,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1648240285
    },
    {
        "content": "<p>Musl linker is very straightforward as expected, it just loads stuff and expects it to be good <a href=\"https://github.com/kraj/musl/blob/kraj/master/ldso/dynlink.c#L624\">https://github.com/kraj/musl/blob/kraj/master/ldso/dynlink.c#L624</a></p>",
        "id": 276675316,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1648240369
    },
    {
        "content": "<p>The bionic linker doesn't check the target os though. It accepts something obviously bogus like ELFOSABI_FREEBSD.</p>",
        "id": 276675462,
        "sender_full_name": "bjorn3",
        "timestamp": 1648240453
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> .  I just did a quick little test with a FreeBSD .so, and indeed the loader does not pay attention to the OS and just fails.  <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> </p>\n<p>The problem I'm trying to figure out is how to handle <code>rustdoc --test</code>.  In order to run doctests, cargo needs to set up LD_LIBRARY_PATH so that the test can find shared libraries.  However, it also needs to set LD_LIBRARY_PATH for proc-macros to find shared libraries, too.  This seems like it could be a problem if someone just so happens to have a dylib with the same name needed for both purposes.  </p>\n<p>Perhaps that situation is unlikely enough to just ignore?</p>",
        "id": 276682668,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648244732
    },
    {
        "content": "<p>Won't they have different hashes in the name if they are for different targets?</p>",
        "id": 276682935,
        "sender_full_name": "bjorn3",
        "timestamp": 1648244885
    },
    {
        "content": "<p>This is for C dylibs.  For example, a build script running <code>cc</code> to generate a <code>.so</code>.</p>",
        "id": 276683146,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648245039
    },
    {
        "content": "<p>So unlikely to have any distinguishing markers in the filename.</p>",
        "id": 276683167,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648245057
    },
    {
        "content": "<p>I feel like maybe I'm overthinking this, as that seems really unlikely.</p>",
        "id": 276683194,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648245072
    },
    {
        "content": "<p>Overthinking thinks is our job :-P</p>",
        "id": 276683228,
        "sender_full_name": "Eh2406",
        "timestamp": 1648245103
    },
    {
        "content": "<p>it should at least ignore libraries that are the wrong arch (e.g. ELF <code>e_machine</code>)</p>",
        "id": 276683766,
        "sender_full_name": "cuviper",
        "timestamp": 1648245412
    },
    {
        "content": "<p>Yea, I confirmed that it will ignore different arch (at least on linux).</p>",
        "id": 276683807,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648245444
    },
    {
        "content": "<p>Apparently <code>cargo doc</code> is broken when using  a proc-macro that loads a shared library, and nobody has reported it, so perhaps people just don't build shared native libs with proc-macros.</p>",
        "id": 276684261,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648245664
    },
    {
        "content": "<p>it's kind of tricky anyway, since you don't want to clash symbols with anything in the entire rustc process. I remember a bug about broken libstdc++ when used by a proc macro</p>",
        "id": 276686581,
        "sender_full_name": "cuviper",
        "timestamp": 1648246818
    },
    {
        "content": "<p>I've encountered the different-arch case before; it's not uncommon if you cross-compile and have some step that uses a native lib when it should have used a cross one or vice versa.</p>",
        "id": 276686614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648246850
    },
    {
        "content": "<p>I didn't realize that the Linux <a href=\"http://ld.so\">ld.so</a> didn't check OS.</p>",
        "id": 276686637,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648246868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/246057-t-cargo/topic/dynamic.20linkers.20.26.20mixed.20targets/near/276686581\">said</a>:</p>\n<blockquote>\n<p>it's kind of tricky anyway, since you don't want to clash symbols with anything in the entire rustc process. I remember a bug about broken libstdc++ when used by a proc macro</p>\n</blockquote>\n<p>Yea, that's probably <a href=\"https://github.com/rust-lang/rust/issues/76980\">#76980</a> where someone had a proc-macro doing vulkan shader compilation with a big C++ library linked in.</p>\n<p>I wish proc-macros were more isolated.</p>",
        "id": 276688105,
        "sender_full_name": "Eric Huss",
        "timestamp": 1648247994
    }
]