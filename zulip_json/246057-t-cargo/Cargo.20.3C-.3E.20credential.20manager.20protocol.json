[
    {
        "content": "<p>Hi all! I'm the engineering manager for Azure DevOps Artifacts. You may recognize me from when I helped bring the rust build onto Azure Pipelines (a long time ago!).  Now, we're excited to be working on Crates support in our product (along with e.g. <span class=\"user-mention\" data-user-id=\"270929\">@Arlo Siemsen</span> ).  We're looking at the credential manager aspect and I wanted to get some feedback :)</p>\n<ol>\n<li>The current RFC seems to focus on credential <em>storage</em>.  Generally, I like to think about credential managers as providing fresh and short-lived auth tokens.  I think these two concepts can coexist, but it means that our authenticator would end up noop-ing actions like \"erase\" and \"store\".  Does this sound right?</li>\n<li>Most protocols (e.g. python, nuget, docker, git) do have a \"proper\" credential manager. It <em>feels</em> weird that cargo is different.  This is discussed some in the PR <a href=\"https://github.com/rust-lang/rfcs/pull/2730#issuecomment-582838921\">https://github.com/rust-lang/rfcs/pull/2730#issuecomment-582838921</a>.  I can't point to anything explicitly incorrect with <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> ' s point that you could shell out to one if need be, but I was wondering if there are any reflections on the current setup now that it's been out for awhile.  e.g. I think some cred managers avoid the \"reparsing args\" mess by sending anything dynamic over structured stdin/stdout. <a href=\"https://git-scm.com/docs/git-credential#IOFMT\">https://git-scm.com/docs/git-credential#IOFMT</a> or using JSON <a href=\"https://docs.microsoft.com/en-us/nuget/reference/extensibility/nuget-exe-credential-providers\">https://docs.microsoft.com/en-us/nuget/reference/extensibility/nuget-exe-credential-providers</a></li>\n<li>We get a lot of support tickets when auth fails.  I would love if we could send back a header to cargo that it would dump to the console e.g. \"X-Cargo-Auth-FailureReason: The provided token is expired\", \"The provided token is for a different tenant\", etc. Thoughts?</li>\n<li>Similar to <a href=\"https://github.com/rust-lang/rust/issues/3\">#3</a> but for the command-line authenticator.  It sounds like if we return a non-zero exit code then cargo could perhaps show a helpful error from the authenticator - e.g. \"no tokens found in keychain\"</li>\n</ol>",
        "id": 274602555,
        "sender_full_name": "John Erickson",
        "timestamp": 1646771636
    },
    {
        "content": "<p>For (3), rather than a header, could you just return an HTTP 401 or similar, and we can print the body if it's text/plain?</p>",
        "id": 274603944,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646772268
    },
    {
        "content": "<p>yes - happy to do whatever is standard/normal/simple for <a href=\"https://github.com/rust-lang/rust/issues/3\">#3</a>.  I know on the NuGet side they were relying on the message in the <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html\"><code>Reason-Phrase</code></a> but that got cut from HTTP2 :(</p>",
        "id": 274604307,
        "sender_full_name": "John Erickson",
        "timestamp": 1646772449
    },
    {
        "content": "<p>Is the idea that Azure Artifacts would provide a Cargo credential manager? If so, that credential manager could output any errors as needed to stdout.</p>\n<p>I know git has the \"Git Credential Manager\" which provides support for ADO Git, GitHub and BitBucket. Are we thinking of building something similar (designed for supporting multiple registry providers)?</p>",
        "id": 274605049,
        "sender_full_name": "Arlo Siemsen",
        "timestamp": 1646772776
    },
    {
        "content": "<p>Hi!  The credential-process support is very primitive, and I feel like it needs some work. I'm not aware of anyone actually using it (other than myself). </p>\n<p>I think for credential systems that are short-lived tokens, I think returning an error for <code>erase</code> and <code>store</code> would be appropriate. It would just be a part of documenting that you do not use <code>cargo login</code> or <code>cargo logout</code>.</p>\n<p>It would be worthwhile to discuss different ways to integrate credential management. The initial design was chosen to avoid needing a JSON parser (to keep the managers as simple as possible), and also to make it feasible for the manager to accept user input over stdin (for entering passwords or whatever).</p>\n<p>For displaying auth errors, Cargo should handle a JSON body with the errors (described in the docs). Is that a feasible option for you?</p>\n<p>As for credential manager errors, the manager should be able to print any message it wants to stderr.  Perhaps I'm misunderstanding that, though?</p>",
        "id": 274605499,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646772971
    },
    {
        "content": "<p>I think we need a better plan for how caching works too. </p>\n<ul>\n<li>Is it the responsibility of the credential provider to cache a token?</li>\n<li>Do we need a way for cargo to signal back to the credential provider that authentication failed, and it may need to acquire a new token?</li>\n</ul>\n<p>Printing errors to stderr seems like it should work fine.</p>",
        "id": 274606473,
        "sender_full_name": "Arlo Siemsen",
        "timestamp": 1646773358
    },
    {
        "content": "<p>As I understand it, GCM is a funny artifact of history.  IIRC the original design was that <code>git</code> would call out to different cred managers - one for each service.  This never materialized and there became one cred manager that <code>git</code> itself interfaced with and then <em>that</em> particular cred manager has multiple plugins.</p>\n<p>Personally, I have no desire to develop and maintain \"one (cargo authenticator key-)ring to rule them all\" <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 274607024,
        "sender_full_name": "John Erickson",
        "timestamp": 1646773571
    },
    {
        "content": "<p>Yea, I think cargo is in the same boat, where each system would have a separate implementation.  And yea, the caching problem means everyone needs to figure out how to cache it themselves, which is not ideal.</p>",
        "id": 274607628,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646773890
    },
    {
        "content": "<p>I don't know what it would look like if cargo handled the caching, and then need to refresh if the auth failed.</p>",
        "id": 274607816,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646773979
    },
    {
        "content": "<p>Part of the exercise was to see what it was like to implement for different mechanisms.</p>",
        "id": 274607840,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646773992
    },
    {
        "content": "<p>I did the macos/windows/linux/1password integrations.  Only the 1password one seems useful, since it forces user interaction.  The others are not for various reasons.</p>",
        "id": 274607933,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646774039
    },
    {
        "content": "<p>And with <a href=\"https://github.com/rust-lang/rfcs/issues/3231\">rfc#3231</a>, it might give more opportunities to use more interesting forms of auth (like hardware keys).</p>",
        "id": 274608114,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646774114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span>  interesting on that RFC - FYI I was chatting with some GitHub peers about how we could leverage the model of <a href=\"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect\">https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect</a> for package managers.</p>",
        "id": 274610244,
        "sender_full_name": "John Erickson",
        "timestamp": 1646775145
    },
    {
        "content": "<p>One caching-related consideration: if someone runs <code>cargo xyz</code> and that process involves multiple registry operations, they shouldn't have to touch their hardware key multiple times.</p>",
        "id": 274610351,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646775199
    },
    {
        "content": "<p>In general, Cargo tends to lean more in the direction of \"standardize one way to do it\" than \"support many different ways to do it\". I think that applies here as well: we don't, for instance, want multiple crypto families, we want one kind of token that works everywhere.</p>",
        "id": 274610508,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646775264
    },
    {
        "content": "<p>In the design of a credential manager protocol, we're not trying to offer <em>maximum</em> flexibility, just <em>enough</em> flexibility to handle the desired use cases.</p>",
        "id": 274610526,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646775280
    },
    {
        "content": "<p>So, for instance, we want to support hardware tokens, or OS keychains/credential-stores, but not allow credential managers to come up with a completely different auth protocol or different crypto.</p>",
        "id": 274610579,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646775314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span>  To elaborate on what <a href=\"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect\">https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect</a> would mean, one would configure <a href=\"http://crates.io/Azure-Artifact\">crates.io/Azure-Artifact</a> to deny publish to all humans/identities, but rather only allow publishes from a specific CI build definition (e.g. GitHub Action).  The CI would not have to store any secrets. As a bonus, the token sent to <a href=\"http://crates.io/Azure-Artifacts\">crates.io/Azure-Artifacts</a> would actually carry cryptographic proof that the bits that are in the body actually came from a GH build of commit ABC in Action XYZ.</p>",
        "id": 274610999,
        "sender_full_name": "John Erickson",
        "timestamp": 1646775530
    },
    {
        "content": "<p>I should start a different topic for that.  Cred provider is more critical for developer desktops IMO :)</p>",
        "id": 274611069,
        "sender_full_name": "John Erickson",
        "timestamp": 1646775568
    },
    {
        "content": "<p>I would love to talk about what you have in mind, especially the ways it is or is not compatible with <a href=\"https://github.com/rust-lang/rfcs/pull/3231\">rfc#3231</a>.</p>",
        "id": 274611291,
        "sender_full_name": "Eh2406",
        "timestamp": 1646775671
    },
    {
        "content": "<p>I'll start another topic on the OIDC stuff once I get ok from someone to share a doc :)</p>",
        "id": 274613008,
        "sender_full_name": "John Erickson",
        "timestamp": 1646776466
    },
    {
        "content": "<p>Generally in the Rust community ( but especially about security matters ) RFCs have a lot of in the weeds details and are not accepted till they've all been thought about carefully. \"this is a big picture goal\" is not how we use RFCs, nor do we except \"we have it all figured out, so do it how we did it\" RFCs. None of us (on the Cargo Team) have a security background, so it is going to take us a lot of work to figure out if a completed design makes sense.<br>\nSpeaking realistically, improvements to the security of this system are going to require some patience too teach us why this is the correct solution among all possible solutions. We can be included in early discussions and educated as the conversation develops, or be brought in at the end with significant effort to catch us up.</p>",
        "id": 274616069,
        "sender_full_name": "Eh2406",
        "timestamp": 1646778034
    },
    {
        "content": "<p>Sometimes I feel like I know just enough to be dangerous :)</p>",
        "id": 274618170,
        "sender_full_name": "John Erickson",
        "timestamp": 1646779172
    },
    {
        "content": "<p>Me too! And that is why I end up moving very slowly!</p>",
        "id": 274619778,
        "sender_full_name": "Eh2406",
        "timestamp": 1646780177
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span>  getting back to some of your earlier questions :)</p>\n<blockquote>\n<p>For displaying auth errors, Cargo should handle a JSON body with the errors (described in the docs). Is that a feasible option for you?<br>\nAs for credential manager errors, the manager should be able to print any message it wants to stderr. Perhaps I'm misunderstanding that, though?</p>\n</blockquote>\n<p>Works for me <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>  Other package managers have been more strict on how to report things back and/or displaying <em>just</em> the HTTP status code - which is usually not sufficient to diagnose the problem.</p>",
        "id": 274619806,
        "sender_full_name": "John Erickson",
        "timestamp": 1646780198
    },
    {
        "content": "<blockquote>\n<p>Most protocols (e.g. python, nuget, docker, git) do have a \"proper\" credential manager. It feels weird that cargo is different.</p>\n</blockquote>\n<p>I don't have a lot of experience with how the other systems work. <span class=\"user-mention\" data-user-id=\"262947\">@John Erickson</span> , what makes them '\"proper\" credential manager\"? In what way are cargo's improper?</p>",
        "id": 274858563,
        "sender_full_name": "Eh2406",
        "timestamp": 1646929254
    },
    {
        "content": "<p>I just brain-dumped with <span class=\"user-mention\" data-user-id=\"270929\">@Arlo Siemsen</span>  :)</p>",
        "id": 275006506,
        "sender_full_name": "John Erickson",
        "timestamp": 1647019987
    }
]