[
    {
        "content": "<p>I'm trying to do something very dark and shady — I'm writing a Cargo subcommand that acts like <code>cargo publish</code>, but instead publishes... elsewhere (specifically, into a registry managed by a larger build system). As part of that, I want to adjust the minor version of the crate being published so that it gets an automatically-assigned minor version rather than using what's in <code>Cargo.toml</code>. Now, I know this is kind of deep in no-no territory (happy to get into why it's likely the right decision if that'd be helpful), but I'm wondering if it's _possible_. I _think_ I can reach into a <code>Workspace</code> deep enough to modify the in-memory state for a package to adjust the version before calling <code>package_one</code>, but is that likely to be sufficient?</p>\n<p><a href=\"https://github.com/rust-lang/cargo/blob/4cc3f4f193c4018e4ffbe0e724686b53d5f38ad2/src/cargo/ops/cargo_package.rs#L581\">https://github.com/rust-lang/cargo/blob/4cc3f4f193c4018e4ffbe0e724686b53d5f38ad2/src/cargo/ops/cargo_package.rs#L581</a></p>\n<p>makes me think it's doable, but I wanted to check before I set down this path and try to actually write the dark voodoo code required</p>",
        "id": 260739083,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636417715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120054\">@Jon Gjengset</span> So, there's a related concept that I think might be useful to you, if you might be interested in working on it.</p>",
        "id": 260739219,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636417833
    },
    {
        "content": "<p>Downstream distributors of crates sometimes need to make revisions. For instance, a Linux distribution might patch a crate.</p>",
        "id": 260739246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636417859
    },
    {
        "content": "<p>I think it'd make sense to augment semver, and add a concept of sub-micro versions, which are infinitely divisible (e.g. there's always a new sub-micro version between any two semver versions).</p>",
        "id": 260739272,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636417901
    },
    {
        "content": "<p>So, if you're patching 1.2.3, you can make 1.2.3.1, and if someone needs to patch <em>that</em> they can make 1.2.3.1.1, and both of those come before 1.2.3.2 or 1.2.4.</p>",
        "id": 260739343,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636417935
    },
    {
        "content": "<p>Your description of adjusting the minor version of the crate makes me wonder if something like this might be what you're looking for.</p>",
        "id": 260739370,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636417971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120054\">@Jon Gjengset</span> What do you think?</p>",
        "id": 260739378,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636417979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> That _would_ be nice in terms of making the version re-assignment more obvious, but I don't _think_ that feature actually helps with the fact that ultimately I still need to package a crate with a different version than what's in its <code>Cargo.toml</code>?</p>",
        "id": 260739482,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418052
    },
    {
        "content": "<p>I suppose it might suggest that <code>publish_one</code> could gain a \"add_microversion\" argument, though that just forwards the problem into Cargo</p>",
        "id": 260739523,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418084
    },
    {
        "content": "<p>You'd still need to either patch or override <code>Cargo.toml</code>, yes.</p>",
        "id": 260739530,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418100
    },
    {
        "content": "<p>Just wondering if the minor or micro version is <em>actually</em> what you were looking to change, or if you just need a workable scheme for downstream versioning.</p>",
        "id": 260739565,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120054\">Jon Gjengset</span> <a href=\"#narrow/stream/246057-t-cargo/topic/dark-magic-reassigning-version/near/260739523\">said</a>:</p>\n<blockquote>\n<p>I suppose it might suggest that <code>publish_one</code> could gain a \"add_microversion\" argument, though that just forwards the problem into Cargo</p>\n</blockquote>\n<p>Are you looking to change it <em>without</em> patching the crate, or could you patch <code>Cargo.toml</code>?</p>",
        "id": 260739673,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418186
    },
    {
        "content": "<p>I'm totally on board with assigning a new microversion instead if such a thing existed, but I specifically do not want to modify <code>Cargo.toml</code> in the file-system. I _only_ want the override in the packaged tarball. This is because the <code>Cargo.toml</code> is in a user's working directory, and I'd rather not make adjustments to their files (which are checked into git) that should be irrelevant to them.</p>",
        "id": 260739681,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418196
    },
    {
        "content": "<p>(And do you apply any other patches to the crate, or is it unmodified?)</p>",
        "id": 260739682,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418199
    },
    {
        "content": "<p>The crate is unpatched. I _only_ want to give it a modified version number.</p>",
        "id": 260739693,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418218
    },
    {
        "content": "<p>In fact, it is arguably a design goal for this process to avoid stepping on Cargo's standard process as much as we possibly can.</p>",
        "id": 260739709,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418241
    },
    {
        "content": "<p>To give a bit more context:</p>",
        "id": 260739718,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418250
    },
    {
        "content": "<p>The fundamental problem I'm trying to solve is that these crates are being built in the context of a larger build system that may choose to re-build a crate (which includes publishing it) even if the crate itself has not changed, such as if one of its (non-Cargo) dependencies changed. In such a case, there is no human who could bump the version in Cargo.toml, so we need to automatically assign the versions (the minor/micro versions specifically). And then I want to align that with the fact that there can _also_ be builds by humans in their development workspaces, where we don't want to be modifying their on-disk files any time the build system decides to publish, because it would just lead to spurious <code>Cargo.toml</code> modifications, which in turn cause git conflicts and pain.</p>",
        "id": 260739934,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418405
    },
    {
        "content": "<p>What does \"publish\" mean here, if the crate is unmodified?</p>",
        "id": 260740008,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418477
    },
    {
        "content": "<p>Or rather, what is the semantic function in your build system of publishing a new version of a crate if the previous version is identical?</p>",
        "id": 260740045,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418518
    },
    {
        "content": "<p>So, it's not necessarily identical. For example, one of my non-Cargo dependencies might be a (non-Cargo) package that vends a JSON file of, say, pre-approved licenses, which I <code>include_str!</code> into my source as part of the build.</p>",
        "id": 260740147,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418583
    },
    {
        "content": "<p>Point being, the \"outer\" build system has to assume that any change in the dependencies of A _may_ result in a change to the build artifacts of A, and therefore has to re-build A, which also means re-publishing A's artifacts, which thus need a new version number.</p>",
        "id": 260740262,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418656
    },
    {
        "content": "<p>So, effectively, these are not versions of the source package, they're versions of the binary artifacts you're building?</p>",
        "id": 260740348,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418717
    },
    {
        "content": "<p>And the \"publish\" operation you're describing is the build-and-ship of a binary compiled version of a crate?</p>",
        "id": 260740447,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418774
    },
    {
        "content": "<p>Well, sort of. It becomes complicated like in the above case for example where a dependency's effective source changes due to something like <code>include_str!</code>. Same thing can happen with things like crates that have build scripts that invoke <code>bindgen</code> on a header file vended by a (non-Cargo) dependency.</p>",
        "id": 260740455,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418785
    },
    {
        "content": "<p>It really is publishing a <code>.crate</code>, and the contents of that <code>.crate</code> may have changed.</p>",
        "id": 260740475,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418805
    },
    {
        "content": "<p>Sure, that makes sense. And your non-cargo build system is managing those other artifacts like the C libraries with their header files or the files being fed into <code>include_str!</code>, and that build system knows that if a dependency changes it needs to update the artifacts depending on it?</p>",
        "id": 260740607,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418910
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 260740619,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636418922
    },
    {
        "content": "<p>So, ignoring for a moment how this would integrate with Cargo...</p>",
        "id": 260740630,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418933
    },
    {
        "content": "<p>It <em>seems</em>, to me, like you need an expanded version number here, in some fashion. You need the crate version, and then you need the version within your build system, which contains the crate version and an additional version (even if it's just a sequentially increasing number).</p>",
        "id": 260740662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636418974
    },
    {
        "content": "<p>(This is assuming, for the moment, that the external dependencies don't actually semantically bump the major version number of a crate, or that you don't care if they do because your build system doesn't do Cargo-style dependency resolution.)</p>",
        "id": 260740729,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419011
    },
    {
        "content": "<p>True. And my plan was to co-opt the minor version number for this. For various reasons, Cargo version numbers are _basically_ not used internally (which makes me sad, and I'm trying to change that somewhat), and _definitely_ not minor versions, so in the interest of getting something working in place, re-using that seemed like the easiest path.</p>",
        "id": 260740774,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636419073
    },
    {
        "content": "<p>If Cargo version numbers aren't used internally, do you actually need the crate version to change?</p>",
        "id": 260740812,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419098
    },
    {
        "content": "<p>Or could you just have your own version number entirely?</p>",
        "id": 260740820,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419107
    },
    {
        "content": "<p>Yes, because Cargo is _very_ picky about crate versions being immutable in registries.</p>",
        "id": 260740831,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636419116
    },
    {
        "content": "<p>It's a lot less picky about directory registries. What kind of registry are you using?</p>",
        "id": 260740904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419144
    },
    {
        "content": "<p>I'm genuinely wondering if what you're doing might do better to integrate very slightly less with Cargo. ;)</p>",
        "id": 260740947,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419192
    },
    {
        "content": "<p>My goal is to use a HTTP registry when that lands. For the time being, a dynamically constructed local registry with <code>[patch]</code> injected into <code>.cargo/config.toml</code> to work around the fact that I don't control the version numbers :p</p>",
        "id": 260740949,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636419195
    },
    {
        "content": "<p>Hmmm.</p>",
        "id": 260741029,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419244
    },
    {
        "content": "<p>I forget exactly why I went with a local registry instead of a directory registry. I believe it was because I need to be able to do _resolution_ across basically all of <a href=\"http://crates.io\">crates.io</a> using Cargo as a library, but then only actually pull in the artifacts that are truly needed.</p>",
        "id": 260741073,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636419293
    },
    {
        "content": "<p>I _think_ the right thing to do here is to lean into Cargo as much as I possibly can and do everything \"the standard way\" and \"the way Cargo wants\". And part of that is because the more things that are custom, the more likely it is users will run into issues in \"the way we do things\", and can't take advantage of all the excellent work in Cargo itself. And I _think_ the way to do that is to give Cargo \"the right version numbers\". I think actually a lot of the pain we're currently having comes from the fact that we insist on giving all packages the same version number (specifically because devs never increment them + the auto-rebuild-on-dependencies case).</p>",
        "id": 260741226,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636419395
    },
    {
        "content": "<p>Well, while I'm not speaking for any other members of the team, and I know that diverging from semver might be concerning and effortful and getting a patch <em>into</em> upstream semver would be harder, I <em>personally</em> would be hugely in favor of adding 1) more-than-three-component version numbers, with the obvious sorting, and 2) an <code>--override-submicro-version</code> option.</p>",
        "id": 260741381,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419553
    },
    {
        "content": "<p>I would highly, <em>highly</em> recommend getting confirmation from the full team on such a plan before embarking on it though.</p>",
        "id": 260741655,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419735
    },
    {
        "content": "<p>Would the combination of those two things address your issue?</p>",
        "id": 260741680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636419770
    },
    {
        "content": "<p>Yes, I think that combination would indeed do what I want. Though I also worry that it's a _very_ long path, especially as you observe because it requires changes to upstream semver. It might be something I can push on, but my guess for that is months-to-years before it actually being available to use. So the question then becomes what to do in the meantime. Which also relates to \"how do you implement <code>--override-submicro-version</code>? Which gets back to my original question :p Not saying this wasn't/isn't a valuable discussion, but I think it's more of a long-term plan than a short-to-medium one.</p>",
        "id": 260741809,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636419856
    },
    {
        "content": "<p>Strictly speaking, it doesn't <em>require</em> changes to upstream semver, it'd just be nicer if we did.</p>",
        "id": 260742095,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420118
    },
    {
        "content": "<p>I suppose that's true. Cargo already does some only-semi-semver things <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 260742123,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420156
    },
    {
        "content": "<p>Actually, there <em>is</em> a path that would stay within semver, if you don't actually care at all about Cargo's version resolution (e.g. resolving <code>1.2.1</code> to <code>1.2.5</code> since the latter is compatible with the former).</p>",
        "id": 260742153,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420199
    },
    {
        "content": "<p>I do care about Cargo's version resolution though, since I want it to pick the latest if there are multiple published versions</p>",
        "id": 260742219,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420251
    },
    {
        "content": "<p>Well, it may be possible to still use it, it just would take some validation to see how well it works.</p>",
        "id": 260742237,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420282
    },
    {
        "content": "<p>You could use the semver \"build metadata\" field, which seems designed for this.</p>",
        "id": 260742254,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420307
    },
    {
        "content": "<p>Hmm, I thought those were stripped by the time a version makes it to the registry?</p>",
        "id": 260742266,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420321
    },
    {
        "content": "<p>No, there are crates in the registry that have them.</p>",
        "id": 260742305,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420331
    },
    {
        "content": "<p>huh, oh yeah <a href=\"https://crates.io/crates/curl-sys\">https://crates.io/crates/curl-sys</a></p>",
        "id": 260742323,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420353
    },
    {
        "content": "<p><a href=\"https://crates.io/crates/zstd\">https://crates.io/crates/zstd</a></p>",
        "id": 260742324,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420353
    },
    {
        "content": "<p>You could add an <code>--append-build-metadata</code> option, which would append a new token to the build metadata.</p>",
        "id": 260742337,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420379
    },
    {
        "content": "<p>hmmmm, I wonder what <a href=\"http://crates.io\">crates.io</a> says if you try to publish two crates whose versions differ only be build metadata <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 260742353,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420397
    },
    {
        "content": "<p>So, <code>--append-build-metadata my123</code> would turn <code>4.5.6</code> into <code>4.5.6+my123</code>, or turn <code>4.5.6+existing.metadata</code> into <code>4.5.6+existing.metadata.my123</code>.</p>",
        "id": 260742371,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120054\">Jon Gjengset</span> <a href=\"#narrow/stream/246057-t-cargo/topic/dark-magic-reassigning-version/near/260742353\">said</a>:</p>\n<blockquote>\n<p>hmmmm, I wonder what <a href=\"http://crates.io\">crates.io</a> says if you try to publish two crates whose versions differ only be build metadata <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>I don't know if <a href=\"http://crates.io\">crates.io</a> allows it. But your registry could. And as far as I know, <em>current</em> cargo should be alright with it, though older cargo had some bugs.</p>",
        "id": 260742448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420479
    },
    {
        "content": "<p>There's some discussion at <a href=\"https://github.com/rust-lang/crates.io/issues/1059\">https://github.com/rust-lang/crates.io/issues/1059</a> .</p>",
        "id": 260742574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420567
    },
    {
        "content": "<p>And it <em>looks</em> like the semver crate handles this sensibly.</p>",
        "id": 260742613,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420606
    },
    {
        "content": "<p>You might run into some corner cases that need fixing in cargo, but this seems like a workable solution path that wouldn't require waiting on long-term standards work.</p>",
        "id": 260742625,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636420623
    },
    {
        "content": "<p>Hmm, reading through that discussion it seems like the general consensus is that Cargo can choose randomly, and that _arguably_ it should be blocked on upload (&lt;<a href=\"https://github.com/rust-lang/crates.io/issues/1059#issuecomment-521787675\">https://github.com/rust-lang/crates.io/issues/1059#issuecomment-521787675</a>&gt;). Which I suppose matches what you say — that if Cargo/<code>semver</code> do something sane, then it's workable.</p>",
        "id": 260742830,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420797
    },
    {
        "content": "<p>Interestingly, this feels _more_ like a hack to me than modifying the minor version number. Because by using build metadata we're communicating the wrong _semantic_ information to semver.</p>",
        "id": 260742898,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420834
    },
    {
        "content": "<p>Two versions that differ only in build metadata _should_ be equivalent, but in this case they really aren't. They _are_ new distinct versions with (potentially) different source.</p>",
        "id": 260742930,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420873
    },
    {
        "content": "<p>hmm hmm hmm</p>",
        "id": 260742953,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636420907
    },
    {
        "content": "<p>So, that may be how semver describes it, but it isn't how people use it.</p>",
        "id": 260743344,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636421261
    },
    {
        "content": "<p>The most common use I've seen is for the version number of an underlying FFI library.</p>",
        "id": 260743397,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636421285
    },
    {
        "content": "<p>(see zstd for an example)</p>",
        "id": 260743406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636421298
    },
    {
        "content": "<p>That's what gave me the idea.</p>",
        "id": 260743417,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636421318
    },
    {
        "content": "<p>Looking at that though, it does seem like build metadata because the Cargo version is _also_ incremented. There are no two releases that differ only in the build metadata. Instead, the build metadata merely indicates which version of the underlying library a given Cargo version was generated from — it's not used to ascribe ordering meaning to the version.</p>",
        "id": 260743565,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636421427
    },
    {
        "content": "<p>Regardless of where I end up, this has been very helpful <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  — thanks for taking the time!</p>",
        "id": 260745625,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636423346
    },
    {
        "content": "<p>That's true about zstd, but I think other crates may not do that.</p>",
        "id": 260746634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636424481
    },
    {
        "content": "<p>And I'm glad!</p>",
        "id": 260746636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636424486
    },
    {
        "content": "<p>Thanks for putting so much effort into trying to cooperate with cargo!</p>",
        "id": 260746644,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636424502
    },
    {
        "content": "<p>You could use prerelease versions (<code>1.0.0-1</code>) which should behave sensibly I think.</p>",
        "id": 260761460,
        "sender_full_name": "bjorn3",
        "timestamp": 1636441852
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Those sort earlier than the final version, though, which would make them problematic for dependencies.</p>",
        "id": 260793827,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636462900
    },
    {
        "content": "<p>You can choose to never release the final version.</p>",
        "id": 260794000,
        "sender_full_name": "bjorn3",
        "timestamp": 1636462980
    },
    {
        "content": "<p>If you're modifying <code>1.2.3</code> into <code>1.2.3~1</code>, that wouldn't (or at least <em>shouldn't</em>, I don't know if there are still issues) satisfy a dependency on \"1.2.3\".</p>",
        "id": 260794243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636463101
    },
    {
        "content": "<p>The crates are not public. It would be possible to depend on <code>1.2.3-0</code> and then modify the crate versions to <code>1.2.3-1</code>, <code>1.2.3-2</code>, ... on upload to the local registry. Newer pre-releases are considered to satisfy older pre-release requirements.</p>",
        "id": 260816955,
        "sender_full_name": "bjorn3",
        "timestamp": 1636472959
    },
    {
        "content": "<p>I had the impression that some crates were imported from public, and if so, it might be painful to rewrite their dependencies too.</p>",
        "id": 260826338,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636477236
    },
    {
        "content": "<p>Ah, so, we never modify public crates (that is, those imported from <a href=\"http://crates.io\">crates.io</a>). This auto-versioning is only for \"internal\" crates managed by this bigger build system, which also means that no public crates will have dependencies on them. So it is feasible to require all internal versions and dependency specifiers to use pre-release versions. However, that feels pretty \"anti-Cargo\" — if the goal is to make internal Rust development as close to external development as possible (which it is), then \"always use pre-release everywhere and never release a non-pre-release version\" seems possibly counter-productive.</p>\n<p>The more I think about this, the more I feel like auto-setting the patch version number is the right way to go short term, and then to have the long-term plan be to have semver (or at least Cargo's semver) have a notion of subpatch versions. Overnight I did realize that that likely won't make it into the semver spec though, since it would be a backwards incompatible change to the spec — parsers that support the _current_ version of the spec would fail to parse version specifiers using the expanded range.</p>",
        "id": 260830698,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636479115
    },
    {
        "content": "<p>You feel like the patch version is going to be a better fit than the build metadata, even if the latter works in Cargo?</p>",
        "id": 260831012,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636479257
    },
    {
        "content": "<p>I'm _really_ torn on build metadata. I like it as a solution because it appends instead of overwrites, but I dislike it because it goes directly against the spec. And experience tells me that going against the spec inevitably comes back to bite you in the ass. Whereas overwriting the patch version doesn't actually seem problematic in this case since I _know_ its unused for the crates anyway (in fact, I'm planning on emitting an error if the patch version is ever <code>!= 0</code>).</p>",
        "id": 260831387,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636479470
    },
    {
        "content": "<p>FWIW, if the crates are <em>exclusively</em> your own, then that seems much less problematic.</p>",
        "id": 260831709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636479583
    },
    {
        "content": "<p>Yes, the crates I'm doing this to are exclusively internal crates (that is, crates written in the context of this build system).</p>",
        "id": 260832243,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636479689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> FYI, I found the \"same version different build metadata\" issue you were thinking of: &lt;<a href=\"https://github.com/rust-lang/cargo/issues/7180\">https://github.com/rust-lang/cargo/issues/7180</a>&gt;.</p>",
        "id": 261202228,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1636679795
    }
]