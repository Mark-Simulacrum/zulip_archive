[
    {
        "content": "<p>I'm trying to address <a href=\"https://github.com/rust-lang/cargo/issues/9863\">https://github.com/rust-lang/cargo/issues/9863</a> (target-specific feature enabling doesn't propagate the target-specificness of the dep to cargo-metadata) and it seems like there are two approaches I could delve into. I'd appreciate any thoughts folks have about which (or others) to pursue:</p>\n<ol>\n<li>I started on <a href=\"https://github.com/rust-lang/cargo/pull/9982\">https://github.com/rust-lang/cargo/pull/9982</a> but the problem here is that (roughly) <code>activate</code> is called once per unique candidate rather than per dependency edge, which means that if there are multiple paths to a dep we only notice one. To address this, I could try to add \"track the metadata\" calls per edge which would do less work than a full <code>activate</code> but enough to note that there are multiple paths, but this is already a fairly complex area of code and it feels like tracking \"edges we haven't visited but have activated, so we can re-visit them\" alongside the existing use-manual-stacks-to-avoid-overflowing-the-stack would be non-trivial extra complexity.</li>\n<li>Rather than trying to do this tracking during resolving itself, we could do a post-processing pass in <code>cargo_output_metadata::build_resolve_graph</code> to walk the graph resolving features and dependencies, and note the target-specific-ness of things as we go. This is nicely self-contained, but feels like it's duplicating a bunch of the resolve itself, which makes it prone to falling out of sync with the \"true\" resolve.</li>\n<li>Any other ideas!</li>\n</ol>",
        "id": 259264200,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1635351264
    },
    {
        "content": "<p>It might be helpful to take a step back and try to better understand what you are trying to do.  The example in <a href=\"https://github.com/rust-lang/cargo/issues/9863\">cargo#9863</a> seems like <code>cargo metadata</code> provides the information needed with the <code>--filter-platform</code> flag.  That is, with <code>--filter-platform=x86_64-pc-windows-msvc</code>, I don't see <code>serde_derive</code> in the <code>cargo metadata</code> output. However, with <code>x86_64-unknown-linux-gnu</code> or <code>x86_64-apple-darwin</code> it is.</p>\n<p>I'm not sure if the issue is implying that <code>serde_derive</code> isn't built on x86_64-unknown-linux-gnu, but it should be.</p>",
        "id": 259317929,
        "sender_full_name": "Eric Huss",
        "timestamp": 1635375100
    },
    {
        "content": "<p>(I just edited the text of the issue because the two platforms were the wrong way around for the code, but that was just confusing rather than substantial!)</p>\n<p>I believe <code>serde_derive</code> _shouldn't_ be built on Linux in the example - it's not enabled by a feature on that platform?</p>\n<p>Running with <code>--filter-platform=x86_64-unknown-linux-gnu</code>, if you delete the darwin-specific dependency from the Cargo.toml file (line 12: <a href=\"https://github.com/illicitonion/cargo-metadata-pathologies/blob/12fe791f4348399c0b8ecb247cb1b8eaee8cf50f/platform-specific-features/Cargo.toml#L12\">https://github.com/illicitonion/cargo-metadata-pathologies/blob/12fe791f4348399c0b8ecb247cb1b8eaee8cf50f/platform-specific-features/Cargo.toml#L12</a>) <code>serde_derive</code> stops appearing in the <code>resolve</code> section . But with line 12 present, it _does_ appear. I think this is incorrect?</p>",
        "id": 259329885,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1635385243
    },
    {
        "content": "<p>I think it's possible the behaviour of cargo for builds changed with resolver 2 to not enable the dependency, but <code>cargo-metadata</code> didn't follow suit? It's possible that the repro example should have a <code>resolver = \"2\"</code> in it...</p>",
        "id": 259329932,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1635385308
    },
    {
        "content": "<p>The stepping back, though - we're trying to generate build plans for Bazel, based on the output of cargo metadata (so we're ourselves invoking <code>rustc</code> and friends, rather than having <code>cargo</code> drive it), and knowing \"we shouldn't try building this windows-only crate on linux\" is useful. One of our contributors put together a hacky solution which issues multiple <code>cargo tree</code> queries, one per platform, because it happens to expose the information, but ideally we'd want to get it directly from <code>cargo metadata</code> rather than having to invoke a bunch of things that happen to probably-accidentally work and stitch the information together :)</p>",
        "id": 259330163,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1635385568
    },
    {
        "content": "<p>This is the code which does the <code>cargo tree</code> calls, in case it's interesting: <a href=\"https://github.com/grafica/cargo-raze-new-features/commit/121db30327423a8062859820bb35ba50b0d70576\">https://github.com/grafica/cargo-raze-new-features/commit/121db30327423a8062859820bb35ba50b0d70576</a></p>",
        "id": 259330193,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1635385621
    },
    {
        "content": "<p>With <code>resolver=\"1\"</code>, the features are unified with all the listed targets if you build for just one of those targets.  With <code>resolver=\"2\"</code>, they will be separated.  And indeed, <code>cargo metadata</code> does not expose information for the new resolver .  See the explanation at <a href=\"https://rust-lang.github.io/rfcs/2957-cargo-features2.html#cargo-metadata\">https://rust-lang.github.io/rfcs/2957-cargo-features2.html#cargo-metadata</a>.   </p>\n<p>For creating a build graph, the <code>--unit-graph</code> flag was added as an experiment.  However, it is still pretty far from being able to generate all the correct flags and everything for rustc, and since it is such a low-level output, I'm pretty uncomfortable with putting it on a path to stabilization.</p>\n<p>So unfortunately there isn't a simple answer on how to handle this with the new feature resolver.</p>",
        "id": 259331410,
        "sender_full_name": "Eric Huss",
        "timestamp": 1635386869
    },
    {
        "content": "<p>That makes sense - thanks for the context!</p>",
        "id": 259358210,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1635411302
    }
]