[
    {
        "content": "<p>Hi all</p>\n<p>I need to configure our CI/CD pipeline to be able to detect if a certain branch has actually introduces any changes in the final artifact of a project inside of a workspace. This is needed to cut down the time spent in CI/CD for projects that are not affected by a change. I have looked at the fresh field in the cargo metadata but it doesn't seem that it can predict if a artifact would be changed in this manner. I have also tried doing md5sums on the artifact between the branches (to at least cut out the testing phase of CI) but I can't seem to get that to work even if the final artifact should not be affected by the change in a shared lib (also inside of the workspace). Yes I have ensured that I strip the artifact after compilation but no luck.</p>\n<p>Has anyone tackled this issue before?</p>",
        "id": 271045422,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644269854
    },
    {
        "content": "<p>Have you looked at what is actually different between you're no op builds with different hashes?</p>",
        "id": 271047971,
        "sender_full_name": "Eh2406",
        "timestamp": 1644270902
    },
    {
        "content": "<p>Trying to get bit for bit identical builds is called \"reproducible builds\", I don't know how close people are to that in rust but it might be a useful search term.</p>",
        "id": 271048130,
        "sender_full_name": "Eh2406",
        "timestamp": 1644270974
    },
    {
        "content": "<p>Hmm yeah thanks, that lead me to this issue <a href=\"https://github.com/rust-lang/rust/issues/34902\">https://github.com/rust-lang/rust/issues/34902</a> and the follow up <a href=\"https://github.com/rust-lang/rust/issues/75362\">https://github.com/rust-lang/rust/issues/75362</a>. I will investigate them closer tomorrow. Thanks for the pointer :)</p>",
        "id": 271050937,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644272172
    },
    {
        "content": "<p>Currently I run <code>env RUSTFLAGS =\"-C link-arg=-s -C relocation-model=static\" cargo build --release --message-format=json</code> but it doesn't seem that it is enough.Did not manage to track down what else I need to set so if anyone has any other ideas I would appreciate it.</p>",
        "id": 271193739,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644355794
    },
    {
        "content": "<p>You could look at the <code>.d</code> file emitted next to the final artifact. It should list all source dependencies as well as all read env vars (env vars maybe only on nightly)</p>",
        "id": 271196188,
        "sender_full_name": "bjorn3",
        "timestamp": 1644357026
    },
    {
        "content": "<p>I'm not sure if it also lists all <code>Cargo.toml</code> and the <code>Cargo.lock</code>.</p>",
        "id": 271196251,
        "sender_full_name": "bjorn3",
        "timestamp": 1644357061
    },
    {
        "content": "<p>I checked and the .d files on stable did not include any information that I did not already get from the metadata messages :/</p>",
        "id": 271478994,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644520029
    },
    {
        "content": "<p>Are you sure. For me it lists all source files. Eg</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ cat target/debug/foo.d\n/data/data/com.termux/files/home/foo/target/debug/foo: /data/data/com.termux/files/home/foo/src/main.rs /data/data/com.termux/files/home/foo/target/debug/build/target-lexicon-536c49ee1f1884eb/out/host.rs\n</code></pre></div>",
        "id": 271483167,
        "sender_full_name": "bjorn3",
        "timestamp": 1644521824
    },
    {
        "content": "<p>looks like it is missing most of the source files for the target-lexicon dependency though.</p>",
        "id": 271483268,
        "sender_full_name": "bjorn3",
        "timestamp": 1644521872
    },
    {
        "content": "<p>Ok, yeah it had a list of files but that doesn't help if say your <a href=\"http://host.rs\">host.rs</a> in target-lexicon contains 2 functions and the binary only uses one of them (so an update should only be triggered if that one changes).</p>",
        "id": 271634118,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644612079
    },
    {
        "content": "<p>Cargo only operates at a file level. You're not going to be able to get more detailed info from cargo.<br>\nAnd remember that line numbers are part of debug info, if the function that changed moved what line numbers the function you used was on you will get a different artifact.<br>\nYou may be able to get more out of \"incremental\" within rustc, don't know how well that can be introspected.</p>",
        "id": 271635358,
        "sender_full_name": "Eh2406",
        "timestamp": 1644612721
    },
    {
        "content": "<p>My current approach is to strip debug info and disable the relocation-model in hope that it would give a reproducible artifact.</p>",
        "id": 271636263,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644613253
    },
    {
        "content": "<p>I'm not concerned with any security of the final artifact, as all I want to do is to determine if a workflow should run or not for this workspace project.</p>",
        "id": 271636352,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644613306
    },
    {
        "content": "<p>Rustc requires recompiling the entire crate if any source file or any dependency changes. Rustc doesn't provide any way to recompile only some source files as all codegen units of a crate may be affected by a change in any source file. For example if you change an <code>#[inline]</code> function inlined into all codegen units. Changing an unused function may also change the abi of a used function when optimizing. In addition rustc flat out refuses compilation when any library is recompiled without recompiling all dependent libraries that are (directly or indirectly) used by the current crate. This even applies to whitespace only changes without debuginfo. A hash of among other things, all source files is used as unique identifier to check if a recompilation is necessary. Also even without debuginfo source locations are significant. Some end up in the final executable through <code>file!()</code>, <code>line!()</code>, <code>column!()</code> and <code>#[track_caller]</code> (the later used by all panics) They also end up in the crate metadata for cross crate diagnostics like pointing to the definition of a trait for which an implementation is missing a function.</p>",
        "id": 271640199,
        "sender_full_name": "bjorn3",
        "timestamp": 1644614973
    },
    {
        "content": "<p>Hmm, ok. I guess that approach won't work then :/</p>",
        "id": 271641168,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644615316
    },
    {
        "content": "<blockquote>\n<p>I need to configure our CI/CD pipeline to be able to detect if a certain branch has actually introduces any changes in the final artifact of a project inside of a workspace. This is needed to cut down the time spent in CI/CD for projects that are not affected by a change. </p>\n</blockquote>\n<p>Have you looked at <a href=\"https://github.com/facebookincubator/cargo-guppy/tree/main/tools/determinator\">determinator</a> to see if that helps?  Its goal is stated as \"Figure out what packages in a Rust workspace changed between two commits.\".</p>",
        "id": 271641437,
        "sender_full_name": "Ed Page",
        "timestamp": 1644615479
    },
    {
        "content": "<p>I have not stumbled across it during my investigations. Will take a look at how it performs.</p>",
        "id": 271642354,
        "sender_full_name": "Fredrik Park",
        "timestamp": 1644616013
    }
]