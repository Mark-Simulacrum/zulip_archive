[
    {
        "content": "<p>Add named path bases to cargo <a href=\"https://github.com/rust-lang/rfcs/pull/3074\">https://github.com/rust-lang/rfcs/pull/3074</a></p>",
        "id": 251638783,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630535106
    },
    {
        "content": "<p>Hi! Some folk at Microsoft are interested in this RFC. Discussion seems to have stalled a while back, and I'm not sure from the thread if the team considered it</p>",
        "id": 251638952,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630535175
    },
    {
        "content": "<p>How is sentiment towards the idea?</p>",
        "id": 251638975,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630535188
    },
    {
        "content": "<p>If we were to implement the feature (or part of it) behind a feature flag, could that land while the RFC was still being discussed?</p>",
        "id": 251639049,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630535254
    },
    {
        "content": "<p>(cc <a href=\"https://github.com/rust-lang/cargo/pull/9855\">https://github.com/rust-lang/cargo/pull/9855</a>)</p>",
        "id": 251639124,
        "sender_full_name": "Eh2406",
        "timestamp": 1630535285
    },
    {
        "content": "<p>Oh yes, that was our minimal solution to the problem we're having. RFC 3074 seems better all round really</p>",
        "id": 251639534,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630535570
    },
    {
        "content": "<p>I think conversation partially stopped because I ended up pursuing <code>patch-in-config</code> instead, which solved my use-case better, and therefore didn't continue to drive the RFC forward. Happy for someone with a concrete need to take it over!</p>",
        "id": 251643057,
        "sender_full_name": "Jon Gjengset",
        "timestamp": 1630538055
    },
    {
        "content": "<p>There is a lot to balance here. On one hand I do want cargo to work ergonomically with big build systems. On the other hand I am nervous about adding a special way to break into cargoes mental model for each one that comes along. How do we adequately test all the permutations of workspaces with version inheritance, and Source replacement, and patch in config, ... and that's just the ships that have sailed.</p>",
        "id": 251645279,
        "sender_full_name": "Eh2406",
        "timestamp": 1630539456
    },
    {
        "content": "<p>If there is any way to solve your problem without adding another; that would be amazing.</p>",
        "id": 251645383,
        "sender_full_name": "Eh2406",
        "timestamp": 1630539527
    },
    {
        "content": "<p>If we do have to add another one I want it to minimize that complexity and have a high probability of fixing the next person's problem to.</p>",
        "id": 251645520,
        "sender_full_name": "Eh2406",
        "timestamp": 1630539613
    },
    {
        "content": "<p>But of course everyone here already knew that. I'll get off my soapbox.</p>",
        "id": 251645591,
        "sender_full_name": "Eh2406",
        "timestamp": 1630539667
    },
    {
        "content": "<p>It's an important soapbox. :)</p>",
        "id": 251646166,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630540112
    },
    {
        "content": "<p>Totally agree there is a lot of complexity to balance, and their are always costs to adding this kind of complexity. I guess the more interesting question to me is how to make decisions about the trade-off. Are there known long term goals for Cargo in this area to evaluate against? Or are there principals (explicit or implicit) we can use to decide if the added complexity is good or bad?</p>",
        "id": 251652062,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630544803
    },
    {
        "content": "<p>IMO, working well with 'large' build systems is a really important goal for Cargo, but I don't know how the Cargo team and other more experienced folk want to accomplish that (assuming you all do want to accomplish it)</p>",
        "id": 251652132,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630544878
    },
    {
        "content": "<p>AFAICT, there isn't an existing mechanism which solves the problem here (or problems, if looking at the RFC use cases)</p>",
        "id": 251652212,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630544945
    },
    {
        "content": "<p>Maybe it's worth trying to abstract the problem a little bit to try and see if there is a more general problem we're trying to solve a part of?</p>",
        "id": 251652239,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630544982
    },
    {
        "content": "<p>I don't think we have well articulated rules for making decisions. ( I acknowledge that that makes it hard for other people to help. ) We accepted patch-in-config after John had made it clear that he had tried every existing tool, and had suggested all of the alternatives he could think of.  It had advantage of being the intersection of two existing features, so in some ways it did not add to the matrix of complexity. On the other hand it broke one of the \"implicit principals\" that pure rust building code should not depend on uncommitted configuration.</p>",
        "id": 251652678,
        "sender_full_name": "Eh2406",
        "timestamp": 1630545367
    },
    {
        "content": "<p>That's an interesting principal! Does that mean that nothing in config.toml should affect builds, or is it more subtle than that?</p>",
        "id": 251653202,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630545871
    },
    {
        "content": "<p>The intent is that the config files are specific to a user's environment.  Like, the proxy to access the network might be different for different users, so you probably don't want to commit that.  In practice, that doesn't always hold because some settings like <code>linker</code> might be <em>required</em> to cross-compile and by convention <em>everyone</em> uses the same linker by name like <code>arm-linux-gnueabihf-gcc</code>, so people do tend to commit config files with the linker setting.  (I think ideally it would be nice if that wasn't required.)</p>",
        "id": 251654095,
        "sender_full_name": "Eric Huss",
        "timestamp": 1630546745
    },
    {
        "content": "<p>It is an \"implicit principals\" so not precisely defined. And sometimes you have to compromise for other benefits. But cargo seems to have worked really hard to make the standard workflow for all rust projects:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">git</span><span class=\"w\"> </span><span class=\"n\">checkout</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"></span>\n<span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">cd</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"></span>\n<span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">cargo</span><span class=\"w\"> </span><span class=\"n\">build</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This was achieved by limiting the ability for <code>cargo build</code> to require a particular <code>.cargo/contig</code> or <code>ENV</code>s to work.</p>",
        "id": 251654762,
        "sender_full_name": "Eh2406",
        "timestamp": 1630547331
    },
    {
        "content": "<p>Eric has listed some of the existing exceptions.</p>",
        "id": 251654796,
        "sender_full_name": "Eh2406",
        "timestamp": 1630547387
    },
    {
        "content": "<p>IMO, one of the reasons I'm comfortable with patch-in-config now is that that pattern is so well established. That even though we have now given you a way to break it, it is not going to change the norm. Between that and it being a confluence of existing functionality and really wanting to support large build system, it seemed like a worthwhile trait off.</p>",
        "id": 251656145,
        "sender_full_name": "Eh2406",
        "timestamp": 1630548609
    },
    {
        "content": "<p>To try and think about features with overlap or potentially more general features, I was thinking about what 3074 is doing in more abstract terms. My model is that a dependency declaration is a mechanism for specifying the location of source code for a dep. Git and path are location literals. Version specs are input into a function (loosely, the version resolver) which produces a source location of a URL in a registry. One could think of multiple locations as a function which depends on the context to choose which location to use (where context here means just local vs on <a href=\"http://crates.io\">crates.io</a>). We might understand 3074 (or the env var proposal) as turning the path literal into a function (context, path, base) -&gt; location. Where context here comes from config.toml (or env vars).</p>",
        "id": 251660022,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552388
    },
    {
        "content": "<p>Under this model, it seems like we are definitely proposing something new, there is no other mechanism to abstract path specifications in this way</p>",
        "id": 251660048,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552433
    },
    {
        "content": "<p>I was thinking about if there are other possible inputs which we might like to use to customise the location</p>",
        "id": 251660139,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552518
    },
    {
        "content": "<p><code>registry</code> is an obvious analogue</p>",
        "id": 251660156,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552541
    },
    {
        "content": "<p>I wonder if it might be useful to have path change depending on features, but since these are boolean in nature, it seems not very useful</p>",
        "id": 251660249,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552630
    },
    {
        "content": "<p>one could consider the default base path (the location of Cargo.toml) as an input of this kind</p>",
        "id": 251660273,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552670
    },
    {
        "content": "<p>in which case specifying a path base is not adding a category of abstraction, it</p>",
        "id": 251660336,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552715
    },
    {
        "content": "<p>'s just extending the range of inputs</p>",
        "id": 251660342,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552726
    },
    {
        "content": "<p>(similar to how specifying the <code>registry</code> extends the range of registries beyond <a href=\"http://crates.io\">crates.io</a>)</p>",
        "id": 251660363,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630552763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> One other thing I'd love to feed in as an input: a mirror, from which cargo could obtain packages by hash, having gotten the hashes from a trusted source.</p>",
        "id": 251660382,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630552801
    },
    {
        "content": "<p>A mirror of a registry?</p>",
        "id": 251660827,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1630553224
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 251665376,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630557867
    }
]